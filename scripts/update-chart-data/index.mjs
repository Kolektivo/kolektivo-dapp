const l5 = "celo", c5 = 42220, d5 = {}, ND = {
  name: l5,
  chainId: c5,
  contracts: d5
}, DD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  chainId: c5,
  contracts: d5,
  default: ND,
  name: l5
}, Symbol.toStringTag, { value: "Module" })), f5 = "celo", p5 = "42220", h5 = {}, BD = {
  name: f5,
  chainId: p5,
  contracts: h5
}, FD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  chainId: p5,
  contracts: h5,
  default: BD,
  name: f5
}, Symbol.toStringTag, { value: "Module" })), y5 = "celo", m5 = "42220", b5 = {
  GeoNFT: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidIdentifier",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidLatitude",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidLongitude",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidTokenId",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "TokenModified",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "int32",
            name: "latitude",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "longitude",
            type: "int32"
          },
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "int32",
            name: "latitude",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "longitude",
            type: "int32"
          },
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "modify",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "tokenData",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "int32",
            name: "",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "",
            type: "int32"
          },
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  KolektivoMultiSig: {
    address: "0xcE960DcafC201a1B4440ed5F6B63A7772a34b2Ab"
  },
  Oracle: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "uint256",
            name: "reportExpirationTime_",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "reportDelay_",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumProviders_",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "invalidProvider",
            type: "address"
          }
        ],
        name: "Oracle__InvalidProvider",
        type: "error"
      },
      {
        inputs: [],
        name: "Oracle__NewReportTooSoonAfterPastReport",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldMinimumProviders",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newMinimumProviders",
            type: "uint256"
          }
        ],
        name: "MinimumProvidersChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [],
        name: "OracleMarkedAsInvalid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [],
        name: "OracleMarkedAsValid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          }
        ],
        name: "ProviderReportPushed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "purger",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderReportsPurged",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "addProvider",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getData",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "isValid",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "minimumProviders",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "providerReports",
        outputs: [
          {
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "providers",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "providersSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "purgeReports",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "purgeReportsFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          }
        ],
        name: "pushReport",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "removeProvider",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "reportDelay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "reportExpirationTime",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "isValid_",
            type: "bool"
          }
        ],
        name: "setIsValid",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "minimumProviders_",
            type: "uint256"
          }
        ],
        name: "setMinimumProviders",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Reserve: {
    address: "0xbFaf9774fcF4BE8B7372C92107F7035825c64503",
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "token_",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOracle_",
            type: "address"
          },
          {
            internalType: "address",
            name: "vestingVault_",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minBacking_",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20BalanceNotSufficient",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20BondingLimitExceeded",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotBondable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotRedeemable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotRegistered",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20RedeemLimitExceeded",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotBondable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotRedeemable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotRegistered",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidOracle",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__MinimumBackingLimitExceeded",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldBacking",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newBacking",
            type: "uint256"
          }
        ],
        name: "BackingUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sBonded",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensMinted",
            type: "uint256"
          }
        ],
        name: "BondedERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensMinted",
            type: "uint256"
          }
        ],
        name: "BondedERC721",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "DebtIncurred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "DebtPaid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20Deregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum IReserve.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            indexed: !1,
            internalType: "enum IReserve.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "ERC20Registered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDeregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sRedeemed",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensBurned",
            type: "uint256"
          }
        ],
        name: "RedeemedERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensBurned",
            type: "uint256"
          }
        ],
        name: "RedeemedERC721Id",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldDiscount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newDiscount",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingDiscount",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldtimeLockDuration",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newtimeLockDuration",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingTimeLock",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetERC20Oracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20RedeemLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldDiscount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newDiscount",
            type: "uint256"
          }
        ],
        name: "SetERC721IdBondingDiscount",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldtimeLockDuration",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newtimeLockDuration",
            type: "uint256"
          }
        ],
        name: "SetERC721IdBondingTimeLock",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetERC721IdOracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldMinBacking",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newMinBacking",
            type: "uint256"
          }
        ],
        name: "SetMinBacking",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "oldTimeLockVault",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newTimeLockVault",
            type: "address"
          }
        ],
        name: "SetTimeLockVault",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetTokenOracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sWithdrawn",
            type: "uint256"
          }
        ],
        name: "WithdrewERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "WithdrewERC721Id",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC20s",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC721Ids",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "erc721",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "id",
                type: "uint256"
              }
            ],
            internalType: "struct IReserve.ERC721Id[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "assetTypeOfERC20",
        outputs: [
          {
            internalType: "enum IReserve.AssetType",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "bondERC20All",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "bondERC20AllFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC20AllFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC20AllTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20From",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20FromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20To",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "bondERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "bondERC721IdFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC721IdFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC721IdTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingDiscountPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "bondingDiscountPerERC721Id",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingTimeLockDurationPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "bondingTimeLockDurationPerERC721Id",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "deregisterERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "deregisterERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "executeTx",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "incurDebt",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Bondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Redeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdBondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdRedeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "minBacking",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "oraclePerERC20",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "oraclePerERC721Id",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "payDebt",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "redeemERC20All",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "redeemERC20AllFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC20AllFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC20AllTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20From",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20FromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20To",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "redeemERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "redeemERC721IdFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC721IdFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC721IdTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "redeemLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "enum IReserve.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            internalType: "enum IReserve.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "registerERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "registerERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC20s",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC721Ids",
        outputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "reserveStatus",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "riskLevelOfERC20",
        outputs: [
          {
            internalType: "enum IReserve.RiskLevel",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          }
        ],
        name: "setBondingDiscountForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          }
        ],
        name: "setBondingDiscountForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "timeLockDuration",
            type: "uint256"
          }
        ],
        name: "setBondingTimeLockForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "timeLockDuration",
            type: "uint256"
          }
        ],
        name: "setBondingTimeLockForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20BondingLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20RedeemLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "minBacking_",
            type: "uint256"
          }
        ],
        name: "setMinBacking",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "timeLockVault_",
            type: "address"
          }
        ],
        name: "setTimeLockVault",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "tokenOracle_",
            type: "address"
          }
        ],
        name: "setTokenOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "timeLockDuration",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Bond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Redemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "timeLockDuration",
            type: "uint256"
          }
        ],
        name: "setupAndListERC721IdBond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "setupAndListERC721IdRedemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "timeLockVault",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "token",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tokenOracle",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateOracleForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateOracleForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "withdrawERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  CuracaoReserveToken: {
    address: "0x5532D39523124A8eE37493DB5F30Ccba0722Ac54",
    abi: [
      {
        inputs: [
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "ReserveToken__InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "ReserveToken__InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "ReserveToken__NotMintBurner",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "mintBurner",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "bool",
            name: "newStatus",
            type: "bool"
          }
        ],
        name: "UpdateMintBurner",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "mintBurner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            internalType: "bool",
            name: "status",
            type: "bool"
          }
        ],
        name: "setMintBurner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Treasury: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "MaxSupplyReached",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20BondingLimitExceeded",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotBondable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotRedeemable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotRegistered",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20RedeemLimitExceeded",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotBondable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotRedeemable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotRegistered",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "Treasury__StaleERC20PriceDeliveredByOracle",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "Treasury__StaleERC721IdPriceDeliveredByOracle",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20Deregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "ERC20OracleUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldPrice",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newPrice",
            type: "uint256"
          }
        ],
        name: "ERC20PriceUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum Treasury.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            indexed: !1,
            internalType: "enum Treasury.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "ERC20Registered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sWithdrawn",
            type: "uint256"
          }
        ],
        name: "ERC20Withdrawn",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsMinted",
            type: "uint256"
          }
        ],
        name: "ERC20sBonded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsBurned",
            type: "uint256"
          }
        ],
        name: "ERC20sRedeemed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDeregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "ERC721IdOracleUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldPrice",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newPrice",
            type: "uint256"
          }
        ],
        name: "ERC721IdPriceUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "ERC721IdRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "ERC721IdWithdrawn",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsMinted",
            type: "uint256"
          }
        ],
        name: "ERC721IdsBonded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsBurned",
            type: "uint256"
          }
        ],
        name: "ERC721IdsRedeemed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "uint256",
            name: "epoch",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newScalar",
            type: "uint256"
          }
        ],
        name: "Rebase",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20RedeemLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "EIP712_DOMAIN",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "EIP712_REVISION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PERMIT_TYPEHASH",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC20s",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC721Ids",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "erc721",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "id",
                type: "uint256"
              }
            ],
            internalType: "struct Treasury.ERC721Id[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner_",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "assetTypeOfERC20",
        outputs: [
          {
            internalType: "enum Treasury.AssetType",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "bondERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "bondERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "deregisterERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "deregisterERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "executeTx",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Bondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Redeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdBondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdRedeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "lastRebase",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "oraclePerERC20",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "oraclePerERC721Id",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "rebase",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "kttWad",
            type: "uint256"
          }
        ],
        name: "redeemERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "redeemERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "redeemLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "enum Treasury.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            internalType: "enum Treasury.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "registerERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "registerERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC20s",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC721Ids",
        outputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "riskLevelOfERC20",
        outputs: [
          {
            internalType: "enum Treasury.RiskLevel",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "scaledBalanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "scaledTotalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20BondingLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20RedeemLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Bond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Redemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalValuation",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "transferAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "transferAllFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateERC20Oracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateERC721IdOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "withdrawERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "Kolektivo Treasury Token": {
    address: "0x0000000000000000000000000000000000000000",
    abi: "ERC20"
  },
  Exchange: {
    address: "0x447F9cabb56855eD0725FC20214eE2565ece6f3e",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "goldBucket",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "stableBucket",
            type: "uint256"
          }
        ],
        name: "BucketsUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchanger",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "bool",
            name: "soldGold",
            type: "bool"
          }
        ],
        name: "Exchanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "minimumReports",
            type: "uint256"
          }
        ],
        name: "MinimumReportsSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "reserveFraction",
            type: "uint256"
          }
        ],
        name: "ReserveFractionSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "spread",
            type: "uint256"
          }
        ],
        name: "SpreadSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "stable",
            type: "address"
          }
        ],
        name: "StableTokenSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "updateFrequency",
            type: "uint256"
          }
        ],
        name: "UpdateFrequencySet",
        type: "event"
      },
      {
        inputs: [],
        name: "activateStable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxSellAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "buyGold",
            type: "bool"
          }
        ],
        name: "buy",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minBuyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "exchange",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getBuyAndSellBuckets",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getBuyTokenAmount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getSellTokenAmount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "goldBucket",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "string",
            name: "stableTokenIdentifier",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "_spread",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_reserveFraction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_updateFrequency",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_minimumReports",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "lastBucketUpdate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "minimumReports",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "reserveFraction",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minBuyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "sell",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newMininumReports",
            type: "uint256"
          }
        ],
        name: "setMinimumReports",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newReserveFraction",
            type: "uint256"
          }
        ],
        name: "setReserveFraction",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newSpread",
            type: "uint256"
          }
        ],
        name: "setSpread",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newStableToken",
            type: "address"
          }
        ],
        name: "setStableToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newUpdateFrequency",
            type: "uint256"
          }
        ],
        name: "setUpdateFrequency",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "spread",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "stable",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "stableBucket",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "stableTokenRegistryId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "updateFrequency",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  MentoReserve: {
    address: "0x4c21e92FAa09CF6CC6587C0480f464012820E60d",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bytes32[]",
            name: "symbols",
            type: "bytes32[]"
          },
          {
            indexed: !1,
            internalType: "uint256[]",
            name: "weights",
            type: "uint256[]"
          }
        ],
        name: "AssetAllocationSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "ratio",
            type: "uint256"
          }
        ],
        name: "DailySpendingRatioSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchangeSpender",
            type: "address"
          }
        ],
        name: "ExchangeSpenderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchangeSpender",
            type: "address"
          }
        ],
        name: "ExchangeSpenderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "otherReserveAddress",
            type: "address"
          }
        ],
        name: "OtherReserveAddressAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "otherReserveAddress",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "OtherReserveAddressRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "ReserveGoldTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "SpenderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "SpenderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxReserveRatioSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxStalenessThresholdSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "TokenAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "TokenRemoved",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "addExchangeSpender",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "reserveAddress",
            type: "address"
          }
        ],
        name: "addOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "addSpender",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "addToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "assetAllocationSymbols",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "assetAllocationWeights",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "exchangeSpenderAddresses",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "frozenReserveGoldDays",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "frozenReserveGoldStartBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "frozenReserveGoldStartDay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAssetAllocationSymbols",
        outputs: [
          {
            internalType: "bytes32[]",
            name: "",
            type: "bytes32[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAssetAllocationWeights",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDailySpendingRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getExchangeSpenders",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getFrozenReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOrComputeTobinTax",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getOtherReserveAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOtherReserveAddressesGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getReserveRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTokens",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getUnfrozenBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getUnfrozenReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_tobinTaxStalenessThreshold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_spendingRatio",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_frozenGold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_frozenDays",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "_assetAllocationSymbols",
            type: "bytes32[]"
          },
          {
            internalType: "uint256[]",
            name: "_assetAllocationWeights",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "_tobinTax",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_tobinTaxReserveRatio",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isExchangeSpender",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isSpender",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "lastSpendingDay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "otherReserveAddresses",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeExchangeSpender",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "reserveAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "removeSpender",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32[]",
            name: "symbols",
            type: "bytes32[]"
          },
          {
            internalType: "uint256[]",
            name: "weights",
            type: "uint256[]"
          }
        ],
        name: "setAssetAllocations",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "ratio",
            type: "uint256"
          }
        ],
        name: "setDailySpendingRatio",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "frozenGold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "frozenDays",
            type: "uint256"
          }
        ],
        name: "setFrozenGold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_reserveToken",
            type: "address"
          }
        ],
        name: "setReserveToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTax",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTaxReserveRatio",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTaxStalenessThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "spendingLimit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tobinTax",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tobinTaxCache",
        outputs: [
          {
            internalType: "uint128",
            name: "numerator",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "timestamp",
            type: "uint128"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tobinTaxReserveRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tobinTaxStalenessThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferExchangeGold",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferGold",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "kGuilder Pool": {
    address: "0xE62A9b63f1d85cD072b792E51e9e18ec9cf26285",
    abi: [
      {
        inputs: [
          {
            internalType: "contract IVault",
            name: "vault",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "amplificationParameter",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pauseWindowDuration",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodDuration",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "startValue",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "endValue",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "startTime",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          }
        ],
        name: "AmpUpdateStarted",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "currentValue",
            type: "uint256"
          }
        ],
        name: "AmpUpdateStopped",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "PausedStateChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "SwapFeePercentageChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "selector",
            type: "bytes4"
          }
        ],
        name: "getActionId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAmplificationParameter",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isUpdating",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "precision",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAuthorizer",
        outputs: [
          {
            internalType: "contract IAuthorizer",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getLastInvariant",
        outputs: [
          {
            internalType: "uint256",
            name: "lastInvariant",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "lastInvariantAmp",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPausedState",
        outputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "pauseWindowEndTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodEndTime",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPoolId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getRate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getScalingFactors",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getSwapFeePercentage",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVault",
        outputs: [
          {
            internalType: "contract IVault",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "addedValue",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onExitPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onJoinPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IERC20",
                name: "tokenIn",
                type: "address"
              },
              {
                internalType: "contract IERC20",
                name: "tokenOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "lastChangeBlock",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "from",
                type: "address"
              },
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IPoolSwapStructs.SwapRequest",
            name: "swapRequest",
            type: "tuple"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "indexIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "indexOut",
            type: "uint256"
          }
        ],
        name: "onSwap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IERC20",
                name: "tokenIn",
                type: "address"
              },
              {
                internalType: "contract IERC20",
                name: "tokenOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "lastChangeBlock",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "from",
                type: "address"
              },
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IPoolSwapStructs.SwapRequest",
            name: "request",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "balanceTokenIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "balanceTokenOut",
            type: "uint256"
          }
        ],
        name: "onSwap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryExit",
        outputs: [
          {
            internalType: "uint256",
            name: "bptIn",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsOut",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryJoin",
        outputs: [
          {
            internalType: "uint256",
            name: "bptOut",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsIn",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "poolConfig",
            type: "bytes"
          }
        ],
        name: "setAssetManagerPoolConfig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "setPaused",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "setSwapFeePercentage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "rawEndValue",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          }
        ],
        name: "startAmplificationParameterUpdate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "stopAmplificationParameterUpdate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "kCur Pool": {
    address: "0xE33787c1557eBEF5DE0b4ee14bE72d5b4D8995C4",
    abi: [
      {
        inputs: [
          {
            internalType: "contract IVault",
            name: "vault",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "normalizedWeights",
            type: "uint256[]"
          },
          {
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pauseWindowDuration",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodDuration",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "PausedStateChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "SwapFeePercentageChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "selector",
            type: "bytes4"
          }
        ],
        name: "getActionId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAuthorizer",
        outputs: [
          {
            internalType: "contract IAuthorizer",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getInvariant",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getLastInvariant",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getNormalizedWeights",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPausedState",
        outputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "pauseWindowEndTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodEndTime",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPoolId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getRate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getScalingFactors",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getSwapFeePercentage",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVault",
        outputs: [
          {
            internalType: "contract IVault",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "addedValue",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onExitPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onJoinPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IERC20",
                name: "tokenIn",
                type: "address"
              },
              {
                internalType: "contract IERC20",
                name: "tokenOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "lastChangeBlock",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "from",
                type: "address"
              },
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IPoolSwapStructs.SwapRequest",
            name: "request",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "balanceTokenIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "balanceTokenOut",
            type: "uint256"
          }
        ],
        name: "onSwap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryExit",
        outputs: [
          {
            internalType: "uint256",
            name: "bptIn",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsOut",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryJoin",
        outputs: [
          {
            internalType: "uint256",
            name: "bptOut",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsIn",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "poolConfig",
            type: "bytes"
          }
        ],
        name: "setAssetManagerPoolConfig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "setPaused",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "setSwapFeePercentage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  TimeLockVault: {
    address: "0xe2DFdF6c1EE6b2D2CD856638343Ba0F94e2a3b09",
    abi: [
      {
        inputs: [],
        name: "InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidDuration",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "SenderCantLock",
        type: "error"
      },
      {
        inputs: [],
        name: "UserHasNoLocks",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Claimed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "unlockAt",
            type: "uint256"
          }
        ],
        name: "Locked",
        type: "event"
      },
      {
        inputs: [],
        name: "claim",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "claimAt",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "claimToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          }
        ],
        name: "getLocksOf",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "token",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unlockAt",
                type: "uint256"
              }
            ],
            internalType: "struct TimeLockVault.Lock[]",
            name: "locks",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "locker",
            type: "address"
          }
        ],
        name: "isLocker",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "duration",
            type: "uint256"
          }
        ],
        name: "lock",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  SortedOracles: {
    address: "0x5eCaA606ed02D5fb541a5A107Ae288d8a8993469",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "newBreakerBox",
            type: "address"
          }
        ],
        name: "BreakerBoxUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "MedianUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracleAddress",
            type: "address"
          }
        ],
        name: "OracleAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracleAddress",
            type: "address"
          }
        ],
        name: "OracleRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "OracleReportRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "OracleReported",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "reportExpiry",
            type: "uint256"
          }
        ],
        name: "ReportExpirySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "reportExpiry",
            type: "uint256"
          }
        ],
        name: "TokenReportExpirySet",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracleAddress",
            type: "address"
          }
        ],
        name: "addOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "breakerBox",
        outputs: [
          {
            internalType: "contract IBreakerBox",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "getOracles",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "getRates",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "enum SortedLinkedListWithMedian.MedianRelation[]",
            name: "",
            type: "uint8[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "getTimestamps",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "enum SortedLinkedListWithMedian.MedianRelation[]",
            name: "",
            type: "uint8[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "getTokenReportExpirySeconds",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_reportExpirySeconds",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "isOldestReportExpired",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isOracle",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "medianRate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "medianTimestamp",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "numRates",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "numTimestamps",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "oracles",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "n",
            type: "uint256"
          }
        ],
        name: "removeExpiredReports",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracleAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "lesserKey",
            type: "address"
          },
          {
            internalType: "address",
            name: "greaterKey",
            type: "address"
          }
        ],
        name: "report",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "reportExpirySeconds",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IBreakerBox",
            name: "newBreakerBox",
            type: "address"
          }
        ],
        name: "setBreakerBox",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_reportExpirySeconds",
            type: "uint256"
          }
        ],
        name: "setReportExpiry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_reportExpirySeconds",
            type: "uint256"
          }
        ],
        name: "setTokenReportExpiry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "tokenReportExpirySeconds",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  BAC: {
    address: "0xc9Ad7747E66DcA343618995B9ee3d96844503c6D",
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "_owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "_avatar",
            type: "address"
          },
          {
            internalType: "address",
            name: "_target",
            type: "address"
          },
          {
            internalType: "address",
            name: "_badger",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "ArraysDifferentLength",
        type: "error"
      },
      {
        inputs: [],
        name: "ModuleTransactionFailed",
        type: "error"
      },
      {
        inputs: [],
        name: "NoMembership",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "guard_",
            type: "address"
          }
        ],
        name: "NotIERC165Compliant",
        type: "error"
      },
      {
        inputs: [],
        name: "RedundantUpdateOfState",
        type: "error"
      },
      {
        inputs: [],
        name: "SetUpModulesAlreadyCalled",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousAvatar",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newAvatar",
            type: "address"
          }
        ],
        name: "AvatarSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "badgerAddress",
            type: "address"
          }
        ],
        name: "BadgerUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "guard",
            type: "address"
          }
        ],
        name: "ChangedGuard",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "initiator",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "avatar",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "target",
            type: "address"
          }
        ],
        name: "RolesModSetup",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "multisendAddress",
            type: "address"
          }
        ],
        name: "SetMultisendAddress",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousTarget",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newTarget",
            type: "address"
          }
        ],
        name: "TargetSet",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "targetAddress",
            type: "address"
          },
          {
            internalType: "enum ExecutionOptions",
            name: "options",
            type: "uint8"
          }
        ],
        name: "allowTarget",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "avatar",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "badger",
        outputs: [
          {
            internalType: "contract IBadger",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          }
        ],
        name: "execTransactionFromModule",
        outputs: [
          {
            internalType: "bool",
            name: "success",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          },
          {
            internalType: "enum Enum.Operation",
            name: "operation",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          }
        ],
        name: "execTransactionFromModuleReturnData",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getGuard",
        outputs: [
          {
            internalType: "address",
            name: "_guard",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "guard",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "multisend",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "targetAddress",
            type: "address"
          }
        ],
        name: "revokeTarget",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "targetAddress",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "functionSig",
            type: "bytes4"
          },
          {
            internalType: "enum ExecutionOptions",
            name: "options",
            type: "uint8"
          }
        ],
        name: "scopeAllowFunction",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "targetAddress",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "functionSig",
            type: "bytes4"
          },
          {
            internalType: "bool[]",
            name: "isParamScoped",
            type: "bool[]"
          },
          {
            internalType: "enum ParameterType[]",
            name: "paramType",
            type: "uint8[]"
          },
          {
            internalType: "enum Comparison[]",
            name: "paramComp",
            type: "uint8[]"
          },
          {
            internalType: "bytes[]",
            name: "compValue",
            type: "bytes[]"
          },
          {
            internalType: "enum ExecutionOptions",
            name: "options",
            type: "uint8"
          }
        ],
        name: "scopeFunction",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "targetAddress",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "functionSig",
            type: "bytes4"
          },
          {
            internalType: "enum ExecutionOptions",
            name: "options",
            type: "uint8"
          }
        ],
        name: "scopeFunctionExecutionOptions",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "targetAddress",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "functionSig",
            type: "bytes4"
          },
          {
            internalType: "uint256",
            name: "paramIndex",
            type: "uint256"
          },
          {
            internalType: "enum ParameterType",
            name: "paramType",
            type: "uint8"
          },
          {
            internalType: "enum Comparison",
            name: "paramComp",
            type: "uint8"
          },
          {
            internalType: "bytes",
            name: "compValue",
            type: "bytes"
          }
        ],
        name: "scopeParameter",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "targetAddress",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "functionSig",
            type: "bytes4"
          },
          {
            internalType: "uint256",
            name: "paramIndex",
            type: "uint256"
          },
          {
            internalType: "enum ParameterType",
            name: "paramType",
            type: "uint8"
          },
          {
            internalType: "bytes[]",
            name: "compValues",
            type: "bytes[]"
          }
        ],
        name: "scopeParameterAsOneOf",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "targetAddress",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "functionSig",
            type: "bytes4"
          }
        ],
        name: "scopeRevokeFunction",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "targetAddress",
            type: "address"
          }
        ],
        name: "scopeTarget",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_avatar",
            type: "address"
          }
        ],
        name: "setAvatar",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_guard",
            type: "address"
          }
        ],
        name: "setGuard",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_multisend",
            type: "address"
          }
        ],
        name: "setMultisend",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_target",
            type: "address"
          }
        ],
        name: "setTarget",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "initParams",
            type: "bytes"
          }
        ],
        name: "setUp",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "target",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "badgeId",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "targetAddress",
            type: "address"
          },
          {
            internalType: "bytes4",
            name: "functionSig",
            type: "bytes4"
          },
          {
            internalType: "uint8",
            name: "paramIndex",
            type: "uint8"
          }
        ],
        name: "unscopeParameter",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_newBadger",
            type: "address"
          }
        ],
        name: "updateBadger",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  KolektivoGuilder: {
    address: "0x391B047a8dde3fa4A13B0d45CcA76f2F4e0A5230",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bytes32",
            name: "oldId",
            type: "bytes32"
          },
          {
            indexed: !1,
            internalType: "bytes32",
            name: "newId",
            type: "bytes32"
          }
        ],
        name: "ExchangeIdentifierUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "factor",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "lastUpdated",
            type: "uint256"
          }
        ],
        name: "InflationFactorUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "rate",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "updatePeriod",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "lastUpdated",
            type: "uint256"
          }
        ],
        name: "InflationParametersUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "string",
            name: "comment",
            type: "string"
          }
        ],
        name: "TransferComment",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "accountOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "accountOwner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "blsKey",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "blsPop",
            type: "bytes"
          }
        ],
        name: "checkProofOfPossession",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "feeRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "gatewayFeeRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "communityFund",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "refund",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tipTxFee",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gatewayFee",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseTxFee",
            type: "uint256"
          }
        ],
        name: "creditGasFees",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "debitGasFees",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "aNumerator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "aDenominator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bNumerator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bDenominator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "exponent",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_decimals",
            type: "uint256"
          }
        ],
        name: "fractionMulExp",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "getBlockNumberFromHeader",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getEpochNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getEpochNumberOfBlock",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getEpochSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getExchangeRegistryId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getInflationParameters",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getParentSealBitmap",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "getVerifiedSealBitmapFromHeader",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "hashHeader",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "uint8",
            name: "_decimals",
            type: "uint8"
          },
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "inflationRate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "inflationFactorUpdatePeriod",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "exchangeIdentifier",
            type: "string"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "minQuorumSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "minQuorumSizeInCurrentSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "mint",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "numberValidatorsInCurrentSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "numberValidatorsInSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "exchangeIdentifier",
            type: "string"
          }
        ],
        name: "setExchangeRegistryId",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "rate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "updatePeriod",
            type: "uint256"
          }
        ],
        name: "setInflationParameters",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "comment",
            type: "string"
          }
        ],
        name: "transferWithComment",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "units",
            type: "uint256"
          }
        ],
        name: "unitsToValue",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "validatorSignerAddressFromCurrentSet",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "validatorSignerAddressFromSet",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "valueToUnits",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  Vault: {
    address: "0xD25E02047E76b688445ab154785F2642c6fe3f73",
    abi: [
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "liquidityProvider",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            indexed: !1,
            internalType: "int256[]",
            name: "deltas",
            type: "int256[]"
          },
          {
            indexed: !1,
            internalType: "uint256[]",
            name: "protocolFeeAmounts",
            type: "uint256[]"
          }
        ],
        name: "PoolBalanceChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "assetManager",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "int256",
            name: "cashDelta",
            type: "int256"
          },
          {
            indexed: !1,
            internalType: "int256",
            name: "managedDelta",
            type: "int256"
          }
        ],
        name: "PoolBalanceManaged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "poolAddress",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum IVault.PoolSpecialization",
            name: "specialization",
            type: "uint8"
          }
        ],
        name: "PoolRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
          }
        ],
        name: "Swap",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !1,
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          }
        ],
        name: "TokensDeregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !1,
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            indexed: !1,
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          }
        ],
        name: "TokensRegistered",
        type: "event"
      },
      {
        inputs: [],
        name: "WETH",
        outputs: [
          {
            internalType: "contract IWETH",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "assetInIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "assetOutIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.BatchSwapStep[]",
            name: "swaps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          },
          {
            internalType: "int256[]",
            name: "limits",
            type: "int256[]"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        name: "batchSwap",
        outputs: [
          {
            internalType: "int256[]",
            name: "",
            type: "int256[]"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          }
        ],
        name: "deregisterTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            components: [
              {
                internalType: "contract IAsset[]",
                name: "assets",
                type: "address[]"
              },
              {
                internalType: "uint256[]",
                name: "minAmountsOut",
                type: "uint256[]"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.ExitPoolRequest",
            name: "request",
            type: "tuple"
          }
        ],
        name: "exitPool",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          }
        ],
        name: "getPool",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "enum IVault.PoolSpecialization",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          }
        ],
        name: "getPoolTokenInfo",
        outputs: [
          {
            internalType: "uint256",
            name: "cash",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "managed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "assetManager",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          }
        ],
        name: "getPoolTokens",
        outputs: [
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            components: [
              {
                internalType: "contract IAsset[]",
                name: "assets",
                type: "address[]"
              },
              {
                internalType: "uint256[]",
                name: "maxAmountsIn",
                type: "uint256[]"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.JoinPoolRequest",
            name: "request",
            type: "tuple"
          }
        ],
        name: "joinPool",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.PoolBalanceOpKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "contract IERC20",
                name: "token",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              }
            ],
            internalType: "struct IVault.PoolBalanceOp[]",
            name: "ops",
            type: "tuple[]"
          }
        ],
        name: "managePoolBalance",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "assetInIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "assetOutIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.BatchSwapStep[]",
            name: "swaps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          }
        ],
        name: "queryBatchSwap",
        outputs: [
          {
            internalType: "int256[]",
            name: "assetDeltas",
            type: "int256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IVault.PoolSpecialization",
            name: "specialization",
            type: "uint8"
          }
        ],
        name: "registerPool",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          }
        ],
        name: "registerTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IAsset",
                name: "assetIn",
                type: "address"
              },
              {
                internalType: "contract IAsset",
                name: "assetOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.SingleSwap",
            name: "singleSwap",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        name: "swap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      }
    ]
  },
  MentoRegistry: {
    address: "0x9C466172eF3Ea77D439deBc4998F706708746C6f",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "string",
            name: "identifier",
            type: "string"
          },
          {
            indexed: !0,
            internalType: "bytes32",
            name: "identifierHash",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "addr",
            type: "address"
          }
        ],
        name: "RegistryUpdated",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "identifierHash",
            type: "bytes32"
          }
        ],
        name: "getAddressFor",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "identifierHash",
            type: "bytes32"
          }
        ],
        name: "getAddressForOrDie",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "getAddressForString",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "getAddressForStringOrDie",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32[]",
            name: "identifierHashes",
            type: "bytes32[]"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "isOneOf",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "registry",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          },
          {
            internalType: "address",
            name: "addr",
            type: "address"
          }
        ],
        name: "setAddressFor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Freezer: {
    address: "0x201AbB71C320915EFDdd0dAB95D4E77f1f36B830",
    abi: [
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  ProxyPool: {
    address: "0x2BdE6D6d622226b48A0d9F9066A0a3e38158FCD4",
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "pairToken_",
            type: "address"
          },
          {
            internalType: "address",
            name: "vault_",
            type: "address"
          },
          {
            internalType: "address",
            name: "reserve_",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "ceilingMultiplier_",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "ceilingTradeShare_",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "floorTradeShare_",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "Paused",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "Unpaused",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "assetInIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "assetOutIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.BatchSwapStep[]",
            name: "swaps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "totalAmountIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minTotalAmountOut",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          },
          {
            internalType: "int256[]",
            name: "limits",
            type: "int256[]"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        name: "batchSwapExactIn",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "assetInIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "assetOutIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.BatchSwapStep[]",
            name: "swaps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "maxTotalAmountIn",
            type: "uint256"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          },
          {
            internalType: "int256[]",
            name: "limits",
            type: "int256[]"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        name: "batchSwapExactOut",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [],
        name: "ceilingMultiplier",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "ceilingTradeShare",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "floorTradeShare",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "inBalanceAfter",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "inBalanceBefore",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "outBalanceAfter",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "outBalanceBefore",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pairToken",
        outputs: [
          {
            internalType: "contract ERC20",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "paused",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "reserve",
        outputs: [
          {
            internalType: "contract IReserve",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "reserveToken",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "unpause",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "vault",
        outputs: [
          {
            internalType: "contract IVault",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  Badger: {
    address: "0xC5d799c3Efbca27195cE7dEEe1590546cfE1e508",
    abi: [
      {
        inputs: [
          {
            internalType: "string",
            name: "_baseUri",
            type: "string"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "TransferDisabled",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "string",
            name: "uri",
            type: "string"
          }
        ],
        name: "TokenUriUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          },
          {
            indexed: !1,
            internalType: "uint256[]",
            name: "values",
            type: "uint256[]"
          }
        ],
        name: "TransferBatch",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TransferSingle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "string",
            name: "value",
            type: "string"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "URI",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "accounts",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          }
        ],
        name: "balanceOfBatch",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "accounts",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "tokenIds",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
          }
        ],
        name: "burnFromMultiple",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "address",
            name: "operator",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address[]",
            name: "accounts",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "tokenIds",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
          }
        ],
        name: "mintToMultiple",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeBatchTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "baseUri",
            type: "string"
          }
        ],
        name: "setBaseUri",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "newUri",
            type: "string"
          }
        ],
        name: "setUri",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "tokenUris",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256"
          }
        ],
        name: "uri",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  cUSD: {
    address: "0x765DE816845861e75A25fCA122bb6898B8B1282a",
    abi: "ERC20"
  }
}, LD = {
  name: y5,
  chainId: m5,
  contracts: b5
}, $D = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  chainId: m5,
  contracts: b5,
  default: LD,
  name: y5
}, Symbol.toStringTag, { value: "Module" })), g5 = [
  {
    inputs: [
      {
        internalType: "string",
        name: "_baseUri",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "TransferDisabled",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "TokenUriUpdated",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: !1,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      }
    ],
    name: "burnFromMultiple",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      }
    ],
    name: "mintToMultiple",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "baseUri",
        type: "string"
      }
    ],
    name: "setBaseUri",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "newUri",
        type: "string"
      }
    ],
    name: "setUri",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "tokenUris",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], x5 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      },
      {
        internalType: "address",
        name: "_target",
        type: "address"
      },
      {
        internalType: "address",
        name: "_badger",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "ArraysDifferentLength",
    type: "error"
  },
  {
    inputs: [],
    name: "ModuleTransactionFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "NoMembership",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guard_",
        type: "address"
      }
    ],
    name: "NotIERC165Compliant",
    type: "error"
  },
  {
    inputs: [],
    name: "RedundantUpdateOfState",
    type: "error"
  },
  {
    inputs: [],
    name: "SetUpModulesAlreadyCalled",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousAvatar",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newAvatar",
        type: "address"
      }
    ],
    name: "AvatarSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "badgerAddress",
        type: "address"
      }
    ],
    name: "BadgerUpdated",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "guard",
        type: "address"
      }
    ],
    name: "ChangedGuard",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "avatar",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "RolesModSetup",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "multisendAddress",
        type: "address"
      }
    ],
    name: "SetMultisendAddress",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousTarget",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newTarget",
        type: "address"
      }
    ],
    name: "TargetSet",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "allowTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "avatar",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "badger",
    outputs: [
      {
        internalType: "contract IBadger",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      }
    ],
    name: "execTransactionFromModule",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      }
    ],
    name: "execTransactionFromModuleReturnData",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getGuard",
    outputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "guard",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "multisend",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      }
    ],
    name: "revokeTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "scopeAllowFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "bool[]",
        name: "isParamScoped",
        type: "bool[]"
      },
      {
        internalType: "enum ParameterType[]",
        name: "paramType",
        type: "uint8[]"
      },
      {
        internalType: "enum Comparison[]",
        name: "paramComp",
        type: "uint8[]"
      },
      {
        internalType: "bytes[]",
        name: "compValue",
        type: "bytes[]"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "scopeFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "scopeFunctionExecutionOptions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "uint256",
        name: "paramIndex",
        type: "uint256"
      },
      {
        internalType: "enum ParameterType",
        name: "paramType",
        type: "uint8"
      },
      {
        internalType: "enum Comparison",
        name: "paramComp",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "compValue",
        type: "bytes"
      }
    ],
    name: "scopeParameter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "uint256",
        name: "paramIndex",
        type: "uint256"
      },
      {
        internalType: "enum ParameterType",
        name: "paramType",
        type: "uint8"
      },
      {
        internalType: "bytes[]",
        name: "compValues",
        type: "bytes[]"
      }
    ],
    name: "scopeParameterAsOneOf",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      }
    ],
    name: "scopeRevokeFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      }
    ],
    name: "scopeTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      }
    ],
    name: "setAvatar",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    name: "setGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_multisend",
        type: "address"
      }
    ],
    name: "setMultisend",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_target",
        type: "address"
      }
    ],
    name: "setTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initParams",
        type: "bytes"
      }
    ],
    name: "setUp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "target",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "uint8",
        name: "paramIndex",
        type: "uint8"
      }
    ],
    name: "unscopeParameter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newBadger",
        type: "address"
      }
    ],
    name: "updateBadger",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], v5 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ScopeGuardSetup",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetDelegateCallAllowedOnTarget",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetFallbackAllowedOnTarget",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetFunctionAllowedOnTarget",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetTargetAllowed",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "scoped",
        type: "bool"
      }
    ],
    name: "SetTargetScoped",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetValueAllowedOnTarget",
    type: "event"
  },
  {
    stateMutability: "nonpayable",
    type: "fallback"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "allowedTargets",
    outputs: [
      {
        internalType: "bool",
        name: "allowed",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "scoped",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "delegateCallAllowed",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "fallbackAllowed",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "valueAllowed",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    name: "checkAfterExecution",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address payable",
        name: "",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "checkTransaction",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      }
    ],
    name: "isAllowedFunction",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isAllowedTarget",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isAllowedToDelegateCall",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isScoped",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isValueAllowed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isfallbackAllowed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setAllowedFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setDelegateCallAllowedOnTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setFallbackAllowedOnTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "scoped",
        type: "bool"
      }
    ],
    name: "setScoped",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setTargetAllowed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initializeParams",
        type: "bytes"
      }
    ],
    name: "setUp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setValueAllowedOnTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], w5 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      },
      {
        internalType: "address",
        name: "_target",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_cooldown",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_expiration",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "AlreadyDisabledModule",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "AlreadyEnabledModule",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "InvalidModule",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "NotAuthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guard_",
        type: "address"
      }
    ],
    name: "NotIERC165Compliant",
    type: "error"
  },
  {
    inputs: [],
    name: "RedundantUpdateOfState",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousAvatar",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newAvatar",
        type: "address"
      }
    ],
    name: "AvatarSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "guard",
        type: "address"
      }
    ],
    name: "ChangedGuard",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "avatar",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "DelaySetup",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "DisabledModule",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "EnabledModule",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "ExecutionFromModuleFailure",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "ExecutionFromModuleSuccess",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "queueIndex",
        type: "uint256"
      },
      {
        indexed: !0,
        internalType: "bytes32",
        name: "txHash",
        type: "bytes32"
      },
      {
        indexed: !1,
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "salt",
        type: "uint256"
      }
    ],
    name: "SecretTransactionAdded",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        indexed: !1,
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "_salt",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "txIndex",
        type: "uint256"
      }
    ],
    name: "SecretTransactionExecuted",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousTarget",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newTarget",
        type: "address"
      }
    ],
    name: "TargetSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "queueIndex",
        type: "uint256"
      },
      {
        indexed: !0,
        internalType: "bytes32",
        name: "txHash",
        type: "bytes32"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        indexed: !1,
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "TransactionAdded",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        indexed: !1,
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "txIndex",
        type: "uint256"
      }
    ],
    name: "TransactionExecuted",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "startingApprovedTrxNonce",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "numberOfTrxApproved",
        type: "uint256"
      }
    ],
    name: "TransactionsApproved",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "startingVetoedTrxNonce",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "numberOfTrxVetoed",
        type: "uint256"
      }
    ],
    name: "TransactionsVetoed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_transactions",
        type: "uint256"
      }
    ],
    name: "approveNext",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "approved",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "avatar",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "prevModule",
        type: "address"
      },
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "disableModule",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "enableModule",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "hashedTransaction",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "enqueueSecretTx",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "execTransactionFromModule",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "execTransactionFromModuleReturnData",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "returnData",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "_salt",
        type: "uint256"
      }
    ],
    name: "executeNextSecretTx",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "executeNextTx",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getGuard",
    outputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "start",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pageSize",
        type: "uint256"
      }
    ],
    name: "getModulesPaginated",
    outputs: [
      {
        internalType: "address[]",
        name: "array",
        type: "address[]"
      },
      {
        internalType: "address",
        name: "next",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "_salt",
        type: "uint256"
      }
    ],
    name: "getSecretTransactionHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "getTransactionHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_nonce",
        type: "uint256"
      }
    ],
    name: "getTxCreatedAt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_nonce",
        type: "uint256"
      }
    ],
    name: "getTxHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "guard",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_module",
        type: "address"
      }
    ],
    name: "isModuleEnabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "queuePointer",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "salt",
    outputs: [
      {
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      }
    ],
    name: "setAvatar",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    name: "setGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_target",
        type: "address"
      }
    ],
    name: "setTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "cooldown",
        type: "uint256"
      }
    ],
    name: "setTxCooldown",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "expiration",
        type: "uint256"
      }
    ],
    name: "setTxExpiration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initParams",
        type: "bytes"
      }
    ],
    name: "setUp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "skipExpired",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "target",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "txCooldown",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "txCreatedAt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "txExpiration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "txHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "txNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_newTxNonce",
        type: "uint256"
      }
    ],
    name: "vetoTransactionsTill",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_newTxNonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_transactions",
        type: "uint256"
      }
    ],
    name: "vetoTransactionsTillAndApprove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], UD = {
  Badger: g5,
  BACRoles: x5,
  ScopeGuard: v5,
  SecretDelay: w5
}, jD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BACRoles: x5,
  Badger: g5,
  ScopeGuard: v5,
  SecretDelay: w5,
  default: UD
}, Symbol.toStringTag, { value: "Module" })), VD = {}, zD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: VD
}, Symbol.toStringTag, { value: "Module" })), T5 = [
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
], A5 = [
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], GD = {
  ERC20: T5,
  ERC721: A5
}, HD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ERC20: T5,
  ERC721: A5,
  default: GD
}, Symbol.toStringTag, { value: "Module" }));
var qD = E5, W2 = 128, WD = 127, KD = ~WD, JD = Math.pow(2, 31);
function E5(n, e, t) {
  e = e || [], t = t || 0;
  for (var r = t; n >= JD; )
    e[t++] = n & 255 | W2, n /= 128;
  for (; n & KD; )
    e[t++] = n & 255 | W2, n >>>= 7;
  return e[t] = n | 0, E5.bytes = t - r + 1, e;
}
var QD = o0, YD = 128, K2 = 127;
function o0(n, r) {
  var t = 0, r = r || 0, i = 0, s = r, a, o = n.length;
  do {
    if (s >= o)
      throw o0.bytes = 0, new RangeError("Could not decode varint");
    a = n[s++], t += i < 28 ? (a & K2) << i : (a & K2) * Math.pow(2, i), i += 7;
  } while (a >= YD);
  return o0.bytes = s - r, t;
}
var XD = Math.pow(2, 7), ZD = Math.pow(2, 14), eB = Math.pow(2, 21), tB = Math.pow(2, 28), nB = Math.pow(2, 35), rB = Math.pow(2, 42), iB = Math.pow(2, 49), sB = Math.pow(2, 56), aB = Math.pow(2, 63), oB = function(n) {
  return n < XD ? 1 : n < ZD ? 2 : n < eB ? 3 : n < tB ? 4 : n < nB ? 5 : n < rB ? 6 : n < iB ? 7 : n < sB ? 8 : n < aB ? 9 : 10;
}, uB = {
  encode: qD,
  decode: QD,
  encodingLength: oB
}, Ud = uB;
const u0 = (n, e = 0) => [Ud.decode(n, e), Ud.decode.bytes], jd = (n, e, t = 0) => (Ud.encode(n, e, t), e), Vd = (n) => Ud.encodingLength(n), lB = (n, e) => {
  if (n === e)
    return !0;
  if (n.byteLength !== e.byteLength)
    return !1;
  for (let t = 0; t < n.byteLength; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}, pm = (n) => {
  if (n instanceof Uint8Array && n.constructor.name === "Uint8Array")
    return n;
  if (n instanceof ArrayBuffer)
    return new Uint8Array(n);
  if (ArrayBuffer.isView(n))
    return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
  throw new Error("Unknown type, must be binary type");
}, cB = (n) => new TextEncoder().encode(n), dB = (n) => new TextDecoder().decode(n), fB = (n, e) => {
  const t = e.byteLength, r = Vd(n), i = r + Vd(t), s = new Uint8Array(i + t);
  return jd(n, s, 0), jd(t, s, r), s.set(e, i), new hm(n, t, e, s);
}, pB = (n) => {
  const e = pm(n), [t, r] = u0(e), [i, s] = u0(e.subarray(r)), a = e.subarray(r + s);
  if (a.byteLength !== i)
    throw new Error("Incorrect length");
  return new hm(t, i, a, e);
}, hB = (n, e) => {
  if (n === e)
    return !0;
  {
    const t = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      e
    );
    return n.code === t.code && n.size === t.size && t.bytes instanceof Uint8Array && lB(n.bytes, t.bytes);
  }
};
class hm {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(e, t, r, i) {
    this.code = e, this.size = t, this.digest = r, this.bytes = i;
  }
}
function yB(n, e) {
  if (n.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
    t[r] = 255;
  for (var i = 0; i < n.length; i++) {
    var s = n.charAt(i), a = s.charCodeAt(0);
    if (t[a] !== 255)
      throw new TypeError(s + " is ambiguous");
    t[a] = i;
  }
  var o = n.length, u = n.charAt(0), l = Math.log(o) / Math.log(256), d = Math.log(256) / Math.log(o);
  function p(x) {
    if (x instanceof Uint8Array || (ArrayBuffer.isView(x) ? x = new Uint8Array(x.buffer, x.byteOffset, x.byteLength) : Array.isArray(x) && (x = Uint8Array.from(x))), !(x instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (x.length === 0)
      return "";
    for (var T = 0, A = 0, M = 0, I = x.length; M !== I && x[M] === 0; )
      M++, T++;
    for (var B = (I - M) * d + 1 >>> 0, k = new Uint8Array(B); M !== I; ) {
      for (var N = x[M], U = 0, W = B - 1; (N !== 0 || U < A) && W !== -1; W--, U++)
        N += 256 * k[W] >>> 0, k[W] = N % o >>> 0, N = N / o >>> 0;
      if (N !== 0)
        throw new Error("Non-zero carry");
      A = U, M++;
    }
    for (var G = B - A; G !== B && k[G] === 0; )
      G++;
    for (var Y = u.repeat(T); G < B; ++G)
      Y += n.charAt(k[G]);
    return Y;
  }
  function m(x) {
    if (typeof x != "string")
      throw new TypeError("Expected String");
    if (x.length === 0)
      return new Uint8Array();
    var T = 0;
    if (x[T] !== " ") {
      for (var A = 0, M = 0; x[T] === u; )
        A++, T++;
      for (var I = (x.length - T) * l + 1 >>> 0, B = new Uint8Array(I); x[T]; ) {
        var k = t[x.charCodeAt(T)];
        if (k === 255)
          return;
        for (var N = 0, U = I - 1; (k !== 0 || N < M) && U !== -1; U--, N++)
          k += o * B[U] >>> 0, B[U] = k % 256 >>> 0, k = k / 256 >>> 0;
        if (k !== 0)
          throw new Error("Non-zero carry");
        M = N, T++;
      }
      if (x[T] !== " ") {
        for (var W = I - M; W !== I && B[W] === 0; )
          W++;
        for (var G = new Uint8Array(A + (I - W)), Y = A; W !== I; )
          G[Y++] = B[W++];
        return G;
      }
    }
  }
  function w(x) {
    var T = m(x);
    if (T)
      return T;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: p,
    decodeUnsafe: m,
    decode: w
  };
}
var mB = yB, bB = mB;
class gB {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(e, t, r) {
    this.name = e, this.prefix = t, this.baseEncode = r;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class xB {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, t, r) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = /** @type {number} */
    t.codePointAt(0), this.baseDecode = r;
  }
  /**
   * @param {string} text
   */
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return S5(this, e);
  }
}
class vB {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(e) {
    this.decoders = e;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return S5(this, e);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(e) {
    const t = (
      /** @type {Prefix} */
      e[0]
    ), r = this.decoders[t];
    if (r)
      return r.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const S5 = (n, e) => new vB(
  /** @type {Decoders<L|R>} */
  {
    ...n.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      n.prefix
    ]: n },
    ...e.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      e.prefix
    ]: e }
  }
);
class wB {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, t, r, i) {
    this.name = e, this.prefix = t, this.baseEncode = r, this.baseDecode = i, this.encoder = new gB(e, t, r), this.decoder = new xB(e, t, i);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(e) {
    return this.encoder.encode(e);
  }
  /**
   * @param {string} input
   */
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Df = ({ name: n, prefix: e, encode: t, decode: r }) => new wB(n, e, t, r), Gl = ({ prefix: n, name: e, alphabet: t }) => {
  const { encode: r, decode: i } = bB(t, e);
  return Df({
    prefix: n,
    name: e,
    encode: r,
    /**
     * @param {string} text
     */
    decode: (s) => pm(i(s))
  });
}, TB = (n, e, t, r) => {
  const i = {};
  for (let d = 0; d < e.length; ++d)
    i[e[d]] = d;
  let s = n.length;
  for (; n[s - 1] === "="; )
    --s;
  const a = new Uint8Array(s * t / 8 | 0);
  let o = 0, u = 0, l = 0;
  for (let d = 0; d < s; ++d) {
    const p = i[n[d]];
    if (p === void 0)
      throw new SyntaxError(`Non-${r} character`);
    u = u << t | p, o += t, o >= 8 && (o -= 8, a[l++] = 255 & u >> o);
  }
  if (o >= t || 255 & u << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a;
}, AB = (n, e, t) => {
  const r = e[e.length - 1] === "=", i = (1 << t) - 1;
  let s = "", a = 0, o = 0;
  for (let u = 0; u < n.length; ++u)
    for (o = o << 8 | n[u], a += 8; a > t; )
      a -= t, s += e[i & o >> a];
  if (a && (s += e[i & o << t - a]), r)
    for (; s.length * t & 7; )
      s += "=";
  return s;
}, pn = ({ name: n, prefix: e, bitsPerChar: t, alphabet: r }) => Df({
  prefix: e,
  name: n,
  encode(i) {
    return AB(i, r, t);
  },
  decode(i) {
    return TB(i, r, t, n);
  }
}), xi = Gl({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), EB = Gl({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), SB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: xi,
  base58flickr: EB
}, Symbol.toStringTag, { value: "Module" })), Bu = pn({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), CB = pn({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), _B = pn({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), MB = pn({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), PB = pn({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), RB = pn({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), IB = pn({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), OB = pn({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), kB = pn({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), NB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: Bu,
  base32hex: PB,
  base32hexpad: IB,
  base32hexpadupper: OB,
  base32hexupper: RB,
  base32pad: _B,
  base32padupper: MB,
  base32upper: CB,
  base32z: kB
}, Symbol.toStringTag, { value: "Module" })), l0 = (n, e) => {
  const { bytes: t, version: r } = n;
  switch (r) {
    case 0:
      return BB(
        t,
        c0(n),
        /** @type {API.MultibaseEncoder<"z">} */
        e || xi.encoder
      );
    default:
      return FB(
        t,
        c0(n),
        /** @type {API.MultibaseEncoder<Prefix>} */
        e || Bu.encoder
      );
  }
}, J2 = /* @__PURE__ */ new WeakMap(), c0 = (n) => {
  const e = J2.get(n);
  if (e == null) {
    const t = /* @__PURE__ */ new Map();
    return J2.set(n, t), t;
  }
  return e;
};
class rn {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(e, t, r, i) {
    this.code = t, this.version = e, this.multihash = r, this.bytes = i, this["/"] = i;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0:
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      case 1: {
        const { code: e, multihash: t } = this;
        if (e !== du)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (t.code !== LB)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          rn.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            t
          )
        );
      }
      default:
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: t } = this.multihash, r = fB(e, t);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          rn.createV1(this.code, r)
        );
      }
      case 1:
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      default:
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(e) {
    return rn.equals(this, e);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(e, t) {
    const r = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      t
    );
    return r && e.code === r.code && e.version === r.version && hB(e.multihash, r.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(e) {
    return l0(this, e);
  }
  toJSON() {
    return { "/": l0(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(e) {
    if (e == null)
      return null;
    const t = (
      /** @type {any} */
      e
    );
    if (t instanceof rn)
      return t;
    if (t["/"] != null && t["/"] === t.bytes || t.asCID === t) {
      const { version: r, code: i, multihash: s, bytes: a } = t;
      return new rn(
        r,
        i,
        /** @type {API.MultihashDigest<Alg>} */
        s,
        a || Q2(r, i, s.bytes)
      );
    } else if (t[$B] === !0) {
      const { version: r, multihash: i, code: s } = t, a = (
        /** @type {API.MultihashDigest<Alg>} */
        pB(i)
      );
      return rn.create(r, s, a);
    } else
      return null;
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(e, t, r) {
    if (typeof t != "number")
      throw new Error("String codecs are no longer supported");
    if (!(r.bytes instanceof Uint8Array))
      throw new Error("Invalid digest");
    switch (e) {
      case 0: {
        if (t !== du)
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${du}) block encoding`
          );
        return new rn(e, t, r, r.bytes);
      }
      case 1: {
        const i = Q2(e, t, r.bytes);
        return new rn(e, t, r, i);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(e) {
    return rn.create(0, du, e);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(e, t) {
    return rn.create(1, e, t);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(e) {
    const [t, r] = rn.decodeFirst(e);
    if (r.length)
      throw new Error("Incorrect length");
    return t;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(e) {
    const t = rn.inspectBytes(e), r = t.size - t.multihashSize, i = pm(
      e.subarray(r, r + t.multihashSize)
    );
    if (i.byteLength !== t.multihashSize)
      throw new Error("Incorrect length");
    const s = i.subarray(
      t.multihashSize - t.digestSize
    ), a = new hm(
      t.multihashCode,
      t.digestSize,
      s,
      i
    );
    return [t.version === 0 ? rn.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      a
    ) : rn.createV1(t.codec, a), e.subarray(t.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(e) {
    let t = 0;
    const r = () => {
      const [p, m] = u0(e.subarray(t));
      return t += m, p;
    };
    let i = (
      /** @type {V} */
      r()
    ), s = (
      /** @type {C} */
      du
    );
    if (/** @type {number} */
    i === 18 ? (i = /** @type {V} */
    0, t = 0) : s = /** @type {C} */
    r(), i !== 0 && i !== 1)
      throw new RangeError(`Invalid CID version ${i}`);
    const a = t, o = (
      /** @type {A} */
      r()
    ), u = r(), l = t + u, d = l - a;
    return { version: i, codec: s, multihashCode: o, digestSize: u, multihashSize: d, size: l };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(e, t) {
    const [r, i] = DB(e, t), s = rn.decode(i);
    if (s.version === 0 && e[0] !== "Q")
      throw Error("Version 0 CID string must not include multibase prefix");
    return c0(s).set(r, e), s;
  }
}
const DB = (n, e) => {
  switch (n[0]) {
    case "Q": {
      const t = e || xi;
      return [
        /** @type {Prefix} */
        xi.prefix,
        t.decode(`${xi.prefix}${n}`)
      ];
    }
    case xi.prefix: {
      const t = e || xi;
      return [
        /** @type {Prefix} */
        xi.prefix,
        t.decode(n)
      ];
    }
    case Bu.prefix: {
      const t = e || Bu;
      return [
        /** @type {Prefix} */
        Bu.prefix,
        t.decode(n)
      ];
    }
    default: {
      if (e == null)
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      return [
        /** @type {Prefix} */
        n[0],
        e.decode(n)
      ];
    }
  }
}, BB = (n, e, t) => {
  const { prefix: r } = t;
  if (r !== xi.prefix)
    throw Error(`Cannot string encode V0 in ${t.name} encoding`);
  const i = e.get(r);
  if (i == null) {
    const s = t.encode(n).slice(1);
    return e.set(r, s), s;
  } else
    return i;
}, FB = (n, e, t) => {
  const { prefix: r } = t, i = e.get(r);
  if (i == null) {
    const s = t.encode(n);
    return e.set(r, s), s;
  } else
    return i;
}, du = 112, LB = 18, Q2 = (n, e, t) => {
  const r = Vd(n), i = r + Vd(e), s = new Uint8Array(i + t.byteLength);
  return jd(n, s, 0), jd(e, s, r), s.set(t, i), s;
}, $B = Symbol.for("@ipld/js-cid/CID"), UB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CID: rn,
  format: l0
}, Symbol.toStringTag, { value: "Module" }));
function C5(n) {
  return globalThis.Buffer != null ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : n;
}
function _5(n = 0) {
  return globalThis.Buffer?.allocUnsafe != null ? C5(globalThis.Buffer.allocUnsafe(n)) : new Uint8Array(n);
}
function jB(n, e) {
  e == null && (e = n.reduce((i, s) => i + s.length, 0));
  const t = _5(e);
  let r = 0;
  for (const i of n)
    t.set(i, r), r += i.length;
  return C5(t);
}
const VB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  concat: jB
}, Symbol.toStringTag, { value: "Module" })), zB = Df({
  prefix: "\0",
  name: "identity",
  encode: (n) => dB(n),
  decode: (n) => cB(n)
}), GB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: zB
}, Symbol.toStringTag, { value: "Module" })), HB = pn({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), qB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: HB
}, Symbol.toStringTag, { value: "Module" })), WB = pn({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), KB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: WB
}, Symbol.toStringTag, { value: "Module" })), JB = Gl({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), QB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: JB
}, Symbol.toStringTag, { value: "Module" })), YB = pn({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), XB = pn({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), ZB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: YB,
  base16upper: XB
}, Symbol.toStringTag, { value: "Module" })), eF = Gl({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), tF = Gl({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), nF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: eF,
  base36upper: tF
}, Symbol.toStringTag, { value: "Module" })), rF = pn({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), iF = pn({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), sF = pn({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), aF = pn({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), oF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: rF,
  base64pad: iF,
  base64url: sF,
  base64urlpad: aF
}, Symbol.toStringTag, { value: "Module" })), M5 = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), uF = (
  /** @type {string[]} */
  M5.reduce(
    (n, e, t) => (n[t] = e, n),
    /** @type {string[]} */
    []
  )
), lF = (
  /** @type {number[]} */
  M5.reduce(
    (n, e, t) => (n[
      /** @type {number} */
      e.codePointAt(0)
    ] = t, n),
    /** @type {number[]} */
    []
  )
);
function cF(n) {
  return n.reduce((e, t) => (e += uF[t], e), "");
}
function dF(n) {
  const e = [];
  for (const t of n) {
    const r = lF[
      /** @type {number} */
      t.codePointAt(0)
    ];
    if (r === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const fF = Df({
  prefix: "🚀",
  name: "base256emoji",
  encode: cF,
  decode: dF
}), pF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: fF
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Y2 = { ...GB, ...qB, ...KB, ...QB, ...ZB, ...NB, ...nF, ...SB, ...oF, ...pF };
function P5(n, e, t, r) {
  return {
    name: n,
    prefix: e,
    encoder: {
      name: n,
      prefix: e,
      encode: t
    },
    decoder: {
      decode: r
    }
  };
}
const X2 = P5("utf8", "u", (n) => "u" + new TextDecoder("utf8").decode(n), (n) => new TextEncoder().encode(n.substring(1))), Kp = P5("ascii", "a", (n) => {
  let e = "a";
  for (let t = 0; t < n.length; t++)
    e += String.fromCharCode(n[t]);
  return e;
}, (n) => {
  n = n.substring(1);
  const e = _5(n.length);
  for (let t = 0; t < n.length; t++)
    e[t] = n.charCodeAt(t);
  return e;
}), hF = {
  utf8: X2,
  "utf-8": X2,
  hex: Y2.base16,
  latin1: Kp,
  ascii: Kp,
  binary: Kp,
  ...Y2
};
function yF(n, e = "utf8") {
  const t = hF[e];
  if (t == null)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString("utf8") : t.encoder.encode(n).substring(1);
}
const mF = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  toString: yF
}, Symbol.toStringTag, { value: "Module" }));
export {
  kD as seed
};


function R5(n, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in n)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s && Object.defineProperty(n, i, s.get ? s : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
function jn(n) {
  return typeof n == "object" && n !== null || typeof n == "function";
}
function d0(n) {
  return n == null;
}
let Fu = /* @__PURE__ */ new WeakMap();
const xn = (n, e, t, r, i) => new TypeError(`${n}(${e.map(String).join(",")}) - Expected '${t}' to be of type ${i}, but got: ${Object.prototype.toString.call(r)} (${String(r)})`);
function Es(n) {
  switch (typeof n) {
    case "undefined":
    case "string":
    case "symbol":
      return n;
    default:
      return `${n}`;
  }
}
function I5(n) {
  switch (typeof n) {
    case "string":
    case "symbol":
      return n;
    default:
      return `${n}`;
  }
}
function O5(n) {
  switch (typeof n) {
    case "undefined":
    case "string":
    case "symbol":
      return n;
    default:
      throw new TypeError(`Invalid metadata propertyKey: ${n}.`);
  }
}
function bl(n, e, t) {
  let r = Fu.get(n);
  if (r === void 0) {
    if (!t)
      return;
    r = /* @__PURE__ */ new Map(), Fu.set(n, r);
  }
  let i = r.get(e);
  if (i === void 0) {
    if (!t)
      return;
    i = /* @__PURE__ */ new Map(), r.set(e, i);
  }
  return i;
}
function f0(n, e, t) {
  const r = bl(e, t, !1);
  return r === void 0 ? !1 : r.has(n);
}
function Z2(n, e, t) {
  if (f0(n, e, t))
    return !0;
  const r = p0(e);
  return r !== null ? Z2(n, r, t) : !1;
}
function ev(n, e, t) {
  const r = bl(e, t, !1);
  if (r !== void 0)
    return r.get(n);
}
function tv(n, e, t) {
  if (f0(n, e, t))
    return ev(n, e, t);
  const r = p0(e);
  if (r !== null)
    return tv(n, r, t);
}
function nv(n, e, t, r) {
  bl(t, r, !0).set(n, e);
}
function rv(n, e) {
  const t = [], r = bl(n, e, !1);
  if (r === void 0)
    return t;
  const i = r.keys();
  let s = 0;
  for (const a of i)
    t[s] = a, ++s;
  return t;
}
function iv(n, e) {
  const t = rv(n, e), r = p0(n);
  if (r === null)
    return t;
  const i = iv(r, e), s = t.length;
  if (s === 0)
    return i;
  const a = i.length;
  if (a === 0)
    return t;
  const o = /* @__PURE__ */ new Set(), u = [];
  let l = 0, d;
  for (let p = 0; p < s; ++p)
    d = t[p], o.has(d) || (o.add(d), u[l] = d, ++l);
  for (let p = 0; p < a; ++p)
    d = i[p], o.has(d) || (o.add(d), u[l] = d, ++l);
  return u;
}
function k5(n, e, t) {
  const r = bl(n, t, !1);
  return r === void 0 ? !1 : r.delete(e);
}
function N5(n, e) {
  function t(r, i) {
    if (!jn(r))
      throw xn("@metadata", [n, e, r, i], "target", r, "Object or Function");
    nv(n, e, r, O5(i));
  }
  return t;
}
function D5(n, e, t, r) {
  if (t !== void 0) {
    if (!Array.isArray(n))
      throw xn("Metadata.decorate", [n, e, t, r], "decorators", n, "Array");
    if (!jn(e))
      throw xn("Metadata.decorate", [n, e, t, r], "target", e, "Object or Function");
    if (!jn(r) && !d0(r))
      throw xn("Metadata.decorate", [n, e, t, r], "attributes", r, "Object, Function, null, or undefined");
    return r === null && (r = void 0), t = I5(t), F5(n, e, t, r);
  } else {
    if (!Array.isArray(n))
      throw xn("Metadata.decorate", [n, e, t, r], "decorators", n, "Array");
    if (typeof e != "function")
      throw xn("Metadata.decorate", [n, e, t, r], "target", e, "Function");
    return B5(n, e);
  }
}
function B5(n, e) {
  for (let t = n.length - 1; t >= 0; --t) {
    const r = n[t], i = r(e);
    if (!d0(i)) {
      if (typeof i != "function")
        throw xn("DecorateConstructor", [n, e], "decorated", i, "Function, null, or undefined");
      e = i;
    }
  }
  return e;
}
function F5(n, e, t, r) {
  for (let i = n.length - 1; i >= 0; --i) {
    const s = n[i], a = s(e, t, r);
    if (!d0(a)) {
      if (!jn(a))
        throw xn("DecorateProperty", [n, e, t, r], "decorated", a, "Object, Function, null, or undefined");
      r = a;
    }
  }
  return r;
}
function sv(n, e, t, r) {
  if (!jn(t))
    throw xn("Metadata.define", [n, e, t, r], "target", t, "Object or Function");
  return nv(n, e, t, Es(r));
}
function av(n, e, t) {
  if (!jn(e))
    throw xn("Metadata.has", [n, e, t], "target", e, "Object or Function");
  return Z2(n, e, Es(t));
}
function ov(n, e, t) {
  if (!jn(e))
    throw xn("Metadata.hasOwn", [n, e, t], "target", e, "Object or Function");
  return f0(n, e, Es(t));
}
function uv(n, e, t) {
  if (!jn(e))
    throw xn("Metadata.get", [n, e, t], "target", e, "Object or Function");
  return tv(n, e, Es(t));
}
function lv(n, e, t) {
  if (!jn(e))
    throw xn("Metadata.getOwn", [n, e, t], "target", e, "Object or Function");
  return ev(n, e, Es(t));
}
function cv(n, e) {
  if (!jn(n))
    throw xn("Metadata.getKeys", [n, e], "target", n, "Object or Function");
  return iv(n, Es(e));
}
function dv(n, e) {
  if (!jn(n))
    throw xn("Metadata.getOwnKeys", [n, e], "target", n, "Object or Function");
  return rv(n, Es(e));
}
function fv(n, e, t) {
  if (!jn(e))
    throw xn("Metadata.delete", [n, e, t], "target", e, "Object or Function");
  return k5(e, n, Es(t));
}
const ui = {
  define: sv,
  has: av,
  hasOwn: ov,
  get: uv,
  getOwn: lv,
  getKeys: cv,
  getOwnKeys: dv,
  delete: fv
}, L5 = (n, e, t, r, i) => {
  if (!Reflect.defineProperty(n, e, {
    writable: r,
    enumerable: !1,
    configurable: i,
    value: t
  }))
    throw Jp(`AUR1000:${e}`);
}, yu = "[[$au]]", $5 = (n) => yu in n, ym = (n, e, t) => [[yu, Fu], ["metadata", N5], ["decorate", D5], ["defineMetadata", sv], ["hasMetadata", av], ["hasOwnMetadata", ov], ["getMetadata", uv], ["getOwnMetadata", lv], ["getMetadataKeys", cv], ["getOwnMetadataKeys", dv], ["deleteMetadata", fv]].forEach(([r, i]) => L5(n, r, i, e, t)), U5 = (n, e = !0, t = !1, r = !0, i = !0) => {
  if ($5(n)) {
    if (n[yu] === Fu)
      return;
    if (n[yu] instanceof WeakMap) {
      Fu = n[yu];
      return;
    }
    throw Jp("AUR1001");
  }
  const s = "metadata decorate defineMetadata hasMetadata hasOwnMetadata getMetadata getOwnMetadata getMetadataKeys getOwnMetadataKeys deleteMetadata".split(" ").filter((a) => a in Reflect);
  if (s.length > 0)
    if (e) {
      const a = s.map(function(o) {
        const u = `${Reflect[o].toString().slice(0, 100)}...`;
        return `${o}:
${u}`;
      }).join(`

`);
      throw Jp(`AUR1002:${a}`);
    } else
      t && ym(n, r, i);
  else
    ym(n, r, i);
}, Jp = (n) => new Error(n), p0 = Object.getPrototypeOf;
function Li(n, e, t, r) {
  var i = arguments.length, s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, r);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (a = n[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function na(n, e) {
  return function(t, r) {
    e(t, r, n);
  };
}
const Io = String, Vn = ui.getOwn, j5 = ui.hasOwn, ms = ui.define, fa = (n) => typeof n == "function", Uc = (n) => typeof n == "string", Ei = () => /* @__PURE__ */ Object.create(null), en = (n) => new Error(n), Hl = {}, Lu = (n) => {
  switch (typeof n) {
    case "number":
      return n >= 0 && (n | 0) === n;
    case "string": {
      const e = Hl[n];
      if (e !== void 0)
        return e;
      const t = n.length;
      if (t === 0)
        return Hl[n] = !1;
      let r = 0, i = 0;
      for (; i < t; ++i)
        if (r = hn(n, i), i === 0 && r === 48 && t > 1 || r < 48 || r > 57)
          return Hl[n] = !1;
      return Hl[n] = !0;
    }
    default:
      return !1;
  }
}, pv = /* @__PURE__ */ function() {
  const n = Object.assign(Ei(), {
    0: !0,
    1: !0,
    2: !0,
    3: !0,
    4: !0,
    5: !0,
    6: !0,
    7: !0,
    8: !0,
    9: !0
  }), e = (t) => t === "" ? 0 : t !== t.toUpperCase() ? 3 : t !== t.toLowerCase() ? 2 : n[t] === !0 ? 1 : 0;
  return (t, r) => {
    const i = t.length;
    if (i === 0)
      return t;
    let s = !1, a = "", o, u = "", l = 0, d = t.charAt(0), p = e(d), m = 0;
    for (; m < i; ++m)
      o = l, u = d, l = p, d = t.charAt(m + 1), p = e(d), l === 0 ? a.length > 0 && (s = !0) : (!s && a.length > 0 && l === 2 && (s = o === 3 || p === 3), a += r(u, s), s = !1);
    return a;
  };
}(), er = /* @__PURE__ */ function() {
  const n = Ei(), e = (t, r) => r ? t.toUpperCase() : t.toLowerCase();
  return (t) => {
    let r = n[t];
    return r === void 0 && (r = n[t] = pv(t, e)), r;
  };
}(), V5 = /* @__PURE__ */ function() {
  const n = Ei();
  return (e) => {
    let t = n[e];
    return t === void 0 && (t = er(e), t.length > 0 && (t = t[0].toUpperCase() + t.slice(1)), n[e] = t), t;
  };
}(), hv = /* @__PURE__ */ function() {
  const n = Ei(), e = (t, r) => r ? `-${t.toLowerCase()}` : t.toLowerCase();
  return (t) => {
    let r = n[t];
    return r === void 0 && (r = n[t] = pv(t, e)), r;
  };
}(), Qf = (n) => {
  const e = n.length, t = Array(e);
  let r = 0;
  for (; r < e; ++r)
    t[r] = n[r];
  return t;
}, Oo = (n, e, t) => ({
  configurable: !0,
  enumerable: t.enumerable,
  get() {
    const r = t.value.bind(this);
    return Reflect.defineProperty(this, e, {
      value: r,
      writable: !0,
      configurable: !0,
      enumerable: t.enumerable
    }), r;
  }
}), jt = (...n) => {
  const e = [];
  let t = 0;
  const r = n.length;
  let i = 0, s, a = 0;
  for (; a < r; ++a)
    if (s = n[a], s !== void 0) {
      i = s.length;
      let o = 0;
      for (; o < i; ++o)
        e[t++] = s[o];
    }
  return e;
}, os = (...n) => {
  const e = n.length;
  let t, r = 0;
  for (; e > r; ++r)
    if (t = n[r], t !== void 0)
      return t;
  throw en("No default value found");
}, z5 = /* @__PURE__ */ function() {
  const n = Function.prototype, e = Object.getPrototypeOf, t = /* @__PURE__ */ new WeakMap();
  let r = n, i = 0, s;
  return function(a) {
    if (s = t.get(a), s === void 0)
      for (t.set(a, s = [r = a]), i = 0; (r = e(r)) !== n; )
        s[++i] = r;
    return s;
  };
}();
function $u(...n) {
  return Object.assign(Ei(), ...n);
}
const mm = /* @__PURE__ */ function() {
  const n = /* @__PURE__ */ new WeakMap();
  let e = !1, t = "", r = 0;
  return (i) => (e = n.get(i), e === void 0 && (t = i.toString(), r = t.length, e = r >= 29 && r <= 100 && hn(t, r - 1) === 125 && hn(t, r - 2) <= 32 && hn(t, r - 3) === 93 && hn(t, r - 4) === 101 && hn(t, r - 5) === 100 && hn(t, r - 6) === 111 && hn(t, r - 7) === 99 && hn(t, r - 8) === 32 && hn(t, r - 9) === 101 && hn(t, r - 10) === 118 && hn(t, r - 11) === 105 && hn(t, r - 12) === 116 && hn(t, r - 13) === 97 && hn(t, r - 14) === 110 && hn(t, r - 15) === 88, n.set(i, e)), e);
}(), Pe = (n, e) => n instanceof Promise ? n.then(e) : e(n), Qt = (...n) => {
  let e, t, r, i = 0, s = n.length;
  for (; i < s; ++i)
    e = n[i], (e = n[i]) instanceof Promise && (t === void 0 ? t = e : r === void 0 ? r = [t, e] : r.push(e));
  return r === void 0 ? t : Promise.all(r);
}, hn = (n, e) => n.charCodeAt(e), aa = "au:annotation", Si = (n, e) => e === void 0 ? `${aa}:${n}` : `${aa}:${n}:${e}`, h0 = (n, e) => {
  const t = Vn(aa, n);
  t === void 0 ? ms(aa, [e], n) : t.push(e);
}, G5 = Object.freeze({
  name: "au:annotation",
  appendTo: h0,
  set(n, e, t) {
    ms(Si(e), t, n);
  },
  get: (n, e) => Vn(Si(e), n),
  getKeys(n) {
    let e = Vn(aa, n);
    return e === void 0 && ms(aa, e = [], n), e;
  },
  isKey: (n) => n.startsWith(aa),
  keyFor: Si
}), jr = "au:resource", Qp = (n) => j5(jr, n), Yp = (n) => {
  const e = Vn(jr, n);
  return e === void 0 ? je : e.map((t) => Vn(t, n));
}, H5 = Object.freeze({
  name: jr,
  appendTo(n, e) {
    const t = Vn(jr, n);
    t === void 0 ? ms(jr, [e], n) : t.push(e);
  },
  has: Qp,
  getAll: Yp,
  getKeys(n) {
    let e = Vn(jr, n);
    return e === void 0 && ms(jr, e = [], n), e;
  },
  isKey: (n) => n.startsWith(jr),
  keyFor(n, e) {
    return e === void 0 ? `${jr}:${n}` : `${jr}:${n}:${e}`;
  }
}), ko = {
  annotation: G5,
  resource: H5
}, yv = Object.prototype.hasOwnProperty;
function xr(n, e, t, r) {
  let i = Vn(Si(n), t);
  return i === void 0 ? (i = e[n], i === void 0 ? (i = t[n], i === void 0 || !yv.call(t, n) ? r() : i) : i) : i;
}
function ir(n, e, t) {
  let r = Vn(Si(n), e);
  return r === void 0 ? (r = e[n], r === void 0 || !yv.call(e, n) ? t() : r) : r;
}
function kn(n, e, t) {
  const r = e[n];
  return r === void 0 ? t() : r;
}
const q5 = new Set("Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise RangeError ReferenceError RegExp Set SharedArrayBuffer String SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet".split(" "));
let W5 = 0, yn = null;
class mu {
  get depth() {
    return this.parent === null ? 0 : this.parent.depth + 1;
  }
  constructor(e, t) {
    this.parent = e, this.config = t, this.id = ++W5, this.t = 0, this.i = /* @__PURE__ */ new Map(), e === null ? (this.root = this, this.u = /* @__PURE__ */ new Map(), this.h = /* @__PURE__ */ new Map(), this.res = Ei()) : (this.root = e.root, this.u = /* @__PURE__ */ new Map(), this.h = e.h, t.inheritParentResources ? this.res = Object.assign(Ei(), e.res, this.root.res) : this.res = Ei()), this.u.set(No, Q5);
  }
  register(...e) {
    if (++this.t === 100)
      throw e3(e);
    let t, r, i, s, a, o = 0, u = e.length;
    for (; o < u; ++o)
      if (t = e[o], !!jn(t))
        if (mc(t))
          t.register(this);
        else if (Qp(t)) {
          const l = Yp(t);
          if (l.length === 1)
            l[0].register(this);
          else
            for (s = 0, a = l.length; a > s; )
              l[s].register(this), ++s;
        } else if (X5(t))
          be.singleton(t, t).register(this);
        else
          for (r = Object.keys(t), s = 0, a = r.length; s < a; ++s)
            i = t[r[s]], jn(i) && (mc(i) ? i.register(this) : this.register(i));
    return --this.t, this;
  }
  registerResolver(e, t, r = !1) {
    ql(e);
    const i = this.u, s = i.get(e);
    if (s == null) {
      if (i.set(e, t), Z5(e)) {
        if (this.res[e] !== void 0)
          throw t3(e);
        this.res[e] = t;
      }
    } else
      s instanceof fr && s.R === 4 ? s._state.push(t) : i.set(e, new fr(e, 4, [s, t]));
    return r && this.i.set(e, t), t;
  }
  registerTransformer(e, t) {
    const r = this.getResolver(e);
    if (r == null)
      return !1;
    if (r.getFactory) {
      const i = r.getFactory(this);
      return i == null ? !1 : (i.registerTransformer(t), !0);
    }
    return !1;
  }
  getResolver(e, t = !0) {
    if (ql(e), e.resolve !== void 0)
      return e;
    const r = yn;
    let i = yn = this, s, a;
    try {
      for (; i != null; )
        if (s = i.u.get(e), s == null) {
          if (i.parent == null)
            return a = gm(e) ? this : i, t ? this.$(e, a) : null;
          i = i.parent;
        } else
          return s;
    } finally {
      yn = r;
    }
    return null;
  }
  has(e, t = !1) {
    return this.u.has(e) ? !0 : t && this.parent != null ? this.parent.has(e, !0) : !1;
  }
  get(e) {
    if (ql(e), e.$isResolver)
      return e.resolve(this, this);
    const t = yn;
    let r = yn = this, i, s;
    try {
      for (; r != null; )
        if (i = r.u.get(e), i == null) {
          if (r.parent == null)
            return s = gm(e) ? this : r, i = this.$(e, s), i.resolve(r, this);
          r = r.parent;
        } else
          return i.resolve(r, this);
    } finally {
      yn = t;
    }
    throw n3(e);
  }
  getAll(e, t = !1) {
    ql(e);
    const r = yn, i = yn = this;
    let s = i, a, o = je;
    try {
      if (t) {
        for (; s != null; )
          a = s.u.get(e), a != null && (o = o.concat(bm(a, s, i))), s = s.parent;
        return o;
      }
      for (; s != null; )
        if (a = s.u.get(e), a == null) {
          if (s = s.parent, s == null)
            return yn = r, je;
        } else
          return bm(a, s, i);
    } finally {
      yn = r;
    }
    return je;
  }
  invoke(e, t) {
    const r = yn;
    yn = this;
    try {
      if (mm(e))
        throw vm(e);
      return t === void 0 ? new e(...bu(e).map(jc, this)) : new e(...bu(e).map(jc, this), ...t);
    } finally {
      yn = r;
    }
  }
  getFactory(e) {
    let t = this.h.get(e);
    if (t === void 0) {
      if (mm(e))
        throw vm(e);
      this.h.set(e, t = new K5(e, bu(e)));
    }
    return t;
  }
  registerFactory(e, t) {
    this.h.set(e, t);
  }
  createChild(e) {
    return e === void 0 && this.config.inheritParentResources ? this.config === Jr.DEFAULT ? new mu(this, this.config) : new mu(this, Jr.from({
      ...this.config,
      inheritParentResources: !1
    })) : new mu(this, Jr.from(e ?? this.config));
  }
  disposeResolvers() {
    const e = this.u, t = this.i;
    let r, i;
    for ([i, r] of t.entries())
      r.dispose(), e.delete(i);
    t.clear();
  }
  find(e, t) {
    const r = e.keyFrom(t);
    let i = this.res[r];
    if (i === void 0 && (i = this.root.res[r], i === void 0) || i === null)
      return null;
    if (fa(i.getFactory)) {
      const s = i.getFactory(this);
      if (s == null)
        return null;
      const a = Vn(e.name, s.Type);
      return a === void 0 ? null : a;
    }
    return null;
  }
  create(e, t) {
    const r = e.keyFrom(t);
    let i = this.res[r];
    return i === void 0 ? (i = this.root.res[r], i === void 0 ? null : i.resolve(this.root, this) ?? null) : i.resolve(this, this) ?? null;
  }
  dispose() {
    this.i.size > 0 && this.disposeResolvers(), this.u.clear();
  }
  $(e, t) {
    if (!fa(e))
      throw r3(e);
    if (q5.has(e.name))
      throw i3(e);
    if (mc(e)) {
      const i = e.register(t, e);
      if (!(i instanceof Object) || i.resolve == null) {
        const s = t.u.get(e);
        if (s != null)
          return s;
        throw xm();
      }
      return i;
    }
    if (Qp(e)) {
      const i = Yp(e);
      if (i.length === 1)
        i[0].register(t);
      else {
        const a = i.length;
        for (let o = 0; o < a; ++o)
          i[o].register(t);
      }
      const s = t.u.get(e);
      if (s != null)
        return s;
      throw xm();
    }
    if (e.$isInterface)
      throw s3(e.friendlyName);
    const r = this.config.defaultResolver(e, t);
    return t.u.set(e, r), r;
  }
}
class K5 {
  constructor(e, t) {
    this.Type = e, this.dependencies = t, this.transformers = null;
  }
  construct(e, t) {
    const r = yn;
    yn = e;
    let i;
    try {
      return t === void 0 ? i = new this.Type(...this.dependencies.map(jc, e)) : i = new this.Type(...this.dependencies.map(jc, e), ...t), this.transformers == null ? i : this.transformers.reduce(J5, i);
    } finally {
      yn = r;
    }
  }
  registerTransformer(e) {
    (this.transformers ?? (this.transformers = [])).push(e);
  }
}
function J5(n, e) {
  return e(n);
}
function ql(n) {
  if (n == null)
    throw en("AUR0014");
}
function jc(n) {
  return this.get(n);
}
const bm = (n, e, t) => {
  if (n instanceof fr && n.R === 4) {
    const r = n._state, i = r.length, s = Array(i);
    let a = 0;
    for (; a < i; ++a)
      s[a] = r[a].resolve(e, t);
    return s;
  }
  return [n.resolve(e, t)];
}, Q5 = {
  $isResolver: !0,
  resolve(n, e) {
    return e;
  }
}, mc = (n) => fa(n.register), Y5 = (n) => mc(n) && typeof n.registerInRequestor == "boolean", gm = (n) => Y5(n) && n.registerInRequestor, X5 = (n) => n.prototype !== void 0, Z5 = (n) => Uc(n) && n.indexOf(":") > 0, e3 = (n) => en(`AUR0006:${n.map(Io)}`), t3 = (n) => en(`AUR0007:${Io(n)}`), n3 = (n) => en(`AUR0008:${Io(n)}`), r3 = (n) => en(`AUR0009:${Io(n)}`), i3 = (n) => en(`AUR0010:${n.name}`), xm = () => en("AUR0011"), s3 = (n) => en(`AUR0012:${n}`), vm = (n) => en(`AUR0015:${n.name}`), mv = (n, e) => new fr(n, 0, e), y0 = (n, e) => new fr(n, 1, e), a3 = (n, e) => new fr(n, 2, e), o3 = (n, e) => new fr(n, 3, e), u3 = (n, e) => new fr(n, 3, bv(e)), l3 = (n, e) => new fr(e, 5, n), c3 = (n, ...e) => new A3(n, e), wm = /* @__PURE__ */ new WeakMap(), bv = (n) => (e, t, r) => {
  let i = wm.get(e);
  if (i === void 0 && wm.set(e, i = /* @__PURE__ */ new WeakMap()), i.has(r))
    return i.get(r);
  const s = n(e, t, r);
  return i.set(r, s), s;
};
U5(Reflect, !1, !1);
class d3 {
  constructor(e, t) {
    this.c = e, this.k = t;
  }
  instance(e) {
    return this.A(0, e);
  }
  singleton(e) {
    return this.A(1, e);
  }
  transient(e) {
    return this.A(2, e);
  }
  callback(e) {
    return this.A(3, e);
  }
  cachedCallback(e) {
    return this.A(3, bv(e));
  }
  aliasTo(e) {
    return this.A(5, e);
  }
  A(e, t) {
    const { c: r, k: i } = this;
    return this.c = this.k = void 0, r.registerResolver(i, new fr(i, e, t));
  }
}
const Zo = (n) => {
  const e = n.slice(), t = Object.keys(n), r = t.length;
  let i;
  for (let s = 0; s < r; ++s)
    i = t[s], Lu(i) || (e[i] = n[i]);
  return e;
}, f3 = {
  none(n) {
    throw p3(n);
  },
  singleton: (n) => new fr(n, 1, n),
  transient: (n) => new fr(n, 2, n)
}, p3 = (n) => en(`AUR0002:${Io(n)}`);
class Jr {
  constructor(e, t) {
    this.inheritParentResources = e, this.defaultResolver = t;
  }
  static from(e) {
    return e === void 0 || e === Jr.DEFAULT ? Jr.DEFAULT : new Jr(e.inheritParentResources ?? !1, e.defaultResolver ?? f3.singleton);
  }
}
Jr.DEFAULT = Jr.from({});
const h3 = (n) => new mu(null, Jr.from(n)), gv = (n) => {
  const e = Si("di:paramtypes");
  return Vn(e, n);
}, y3 = (n) => Vn("design:paramtypes", n), Ja = (n) => {
  const e = Si("di:paramtypes");
  let t = Vn(e, n);
  return t === void 0 && (ms(e, t = [], n), h0(n, e)), t;
}, bu = (n) => {
  const e = Si("di:dependencies");
  let t = Vn(e, n);
  if (t === void 0) {
    const r = n.inject;
    if (r === void 0) {
      const i = me.getDesignParamtypes(n), s = gv(n);
      if (i === void 0)
        if (s === void 0) {
          const a = Object.getPrototypeOf(n);
          fa(a) && a !== Function.prototype ? t = Zo(bu(a)) : t = [];
        } else
          t = Zo(s);
      else if (s === void 0)
        t = Zo(i);
      else {
        t = Zo(i);
        let a = s.length, o, u = 0;
        for (; u < a; ++u)
          o = s[u], o !== void 0 && (t[u] = o);
        const l = Object.keys(s);
        let d;
        for (u = 0, a = l.length, u = 0; u < a; ++u)
          d = l[u], Lu(d) || (t[d] = s[d]);
      }
    } else
      t = Zo(r);
    ms(e, t, n), h0(n, e);
  }
  return t;
}, $i = (n, e) => {
  const t = fa(n) ? n : e, r = (Uc(n) ? n : void 0) ?? "(anonymous)", i = function(s, a, o) {
    if (s == null || new.target !== void 0)
      throw m3(r);
    const u = Ja(s);
    u[o] = i;
  };
  return i.$isInterface = !0, i.friendlyName = r, t != null && (i.register = (s, a) => t(new d3(s, a ?? i))), i.toString = () => `InterfaceSymbol<${r}>`, i;
}, m3 = (n) => en(`AUR0001:${n}`), me = {
  createContainer: h3,
  getDesignParamtypes: y3,
  getAnnotationParamtypes: gv,
  getOrCreateAnnotationParamTypes: Ja,
  getDependencies: bu,
  createInterface: $i,
  inject(...n) {
    return (e, t, r) => {
      if (typeof r == "number") {
        const i = Ja(e), s = n[0];
        s !== void 0 && (i[r] = s);
      } else if (t) {
        const i = Ja(e.constructor), s = n[0];
        s !== void 0 && (i[t] = s);
      } else if (r) {
        const i = r.value, s = Ja(i);
        let a, o = 0;
        for (; o < n.length; ++o)
          a = n[o], a !== void 0 && (s[o] = a);
      } else {
        const i = Ja(e);
        let s, a = 0;
        for (; a < n.length; ++a)
          s = n[a], s !== void 0 && (i[a] = s);
      }
    };
  },
  transient(n) {
    return n.register = function(e) {
      return be.transient(n, n).register(e, n);
    }, n.registerInRequestor = !1, n;
  },
  singleton(n, e = x3) {
    return n.register = function(t) {
      return be.singleton(n, n).register(t, n);
    }, n.registerInRequestor = e.scoped, n;
  }
}, No = /* @__PURE__ */ $i("IContainer"), b3 = No;
function g3(n) {
  return function(e) {
    const t = function(r, i, s) {
      m0(t)(r, i, s);
    };
    return t.$isResolver = !0, t.resolve = function(r, i) {
      return n(e, r, i);
    }, t;
  };
}
const m0 = me.inject;
function Tm(n) {
  return me.transient(n);
}
function xv(n) {
  return n == null ? Tm : Tm(n);
}
const x3 = {
  scoped: !1
}, vv = (n, e = !1) => {
  function t(r, i, s) {
    m0(t)(r, i, s);
  }
  return t.$isResolver = !0, t.resolve = (r, i) => i.getAll(n, e), t;
}, wv = /* @__PURE__ */ g3((n, e, t) => {
  if (t.has(n, !0))
    return t.get(n);
}), zd = (n, e, t) => {
  m0(zd)(n, e, t);
};
zd.$isResolver = !0;
zd.resolve = () => {
};
let fr = class {
  constructor(e, t, r) {
    this.k = e, this.R = t, this._state = r, this.resolving = !1;
  }
  get $isResolver() {
    return !0;
  }
  register(e, t) {
    return e.registerResolver(t || this.k, this);
  }
  resolve(e, t) {
    switch (this.R) {
      case 0:
        return this._state;
      case 1: {
        if (this.resolving)
          throw v3(this._state.name);
        return this.resolving = !0, this._state = e.getFactory(this._state).construct(t), this.R = 0, this.resolving = !1, this._state;
      }
      case 2: {
        const r = e.getFactory(this._state);
        if (r === null)
          throw w3(this.k);
        return r.construct(t);
      }
      case 3:
        return this._state(e, t, this);
      case 4:
        return this._state[0].resolve(e, t);
      case 5:
        return t.get(this._state);
      default:
        throw T3(this.R);
    }
  }
  getFactory(e) {
    switch (this.R) {
      case 1:
      case 2:
        return e.getFactory(this._state);
      case 5:
        return e.getResolver(this._state)?.getFactory?.(e) ?? null;
      default:
        return null;
    }
  }
};
const v3 = (n) => en(`AUR0003:${n}`), w3 = (n) => en(`AUR0004:${Io(n)}`), T3 = (n) => en(`AUR0005:${n}`);
class A3 {
  constructor(e, t) {
    this.key = e, this.params = t;
  }
  register(e) {
    e.has(this.key, !0) ? e.get(this.key).register(e, ...this.params) : e.register(...this.params.filter((t) => typeof t == "object"));
  }
}
const be = {
  instance: mv,
  singleton: y0,
  transient: a3,
  callback: o3,
  cachedCallback: u3,
  aliasTo: l3,
  defer: c3
};
class _n {
  get friendlyName() {
    return this.C;
  }
  constructor(e, t) {
    this._ = null, this.C = e, t !== void 0 && (this._ = t);
  }
  prepare(e) {
    this._ = e;
  }
  get $isResolver() {
    return !0;
  }
  resolve() {
    if (this._ == null)
      throw E3(this.C);
    return this._;
  }
  dispose() {
    this._ = null;
  }
}
const E3 = (n) => en(`AUR0013:${n}`), je = Object.freeze([]), S3 = Object.freeze({});
function oa() {
}
const gl = /* @__PURE__ */ $i("IPlatform");
var Am;
(function(n) {
  n[n.trace = 0] = "trace", n[n.debug = 1] = "debug", n[n.info = 2] = "info", n[n.warn = 3] = "warn", n[n.error = 4] = "error", n[n.fatal = 5] = "fatal", n[n.none = 6] = "none";
})(Am || (Am = {}));
var Em;
(function(n) {
  n[n.noColors = 0] = "noColors", n[n.colors = 1] = "colors";
})(Em || (Em = {}));
const b0 = /* @__PURE__ */ $i("ILogConfig", (n) => n.instance(new Tv(0, 3))), g0 = /* @__PURE__ */ $i("ISink"), C3 = /* @__PURE__ */ $i("ILogEventFactory", (n) => n.singleton(Xp)), Ra = /* @__PURE__ */ $i("ILogger", (n) => n.singleton(Pi)), _3 = /* @__PURE__ */ $i("ILogScope"), M3 = Object.freeze({
  key: Si("logger-sink-handles"),
  define(n, e) {
    return ms(this.key, e.handles, n.prototype), n;
  },
  getHandles(n) {
    return ui.get(this.key, n);
  }
}), pi = $u({
  red(n) {
    return `\x1B[31m${n}\x1B[39m`;
  },
  green(n) {
    return `\x1B[32m${n}\x1B[39m`;
  },
  yellow(n) {
    return `\x1B[33m${n}\x1B[39m`;
  },
  blue(n) {
    return `\x1B[34m${n}\x1B[39m`;
  },
  magenta(n) {
    return `\x1B[35m${n}\x1B[39m`;
  },
  cyan(n) {
    return `\x1B[36m${n}\x1B[39m`;
  },
  white(n) {
    return `\x1B[37m${n}\x1B[39m`;
  },
  grey(n) {
    return `\x1B[90m${n}\x1B[39m`;
  }
});
class Tv {
  constructor(e, t) {
    this.colorOptions = e, this.level = t;
  }
}
const Sm = function() {
  const n = [$u({
    TRC: "TRC",
    DBG: "DBG",
    INF: "INF",
    WRN: "WRN",
    ERR: "ERR",
    FTL: "FTL",
    QQQ: "???"
  }), $u({
    TRC: pi.grey("TRC"),
    DBG: pi.grey("DBG"),
    INF: pi.white("INF"),
    WRN: pi.yellow("WRN"),
    ERR: pi.red("ERR"),
    FTL: pi.red("FTL"),
    QQQ: pi.grey("???")
  })];
  return (e, t) => e <= 0 ? n[t].TRC : e <= 1 ? n[t].DBG : e <= 2 ? n[t].INF : e <= 3 ? n[t].WRN : e <= 4 ? n[t].ERR : e <= 5 ? n[t].FTL : n[t].QQQ;
}(), P3 = (n, e) => e === 0 ? n.join(".") : n.map(pi.cyan).join("."), Cm = (n, e) => e === 0 ? new Date(n).toISOString() : pi.grey(new Date(n).toISOString());
class R3 {
  constructor(e, t, r, i, s, a) {
    this.severity = e, this.message = t, this.optionalParams = r, this.scope = i, this.colorOptions = s, this.timestamp = a;
  }
  toString() {
    const { severity: e, message: t, scope: r, colorOptions: i, timestamp: s } = this;
    return r.length === 0 ? `${Cm(s, i)} [${Sm(e, i)}] ${t}` : `${Cm(s, i)} [${Sm(e, i)} ${P3(r, i)}] ${t}`;
  }
}
let Xp = class {
  constructor(e) {
    this.config = e;
  }
  createLogEvent(e, t, r, i) {
    return new R3(t, r, i, e.scope, this.config.colorOptions, Date.now());
  }
};
Xp = Li([na(0, b0)], Xp);
let _m = class Av {
  static register(e) {
    y0(g0, Av).register(e);
  }
  constructor(e) {
    const t = e.console;
    this.handleEvent = function(i) {
      const s = i.optionalParams;
      if (s === void 0 || s.length === 0) {
        const a = i.toString();
        switch (i.severity) {
          case 0:
          case 1:
            return t.debug(a);
          case 2:
            return t.info(a);
          case 3:
            return t.warn(a);
          case 4:
          case 5:
            return t.error(a);
        }
      } else {
        let a = i.toString(), o = 0;
        for (; a.includes("%s"); )
          a = a.replace("%s", String(s[o++]));
        switch (i.severity) {
          case 0:
          case 1:
            return t.debug(a, ...s.slice(o));
          case 2:
            return t.info(a, ...s.slice(o));
          case 3:
            return t.warn(a, ...s.slice(o));
          case 4:
          case 5:
            return t.error(a, ...s.slice(o));
        }
      }
    };
  }
};
_m = Li([na(0, gl)], _m);
let Pi = class Ev {
  constructor(e, t, r, i = [], s = null) {
    this.scope = i, this.O = Ei();
    let a, o, u, l, d, p;
    if (this.config = e, this.f = t, this.sinks = r, s === null) {
      this.root = this, this.parent = this, a = this.I = [], o = this.j = [], u = this.L = [], l = this.M = [], d = this.T = [], p = this.F = [];
      for (const m of r) {
        const w = M3.getHandles(m);
        (w?.includes(0) ?? !0) && a.push(m), (w?.includes(1) ?? !0) && o.push(m), (w?.includes(2) ?? !0) && u.push(m), (w?.includes(3) ?? !0) && l.push(m), (w?.includes(4) ?? !0) && d.push(m), (w?.includes(5) ?? !0) && p.push(m);
      }
    } else
      this.root = s.root, this.parent = s, a = this.I = s.I, o = this.j = s.j, u = this.L = s.L, l = this.M = s.M, d = this.T = s.T, p = this.F = s.F;
  }
  trace(e, ...t) {
    this.config.level <= 0 && this.U(this.I, 0, e, t);
  }
  debug(e, ...t) {
    this.config.level <= 1 && this.U(this.j, 1, e, t);
  }
  info(e, ...t) {
    this.config.level <= 2 && this.U(this.L, 2, e, t);
  }
  warn(e, ...t) {
    this.config.level <= 3 && this.U(this.M, 3, e, t);
  }
  error(e, ...t) {
    this.config.level <= 4 && this.U(this.T, 4, e, t);
  }
  fatal(e, ...t) {
    this.config.level <= 5 && this.U(this.F, 5, e, t);
  }
  scopeTo(e) {
    const t = this.O;
    let r = t[e];
    return r === void 0 && (r = t[e] = new Ev(this.config, this.f, void 0, this.scope.concat(e), this)), r;
  }
  U(e, t, r, i) {
    const s = fa(r) ? r() : r, a = this.f.createLogEvent(this, t, s, i);
    for (let o = 0, u = e.length; o < u; ++o)
      e[o].handleEvent(a);
  }
};
Li([Oo], Pi.prototype, "trace", null);
Li([Oo], Pi.prototype, "debug", null);
Li([Oo], Pi.prototype, "info", null);
Li([Oo], Pi.prototype, "warn", null);
Li([Oo], Pi.prototype, "error", null);
Li([Oo], Pi.prototype, "fatal", null);
Pi = Li([na(0, b0), na(1, C3), na(2, vv(g0)), na(3, wv(_3)), na(4, zd)], Pi);
$u({
  create({ level: n = 3, colorOptions: e = 0, sinks: t = [] } = {}) {
    return $u({
      register(r) {
        r.register(mv(b0, new Tv(e, n)));
        for (const i of t)
          fa(i) ? r.register(y0(g0, i)) : r.register(i);
        return r;
      }
    });
  }
});
class I3 {
  constructor(e, t) {
    this.type = e, this.cb = t;
  }
  handle(e) {
    e instanceof this.type && this.cb.call(null, e);
  }
}
const Gd = /* @__PURE__ */ $i("IEventAggregator", (n) => n.singleton(O3));
class O3 {
  constructor() {
    this.eventLookup = {}, this.messageHandlers = [];
  }
  publish(e, t) {
    if (!e)
      throw en(`Invalid channel name or instance: ${e}.`);
    if (Uc(e)) {
      let r = this.eventLookup[e];
      if (r !== void 0) {
        r = r.slice();
        let i = r.length;
        for (; i-- > 0; )
          r[i](t, e);
      }
    } else {
      const r = this.messageHandlers.slice();
      let i = r.length;
      for (; i-- > 0; )
        r[i].handle(e);
    }
  }
  subscribe(e, t) {
    if (!e)
      throw en(`Invalid channel name or type: ${e}.`);
    let r, i;
    return Uc(e) ? (this.eventLookup[e] === void 0 && (this.eventLookup[e] = []), r = t, i = this.eventLookup[e]) : (r = new I3(e, t), i = this.messageHandlers), i.push(r), {
      dispose() {
        const s = i.indexOf(r);
        s !== -1 && i.splice(s, 1);
      }
    };
  }
  subscribeOnce(e, t) {
    const r = this.subscribe(e, (i, s) => {
      r.dispose(), t(i, s);
    });
    return r;
  }
}
const Hd = Object, k3 = Hd.prototype.hasOwnProperty, pr = Reflect.defineProperty, ae = (n) => new Error(n), Fn = (n) => typeof n == "function", gu = (n) => n instanceof Hd, bs = (n) => n instanceof Array, xl = (n) => n instanceof Set, ds = (n) => n instanceof Map, Vc = Hd.is;
function Ri(n, e, t) {
  return pr(n, e, {
    enumerable: !1,
    configurable: !0,
    writable: !0,
    value: t
  }), t;
}
function vi(n, e, t) {
  e in n || Ri(n, e, t);
}
const x0 = Object.assign, Do = String, vl = me.createInterface, xu = () => Hd.create(null), v0 = ui.getOwn, w0 = ui.define;
ko.annotation.keyFor;
ko.resource.keyFor;
ko.resource.appendTo;
var Mm;
(function(n) {
  n[n.AccessThis = 0] = "AccessThis", n[n.AccessScope = 1] = "AccessScope", n[n.ArrayLiteral = 2] = "ArrayLiteral", n[n.ObjectLiteral = 3] = "ObjectLiteral", n[n.PrimitiveLiteral = 4] = "PrimitiveLiteral", n[n.Template = 5] = "Template", n[n.Unary = 6] = "Unary", n[n.CallScope = 7] = "CallScope", n[n.CallMember = 8] = "CallMember", n[n.CallFunction = 9] = "CallFunction", n[n.AccessMember = 10] = "AccessMember", n[n.AccessKeyed = 11] = "AccessKeyed", n[n.TaggedTemplate = 12] = "TaggedTemplate", n[n.Binary = 13] = "Binary", n[n.Conditional = 14] = "Conditional", n[n.Assign = 15] = "Assign", n[n.ArrowFunction = 16] = "ArrowFunction", n[n.ValueConverter = 17] = "ValueConverter", n[n.BindingBehavior = 18] = "BindingBehavior", n[n.ArrayBindingPattern = 19] = "ArrayBindingPattern", n[n.ObjectBindingPattern = 20] = "ObjectBindingPattern", n[n.BindingIdentifier = 21] = "BindingIdentifier", n[n.ForOfStatement = 22] = "ForOfStatement", n[n.Interpolation = 23] = "Interpolation", n[n.ArrayDestructuring = 24] = "ArrayDestructuring", n[n.ObjectDestructuring = 25] = "ObjectDestructuring", n[n.DestructuringAssignmentLeaf = 26] = "DestructuringAssignmentLeaf", n[n.DestructuringAssignmentRestLeaf = 27] = "DestructuringAssignmentRestLeaf", n[n.Custom = 28] = "Custom";
})(Mm || (Mm = {}));
class T0 {
  constructor(e) {
    this.value = e, this.$kind = 28;
  }
  evaluate(e, t, r) {
    return this.value;
  }
  assign(e, t, r) {
    return r;
  }
  bind(e, t) {
  }
  unbind(e, t) {
  }
  accept(e) {
  }
}
class N3 {
  constructor(e, t, r) {
    this.expression = e, this.name = t, this.args = r, this.$kind = 18, this.key = `_bb_${t}`;
  }
}
class Uu {
  constructor(e, t, r) {
    this.expression = e, this.name = t, this.args = r, this.$kind = 17;
  }
}
class D3 {
  constructor(e, t) {
    this.target = e, this.value = t, this.$kind = 15;
  }
}
class B3 {
  constructor(e, t, r) {
    this.condition = e, this.yes = t, this.no = r, this.$kind = 14;
  }
}
class Ci {
  constructor(e = 0) {
    this.ancestor = e, this.$kind = 0;
  }
}
Ci.$this = new Ci(0);
Ci.$parent = new Ci(1);
class bc {
  constructor(e, t = 0) {
    this.name = e, this.ancestor = t, this.$kind = 1;
  }
}
class Zp {
  constructor(e, t, r = !1) {
    this.object = e, this.name = t, this.optional = r, this.$kind = 10;
  }
}
class Sv {
  constructor(e, t, r = !1) {
    this.object = e, this.key = t, this.optional = r, this.$kind = 11;
  }
}
class Cv {
  constructor(e, t, r = 0, i = !1) {
    this.name = e, this.args = t, this.ancestor = r, this.optional = i, this.$kind = 7;
  }
}
class zc {
  constructor(e, t, r, i = !1, s = !1) {
    this.object = e, this.name = t, this.args = r, this.optionalMember = i, this.optionalCall = s, this.$kind = 8;
  }
}
class gc {
  constructor(e, t, r = !1) {
    this.func = e, this.args = t, this.optional = r, this.$kind = 9;
  }
}
class F3 {
  constructor(e, t, r) {
    this.operation = e, this.left = t, this.right = r, this.$kind = 13;
  }
}
class L3 {
  constructor(e, t) {
    this.operation = e, this.expression = t, this.$kind = 6;
  }
}
class cn {
  constructor(e) {
    this.value = e, this.$kind = 4;
  }
}
cn.$undefined = new cn(void 0);
cn.$null = new cn(null);
cn.$true = new cn(!0);
cn.$false = new cn(!1);
cn.$empty = new cn("");
class eh {
  constructor(e) {
    this.elements = e, this.$kind = 2;
  }
}
eh.$empty = new eh(je);
class th {
  constructor(e, t) {
    this.keys = e, this.values = t, this.$kind = 3;
  }
}
th.$empty = new th(je, je);
class Gc {
  constructor(e, t = je) {
    this.cooked = e, this.expressions = t, this.$kind = 5;
  }
}
Gc.$empty = new Gc([""]);
class _v {
  constructor(e, t, r, i = je) {
    this.cooked = e, this.func = r, this.expressions = i, this.$kind = 12, e.raw = t;
  }
}
class $3 {
  constructor(e) {
    this.elements = e, this.$kind = 19;
  }
}
class U3 {
  constructor(e, t) {
    this.keys = e, this.values = t, this.$kind = 20;
  }
}
class Hc {
  constructor(e) {
    this.name = e, this.$kind = 21;
  }
}
class j3 {
  constructor(e, t, r) {
    this.declaration = e, this.iterable = t, this.semiIdx = r, this.$kind = 22;
  }
}
class Mv {
  constructor(e, t = je) {
    this.parts = e, this.expressions = t, this.$kind = 23, this.isMulti = t.length > 1, this.firstExpression = t[0];
  }
}
class V3 {
  constructor(e, t, r, i) {
    this.$kind = e, this.list = t, this.source = r, this.initializer = i;
  }
}
class Pv {
  constructor(e, t, r) {
    this.target = e, this.source = t, this.initializer = r, this.$kind = 26;
  }
}
class nh {
  constructor(e, t, r = !1) {
    this.args = e, this.body = t, this.rest = r, this.$kind = 16;
  }
}
class Pm {
  constructor(e, t) {
    e !== void 0 && (this[e] = t);
  }
}
class dn {
  constructor(e, t, r, i) {
    this.parent = e, this.bindingContext = t, this.overrideContext = r, this.isBoundary = i;
  }
  static getContext(e, t, r) {
    if (e == null)
      throw Rm();
    let i = e.overrideContext, s = e;
    if (r > 0) {
      for (; r > 0; )
        if (r--, s = s.parent, s == null)
          return;
      return i = s.overrideContext, t in i ? i : s.bindingContext;
    }
    for (; s != null && !s.isBoundary && !(t in s.overrideContext) && !(t in s.bindingContext); )
      s = s.parent;
    return s == null ? e.bindingContext : (i = s.overrideContext, t in i ? i : s.bindingContext);
  }
  static create(e, t, r) {
    if (e == null)
      throw z3();
    return new dn(null, e, t ?? new Im(), r ?? !1);
  }
  static fromParent(e, t) {
    if (e == null)
      throw Rm();
    return new dn(e, t, new Im(), !1);
  }
}
const Rm = () => ae("AUR0203"), z3 = () => ae("AUR0204");
class Im {
}
const rh = dn.getContext;
function z(n, e, t, r) {
  switch (n.$kind) {
    case 0: {
      let i = e.overrideContext, s = e, a = n.ancestor;
      for (; a-- && i; )
        s = s.parent, i = s?.overrideContext ?? null;
      return a < 1 && s ? s.bindingContext : void 0;
    }
    case 1: {
      const i = rh(e, n.name, n.ancestor);
      r !== null && r.observe(i, n.name);
      const s = i[n.name];
      if (s == null && n.name === "$host")
        throw ae("AUR0105");
      return t?.strict ? t?.boundFn && Fn(s) ? s.bind(i) : s : s == null ? "" : t?.boundFn && Fn(s) ? s.bind(i) : s;
    }
    case 2:
      return n.elements.map((i) => z(i, e, t, r));
    case 3: {
      const i = {};
      for (let s = 0; s < n.keys.length; ++s)
        i[n.keys[s]] = z(n.values[s], e, t, r);
      return i;
    }
    case 4:
      return n.value;
    case 5: {
      let i = n.cooked[0];
      for (let s = 0; s < n.expressions.length; ++s)
        i += String(z(n.expressions[s], e, t, r)), i += n.cooked[s + 1];
      return i;
    }
    case 6:
      switch (n.operation) {
        case "void":
          return void z(n.expression, e, t, r);
        case "typeof":
          return typeof z(n.expression, e, t, r);
        case "!":
          return !z(n.expression, e, t, r);
        case "-":
          return -z(n.expression, e, t, r);
        case "+":
          return +z(n.expression, e, t, r);
        default:
          throw ae(`AUR0109:${n.operation}`);
      }
    case 7: {
      const i = n.args.map((o) => z(o, e, t, r)), s = rh(e, n.name, n.ancestor), a = Om(t?.strictFnCall, s, n.name);
      return a ? a.apply(s, i) : void 0;
    }
    case 8: {
      const i = z(n.object, e, t, r), s = n.args.map((u) => z(u, e, t, r)), a = Om(t?.strictFnCall, i, n.name);
      let o;
      return a && (o = a.apply(i, s), bs(i) && q3.includes(n.name) && r?.observeCollection(i)), o;
    }
    case 9: {
      const i = z(n.func, e, t, r);
      if (Fn(i))
        return i(...n.args.map((s) => z(s, e, t, r)));
      if (!t?.strictFnCall && i == null)
        return;
      throw ae("AUR0107");
    }
    case 16:
      return (...s) => {
        const a = n.args, o = n.rest, u = a.length - 1, l = a.reduce((p, m, w) => (o && w === u ? p[m.name] = s.slice(w) : p[m.name] = s[w], p), {}), d = dn.fromParent(e, l);
        return z(n.body, d, t, r);
      };
    case 10: {
      const i = z(n.object, e, t, r);
      let s;
      return t?.strict ? i == null ? void 0 : (r !== null && r.observe(i, n.name), s = i[n.name], t?.boundFn && Fn(s) ? s.bind(i) : s) : (r !== null && gu(i) && r.observe(i, n.name), i ? (s = i[n.name], t?.boundFn && Fn(s) ? s.bind(i) : s) : "");
    }
    case 11: {
      const i = z(n.object, e, t, r), s = z(n.key, e, t, r);
      return gu(i) ? (r !== null && r.observe(i, s), i[s]) : i?.[s];
    }
    case 12: {
      const i = n.expressions.map((a) => z(a, e, t, r)), s = z(n.func, e, t, r);
      if (!Fn(s))
        throw ae("AUR0110");
      return s(n.cooked, ...i);
    }
    case 13: {
      const i = n.left, s = n.right;
      switch (n.operation) {
        case "&&":
          return z(i, e, t, r) && z(s, e, t, r);
        case "||":
          return z(i, e, t, r) || z(s, e, t, r);
        case "??":
          return z(i, e, t, r) ?? z(s, e, t, r);
        case "==":
          return z(i, e, t, r) == z(s, e, t, r);
        case "===":
          return z(i, e, t, r) === z(s, e, t, r);
        case "!=":
          return z(i, e, t, r) != z(s, e, t, r);
        case "!==":
          return z(i, e, t, r) !== z(s, e, t, r);
        case "instanceof": {
          const a = z(s, e, t, r);
          return Fn(a) ? z(i, e, t, r) instanceof a : !1;
        }
        case "in": {
          const a = z(s, e, t, r);
          return gu(a) ? z(i, e, t, r) in a : !1;
        }
        case "+": {
          const a = z(i, e, t, r), o = z(s, e, t, r);
          if (t?.strict)
            return a + o;
          if (!a || !o) {
            if (km(a) || km(o))
              return (a || 0) + (o || 0);
            if (Nm(a) || Nm(o))
              return (a || "") + (o || "");
          }
          return a + o;
        }
        case "-":
          return z(i, e, t, r) - z(s, e, t, r);
        case "*":
          return z(i, e, t, r) * z(s, e, t, r);
        case "/":
          return z(i, e, t, r) / z(s, e, t, r);
        case "%":
          return z(i, e, t, r) % z(s, e, t, r);
        case "<":
          return z(i, e, t, r) < z(s, e, t, r);
        case ">":
          return z(i, e, t, r) > z(s, e, t, r);
        case "<=":
          return z(i, e, t, r) <= z(s, e, t, r);
        case ">=":
          return z(i, e, t, r) >= z(s, e, t, r);
        default:
          throw ae(`AUR0108:${n.operation}`);
      }
    }
    case 14:
      return z(n.condition, e, t, r) ? z(n.yes, e, t, r) : z(n.no, e, t, r);
    case 15:
      return bn(n.target, e, t, z(n.value, e, t, r));
    case 17: {
      const i = t?.getConverter?.(n.name);
      if (i == null)
        throw ae(`AUR0103:${n.name}`);
      return "toView" in i ? i.toView(z(n.expression, e, t, r), ...n.args.map((s) => z(s, e, t, r))) : z(n.expression, e, t, r);
    }
    case 18:
      return z(n.expression, e, t, r);
    case 21:
      return n.name;
    case 22:
      return z(n.iterable, e, t, r);
    case 23:
      if (n.isMulti) {
        let i = n.parts[0], s = 0;
        for (; s < n.expressions.length; ++s)
          i += Do(z(n.expressions[s], e, t, r)), i += n.parts[s + 1];
        return i;
      } else
        return `${n.parts[0]}${z(n.firstExpression, e, t, r)}${n.parts[1]}`;
    case 26:
      return z(n.target, e, t, r);
    case 24:
      return n.list.map((i) => z(i, e, t, r));
    case 19:
    case 20:
    case 25:
    default:
      return;
    case 28:
      return n.evaluate(e, t, r);
  }
}
function bn(n, e, t, r) {
  switch (n.$kind) {
    case 1: {
      if (n.name === "$host")
        throw ae("AUR0106");
      const i = rh(e, n.name, n.ancestor);
      return i[n.name] = r;
    }
    case 10: {
      const i = z(n.object, e, t, null);
      return gu(i) ? n.name === "length" && bs(i) && !isNaN(r) ? i.splice(r) : i[n.name] = r : bn(n.object, e, t, {
        [n.name]: r
      }), r;
    }
    case 11: {
      const i = z(n.object, e, t, null), s = z(n.key, e, t, null);
      if (bs(i)) {
        if (s === "length" && !isNaN(r))
          return i.splice(r), r;
        if (Lu(s))
          return i.splice(s, 1, r), r;
      }
      return i[s] = r;
    }
    case 15:
      return bn(n.value, e, t, r), bn(n.target, e, t, r);
    case 17: {
      const i = t?.getConverter?.(n.name);
      if (i == null)
        throw Rv(n.name);
      return "fromView" in i && (r = i.fromView(r, ...n.args.map((s) => z(s, e, t, null)))), bn(n.expression, e, t, r);
    }
    case 18:
      return bn(n.expression, e, t, r);
    case 24:
    case 25: {
      const i = n.list, s = i.length;
      let a, o;
      for (a = 0; a < s; a++)
        switch (o = i[a], o.$kind) {
          case 26:
            bn(o, e, t, r);
            break;
          case 24:
          case 25: {
            if (typeof r != "object" || r === null)
              throw ae("AUR0112");
            let u = z(o.source, dn.create(r), t, null);
            u === void 0 && o.initializer && (u = z(o.initializer, e, t, null)), bn(o, e, t, u);
            break;
          }
        }
      break;
    }
    case 26: {
      if (n instanceof Pv) {
        if (r == null)
          return;
        if (typeof r != "object")
          throw ae("AUR0112");
        let i = z(n.source, dn.create(r), t, null);
        i === void 0 && n.initializer && (i = z(n.initializer, e, t, null)), bn(n.target, e, t, i);
      } else {
        if (r == null)
          return;
        if (typeof r != "object")
          throw ae("AUR0112");
        const i = n.indexOrProperties;
        let s;
        if (Lu(i)) {
          if (!Array.isArray(r))
            throw ae("AUR0112");
          s = r.slice(i);
        } else
          s = Object.entries(r).reduce((a, [o, u]) => (i.includes(o) || (a[o] = u), a), {});
        bn(n.target, e, t, s);
      }
      break;
    }
    case 28:
      return n.assign(e, t, r);
    default:
      return;
  }
}
function Or(n, e, t) {
  switch (n.$kind) {
    case 18: {
      const r = n.name, i = n.key, s = t.getBehavior?.(r);
      if (s == null)
        throw G3(r);
      if (t[i] === void 0)
        t[i] = s, s.bind?.(e, t, ...n.args.map((a) => z(a, e, t, null)));
      else
        throw H3(r);
      Or(n.expression, e, t);
      return;
    }
    case 17: {
      const r = n.name, i = t.getConverter?.(r);
      if (i == null)
        throw Rv(r);
      const s = i.signals;
      if (s != null) {
        const a = t.getSignaler?.(), o = s.length;
        let u = 0;
        for (; u < o; ++u)
          a?.addSignalListener(s[u], t);
      }
      Or(n.expression, e, t);
      return;
    }
    case 22: {
      Or(n.iterable, e, t);
      break;
    }
    case 28:
      n.bind?.(e, t);
  }
}
function dr(n, e, t) {
  switch (n.$kind) {
    case 18: {
      const r = n.key, i = t;
      i[r] !== void 0 && (i[r].unbind?.(e, t), i[r] = void 0), dr(n.expression, e, t);
      break;
    }
    case 17: {
      const r = t.getConverter?.(n.name);
      if (r?.signals === void 0)
        return;
      const i = t.getSignaler?.();
      let s = 0;
      for (; s < r.signals.length; ++s)
        i?.removeSignalListener(r.signals[s], t);
      dr(n.expression, e, t);
      break;
    }
    case 22: {
      dr(n.iterable, e, t);
      break;
    }
    case 28:
      n.unbind?.(e, t);
  }
}
const G3 = (n) => ae(`AUR0101:${n}`), H3 = (n) => ae(`AUR0102:${n}`), Rv = (n) => ae(`AUR0103:${n}`), Om = (n, e, t) => {
  const r = e == null ? null : e[t];
  if (Fn(r))
    return r;
  if (!n && r == null)
    return null;
  throw ae(`AUR0111:${t}`);
}, km = (n) => {
  switch (typeof n) {
    case "number":
    case "bigint":
      return !0;
    default:
      return !1;
  }
}, Nm = (n) => {
  switch (typeof n) {
    case "string":
      return !0;
    case "object":
      return n instanceof Date;
    default:
      return !1;
  }
}, q3 = "at map filter includes indexOf lastIndexOf findIndex find flat flatMap join reduce reduceRight slice every some sort".split(" "), W3 = /* @__PURE__ */ me.createInterface("ICoercionConfiguration");
var Dm;
(function(n) {
  n[n.indexed = 8] = "indexed", n[n.keyed = 4] = "keyed", n[n.array = 9] = "array", n[n.map = 6] = "map", n[n.set = 7] = "set";
})(Dm || (Dm = {}));
var Bm;
(function(n) {
  n[n.None = 0] = "None", n[n.Observer = 1] = "Observer", n[n.Node = 2] = "Node", n[n.Layout = 4] = "Layout", n[n.Primtive = 8] = "Primtive", n[n.Array = 18] = "Array", n[n.Set = 34] = "Set", n[n.Map = 66] = "Map";
})(Bm || (Bm = {}));
function pa(n = 0) {
  const e = Array(n);
  let t = 0;
  for (; t < n; )
    e[t] = t++;
  return e.deletedIndices = [], e.deletedItems = [], e.isIndexMap = !0, e;
}
function K3(n) {
  const e = n.slice();
  return e.deletedIndices = n.deletedIndices.slice(), e.deletedItems = n.deletedItems.slice(), e.isIndexMap = !0, e;
}
function tr(n) {
  return n == null ? Fm : Fm(n);
}
function Fm(n) {
  const e = n.prototype;
  pr(e, "subs", {
    get: Q3
  }), vi(e, "subscribe", Y3), vi(e, "unsubscribe", X3);
}
class J3 {
  constructor() {
    this.count = 0, this.t = [];
  }
  add(e) {
    return this.t.includes(e) ? !1 : (this.t[this.t.length] = e, ++this.count, !0);
  }
  remove(e) {
    const t = this.t.indexOf(e);
    return t !== -1 ? (this.t.splice(t, 1), --this.count, !0) : !1;
  }
  notify(e, t) {
    const r = this.t.slice(0), i = r.length;
    let s = 0;
    for (; s < i; ++s)
      r[s].handleChange(e, t);
  }
  notifyCollection(e, t) {
    const r = this.t.slice(0), i = r.length;
    let s = 0;
    for (; s < i; ++s)
      r[s].handleCollectionChange(e, t);
  }
}
function Q3() {
  return Ri(this, "subs", new J3());
}
function Y3(n) {
  return this.subs.add(n);
}
function X3(n) {
  return this.subs.remove(n);
}
class Iv {
  constructor(e) {
    this.owner = e, this.type = 18, this.v = (this.o = e.collection).length;
  }
  getValue() {
    return this.o.length;
  }
  setValue(e) {
    e !== this.v && (Number.isNaN(e) || (this.o.splice(e), this.v = this.o.length));
  }
  handleCollectionChange(e, t) {
    const r = this.v, i = this.o.length;
    (this.v = i) !== r && this.subs.notify(this.v, r);
  }
}
class A0 {
  constructor(e) {
    this.owner = e, this.v = (this.o = e.collection).size, this.type = ds(this.o) ? 66 : 34;
  }
  getValue() {
    return this.o.size;
  }
  setValue() {
    throw ae("AUR02");
  }
  handleCollectionChange(e, t) {
    const r = this.v, i = this.o.size;
    (this.v = i) !== r && this.subs.notify(this.v, r);
  }
}
function Ov(n) {
  const e = n.prototype;
  vi(e, "subscribe", Z3), vi(e, "unsubscribe", eA), tr(n);
}
function Z3(n) {
  this.subs.add(n) && this.subs.count === 1 && this.owner.subscribe(this);
}
function eA(n) {
  this.subs.remove(n) && this.subs.count === 0 && this.owner.subscribe(this);
}
Ov(Iv);
Ov(A0);
const Lm = Symbol.for("__au_arr_obs__"), hi = Array[Lm] ?? Ri(Array, Lm, /* @__PURE__ */ new WeakMap());
function tA(n, e) {
  return n === e ? 0 : (n = n === null ? "null" : n.toString(), e = e === null ? "null" : e.toString(), n < e ? -1 : 1);
}
function nA(n, e) {
  return n === void 0 ? e === void 0 ? 0 : 1 : e === void 0 ? -1 : 0;
}
function rA(n, e, t, r, i) {
  let s, a, o, u, l, d, p;
  for (d = t + 1; d < r; d++) {
    for (s = n[d], a = e[d], p = d - 1; p >= t && (o = n[p], u = e[p], l = i(o, s), l > 0); p--)
      n[p + 1] = o, e[p + 1] = u;
    n[p + 1] = s, e[p + 1] = a;
  }
}
function qc(n, e, t, r, i) {
  let s = 0, a = 0, o, u, l, d, p, m, w, x, T, A, M, I, B, k, N, U, W, G, Y;
  for (; ; ) {
    if (r - t <= 10) {
      rA(n, e, t, r, i);
      return;
    }
    s = t + (r - t >> 1), o = n[t], d = e[t], u = n[r - 1], p = e[r - 1], l = n[s], m = e[s], w = i(o, u), w > 0 && (A = o, M = d, o = u, d = p, u = A, p = M), x = i(o, l), x >= 0 ? (A = o, M = d, o = l, d = m, l = u, m = p, u = A, p = M) : (T = i(u, l), T > 0 && (A = u, M = p, u = l, p = m, l = A, m = M)), n[t] = o, e[t] = d, n[r - 1] = l, e[r - 1] = m, I = u, B = p, k = t + 1, N = r - 1, n[s] = n[k], e[s] = e[k], n[k] = I, e[k] = B;
    e:
      for (a = k + 1; a < N; a++)
        if (U = n[a], W = e[a], G = i(U, I), G < 0)
          n[a] = n[k], e[a] = e[k], n[k] = U, e[k] = W, k++;
        else if (G > 0) {
          do {
            if (N--, N == a)
              break e;
            Y = n[N], G = i(Y, I);
          } while (G > 0);
          n[a] = n[N], e[a] = e[N], n[N] = U, e[N] = W, G < 0 && (U = n[a], W = e[a], n[a] = n[k], e[a] = e[k], n[k] = U, e[k] = W, k++);
        }
    r - N < k - t ? (qc(n, e, N, r, i), r = k) : (qc(n, e, t, k, i), t = N);
  }
}
const Ii = Array.prototype, iA = Ii.push, Yf = Ii.unshift, Xf = Ii.pop, Zf = Ii.shift, Wl = Ii.splice, sA = Ii.reverse, aA = Ii.sort, kv = ["push", "unshift", "pop", "shift", "splice", "reverse", "sort"], Nv = {
  push: function(...n) {
    const e = hi.get(this);
    if (e === void 0)
      return iA.apply(this, n);
    const t = this.length, r = n.length;
    if (r === 0)
      return t;
    this.length = e.indexMap.length = t + r;
    let i = t;
    for (; i < this.length; )
      this[i] = n[i - t], e.indexMap[i] = -2, i++;
    return e.notify(), this.length;
  },
  unshift: function(...n) {
    const e = hi.get(this);
    if (e === void 0)
      return Yf.apply(this, n);
    const t = n.length, r = new Array(t);
    let i = 0;
    for (; i < t; )
      r[i++] = -2;
    Yf.apply(e.indexMap, r);
    const s = Yf.apply(this, n);
    return e.notify(), s;
  },
  pop: function() {
    const n = hi.get(this);
    if (n === void 0)
      return Xf.call(this);
    const e = n.indexMap, t = Xf.call(this), r = e.length - 1;
    return e[r] > -1 && (e.deletedIndices.push(e[r]), e.deletedItems.push(t)), Xf.call(e), n.notify(), t;
  },
  shift: function() {
    const n = hi.get(this);
    if (n === void 0)
      return Zf.call(this);
    const e = n.indexMap, t = Zf.call(this);
    return e[0] > -1 && (e.deletedIndices.push(e[0]), e.deletedItems.push(t)), Zf.call(e), n.notify(), t;
  },
  splice: function(...n) {
    const e = n[0], t = n[1], r = hi.get(this);
    if (r === void 0)
      return Wl.apply(this, n);
    const i = this.length, s = e | 0, a = s < 0 ? Math.max(i + s, 0) : Math.min(s, i), o = r.indexMap, u = n.length, l = u === 0 ? 0 : u === 1 ? i - a : t;
    let d = a;
    if (l > 0) {
      const m = d + l;
      for (; d < m; )
        o[d] > -1 && (o.deletedIndices.push(o[d]), o.deletedItems.push(this[d])), d++;
    }
    if (d = 0, u > 2) {
      const m = u - 2, w = new Array(m);
      for (; d < m; )
        w[d++] = -2;
      Wl.call(o, e, t, ...w);
    } else
      Wl.apply(o, n);
    const p = Wl.apply(this, n);
    return (l > 0 || d > 0) && r.notify(), p;
  },
  reverse: function() {
    const n = hi.get(this);
    if (n === void 0)
      return sA.call(this), this;
    const e = this.length, t = e / 2 | 0;
    let r = 0;
    for (; r !== t; ) {
      const i = e - r - 1, s = this[r], a = n.indexMap[r], o = this[i], u = n.indexMap[i];
      this[r] = o, n.indexMap[r] = u, this[i] = s, n.indexMap[i] = a, r++;
    }
    return n.notify(), this;
  },
  sort: function(n) {
    const e = hi.get(this);
    if (e === void 0)
      return aA.call(this, n), this;
    let t = this.length;
    if (t < 2)
      return this;
    qc(this, e.indexMap, 0, t, nA);
    let r = 0;
    for (; r < t && this[r] !== void 0; )
      r++;
    (n === void 0 || !Fn(n)) && (n = tA), qc(this, e.indexMap, 0, r, n);
    let i = !1;
    for (r = 0, t = e.indexMap.length; t > r; ++r)
      if (e.indexMap[r] !== r) {
        i = !0;
        break;
      }
    return i && e.notify(), this;
  }
};
for (const n of kv)
  pr(Nv[n], "observing", {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1
  });
let $m = !1;
const Um = "__au_arr_on__";
function oA() {
  if (!(v0(Um, Array) ?? !1)) {
    w0(Um, !0, Array);
    for (const n of kv)
      Ii[n].observing !== !0 && Ri(Ii, n, Nv[n]);
  }
}
class Dv {
  constructor(e) {
    this.type = 18, $m || ($m = !0, oA()), this.indexObservers = {}, this.collection = e, this.indexMap = pa(e.length), this.lenObs = void 0, hi.set(e, this);
  }
  notify() {
    this.subs;
    const e = this.indexMap, t = this.collection, r = t.length;
    this.indexMap = pa(r), this.subs.notifyCollection(t, e);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new Iv(this));
  }
  getIndexObserver(e) {
    var t;
    return (t = this.indexObservers)[e] ?? (t[e] = new Bv(this, e));
  }
}
class Bv {
  constructor(e, t) {
    this.owner = e, this.index = t, this.doNotCache = !0, this.value = this.getValue();
  }
  getValue() {
    return this.owner.collection[this.index];
  }
  setValue(e) {
    if (e === this.getValue())
      return;
    const t = this.owner, r = this.index, i = t.indexMap;
    i[r] > -1 && i.deletedIndices.push(i[r]), i[r] = -2, t.collection[r] = e, t.notify();
  }
  handleCollectionChange(e, t) {
    const r = this.index;
    if (t[r] === r)
      return;
    const s = this.value, a = this.value = this.getValue();
    s !== a && this.subs.notify(a, s);
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && this.owner.subscribe(this);
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && this.owner.unsubscribe(this);
  }
}
tr(Dv);
tr(Bv);
function vu(n) {
  let e = hi.get(n);
  return e === void 0 && (e = new Dv(n)), e;
}
const uA = (n, e) => n - e;
function lA(n) {
  let e = 0, t = 0, r = 0;
  const i = K3(n);
  i.deletedIndices.length > 1 && i.deletedIndices.sort(uA);
  const s = i.length;
  for (; r < s; ++r) {
    for (; i.deletedIndices[t] <= r - e; )
      ++t, --e;
    i[r] === -2 ? ++e : i[r] += e;
  }
  return i;
}
function cA(n, e) {
  const t = n.slice(), r = e.length;
  let i = 0, s = 0;
  for (; i < r; )
    s = e[i], s !== -2 && (n[i] = t[s]), ++i;
}
const jm = Symbol.for("__au_set_obs__"), wu = Set[jm] ?? Ri(Set, jm, /* @__PURE__ */ new WeakMap()), ju = Set.prototype, Vm = ju.add, zm = ju.clear, Gm = ju.delete, Fv = ["add", "clear", "delete"], Lv = {
  add: function(n) {
    const e = wu.get(this);
    if (e === void 0)
      return Vm.call(this, n), this;
    const t = this.size;
    return Vm.call(this, n), this.size === t ? this : (e.indexMap[t] = -2, e.notify(), this);
  },
  clear: function() {
    const n = wu.get(this);
    if (n === void 0)
      return zm.call(this);
    if (this.size > 0) {
      const t = n.indexMap;
      let r = 0;
      for (const i of this.keys())
        t[r] > -1 && (t.deletedIndices.push(t[r]), t.deletedItems.push(i)), r++;
      zm.call(this), t.length = 0, n.notify();
    }
  },
  delete: function(n) {
    const e = wu.get(this);
    if (e === void 0)
      return Gm.call(this, n);
    if (this.size === 0)
      return !1;
    let r = 0;
    const i = e.indexMap;
    for (const s of this.keys()) {
      if (s === n) {
        i[r] > -1 && (i.deletedIndices.push(i[r]), i.deletedItems.push(s)), i.splice(r, 1);
        const a = Gm.call(this, n);
        return a === !0 && e.notify(), a;
      }
      r++;
    }
    return !1;
  }
}, dA = {
  writable: !0,
  enumerable: !1,
  configurable: !0
};
for (const n of Fv)
  pr(Lv[n], "observing", {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1
  });
let Hm = !1;
const qm = "__au_set_on__";
function fA() {
  if (!(v0(qm, Set) ?? !1)) {
    w0(qm, !0, Set);
    for (const n of Fv)
      ju[n].observing !== !0 && pr(ju, n, {
        ...dA,
        value: Lv[n]
      });
  }
}
class $v {
  constructor(e) {
    this.type = 34, Hm || (Hm = !0, fA()), this.collection = e, this.indexMap = pa(e.size), this.lenObs = void 0, wu.set(e, this);
  }
  notify() {
    this.subs;
    const e = this.indexMap, t = this.collection, r = t.size;
    this.indexMap = pa(r), this.subs.notifyCollection(t, e);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new A0(this));
  }
}
tr($v);
function Wc(n) {
  let e = wu.get(n);
  return e === void 0 && (e = new $v(n)), e;
}
const Wm = Symbol.for("__au_map_obs__"), Tu = Map[Wm] ?? Ri(Map, Wm, /* @__PURE__ */ new WeakMap()), Vu = Map.prototype, Km = Vu.set, Jm = Vu.clear, Qm = Vu.delete, Uv = ["set", "clear", "delete"], jv = {
  set: function(n, e) {
    const t = Tu.get(this);
    if (t === void 0)
      return Km.call(this, n, e), this;
    const r = this.get(n), i = this.size;
    if (Km.call(this, n, e), this.size === i) {
      let a = 0;
      for (const o of this.entries()) {
        if (o[0] === n)
          return o[1] !== r && (t.indexMap.deletedIndices.push(t.indexMap[a]), t.indexMap.deletedItems.push(o), t.indexMap[a] = -2, t.notify()), this;
        a++;
      }
      return this;
    }
    return t.indexMap[i] = -2, t.notify(), this;
  },
  clear: function() {
    const n = Tu.get(this);
    if (n === void 0)
      return Jm.call(this);
    if (this.size > 0) {
      const t = n.indexMap;
      let r = 0;
      for (const i of this.keys())
        t[r] > -1 && (t.deletedIndices.push(t[r]), t.deletedItems.push(i)), r++;
      Jm.call(this), t.length = 0, n.notify();
    }
  },
  delete: function(n) {
    const e = Tu.get(this);
    if (e === void 0)
      return Qm.call(this, n);
    if (this.size === 0)
      return !1;
    let r = 0;
    const i = e.indexMap;
    for (const s of this.keys()) {
      if (s === n) {
        i[r] > -1 && (i.deletedIndices.push(i[r]), i.deletedItems.push(s)), i.splice(r, 1);
        const a = Qm.call(this, n);
        return a === !0 && e.notify(), a;
      }
      ++r;
    }
    return !1;
  }
}, pA = {
  writable: !0,
  enumerable: !1,
  configurable: !0
};
for (const n of Uv)
  pr(jv[n], "observing", {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1
  });
let Ym = !1;
const Xm = "__au_map_on__";
function hA() {
  if (!(v0(Xm, Map) ?? !1)) {
    w0(Xm, !0, Map);
    for (const n of Uv)
      Vu[n].observing !== !0 && pr(Vu, n, {
        ...pA,
        value: jv[n]
      });
  }
}
class Vv {
  constructor(e) {
    this.type = 66, Ym || (Ym = !0, hA()), this.collection = e, this.indexMap = pa(e.size), this.lenObs = void 0, Tu.set(e, this);
  }
  notify() {
    const e = this.subs, t = this.indexMap, r = this.collection, i = r.size;
    this.indexMap = pa(i), e.notifyCollection(r, t);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new A0(this));
  }
}
tr(Vv);
function Kc(n) {
  let e = Tu.get(n);
  return e === void 0 && (e = new Vv(n)), e;
}
function yA() {
  return Ri(this, "obs", new wA(this));
}
function mA(n, e) {
  this.obs.add(this.oL.getObserver(n, e));
}
function bA(n) {
  let e;
  if (bs(n))
    e = vu(n);
  else if (xl(n))
    e = Wc(n);
  else if (ds(n))
    e = Kc(n);
  else
    throw ae("AUR0210");
  this.obs.add(e);
}
function gA(n) {
  this.obs.add(n);
}
function xA() {
  throw ae("AUR2011:handleChange");
}
function vA() {
  throw ae("AUR2011:handleCollectionChange");
}
class wA {
  constructor(e) {
    this.version = 0, this.count = 0, this.o = /* @__PURE__ */ new Map(), this.b = e;
  }
  add(e) {
    this.o.has(e) || (e.subscribe(this.b), ++this.count), this.o.set(e, this.version);
  }
  clear() {
    this.o.forEach(AA, this), this.count = this.o.size;
  }
  clearAll() {
    this.o.forEach(TA, this), this.o.clear(), this.count = 0;
  }
}
function TA(n, e) {
  e.unsubscribe(this.b);
}
function AA(n, e) {
  this.version !== n && (e.unsubscribe(this.b), this.o.delete(e));
}
function Zm(n) {
  const e = n.prototype;
  return vi(e, "observe", mA), vi(e, "observeCollection", bA), vi(e, "subscribeTo", gA), pr(e, "obs", {
    get: yA
  }), vi(e, "handleChange", xA), vi(e, "handleCollectionChange", vA), n;
}
function Fr(n) {
  return n == null ? Zm : Zm(n);
}
const E0 = vl("IExpressionParser", (n) => n.singleton(EA));
class EA {
  constructor() {
    this.i = xu(), this.u = xu(), this.h = xu();
  }
  parse(e, t) {
    let r;
    switch (t) {
      case 32:
        return new T0(e);
      case 1:
        return r = this.h[e], r === void 0 && (r = this.h[e] = this.$parse(e, t)), r;
      case 2:
        return r = this.u[e], r === void 0 && (r = this.u[e] = this.$parse(e, t)), r;
      default: {
        if (e.length === 0) {
          if ((t & 24) > 0)
            return cn.$empty;
          throw jA();
        }
        return r = this.i[e], r === void 0 && (r = this.i[e] = this.$parse(e, t)), r;
      }
    }
  }
  $parse(e, t) {
    return ke = e, Me = 0, ei = e.length, Xn = 0, ha = 0, ee = 6291456, ze = "", At = ya(0), Ne = !0, Re = !1, C0 = -1, It(61, t === void 0 ? 16 : t);
  }
}
function S0(n) {
  switch (n) {
    case 98:
      return 8;
    case 116:
      return 9;
    case 110:
      return 10;
    case 118:
      return 11;
    case 102:
      return 12;
    case 114:
      return 13;
    case 34:
      return 34;
    case 39:
      return 39;
    case 92:
      return 92;
    default:
      return n;
  }
}
const SA = cn.$false, CA = cn.$true, _A = cn.$null, zv = cn.$undefined, Au = Ci.$this, ep = Ci.$parent;
var eb;
(function(n) {
  n[n.None = 0] = "None", n[n.Interpolation = 1] = "Interpolation", n[n.IsIterator = 2] = "IsIterator", n[n.IsChainable = 4] = "IsChainable", n[n.IsFunction = 8] = "IsFunction", n[n.IsProperty = 16] = "IsProperty", n[n.IsCustom = 32] = "IsCustom";
})(eb || (eb = {}));
let ke = "", Me = 0, ei = 0, Xn = 0, ha = 0, ee = 6291456, ze = "", At, Ne = !0, Re = !1, C0 = -1;
const zu = String.fromCharCode, ya = (n) => ke.charCodeAt(n), co = () => ke.slice(ha, Me);
function It(n, e) {
  if (e === 32)
    return new T0(ke);
  if (Me === 0) {
    if (e & 1)
      return NA();
    if (de(), ee & 4194304)
      throw LA();
  }
  Ne = 513 > n, Re = !1;
  let t = !1, r, i = 0;
  if (ee & 131072) {
    const s = wc[ee & 63];
    de(), r = new L3(s, It(514, e)), Ne = !1;
  } else {
    e:
      switch (ee) {
        case 12294:
          i = Xn, Ne = !1;
          do
            switch (de(), ++i, ee) {
              case 65545:
                if (de(), !(ee & 12288))
                  throw fi();
                break;
              case 10:
              case 11:
                throw fi();
              case 2162700:
                if (Re = !0, de(), !(ee & 12288)) {
                  r = i === 0 ? Au : i === 1 ? ep : new Ci(i), t = !0;
                  break e;
                }
                break;
              default:
                if (ee & 2097152) {
                  r = i === 0 ? Au : i === 1 ? ep : new Ci(i);
                  break e;
                }
                throw $A();
            }
          while (ee === 12294);
        case 4096: {
          const s = ze;
          if (e & 2 ? r = new Hc(s) : r = new bc(s, i), Ne = !Re, de(), Sr(50)) {
            if (ee === 524296)
              throw Qv();
            const a = Re, o = Xn;
            ++Xn;
            const u = It(62, 0);
            Re = a, Xn = o, Ne = !1, r = new nh([new Hc(s)], u);
          }
          break;
        }
        case 10:
          throw QA();
        case 11:
          throw ih();
        case 12292:
          switch (Ne = !1, de(), Xn) {
            case 0:
              r = Au;
              break;
            case 1:
              r = ep;
              break;
            default:
              r = new Ci(Xn);
              break;
          }
          break;
        case 2688007:
          r = RA(e);
          break;
        case 2688016:
          r = ke.search(/\s+of\s+/) > Me ? MA() : IA(e);
          break;
        case 524296:
          r = kA(e);
          break;
        case 2163759:
          r = new Gc([ze]), Ne = !1, de();
          break;
        case 2163760:
          r = tp(e, r, !1);
          break;
        case 16384:
        case 32768:
          r = new cn(ze), Ne = !1, de();
          break;
        case 8194:
        case 8195:
        case 8193:
        case 8192:
          r = wc[ee & 63], Ne = !1, de();
          break;
        default:
          throw Me >= ei ? UA() : np();
      }
    if (e & 2)
      return OA(r);
    if (514 < n)
      return r;
    if (ee === 10 || ee === 11)
      throw fi();
    if (r.$kind === 0)
      switch (ee) {
        case 2162700:
          if (Re = !0, Ne = !1, de(), !(ee & 13312))
            throw _0();
          if (ee & 12288)
            r = new bc(ze, r.ancestor), de();
          else if (ee === 2688007)
            r = new gc(r, Gr(), !0);
          else if (ee === 2688016)
            r = xc(r, !0);
          else
            throw vc();
          break;
        case 65545:
          if (Ne = !Re, de(), !(ee & 12288))
            throw fi();
          r = new bc(ze, r.ancestor), de();
          break;
        case 10:
        case 11:
          throw fi();
        case 2688007:
          r = new gc(r, Gr(), t);
          break;
        case 2688016:
          r = xc(r, t);
          break;
        case 2163759:
          r = tb(r);
          break;
        case 2163760:
          r = tp(e, r, !0);
          break;
      }
    for (; (ee & 65536) > 0; )
      switch (ee) {
        case 2162700:
          r = PA(r);
          break;
        case 65545:
          if (de(), !(ee & 12288))
            throw fi();
          r = Gv(r, !1);
          break;
        case 10:
        case 11:
          throw fi();
        case 2688007:
          r.$kind === 1 ? r = new Cv(r.name, Gr(), r.ancestor, !1) : r.$kind === 10 ? r = new zc(r.object, r.name, Gr(), r.optional, !1) : r = new gc(r, Gr(), !1);
          break;
        case 2688016:
          r = xc(r, !1);
          break;
        case 2163759:
          if (Re)
            throw vc();
          r = tb(r);
          break;
        case 2163760:
          if (Re)
            throw vc();
          r = tp(e, r, !0);
          break;
      }
  }
  if (ee === 10 || ee === 11)
    throw fi();
  if (513 < n)
    return r;
  for (; (ee & 262144) > 0; ) {
    const s = ee;
    if ((s & 960) <= n)
      break;
    de(), r = new F3(wc[s & 63], r, It(s & 960, e)), Ne = !1;
  }
  if (63 < n)
    return r;
  if (Sr(6291478)) {
    const s = It(62, e);
    kr(6291476), r = new B3(r, s, It(62, e)), Ne = !1;
  }
  if (62 < n)
    return r;
  if (Sr(4194349)) {
    if (!Ne)
      throw VA();
    r = new D3(r, It(62, e));
  }
  if (61 < n)
    return r;
  for (; Sr(6291480); ) {
    if (ee === 6291456)
      throw zA();
    const s = ze;
    de();
    const a = new Array();
    for (; Sr(6291476); )
      a.push(It(62, e));
    r = new Uu(r, s, a);
  }
  for (; Sr(6291479); ) {
    if (ee === 6291456)
      throw GA();
    const s = ze;
    de();
    const a = new Array();
    for (; Sr(6291476); )
      a.push(It(62, e));
    r = new N3(r, s, a);
  }
  if (ee !== 6291456) {
    if ((e & 1) > 0 && ee === 7340045)
      return r;
    if ((e & 4) > 0 && ee === 6291477) {
      if (Me === ei)
        throw np();
      return C0 = Me - 1, r;
    }
    throw co() === "of" ? HA() : np();
  }
  return r;
}
function MA() {
  const n = [], e = new V3(24, n, void 0, void 0);
  let t = "", r = !0, i = 0;
  for (; r; )
    switch (de(), ee) {
      case 7340051:
        r = !1, s();
        break;
      case 6291471:
        s();
        break;
      case 4096:
        t = co();
        break;
      default:
        throw KA();
    }
  return kr(7340051), e;
  function s() {
    t !== "" ? (n.push(new Pv(new Zp(Au, t), new Sv(Au, new cn(i++)), void 0)), t = "") : i++;
  }
}
function Gr() {
  const n = Re;
  de();
  const e = [];
  for (; ee !== 7340046 && (e.push(It(62, 0)), !!Sr(6291471)); )
    ;
  return kr(7340046), Ne = !1, Re = n, e;
}
function xc(n, e) {
  const t = Re;
  return de(), n = new Sv(n, It(62, 0), e), kr(7340051), Ne = !t, Re = t, n;
}
function PA(n) {
  if (Re = !0, Ne = !1, de(), !(ee & 13312))
    throw _0();
  if (ee & 12288)
    return Gv(n, !0);
  if (ee === 2688007)
    return n.$kind === 1 ? new Cv(n.name, Gr(), n.ancestor, !0) : n.$kind === 10 ? new zc(n.object, n.name, Gr(), n.optional, !0) : new gc(n, Gr(), !0);
  if (ee === 2688016)
    return xc(n, !0);
  throw vc();
}
function Gv(n, e) {
  const t = ze;
  switch (ee) {
    case 2162700: {
      Re = !0, Ne = !1;
      const r = Me, i = ha, s = ee, a = At, o = ze, u = Ne, l = Re;
      if (de(), !(ee & 13312))
        throw _0();
      return ee === 2688007 ? new zc(n, t, Gr(), e, !0) : (Me = r, ha = i, ee = s, At = a, ze = o, Ne = u, Re = l, new Zp(n, t, e));
    }
    case 2688007:
      return Ne = !1, new zc(n, t, Gr(), e, !1);
    default:
      return Ne = !Re, de(), new Zp(n, t, e);
  }
}
function RA(n) {
  de();
  const e = Me, t = ha, r = ee, i = At, s = ze, a = Ne, o = Re, u = [];
  let l = 1, d = !1;
  e:
    for (; ; ) {
      if (ee === 11) {
        if (de(), ee !== 4096)
          throw fi();
        if (u.push(new Hc(ze)), de(), ee === 6291471)
          throw JA();
        if (ee !== 7340046 || (de(), ee !== 50))
          throw ih();
        de();
        const w = Re, x = Xn;
        ++Xn;
        const T = It(62, 0);
        return Re = w, Xn = x, Ne = !1, new nh(u, T, !0);
      }
      switch (ee) {
        case 4096:
          u.push(new Hc(ze)), de();
          break;
        case 7340046:
          de();
          break e;
        case 524296:
        case 2688016:
          de(), l = 4;
          break;
        case 6291471:
          l = 2, d = !0;
          break e;
        case 2688007:
          l = 2;
          break e;
        default:
          de(), l = 2;
          break;
      }
      switch (ee) {
        case 6291471:
          if (de(), d = !0, l === 1)
            break;
          break e;
        case 7340046:
          de();
          break e;
        case 4194349:
          l === 1 && (l = 3);
          break e;
        case 50:
          if (d)
            throw Kl();
          de(), l = 2;
          break e;
        default:
          l === 1 && (l = 2);
          break e;
      }
    }
  if (ee === 50) {
    if (l === 1) {
      if (de(), ee === 524296)
        throw Qv();
      const w = Re, x = Xn;
      ++Xn;
      const T = It(62, 0);
      return Re = w, Xn = x, Ne = !1, new nh(u, T);
    }
    throw Kl();
  } else if (l === 1 && u.length === 0)
    throw Kv(50);
  if (d)
    switch (l) {
      case 2:
        throw Kl();
      case 3:
        throw rb();
      case 4:
        throw ib();
    }
  Me = e, ha = t, ee = r, At = i, ze = s, Ne = a, Re = o;
  const p = Re, m = It(62, n);
  if (Re = p, kr(7340046), ee === 50)
    switch (l) {
      case 2:
        throw Kl();
      case 3:
        throw rb();
      case 4:
        throw ib();
    }
  return m;
}
function IA(n) {
  const e = Re;
  de();
  const t = new Array();
  for (; ee !== 7340051; )
    if (Sr(6291471)) {
      if (t.push(zv), ee === 7340051)
        break;
    } else if (t.push(It(62, n & -3)), Sr(6291471)) {
      if (ee === 7340051)
        break;
    } else
      break;
  return Re = e, kr(7340051), n & 2 ? new $3(t) : (Ne = !1, new eh(t));
}
function OA(n) {
  if (!(n.$kind & 23) || ee !== 4204593)
    throw nb();
  de();
  const e = n, t = It(61, 4);
  return new j3(e, t, C0);
}
function kA(n) {
  const e = Re, t = new Array(), r = new Array();
  for (de(); ee !== 7340045; ) {
    if (t.push(ze), ee & 49152)
      de(), kr(6291476), r.push(It(62, n & -3));
    else if (ee & 12288) {
      const i = At, s = ee, a = Me;
      de(), Sr(6291476) ? r.push(It(62, n & -3)) : (At = i, ee = s, Me = a, r.push(It(515, n & -3)));
    } else
      throw qA();
    ee !== 7340045 && kr(6291471);
  }
  return Re = e, kr(7340045), n & 2 ? new U3(t, r) : (Ne = !1, new th(t, r));
}
function NA() {
  const n = [], e = [], t = ei;
  let r = "";
  for (; Me < t; ) {
    switch (At) {
      case 36:
        if (ya(Me + 1) === 123) {
          n.push(r), r = "", Me += 2, At = ya(Me), de();
          const i = It(61, 1);
          e.push(i);
          continue;
        } else
          r += "$";
        break;
      case 92:
        r += zu(S0(xe()));
        break;
      default:
        r += zu(At);
    }
    xe();
  }
  return e.length ? (n.push(r), new Mv(n, e)) : null;
}
function tp(n, e, t) {
  const r = Re, i = [ze];
  kr(2163760);
  const s = [It(62, n)];
  for (; (ee = FA()) !== 2163759; )
    i.push(ze), kr(2163760), s.push(It(62, n));
  return i.push(ze), Ne = !1, Re = r, t ? (de(), new _v(i, i, e, s)) : (de(), new Gc(i, s));
}
function tb(n) {
  Ne = !1;
  const e = [ze];
  return de(), new _v(e, e, n);
}
function de() {
  for (; Me < ei; )
    if (ha = Me, (ee = Be[At]()) != null)
      return;
  ee = 6291456;
}
function xe() {
  return At = ya(++Me);
}
function DA() {
  for (; M0[xe()]; )
    ;
  const n = YA[ze = co()];
  return n === void 0 ? 4096 : n;
}
function Hv(n) {
  let e = At;
  if (n === !1) {
    do
      e = xe();
    while (e <= 57 && e >= 48);
    if (e !== 46)
      return ze = parseInt(co(), 10), 32768;
    if (e = xe(), Me >= ei)
      return ze = parseInt(co().slice(0, -1), 10), 32768;
  }
  if (e <= 57 && e >= 48)
    do
      e = xe();
    while (e <= 57 && e >= 48);
  else
    At = ya(--Me);
  return ze = parseFloat(co()), 32768;
}
function BA() {
  const n = At;
  xe();
  let e = 0;
  const t = new Array();
  let r = Me;
  for (; At !== n; )
    if (At === 92)
      t.push(ke.slice(r, Me)), xe(), e = S0(At), xe(), t.push(zu(e)), r = Me;
    else {
      if (Me >= ei)
        throw WA();
      xe();
    }
  const i = ke.slice(r, Me);
  return xe(), t.push(i), ze = t.join(""), 16384;
}
function qv() {
  let n = !0, e = "";
  for (; xe() !== 96; )
    if (At === 36)
      if (Me + 1 < ei && ya(Me + 1) === 123) {
        Me++, n = !1;
        break;
      } else
        e += "$";
    else if (At === 92)
      e += zu(S0(xe()));
    else {
      if (Me >= ei)
        throw Wv();
      e += zu(At);
    }
  return xe(), ze = e, n ? 2163759 : 2163760;
}
const FA = () => {
  if (Me >= ei)
    throw Wv();
  return Me--, qv();
}, Sr = (n) => ee === n ? (de(), !0) : !1, kr = (n) => {
  if (ee === n)
    de();
  else
    throw Kv(n);
}, LA = () => ae(`AUR0151:${ke}`), ih = () => ae(`AUR0152:${ke}`), fi = () => ae(`AUR0153:${ke}`), $A = () => ae(`AUR0154:${ke}`), UA = () => ae(`AUR0155:${ke}`), np = () => ae(`AUR0156:${ke}`), jA = () => ae("AUR0157"), VA = () => ae(`AUR0158:${ke}`), zA = () => ae(`AUR0159:${ke}`), GA = () => ae(`AUR0160:${ke}`), HA = () => ae(`AUR0161:${ke}`), nb = () => ae(`AUR0163:${ke}`), qA = () => ae(`AUR0164:${ke}`), WA = () => ae(`AUR0165:${ke}`), Wv = () => ae(`AUR0166:${ke}`), Kv = (n) => ae(`AUR0167:${ke}<${wc[n & 63]}`), Jv = () => {
  throw ae(`AUR0168:${ke}`);
};
Jv.notMapped = !0;
const KA = () => ae(`AUR0170:${ke}`), _0 = () => ae(`AUR0171:${ke}`), vc = () => ae(`AUR0172:${ke}`), Kl = () => ae(`AUR0173:${ke}`), rb = () => ae(`AUR0174:${ke}`), ib = () => ae(`AUR0175:${ke}`), JA = () => ae(`AUR0176:${ke}`), Qv = () => ae(`AUR0178:${ke}`), QA = () => ae(`AUR0179:${ke}`), wc = [SA, CA, _A, zv, "$this", null, "$parent", "(", "{", ".", "..", "...", "?.", "}", ")", ",", "[", "]", ":", ";", "?", "'", '"', "&", "|", "??", "||", "&&", "==", "!=", "===", "!==", "<", ">", "<=", ">=", "in", "instanceof", "+", "-", "typeof", "void", "*", "%", "/", "=", "!", 2163759, 2163760, "of", "=>"], YA = x0(/* @__PURE__ */ Object.create(null), {
  true: 8193,
  null: 8194,
  false: 8192,
  undefined: 8195,
  $this: 12292,
  $parent: 12294,
  in: 6562212,
  instanceof: 6562213,
  typeof: 139304,
  void: 139305,
  of: 4204593
}), Bo = {
  AsciiIdPart: [36, 0, 48, 58, 65, 91, 95, 0, 97, 123],
  IdStart: [36, 0, 65, 91, 95, 0, 97, 123, 170, 0, 186, 0, 192, 215, 216, 247, 248, 697, 736, 741, 7424, 7462, 7468, 7517, 7522, 7526, 7531, 7544, 7545, 7615, 7680, 7936, 8305, 0, 8319, 0, 8336, 8349, 8490, 8492, 8498, 0, 8526, 0, 8544, 8585, 11360, 11392, 42786, 42888, 42891, 42927, 42928, 42936, 42999, 43008, 43824, 43867, 43868, 43877, 64256, 64263, 65313, 65339, 65345, 65371],
  Digit: [48, 58],
  Skip: [0, 33, 127, 161]
}, Fo = (n, e, t, r) => {
  const i = t.length;
  for (let s = 0; s < i; s += 2) {
    const a = t[s];
    let o = t[s + 1];
    if (o = o > 0 ? o : a + 1, n && n.fill(r, a, o), e)
      for (let u = a; u < o; u++)
        e.add(u);
  }
}, Gn = (n) => () => (xe(), n), XA = /* @__PURE__ */ new Set();
Fo(null, XA, Bo.AsciiIdPart, !0);
const M0 = new Uint8Array(65535);
Fo(M0, null, Bo.IdStart, 1);
Fo(M0, null, Bo.Digit, 1);
const Be = new Array(65535);
Be.fill(Jv, 0, 65535);
Fo(Be, null, Bo.Skip, () => (xe(), null));
Fo(Be, null, Bo.IdStart, DA);
Fo(Be, null, Bo.Digit, () => Hv(!1));
Be[34] = Be[39] = () => BA();
Be[96] = () => qv();
Be[33] = () => xe() !== 61 ? 131118 : xe() !== 61 ? 6553949 : (xe(), 6553951);
Be[61] = () => xe() === 62 ? (xe(), 50) : At !== 61 ? 4194349 : xe() !== 61 ? 6553948 : (xe(), 6553950);
Be[38] = () => xe() !== 38 ? 6291479 : (xe(), 6553883);
Be[124] = () => xe() !== 124 ? 6291480 : (xe(), 6553818);
Be[63] = () => {
  if (xe() === 46) {
    const n = ya(Me + 1);
    return n <= 48 || n >= 57 ? (xe(), 2162700) : 6291478;
  }
  return At !== 63 ? 6291478 : (xe(), 6553753);
};
Be[46] = () => xe() <= 57 && At >= 48 ? Hv(!0) : At === 46 ? xe() !== 46 ? 10 : (xe(), 11) : 65545;
Be[60] = () => xe() !== 61 ? 6554016 : (xe(), 6554018);
Be[62] = () => xe() !== 61 ? 6554017 : (xe(), 6554019);
Be[37] = Gn(6554155);
Be[40] = Gn(2688007);
Be[41] = Gn(7340046);
Be[42] = Gn(6554154);
Be[43] = Gn(2490854);
Be[44] = Gn(6291471);
Be[45] = Gn(2490855);
Be[47] = Gn(6554156);
Be[58] = Gn(6291476);
Be[59] = Gn(6291477);
Be[91] = Gn(2688016);
Be[93] = Gn(7340051);
Be[123] = Gn(524296);
Be[125] = Gn(7340045);
let Ae = null;
const ro = [];
let Oi = !1;
function ZA() {
  Oi = !1;
}
function eE() {
  Oi = !0;
}
function P0() {
  return Ae;
}
function R0(n) {
  if (n == null)
    throw ae("AUR0206");
  if (Ae == null) {
    Ae = n, ro[0] = Ae, Oi = !0;
    return;
  }
  if (Ae === n)
    throw ae("AUR0207");
  ro.push(n), Ae = n, Oi = !0;
}
function I0(n) {
  if (n == null)
    throw ae("AUR0208");
  if (Ae !== n)
    throw ae("AUR0209");
  ro.pop(), Ae = ro.length > 0 ? ro[ro.length - 1] : null, Oi = Ae != null;
}
const tE = Object.freeze({
  get current() {
    return Ae;
  },
  get connecting() {
    return Oi;
  },
  enter: R0,
  exit: I0,
  pause: ZA,
  resume: eE
}), go = Reflect.get, nE = Object.prototype.toString, sh = /* @__PURE__ */ new WeakMap(), Yv = "__au_nw__", Xv = "__au_nw";
function Zv(n) {
  switch (nE.call(n)) {
    case "[object Object]":
      return n.constructor[Yv] !== !0;
    case "[object Array]":
    case "[object Map]":
    case "[object Set]":
      return !0;
    default:
      return !1;
  }
}
const Lo = "__raw__";
function ve(n) {
  return Zv(n) ? qd(n) : n;
}
function qd(n) {
  return sh.get(n) ?? rE(n);
}
function Oe(n) {
  return n[Lo] ?? n;
}
function Pn(n) {
  return Zv(n) && n[Lo] || n;
}
function O0(n, e) {
  return e === "constructor" || e === "__proto__" || e === "$observers" || e === Symbol.toPrimitive || e === Symbol.toStringTag || n.constructor[`${Xv}_${Do(e)}__`] === !0;
}
function rE(n) {
  const e = bs(n) ? sE : ds(n) || xl(n) ? ME : iE, t = new Proxy(n, e);
  return sh.set(n, t), sh.set(t, t), t;
}
const iE = {
  get(n, e, t) {
    if (e === Lo)
      return n;
    const r = P0();
    return !Oi || O0(n, e) || r == null ? go(n, e, t) : (r.observe(n, e), ve(go(n, e, t)));
  }
}, sE = {
  get(n, e, t) {
    if (e === Lo)
      return n;
    if (!Oi || O0(n, e) || Ae == null)
      return go(n, e, t);
    switch (e) {
      case "length":
        return Ae.observe(n, "length"), n.length;
      case "map":
        return aE;
      case "includes":
        return lE;
      case "indexOf":
        return cE;
      case "lastIndexOf":
        return dE;
      case "every":
        return oE;
      case "filter":
        return uE;
      case "find":
        return pE;
      case "findIndex":
        return fE;
      case "flat":
        return hE;
      case "flatMap":
        return yE;
      case "join":
        return mE;
      case "push":
        return gE;
      case "pop":
        return bE;
      case "reduce":
        return CE;
      case "reduceRight":
        return _E;
      case "reverse":
        return TE;
      case "shift":
        return xE;
      case "unshift":
        return vE;
      case "slice":
        return SE;
      case "splice":
        return wE;
      case "some":
        return AE;
      case "sort":
        return EE;
      case "keys":
        return e1;
      case "values":
      case Symbol.iterator:
        return ah;
      case "entries":
        return oh;
    }
    return Ae.observe(n, e), ve(go(n, e, t));
  },
  ownKeys(n) {
    return P0()?.observe(n, "length"), Reflect.ownKeys(n);
  }
};
function aE(n, e) {
  const t = Oe(this), r = t.map((i, s) => Pn(n.call(e, ve(i), s, this)));
  return Mt(Ae, t), ve(r);
}
function oE(n, e) {
  const t = Oe(this), r = t.every((i, s) => n.call(e, ve(i), s, this));
  return Mt(Ae, t), r;
}
function uE(n, e) {
  const t = Oe(this), r = t.filter((i, s) => Pn(n.call(e, ve(i), s, this)));
  return Mt(Ae, t), ve(r);
}
function lE(n) {
  const e = Oe(this), t = e.includes(Pn(n));
  return Mt(Ae, e), t;
}
function cE(n) {
  const e = Oe(this), t = e.indexOf(Pn(n));
  return Mt(Ae, e), t;
}
function dE(n) {
  const e = Oe(this), t = e.lastIndexOf(Pn(n));
  return Mt(Ae, e), t;
}
function fE(n, e) {
  const t = Oe(this), r = t.findIndex((i, s) => Pn(n.call(e, ve(i), s, this)));
  return Mt(Ae, t), r;
}
function pE(n, e) {
  const t = Oe(this), r = t.find((i, s) => n(ve(i), s, this), e);
  return Mt(Ae, t), ve(r);
}
function hE() {
  const n = Oe(this);
  return Mt(Ae, n), ve(n.flat());
}
function yE(n, e) {
  const t = Oe(this);
  return Mt(Ae, t), qd(t.flatMap((r, i) => ve(n.call(e, ve(r), i, this))));
}
function mE(n) {
  const e = Oe(this);
  return Mt(Ae, e), e.join(n);
}
function bE() {
  return ve(Oe(this).pop());
}
function gE(...n) {
  return Oe(this).push(...n);
}
function xE() {
  return ve(Oe(this).shift());
}
function vE(...n) {
  return Oe(this).unshift(...n);
}
function wE(...n) {
  return ve(Oe(this).splice(...n));
}
function TE(...n) {
  const e = Oe(this), t = e.reverse();
  return Mt(Ae, e), ve(t);
}
function AE(n, e) {
  const t = Oe(this), r = t.some((i, s) => Pn(n.call(e, ve(i), s, this)));
  return Mt(Ae, t), r;
}
function EE(n) {
  const e = Oe(this), t = e.sort(n);
  return Mt(Ae, e), ve(t);
}
function SE(n, e) {
  const t = Oe(this);
  return Mt(Ae, t), qd(t.slice(n, e));
}
function CE(n, e) {
  const t = Oe(this), r = t.reduce((i, s, a) => n(i, ve(s), a, this), e);
  return Mt(Ae, t), ve(r);
}
function _E(n, e) {
  const t = Oe(this), r = t.reduceRight((i, s, a) => n(i, ve(s), a, this), e);
  return Mt(Ae, t), ve(r);
}
const ME = {
  get(n, e, t) {
    if (e === Lo)
      return n;
    const r = P0();
    if (!Oi || O0(n, e) || r == null)
      return go(n, e, t);
    switch (e) {
      case "size":
        return r.observe(n, "size"), n.size;
      case "clear":
        return NE;
      case "delete":
        return DE;
      case "forEach":
        return PE;
      case "add":
        if (xl(n))
          return kE;
        break;
      case "get":
        if (ds(n))
          return IE;
        break;
      case "set":
        if (ds(n))
          return OE;
        break;
      case "has":
        return RE;
      case "keys":
        return e1;
      case "values":
        return ah;
      case "entries":
        return oh;
      case Symbol.iterator:
        return ds(n) ? oh : ah;
    }
    return ve(go(n, e, t));
  }
};
function PE(n, e) {
  const t = Oe(this);
  return Mt(Ae, t), t.forEach((r, i) => {
    n.call(e, ve(r), ve(i), this);
  });
}
function RE(n) {
  const e = Oe(this);
  return Mt(Ae, e), e.has(Pn(n));
}
function IE(n) {
  const e = Oe(this);
  return Mt(Ae, e), ve(e.get(Pn(n)));
}
function OE(n, e) {
  return ve(Oe(this).set(Pn(n), Pn(e)));
}
function kE(n) {
  return ve(Oe(this).add(Pn(n)));
}
function NE() {
  return ve(Oe(this).clear());
}
function DE(n) {
  return ve(Oe(this).delete(Pn(n)));
}
function e1() {
  const n = Oe(this);
  Mt(Ae, n);
  const e = n.keys();
  return {
    next() {
      const t = e.next(), r = t.value, i = t.done;
      return i ? {
        value: void 0,
        done: i
      } : {
        value: ve(r),
        done: i
      };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function ah() {
  const n = Oe(this);
  Mt(Ae, n);
  const e = n.values();
  return {
    next() {
      const t = e.next(), r = t.value, i = t.done;
      return i ? {
        value: void 0,
        done: i
      } : {
        value: ve(r),
        done: i
      };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function oh() {
  const n = Oe(this);
  Mt(Ae, n);
  const e = n.entries();
  return {
    next() {
      const t = e.next(), r = t.value, i = t.done;
      return i ? {
        value: void 0,
        done: i
      } : {
        value: [ve(r[0]), ve(r[1])],
        done: i
      };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
const Mt = (n, e) => n?.observeCollection(e), BE = Object.freeze({
  getProxy: qd,
  getRaw: Oe,
  wrap: ve,
  unwrap: Pn,
  rawKey: Lo
});
class Jc {
  constructor(e, t, r, i, s) {
    this.type = 1, this.v = void 0, this.ir = !1, this.D = !1, this.cb = void 0, this.A = void 0, this.C = void 0, this.o = e, this.O = s ? ve(e) : e, this.$get = t, this.$set = r, this.oL = i;
  }
  init(e) {
    this.v = e, this.D = !1;
  }
  getValue() {
    return this.subs.count === 0 ? this.$get.call(this.o, this.o, this) : (this.D && (this.compute(), this.D = !1), this.v);
  }
  setValue(e) {
    if (Fn(this.$set))
      this.A !== void 0 && (e = this.A.call(null, e, this.C)), Vc(e, this.v) || (this.ir = !0, this.$set.call(this.o, e), this.ir = !1, this.run());
    else
      throw ae("AUR0221");
  }
  useCoercer(e, t) {
    return this.A = e, this.C = t, !0;
  }
  useCallback(e) {
    return this.cb = e, !0;
  }
  handleChange() {
    this.D = !0, this.subs.count > 0 && this.run();
  }
  handleCollectionChange() {
    this.D = !0, this.subs.count > 0 && this.run();
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.compute(), this.D = !1);
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && (this.D = !0, this.obs.clearAll());
  }
  run() {
    if (this.ir)
      return;
    const e = this.v, t = this.compute();
    this.D = !1, Vc(t, e) || (this.cb?.(t, e), this.subs.notify(this.v, e));
  }
  compute() {
    this.ir = !0, this.obs.version++;
    try {
      return R0(this), this.v = Pn(this.$get.call(this.O, this.O, this));
    } finally {
      this.obs.clear(), this.ir = !1, I0(this);
    }
  }
}
Fr(Jc);
tr(Jc);
const t1 = vl("IDirtyChecker", (n) => n.singleton(n1)), FE = {
  timeoutsPerCheck: 25,
  disabled: !1,
  throw: !1,
  resetToDefault() {
    this.timeoutsPerCheck = 6, this.disabled = !1, this.throw = !1;
  }
}, LE = {
  persistent: !0
};
class n1 {
  constructor(e) {
    this.p = e, this.tracked = [], this.R = null, this.T = 0, this.check = () => {
      if (++this.T < FE.timeoutsPerCheck)
        return;
      this.T = 0;
      const t = this.tracked, r = t.length;
      let i, s = 0;
      for (; s < r; ++s)
        i = t[s], i.isDirty() && i.flush();
    };
  }
  createProperty(e, t) {
    return new r1(this, e, t);
  }
  addProperty(e) {
    this.tracked.push(e), this.tracked.length === 1 && (this.R = this.p.taskQueue.queueTask(this.check, LE));
  }
  removeProperty(e) {
    this.tracked.splice(this.tracked.indexOf(e), 1), this.tracked.length === 0 && (this.R.cancel(), this.R = null);
  }
}
n1.inject = [gl];
class r1 {
  constructor(e, t, r) {
    this.obj = t, this.key = r, this.type = 0, this.ov = void 0, this.P = e;
  }
  getValue() {
    return this.obj[this.key];
  }
  setValue(e) {
    throw ae(`Trying to set value for property ${Do(this.key)} in dirty checker`);
  }
  isDirty() {
    return this.ov !== this.obj[this.key];
  }
  flush() {
    const e = this.ov, t = this.getValue();
    this.ov = t, this.subs.notify(t, e);
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.ov = this.obj[this.key], this.P.addProperty(this));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && this.P.removeProperty(this);
  }
}
tr(r1);
class $E {
  get doNotCache() {
    return !0;
  }
  constructor(e, t) {
    this.type = 0, this.o = e, this.k = t;
  }
  getValue() {
    return this.o[this.k];
  }
  setValue() {
  }
  subscribe() {
  }
  unsubscribe() {
  }
}
class i1 {
  constructor() {
    this.type = 0;
  }
  getValue(e, t) {
    return e[t];
  }
  setValue(e, t, r) {
    t[r] = e;
  }
}
class k0 {
  constructor(e, t) {
    this.type = 1, this.v = void 0, this.iO = !1, this.cb = void 0, this.A = void 0, this.C = void 0, this.o = e, this.k = t;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    if (this.A !== void 0 && (e = this.A.call(void 0, e, this.C)), this.iO) {
      if (Vc(e, this.v))
        return;
      Jl = this.v, this.v = e, this.cb?.(e, Jl), this.subs.notify(e, Jl);
    } else
      this.v = this.o[this.k] = e, this.cb?.(e, Jl);
  }
  useCallback(e) {
    return this.cb = e, this.start(), !0;
  }
  useCoercer(e, t) {
    return this.A = e, this.C = t, this.start(), !0;
  }
  subscribe(e) {
    this.iO === !1 && this.start(), this.subs.add(e);
  }
  start() {
    return this.iO === !1 && (this.iO = !0, this.v = this.o[this.k], pr(this.o, this.k, {
      enumerable: !0,
      configurable: !0,
      get: x0(() => this.getValue(), {
        getObserver: () => this
      }),
      set: (e) => {
        this.setValue(e);
      }
    })), this;
  }
  stop() {
    return this.iO && (pr(this.o, this.k, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.v
    }), this.iO = !1), this;
  }
}
tr(k0);
let Jl;
const uh = new i1(), Ia = /* @__PURE__ */ vl("IObserverLocator", (n) => n.singleton(s1)), Qc = /* @__PURE__ */ vl("INodeObserverLocator", (n) => n.cachedCallback((e) => new UE()));
class UE {
  handles() {
    return !1;
  }
  getObserver() {
    return uh;
  }
  getAccessor() {
    return uh;
  }
}
class s1 {
  constructor(e, t) {
    this.$ = [], this.P = e, this.I = t;
  }
  addAdapter(e) {
    this.$.push(e);
  }
  getObserver(e, t) {
    if (e == null)
      throw VE(Do(t));
    if (!gu(e))
      return new $E(e, Fn(t) ? "" : t);
    if (Fn(t))
      return new Jc(e, t, void 0, this, !0);
    const r = a1(e);
    let i = r[t];
    return i === void 0 && (i = this.createObserver(e, t), i.doNotCache || (r[t] = i)), i;
  }
  getAccessor(e, t) {
    const r = e.$observers?.[t];
    return r !== void 0 ? r : this.I.handles(e, t, this) ? this.I.getAccessor(e, t, this) : uh;
  }
  getArrayObserver(e) {
    return vu(e);
  }
  getMapObserver(e) {
    return Kc(e);
  }
  getSetObserver(e) {
    return Wc(e);
  }
  createObserver(e, t) {
    if (this.I.handles(e, t, this))
      return this.I.getObserver(e, t, this);
    switch (t) {
      case "length":
        if (bs(e))
          return vu(e).getLengthObserver();
        break;
      case "size":
        if (ds(e))
          return Kc(e).getLengthObserver();
        if (xl(e))
          return Wc(e).getLengthObserver();
        break;
      default:
        if (bs(e) && Lu(t))
          return vu(e).getIndexObserver(Number(t));
        break;
    }
    let r = ab(e, t);
    if (r === void 0) {
      let i = sb(e);
      for (; i !== null && (r = ab(i, t), r === void 0); )
        i = sb(i);
    }
    if (r !== void 0 && !k3.call(r, "value")) {
      let i = this.U(e, t, r);
      return i == null && (i = (r.get?.getObserver ?? r.set?.getObserver)?.(e, this)), i ?? (r.configurable ? this.L(e, t, r, !0) : this.P.createProperty(e, t));
    }
    return new k0(e, t);
  }
  L(e, t, r, i) {
    const s = new Jc(e, r.get, r.set, this, !!i);
    return pr(e, t, {
      enumerable: r.enumerable,
      configurable: !0,
      get: x0(() => s.getValue(), {
        getObserver: () => s
      }),
      set: (a) => {
        s.setValue(a);
      }
    }), s;
  }
  U(e, t, r) {
    if (this.$.length > 0)
      for (const i of this.$) {
        const s = i.getObserver(e, t, r, this);
        if (s != null)
          return s;
      }
    return null;
  }
}
s1.inject = [t1, Qc];
const jE = (n) => {
  let e;
  return bs(n) ? e = vu(n) : ds(n) ? e = Kc(n) : xl(n) && (e = Wc(n)), e;
}, sb = Object.getPrototypeOf, ab = Object.getOwnPropertyDescriptor, a1 = (n) => {
  let e = n.$observers;
  return e === void 0 && pr(n, "$observers", {
    enumerable: !1,
    value: e = xu()
  }), e;
}, VE = (n) => ae(`AUR0199:${Do(n)}`);
class zE {
  constructor(e, t) {
    this.oL = e, this.fn = t, this.maxRunCount = 10, this.queued = !1, this.running = !1, this.runCount = 0, this.stopped = !1;
  }
  handleChange() {
    this.queued = !0, this.run();
  }
  handleCollectionChange() {
    this.queued = !0, this.run();
  }
  run() {
    if (this.stopped)
      throw ae("AUR0225");
    if (!this.running) {
      ++this.runCount, this.running = !0, this.queued = !1, ++this.obs.version;
      try {
        R0(this), this.fn(this);
      } finally {
        this.obs.clear(), this.running = !1, I0(this);
      }
      if (this.queued) {
        if (this.runCount > this.maxRunCount)
          throw this.runCount = 0, ae("AUR0226");
        this.run();
      } else
        this.runCount = 0;
    }
  }
  stop() {
    this.stopped = !0, this.obs.clearAll();
  }
}
Fr(zE);
class GE {
  constructor(e, t, r, i) {
    this.type = 1, this.v = void 0, this.ov = void 0, this.o = e, this.S = r, this.hs = Fn(r);
    const s = e[t];
    this.cb = Fn(s) ? s : void 0, this.v = i;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.hs && (e = this.S(e)), Vc(e, this.v) || (this.ov = this.v, this.v = e, this.cb?.call(this.o, this.v, this.ov), e = this.ov, this.ov = this.v, this.subs.notify(this.v, e));
  }
}
tr(GE);
function HE(n, e) {
  if (n == null)
    return (r, i) => t(r, i);
  return t(n, e);
  function t(r, i) {
    !i ? Ri(r, Yv, !0) : Ri(r.constructor, `${Xv}_${Do(i)}__`, !0);
  }
}
const Wd = vl("ISignaler", (n) => n.singleton(qE));
class qE {
  constructor() {
    this.signals = xu();
  }
  dispatchSignal(e) {
    const t = this.signals[e];
    if (t === void 0)
      return;
    let r;
    for (r of t.keys())
      r.handleChange(void 0, void 0);
  }
  addSignalListener(e, t) {
    const r = this.signals, i = r[e];
    i === void 0 ? r[e] = /* @__PURE__ */ new Set([t]) : i.add(t);
  }
  removeSignalListener(e, t) {
    this.signals[e]?.delete(t);
  }
}
class WE extends Error {
  constructor(e) {
    super("Task was canceled."), this.task = e;
  }
}
var ob;
(function(n) {
  n[n.pending = 0] = "pending", n[n.running = 1] = "running", n[n.completed = 2] = "completed", n[n.canceled = 3] = "canceled";
})(ob || (ob = {}));
var ub;
(function(n) {
  n[n.render = 0] = "render", n[n.macroTask = 1] = "macroTask", n[n.postRender = 2] = "postRender";
})(ub || (ub = {}));
function Z(n, e, t, r) {
  var i = arguments.length, s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, r);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (a = n[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function wn(n, e) {
  return function(t, r) {
    e(t, r, n);
  };
}
const Rn = ui.getOwn, Kd = ui.hasOwn, Ft = ui.define, { annotation: N0, resource: o1 } = ko, Hn = N0.keyFor, $o = o1.keyFor, Oa = o1.appendTo, u1 = N0.appendTo, KE = N0.getKeys, Ss = Object, gs = String, D0 = Ss.prototype, Jn = () => Ss.create(null), se = (n) => new Error(n), fs = D0.hasOwnProperty, Ui = Ss.freeze, Jd = Ss.assign, l1 = Ss.getOwnPropertyNames, c1 = Ss.keys, lb = /* @__PURE__ */ Jn(), cb = (n, e, t) => {
  if (lb[e] === !0)
    return !0;
  if (!Et(e))
    return !1;
  const r = e.slice(0, 5);
  return lb[e] = r === "aria-" || r === "data-" || t.isStandardSvgAttribute(n, e);
}, un = (n) => n instanceof Promise, ti = (n) => n instanceof Array, Nr = (n) => typeof n == "function", Et = (n) => typeof n == "string", JE = Ss.defineProperty, Yc = (n) => {
  throw n;
}, Qd = Ss.is, lh = Reflect.defineProperty, Pr = (n, e, t) => (lh(n, e, {
  enumerable: !1,
  configurable: !0,
  writable: !0,
  value: t
}), t), d1 = (n, e, t) => n.addSignalListener(e, t), f1 = (n, e, t) => n.removeSignalListener(e, t);
function Ue(n, e) {
  let t;
  function r(i, s) {
    arguments.length > 1 && (t.property = s), Ft(io, ia.create(s, i, t), i.constructor, s), u1(i.constructor, as.keyFrom(s));
  }
  if (arguments.length > 1) {
    t = {}, r(n, e);
    return;
  } else if (Et(n))
    return t = {}, r;
  return t = n === void 0 ? {} : n, r;
}
function QE(n) {
  return n.startsWith(io);
}
const io = /* @__PURE__ */ Hn("bindable"), as = Ui({
  name: io,
  keyFrom: (n) => `${io}:${n}`,
  from(n, ...e) {
    const t = {}, r = Array.isArray;
    function i(o) {
      t[o] = ia.create(o, n);
    }
    function s(o, u) {
      t[o] = u instanceof ia ? u : ia.create(o, n, u);
    }
    function a(o) {
      r(o) ? o.forEach(i) : o instanceof ia ? t[o.property] = o : o !== void 0 && c1(o).forEach((u) => s(u, o[u]));
    }
    return e.forEach(a), t;
  },
  getAll(n) {
    const e = io.length + 1, t = [], r = z5(n);
    let i = r.length, s = 0, a, o, u, l;
    for (; --i >= 0; )
      for (u = r[i], a = KE(u).filter(QE), o = a.length, l = 0; l < o; ++l)
        t[s++] = Rn(io, u, a[l].slice(e));
    return t;
  }
});
class ia {
  constructor(e, t, r, i, s, a) {
    this.attribute = e, this.callback = t, this.mode = r, this.primary = i, this.property = s, this.set = a;
  }
  static create(e, t, r = {}) {
    return new ia(r.attribute ?? hv(e), r.callback ?? `${e}Changed`, r.mode ?? 2, r.primary ?? !1, r.property ?? e, r.set ?? YE(e, t, r));
  }
}
const ch = {
  key: /* @__PURE__ */ Hn("coercer"),
  define(n, e) {
    Ft(ch.key, n[e].bind(n), n);
  },
  for(n) {
    return Rn(ch.key, n);
  }
};
function YE(n, e, t = {}) {
  const r = t.type ?? ui.get("design:type", e, n) ?? null;
  if (r == null)
    return oa;
  let i;
  switch (r) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
      i = r;
      break;
    default: {
      const s = r.coerce;
      i = typeof s == "function" ? s.bind(r) : ch.for(r) ?? oa;
      break;
    }
  }
  return i === oa ? i : XE(i, t.nullable);
}
function XE(n, e) {
  return function(t, r) {
    return r?.enableCoercion ? (e ?? !(r?.coerceNullish ?? !1)) && t == null ? t : n(t, r) : t;
  };
}
const db = (n) => {
  function e(t, r, i) {
    me.inject(e)(t, r, i);
  }
  return e.$isResolver = !0, e.resolve = (t, r) => r.has(n, !1) ? r.get(n) : r.root.get(n), e;
}, ZE = (n) => Jd(function e(t, r, i) {
  me.inject(e)(t, r, i);
}, {
  $isResolver: !0,
  resolve: (e, t) => t.has(n, !1) ? t.get(n) : t.root.has(n, !1) ? t.root.get(n) : void 0
}), $t = me.createInterface, Uo = be.singleton, wl = be.aliasTo, p1 = be.transient, Jt = (n, e, t) => n.registerResolver(e, t);
function e8(...n) {
  return function(e) {
    const t = Hn("aliases"), r = Rn(t, e);
    r === void 0 ? Ft(t, n, e) : r.push(...n);
  };
}
function Tl(n, e, t, r) {
  for (let i = 0, s = n.length; i < s; ++i)
    be.aliasTo(t, e.keyFrom(n[i])).register(r);
}
function qn(n) {
  return function(e) {
    return Xc.define(n, e);
  };
}
class B0 {
  constructor(e, t, r, i) {
    this.Type = e, this.name = t, this.aliases = r, this.key = i;
  }
  static create(e, t) {
    let r, i;
    return Et(e) ? (r = e, i = {
      name: r
    }) : (r = e.name, i = e), new B0(t, os(dh(t, "name"), r), jt(dh(t, "aliases"), i.aliases, t.aliases), Xc.keyFrom(r));
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    Uo(r, t).register(e), wl(r, t).register(e), Tl(i, Xc, r, e);
  }
}
const Ks = $o("binding-behavior"), dh = (n, e) => Rn(Hn(e), n), Xc = Ui({
  name: Ks,
  keyFrom(n) {
    return `${Ks}:${n}`;
  },
  isType(n) {
    return Nr(n) && Kd(Ks, n);
  },
  define(n, e) {
    const t = B0.create(n, e);
    return Ft(Ks, t, t.Type), Ft(Ks, t, t), Oa(e, Ks), t.Type;
  },
  getDefinition(n) {
    const e = Rn(Ks, n);
    if (e === void 0)
      throw se(`AUR0151:${n.name}`);
    return e;
  },
  annotate(n, e, t) {
    Ft(Hn(e), t, n);
  },
  getAnnotation: dh
}), rp = /* @__PURE__ */ new Map();
class Yd {
  bind(e, t) {
    rp.set(t, t.mode), t.mode = this.mode;
  }
  unbind(e, t) {
    t.mode = rp.get(t), rp.delete(t);
  }
}
class t8 extends Yd {
  get mode() {
    return 1;
  }
}
class n8 extends Yd {
  get mode() {
    return 2;
  }
}
class r8 extends Yd {
  get mode() {
    return 4;
  }
}
class i8 extends Yd {
  get mode() {
    return 6;
  }
}
qn("oneTime")(t8);
qn("toView")(n8);
qn("fromView")(r8);
qn("twoWay")(i8);
const ip = /* @__PURE__ */ new WeakMap(), s8 = 200;
class h1 {
  constructor(e) {
    this.p = e;
  }
  bind(e, t, r, i) {
    const s = {
      type: "debounce",
      delay: r ?? s8,
      now: this.p.performanceNow,
      queue: this.p.taskQueue,
      signals: Et(i) ? [i] : i ?? je
    }, a = t.limit?.(s);
    a == null || ip.set(t, a);
  }
  unbind(e, t) {
    ip.get(t)?.dispose(), ip.delete(t);
  }
}
h1.inject = [gl];
qn("debounce")(h1);
class y1 {
  constructor(e) {
    this.i = /* @__PURE__ */ new Map(), this.u = e;
  }
  bind(e, t, ...r) {
    if (!("handleChange" in t))
      throw se("AUR0817");
    if (r.length === 0)
      throw se("AUR0818");
    this.i.set(t, r);
    let i;
    for (i of r)
      d1(this.u, i, t);
  }
  unbind(e, t) {
    const r = this.i.get(t);
    this.i.delete(t);
    let i;
    for (i of r)
      f1(this.u, i, t);
  }
}
y1.inject = [Wd];
qn("signal")(y1);
const sp = /* @__PURE__ */ new WeakMap(), a8 = 200;
class m1 {
  constructor(e) {
    this.A = e.performanceNow, this.C = e.taskQueue;
  }
  bind(e, t, r, i) {
    const s = {
      type: "throttle",
      delay: r ?? a8,
      now: this.A,
      queue: this.C,
      signals: Et(i) ? [i] : i ?? je
    }, a = t.limit?.(s);
    a == null || sp.set(t, a);
  }
  unbind(e, t) {
    sp.get(t)?.dispose(), sp.delete(t);
  }
}
m1.inject = [gl];
qn("throttle")(m1);
const ji = gl, o8 = "au-start", u8 = "au-end", fb = (n, e) => n.document.createComment(e), l8 = (n) => {
  const e = fb(n, u8);
  return e.$start = fb(n, o8), e;
}, c8 = (n, e) => n.document.createTextNode(e), d8 = (n, e, t) => n.insertBefore(e, t), Ql = (n, e, t) => {
  if (n === null)
    return;
  const r = t.length;
  let i = 0;
  for (; r > i; )
    n.insertBefore(t[i], e), ++i;
}, f8 = (n) => {
  const e = n.previousSibling;
  let t;
  if (e?.nodeType === 8 && e.textContent === "au-end") {
    if (t = e, (t.$start = t.previousSibling) == null)
      throw pb();
    return n.parentNode?.removeChild(n), t;
  } else
    throw pb();
}, F0 = (n, e) => new n.ownerDocument.defaultView.MutationObserver(e), pb = () => se("AURxxxx");
class p8 {
}
function fu(n, e) {
  return n.$au?.[e] ?? null;
}
function En(n, e, t) {
  var r;
  ((r = n).$au ?? (r.$au = new p8()))[e] = t;
}
const Xd = /* @__PURE__ */ $t("INode"), In = /* @__PURE__ */ $t("IRenderLocation"), hb = /* @__PURE__ */ $t("CssModules"), Zc = /* @__PURE__ */ new WeakMap();
function fh(n) {
  if (Zc.has(n))
    return Zc.get(n);
  let e = 0, t = n.nextSibling;
  for (; t !== null; ) {
    if (t.nodeType === 8)
      switch (t.textContent) {
        case "au-start":
          ++e;
          break;
        case "au-end":
          if (e-- === 0)
            return t;
      }
    t = t.nextSibling;
  }
  if (n.parentNode === null && n.nodeType === 11) {
    const r = la(n);
    if (r === void 0)
      return null;
    if (r.mountTarget === 2)
      return fh(r.host);
  }
  return n.parentNode;
}
function h8(n, e) {
  if (n.platform !== void 0 && !(n instanceof n.platform.Node)) {
    const t = n.childNodes;
    for (let r = 0, i = t.length; r < i; ++r)
      Zc.set(t[r], e);
  } else
    Zc.set(n, e);
}
function L0(n) {
  if (ed(n))
    return n;
  const e = n.ownerDocument.createComment("au-end"), t = e.$start = n.ownerDocument.createComment("au-start"), r = n.parentNode;
  return r !== null && (r.replaceChild(e, n), r.insertBefore(t, e)), e;
}
function ed(n) {
  return n.textContent === "au-end";
}
class ap {
  get firstChild() {
    return this.R;
  }
  get lastChild() {
    return this.B;
  }
  constructor(e, t) {
    this.platform = e, this.next = void 0, this._ = !1, this.T = !1, this.ref = null, this.f = t;
    const r = t.querySelectorAll(".au");
    let i = 0, s = r.length, a, o = this.t = Array(s);
    for (; s > i; )
      a = r[i], a.nodeName === "AU-M" ? o[i] = f8(a) : o[i] = a, ++i;
    const u = t.childNodes, l = this.childNodes = Array(s = u.length);
    for (i = 0; s > i; )
      l[i] = u[i], ++i;
    this.R = t.firstChild, this.B = t.lastChild;
  }
  findTargets() {
    return this.t;
  }
  insertBefore(e) {
    if (this.T && this.ref)
      this.addToLinked();
    else {
      const t = e.parentNode;
      if (this._) {
        let r = this.R, i;
        const s = this.B;
        for (; r != null && (i = r.nextSibling, t.insertBefore(r, e), r !== s); )
          r = i;
      } else
        this._ = !0, e.parentNode.insertBefore(this.f, e);
    }
  }
  appendTo(e, t = !1) {
    if (this._) {
      let r = this.R, i;
      const s = this.B;
      for (; r != null && (i = r.nextSibling, e.appendChild(r), r !== s); )
        r = i;
    } else
      this._ = !0, t || e.appendChild(this.f);
  }
  remove() {
    if (this._) {
      this._ = !1;
      const e = this.f, t = this.B;
      let r, i = this.R;
      for (; i !== null && (r = i.nextSibling, e.appendChild(i), i !== t); )
        i = r;
    }
  }
  addToLinked() {
    const e = this.ref, t = e.parentNode;
    if (this._) {
      let r = this.R, i;
      const s = this.B;
      for (; r != null && (i = r.nextSibling, t.insertBefore(r, e), r !== s); )
        r = i;
    } else
      this._ = !0, t.insertBefore(this.f, e);
  }
  unlink() {
    this.T = !1, this.next = void 0, this.ref = void 0;
  }
  link(e) {
    this.T = !0, ed(e) ? this.ref = e : (this.next = e, this.I());
  }
  I() {
    this.next !== void 0 ? this.ref = this.next.firstChild : this.ref = void 0;
  }
}
const $0 = (n, e, t) => (Jt(n, e.HTMLElement, Jt(n, e.Element, Jt(n, Xd, new _n("ElementResolver", t)))), n);
function b1(n) {
  return function(e) {
    return V0(n, e);
  };
}
function mr(n) {
  return function(e) {
    return V0(Et(n) ? {
      isTemplateController: !0,
      name: n
    } : {
      isTemplateController: !0,
      ...n
    }, e);
  };
}
class U0 {
  get type() {
    return 2;
  }
  constructor(e, t, r, i, s, a, o, u, l, d) {
    this.Type = e, this.name = t, this.aliases = r, this.key = i, this.defaultBindingMode = s, this.isTemplateController = a, this.bindables = o, this.noMultiBindings = u, this.watches = l, this.dependencies = d;
  }
  static create(e, t) {
    let r, i;
    return Et(e) ? (r = e, i = {
      name: r
    }) : (r = e.name, i = e), new U0(t, os(ns(t, "name"), r), jt(ns(t, "aliases"), i.aliases, t.aliases), j0(r), os(ns(t, "defaultBindingMode"), i.defaultBindingMode, t.defaultBindingMode, 2), os(ns(t, "isTemplateController"), i.isTemplateController, t.isTemplateController, !1), as.from(t, ...as.getAll(t), ns(t, "bindables"), t.bindables, i.bindables), os(ns(t, "noMultiBindings"), i.noMultiBindings, t.noMultiBindings, !1), jt(hh.getAnnotation(t), t.watches), jt(ns(t, "dependencies"), i.dependencies, t.dependencies));
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    p1(r, t).register(e), wl(r, t).register(e), Tl(i, z0, r, e);
  }
}
const ua = $o("custom-attribute"), j0 = (n) => `${ua}:${n}`, ns = (n, e) => Rn(Hn(e), n), y8 = (n) => Nr(n) && Kd(ua, n), g1 = (n, e) => fu(n, j0(e)) ?? void 0, V0 = (n, e) => {
  const t = U0.create(n, e);
  return Ft(ua, t, t.Type), Ft(ua, t, t), Oa(e, ua), t.Type;
}, ph = (n) => {
  const e = Rn(ua, n);
  if (e === void 0)
    throw se(`AUR0759:${n.name}`);
  return e;
}, z0 = Ui({
  name: ua,
  keyFrom: j0,
  isType: y8,
  for: g1,
  define: V0,
  getDefinition: ph,
  annotate(n, e, t) {
    Ft(Hn(e), t, n);
  },
  getAnnotation: ns
}), m8 = je, Yl = Hn("watch"), hh = Ui({
  name: Yl,
  add(n, e) {
    let t = Rn(Yl, n);
    t == null && Ft(Yl, t = [], n), t.push(e);
  },
  getAnnotation(n) {
    return Rn(Yl, n) ?? m8;
  }
});
function x1(n) {
  return function(e) {
    return v1(n, e);
  };
}
const op = /* @__PURE__ */ new WeakMap();
class Hr {
  get type() {
    return 1;
  }
  constructor(e, t, r, i, s, a, o, u, l, d, p, m, w, x, T, A, M, I, B, k) {
    this.Type = e, this.name = t, this.aliases = r, this.key = i, this.cache = s, this.capture = a, this.template = o, this.instructions = u, this.dependencies = l, this.injectable = d, this.needsCompile = p, this.surrogates = m, this.bindables = w, this.containerless = x, this.isStrictBinding = T, this.shadowOptions = A, this.hasSlots = M, this.enhance = I, this.watches = B, this.processContent = k;
  }
  static create(e, t = null) {
    if (t === null) {
      const i = e;
      if (Et(i))
        throw se(`AUR0761:${e}`);
      const s = kn("name", i, yh);
      return Nr(i.Type) ? t = i.Type : t = w1(V5(s)), new Hr(t, s, jt(i.aliases), kn("key", i, () => Tc(s)), kn("cache", i, up), kn("capture", i, An), kn("template", i, sr), jt(i.instructions), jt(i.dependencies), kn("injectable", i, sr), kn("needsCompile", i, lp), jt(i.surrogates), as.from(t, i.bindables), kn("containerless", i, An), kn("isStrictBinding", i, An), kn("shadowOptions", i, sr), kn("hasSlots", i, An), kn("enhance", i, An), kn("watches", i, g8), ir("processContent", t, sr));
    }
    if (Et(e))
      return new Hr(t, e, jt(Ar(t, "aliases"), t.aliases), Tc(e), ir("cache", t, up), ir("capture", t, An), ir("template", t, sr), jt(Ar(t, "instructions"), t.instructions), jt(Ar(t, "dependencies"), t.dependencies), ir("injectable", t, sr), ir("needsCompile", t, lp), jt(Ar(t, "surrogates"), t.surrogates), as.from(t, ...as.getAll(t), Ar(t, "bindables"), t.bindables), ir("containerless", t, An), ir("isStrictBinding", t, An), ir("shadowOptions", t, sr), ir("hasSlots", t, An), ir("enhance", t, An), jt(hh.getAnnotation(t), t.watches), ir("processContent", t, sr));
    const r = kn("name", e, yh);
    return new Hr(t, r, jt(Ar(t, "aliases"), e.aliases, t.aliases), Tc(r), xr("cache", e, t, up), xr("capture", e, t, An), xr("template", e, t, sr), jt(Ar(t, "instructions"), e.instructions, t.instructions), jt(Ar(t, "dependencies"), e.dependencies, t.dependencies), xr("injectable", e, t, sr), xr("needsCompile", e, t, lp), jt(Ar(t, "surrogates"), e.surrogates, t.surrogates), as.from(t, ...as.getAll(t), Ar(t, "bindables"), t.bindables, e.bindables), xr("containerless", e, t, An), xr("isStrictBinding", e, t, An), xr("shadowOptions", e, t, sr), xr("hasSlots", e, t, An), xr("enhance", e, t, An), jt(e.watches, hh.getAnnotation(t), t.watches), xr("processContent", e, t, sr));
  }
  static getOrCreate(e) {
    if (e instanceof Hr)
      return e;
    if (op.has(e))
      return op.get(e);
    const t = Hr.create(e);
    return op.set(e, t), Ft(Zt, t, t.Type), t;
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    e.has(r, !1) || (p1(r, t).register(e), wl(r, t).register(e), Tl(i, fo, r, e));
  }
}
const b8 = {
  name: void 0,
  searchParents: !1,
  optional: !1
}, up = () => 0, sr = () => null, An = () => !1, lp = () => !0, g8 = () => je, Zt = /* @__PURE__ */ $o("custom-element"), Tc = (n) => `${Zt}:${n}`, yh = /* @__PURE__ */ (() => {
  let n = 0;
  return () => `unnamed-${++n}`;
})(), x8 = (n, e, t) => {
  Ft(Hn(e), t, n);
}, v1 = (n, e) => {
  const t = Hr.create(n, e);
  return Ft(Zt, t, t.Type), Ft(Zt, t, t), Oa(t.Type, Zt), t.Type;
}, v8 = (n) => Nr(n) && Kd(Zt, n), la = (n, e = b8) => {
  if (e.name === void 0 && e.searchParents !== !0) {
    const r = fu(n, Zt);
    if (r === null) {
      if (e.optional === !0)
        return null;
      throw se("AUR0762");
    }
    return r;
  }
  if (e.name !== void 0) {
    if (e.searchParents !== !0) {
      const s = fu(n, Zt);
      if (s === null)
        throw se("AUR0763");
      return s.is(e.name) ? s : void 0;
    }
    let r = n, i = !1;
    for (; r !== null; ) {
      const s = fu(r, Zt);
      if (s !== null && (i = !0, s.is(e.name)))
        return s;
      r = fh(r);
    }
    if (i)
      return;
    throw se("AUR0764");
  }
  let t = n;
  for (; t !== null; ) {
    const r = fu(t, Zt);
    if (r !== null)
      return r;
    t = fh(t);
  }
  throw se("AUR0765");
}, Ar = (n, e) => Rn(Hn(e), n), mh = (n) => {
  const e = Rn(Zt, n);
  if (e === void 0)
    throw se(`AUR0760:${n.name}`);
  return e;
}, w8 = () => {
  const n = function(e, t, r) {
    const i = me.getOrCreateAnnotationParamTypes(e);
    return i[r] = n, e;
  };
  return n.register = function(e) {
    return {
      resolve(t, r) {
        return r.has(n, !0) ? r.get(n) : null;
      }
    };
  }, n;
}, w1 = /* @__PURE__ */ function() {
  const n = {
    value: "",
    writable: !1,
    enumerable: !1,
    configurable: !0
  }, e = {};
  return function(t, r = e) {
    const i = class {
    };
    return n.value = t, Reflect.defineProperty(i, "name", n), r !== e && Jd(i.prototype, r), i;
  };
}(), fo = Ui({
  name: Zt,
  keyFrom: Tc,
  isType: v8,
  for: la,
  define: v1,
  getDefinition: mh,
  annotate: x8,
  getAnnotation: Ar,
  generateName: yh,
  createInjectable: w8,
  generateType: w1
}), yb = (n, e, t, r) => {
  n.addEventListener(e, t, r);
}, mb = (n, e, t, r) => {
  n.removeEventListener(e, t, r);
}, G0 = (n) => {
  let e;
  const t = n.prototype;
  Pr(t, "subscribe", function(r) {
    if (this.subs.add(r) && this.subs.count === 1) {
      for (e of this.cf.events)
        yb(this.P, e, this);
      this.L = !0, this.M?.();
    }
  }), Pr(t, "unsubscribe", function(r) {
    if (this.subs.remove(r) && this.subs.count === 0) {
      for (e of this.cf.events)
        mb(this.P, e, this);
      this.L = !1, this.$?.();
    }
  }), Pr(t, "useConfig", function(r) {
    if (this.cf = r, this.L) {
      for (e of this.cf.events)
        mb(this.P, e, this);
      for (e of this.cf.events)
        yb(this.P, e, this);
    }
  });
}, Zd = (n) => {
  Pr(n.prototype, "subscribe", oa), Pr(n.prototype, "unsubscribe", oa);
};
class T1 {
  get doNotCache() {
    return !0;
  }
  constructor(e) {
    this.obj = e, this.type = 6, this.value = "", this.ov = "", this.U = {}, this.q = 0, this.F = !1;
  }
  getValue() {
    return this.value;
  }
  setValue(e) {
    this.value = e, this.F = e !== this.ov, this.H();
  }
  H() {
    if (this.F) {
      this.F = !1;
      const e = this.value, t = this.U, r = A1(e);
      let i = this.q;
      if (this.ov = e, r.length > 0 && this.O(r), this.q += 1, i === 0)
        return;
      i -= 1;
      for (const s in t)
        !fs.call(t, s) || t[s] !== i || this.obj.classList.remove(s);
    }
  }
  O(e) {
    const t = this.obj, r = e.length;
    let i = 0, s;
    for (; i < r; i++)
      s = e[i], s.length !== 0 && (this.U[s] = this.q, t.classList.add(s));
  }
}
function A1(n) {
  if (Et(n))
    return bb(n);
  if (typeof n != "object")
    return je;
  if (n instanceof Array) {
    const r = n.length;
    if (r > 0) {
      const i = [];
      let s = 0;
      for (; r > s; ++s)
        i.push(...A1(n[s]));
      return i;
    } else
      return je;
  }
  const e = [];
  let t;
  for (t in n)
    n[t] && (t.includes(" ") ? e.push(...bb(t)) : e.push(t));
  return e;
}
function bb(n) {
  const e = n.match(/\S+/g);
  return e === null ? je : e;
}
Zd(T1);
const gb = /* @__PURE__ */ $t("IShadowDOMStyles"), T8 = /* @__PURE__ */ $t("IShadowDOMGlobalStyles", (n) => n.instance({
  applyTo: oa
}));
function Al(n) {
  return function(e) {
    return td.define(n, e);
  };
}
class H0 {
  constructor(e, t, r, i) {
    this.Type = e, this.name = t, this.aliases = r, this.key = i;
  }
  static create(e, t) {
    let r, i;
    return Et(e) ? (r = e, i = {
      name: r
    }) : (r = e.name, i = e), new H0(t, os(bh(t, "name"), r), jt(bh(t, "aliases"), i.aliases, t.aliases), td.keyFrom(r));
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    be.singleton(r, t).register(e), be.aliasTo(r, t).register(e), Tl(i, td, r, e);
  }
}
const Js = $o("value-converter"), bh = (n, e) => Rn(Hn(e), n), td = Ui({
  name: Js,
  keyFrom: (n) => `${Js}:${n}`,
  isType(n) {
    return Nr(n) && Kd(Js, n);
  },
  define(n, e) {
    const t = H0.create(n, e);
    return Ft(Js, t, t.Type), Ft(Js, t, t), Oa(e, Js), t.Type;
  },
  getDefinition(n) {
    const e = Rn(Js, n);
    if (e === void 0)
      throw se(`AUR0152:${n.name}`);
    return e;
  },
  annotate(n, e, t) {
    Ft(Hn(e), t, n);
  },
  getAnnotation: bh
});
class A8 {
  constructor(e, t) {
    this.v = void 0, this.b = e, this.N = t;
  }
  flush() {
    this.b.updateSource(this.v);
  }
  handleChange(e, t) {
    const r = this.b;
    e !== z(r.ast, r.s, r, null) && (this.v = e, this.N.add(this));
  }
}
const jo = (n) => {
  Pr(n.prototype, "useScope", function(e) {
    this.s = e;
  });
}, li = (n, e = !0) => (t) => {
  const r = t.prototype;
  n != null && lh(r, "strict", {
    enumerable: !0,
    get: function() {
      return n;
    }
  }), lh(r, "strictFnCall", {
    enumerable: !0,
    get: function() {
      return e;
    }
  }), Pr(r, "get", function(i) {
    return this.l.get(i);
  }), Pr(r, "getSignaler", function() {
    return this.l.root.get(Wd);
  }), Pr(r, "getConverter", function(i) {
    const s = td.keyFrom(i);
    let a = Xl.get(this);
    return a == null && Xl.set(this, a = new xb()), a[s] ?? (a[s] = this.l.get(db(s)));
  }), Pr(r, "getBehavior", function(i) {
    const s = Xc.keyFrom(i);
    let a = Xl.get(this);
    return a == null && Xl.set(this, a = new xb()), a[s] ?? (a[s] = this.l.get(db(s)));
  });
}, Xl = /* @__PURE__ */ new WeakMap();
class xb {
}
const E8 = /* @__PURE__ */ $t("IFlushQueue", (n) => n.singleton(S8));
class S8 {
  constructor() {
    this.j = !1, this.W = /* @__PURE__ */ new Set();
  }
  get count() {
    return this.W.size;
  }
  add(e) {
    if (this.W.add(e), !this.j) {
      this.j = !0;
      try {
        this.W.forEach(C8);
      } finally {
        this.j = !1;
      }
    }
  }
  clear() {
    this.W.clear(), this.j = !1;
  }
}
function C8(n, e, t) {
  t.delete(n), n.flush();
}
const cp = /* @__PURE__ */ new WeakSet(), ka = (n, e) => {
  Pr(n.prototype, "limit", function(t) {
    if (cp.has(this))
      throw se("AURXXXX: a rate limit has already been applied.");
    cp.add(this);
    const r = e(this, t), i = t.signals, s = i.length > 0 ? this.get(Wd) : null, a = this[r], o = (...d) => a.call(this, ...d), u = t.type === "debounce" ? _8(t, o, this) : M8(t, o, this), l = s ? {
      handleChange: u.flush
    } : null;
    return this[r] = u, s && i.forEach((d) => d1(s, d, l)), {
      dispose: () => {
        s && i.forEach((d) => f1(s, d, l)), cp.delete(this), u.dispose(), delete this[r];
      }
    };
  });
}, _8 = (n, e, t) => {
  let r, i, s, a = !1;
  const o = n.queue, u = () => e(s), l = (p) => {
    s = p, t.isBound ? (i = r, r = o.queueTask(u, {
      delay: n.delay,
      reusable: !1
    }), i?.cancel()) : u();
  }, d = l.dispose = () => {
    i?.cancel(), r?.cancel(), i = r = void 0;
  };
  return l.flush = () => {
    a = r?.status === 0, d(), a && u();
  }, l;
}, M8 = (n, e, t) => {
  let r, i, s = 0, a = 0, o, u = !1;
  const l = n.queue, d = () => n.now(), p = () => e(o), m = (x) => {
    o = x, t.isBound ? (a = d() - s, i = r, a > n.delay ? (s = d(), p()) : r = l.queueTask(() => {
      s = d(), p();
    }, {
      delay: n.delay - a,
      reusable: !1
    }), i?.cancel()) : p();
  }, w = m.dispose = () => {
    i?.cancel(), r?.cancel(), i = r = void 0;
  };
  return m.flush = () => {
    u = r?.status === 0, w(), u && p();
  }, m;
}, { enter: P8, exit: R8 } = tE, { wrap: I8, unwrap: O8 } = BE;
class E1 {
  get value() {
    return this.v;
  }
  constructor(e, t, r, i, s) {
    this.obj = e, this.$get = r, this.useProxy = s, this.isBound = !1, this.running = !1, this.v = void 0, this.cb = i, this.oL = t;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  bind() {
    this.isBound || (this.compute(), this.isBound = !0);
  }
  unbind() {
    this.isBound && (this.isBound = !1, this.obs.clearAll());
  }
  run() {
    if (!this.isBound || this.running)
      return;
    const e = this.obj, t = this.v, r = this.compute();
    Qd(r, t) || this.cb.call(e, r, t, e);
  }
  compute() {
    this.running = !0, this.obs.version++;
    try {
      return P8(this), this.v = O8(this.$get.call(void 0, this.useProxy ? I8(this.obj) : this.obj, this));
    } finally {
      this.obs.clear(), this.running = !1, R8(this);
    }
  }
}
class q0 {
  get value() {
    return this.v;
  }
  constructor(e, t, r, i, s) {
    this.scope = e, this.l = t, this.oL = r, this.isBound = !1, this.boundFn = !1, this.obj = e.bindingContext, this.G = i, this.cb = s;
  }
  handleChange(e) {
    const t = this.G, r = this.obj, i = this.v;
    t.$kind === 1 && this.obs.count === 1 || (this.obs.version++, e = z(t, this.scope, this, this), this.obs.clear()), Qd(e, i) || (this.v = e, this.cb.call(r, e, i, r));
  }
  bind() {
    this.isBound || (this.obs.version++, this.v = z(this.G, this.scope, this, this), this.obs.clear(), this.isBound = !0);
  }
  unbind() {
    this.isBound && (this.isBound = !1, this.obs.clearAll(), this.v = void 0);
  }
}
Fr(E1);
Fr(q0);
li(!0)(q0);
const Qa = /* @__PURE__ */ $t("ILifecycleHooks");
class k8 {
  constructor(e, t) {
    this.definition = e, this.instance = t;
  }
}
class W0 {
  constructor(e, t) {
    this.Type = e, this.propertyNames = t;
  }
  static create(e, t) {
    const r = /* @__PURE__ */ new Set();
    let i = t.prototype;
    for (; i !== D0; ) {
      for (const s of l1(i))
        s !== "constructor" && !s.startsWith("_") && r.add(s);
      i = Object.getPrototypeOf(i);
    }
    return new W0(t, r);
  }
  register(e) {
    Uo(Qa, this.Type).register(e);
  }
}
const vb = /* @__PURE__ */ new WeakMap(), Zl = Hn("lifecycle-hooks"), wb = Ui({
  name: Zl,
  define(n, e) {
    const t = W0.create(n, e);
    return Ft(Zl, t, e), Oa(e, Zl), t.Type;
  },
  resolve(n) {
    let e = vb.get(n);
    if (e === void 0) {
      vb.set(n, e = new N8());
      const t = n.root, r = t.id === n.id ? n.getAll(Qa) : n.has(Qa, !1) ? t.getAll(Qa).concat(n.getAll(Qa)) : t.getAll(Qa);
      let i, s, a, o, u;
      for (i of r) {
        s = Rn(Zl, i.constructor), a = new k8(s, i);
        for (o of s.propertyNames)
          u = e[o], u === void 0 ? e[o] = [a] : u.push(a);
      }
    }
    return e;
  }
});
class N8 {
}
class S1 {
  constructor(e, t, r) {
    this.type = 7, this.v = null, this.ov = null, this.F = !1, this.o = e, this.X = t, this.K = r;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.v = e, this.F = e !== this.ov, this.H();
  }
  H() {
    if (this.F)
      switch (this.F = !1, this.ov = this.v, this.K) {
        case "class": {
          this.o.classList.toggle(this.X, !!this.v);
          break;
        }
        case "style": {
          let e = "", t = this.v;
          Et(t) && t.includes("!important") && (e = "important", t = t.replace("!important", "")), this.o.style.setProperty(this.X, t, e);
          break;
        }
        default:
          this.v == null ? this.o.removeAttribute(this.K) : this.o.setAttribute(this.K, gs(this.v));
      }
  }
  handleMutation(e) {
    let t = !1;
    for (let r = 0, i = e.length; i > r; ++r) {
      const s = e[r];
      if (s.type === "attributes" && s.attributeName === this.X) {
        t = !0;
        break;
      }
    }
    if (t) {
      let r;
      switch (this.K) {
        case "class":
          r = this.o.classList.contains(this.X);
          break;
        case "style":
          r = this.o.style.getPropertyValue(this.X);
          break;
        default:
          throw se(`AUR0651:${this.K}`);
      }
      r !== this.v && (this.ov = this.v, this.v = r, this.F = !1, this.Y());
    }
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.v = this.ov = this.o.getAttribute(this.X), D8(this.o, this));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && B8(this.o, this);
  }
  Y() {
    Tb = this.ov, this.ov = this.v, this.subs.notify(this.v, Tb);
  }
}
tr(S1);
const D8 = (n, e) => {
  n.$eMObs === void 0 && (n.$eMObs = /* @__PURE__ */ new Set()), n.$mObs === void 0 && (n.$mObs = F0(n, F8)).observe(n, {
    attributes: !0
  }), n.$eMObs.add(e);
}, B8 = (n, e) => {
  const t = n.$eMObs;
  return t && t.delete(e) ? (t.size === 0 && (n.$mObs.disconnect(), n.$mObs = void 0), !0) : !1;
}, F8 = (n) => {
  n[0].target.$eMObs.forEach(L8, n);
};
function L8(n) {
  n.handleMutation(this);
}
let Tb;
const $8 = {
  reusable: !1,
  preempt: !0
};
class El {
  constructor(e, t, r, i, s, a, o, u, l) {
    this.targetAttribute = o, this.targetProperty = u, this.mode = l, this.isBound = !1, this.s = void 0, this.Z = null, this.v = void 0, this.boundFn = !1, this.l = t, this.ast = s, this.J = e, this.target = a, this.oL = r, this.C = i;
  }
  updateTarget(e) {
    this.tt.setValue(e, this.target, this.targetProperty);
  }
  handleChange() {
    if (!this.isBound)
      return;
    let e;
    this.obs.version++;
    const t = z(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    this.obs.clear(), t !== this.v && (this.v = t, this.J.state !== 1 && (this.tt.type & 4) > 0 ? (e = this.Z, this.Z = this.C.queueTask(() => {
      this.Z = null, this.updateTarget(t);
    }, $8), e?.cancel()) : this.updateTarget(t));
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Or(this.ast, e, this), this.tt ?? (this.tt = new S1(this.target, this.targetProperty, this.targetAttribute)), this.mode & 3 && this.updateTarget(this.v = z(this.ast, e, this, (this.mode & 2) > 0 ? this : null)), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, dr(this.ast, this.s, this), this.s = void 0, this.v = void 0, this.Z?.cancel(), this.Z = null, this.obs.clearAll());
  }
}
jo(El);
ka(El, () => "updateTarget");
Fr(El);
li(!0)(El);
const C1 = {
  reusable: !1,
  preempt: !0
};
class U8 {
  constructor(e, t, r, i, s, a, o, u) {
    this.ast = s, this.target = a, this.targetProperty = o, this.mode = u, this.isBound = !1, this.s = void 0, this.Z = null, this.J = e, this.oL = r, this.C = i, this.tt = r.getAccessor(a, o);
    const l = s.expressions, d = this.partBindings = Array(l.length), p = l.length;
    let m = 0;
    for (; p > m; ++m)
      d[m] = new Sl(l[m], a, o, t, r, this);
  }
  et() {
    this.updateTarget();
  }
  updateTarget() {
    const e = this.partBindings, t = this.ast.parts, r = e.length;
    let i = "", s = 0;
    if (r === 1)
      i = t[0] + e[0].v + t[1];
    else
      for (i = t[0]; r > s; ++s)
        i += e[s].v + t[s + 1];
    const a = this.tt, o = this.J.state !== 1 && (a.type & 4) > 0;
    let u;
    o ? (u = this.Z, this.Z = this.C.queueTask(() => {
      this.Z = null, a.setValue(i, this.target, this.targetProperty);
    }, C1), u?.cancel(), u = null) : a.setValue(i, this.target, this.targetProperty);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e;
    const t = this.partBindings, r = t.length;
    let i = 0;
    for (; r > i; ++i)
      t[i].bind(e);
    this.updateTarget(), this.isBound = !0;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = !1, this.s = void 0;
    const e = this.partBindings, t = e.length;
    let r = 0;
    for (; t > r; ++r)
      e[r].unbind();
    this.Z?.cancel(), this.Z = null;
  }
}
class Sl {
  constructor(e, t, r, i, s, a) {
    this.ast = e, this.target = t, this.targetProperty = r, this.owner = a, this.mode = 2, this.task = null, this.isBound = !1, this.v = "", this.boundFn = !1, this.l = i, this.oL = s;
  }
  updateTarget() {
    this.owner.et();
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = z(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    this.obs.clear(), e != this.v && (this.v = e, ti(e) && this.observeCollection(e), this.updateTarget());
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Or(this.ast, e, this), this.v = z(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null), ti(this.v) && this.observeCollection(this.v), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, dr(this.ast, this.s, this), this.s = void 0, this.obs.clearAll());
  }
}
jo(Sl);
ka(Sl, () => "updateTarget");
Fr(Sl);
li(!0)(Sl);
class Cl {
  constructor(e, t, r, i, s, a, o, u) {
    this.p = s, this.ast = a, this.target = o, this.strict = u, this.isBound = !1, this.mode = 2, this.Z = null, this.v = "", this.boundFn = !1, this.l = t, this.J = e, this.oL = r, this.C = i;
  }
  updateTarget(e) {
    const t = this.target, r = this.p.Node, i = this.v;
    this.v = e, i instanceof r && i.parentNode?.removeChild(i), e instanceof r ? (t.textContent = "", t.parentNode?.insertBefore(e, t)) : t.textContent = gs(e);
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = z(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    if (this.obs.clear(), e === this.v) {
      this.Z?.cancel(), this.Z = null;
      return;
    }
    this.J.state !== 1 ? this.it(e) : this.updateTarget(e);
  }
  handleCollectionChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = this.v = z(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    this.obs.clear(), ti(e) && this.observeCollection(e), this.J.state !== 1 ? this.it(e) : this.updateTarget(e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Or(this.ast, e, this);
    const t = this.v = z(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    ti(t) && this.observeCollection(t), this.updateTarget(t), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, dr(this.ast, this.s, this), this.s = void 0, this.obs.clearAll(), this.Z?.cancel(), this.Z = null);
  }
  it(e) {
    const t = this.Z;
    this.Z = this.C.queueTask(() => {
      this.Z = null, this.updateTarget(e);
    }, C1), t?.cancel();
  }
}
jo(Cl);
ka(Cl, () => "updateTarget");
Fr()(Cl);
li(void 0, !1)(Cl);
class _l {
  constructor(e, t, r, i, s = !1) {
    this.ast = r, this.targetProperty = i, this.isBound = !1, this.s = void 0, this.target = null, this.boundFn = !1, this.l = e, this.oL = t, this.st = s;
  }
  updateTarget() {
    this.target[this.targetProperty] = this.v;
  }
  handleChange() {
    this.isBound && (this.obs.version++, this.v = z(this.ast, this.s, this, this), this.obs.clear(), this.updateTarget());
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, this.target = this.st ? e.bindingContext : e.overrideContext, Or(this.ast, e, this), this.v = z(this.ast, this.s, this, this), this.updateTarget(), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, dr(this.ast, this.s, this), this.s = void 0, this.obs.clearAll());
  }
}
jo(_l);
ka(_l, () => "updateTarget");
Fr(_l);
li(!0)(_l);
class Vi {
  constructor(e, t, r, i, s, a, o, u) {
    this.ast = s, this.target = a, this.targetProperty = o, this.mode = u, this.isBound = !1, this.s = void 0, this.tt = void 0, this.Z = null, this.nt = null, this.boundFn = !1, this.l = t, this.J = e, this.C = i, this.oL = r;
  }
  updateTarget(e) {
    this.tt.setValue(e, this.target, this.targetProperty);
  }
  updateSource(e) {
    bn(this.ast, this.s, this, e);
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = z(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    this.obs.clear(), this.J.state !== 1 && (this.tt.type & 4) > 0 ? (dp = this.Z, this.Z = this.C.queueTask(() => {
      this.updateTarget(e), this.Z = null;
    }, j8), dp?.cancel(), dp = null) : this.updateTarget(e);
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Or(this.ast, e, this);
    const t = this.oL, r = this.mode;
    let i = this.tt;
    i || (r & 4 ? i = t.getObserver(this.target, this.targetProperty) : i = t.getAccessor(this.target, this.targetProperty), this.tt = i);
    const s = (r & 2) > 0;
    r & 3 && this.updateTarget(z(this.ast, this.s, this, s ? this : null)), r & 4 && (i.subscribe(this.nt ?? (this.nt = new A8(this, this.l.get(E8)))), s || this.updateSource(i.getValue(this.target, this.targetProperty))), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, dr(this.ast, this.s, this), this.s = void 0, this.nt && (this.tt.unsubscribe(this.nt), this.nt = null), this.Z?.cancel(), this.Z = null, this.obs.clearAll());
  }
  useTargetObserver(e) {
    this.tt?.unsubscribe(this), (this.tt = e).subscribe(this);
  }
  useTargetSubscriber(e) {
    if (this.nt != null)
      throw se("AURxxxx: binding already has a target subscriber");
    this.nt = e;
  }
}
jo(Vi);
ka(Vi, (n) => n.mode & 4 ? "updateSource" : "updateTarget");
Fr(Vi);
li(!0, !1)(Vi);
let dp = null;
const j8 = {
  reusable: !1,
  preempt: !0
};
class _1 {
  constructor(e, t, r) {
    this.ast = t, this.target = r, this.isBound = !1, this.s = void 0, this.l = e;
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Or(this.ast, e, this), bn(this.ast, this.s, this, this.target), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, z(this.ast, this.s, this, null) === this.target && bn(this.ast, this.s, this, null), dr(this.ast, this.s, this), this.s = void 0);
  }
}
li(!1)(_1);
class V8 {
  constructor(e, t = !1) {
    this.prevent = e, this.capture = t;
  }
}
class Ml {
  constructor(e, t, r, i, s) {
    this.ast = t, this.target = r, this.targetEvent = i, this.isBound = !1, this.self = !1, this.boundFn = !0, this.l = e, this.rt = s;
  }
  callSource(e) {
    const t = this.s.overrideContext;
    t.$event = e;
    let r = z(this.ast, this.s, this, null);
    return delete t.$event, Nr(r) && (r = r(e)), r !== !0 && this.rt.prevent && e.preventDefault(), r;
  }
  handleEvent(e) {
    this.self && this.target !== e.composedPath()[0] || this.callSource(e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Or(this.ast, e, this), this.target.addEventListener(this.targetEvent, this, this.rt), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, dr(this.ast, this.s, this), this.s = void 0, this.target.removeEventListener(this.targetEvent, this, this.rt));
  }
}
jo(Ml);
ka(Ml, () => "callSource");
li(!0, !0)(Ml);
const nr = /* @__PURE__ */ $t("IViewFactory");
class ef {
  constructor(e, t) {
    this.isCaching = !1, this.ot = null, this.lt = -1, this.name = t.name, this.container = e, this.def = t;
  }
  setCacheSize(e, t) {
    e && (e === "*" ? e = ef.maxCacheSize : Et(e) && (e = parseInt(e, 10)), (this.lt === -1 || !t) && (this.lt = e)), this.lt > 0 ? this.ot = [] : this.ot = null, this.isCaching = this.lt > 0;
  }
  canReturnToCache(e) {
    return this.ot != null && this.ot.length < this.lt;
  }
  tryReturnToCache(e) {
    return this.canReturnToCache(e) ? (this.ot.push(e), !0) : !1;
  }
  create(e) {
    const t = this.ot;
    let r;
    return t != null && t.length > 0 ? (r = t.pop(), r) : (r = cr.$view(this, e), r);
  }
}
ef.maxCacheSize = 65535;
const M1 = /* @__PURE__ */ $t("IAuSlotsInfo");
class P1 {
  constructor(e) {
    this.projectedSlots = e;
  }
}
const z8 = /* @__PURE__ */ $t("IAuSlotWatcher");
var Ab;
(function(n) {
  n.hydrateElement = "ra", n.hydrateAttribute = "rb", n.hydrateTemplateController = "rc", n.hydrateLetElement = "rd", n.setProperty = "re", n.interpolation = "rf", n.propertyBinding = "rg", n.letBinding = "ri", n.refBinding = "rj", n.iteratorBinding = "rk", n.multiAttr = "rl", n.textBinding = "ha", n.listenerBinding = "hb", n.attributeBinding = "hc", n.stylePropertyBinding = "hd", n.setAttribute = "he", n.setClassAttribute = "hf", n.setStyleAttribute = "hg", n.spreadBinding = "hs", n.spreadElementProp = "hp";
})(Ab || (Ab = {}));
const Vo = /* @__PURE__ */ $t("Instruction");
class Pl {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.mode = r, this.type = "rg";
  }
}
class G8 {
  constructor(e, t, r) {
    this.forOf = e, this.to = t, this.props = r, this.type = "rk";
  }
}
class H8 {
  constructor(e, t) {
    this.from = e, this.to = t, this.type = "rj";
  }
}
class q8 {
  constructor(e, t, r) {
    this.value = e, this.to = t, this.command = r, this.type = "rl";
  }
}
class R1 {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.preventDefault = r, this.capture = i, this.type = "hb";
  }
}
class K0 {
  constructor(e, t, r) {
    this.attr = e, this.from = t, this.to = r, this.type = "hc";
  }
}
class W8 {
  constructor() {
    this.type = "hs";
  }
}
const I1 = /* @__PURE__ */ $t("ITemplateCompiler"), O1 = /* @__PURE__ */ $t("IRenderer");
function Gt(n) {
  return function(t) {
    return t.register = function(r) {
      Uo(O1, this).register(r);
    }, JE(t.prototype, "target", {
      configurable: !0,
      get: function() {
        return n;
      }
    }), t;
  };
}
function zi(n, e, t) {
  return Et(e) ? n.parse(e, t) : e;
}
function tf(n) {
  return n.viewModel != null ? n.viewModel : n;
}
function K8(n, e) {
  if (e === "element")
    return n;
  switch (e) {
    case "controller":
      return la(n);
    case "view":
      throw se("AUR0750");
    case "view-model":
      return la(n).viewModel;
    default: {
      const t = g1(n, e);
      if (t !== void 0)
        return t.viewModel;
      const r = la(n, {
        name: e
      });
      if (r === void 0)
        throw se(`AUR0751:${e}`);
      return r.viewModel;
    }
  }
}
let Eb = class {
  render(e, t, r) {
    const i = tf(t);
    i.$observers?.[r.to] !== void 0 ? i.$observers[r.to].setValue(r.value) : i[r.to] = r.value;
  }
};
Eb = Z([Gt("re")], Eb);
let Sb = class {
  static get inject() {
    return [Na];
  }
  constructor(e) {
    this.r = e;
  }
  render(e, t, r, i, s, a) {
    let o, u, l, d;
    const p = r.res, m = r.projections, w = e.container;
    switch (typeof p) {
      case "string":
        if (o = w.find(fo, p), o == null)
          throw se(`AUR0752:${p}@${e.name}`);
        break;
      default:
        o = p;
    }
    const T = r.containerless || o.containerless ? L0(t) : null, A = Z8(i, e, t, r, T, m == null ? void 0 : new P1(c1(m)));
    u = o.Type, l = A.invoke(u), Jt(A, u, new _n(o.key, l)), d = cr.$el(A, l, t, r, o, T), En(t, o.key, d);
    const M = this.r.renderers, I = r.props, B = I.length;
    let k = 0, N;
    for (; B > k; )
      N = I[k], M[N.type].render(e, d, N, i, s, a), ++k;
    e.addChild(d);
  }
};
Sb = Z([Gt("ra")], Sb);
let Cb = class {
  static get inject() {
    return [Na];
  }
  constructor(e) {
    this.r = e;
  }
  render(e, t, r, i, s, a) {
    let o = e.container, u;
    switch (typeof r.res) {
      case "string":
        if (u = o.find(z0, r.res), u == null)
          throw se(`AUR0753:${r.res}@${e.name}`);
        break;
      default:
        u = r.res;
    }
    const l = B1(i, u, e, t, r, void 0, void 0), d = cr.$attr(l.ctn, l.vm, t, u);
    En(t, u.key, d);
    const p = this.r.renderers, m = r.props, w = m.length;
    let x = 0, T;
    for (; w > x; )
      T = m[x], p[T.type].render(e, d, T, i, s, a), ++x;
    e.addChild(d);
  }
};
Cb = Z([Gt("rb")], Cb);
let _b = class {
  static get inject() {
    return [Na, ji];
  }
  constructor(e, t) {
    this.r = e, this.p = t;
  }
  render(e, t, r, i, s, a) {
    let o = e.container, u;
    switch (typeof r.res) {
      case "string":
        if (u = o.find(z0, r.res), u == null)
          throw se(`AUR0754:${r.res}@${e.name}`);
        break;
      default:
        u = r.res;
    }
    const l = this.r.getViewFactory(r.def, o), d = L0(t), p = B1(this.p, u, e, t, r, l, d), m = cr.$attr(p.ctn, p.vm, t, u);
    En(d, u.key, m), p.vm.link?.(e, m, t, r);
    const w = this.r.renderers, x = r.props, T = x.length;
    let A = 0, M;
    for (; T > A; )
      M = x[A], w[M.type].render(e, m, M, i, s, a), ++A;
    e.addChild(m);
  }
};
_b = Z([Gt("rc")], _b);
let Mb = class {
  render(e, t, r, i, s, a) {
    t.remove();
    const o = r.instructions, u = r.toBindingContext, l = e.container, d = o.length;
    let p, m, w = 0;
    for (; d > w; )
      p = o[w], m = zi(s, p.from, 16), e.addBinding(new _l(l, a, m, p.to, u)), ++w;
  }
};
Mb = Z([Gt("rd")], Mb);
let Pb = class {
  render(e, t, r, i, s) {
    e.addBinding(new _1(e.container, zi(s, r.from, 16), K8(t, r.to)));
  }
};
Pb = Z([Gt("rj")], Pb);
let Rb = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new U8(e, e.container, a, i.domWriteQueue, zi(s, r.from, 1), tf(t), r.to, 2));
  }
};
Rb = Z([Gt("rf")], Rb);
let Ib = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Vi(e, e.container, a, i.domWriteQueue, zi(s, r.from, 16), tf(t), r.to, r.mode));
  }
};
Ib = Z([Gt("rg")], Ib);
let Ob = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Vi(e, e.container, a, i.domWriteQueue, zi(s, r.forOf, 2), tf(t), r.to, 2));
  }
};
Ob = Z([Gt("rk")], Ob);
let kb = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Cl(e, e.container, a, i.domWriteQueue, i, zi(s, r.from, 16), d8(t.parentNode, c8(i, ""), t), r.strict));
  }
};
kb = Z([Gt("ha")], kb);
let Nb = class {
  render(e, t, r, i, s) {
    e.addBinding(new Ml(e.container, zi(s, r.from, 8), t, r.to, new V8(r.preventDefault, r.capture)));
  }
};
Nb = Z([Gt("hb")], Nb);
let Db = class {
  render(e, t, r) {
    t.setAttribute(r.to, r.value);
  }
};
Db = Z([Gt("he")], Db);
let Bb = class {
  render(e, t, r) {
    Q8(t.classList, r.value);
  }
};
Bb = Z([Gt("hf")], Bb);
let Fb = class {
  render(e, t, r) {
    t.style.cssText += r.value;
  }
};
Fb = Z([Gt("hg")], Fb);
let Lb = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Vi(e, e.container, a, i.domWriteQueue, zi(s, r.from, 16), t.style, r.to, 2));
  }
};
Lb = Z([Gt("hd")], Lb);
let $b = class {
  render(e, t, r, i, s, a) {
    const o = e.container, u = o.has(hb, !1) ? o.get(hb) : null;
    e.addBinding(new El(e, o, a, i.domWriteQueue, zi(s, r.from, 16), t, r.attr, u == null ? r.to : r.to.split(/\s/g).map((l) => u[l] ?? l).join(" "), 2));
  }
};
$b = Z([Gt("hc")], $b);
let Ub = class {
  static get inject() {
    return [I1, Na];
  }
  constructor(e, t) {
    this.ft = e, this.r = t;
  }
  render(e, t, r, i, s, a) {
    const u = e.container.get(nd), l = this.r.renderers, d = (m) => {
      let w = m, x = u;
      for (; x != null && w > 0; )
        x = x.parent, --w;
      if (x == null)
        throw se("No scope context for spread binding.");
      return x;
    }, p = (m) => {
      const w = d(m), x = Y8(w), T = this.ft.compileSpread(w.controller.definition, w.instruction?.captures ?? je, w.controller.container, t);
      let A;
      for (A of T)
        switch (A.type) {
          case "hs":
            p(m + 1);
            break;
          case "hp":
            l[A.instructions.type].render(x, la(t), A.instructions, i, s, a);
            break;
          default:
            l[A.type].render(x, t, A, i, s, a);
        }
      e.addBinding(x);
    };
    p(0);
  }
};
Ub = Z([Gt("hs")], Ub);
class J8 {
  get container() {
    return this.locator;
  }
  get definition() {
    return this.ctrl.definition;
  }
  get isStrictBinding() {
    return this.ctrl.isStrictBinding;
  }
  get state() {
    return this.ctrl.state;
  }
  constructor(e, t) {
    this.dt = e, this.gt = t, this.isBound = !1, this.ctrl = t.controller, this.locator = this.ctrl.container;
  }
  get(e) {
    return this.locator.get(e);
  }
  bind(e) {
    if (this.isBound)
      return;
    this.isBound = !0;
    const t = this.scope = this.gt.controller.scope.parent ?? void 0;
    if (t == null)
      throw se("Invalid spreading. Context scope is null/undefined");
    this.dt.forEach((r) => r.bind(t));
  }
  unbind() {
    this.dt.forEach((e) => e.unbind()), this.isBound = !1;
  }
  addBinding(e) {
    this.dt.push(e);
  }
  addChild(e) {
    if (e.vmKind !== 1)
      throw se("Spread binding does not support spreading custom attributes/template controllers");
    this.ctrl.addChild(e);
  }
}
function Q8(n, e) {
  const t = e.length;
  let r = 0;
  for (let i = 0; i < t; ++i)
    e.charCodeAt(i) === 32 ? (i !== r && n.add(e.slice(r, i)), r = i + 1) : i + 1 === t && n.add(e.slice(r));
}
const Y8 = (n) => new J8([], n), k1 = "IController", N1 = "IInstruction", X8 = "IRenderLocation", J0 = "ISlotsInfo";
function Z8(n, e, t, r, i, s) {
  const a = e.container.createChild();
  return $0(a, n, t), Jt(a, nf, new _n(k1, e)), Jt(a, Vo, new _n(N1, r)), Jt(a, In, i == null ? L1 : new F1(i)), Jt(a, nr, $1), Jt(a, M1, s == null ? U1 : new _n(J0, s)), a;
}
class D1 {
  get $isResolver() {
    return !0;
  }
  constructor(e) {
    this.f = e;
  }
  resolve() {
    const e = this.f;
    if (e === null)
      throw se("AUR7055");
    if (!Et(e.name) || e.name.length === 0)
      throw se("AUR0756");
    return e;
  }
}
function B1(n, e, t, r, i, s, a, o) {
  const u = t.container.createChild();
  return $0(u, n, r), t = t instanceof cr ? t : t.ctrl, Jt(u, nf, new _n(k1, t)), Jt(u, Vo, new _n(N1, i)), Jt(u, In, a == null ? L1 : new _n(X8, a)), Jt(u, nr, s == null ? $1 : new D1(s)), Jt(u, M1, o == null ? U1 : new _n(J0, o)), {
    vm: u.invoke(e.Type),
    ctn: u
  };
}
class F1 {
  get name() {
    return "IRenderLocation";
  }
  get $isResolver() {
    return !0;
  }
  constructor(e) {
    this.l = e;
  }
  resolve() {
    return this.l;
  }
}
const L1 = new F1(null), $1 = new D1(null), U1 = new _n(J0, new P1(je)), Na = /* @__PURE__ */ $t("IRendering", (n) => n.singleton(j1));
class j1 {
  get renderers() {
    return this.vt ?? (this.vt = this.bt.getAll(O1, !1).reduce((e, t) => (e[t.target] = t, e), Jn()));
  }
  constructor(e) {
    this.xt = /* @__PURE__ */ new WeakMap(), this.wt = /* @__PURE__ */ new WeakMap();
    const t = e.root;
    this.p = (this.bt = t).get(ji), this.ep = t.get(E0), this.oL = t.get(Ia), this.yt = new ap(this.p, this.p.document.createDocumentFragment());
  }
  compile(e, t, r) {
    if (e.needsCompile !== !1) {
      const i = this.xt, s = t.get(I1);
      let a = i.get(e);
      return a == null ? i.set(e, a = s.compile(e, t, r)) : t.register(...a.dependencies), a;
    }
    return e;
  }
  getViewFactory(e, t) {
    return new ef(t, Hr.getOrCreate(e));
  }
  createNodes(e) {
    if (e.enhance === !0)
      return new ap(this.p, e.template);
    let t, r = !1;
    const i = this.wt, s = this.p, a = s.document;
    if (i.has(e))
      t = i.get(e);
    else {
      const o = e.template;
      let u;
      o === null ? t = null : o instanceof s.Node ? o.nodeName === "TEMPLATE" ? (t = o.content, r = !0) : (t = a.createDocumentFragment()).appendChild(o.cloneNode(!0)) : (u = a.createElement("template"), Et(o) && (u.innerHTML = o), t = u.content, r = !0), i.set(e, t);
    }
    return t == null ? this.yt : new ap(this.p, r ? a.importNode(t, !0) : a.adoptNode(t.cloneNode(!0)));
  }
  render(e, t, r, i) {
    const s = r.instructions, a = this.renderers, o = t.length;
    if (t.length !== s.length)
      throw se(`AUR0757:${o}<>${s.length}`);
    let u = 0, l = 0, d = 0, p, m, w;
    if (o > 0)
      for (; o > u; ) {
        for (p = s[u], w = t[u], l = 0, d = p.length; d > l; )
          m = p[l], a[m.type].render(e, w, m, this.p, this.ep, this.oL), ++l;
        ++u;
      }
    if (i != null && (p = r.surrogates, (d = p.length) > 0))
      for (l = 0; d > l; )
        m = p[l], a[m.type].render(e, i, m, this.p, this.ep, this.oL), ++l;
  }
}
j1.inject = [No];
var jb;
(function(n) {
  n[n.none = 0] = "none", n[n.host = 1] = "host", n[n.shadowRoot = 2] = "shadowRoot", n[n.location = 3] = "location";
})(jb || (jb = {}));
const e4 = {
  optional: !0
}, t4 = ZE(W3), Zi = /* @__PURE__ */ new WeakMap();
class cr {
  get lifecycleHooks() {
    return this.kt;
  }
  get isActive() {
    return (this.state & 3) > 0 && (this.state & 4) === 0;
  }
  get name() {
    if (this.parent === null)
      switch (this.vmKind) {
        case 1:
          return `[${this.definition.name}]`;
        case 0:
          return this.definition.name;
        case 2:
          return this.viewFactory.name;
      }
    switch (this.vmKind) {
      case 1:
        return `${this.parent.name}>[${this.definition.name}]`;
      case 0:
        return `${this.parent.name}>${this.definition.name}`;
      case 2:
        return this.viewFactory.name === this.parent.definition?.name ? `${this.parent.name}[view]` : `${this.parent.name}[view:${this.viewFactory.name}]`;
    }
  }
  get hooks() {
    return this.At;
  }
  get viewModel() {
    return this.Ct;
  }
  set viewModel(e) {
    this.Ct = e, this.At = e == null || this.vmKind === 2 ? so.none : new so(e);
  }
  constructor(e, t, r, i, s, a, o) {
    this.container = e, this.vmKind = t, this.definition = r, this.viewFactory = i, this.host = a, this.head = null, this.tail = null, this.next = null, this.parent = null, this.bindings = null, this.children = null, this.hasLockedScope = !1, this.isStrictBinding = !1, this.scope = null, this.isBound = !1, this.hostController = null, this.mountTarget = 0, this.shadowRoot = null, this.nodes = null, this.location = null, this.kt = null, this.state = 0, this.Rt = !1, this.$initiator = null, this.$resolve = void 0, this.$reject = void 0, this.$promise = void 0, this.Bt = 0, this.St = 0, this._t = 0, this.Ct = s, this.At = t === 2 ? so.none : new so(s), this.location = o, this.r = e.root.get(Na), this.coercion = t === 2 ? void 0 : e.get(t4);
  }
  static getCached(e) {
    return Zi.get(e);
  }
  static getCachedOrThrow(e) {
    const t = cr.getCached(e);
    if (t === void 0)
      throw se(`AUR0500:${e}`);
    return t;
  }
  static $el(e, t, r, i, s = void 0, a = null) {
    if (Zi.has(t))
      return Zi.get(t);
    s = s ?? mh(t.constructor);
    const o = new cr(e, 0, s, null, t, r, a), u = e.get(wv(nd));
    return s.dependencies.length > 0 && e.register(...s.dependencies), Jt(e, nd, new _n("IHydrationContext", new i4(o, i, u))), Zi.set(t, o), (i == null || i.hydrate !== !1) && o.hE(i, u), o;
  }
  static $attr(e, t, r, i) {
    if (Zi.has(t))
      return Zi.get(t);
    i = i ?? ph(t.constructor);
    const s = new cr(e, 1, i, null, t, r, null);
    return i.dependencies.length > 0 && e.register(...i.dependencies), Zi.set(t, s), s.Tt(), s;
  }
  static $view(e, t = void 0) {
    const r = new cr(e.container, 2, null, e, null, null, null);
    return r.parent = t ?? null, r.It(), r;
  }
  hE(e, t) {
    const r = this.container, i = this.Ct;
    let s = this.definition;
    if (this.scope = dn.create(i, null, !0), s.watches.length > 0 && Gb(this, r, s, i), Vb(this, s, i), this.At.hasDefine) {
      const a = i.define(this, t, s);
      a !== void 0 && a !== s && (s = Hr.getOrCreate(a));
    }
    this.kt = wb.resolve(r), s.register(r), s.injectable !== null && Jt(r, s.injectable, new _n("definition.injectable", i)), (e == null || e.hydrate !== !1) && (this.hS(e), this.hC());
  }
  hS(e) {
    this.kt.hydrating != null && this.kt.hydrating.forEach(a4, this), this.At.hasHydrating && this.Ct.hydrating(this);
    const t = this.Et = this.r.compile(this.definition, this.container, e), { shadowOptions: r, isStrictBinding: i, hasSlots: s, containerless: a } = t;
    let o = this.location;
    if (this.isStrictBinding = i, (this.hostController = la(this.host, e4)) !== null && (this.host = this.container.root.get(ji).document.createElement(this.definition.name), a && o == null && (o = this.location = L0(this.host))), En(this.host, Zt, this), En(this.host, this.definition.key, this), r !== null || s) {
      if (o != null)
        throw se("AUR0501");
      En(this.shadowRoot = this.host.attachShadow(r ?? r4), Zt, this), En(this.shadowRoot, this.definition.key, this), this.mountTarget = 2;
    } else
      o != null ? (En(o, Zt, this), En(o, this.definition.key, this), this.mountTarget = 3) : this.mountTarget = 1;
    this.Ct.$controller = this, this.nodes = this.r.createNodes(t), this.kt.hydrated !== void 0 && this.kt.hydrated.forEach(o4, this), this.At.hasHydrated && this.Ct.hydrated(this);
  }
  hC() {
    this.r.render(this, this.nodes.findTargets(), this.Et, this.host), this.kt.created !== void 0 && this.kt.created.forEach(Kb, this), this.At.hasCreated && this.Ct.created(this);
  }
  Tt() {
    const e = this.definition, t = this.Ct;
    e.watches.length > 0 && Gb(this, this.container, e, t), Vb(this, e, t), t.$controller = this, this.kt = wb.resolve(this.container), this.kt.created !== void 0 && this.kt.created.forEach(Kb, this), this.At.hasCreated && this.Ct.created(this);
  }
  It() {
    this.Et = this.r.compile(this.viewFactory.def, this.container, null), this.isStrictBinding = this.Et.isStrictBinding, this.r.render(this, (this.nodes = this.r.createNodes(this.Et)).findTargets(), this.Et, void 0);
  }
  activate(e, t, r) {
    switch (this.state) {
      case 0:
      case 8:
        if (!(t === null || t.isActive))
          return;
        this.state = 1;
        break;
      case 2:
        return;
      case 32:
        throw se(`AUR0502:${this.name}`);
      default:
        throw se(`AUR0503:${this.name} ${Wb(this.state)}`);
    }
    switch (this.parent = t, this.vmKind) {
      case 0:
        this.scope.parent = r ?? null;
        break;
      case 1:
        this.scope = r ?? null;
        break;
      case 2:
        if (r == null)
          throw se("AUR0504");
        this.hasLockedScope || (this.scope = r);
        break;
    }
    this.isStrictBinding, this.$initiator = e, this.Pt();
    let i;
    return this.vmKind !== 2 && this.kt.binding != null && (i = Qt(...this.kt.binding.map(u4, this))), this.At.hasBinding && (i = Qt(i, this.Ct.binding(this.$initiator, this.parent))), un(i) ? (this.Lt(), i.then(() => {
      this.bind();
    }).catch((s) => {
      this.Mt(s);
    }), this.$promise) : (this.bind(), this.$promise);
  }
  bind() {
    let e = 0, t = 0, r;
    if (this.bindings !== null)
      for (e = 0, t = this.bindings.length; t > e; )
        this.bindings[e].bind(this.scope), ++e;
    if (this.vmKind !== 2 && this.kt.bound != null && (r = Qt(...this.kt.bound.map(l4, this))), this.At.hasBound && (r = Qt(r, this.Ct.bound(this.$initiator, this.parent))), un(r)) {
      this.Lt(), r.then(() => {
        this.isBound = !0, this.Dt();
      }).catch((i) => {
        this.Mt(i);
      });
      return;
    }
    this.isBound = !0, this.Dt();
  }
  $t(...e) {
    switch (this.mountTarget) {
      case 1:
        this.host.append(...e);
        break;
      case 2:
        this.shadowRoot.append(...e);
        break;
      case 3: {
        let t = 0;
        for (; t < e.length; ++t)
          this.location.parentNode.insertBefore(e[t], this.location);
        break;
      }
    }
  }
  Dt() {
    if (this.hostController !== null)
      switch (this.mountTarget) {
        case 1:
        case 2:
          this.hostController.$t(this.host);
          break;
        case 3:
          this.hostController.$t(this.location.$start, this.location);
          break;
      }
    switch (this.mountTarget) {
      case 1:
        this.nodes.appendTo(this.host, this.definition != null && this.definition.enhance);
        break;
      case 2: {
        const r = this.container;
        (r.has(gb, !1) ? r.get(gb) : r.get(T8)).applyTo(this.shadowRoot), this.nodes.appendTo(this.shadowRoot);
        break;
      }
      case 3:
        this.nodes.insertBefore(this.location);
        break;
    }
    let e = 0, t;
    if (this.vmKind !== 2 && this.kt.attaching != null && (t = Qt(...this.kt.attaching.map(c4, this))), this.At.hasAttaching && (t = Qt(t, this.Ct.attaching(this.$initiator, this.parent))), un(t) && (this.Lt(), this.Pt(), t.then(() => {
      this.Ut();
    }).catch((r) => {
      this.Mt(r);
    })), this.children !== null)
      for (; e < this.children.length; ++e)
        this.children[e].activate(this.$initiator, this, this.scope);
    this.Ut();
  }
  deactivate(e, t) {
    switch (this.state & -17) {
      case 2:
        this.state = 4;
        break;
      case 0:
      case 8:
      case 32:
      case 40:
        return;
      default:
        throw se(`AUR0505:${this.name} ${Wb(this.state)}`);
    }
    this.$initiator = e, e === this && this.qt();
    let r = 0, i;
    if (this.children !== null)
      for (r = 0; r < this.children.length; ++r)
        this.children[r].deactivate(e, this);
    if (this.vmKind !== 2 && this.kt.detaching != null && (i = Qt(...this.kt.detaching.map(f4, this))), this.At.hasDetaching && (i = Qt(i, this.Ct.detaching(this.$initiator, this.parent))), un(i) && (this.Lt(), e.qt(), i.then(() => {
      e.Ft();
    }).catch((s) => {
      e.Mt(s);
    })), e.head === null ? e.head = this : e.tail.next = this, e.tail = this, e === this)
      return this.Ft(), this.$promise;
  }
  removeNodes() {
    switch (this.vmKind) {
      case 0:
      case 2:
        this.nodes.remove(), this.nodes.unlink();
    }
    if (this.hostController !== null)
      switch (this.mountTarget) {
        case 1:
        case 2:
          this.host.remove();
          break;
        case 3:
          this.location.$start.remove(), this.location.remove();
          break;
      }
  }
  unbind() {
    let e = 0;
    if (this.bindings !== null)
      for (; e < this.bindings.length; ++e)
        this.bindings[e].unbind();
    switch (this.parent = null, this.vmKind) {
      case 1:
        this.scope = null;
        break;
      case 2:
        this.hasLockedScope || (this.scope = null), (this.state & 16) === 16 && !this.viewFactory.tryReturnToCache(this) && this.$initiator === this && this.dispose();
        break;
      case 0:
        this.scope.parent = null;
        break;
    }
    this.state = 8, this.$initiator = null, this.Ht();
  }
  Lt() {
    this.$promise === void 0 && (this.$promise = new Promise((e, t) => {
      this.$resolve = e, this.$reject = t;
    }), this.$initiator !== this && this.parent.Lt());
  }
  Ht() {
    this.$promise !== void 0 && (fp = this.$resolve, this.$resolve = this.$reject = this.$promise = void 0, fp(), fp = void 0);
  }
  Mt(e) {
    this.$promise !== void 0 && (pp = this.$reject, this.$resolve = this.$reject = this.$promise = void 0, pp(e), pp = void 0), this.$initiator !== this && this.parent.Mt(e);
  }
  Pt() {
    ++this.Bt, this.$initiator !== this && this.parent.Pt();
  }
  Ut() {
    if (--this.Bt === 0) {
      if (this.vmKind !== 2 && this.kt.attached != null && (Qs = Qt(...this.kt.attached.map(d4, this))), this.At.hasAttached && (Qs = Qt(Qs, this.Ct.attached(this.$initiator))), un(Qs)) {
        this.Lt(), Qs.then(() => {
          this.state = 2, this.Ht(), this.$initiator !== this && this.parent.Ut();
        }).catch((e) => {
          this.Mt(e);
        }), Qs = void 0;
        return;
      }
      Qs = void 0, this.state = 2, this.Ht();
    }
    this.$initiator !== this && this.parent.Ut();
  }
  qt() {
    ++this.St;
  }
  Ft() {
    if (--this.St === 0) {
      this.Ot(), this.removeNodes();
      let e = this.$initiator.head, t;
      for (; e !== null; )
        e !== this && (e.debug && e.logger.trace("detach()"), e.removeNodes()), e.vmKind !== 2 && e.kt.unbinding != null && (t = Qt(...e.kt.unbinding.map(p4, this))), e.At.hasUnbinding && (e.debug && e.logger.trace("unbinding()"), t = Qt(t, e.viewModel.unbinding(e.$initiator, e.parent))), un(t) && (this.Lt(), this.Ot(), t.then(() => {
          this.Vt();
        }).catch((r) => {
          this.Mt(r);
        })), t = void 0, e = e.next;
      this.Vt();
    }
  }
  Ot() {
    ++this._t;
  }
  Vt() {
    if (--this._t === 0) {
      let e = this.$initiator.head, t = null;
      for (; e !== null; )
        e !== this && (e.isBound = !1, e.unbind()), t = e.next, e.next = null, e = t;
      this.head = this.tail = null, this.isBound = !1, this.unbind();
    }
  }
  addBinding(e) {
    this.bindings === null ? this.bindings = [e] : this.bindings[this.bindings.length] = e;
  }
  addChild(e) {
    this.children === null ? this.children = [e] : this.children[this.children.length] = e;
  }
  is(e) {
    switch (this.vmKind) {
      case 1:
        return ph(this.Ct.constructor).name === e;
      case 0:
        return mh(this.Ct.constructor).name === e;
      case 2:
        return this.viewFactory.name === e;
    }
  }
  lockScope(e) {
    this.scope = e, this.hasLockedScope = !0;
  }
  setHost(e) {
    return this.vmKind === 0 && (En(e, Zt, this), En(e, this.definition.key, this)), this.host = e, this.mountTarget = 1, this;
  }
  setShadowRoot(e) {
    return this.vmKind === 0 && (En(e, Zt, this), En(e, this.definition.key, this)), this.shadowRoot = e, this.mountTarget = 2, this;
  }
  setLocation(e) {
    return this.vmKind === 0 && (En(e, Zt, this), En(e, this.definition.key, this)), this.location = e, this.mountTarget = 3, this;
  }
  release() {
    this.state |= 16;
  }
  dispose() {
    (this.state & 32) !== 32 && (this.state |= 32, this.At.hasDispose && this.Ct.dispose(), this.children !== null && (this.children.forEach(s4), this.children = null), this.hostController = null, this.scope = null, this.nodes = null, this.location = null, this.viewFactory = null, this.Ct !== null && (Zi.delete(this.Ct), this.Ct = null), this.Ct = null, this.host = null, this.shadowRoot = null, this.container.disposeResolvers());
  }
  accept(e) {
    if (e(this) === !0 || this.At.hasAccept && this.Ct.accept(e) === !0)
      return !0;
    if (this.children !== null) {
      const { children: t } = this;
      for (let r = 0, i = t.length; r < i; ++r)
        if (t[r].accept(e) === !0)
          return !0;
    }
  }
}
function Vb(n, e, t) {
  const r = e.bindables, i = l1(r), s = i.length, a = n.container.get(Ia);
  if (s > 0)
    for (let o = 0; o < s; ++o) {
      const u = i[o], l = r[u], d = l.callback, p = a.getObserver(t, u);
      if (l.set !== oa && p.useCoercer?.(l.set, n.coercion) !== !0)
        throw se(`AURxxxx: coercion(${gs(u)})`);
      if (t[d] != null || t.propertyChanged != null) {
        const m = (w, x) => {
          n.isBound && (t[d]?.(w, x), t.propertyChanged?.(u, w, x));
        };
        if (p.useCallback?.(m) !== !0)
          throw se(`AURxxx: changed(${gs})`);
      }
    }
}
const zb = /* @__PURE__ */ new Map(), n4 = (n) => {
  let e = zb.get(n);
  return e == null && (e = new bc(n, 0), zb.set(n, e)), e;
};
function Gb(n, e, t, r) {
  const i = e.get(Ia), s = e.get(E0), a = t.watches, o = n.vmKind === 0 ? n.scope : dn.create(r, null, !0), u = a.length;
  let l, d, p, m = 0;
  for (; u > m; ++m) {
    if ({ expression: l, callback: d } = a[m], d = Nr(d) ? d : Reflect.get(r, d), !Nr(d))
      throw se(`AUR0506:${gs(d)}`);
    Nr(l) ? n.addBinding(new E1(r, i, l, d, !0)) : (p = Et(l) ? s.parse(l, 16) : n4(l), n.addBinding(new q0(o, e, i, p, d)));
  }
}
class so {
  constructor(e) {
    this.hasDefine = "define" in e, this.hasHydrating = "hydrating" in e, this.hasHydrated = "hydrated" in e, this.hasCreated = "created" in e, this.hasBinding = "binding" in e, this.hasBound = "bound" in e, this.hasAttaching = "attaching" in e, this.hasAttached = "attached" in e, this.hasDetaching = "detaching" in e, this.hasUnbinding = "unbinding" in e, this.hasDispose = "dispose" in e, this.hasAccept = "accept" in e;
  }
}
so.none = new so({});
const r4 = {
  mode: "open"
};
var Hb;
(function(n) {
  n[n.customElement = 0] = "customElement", n[n.customAttribute = 1] = "customAttribute", n[n.synthetic = 2] = "synthetic";
})(Hb || (Hb = {}));
var qb;
(function(n) {
  n[n.none = 0] = "none", n[n.activating = 1] = "activating", n[n.activated = 2] = "activated", n[n.deactivating = 4] = "deactivating", n[n.deactivated = 8] = "deactivated", n[n.released = 16] = "released", n[n.disposed = 32] = "disposed";
})(qb || (qb = {}));
function Wb(n) {
  const e = [];
  return (n & 1) === 1 && e.push("activating"), (n & 2) === 2 && e.push("activated"), (n & 4) === 4 && e.push("deactivating"), (n & 8) === 8 && e.push("deactivated"), (n & 16) === 16 && e.push("released"), (n & 32) === 32 && e.push("disposed"), e.length === 0 ? "none" : e.join("|");
}
const nf = /* @__PURE__ */ $t("IController"), nd = /* @__PURE__ */ $t("IHydrationContext");
class i4 {
  constructor(e, t, r) {
    this.instruction = t, this.parent = r, this.controller = e;
  }
}
function s4(n) {
  n.dispose();
}
function Kb(n) {
  n.instance.created(this.Ct, this);
}
function a4(n) {
  n.instance.hydrating(this.Ct, this);
}
function o4(n) {
  n.instance.hydrated(this.Ct, this);
}
function u4(n) {
  return n.instance.binding(this.Ct, this.$initiator, this.parent);
}
function l4(n) {
  return n.instance.bound(this.Ct, this.$initiator, this.parent);
}
function c4(n) {
  return n.instance.attaching(this.Ct, this.$initiator, this.parent);
}
function d4(n) {
  return n.instance.attached(this.Ct, this.$initiator);
}
function f4(n) {
  return n.instance.detaching(this.Ct, this.$initiator, this.parent);
}
function p4(n) {
  return n.instance.unbinding(this.Ct, this.$initiator, this.parent);
}
let fp, pp, Qs;
class Q0 {
  constructor(e, t, r, i) {
    if (this.chars = e, this.repeat = t, this.isSymbol = r, this.isInverted = i, i)
      switch (e.length) {
        case 0:
          this.has = this.Jt;
          break;
        case 1:
          this.has = this.te;
          break;
        default:
          this.has = this.ee;
      }
    else
      switch (e.length) {
        case 0:
          this.has = this.ie;
          break;
        case 1:
          this.has = this.se;
          break;
        default:
          this.has = this.ne;
      }
  }
  equals(e) {
    return this.chars === e.chars && this.repeat === e.repeat && this.isSymbol === e.isSymbol && this.isInverted === e.isInverted;
  }
  ne(e) {
    return this.chars.includes(e);
  }
  se(e) {
    return this.chars === e;
  }
  ie(e) {
    return !1;
  }
  ee(e) {
    return !this.chars.includes(e);
  }
  te(e) {
    return this.chars !== e;
  }
  Jt(e) {
    return !0;
  }
}
class h4 {
  constructor() {
    this.parts = je, this.re = "", this.oe = {}, this.le = {};
  }
  get pattern() {
    const e = this.re;
    return e === "" ? null : e;
  }
  set pattern(e) {
    e == null ? (this.re = "", this.parts = je) : (this.re = e, this.parts = this.le[e]);
  }
  append(e, t) {
    const r = this.oe;
    r[e] === void 0 ? r[e] = t : r[e] += t;
  }
  next(e) {
    const t = this.oe;
    let r;
    t[e] !== void 0 && (r = this.le, r[e] === void 0 ? r[e] = [t[e]] : r[e].push(t[e]), t[e] = void 0);
  }
}
class Y0 {
  get re() {
    return this.he ? this.ae[0] : null;
  }
  constructor(e, ...t) {
    this.charSpec = e, this.ce = [], this.ue = null, this.he = !1, this.ae = t;
  }
  findChild(e) {
    const t = this.ce, r = t.length;
    let i = null, s = 0;
    for (; s < r; ++s)
      if (i = t[s], e.equals(i.charSpec))
        return i;
    return null;
  }
  append(e, t) {
    const r = this.ae;
    r.includes(t) || r.push(t);
    let i = this.findChild(e);
    return i == null && (i = new Y0(e, t), this.ce.push(i), e.repeat && i.ce.push(i)), i;
  }
  findMatches(e, t) {
    const r = [], i = this.ce, s = i.length;
    let a = 0, o = null, u = 0, l = 0;
    for (; u < s; ++u)
      if (o = i[u], o.charSpec.has(e))
        if (r.push(o), a = o.ae.length, l = 0, o.charSpec.isSymbol)
          for (; l < a; ++l)
            t.next(o.ae[l]);
        else
          for (; l < a; ++l)
            t.append(o.ae[l], e);
    return r;
  }
}
class Jb {
  constructor(e) {
    this.text = e;
    const t = this.fe = e.length, r = this.de = [];
    let i = 0;
    for (; t > i; ++i)
      r.push(new Q0(e[i], !1, !1, !1));
  }
  eachChar(e) {
    const t = this.fe, r = this.de;
    let i = 0;
    for (; t > i; ++i)
      e(r[i]);
  }
}
class y4 {
  constructor(e) {
    this.text = "PART", this.me = new Q0(e, !0, !1, !0);
  }
  eachChar(e) {
    e(this.me);
  }
}
class m4 {
  constructor(e) {
    this.text = e, this.me = new Q0(e, !1, !0, !1);
  }
  eachChar(e) {
    e(this.me);
  }
}
class b4 {
  constructor() {
    this.statics = 0, this.dynamics = 0, this.symbols = 0;
  }
}
const g4 = /* @__PURE__ */ $t("ISyntaxInterpreter", (n) => n.singleton(x4));
class x4 {
  constructor() {
    this.ge = new Y0(null), this.pe = [this.ge];
  }
  add(e) {
    e = e.slice(0).sort((m, w) => m.pattern > w.pattern ? 1 : -1);
    const t = e.length;
    let r, i, s, a, o, u, l, d = 0, p;
    for (; t > d; ) {
      for (r = this.ge, i = e[d], s = i.pattern, a = new b4(), o = this.ve(i, a), u = o.length, l = (m) => r = r.append(m, s), p = 0; u > p; ++p)
        o[p].eachChar(l);
      r.ue = a, r.he = !0, ++d;
    }
  }
  interpret(e) {
    const t = new h4(), r = e.length;
    let i = this.pe, s = 0, a;
    for (; s < r && (i = this.be(i, e.charAt(s), t), i.length !== 0); ++s)
      ;
    return i = i.filter(v4), i.length > 0 && (i.sort(w4), a = i[0], a.charSpec.isSymbol || t.next(a.re), t.pattern = a.re), t;
  }
  be(e, t, r) {
    const i = [];
    let s = null;
    const a = e.length;
    let o = 0;
    for (; o < a; ++o)
      s = e[o], i.push(...s.findMatches(t, r));
    return i;
  }
  ve(e, t) {
    const r = [], i = e.pattern, s = i.length, a = e.symbols;
    let o = 0, u = 0, l = "";
    for (; o < s; )
      l = i.charAt(o), a.length === 0 || !a.includes(l) ? o === u && l === "P" && i.slice(o, o + 4) === "PART" ? (u = o = o + 4, r.push(new y4(a)), ++t.dynamics) : ++o : o !== u ? (r.push(new Jb(i.slice(u, o))), ++t.statics, u = o) : (r.push(new m4(i.slice(u, o + 1))), ++t.symbols, u = ++o);
    return u !== o && (r.push(new Jb(i.slice(u, o))), ++t.statics), r;
  }
}
function v4(n) {
  return n.he;
}
function w4(n, e) {
  const t = n.ue, r = e.ue;
  return t.statics !== r.statics ? r.statics - t.statics : t.dynamics !== r.dynamics ? r.dynamics - t.dynamics : t.symbols !== r.symbols ? r.symbols - t.symbols : 0;
}
class hr {
  constructor(e, t, r, i) {
    this.rawName = e, this.rawValue = t, this.target = r, this.command = i;
  }
}
const V1 = /* @__PURE__ */ $t("IAttributePattern"), T4 = /* @__PURE__ */ $t("IAttributeParser", (n) => n.singleton(z1));
class z1 {
  constructor(e, t) {
    this.ot = {}, this.xe = e;
    const r = this.ae = {}, i = t.reduce((s, a) => {
      const o = G1(a.constructor);
      return o.forEach((u) => r[u.pattern] = a), s.concat(o);
    }, je);
    e.add(i);
  }
  parse(e, t) {
    let r = this.ot[e];
    r == null && (r = this.ot[e] = this.xe.interpret(e));
    const i = r.pattern;
    return i == null ? new hr(e, t, e, null) : this.ae[i][i](e, t, r.parts);
  }
}
z1.inject = [g4, vv(V1)];
function Gi(...n) {
  return function(t) {
    return E4.define(n, t);
  };
}
class A4 {
  constructor(e) {
    this.Type = e, this.name = void 0;
  }
  register(e) {
    Uo(V1, this.Type).register(e);
  }
}
const hp = $o("attribute-pattern"), Ac = "attribute-pattern-definitions", G1 = (n) => ko.annotation.get(n, Ac), E4 = Ui({
  name: hp,
  definitionAnnotationKey: Ac,
  define(n, e) {
    const t = new A4(e);
    return Ft(hp, t, e), Oa(e, hp), ko.annotation.set(e, Ac, n), u1(e, Ac), e;
  },
  getPatternDefinitions: G1
});
let Qb = class {
  "PART.PART"(e, t, r) {
    return new hr(e, t, r[0], r[1]);
  }
  "PART.PART.PART"(e, t, r) {
    return new hr(e, t, `${r[0]}.${r[1]}`, r[2]);
  }
};
Qb = Z([Gi({
  pattern: "PART.PART",
  symbols: "."
}, {
  pattern: "PART.PART.PART",
  symbols: "."
})], Qb);
let Yb = class {
  ref(e, t, r) {
    return new hr(e, t, "element", "ref");
  }
  "PART.ref"(e, t, r) {
    return new hr(e, t, r[0], "ref");
  }
};
Yb = Z([Gi({
  pattern: "ref",
  symbols: ""
}, {
  pattern: "PART.ref",
  symbols: "."
})], Yb);
let Xb = class {
  ":PART"(e, t, r) {
    return new hr(e, t, r[0], "bind");
  }
};
Xb = Z([Gi({
  pattern: ":PART",
  symbols: ":"
})], Xb);
let Zb = class {
  "@PART"(e, t, r) {
    return new hr(e, t, r[0], "trigger");
  }
};
Zb = Z([Gi({
  pattern: "@PART",
  symbols: "@"
})], Zb);
let eg = class {
  "...$attrs"(e, t, r) {
    return new hr(e, t, "", "...$attrs");
  }
};
eg = Z([Gi({
  pattern: "...$attrs",
  symbols: ""
})], eg);
var tg;
(function(n) {
  n[n.None = 0] = "None", n[n.IgnoreAttr = 1] = "IgnoreAttr";
})(tg || (tg = {}));
function Wn(n) {
  return function(e) {
    return q1.define(n, e);
  };
}
class X0 {
  constructor(e, t, r, i, s) {
    this.Type = e, this.name = t, this.aliases = r, this.key = i, this.type = s;
  }
  static create(e, t) {
    let r, i;
    return Et(e) ? (r = e, i = {
      name: r
    }) : (r = e.name, i = e), new X0(t, os(Ec(t, "name"), r), jt(Ec(t, "aliases"), i.aliases, t.aliases), H1(r), os(Ec(t, "type"), i.type, t.type, null));
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    Uo(r, t).register(e), wl(r, t).register(e), Tl(i, q1, r, e);
  }
}
const pu = $o("binding-command"), H1 = (n) => `${pu}:${n}`, Ec = (n, e) => Rn(Hn(e), n), q1 = Ui({
  name: pu,
  keyFrom: H1,
  define(n, e) {
    const t = X0.create(n, e);
    return Ft(pu, t, t.Type), Ft(pu, t, t), Oa(e, pu), t.Type;
  },
  getAnnotation: Ec
});
let ng = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    let s = e.attr.target, a = e.attr.rawValue;
    return e.bindable == null ? s = r.map(e.node, s) ?? er(s) : (a === "" && e.def.type === 1 && (a = er(s)), s = e.bindable.property), new Pl(t.parse(a, 16), s, 1);
  }
};
ng = Z([Wn("one-time")], ng);
let rg = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    let s = e.attr.target, a = e.attr.rawValue;
    return e.bindable == null ? s = r.map(e.node, s) ?? er(s) : (a === "" && e.def.type === 1 && (a = er(s)), s = e.bindable.property), new Pl(t.parse(a, 16), s, 2);
  }
};
rg = Z([Wn("to-view")], rg);
let ig = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    const i = e.attr;
    let s = i.target, a = i.rawValue;
    return e.bindable == null ? s = r.map(e.node, s) ?? er(s) : (a === "" && e.def.type === 1 && (a = er(s)), s = e.bindable.property), new Pl(t.parse(a, 16), s, 4);
  }
};
ig = Z([Wn("from-view")], ig);
let sg = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    const i = e.attr;
    let s = i.target, a = i.rawValue;
    return e.bindable == null ? s = r.map(e.node, s) ?? er(s) : (a === "" && e.def.type === 1 && (a = er(s)), s = e.bindable.property), new Pl(t.parse(a, 16), s, 6);
  }
};
sg = Z([Wn("two-way")], sg);
let ag = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    const i = e.attr, s = e.bindable;
    let a, o, u = i.target, l = i.rawValue;
    return s == null ? (o = r.isTwoWay(e.node, u) ? 6 : 2, u = r.map(e.node, u) ?? er(u)) : (l === "" && e.def.type === 1 && (l = er(u)), a = e.def.defaultBindingMode, o = s.mode === 8 || s.mode == null ? a == null || a === 8 ? 2 : a : s.mode, u = s.property), new Pl(t.parse(l, 16), u, o);
  }
};
ag = Z([Wn("bind")], ag);
let og = class {
  get type() {
    return 0;
  }
  static get inject() {
    return [T4];
  }
  constructor(e) {
    this.we = e;
  }
  build(e, t) {
    const r = e.bindable === null ? er(e.attr.target) : e.bindable.property, i = t.parse(e.attr.rawValue, 2);
    let s = je;
    if (i.semiIdx > -1) {
      const a = e.attr.rawValue.slice(i.semiIdx + 1), o = a.indexOf(":");
      if (o > -1) {
        const u = a.slice(0, o).trim(), l = a.slice(o + 1).trim(), d = this.we.parse(u, l);
        s = [new q8(l, d.target, d.command)];
      }
    }
    return new G8(i, r, s);
  }
};
og = Z([Wn("for")], og);
let ug = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new R1(t.parse(e.attr.rawValue, 8), e.attr.target, !0, !1);
  }
};
ug = Z([Wn("trigger")], ug);
let lg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new R1(t.parse(e.attr.rawValue, 8), e.attr.target, !1, !0);
  }
};
lg = Z([Wn("capture")], lg);
let cg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new K0(e.attr.target, t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
cg = Z([Wn("attr")], cg);
let dg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new K0("style", t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
dg = Z([Wn("style")], dg);
let fg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new K0("class", t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
fg = Z([Wn("class")], fg);
let pg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new H8(t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
pg = Z([Wn("ref")], pg);
let hg = class {
  get type() {
    return 1;
  }
  build(e) {
    return new W8();
  }
};
hg = Z([Wn("...$attrs")], hg);
const S4 = /* @__PURE__ */ $t("ISVGAnalyzer", (n) => n.singleton(C4));
class C4 {
  isStandardSvgAttribute(e, t) {
    return !1;
  }
}
var yg;
(function(n) {
  n[n.oneTime = 1] = "oneTime", n[n.toView = 2] = "toView", n[n.fromView = 4] = "fromView", n[n.twoWay = 6] = "twoWay", n[n.default = 8] = "default";
})(yg || (yg = {}));
const mg = Jn();
class Gu {
  static forNs(e) {
    return mg[e] ?? (mg[e] = new Gu(e));
  }
  constructor(e) {
    this.ns = e, this.type = 6;
  }
  getValue(e, t) {
    return e.getAttributeNS(this.ns, t);
  }
  setValue(e, t, r) {
    e == null ? t.removeAttributeNS(this.ns, r) : t.setAttributeNS(this.ns, r, e);
  }
}
Zd(Gu);
class W1 {
  constructor() {
    this.type = 6;
  }
  getValue(e, t) {
    return e.getAttribute(t);
  }
  setValue(e, t, r) {
    e == null ? t.removeAttribute(r) : t.setAttribute(r, e);
  }
}
Zd(W1);
const Sc = new W1(), _4 = {
  childList: !0,
  subtree: !0,
  characterData: !0
};
function bg(n, e) {
  return n === e;
}
class Z0 {
  constructor(e, t, r, i) {
    this.type = 7, this.v = void 0, this.ov = void 0, this.F = !1, this.Be = void 0, this.Se = void 0, this.iO = !1, this.L = !1, this.P = e, this.oL = i, this.cf = r;
  }
  getValue() {
    return this.iO ? this.v : this.P.multiple ? M4(this.P.options) : this.P.value;
  }
  setValue(e) {
    this.ov = this.v, this.v = e, this.F = e !== this.ov, this._e(e instanceof Array ? e : null), this.H();
  }
  H() {
    this.F && (this.F = !1, this.syncOptions());
  }
  handleCollectionChange() {
    this.syncOptions();
  }
  syncOptions() {
    const e = this.v, t = this.P, r = ti(e), i = t.matcher ?? bg, s = t.options;
    let a = s.length;
    for (; a-- > 0; ) {
      const o = s[a], u = fs.call(o, "model") ? o.model : o.value;
      if (r) {
        o.selected = e.findIndex((l) => !!i(u, l)) !== -1;
        continue;
      }
      o.selected = !!i(u, e);
    }
  }
  syncValue() {
    const e = this.P, t = e.options, r = t.length, i = this.v;
    let s = 0;
    if (e.multiple) {
      if (!(i instanceof Array))
        return !0;
      let u;
      const l = e.matcher || bg, d = [];
      for (; s < r; )
        u = t[s], u.selected && d.push(fs.call(u, "model") ? u.model : u.value), ++s;
      let p;
      for (s = 0; s < i.length; )
        p = i[s], d.findIndex((m) => !!l(p, m)) === -1 ? i.splice(s, 1) : ++s;
      for (s = 0; s < d.length; )
        p = d[s], i.findIndex((m) => !!l(p, m)) === -1 && i.push(p), ++s;
      return !1;
    }
    let a = null, o;
    for (; s < r; ) {
      if (o = t[s], o.selected) {
        a = fs.call(o, "model") ? o.model : o.value;
        break;
      }
      ++s;
    }
    return this.ov = this.v, this.v = a, !0;
  }
  M() {
    (this.Se = F0(this.P, this.Te.bind(this))).observe(this.P, _4), this._e(this.v instanceof Array ? this.v : null), this.iO = !0;
  }
  $() {
    this.Se.disconnect(), this.Be?.unsubscribe(this), this.Se = this.Be = void 0, this.iO = !1;
  }
  _e(e) {
    if (this.Be?.unsubscribe(this), this.Be = void 0, e != null) {
      if (!this.P.multiple)
        throw se("AUR0654");
      (this.Be = this.oL.getArrayObserver(e)).subscribe(this);
    }
  }
  handleEvent() {
    this.syncValue() && this.Y();
  }
  Te(e) {
    this.syncOptions(), this.syncValue() && this.Y();
  }
  Y() {
    gg = this.ov, this.ov = this.v, this.subs.notify(this.v, gg);
  }
}
G0(Z0);
tr(Z0);
function M4(n) {
  const e = [];
  if (n.length === 0)
    return e;
  const t = n.length;
  let r = 0, i;
  for (; t > r; )
    i = n[r], i.selected && (e[e.length] = fs.call(i, "model") ? i.model : i.value), ++r;
  return e;
}
let gg;
const P4 = "--";
class K1 {
  constructor(e) {
    this.obj = e, this.type = 6, this.v = "", this.ov = "", this.styles = {}, this.version = 0, this.F = !1;
  }
  getValue() {
    return this.obj.style.cssText;
  }
  setValue(e) {
    this.v = e, this.F = e !== this.ov, this.H();
  }
  Ie(e) {
    const t = [], r = /url\([^)]+$/;
    let i = 0, s = "", a, o, u, l;
    for (; i < e.length; ) {
      if (a = e.indexOf(";", i), a === -1 && (a = e.length), s += e.substring(i, a), i = a + 1, r.test(s)) {
        s += ";";
        continue;
      }
      o = s.indexOf(":"), u = s.substring(0, o).trim(), l = s.substring(o + 1).trim(), t.push([u, l]), s = "";
    }
    return t;
  }
  Ee(e) {
    let t, r;
    const i = [];
    for (r in e)
      if (t = e[r], t != null) {
        if (Et(t)) {
          if (r.startsWith(P4)) {
            i.push([r, t]);
            continue;
          }
          i.push([hv(r), t]);
          continue;
        }
        i.push(...this.Pe(t));
      }
    return i;
  }
  Le(e) {
    const t = e.length;
    if (t > 0) {
      const r = [];
      let i = 0;
      for (; t > i; ++i)
        r.push(...this.Pe(e[i]));
      return r;
    }
    return je;
  }
  Pe(e) {
    return Et(e) ? this.Ie(e) : e instanceof Array ? this.Le(e) : e instanceof Object ? this.Ee(e) : je;
  }
  H() {
    if (this.F) {
      this.F = !1;
      const e = this.v, t = this.styles, r = this.Pe(e);
      let i, s = this.version;
      this.ov = e;
      let a, o, u, l = 0;
      const d = r.length;
      for (; l < d; ++l)
        a = r[l], o = a[0], u = a[1], this.setProperty(o, u), t[o] = s;
      if (this.styles = t, this.version += 1, s === 0)
        return;
      s -= 1;
      for (i in t)
        !fs.call(t, i) || t[i] !== s || this.obj.style.removeProperty(i);
    }
  }
  setProperty(e, t) {
    let r = "";
    t != null && Nr(t.indexOf) && t.includes("!important") && (r = "important", t = t.replace("!important", "")), this.obj.style.setProperty(e, t, r);
  }
  bind() {
    this.v = this.ov = this.obj.style.cssText;
  }
}
Zd(K1);
class ey {
  constructor(e, t, r) {
    this.type = 7, this.v = "", this.ov = "", this.F = !1, this.L = !1, this.P = e, this.k = t, this.cf = r;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    Qd(e, this.v) || (this.ov = this.v, this.v = e, this.F = !0, this.cf.readonly || this.H());
  }
  H() {
    this.F && (this.F = !1, this.P[this.k] = this.v ?? this.cf.default, this.Y());
  }
  handleEvent() {
    this.ov = this.v, this.v = this.P[this.k], this.ov !== this.v && (this.F = !1, this.Y());
  }
  M() {
    this.v = this.ov = this.P[this.k];
  }
  Y() {
    xg = this.ov, this.ov = this.v, this.subs.notify(this.v, xg);
  }
}
G0(ey);
tr(ey);
let xg;
const Ys = "http://www.w3.org/1999/xlink", vg = "http://www.w3.org/XML/1998/namespace", wg = "http://www.w3.org/2000/xmlns/", Tg = Jd(Jn(), {
  "xlink:actuate": ["actuate", Ys],
  "xlink:arcrole": ["arcrole", Ys],
  "xlink:href": ["href", Ys],
  "xlink:role": ["role", Ys],
  "xlink:show": ["show", Ys],
  "xlink:title": ["title", Ys],
  "xlink:type": ["type", Ys],
  "xml:lang": ["lang", vg],
  "xml:space": ["space", vg],
  xmlns: ["xmlns", wg],
  "xmlns:xlink": ["xlink", wg]
}), J1 = new i1();
J1.type = 6;
class Hu {
  constructor(e, t, r, i) {
    this.locator = e, this.platform = t, this.dirtyChecker = r, this.svgAnalyzer = i, this.allowDirtyCheck = !0, this.Me = Jn(), this.De = Jn(), this.$e = Jn(), this.Ue = Jn();
    const s = ["change", "input"], a = {
      events: s,
      default: ""
    };
    this.useConfig({
      INPUT: {
        value: a,
        valueAsNumber: {
          events: s,
          default: 0
        },
        checked: {
          type: ty,
          events: s
        },
        files: {
          events: s,
          readonly: !0
        }
      },
      SELECT: {
        value: {
          type: Z0,
          events: ["change"],
          default: ""
        }
      },
      TEXTAREA: {
        value: a
      }
    });
    const o = {
      events: ["change", "input", "blur", "keyup", "paste"],
      default: ""
    }, u = {
      events: ["scroll"],
      default: 0
    };
    this.useConfigGlobal({
      scrollTop: u,
      scrollLeft: u,
      textContent: o,
      innerHTML: o
    }), this.overrideAccessorGlobal("css", "style", "class"), this.overrideAccessor({
      INPUT: ["value", "checked", "model"],
      SELECT: ["value"],
      TEXTAREA: ["value"]
    });
  }
  static register(e) {
    wl(Qc, Hu).register(e), Uo(Qc, Hu).register(e);
  }
  handles(e, t) {
    return e instanceof this.platform.Node;
  }
  useConfig(e, t, r) {
    const i = this.Me;
    let s;
    if (Et(e))
      s = i[e] ?? (i[e] = Jn()), s[t] == null ? s[t] = r : ec(e, t);
    else
      for (const a in e) {
        s = i[a] ?? (i[a] = Jn());
        const o = e[a];
        for (t in o)
          s[t] == null ? s[t] = o[t] : ec(a, t);
      }
  }
  useConfigGlobal(e, t) {
    const r = this.De;
    if (typeof e == "object")
      for (const i in e)
        r[i] == null ? r[i] = e[i] : ec("*", i);
    else
      r[e] == null ? r[e] = t : ec("*", e);
  }
  getAccessor(e, t, r) {
    if (t in this.Ue || t in (this.$e[e.tagName] ?? S3))
      return this.getObserver(e, t, r);
    switch (t) {
      case "src":
      case "href":
      case "role":
      case "minLength":
      case "maxLength":
      case "placeholder":
      case "size":
      case "pattern":
      case "title":
        return Sc;
      default: {
        const i = Tg[t];
        return i !== void 0 ? Gu.forNs(i[1]) : cb(e, t, this.svgAnalyzer) ? Sc : J1;
      }
    }
  }
  overrideAccessor(e, t) {
    var r, i;
    let s;
    if (Et(e))
      s = (r = this.$e)[e] ?? (r[e] = Jn()), s[t] = !0;
    else
      for (const a in e)
        for (const o of e[a])
          s = (i = this.$e)[a] ?? (i[a] = Jn()), s[o] = !0;
  }
  overrideAccessorGlobal(...e) {
    for (const t of e)
      this.Ue[t] = !0;
  }
  getNodeObserverConfig(e, t) {
    return this.Me[e.tagName]?.[t] ?? this.De[t];
  }
  getNodeObserver(e, t, r) {
    const i = this.Me[e.tagName]?.[t] ?? this.De[t];
    let s;
    return i != null ? (s = new (i.type ?? ey)(e, t, i, r, this.locator), s.doNotCache || (a1(e)[t] = s), s) : null;
  }
  getObserver(e, t, r) {
    switch (t) {
      case "class":
        return new T1(e);
      case "css":
      case "style":
        return new K1(e);
    }
    const i = this.getNodeObserver(e, t, r);
    if (i != null)
      return i;
    const s = Tg[t];
    if (s !== void 0)
      return Gu.forNs(s[1]);
    if (cb(e, t, this.svgAnalyzer))
      return Sc;
    if (t in e.constructor.prototype) {
      if (this.allowDirtyCheck)
        return this.dirtyChecker.createProperty(e, t);
      throw se(`AUR0652:${gs(t)}`);
    } else
      return new k0(e, t);
  }
}
Hu.inject = [b3, ji, t1, S4];
function R4(n, e) {
  if (n instanceof Array)
    return e.getArrayObserver(n);
  if (n instanceof Map)
    return e.getMapObserver(n);
  if (n instanceof Set)
    return e.getSetObserver(n);
}
function ec(n, e) {
  throw se(`AUR0653:${gs(e)}@${n}`);
}
function Ag(n, e) {
  return n === e;
}
class ty {
  constructor(e, t, r, i) {
    this.type = 7, this.v = void 0, this.ov = void 0, this.qe = void 0, this.Fe = void 0, this.L = !1, this.P = e, this.oL = i, this.cf = r;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    const t = this.v;
    e !== t && (this.v = e, this.ov = t, this.He(), this.Oe(), this.Y());
  }
  handleCollectionChange() {
    this.Oe();
  }
  handleChange(e, t) {
    this.Oe();
  }
  Oe() {
    const e = this.v, t = this.P, r = fs.call(t, "model") ? t.model : t.value, i = t.type === "radio", s = t.matcher !== void 0 ? t.matcher : Ag;
    if (i)
      t.checked = !!s(e, r);
    else if (e === !0)
      t.checked = !0;
    else {
      let a = !1;
      if (ti(e))
        a = e.findIndex((o) => !!s(o, r)) !== -1;
      else if (e instanceof Set) {
        for (const o of e)
          if (s(o, r)) {
            a = !0;
            break;
          }
      } else if (e instanceof Map)
        for (const o of e) {
          const u = o[0], l = o[1];
          if (s(u, r) && l === !0) {
            a = !0;
            break;
          }
        }
      t.checked = a;
    }
  }
  handleEvent() {
    let e = this.ov = this.v;
    const t = this.P, r = fs.call(t, "model") ? t.model : t.value, i = t.checked, s = t.matcher !== void 0 ? t.matcher : Ag;
    if (t.type === "checkbox") {
      if (ti(e)) {
        const a = e.findIndex((o) => !!s(o, r));
        i && a === -1 ? e.push(r) : !i && a !== -1 && e.splice(a, 1);
        return;
      } else if (e instanceof Set) {
        const a = {};
        let o = a;
        for (const u of e)
          if (s(u, r) === !0) {
            o = u;
            break;
          }
        i && o === a ? e.add(r) : !i && o !== a && e.delete(o);
        return;
      } else if (e instanceof Map) {
        let a;
        for (const o of e) {
          const u = o[0];
          if (s(u, r) === !0) {
            a = u;
            break;
          }
        }
        e.set(a, i);
        return;
      }
      e = i;
    } else if (i)
      e = r;
    else
      return;
    this.v = e, this.Y();
  }
  M() {
    this.He();
  }
  $() {
    this.qe?.unsubscribe(this), this.Fe?.unsubscribe(this), this.qe = this.Fe = void 0;
  }
  Y() {
    Eg = this.ov, this.ov = this.v, this.subs.notify(this.v, Eg);
  }
  He() {
    const e = this.P;
    (this.Fe ?? (this.Fe = e.$observers?.model ?? e.$observers?.value))?.subscribe(this), this.qe?.unsubscribe(this), this.qe = void 0, e.type === "checkbox" && (this.qe = R4(this.v, this.oL))?.subscribe(this);
  }
}
G0(ty);
tr(ty);
let Eg;
class I4 {
  bind(e, t) {
    if (!(t instanceof Vi))
      throw se("AURxxxx");
    t.useTargetObserver(Sc);
  }
}
qn("attr")(I4);
class O4 {
  bind(e, t) {
    if (!(t instanceof Ml))
      throw se("AUR0801");
    t.self = !0;
  }
  unbind(e, t) {
    t.self = !1;
  }
}
qn("self")(O4);
class Q1 {
  constructor(e, t) {
    if (!(t instanceof Hu))
      throw se("AURxxxx: updateTrigger binding behavior only works with the default implementation of Aurelia HTML observation. Implement your own node observation + updateTrigger");
    this.oL = e, this.Ve = t;
  }
  bind(e, t, ...r) {
    if (r.length === 0)
      throw se("AUR0802");
    if (!(t instanceof Vi) || !(t.mode & 4))
      throw se("AUR0803");
    const i = this.Ve.getNodeObserverConfig(t.target, t.targetProperty);
    if (i == null)
      throw se("AURxxxx");
    const s = this.Ve.getNodeObserver(t.target, t.targetProperty, this.oL);
    s.useConfig({
      readonly: i.readonly,
      default: i.default,
      events: r
    }), t.useTargetObserver(s);
  }
}
Q1.inject = [Ia, Qc];
qn("updateTrigger")(Q1);
class xo {
  constructor(e, t) {
    this.elseFactory = void 0, this.elseView = void 0, this.ifView = void 0, this.view = void 0, this.value = !1, this.cache = !0, this.pending = void 0, this.Ne = !1, this.je = 0, this.We = e, this.l = t;
  }
  attaching(e, t) {
    let r;
    const i = this.$controller, s = this.je++, a = () => !this.Ne && this.je === s + 1;
    return Pe(this.pending, () => {
      a() && (this.pending = void 0, this.value ? r = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this.We.create() : r = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create(), r != null && (r.setLocation(this.l), this.pending = Pe(r.activate(e, i, i.scope), () => {
        a() && (this.pending = void 0);
      })));
    });
  }
  detaching(e, t) {
    return this.Ne = !0, Pe(this.pending, () => {
      this.Ne = !1, this.pending = void 0, this.view?.deactivate(e, this.$controller);
    });
  }
  valueChanged(e, t) {
    if (!this.$controller.isActive || (e = !!e, t = !!t, e === t))
      return;
    const r = this.view, i = this.$controller, s = this.je++, a = () => !this.Ne && this.je === s + 1;
    let o;
    return Pe(this.pending, () => this.pending = Pe(r?.deactivate(r, i), () => {
      if (a() && (e ? o = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this.We.create() : o = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create(), o != null))
        return o.setLocation(this.l), Pe(o.activate(o, i, i.scope), () => {
          a() && (this.pending = void 0);
        });
    }));
  }
  dispose() {
    this.ifView?.dispose(), this.elseView?.dispose(), this.ifView = this.elseView = this.view = void 0;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
}
xo.inject = [nr, In];
Z([Ue], xo.prototype, "value", void 0);
Z([Ue({
  set: (n) => n === "" || !!n && n !== "false"
})], xo.prototype, "cache", void 0);
mr("if")(xo);
class Y1 {
  constructor(e) {
    this.f = e;
  }
  link(e, t, r, i) {
    const s = e.children, a = s[s.length - 1];
    if (a instanceof xo)
      a.elseFactory = this.f;
    else if (a.viewModel instanceof xo)
      a.viewModel.elseFactory = this.f;
    else
      throw se("AUR0810");
  }
}
Y1.inject = [nr];
mr({
  name: "else"
})(Y1);
function k4(n) {
  n.dispose();
}
const N4 = [18, 17];
class ny {
  constructor(e, t, r, i, s) {
    this.views = [], this.key = null, this.ze = /* @__PURE__ */ new Map(), this.Ge = /* @__PURE__ */ new Map(), this.Xe = void 0, this.Ke = !1, this.Qe = !1, this.Ye = null, this.Ze = void 0, this.Je = !1;
    const a = e.props[0].props[0];
    if (a !== void 0) {
      const { to: o, value: u, command: l } = a;
      if (o === "key")
        if (l === null)
          this.key = u;
        else if (l === "bind")
          this.key = t.parse(u, 16);
        else
          throw se(`AUR775:${l}`);
      else
        throw se(`AUR776:${o}`);
    }
    this.l = r, this.ti = i, this.f = s;
  }
  binding(e, t) {
    const r = this.ti.bindings, i = r.length;
    let s, a, o = 0;
    for (; i > o; ++o)
      if (s = r[o], s.target === this && s.targetProperty === "items") {
        a = this.forOf = s.ast, this.ei = s;
        let l = a.iterable;
        for (; l != null && N4.includes(l.$kind); )
          l = l.expression, this.Ke = !0;
        this.Ye = l;
        break;
      }
    this.ii();
    const u = a.declaration;
    (this.Je = u.$kind === 24 || u.$kind === 25) || (this.local = z(u, this.$controller.scope, s, null));
  }
  attaching(e, t) {
    return this.si(), this.ni(e);
  }
  detaching(e, t) {
    return this.ii(), this.ri(e);
  }
  unbinding(e, t) {
    this.Ge.clear(), this.ze.clear();
  }
  itemsChanged() {
    this.$controller.isActive && (this.ii(), this.si(), this.oi(this.items, void 0));
  }
  handleCollectionChange(e, t) {
    const r = this.$controller;
    if (r.isActive) {
      if (this.Ke) {
        if (this.Qe)
          return;
        this.Qe = !0, this.items = z(this.forOf.iterable, r.scope, this.ei, null), this.Qe = !1;
        return;
      }
      this.si(), this.oi(e, t);
    }
  }
  oi(e, t) {
    const r = this.views, i = r.length, s = this.key, a = s !== null;
    if (a || t === void 0) {
      const o = this.local, u = this.Ze, l = u.length, d = this.forOf, p = d.declaration, m = this.ei, w = this.Je;
      t = pa(l);
      let x = 0;
      if (i === 0)
        for (; x < l; ++x)
          t[x] = -2;
      else if (l === 0)
        if (w)
          for (x = 0; x < i; ++x)
            t.deletedIndices.push(x), t.deletedItems.push(z(p, r[x].scope, m, null));
        else
          for (x = 0; x < i; ++x)
            t.deletedIndices.push(x), t.deletedItems.push(r[x].scope.bindingContext[o]);
      else {
        const T = Array(i);
        if (w)
          for (x = 0; x < i; ++x)
            T[x] = z(p, r[x].scope, m, null);
        else
          for (x = 0; x < i; ++x)
            T[x] = r[x].scope.bindingContext[o];
        let A, M, I, B, k = 0;
        const N = i - 1, U = l - 1, W = /* @__PURE__ */ new Map(), G = /* @__PURE__ */ new Map(), Y = this.ze, ue = this.Ge, K = this.$controller.scope;
        x = 0;
        e: {
          for (; ; ) {
            if (a ? (A = T[x], M = u[x], I = Va(Y, s, A, Xs(ue, A, d, K, m, o, w), m), B = Va(Y, s, M, Xs(ue, M, d, K, m, o, w), m)) : (A = I = Zs(T[x], x), M = B = Zs(u[x], x)), I !== B) {
              Y.set(A, I), Y.set(M, B);
              break;
            }
            if (++x, x > N || x > U)
              break e;
          }
          if (N !== U)
            break e;
          for (k = U; ; ) {
            if (a ? (A = T[k], M = u[k], I = Va(Y, s, A, Xs(ue, A, d, K, m, o, w), m), B = Va(Y, s, M, Xs(ue, M, d, K, m, o, w), m)) : (A = I = Zs(T[x], x), M = B = Zs(u[x], x)), I !== B) {
              Y.set(A, I), Y.set(M, B);
              break;
            }
            if (--k, x > k)
              break e;
          }
        }
        const le = x, C = x;
        for (x = C; x <= U; ++x)
          Y.has(M = a ? u[x] : Zs(u[x], x)) ? B = Y.get(M) : (B = a ? Va(Y, s, M, Xs(ue, M, d, K, m, o, w), m) : M, Y.set(M, B)), G.set(B, x);
        for (x = le; x <= N; ++x)
          Y.has(A = a ? T[x] : Zs(T[x], x)) ? I = Y.get(A) : I = a ? Va(Y, s, A, r[x].scope, m) : A, W.set(I, x), G.has(I) ? t[G.get(I)] = x : (t.deletedIndices.push(x), t.deletedItems.push(A));
        for (x = C; x <= U; ++x)
          W.has(Y.get(a ? u[x] : Zs(u[x], x))) || (t[x] = -2);
        W.clear(), G.clear();
      }
    }
    if (t === void 0) {
      const o = Pe(this.ri(null), () => this.ni(null));
      un(o) && o.catch(Yc);
    } else {
      const o = lA(t);
      if (o.deletedIndices.length > 0) {
        const u = Pe(this.li(o), () => this.hi(i, o));
        un(u) && u.catch(Yc);
      } else
        this.hi(i, o);
    }
  }
  ii() {
    const e = this.$controller.scope;
    let t = this.ai, r = this.Ke, i;
    r && (t = this.ai = z(this.Ye, e, this.ei, null) ?? null, r = this.Ke = !Qd(this.items, t));
    const s = this.Xe;
    this.$controller.isActive ? (i = this.Xe = jE(r ? t : this.items), s !== i && (s?.unsubscribe(this), i?.subscribe(this))) : (s?.unsubscribe(this), this.Xe = void 0);
  }
  si() {
    const { items: e } = this;
    if (ti(e)) {
      this.Ze = e;
      return;
    }
    const t = [];
    Sg(e, (r, i) => {
      t[i] = r;
    }), this.Ze = t;
  }
  ni(e) {
    let t, r, i, s;
    const { $controller: a, f: o, local: u, l, items: d, Ge: p, ei: m, forOf: w, Je: x } = this, T = a.scope, A = F4(d), M = this.views = Array(A);
    if (Sg(d, (I, B) => {
      i = M[B] = o.create().setLocation(l), i.nodes.unlink(), s = Xs(p, I, w, T, m, u, x), nc(s.overrideContext, B, A), r = i.activate(e ?? i, a, s), un(r) && (t ?? (t = [])).push(r);
    }), t !== void 0)
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  ri(e) {
    let t, r, i, s = 0;
    const { views: a, $controller: o } = this, u = a.length;
    for (; u > s; ++s)
      i = a[s], i.release(), r = i.deactivate(e ?? i, o), un(r) && (t ?? (t = [])).push(r);
    if (t !== void 0)
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  li(e) {
    let t, r, i;
    const { $controller: s, views: a } = this, o = e.deletedIndices, u = o.length;
    let l = 0;
    for (; u > l; ++l)
      i = a[o[l]], i.release(), r = i.deactivate(i, s), un(r) && (t ?? (t = [])).push(r);
    l = 0;
    let d = 0;
    for (; u > l; ++l)
      d = o[l] - l, a.splice(d, 1);
    if (t !== void 0)
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  hi(e, t) {
    let r, i, s, a, o = 0;
    const { $controller: u, f: l, local: d, Ze: p, l: m, views: w, Je: x, ei: T, Ge: A, forOf: M } = this, I = t.length;
    for (; I > o; ++o)
      t[o] === -2 && (s = l.create(), w.splice(o, 0, s));
    if (w.length !== I)
      throw B4(w.length, I);
    const B = u.scope, k = t.length;
    cA(w, t);
    const N = D4(t), U = N.length, W = M.declaration;
    let G, Y = U - 1;
    for (o = k - 1; o >= 0; --o)
      s = w[o], G = w[o + 1], s.nodes.link(G?.nodes ?? m), t[o] === -2 ? (a = Xs(A, p[o], M, B, T, d, x), nc(a.overrideContext, o, k), s.setLocation(m), i = s.activate(s, u, a), un(i) && (r ?? (r = [])).push(i)) : Y < 0 || U === 1 || o !== N[Y] ? (x ? bn(W, s.scope, T, p[o]) : s.scope.bindingContext[d] = p[o], nc(s.scope.overrideContext, o, k), s.nodes.insertBefore(s.location)) : (x ? bn(W, s.scope, T, p[o]) : s.scope.bindingContext[d] = p[o], e !== k && nc(s.scope.overrideContext, o, k), --Y);
    if (r !== void 0)
      return r.length === 1 ? r[0] : Promise.all(r);
  }
  dispose() {
    this.views.forEach(k4), this.views = void 0;
  }
  accept(e) {
    const { views: t } = this;
    if (t !== void 0) {
      for (let r = 0, i = t.length; r < i; ++r)
        if (t[r].accept(e) === !0)
          return !0;
    }
  }
}
ny.inject = [Vo, E0, In, nf, nr];
Z([Ue], ny.prototype, "items", void 0);
mr("repeat")(ny);
let rd = 16, di = new Int32Array(rd), tc = new Int32Array(rd);
function D4(n) {
  const e = n.length;
  e > rd && (rd = e, di = new Int32Array(e), tc = new Int32Array(e));
  let t = 0, r = 0, i = 0, s = 0, a = 0, o = 0, u = 0, l = 0;
  for (; s < e; s++)
    if (r = n[s], r !== -2) {
      if (a = di[t], i = n[a], i !== -2 && i < r) {
        tc[s] = a, di[++t] = s;
        continue;
      }
      for (o = 0, u = t; o < u; )
        l = o + u >> 1, i = n[di[l]], i !== -2 && i < r ? o = l + 1 : u = l;
      i = n[di[o]], (r < i || i === -2) && (o > 0 && (tc[s] = di[o - 1]), di[o] = s);
    }
  s = ++t;
  const d = new Int32Array(s);
  for (r = di[t - 1]; t-- > 0; )
    d[t] = r, r = tc[r];
  for (; s-- > 0; )
    di[s] = 0;
  return d;
}
const B4 = (n, e) => se(`AUR0814:${n}!=${e}`), nc = (n, e, t) => {
  const r = e === 0, i = e === t - 1, s = e % 2 === 0;
  n.$index = e, n.$first = r, n.$last = i, n.$middle = !r && !i, n.$even = s, n.$odd = !s, n.$length = t;
}, id = D0.toString, F4 = (n) => {
  switch (id.call(n)) {
    case "[object Array]":
      return n.length;
    case "[object Map]":
      return n.size;
    case "[object Set]":
      return n.size;
    case "[object Number]":
      return n;
    case "[object Null]":
      return 0;
    case "[object Undefined]":
      return 0;
    default:
      throw se(`Cannot count ${id.call(n)}`);
  }
}, Sg = (n, e) => {
  switch (id.call(n)) {
    case "[object Array]":
      return L4(n, e);
    case "[object Map]":
      return $4(n, e);
    case "[object Set]":
      return U4(n, e);
    case "[object Number]":
      return j4(n, e);
    case "[object Null]":
      return;
    case "[object Undefined]":
      return;
    default:
      throw se(`Cannot iterate over ${id.call(n)}`);
  }
}, L4 = (n, e) => {
  const t = n.length;
  let r = 0;
  for (; r < t; ++r)
    e(n[r], r, n);
}, $4 = (n, e) => {
  let t = -0, r;
  for (r of n.entries())
    e(r, t++, n);
}, U4 = (n, e) => {
  let t = 0, r;
  for (r of n.keys())
    e(r, t++, n);
}, j4 = (n, e) => {
  let t = 0;
  for (; t < n; ++t)
    e(t, t, n);
}, Va = (n, e, t, r, i) => {
  let s = n.get(t);
  return s === void 0 && (typeof e == "string" ? s = t[e] : s = z(e, r, i, null), n.set(t, s)), s;
}, Xs = (n, e, t, r, i, s, a) => {
  let o = n.get(e);
  return o === void 0 && (a ? bn(t.declaration, o = dn.fromParent(r, new Pm()), i, e) : o = dn.fromParent(r, new Pm(s, e)), n.set(e, o)), o;
}, Zs = (n, e) => {
  const t = typeof n;
  switch (t) {
    case "object":
      if (n !== null)
        return n;
    case "string":
    case "number":
    case "bigint":
    case "undefined":
    case "boolean":
      return `${e}${t}${n}`;
    default:
      return n;
  }
};
class ry {
  constructor(e, t) {
    this.view = e.create().setLocation(t);
  }
  valueChanged(e, t) {
    const r = this.$controller, i = this.view.bindings;
    let s, a = 0, o = 0;
    if (r.isActive && i != null)
      for (s = dn.fromParent(r.scope, e === void 0 ? {} : e), o = i.length; o > a; ++a)
        i[a].bind(s);
  }
  attaching(e, t) {
    const { $controller: r, value: i } = this, s = dn.fromParent(r.scope, i === void 0 ? {} : i);
    return this.view.activate(e, r, s);
  }
  detaching(e, t) {
    return this.view.deactivate(e, this.$controller);
  }
  dispose() {
    this.view.dispose(), this.view = void 0;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
}
ry.inject = [nr, In];
Z([Ue], ry.prototype, "value", void 0);
mr("with")(ry);
let sd = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.cases = [], this.activeCases = [], this.promise = void 0;
  }
  link(e, t, r, i) {
    this.view = this.f.create(this.$controller).setLocation(this.l);
  }
  attaching(e, t) {
    const r = this.view, i = this.$controller;
    return this.queue(() => r.activate(e, i, i.scope)), this.queue(() => this.swap(e, this.value)), this.promise;
  }
  detaching(e, t) {
    return this.queue(() => this.view.deactivate(e, this.$controller)), this.promise;
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
  valueChanged(e, t) {
    this.$controller.isActive && this.queue(() => this.swap(null, this.value));
  }
  caseChanged(e) {
    this.queue(() => this.ui(e));
  }
  ui(e) {
    const t = e.isMatch(this.value), r = this.activeCases, i = r.length;
    if (!t)
      return i > 0 && r[0].id === e.id ? this.fi(null) : void 0;
    if (i > 0 && r[0].id < e.id)
      return;
    const s = [];
    let a = e.fallThrough;
    if (!a)
      s.push(e);
    else {
      const o = this.cases, u = o.indexOf(e);
      for (let l = u, d = o.length; l < d && a; l++) {
        const p = o[l];
        s.push(p), a = p.fallThrough;
      }
    }
    return Pe(this.fi(null, s), () => (this.activeCases = s, this.di(null)));
  }
  swap(e, t) {
    const r = [];
    let i = !1;
    for (const a of this.cases)
      if ((i || a.isMatch(t)) && (r.push(a), i = a.fallThrough), r.length > 0 && !i)
        break;
    const s = this.defaultCase;
    return r.length === 0 && s !== void 0 && r.push(s), Pe(this.activeCases.length > 0 ? this.fi(e, r) : void 0, () => {
      if (this.activeCases = r, r.length !== 0)
        return this.di(e);
    });
  }
  di(e) {
    const t = this.$controller;
    if (!t.isActive)
      return;
    const r = this.activeCases, i = r.length;
    if (i === 0)
      return;
    const s = t.scope;
    return i === 1 ? r[0].activate(e, s) : Qt(...r.map((a) => a.activate(e, s)));
  }
  fi(e, t = []) {
    const r = this.activeCases, i = r.length;
    if (i !== 0) {
      if (i === 1) {
        const s = r[0];
        return t.includes(s) ? void 0 : (r.length = 0, s.deactivate(e));
      }
      return Pe(Qt(...r.reduce((s, a) => (t.includes(a) || s.push(a.deactivate(e)), s), [])), () => {
        r.length = 0;
      });
    }
  }
  queue(e) {
    const t = this.promise;
    let r;
    r = this.promise = Pe(Pe(t, e), () => {
      this.promise === r && (this.promise = void 0);
    });
  }
  accept(e) {
    if (this.$controller.accept(e) === !0 || this.activeCases.some((t) => t.accept(e)))
      return !0;
  }
};
Z([Ue], sd.prototype, "value", void 0);
sd = Z([mr("switch"), wn(0, nr), wn(1, In)], sd);
let V4 = 0, vo = class {
  constructor(e, t, r, i) {
    this.f = e, this.mi = t, this.l = r, this.id = ++V4, this.fallThrough = !1, this.view = void 0, this.gi = i.config.level <= 1, this.pi = i.scopeTo(`${this.constructor.name}-#${this.id}`);
  }
  link(e, t, r, i) {
    const a = e.parent?.viewModel;
    if (a instanceof sd)
      this.$switch = a, this.linkToSwitch(a);
    else
      throw se("AUR0815");
  }
  detaching(e, t) {
    return this.deactivate(e);
  }
  isMatch(e) {
    this.pi.debug("isMatch()");
    const t = this.value;
    return ti(t) ? (this.Xe === void 0 && (this.Xe = this.vi(t)), t.includes(e)) : t === e;
  }
  valueChanged(e, t) {
    ti(e) ? (this.Xe?.unsubscribe(this), this.Xe = this.vi(e)) : this.Xe !== void 0 && this.Xe.unsubscribe(this), this.$switch.caseChanged(this);
  }
  handleCollectionChange() {
    this.$switch.caseChanged(this);
  }
  activate(e, t) {
    let r = this.view;
    if (r === void 0 && (r = this.view = this.f.create().setLocation(this.l)), !r.isActive)
      return r.activate(e ?? r, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive))
      return t.deactivate(e ?? t, this.$controller);
  }
  dispose() {
    this.Xe?.unsubscribe(this), this.view?.dispose(), this.view = void 0;
  }
  linkToSwitch(e) {
    e.cases.push(this);
  }
  vi(e) {
    const t = this.mi.getArrayObserver(e);
    return t.subscribe(this), t;
  }
  accept(e) {
    return this.$controller.accept(e) === !0 ? !0 : this.view?.accept(e);
  }
};
vo.inject = [nr, Ia, In, Ra];
Z([Ue], vo.prototype, "value", void 0);
Z([Ue({
  set: (n) => {
    switch (n) {
      case "true":
        return !0;
      case "false":
        return !1;
      default:
        return !!n;
    }
  },
  mode: 1
})], vo.prototype, "fallThrough", void 0);
vo = Z([mr("case")], vo);
let Cg = class extends vo {
  linkToSwitch(e) {
    if (e.defaultCase !== void 0)
      throw se("AUR0816");
    e.defaultCase = this;
  }
};
Cg = Z([mr("default-case")], Cg);
let ad = class {
  constructor(e, t, r, i) {
    this.f = e, this.l = t, this.p = r, this.preSettledTask = null, this.postSettledTask = null, this.logger = i.scopeTo("promise.resolve");
  }
  link(e, t, r, i) {
    this.view = this.f.create(this.$controller).setLocation(this.l);
  }
  attaching(e, t) {
    const r = this.view, i = this.$controller;
    return Pe(r.activate(e, i, this.viewScope = dn.fromParent(i.scope, {})), () => this.swap(e));
  }
  valueChanged(e, t) {
    this.$controller.isActive && this.swap(null);
  }
  swap(e) {
    const t = this.value;
    if (!un(t)) {
      this.logger.warn(`The value '${gs(t)}' is not a promise. No change will be done.`);
      return;
    }
    const r = this.p.domWriteQueue, i = this.fulfilled, s = this.rejected, a = this.pending, o = this.viewScope;
    let u;
    const l = {
      reusable: !1
    }, d = () => {
      Qt(u = (this.preSettledTask = r.queueTask(() => Qt(i?.deactivate(e), s?.deactivate(e), a?.activate(e, o)), l)).result.catch((p) => {
        if (!(p instanceof WE))
          throw p;
      }), t.then((p) => {
        if (this.value !== t)
          return;
        const m = () => {
          this.postSettlePromise = (this.postSettledTask = r.queueTask(() => Qt(a?.deactivate(e), s?.deactivate(e), i?.activate(e, o, p)), l)).result;
        };
        this.preSettledTask.status === 1 ? u.then(m) : (this.preSettledTask.cancel(), m());
      }, (p) => {
        if (this.value !== t)
          return;
        const m = () => {
          this.postSettlePromise = (this.postSettledTask = r.queueTask(() => Qt(a?.deactivate(e), i?.deactivate(e), s?.activate(e, o, p)), l)).result;
        };
        this.preSettledTask.status === 1 ? u.then(m) : (this.preSettledTask.cancel(), m());
      }));
    };
    this.postSettledTask?.status === 1 ? this.postSettlePromise.then(d) : (this.postSettledTask?.cancel(), d());
  }
  detaching(e, t) {
    return this.preSettledTask?.cancel(), this.postSettledTask?.cancel(), this.preSettledTask = this.postSettledTask = null, this.view.deactivate(e, this.$controller);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
Z([Ue], ad.prototype, "value", void 0);
ad = Z([mr("promise"), wn(0, nr), wn(1, In), wn(2, ji), wn(3, Ra)], ad);
let gh = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.view = void 0;
  }
  link(e, t, r, i) {
    iy(e).pending = this;
  }
  activate(e, t) {
    let r = this.view;
    if (r === void 0 && (r = this.view = this.f.create().setLocation(this.l)), !r.isActive)
      return r.activate(r, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive))
      return t.deactivate(t, this.$controller);
  }
  detaching(e) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
Z([Ue({
  mode: 2
})], gh.prototype, "value", void 0);
gh = Z([mr("pending"), wn(0, nr), wn(1, In)], gh);
let xh = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.view = void 0;
  }
  link(e, t, r, i) {
    iy(e).fulfilled = this;
  }
  activate(e, t, r) {
    this.value = r;
    let i = this.view;
    if (i === void 0 && (i = this.view = this.f.create().setLocation(this.l)), !i.isActive)
      return i.activate(i, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive))
      return t.deactivate(t, this.$controller);
  }
  detaching(e, t) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
Z([Ue({
  mode: 4
})], xh.prototype, "value", void 0);
xh = Z([mr("then"), wn(0, nr), wn(1, In)], xh);
let vh = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.view = void 0;
  }
  link(e, t, r, i) {
    iy(e).rejected = this;
  }
  activate(e, t, r) {
    this.value = r;
    let i = this.view;
    if (i === void 0 && (i = this.view = this.f.create().setLocation(this.l)), !i.isActive)
      return i.activate(i, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive))
      return t.deactivate(t, this.$controller);
  }
  detaching(e, t) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
Z([Ue({
  mode: 4
})], vh.prototype, "value", void 0);
vh = Z([mr("catch"), wn(0, nr), wn(1, In)], vh);
function iy(n) {
  const t = n.parent?.viewModel;
  if (t instanceof ad)
    return t;
  throw se("AUR0813");
}
let _g = class {
  "promise.resolve"(e, t, r) {
    return new hr(e, t, "promise", "bind");
  }
};
_g = Z([Gi({
  pattern: "promise.resolve",
  symbols: ""
})], _g);
let Mg = class {
  then(e, t, r) {
    return new hr(e, t, "then", "from-view");
  }
};
Mg = Z([Gi({
  pattern: "then",
  symbols: ""
})], Mg);
let Pg = class {
  catch(e, t, r) {
    return new hr(e, t, "catch", "from-view");
  }
};
Pg = Z([Gi({
  pattern: "catch",
  symbols: ""
})], Pg);
class sy {
  constructor(e, t) {
    this.bi = !1, this.xi = e, this.p = t;
  }
  binding() {
    this.valueChanged();
  }
  valueChanged() {
    this.$controller.isActive ? this.wi() : this.bi = !0;
  }
  attached() {
    this.bi && (this.bi = !1, this.wi()), this.xi.addEventListener("focus", this), this.xi.addEventListener("blur", this);
  }
  detaching() {
    const e = this.xi;
    e.removeEventListener("focus", this), e.removeEventListener("blur", this);
  }
  handleEvent(e) {
    e.type === "focus" ? this.value = !0 : this.yi || (this.value = !1);
  }
  wi() {
    const e = this.xi, t = this.yi, r = this.value;
    r && !t ? e.focus() : !r && t && e.blur();
  }
  get yi() {
    return this.xi === this.p.document.activeElement;
  }
}
sy.inject = [Xd, ji];
Z([Ue({
  mode: 6
})], sy.prototype, "value", void 0);
b1("focus")(sy);
class Lr {
  constructor(e, t, r) {
    this.position = "beforeend", this.strict = !1, this.p = r, this.ki = r.document.createElement("div"), (this.view = e.create()).setLocation(this.Ai = l8(r)), h8(this.view.nodes, t);
  }
  attaching(e) {
    this.callbackContext == null && (this.callbackContext = this.$controller.scope.bindingContext);
    const t = this.ki = this.Ci();
    return this.Ri(t, this.position), this.Bi(e, t);
  }
  detaching(e) {
    return this.Si(e, this.ki);
  }
  targetChanged() {
    const { $controller: e } = this;
    if (!e.isActive)
      return;
    const t = this.Ci();
    if (this.ki === t)
      return;
    this.ki = t;
    const r = Pe(this.Si(null, t), () => (this.Ri(t, this.position), this.Bi(null, t)));
    un(r) && r.catch(Yc);
  }
  positionChanged() {
    const { $controller: e, ki: t } = this;
    if (!e.isActive)
      return;
    const r = Pe(this.Si(null, t), () => (this.Ri(t, this.position), this.Bi(null, t)));
    un(r) && r.catch(Yc);
  }
  Bi(e, t) {
    const { activating: r, callbackContext: i, view: s } = this;
    return Pe(r?.call(i, t, s), () => this._i(e, t));
  }
  _i(e, t) {
    const { $controller: r, view: i } = this;
    if (e === null)
      i.nodes.insertBefore(this.Ai);
    else
      return Pe(i.activate(e ?? i, r, r.scope), () => this.Ti(t));
    return this.Ti(t);
  }
  Ti(e) {
    const { activated: t, callbackContext: r, view: i } = this;
    return t?.call(r, e, i);
  }
  Si(e, t) {
    const { deactivating: r, callbackContext: i, view: s } = this;
    return Pe(r?.call(i, t, s), () => this.Ii(e, t));
  }
  Ii(e, t) {
    const { $controller: r, view: i } = this;
    if (e === null)
      i.nodes.remove();
    else
      return Pe(i.deactivate(e, r), () => this.Ei(t));
    return this.Ei(t);
  }
  Ei(e) {
    const { deactivated: t, callbackContext: r, view: i } = this;
    return t?.call(r, e, i);
  }
  Ci() {
    const e = this.p, t = e.document;
    let r = this.target, i = this.renderContext;
    if (r === "") {
      if (this.strict)
        throw se("AUR0811");
      return t.body;
    }
    if (Et(r)) {
      let s = t;
      Et(i) && (i = t.querySelector(i)), i instanceof e.Node && (s = i), r = s.querySelector(r);
    }
    if (r instanceof e.Node)
      return r;
    if (r == null) {
      if (this.strict)
        throw se("AUR0812");
      return t.body;
    }
    return r;
  }
  Ri(e, t) {
    const r = this.Ai, i = r.$start, s = e.parentNode, a = [i, r];
    switch (t) {
      case "beforeend":
        Ql(e, null, a);
        break;
      case "afterbegin":
        Ql(e, e.firstChild, a);
        break;
      case "beforebegin":
        Ql(s, e, a);
        break;
      case "afterend":
        Ql(s, e.nextSibling, a);
        break;
      default:
        throw new Error("Invalid portal insertion position");
    }
  }
  dispose() {
    this.view.dispose(), this.view = void 0, this.callbackContext = null;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
}
Lr.inject = [nr, In, ji];
Z([Ue({
  primary: !0
})], Lr.prototype, "target", void 0);
Z([Ue()], Lr.prototype, "position", void 0);
Z([Ue({
  callback: "targetChanged"
})], Lr.prototype, "renderContext", void 0);
Z([Ue()], Lr.prototype, "strict", void 0);
Z([Ue()], Lr.prototype, "deactivating", void 0);
Z([Ue()], Lr.prototype, "activating", void 0);
Z([Ue()], Lr.prototype, "deactivated", void 0);
Z([Ue()], Lr.prototype, "activated", void 0);
Z([Ue()], Lr.prototype, "callbackContext", void 0);
mr("portal")(Lr);
let od = class {
  static get inject() {
    return [In, Vo, nd, Na];
  }
  constructor(e, t, r, i) {
    this.Pi = null, this.Li = null, this.Mi = !1, this.expose = null, this.slotchange = null, this.Di = /* @__PURE__ */ new Set(), this.Xe = null;
    let s, a;
    const o = t.auSlot, u = r.instruction?.projections?.[o.name], l = r.controller;
    this.name = o.name, u == null ? (s = i.getViewFactory(o.fallback, l.container), this.$i = !1) : (a = r.parent.controller.container.createChild(), Jt(a, l.definition.Type, new _n(void 0, l.viewModel)), s = i.getViewFactory(u, a), this.$i = !0, this.Ui = l.container.getAll(z8, !1)?.filter((d) => d.slotName === "*" || d.slotName === o.name) ?? je), this.qi = (this.Ui ?? (this.Ui = je)).length > 0, this.Fi = r, this.view = s.create().setLocation(this.l = e);
  }
  get nodes() {
    const e = [], t = this.l;
    let r = t.$start.nextSibling;
    for (; r != null && r !== t; )
      r.nodeType !== 8 && e.push(r), r = r.nextSibling;
    return e;
  }
  subscribe(e) {
    this.Di.add(e);
  }
  unsubscribe(e) {
    this.Di.delete(e);
  }
  binding(e, t) {
    this.Pi = this.$controller.scope.parent;
    let r;
    this.$i && (r = this.Fi.controller.scope.parent, (this.Li = dn.fromParent(r, r.bindingContext)).overrideContext.$host = this.expose ?? this.Pi.bindingContext);
  }
  attaching(e, t) {
    return Pe(this.view.activate(e, this.$controller, this.$i ? this.Li : this.Pi), () => {
      this.qi && (this.Ui.forEach((r) => r.watch(this)), this.He(), this.Hi(), this.Mi = !0);
    });
  }
  detaching(e, t) {
    return this.Mi = !1, this.Oi(), this.Ui.forEach((r) => r.unwatch(this)), this.view.deactivate(e, this.$controller);
  }
  exposeChanged(e) {
    this.$i && this.Li != null && (this.Li.overrideContext.$host = e);
  }
  dispose() {
    this.view.dispose(), this.view = void 0;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
  He() {
    if (this.Xe != null)
      return;
    const e = this.l, t = e.parentElement;
    t != null && (this.Xe = F0(t, (r) => {
      z4(e, r) && this.Hi();
    })).observe(t, {
      childList: !0
    });
  }
  Oi() {
    this.Xe?.disconnect(), this.Xe = null;
  }
  Hi() {
    const e = this.nodes, t = new Set(this.Di);
    let r;
    this.Mi && this.slotchange?.call(void 0, this.name, e);
    for (r of t)
      r.handleSlotChange(this, e);
  }
};
Z([Ue], od.prototype, "expose", void 0);
Z([Ue], od.prototype, "slotchange", void 0);
od = Z([x1({
  name: "au-slot",
  template: null,
  containerless: !0
})], od);
const rc = (n, e) => n.compareDocumentPosition(e), z4 = (n, e) => {
  for (const { addedNodes: t, removedNodes: r, nextSibling: i } of e) {
    let s = 0, a = t.length, o;
    for (; s < a; ++s)
      if (o = t[s], rc(n.$start, o) === 4 && rc(n, o) === 2)
        return !0;
    if (r.length > 0 && i != null && rc(n.$start, i) === 4 && rc(n, i) === 2)
      return !0;
  }
};
var Rg;
(function(n) {
  n[n.Element = 1] = "Element", n[n.Attribute = 2] = "Attribute";
})(Rg || (Rg = {}));
class Rl {
  static get inject() {
    return [No, nf, Xd, In, ji, Vo, xv(H4)];
  }
  get pending() {
    return this.Vi;
  }
  get composition() {
    return this.Ni;
  }
  constructor(e, t, r, i, s, a, o) {
    this.c = e, this.parent = t, this.host = r, this.l = i, this.p = s, this.scopeBehavior = "auto", this.Ni = void 0, this.r = e.get(Na), this.ji = a, this.Wi = o;
  }
  attaching(e, t) {
    return this.Vi = Pe(this.queue(new Ig(this.template, this.component, this.model, void 0), e), (r) => {
      this.Wi.isCurrent(r) && (this.Vi = void 0);
    });
  }
  detaching(e) {
    const t = this.Ni, r = this.Vi;
    return this.Wi.invalidate(), this.Ni = this.Vi = void 0, Pe(r, () => t?.deactivate(e));
  }
  propertyChanged(e) {
    if (e === "model" && this.Ni != null) {
      this.Ni.update(this.model);
      return;
    }
    this.Vi = Pe(this.Vi, () => Pe(this.queue(new Ig(this.template, this.component, this.model, e), void 0), (t) => {
      this.Wi.isCurrent(t) && (this.Vi = void 0);
    }));
  }
  queue(e, t) {
    const r = this.Wi, i = this.Ni;
    return Pe(r.create(e), (s) => r.isCurrent(s) ? Pe(this.compose(s), (a) => r.isCurrent(s) ? Pe(a.activate(t), () => r.isCurrent(s) ? (this.Ni = a, Pe(i?.deactivate(t), () => s)) : Pe(a.controller.deactivate(a.controller, this.$controller), () => (a.controller.dispose(), s))) : (a.controller.dispose(), s)) : s);
  }
  compose(e) {
    let t, r, i;
    const { zi: s, Gi: a, Xi: o } = e.change, { c: u, host: l, $controller: d, l: p } = this, m = this.getDef(a), w = u.createChild(), x = p == null ? l.parentNode : p.parentNode;
    if (m !== null) {
      if (m.containerless)
        throw se("AUR0806");
      p == null ? (r = l, i = () => {
      }) : (r = x.insertBefore(this.p.document.createElement(m.name), p), i = () => {
        r.remove();
      }), t = this.Ki(w, a, r);
    } else
      r = p ?? l, t = this.Ki(w, a, r);
    const T = () => {
      if (m !== null) {
        const A = cr.$el(w, t, r, {
          projections: this.ji.projections
        }, m);
        return new kg(A, (M) => A.activate(M ?? A, d, d.scope.parent), (M) => Pe(A.deactivate(M ?? A, d), i), (M) => t.activate?.(M), e);
      } else {
        const A = Hr.create({
          name: fo.generateName(),
          template: s
        }), M = this.r.getViewFactory(A, w), I = cr.$view(M, d), B = this.scopeBehavior === "auto" ? dn.fromParent(this.parent.scope, t) : dn.create(t);
        return ed(r) ? I.setLocation(r) : I.setHost(r), new kg(I, (k) => I.activate(k ?? I, d, B), (k) => I.deactivate(k ?? I, d), (k) => t.activate?.(k), e);
      }
    };
    return "activate" in t ? Pe(t.activate(o), () => T()) : T();
  }
  Ki(e, t, r) {
    if (t == null)
      return new G4();
    if (typeof t == "object")
      return t;
    const i = this.p, s = ed(r);
    $0(e, i, s ? null : r), Jt(e, In, new _n("IRenderLocation", s ? r : null));
    const a = e.invoke(t);
    return Jt(e, t, new _n("au-compose.component", a)), a;
  }
  getDef(e) {
    const t = Nr(e) ? e : e?.constructor;
    return fo.isType(t) ? fo.getDefinition(t) : null;
  }
}
Z([Ue], Rl.prototype, "template", void 0);
Z([Ue], Rl.prototype, "component", void 0);
Z([Ue], Rl.prototype, "model", void 0);
Z([Ue({
  set: (n) => {
    if (n === "scoped" || n === "auto")
      return n;
    throw se("AUR0805");
  }
})], Rl.prototype, "scopeBehavior", void 0);
x1("au-compose")(Rl);
class G4 {
}
class H4 {
  constructor() {
    this.id = 0;
  }
  isCurrent(e) {
    return e.id === this.id;
  }
  create(e) {
    return Pe(e.load(), (t) => new q4(++this.id, t));
  }
  invalidate() {
    this.id++;
  }
}
class Ig {
  constructor(e, t, r, i) {
    this.zi = e, this.Gi = t, this.Xi = r, this.Qi = i;
  }
  load() {
    return un(this.zi) || un(this.Gi) ? Promise.all([this.zi, this.Gi]).then(([e, t]) => new Og(e, t, this.Xi, this.Qi)) : new Og(this.zi, this.Gi, this.Xi, this.Qi);
  }
}
class Og {
  constructor(e, t, r, i) {
    this.zi = e, this.Gi = t, this.Xi = r, this.Qi = i;
  }
}
class q4 {
  constructor(e, t) {
    this.id = e, this.change = t;
  }
}
class kg {
  constructor(e, t, r, i, s) {
    this.controller = e, this.start = t, this.stop = r, this.update = i, this.context = s, this.state = 0;
  }
  activate(e) {
    if (this.state !== 0)
      throw se(`AUR0807:${this.controller.name}`);
    return this.state = 1, this.start(e);
  }
  deactivate(e) {
    switch (this.state) {
      case 1:
        return this.state = -1, this.stop(e);
      case -1:
        throw se("AUR0808");
      default:
        this.state = -1;
    }
  }
}
const W4 = /* @__PURE__ */ $t("ISanitizer", (n) => n.singleton(class {
  sanitize() {
    throw se('"sanitize" method not implemented');
  }
}));
let wh = class {
  constructor(e) {
    this.Yi = e;
  }
  toView(e) {
    return e == null ? null : this.Yi.sanitize(e);
  }
};
wh = Z([wn(0, W4)], wh);
Al("sanitize")(wh);
Jd(Jn(), {
  id: !0,
  name: !0,
  "au-slot": !0,
  "as-element": !0
});
let qu = class {
  constructor(e, t, r) {
    this.el = e, this.p = t, this.Rs = !1, this.Z = null, this.$val = "", this.$prio = "", this.update = () => {
      this.Z = null, !!this.value !== this.Bs && (this.Bs === this.Ss ? (this.Bs = !this.Ss, this.$val = this.el.style.getPropertyValue("display"), this.$prio = this.el.style.getPropertyPriority("display"), this.el.style.setProperty("display", "none", "important")) : (this.Bs = this.Ss, this.el.style.setProperty("display", this.$val, this.$prio), this.el.getAttribute("style") === "" && this.el.removeAttribute("style")));
    }, this.Bs = this.Ss = r.alias !== "hide";
  }
  binding() {
    this.Rs = !0, this.update();
  }
  detaching() {
    this.Rs = !1, this.Z?.cancel(), this.Z = null;
  }
  valueChanged() {
    this.Rs && this.Z === null && (this.Z = this.p.domWriteQueue.queueTask(this.update));
  }
};
Z([Ue], qu.prototype, "value", void 0);
qu = Z([wn(0, Xd), wn(1, ji), wn(2, Vo)], qu);
e8("hide")(qu);
b1("show")(qu);
const Cs = me.createInterface();
var bi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function _s(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function kt(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function r() {
      if (this instanceof r) {
        var i = [null];
        i.push.apply(i, arguments);
        var s = Function.bind.apply(e, i);
        return new s();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(t, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return n[r];
      }
    });
  }), t;
}
var ay = { exports: {} };
const K4 = {}, J4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: K4
}, Symbol.toStringTag, { value: "Module" })), Q4 = /* @__PURE__ */ kt(J4);
ay.exports;
(function(n) {
  (function(e, t) {
    function r(C, c) {
      if (!C)
        throw new Error(c || "Assertion failed");
    }
    function i(C, c) {
      C.super_ = c;
      var h = function() {
      };
      h.prototype = c.prototype, C.prototype = new h(), C.prototype.constructor = C;
    }
    function s(C, c, h) {
      if (s.isBN(C))
        return C;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, C !== null && ((c === "le" || c === "be") && (h = c, c = 10), this._init(C || 0, c || 10, h || "be"));
    }
    typeof e == "object" ? e.exports = s : t.BN = s, s.BN = s, s.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = Q4.Buffer;
    } catch {
    }
    s.isBN = function(c) {
      return c instanceof s ? !0 : c !== null && typeof c == "object" && c.constructor.wordSize === s.wordSize && Array.isArray(c.words);
    }, s.max = function(c, h) {
      return c.cmp(h) > 0 ? c : h;
    }, s.min = function(c, h) {
      return c.cmp(h) < 0 ? c : h;
    }, s.prototype._init = function(c, h, g) {
      if (typeof c == "number")
        return this._initNumber(c, h, g);
      if (typeof c == "object")
        return this._initArray(c, h, g);
      h === "hex" && (h = 16), r(h === (h | 0) && h >= 2 && h <= 36), c = c.toString().replace(/\s+/g, "");
      var E = 0;
      c[0] === "-" && (E++, this.negative = 1), E < c.length && (h === 16 ? this._parseHex(c, E, g) : (this._parseBase(c, h, E), g === "le" && this._initArray(this.toArray(), h, g)));
    }, s.prototype._initNumber = function(c, h, g) {
      c < 0 && (this.negative = 1, c = -c), c < 67108864 ? (this.words = [c & 67108863], this.length = 1) : c < 4503599627370496 ? (this.words = [
        c & 67108863,
        c / 67108864 & 67108863
      ], this.length = 2) : (r(c < 9007199254740992), this.words = [
        c & 67108863,
        c / 67108864 & 67108863,
        1
      ], this.length = 3), g === "le" && this._initArray(this.toArray(), h, g);
    }, s.prototype._initArray = function(c, h, g) {
      if (r(typeof c.length == "number"), c.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(c.length / 3), this.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        this.words[E] = 0;
      var S, _, P = 0;
      if (g === "be")
        for (E = c.length - 1, S = 0; E >= 0; E -= 3)
          _ = c[E] | c[E - 1] << 8 | c[E - 2] << 16, this.words[S] |= _ << P & 67108863, this.words[S + 1] = _ >>> 26 - P & 67108863, P += 24, P >= 26 && (P -= 26, S++);
      else if (g === "le")
        for (E = 0, S = 0; E < c.length; E += 3)
          _ = c[E] | c[E + 1] << 8 | c[E + 2] << 16, this.words[S] |= _ << P & 67108863, this.words[S + 1] = _ >>> 26 - P & 67108863, P += 24, P >= 26 && (P -= 26, S++);
      return this._strip();
    };
    function o(C, c) {
      var h = C.charCodeAt(c);
      if (h >= 48 && h <= 57)
        return h - 48;
      if (h >= 65 && h <= 70)
        return h - 55;
      if (h >= 97 && h <= 102)
        return h - 87;
      r(!1, "Invalid character in " + C);
    }
    function u(C, c, h) {
      var g = o(C, h);
      return h - 1 >= c && (g |= o(C, h - 1) << 4), g;
    }
    s.prototype._parseHex = function(c, h, g) {
      this.length = Math.ceil((c.length - h) / 6), this.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        this.words[E] = 0;
      var S = 0, _ = 0, P;
      if (g === "be")
        for (E = c.length - 1; E >= h; E -= 2)
          P = u(c, h, E) << S, this.words[_] |= P & 67108863, S >= 18 ? (S -= 18, _ += 1, this.words[_] |= P >>> 26) : S += 8;
      else {
        var b = c.length - h;
        for (E = b % 2 === 0 ? h + 1 : h; E < c.length; E += 2)
          P = u(c, h, E) << S, this.words[_] |= P & 67108863, S >= 18 ? (S -= 18, _ += 1, this.words[_] |= P >>> 26) : S += 8;
      }
      this._strip();
    };
    function l(C, c, h, g) {
      for (var E = 0, S = 0, _ = Math.min(C.length, h), P = c; P < _; P++) {
        var b = C.charCodeAt(P) - 48;
        E *= g, b >= 49 ? S = b - 49 + 10 : b >= 17 ? S = b - 17 + 10 : S = b, r(b >= 0 && S < g, "Invalid character"), E += S;
      }
      return E;
    }
    s.prototype._parseBase = function(c, h, g) {
      this.words = [0], this.length = 1;
      for (var E = 0, S = 1; S <= 67108863; S *= h)
        E++;
      E--, S = S / h | 0;
      for (var _ = c.length - g, P = _ % E, b = Math.min(_, _ - P) + g, f = 0, v = g; v < b; v += E)
        f = l(c, v, v + E, h), this.imuln(S), this.words[0] + f < 67108864 ? this.words[0] += f : this._iaddn(f);
      if (P !== 0) {
        var O = 1;
        for (f = l(c, v, c.length, h), v = 0; v < P; v++)
          O *= h;
        this.imuln(O), this.words[0] + f < 67108864 ? this.words[0] += f : this._iaddn(f);
      }
      this._strip();
    }, s.prototype.copy = function(c) {
      c.words = new Array(this.length);
      for (var h = 0; h < this.length; h++)
        c.words[h] = this.words[h];
      c.length = this.length, c.negative = this.negative, c.red = this.red;
    };
    function d(C, c) {
      C.words = c.words, C.length = c.length, C.negative = c.negative, C.red = c.red;
    }
    if (s.prototype._move = function(c) {
      d(c, this);
    }, s.prototype.clone = function() {
      var c = new s(null);
      return this.copy(c), c;
    }, s.prototype._expand = function(c) {
      for (; this.length < c; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
      } catch {
        s.prototype.inspect = p;
      }
    else
      s.prototype.inspect = p;
    function p() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var m = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], w = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], x = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(c, h) {
      c = c || 10, h = h | 0 || 1;
      var g;
      if (c === 16 || c === "hex") {
        g = "";
        for (var E = 0, S = 0, _ = 0; _ < this.length; _++) {
          var P = this.words[_], b = ((P << E | S) & 16777215).toString(16);
          S = P >>> 24 - E & 16777215, E += 2, E >= 26 && (E -= 26, _--), S !== 0 || _ !== this.length - 1 ? g = m[6 - b.length] + b + g : g = b + g;
        }
        for (S !== 0 && (g = S.toString(16) + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      if (c === (c | 0) && c >= 2 && c <= 36) {
        var f = w[c], v = x[c];
        g = "";
        var O = this.clone();
        for (O.negative = 0; !O.isZero(); ) {
          var y = O.modrn(v).toString(c);
          O = O.idivn(v), O.isZero() ? g = y + g : g = m[f - y.length] + y + g;
        }
        for (this.isZero() && (g = "0" + g); g.length % h !== 0; )
          g = "0" + g;
        return this.negative !== 0 && (g = "-" + g), g;
      }
      r(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var c = this.words[0];
      return this.length === 2 ? c += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? c += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -c : c;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, a && (s.prototype.toBuffer = function(c, h) {
      return this.toArrayLike(a, c, h);
    }), s.prototype.toArray = function(c, h) {
      return this.toArrayLike(Array, c, h);
    };
    var T = function(c, h) {
      return c.allocUnsafe ? c.allocUnsafe(h) : new c(h);
    };
    s.prototype.toArrayLike = function(c, h, g) {
      this._strip();
      var E = this.byteLength(), S = g || Math.max(1, E);
      r(E <= S, "byte array longer than desired length"), r(S > 0, "Requested array length <= 0");
      var _ = T(c, S), P = h === "le" ? "LE" : "BE";
      return this["_toArrayLike" + P](_, E), _;
    }, s.prototype._toArrayLikeLE = function(c, h) {
      for (var g = 0, E = 0, S = 0, _ = 0; S < this.length; S++) {
        var P = this.words[S] << _ | E;
        c[g++] = P & 255, g < c.length && (c[g++] = P >> 8 & 255), g < c.length && (c[g++] = P >> 16 & 255), _ === 6 ? (g < c.length && (c[g++] = P >> 24 & 255), E = 0, _ = 0) : (E = P >>> 24, _ += 2);
      }
      if (g < c.length)
        for (c[g++] = E; g < c.length; )
          c[g++] = 0;
    }, s.prototype._toArrayLikeBE = function(c, h) {
      for (var g = c.length - 1, E = 0, S = 0, _ = 0; S < this.length; S++) {
        var P = this.words[S] << _ | E;
        c[g--] = P & 255, g >= 0 && (c[g--] = P >> 8 & 255), g >= 0 && (c[g--] = P >> 16 & 255), _ === 6 ? (g >= 0 && (c[g--] = P >> 24 & 255), E = 0, _ = 0) : (E = P >>> 24, _ += 2);
      }
      if (g >= 0)
        for (c[g--] = E; g >= 0; )
          c[g--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(c) {
      return 32 - Math.clz32(c);
    } : s.prototype._countBits = function(c) {
      var h = c, g = 0;
      return h >= 4096 && (g += 13, h >>>= 13), h >= 64 && (g += 7, h >>>= 7), h >= 8 && (g += 4, h >>>= 4), h >= 2 && (g += 2, h >>>= 2), g + h;
    }, s.prototype._zeroBits = function(c) {
      if (c === 0)
        return 26;
      var h = c, g = 0;
      return h & 8191 || (g += 13, h >>>= 13), h & 127 || (g += 7, h >>>= 7), h & 15 || (g += 4, h >>>= 4), h & 3 || (g += 2, h >>>= 2), h & 1 || g++, g;
    }, s.prototype.bitLength = function() {
      var c = this.words[this.length - 1], h = this._countBits(c);
      return (this.length - 1) * 26 + h;
    };
    function A(C) {
      for (var c = new Array(C.bitLength()), h = 0; h < c.length; h++) {
        var g = h / 26 | 0, E = h % 26;
        c[h] = C.words[g] >>> E & 1;
      }
      return c;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var c = 0, h = 0; h < this.length; h++) {
        var g = this._zeroBits(this.words[h]);
        if (c += g, g !== 26)
          break;
      }
      return c;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(c) {
      return this.negative !== 0 ? this.abs().inotn(c).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(c) {
      return this.testn(c - 1) ? this.notn(c).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(c) {
      for (; this.length < c.length; )
        this.words[this.length++] = 0;
      for (var h = 0; h < c.length; h++)
        this.words[h] = this.words[h] | c.words[h];
      return this._strip();
    }, s.prototype.ior = function(c) {
      return r((this.negative | c.negative) === 0), this.iuor(c);
    }, s.prototype.or = function(c) {
      return this.length > c.length ? this.clone().ior(c) : c.clone().ior(this);
    }, s.prototype.uor = function(c) {
      return this.length > c.length ? this.clone().iuor(c) : c.clone().iuor(this);
    }, s.prototype.iuand = function(c) {
      var h;
      this.length > c.length ? h = c : h = this;
      for (var g = 0; g < h.length; g++)
        this.words[g] = this.words[g] & c.words[g];
      return this.length = h.length, this._strip();
    }, s.prototype.iand = function(c) {
      return r((this.negative | c.negative) === 0), this.iuand(c);
    }, s.prototype.and = function(c) {
      return this.length > c.length ? this.clone().iand(c) : c.clone().iand(this);
    }, s.prototype.uand = function(c) {
      return this.length > c.length ? this.clone().iuand(c) : c.clone().iuand(this);
    }, s.prototype.iuxor = function(c) {
      var h, g;
      this.length > c.length ? (h = this, g = c) : (h = c, g = this);
      for (var E = 0; E < g.length; E++)
        this.words[E] = h.words[E] ^ g.words[E];
      if (this !== h)
        for (; E < h.length; E++)
          this.words[E] = h.words[E];
      return this.length = h.length, this._strip();
    }, s.prototype.ixor = function(c) {
      return r((this.negative | c.negative) === 0), this.iuxor(c);
    }, s.prototype.xor = function(c) {
      return this.length > c.length ? this.clone().ixor(c) : c.clone().ixor(this);
    }, s.prototype.uxor = function(c) {
      return this.length > c.length ? this.clone().iuxor(c) : c.clone().iuxor(this);
    }, s.prototype.inotn = function(c) {
      r(typeof c == "number" && c >= 0);
      var h = Math.ceil(c / 26) | 0, g = c % 26;
      this._expand(h), g > 0 && h--;
      for (var E = 0; E < h; E++)
        this.words[E] = ~this.words[E] & 67108863;
      return g > 0 && (this.words[E] = ~this.words[E] & 67108863 >> 26 - g), this._strip();
    }, s.prototype.notn = function(c) {
      return this.clone().inotn(c);
    }, s.prototype.setn = function(c, h) {
      r(typeof c == "number" && c >= 0);
      var g = c / 26 | 0, E = c % 26;
      return this._expand(g + 1), h ? this.words[g] = this.words[g] | 1 << E : this.words[g] = this.words[g] & ~(1 << E), this._strip();
    }, s.prototype.iadd = function(c) {
      var h;
      if (this.negative !== 0 && c.negative === 0)
        return this.negative = 0, h = this.isub(c), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && c.negative !== 0)
        return c.negative = 0, h = this.isub(c), c.negative = 1, h._normSign();
      var g, E;
      this.length > c.length ? (g = this, E = c) : (g = c, E = this);
      for (var S = 0, _ = 0; _ < E.length; _++)
        h = (g.words[_] | 0) + (E.words[_] | 0) + S, this.words[_] = h & 67108863, S = h >>> 26;
      for (; S !== 0 && _ < g.length; _++)
        h = (g.words[_] | 0) + S, this.words[_] = h & 67108863, S = h >>> 26;
      if (this.length = g.length, S !== 0)
        this.words[this.length] = S, this.length++;
      else if (g !== this)
        for (; _ < g.length; _++)
          this.words[_] = g.words[_];
      return this;
    }, s.prototype.add = function(c) {
      var h;
      return c.negative !== 0 && this.negative === 0 ? (c.negative = 0, h = this.sub(c), c.negative ^= 1, h) : c.negative === 0 && this.negative !== 0 ? (this.negative = 0, h = c.sub(this), this.negative = 1, h) : this.length > c.length ? this.clone().iadd(c) : c.clone().iadd(this);
    }, s.prototype.isub = function(c) {
      if (c.negative !== 0) {
        c.negative = 0;
        var h = this.iadd(c);
        return c.negative = 1, h._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(c), this.negative = 1, this._normSign();
      var g = this.cmp(c);
      if (g === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var E, S;
      g > 0 ? (E = this, S = c) : (E = c, S = this);
      for (var _ = 0, P = 0; P < S.length; P++)
        h = (E.words[P] | 0) - (S.words[P] | 0) + _, _ = h >> 26, this.words[P] = h & 67108863;
      for (; _ !== 0 && P < E.length; P++)
        h = (E.words[P] | 0) + _, _ = h >> 26, this.words[P] = h & 67108863;
      if (_ === 0 && P < E.length && E !== this)
        for (; P < E.length; P++)
          this.words[P] = E.words[P];
      return this.length = Math.max(this.length, P), E !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(c) {
      return this.clone().isub(c);
    };
    function M(C, c, h) {
      h.negative = c.negative ^ C.negative;
      var g = C.length + c.length | 0;
      h.length = g, g = g - 1 | 0;
      var E = C.words[0] | 0, S = c.words[0] | 0, _ = E * S, P = _ & 67108863, b = _ / 67108864 | 0;
      h.words[0] = P;
      for (var f = 1; f < g; f++) {
        for (var v = b >>> 26, O = b & 67108863, y = Math.min(f, c.length - 1), R = Math.max(0, f - C.length + 1); R <= y; R++) {
          var L = f - R | 0;
          E = C.words[L] | 0, S = c.words[R] | 0, _ = E * S + O, v += _ / 67108864 | 0, O = _ & 67108863;
        }
        h.words[f] = O | 0, b = v | 0;
      }
      return b !== 0 ? h.words[f] = b | 0 : h.length--, h._strip();
    }
    var I = function(c, h, g) {
      var E = c.words, S = h.words, _ = g.words, P = 0, b, f, v, O = E[0] | 0, y = O & 8191, R = O >>> 13, L = E[1] | 0, F = L & 8191, $ = L >>> 13, te = E[2] | 0, Q = te & 8191, X = te >>> 13, St = E[3] | 0, ne = St & 8191, he = St >>> 13, Os = E[4] | 0, He = Os & 8191, qe = Os >>> 13, ks = E[5] | 0, We = ks & 8191, Ke = ks >>> 13, Ns = E[6] | 0, Je = Ns & 8191, Qe = Ns >>> 13, Ds = E[7] | 0, Ye = Ds & 8191, Xe = Ds >>> 13, Bs = E[8] | 0, Ze = Bs & 8191, et = Bs >>> 13, Fs = E[9] | 0, tt = Fs & 8191, nt = Fs >>> 13, Ls = S[0] | 0, rt = Ls & 8191, it = Ls >>> 13, $s = S[1] | 0, st = $s & 8191, at = $s >>> 13, Us = S[2] | 0, ot = Us & 8191, ut = Us >>> 13, js = S[3] | 0, lt = js & 8191, ct = js >>> 13, Vs = S[4] | 0, dt = Vs & 8191, ft = Vs >>> 13, zs = S[5] | 0, pt = zs & 8191, ht = zs >>> 13, Gs = S[6] | 0, yt = Gs & 8191, mt = Gs >>> 13, Hs = S[7] | 0, bt = Hs & 8191, gt = Hs >>> 13, qs = S[8] | 0, xt = qs & 8191, vt = qs >>> 13, Ws = S[9] | 0, wt = Ws & 8191, Tt = Ws >>> 13;
      g.negative = c.negative ^ h.negative, g.length = 19, b = Math.imul(y, rt), f = Math.imul(y, it), f = f + Math.imul(R, rt) | 0, v = Math.imul(R, it);
      var Ki = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Ki >>> 26) | 0, Ki &= 67108863, b = Math.imul(F, rt), f = Math.imul(F, it), f = f + Math.imul($, rt) | 0, v = Math.imul($, it), b = b + Math.imul(y, st) | 0, f = f + Math.imul(y, at) | 0, f = f + Math.imul(R, st) | 0, v = v + Math.imul(R, at) | 0;
      var Ji = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Ji >>> 26) | 0, Ji &= 67108863, b = Math.imul(Q, rt), f = Math.imul(Q, it), f = f + Math.imul(X, rt) | 0, v = Math.imul(X, it), b = b + Math.imul(F, st) | 0, f = f + Math.imul(F, at) | 0, f = f + Math.imul($, st) | 0, v = v + Math.imul($, at) | 0, b = b + Math.imul(y, ot) | 0, f = f + Math.imul(y, ut) | 0, f = f + Math.imul(R, ot) | 0, v = v + Math.imul(R, ut) | 0;
      var Qi = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Qi >>> 26) | 0, Qi &= 67108863, b = Math.imul(ne, rt), f = Math.imul(ne, it), f = f + Math.imul(he, rt) | 0, v = Math.imul(he, it), b = b + Math.imul(Q, st) | 0, f = f + Math.imul(Q, at) | 0, f = f + Math.imul(X, st) | 0, v = v + Math.imul(X, at) | 0, b = b + Math.imul(F, ot) | 0, f = f + Math.imul(F, ut) | 0, f = f + Math.imul($, ot) | 0, v = v + Math.imul($, ut) | 0, b = b + Math.imul(y, lt) | 0, f = f + Math.imul(y, ct) | 0, f = f + Math.imul(R, lt) | 0, v = v + Math.imul(R, ct) | 0;
      var Yi = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Yi >>> 26) | 0, Yi &= 67108863, b = Math.imul(He, rt), f = Math.imul(He, it), f = f + Math.imul(qe, rt) | 0, v = Math.imul(qe, it), b = b + Math.imul(ne, st) | 0, f = f + Math.imul(ne, at) | 0, f = f + Math.imul(he, st) | 0, v = v + Math.imul(he, at) | 0, b = b + Math.imul(Q, ot) | 0, f = f + Math.imul(Q, ut) | 0, f = f + Math.imul(X, ot) | 0, v = v + Math.imul(X, ut) | 0, b = b + Math.imul(F, lt) | 0, f = f + Math.imul(F, ct) | 0, f = f + Math.imul($, lt) | 0, v = v + Math.imul($, ct) | 0, b = b + Math.imul(y, dt) | 0, f = f + Math.imul(y, ft) | 0, f = f + Math.imul(R, dt) | 0, v = v + Math.imul(R, ft) | 0;
      var Xi = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Xi >>> 26) | 0, Xi &= 67108863, b = Math.imul(We, rt), f = Math.imul(We, it), f = f + Math.imul(Ke, rt) | 0, v = Math.imul(Ke, it), b = b + Math.imul(He, st) | 0, f = f + Math.imul(He, at) | 0, f = f + Math.imul(qe, st) | 0, v = v + Math.imul(qe, at) | 0, b = b + Math.imul(ne, ot) | 0, f = f + Math.imul(ne, ut) | 0, f = f + Math.imul(he, ot) | 0, v = v + Math.imul(he, ut) | 0, b = b + Math.imul(Q, lt) | 0, f = f + Math.imul(Q, ct) | 0, f = f + Math.imul(X, lt) | 0, v = v + Math.imul(X, ct) | 0, b = b + Math.imul(F, dt) | 0, f = f + Math.imul(F, ft) | 0, f = f + Math.imul($, dt) | 0, v = v + Math.imul($, ft) | 0, b = b + Math.imul(y, pt) | 0, f = f + Math.imul(y, ht) | 0, f = f + Math.imul(R, pt) | 0, v = v + Math.imul(R, ht) | 0;
      var Bf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Bf >>> 26) | 0, Bf &= 67108863, b = Math.imul(Je, rt), f = Math.imul(Je, it), f = f + Math.imul(Qe, rt) | 0, v = Math.imul(Qe, it), b = b + Math.imul(We, st) | 0, f = f + Math.imul(We, at) | 0, f = f + Math.imul(Ke, st) | 0, v = v + Math.imul(Ke, at) | 0, b = b + Math.imul(He, ot) | 0, f = f + Math.imul(He, ut) | 0, f = f + Math.imul(qe, ot) | 0, v = v + Math.imul(qe, ut) | 0, b = b + Math.imul(ne, lt) | 0, f = f + Math.imul(ne, ct) | 0, f = f + Math.imul(he, lt) | 0, v = v + Math.imul(he, ct) | 0, b = b + Math.imul(Q, dt) | 0, f = f + Math.imul(Q, ft) | 0, f = f + Math.imul(X, dt) | 0, v = v + Math.imul(X, ft) | 0, b = b + Math.imul(F, pt) | 0, f = f + Math.imul(F, ht) | 0, f = f + Math.imul($, pt) | 0, v = v + Math.imul($, ht) | 0, b = b + Math.imul(y, yt) | 0, f = f + Math.imul(y, mt) | 0, f = f + Math.imul(R, yt) | 0, v = v + Math.imul(R, mt) | 0;
      var Ff = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Ff >>> 26) | 0, Ff &= 67108863, b = Math.imul(Ye, rt), f = Math.imul(Ye, it), f = f + Math.imul(Xe, rt) | 0, v = Math.imul(Xe, it), b = b + Math.imul(Je, st) | 0, f = f + Math.imul(Je, at) | 0, f = f + Math.imul(Qe, st) | 0, v = v + Math.imul(Qe, at) | 0, b = b + Math.imul(We, ot) | 0, f = f + Math.imul(We, ut) | 0, f = f + Math.imul(Ke, ot) | 0, v = v + Math.imul(Ke, ut) | 0, b = b + Math.imul(He, lt) | 0, f = f + Math.imul(He, ct) | 0, f = f + Math.imul(qe, lt) | 0, v = v + Math.imul(qe, ct) | 0, b = b + Math.imul(ne, dt) | 0, f = f + Math.imul(ne, ft) | 0, f = f + Math.imul(he, dt) | 0, v = v + Math.imul(he, ft) | 0, b = b + Math.imul(Q, pt) | 0, f = f + Math.imul(Q, ht) | 0, f = f + Math.imul(X, pt) | 0, v = v + Math.imul(X, ht) | 0, b = b + Math.imul(F, yt) | 0, f = f + Math.imul(F, mt) | 0, f = f + Math.imul($, yt) | 0, v = v + Math.imul($, mt) | 0, b = b + Math.imul(y, bt) | 0, f = f + Math.imul(y, gt) | 0, f = f + Math.imul(R, bt) | 0, v = v + Math.imul(R, gt) | 0;
      var Lf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Lf >>> 26) | 0, Lf &= 67108863, b = Math.imul(Ze, rt), f = Math.imul(Ze, it), f = f + Math.imul(et, rt) | 0, v = Math.imul(et, it), b = b + Math.imul(Ye, st) | 0, f = f + Math.imul(Ye, at) | 0, f = f + Math.imul(Xe, st) | 0, v = v + Math.imul(Xe, at) | 0, b = b + Math.imul(Je, ot) | 0, f = f + Math.imul(Je, ut) | 0, f = f + Math.imul(Qe, ot) | 0, v = v + Math.imul(Qe, ut) | 0, b = b + Math.imul(We, lt) | 0, f = f + Math.imul(We, ct) | 0, f = f + Math.imul(Ke, lt) | 0, v = v + Math.imul(Ke, ct) | 0, b = b + Math.imul(He, dt) | 0, f = f + Math.imul(He, ft) | 0, f = f + Math.imul(qe, dt) | 0, v = v + Math.imul(qe, ft) | 0, b = b + Math.imul(ne, pt) | 0, f = f + Math.imul(ne, ht) | 0, f = f + Math.imul(he, pt) | 0, v = v + Math.imul(he, ht) | 0, b = b + Math.imul(Q, yt) | 0, f = f + Math.imul(Q, mt) | 0, f = f + Math.imul(X, yt) | 0, v = v + Math.imul(X, mt) | 0, b = b + Math.imul(F, bt) | 0, f = f + Math.imul(F, gt) | 0, f = f + Math.imul($, bt) | 0, v = v + Math.imul($, gt) | 0, b = b + Math.imul(y, xt) | 0, f = f + Math.imul(y, vt) | 0, f = f + Math.imul(R, xt) | 0, v = v + Math.imul(R, vt) | 0;
      var $f = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + ($f >>> 26) | 0, $f &= 67108863, b = Math.imul(tt, rt), f = Math.imul(tt, it), f = f + Math.imul(nt, rt) | 0, v = Math.imul(nt, it), b = b + Math.imul(Ze, st) | 0, f = f + Math.imul(Ze, at) | 0, f = f + Math.imul(et, st) | 0, v = v + Math.imul(et, at) | 0, b = b + Math.imul(Ye, ot) | 0, f = f + Math.imul(Ye, ut) | 0, f = f + Math.imul(Xe, ot) | 0, v = v + Math.imul(Xe, ut) | 0, b = b + Math.imul(Je, lt) | 0, f = f + Math.imul(Je, ct) | 0, f = f + Math.imul(Qe, lt) | 0, v = v + Math.imul(Qe, ct) | 0, b = b + Math.imul(We, dt) | 0, f = f + Math.imul(We, ft) | 0, f = f + Math.imul(Ke, dt) | 0, v = v + Math.imul(Ke, ft) | 0, b = b + Math.imul(He, pt) | 0, f = f + Math.imul(He, ht) | 0, f = f + Math.imul(qe, pt) | 0, v = v + Math.imul(qe, ht) | 0, b = b + Math.imul(ne, yt) | 0, f = f + Math.imul(ne, mt) | 0, f = f + Math.imul(he, yt) | 0, v = v + Math.imul(he, mt) | 0, b = b + Math.imul(Q, bt) | 0, f = f + Math.imul(Q, gt) | 0, f = f + Math.imul(X, bt) | 0, v = v + Math.imul(X, gt) | 0, b = b + Math.imul(F, xt) | 0, f = f + Math.imul(F, vt) | 0, f = f + Math.imul($, xt) | 0, v = v + Math.imul($, vt) | 0, b = b + Math.imul(y, wt) | 0, f = f + Math.imul(y, Tt) | 0, f = f + Math.imul(R, wt) | 0, v = v + Math.imul(R, Tt) | 0;
      var Uf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Uf >>> 26) | 0, Uf &= 67108863, b = Math.imul(tt, st), f = Math.imul(tt, at), f = f + Math.imul(nt, st) | 0, v = Math.imul(nt, at), b = b + Math.imul(Ze, ot) | 0, f = f + Math.imul(Ze, ut) | 0, f = f + Math.imul(et, ot) | 0, v = v + Math.imul(et, ut) | 0, b = b + Math.imul(Ye, lt) | 0, f = f + Math.imul(Ye, ct) | 0, f = f + Math.imul(Xe, lt) | 0, v = v + Math.imul(Xe, ct) | 0, b = b + Math.imul(Je, dt) | 0, f = f + Math.imul(Je, ft) | 0, f = f + Math.imul(Qe, dt) | 0, v = v + Math.imul(Qe, ft) | 0, b = b + Math.imul(We, pt) | 0, f = f + Math.imul(We, ht) | 0, f = f + Math.imul(Ke, pt) | 0, v = v + Math.imul(Ke, ht) | 0, b = b + Math.imul(He, yt) | 0, f = f + Math.imul(He, mt) | 0, f = f + Math.imul(qe, yt) | 0, v = v + Math.imul(qe, mt) | 0, b = b + Math.imul(ne, bt) | 0, f = f + Math.imul(ne, gt) | 0, f = f + Math.imul(he, bt) | 0, v = v + Math.imul(he, gt) | 0, b = b + Math.imul(Q, xt) | 0, f = f + Math.imul(Q, vt) | 0, f = f + Math.imul(X, xt) | 0, v = v + Math.imul(X, vt) | 0, b = b + Math.imul(F, wt) | 0, f = f + Math.imul(F, Tt) | 0, f = f + Math.imul($, wt) | 0, v = v + Math.imul($, Tt) | 0;
      var jf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (jf >>> 26) | 0, jf &= 67108863, b = Math.imul(tt, ot), f = Math.imul(tt, ut), f = f + Math.imul(nt, ot) | 0, v = Math.imul(nt, ut), b = b + Math.imul(Ze, lt) | 0, f = f + Math.imul(Ze, ct) | 0, f = f + Math.imul(et, lt) | 0, v = v + Math.imul(et, ct) | 0, b = b + Math.imul(Ye, dt) | 0, f = f + Math.imul(Ye, ft) | 0, f = f + Math.imul(Xe, dt) | 0, v = v + Math.imul(Xe, ft) | 0, b = b + Math.imul(Je, pt) | 0, f = f + Math.imul(Je, ht) | 0, f = f + Math.imul(Qe, pt) | 0, v = v + Math.imul(Qe, ht) | 0, b = b + Math.imul(We, yt) | 0, f = f + Math.imul(We, mt) | 0, f = f + Math.imul(Ke, yt) | 0, v = v + Math.imul(Ke, mt) | 0, b = b + Math.imul(He, bt) | 0, f = f + Math.imul(He, gt) | 0, f = f + Math.imul(qe, bt) | 0, v = v + Math.imul(qe, gt) | 0, b = b + Math.imul(ne, xt) | 0, f = f + Math.imul(ne, vt) | 0, f = f + Math.imul(he, xt) | 0, v = v + Math.imul(he, vt) | 0, b = b + Math.imul(Q, wt) | 0, f = f + Math.imul(Q, Tt) | 0, f = f + Math.imul(X, wt) | 0, v = v + Math.imul(X, Tt) | 0;
      var Vf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Vf >>> 26) | 0, Vf &= 67108863, b = Math.imul(tt, lt), f = Math.imul(tt, ct), f = f + Math.imul(nt, lt) | 0, v = Math.imul(nt, ct), b = b + Math.imul(Ze, dt) | 0, f = f + Math.imul(Ze, ft) | 0, f = f + Math.imul(et, dt) | 0, v = v + Math.imul(et, ft) | 0, b = b + Math.imul(Ye, pt) | 0, f = f + Math.imul(Ye, ht) | 0, f = f + Math.imul(Xe, pt) | 0, v = v + Math.imul(Xe, ht) | 0, b = b + Math.imul(Je, yt) | 0, f = f + Math.imul(Je, mt) | 0, f = f + Math.imul(Qe, yt) | 0, v = v + Math.imul(Qe, mt) | 0, b = b + Math.imul(We, bt) | 0, f = f + Math.imul(We, gt) | 0, f = f + Math.imul(Ke, bt) | 0, v = v + Math.imul(Ke, gt) | 0, b = b + Math.imul(He, xt) | 0, f = f + Math.imul(He, vt) | 0, f = f + Math.imul(qe, xt) | 0, v = v + Math.imul(qe, vt) | 0, b = b + Math.imul(ne, wt) | 0, f = f + Math.imul(ne, Tt) | 0, f = f + Math.imul(he, wt) | 0, v = v + Math.imul(he, Tt) | 0;
      var zf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (zf >>> 26) | 0, zf &= 67108863, b = Math.imul(tt, dt), f = Math.imul(tt, ft), f = f + Math.imul(nt, dt) | 0, v = Math.imul(nt, ft), b = b + Math.imul(Ze, pt) | 0, f = f + Math.imul(Ze, ht) | 0, f = f + Math.imul(et, pt) | 0, v = v + Math.imul(et, ht) | 0, b = b + Math.imul(Ye, yt) | 0, f = f + Math.imul(Ye, mt) | 0, f = f + Math.imul(Xe, yt) | 0, v = v + Math.imul(Xe, mt) | 0, b = b + Math.imul(Je, bt) | 0, f = f + Math.imul(Je, gt) | 0, f = f + Math.imul(Qe, bt) | 0, v = v + Math.imul(Qe, gt) | 0, b = b + Math.imul(We, xt) | 0, f = f + Math.imul(We, vt) | 0, f = f + Math.imul(Ke, xt) | 0, v = v + Math.imul(Ke, vt) | 0, b = b + Math.imul(He, wt) | 0, f = f + Math.imul(He, Tt) | 0, f = f + Math.imul(qe, wt) | 0, v = v + Math.imul(qe, Tt) | 0;
      var Gf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Gf >>> 26) | 0, Gf &= 67108863, b = Math.imul(tt, pt), f = Math.imul(tt, ht), f = f + Math.imul(nt, pt) | 0, v = Math.imul(nt, ht), b = b + Math.imul(Ze, yt) | 0, f = f + Math.imul(Ze, mt) | 0, f = f + Math.imul(et, yt) | 0, v = v + Math.imul(et, mt) | 0, b = b + Math.imul(Ye, bt) | 0, f = f + Math.imul(Ye, gt) | 0, f = f + Math.imul(Xe, bt) | 0, v = v + Math.imul(Xe, gt) | 0, b = b + Math.imul(Je, xt) | 0, f = f + Math.imul(Je, vt) | 0, f = f + Math.imul(Qe, xt) | 0, v = v + Math.imul(Qe, vt) | 0, b = b + Math.imul(We, wt) | 0, f = f + Math.imul(We, Tt) | 0, f = f + Math.imul(Ke, wt) | 0, v = v + Math.imul(Ke, Tt) | 0;
      var Hf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Hf >>> 26) | 0, Hf &= 67108863, b = Math.imul(tt, yt), f = Math.imul(tt, mt), f = f + Math.imul(nt, yt) | 0, v = Math.imul(nt, mt), b = b + Math.imul(Ze, bt) | 0, f = f + Math.imul(Ze, gt) | 0, f = f + Math.imul(et, bt) | 0, v = v + Math.imul(et, gt) | 0, b = b + Math.imul(Ye, xt) | 0, f = f + Math.imul(Ye, vt) | 0, f = f + Math.imul(Xe, xt) | 0, v = v + Math.imul(Xe, vt) | 0, b = b + Math.imul(Je, wt) | 0, f = f + Math.imul(Je, Tt) | 0, f = f + Math.imul(Qe, wt) | 0, v = v + Math.imul(Qe, Tt) | 0;
      var qf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (qf >>> 26) | 0, qf &= 67108863, b = Math.imul(tt, bt), f = Math.imul(tt, gt), f = f + Math.imul(nt, bt) | 0, v = Math.imul(nt, gt), b = b + Math.imul(Ze, xt) | 0, f = f + Math.imul(Ze, vt) | 0, f = f + Math.imul(et, xt) | 0, v = v + Math.imul(et, vt) | 0, b = b + Math.imul(Ye, wt) | 0, f = f + Math.imul(Ye, Tt) | 0, f = f + Math.imul(Xe, wt) | 0, v = v + Math.imul(Xe, Tt) | 0;
      var Wf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Wf >>> 26) | 0, Wf &= 67108863, b = Math.imul(tt, xt), f = Math.imul(tt, vt), f = f + Math.imul(nt, xt) | 0, v = Math.imul(nt, vt), b = b + Math.imul(Ze, wt) | 0, f = f + Math.imul(Ze, Tt) | 0, f = f + Math.imul(et, wt) | 0, v = v + Math.imul(et, Tt) | 0;
      var Kf = (P + b | 0) + ((f & 8191) << 13) | 0;
      P = (v + (f >>> 13) | 0) + (Kf >>> 26) | 0, Kf &= 67108863, b = Math.imul(tt, wt), f = Math.imul(tt, Tt), f = f + Math.imul(nt, wt) | 0, v = Math.imul(nt, Tt);
      var Jf = (P + b | 0) + ((f & 8191) << 13) | 0;
      return P = (v + (f >>> 13) | 0) + (Jf >>> 26) | 0, Jf &= 67108863, _[0] = Ki, _[1] = Ji, _[2] = Qi, _[3] = Yi, _[4] = Xi, _[5] = Bf, _[6] = Ff, _[7] = Lf, _[8] = $f, _[9] = Uf, _[10] = jf, _[11] = Vf, _[12] = zf, _[13] = Gf, _[14] = Hf, _[15] = qf, _[16] = Wf, _[17] = Kf, _[18] = Jf, P !== 0 && (_[19] = P, g.length++), g;
    };
    Math.imul || (I = M);
    function B(C, c, h) {
      h.negative = c.negative ^ C.negative, h.length = C.length + c.length;
      for (var g = 0, E = 0, S = 0; S < h.length - 1; S++) {
        var _ = E;
        E = 0;
        for (var P = g & 67108863, b = Math.min(S, c.length - 1), f = Math.max(0, S - C.length + 1); f <= b; f++) {
          var v = S - f, O = C.words[v] | 0, y = c.words[f] | 0, R = O * y, L = R & 67108863;
          _ = _ + (R / 67108864 | 0) | 0, L = L + P | 0, P = L & 67108863, _ = _ + (L >>> 26) | 0, E += _ >>> 26, _ &= 67108863;
        }
        h.words[S] = P, g = _, _ = E;
      }
      return g !== 0 ? h.words[S] = g : h.length--, h._strip();
    }
    function k(C, c, h) {
      return B(C, c, h);
    }
    s.prototype.mulTo = function(c, h) {
      var g, E = this.length + c.length;
      return this.length === 10 && c.length === 10 ? g = I(this, c, h) : E < 63 ? g = M(this, c, h) : E < 1024 ? g = B(this, c, h) : g = k(this, c, h), g;
    }, s.prototype.mul = function(c) {
      var h = new s(null);
      return h.words = new Array(this.length + c.length), this.mulTo(c, h);
    }, s.prototype.mulf = function(c) {
      var h = new s(null);
      return h.words = new Array(this.length + c.length), k(this, c, h);
    }, s.prototype.imul = function(c) {
      return this.clone().mulTo(c, this);
    }, s.prototype.imuln = function(c) {
      var h = c < 0;
      h && (c = -c), r(typeof c == "number"), r(c < 67108864);
      for (var g = 0, E = 0; E < this.length; E++) {
        var S = (this.words[E] | 0) * c, _ = (S & 67108863) + (g & 67108863);
        g >>= 26, g += S / 67108864 | 0, g += _ >>> 26, this.words[E] = _ & 67108863;
      }
      return g !== 0 && (this.words[E] = g, this.length++), h ? this.ineg() : this;
    }, s.prototype.muln = function(c) {
      return this.clone().imuln(c);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(c) {
      var h = A(c);
      if (h.length === 0)
        return new s(1);
      for (var g = this, E = 0; E < h.length && h[E] === 0; E++, g = g.sqr())
        ;
      if (++E < h.length)
        for (var S = g.sqr(); E < h.length; E++, S = S.sqr())
          h[E] !== 0 && (g = g.mul(S));
      return g;
    }, s.prototype.iushln = function(c) {
      r(typeof c == "number" && c >= 0);
      var h = c % 26, g = (c - h) / 26, E = 67108863 >>> 26 - h << 26 - h, S;
      if (h !== 0) {
        var _ = 0;
        for (S = 0; S < this.length; S++) {
          var P = this.words[S] & E, b = (this.words[S] | 0) - P << h;
          this.words[S] = b | _, _ = P >>> 26 - h;
        }
        _ && (this.words[S] = _, this.length++);
      }
      if (g !== 0) {
        for (S = this.length - 1; S >= 0; S--)
          this.words[S + g] = this.words[S];
        for (S = 0; S < g; S++)
          this.words[S] = 0;
        this.length += g;
      }
      return this._strip();
    }, s.prototype.ishln = function(c) {
      return r(this.negative === 0), this.iushln(c);
    }, s.prototype.iushrn = function(c, h, g) {
      r(typeof c == "number" && c >= 0);
      var E;
      h ? E = (h - h % 26) / 26 : E = 0;
      var S = c % 26, _ = Math.min((c - S) / 26, this.length), P = 67108863 ^ 67108863 >>> S << S, b = g;
      if (E -= _, E = Math.max(0, E), b) {
        for (var f = 0; f < _; f++)
          b.words[f] = this.words[f];
        b.length = _;
      }
      if (_ !== 0)
        if (this.length > _)
          for (this.length -= _, f = 0; f < this.length; f++)
            this.words[f] = this.words[f + _];
        else
          this.words[0] = 0, this.length = 1;
      var v = 0;
      for (f = this.length - 1; f >= 0 && (v !== 0 || f >= E); f--) {
        var O = this.words[f] | 0;
        this.words[f] = v << 26 - S | O >>> S, v = O & P;
      }
      return b && v !== 0 && (b.words[b.length++] = v), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(c, h, g) {
      return r(this.negative === 0), this.iushrn(c, h, g);
    }, s.prototype.shln = function(c) {
      return this.clone().ishln(c);
    }, s.prototype.ushln = function(c) {
      return this.clone().iushln(c);
    }, s.prototype.shrn = function(c) {
      return this.clone().ishrn(c);
    }, s.prototype.ushrn = function(c) {
      return this.clone().iushrn(c);
    }, s.prototype.testn = function(c) {
      r(typeof c == "number" && c >= 0);
      var h = c % 26, g = (c - h) / 26, E = 1 << h;
      if (this.length <= g)
        return !1;
      var S = this.words[g];
      return !!(S & E);
    }, s.prototype.imaskn = function(c) {
      r(typeof c == "number" && c >= 0);
      var h = c % 26, g = (c - h) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= g)
        return this;
      if (h !== 0 && g++, this.length = Math.min(g, this.length), h !== 0) {
        var E = 67108863 ^ 67108863 >>> h << h;
        this.words[this.length - 1] &= E;
      }
      return this._strip();
    }, s.prototype.maskn = function(c) {
      return this.clone().imaskn(c);
    }, s.prototype.iaddn = function(c) {
      return r(typeof c == "number"), r(c < 67108864), c < 0 ? this.isubn(-c) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= c ? (this.words[0] = c - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(c), this.negative = 1, this) : this._iaddn(c);
    }, s.prototype._iaddn = function(c) {
      this.words[0] += c;
      for (var h = 0; h < this.length && this.words[h] >= 67108864; h++)
        this.words[h] -= 67108864, h === this.length - 1 ? this.words[h + 1] = 1 : this.words[h + 1]++;
      return this.length = Math.max(this.length, h + 1), this;
    }, s.prototype.isubn = function(c) {
      if (r(typeof c == "number"), r(c < 67108864), c < 0)
        return this.iaddn(-c);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(c), this.negative = 1, this;
      if (this.words[0] -= c, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var h = 0; h < this.length && this.words[h] < 0; h++)
          this.words[h] += 67108864, this.words[h + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(c) {
      return this.clone().iaddn(c);
    }, s.prototype.subn = function(c) {
      return this.clone().isubn(c);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(c, h, g) {
      var E = c.length + g, S;
      this._expand(E);
      var _, P = 0;
      for (S = 0; S < c.length; S++) {
        _ = (this.words[S + g] | 0) + P;
        var b = (c.words[S] | 0) * h;
        _ -= b & 67108863, P = (_ >> 26) - (b / 67108864 | 0), this.words[S + g] = _ & 67108863;
      }
      for (; S < this.length - g; S++)
        _ = (this.words[S + g] | 0) + P, P = _ >> 26, this.words[S + g] = _ & 67108863;
      if (P === 0)
        return this._strip();
      for (r(P === -1), P = 0, S = 0; S < this.length; S++)
        _ = -(this.words[S] | 0) + P, P = _ >> 26, this.words[S] = _ & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(c, h) {
      var g = this.length - c.length, E = this.clone(), S = c, _ = S.words[S.length - 1] | 0, P = this._countBits(_);
      g = 26 - P, g !== 0 && (S = S.ushln(g), E.iushln(g), _ = S.words[S.length - 1] | 0);
      var b = E.length - S.length, f;
      if (h !== "mod") {
        f = new s(null), f.length = b + 1, f.words = new Array(f.length);
        for (var v = 0; v < f.length; v++)
          f.words[v] = 0;
      }
      var O = E.clone()._ishlnsubmul(S, 1, b);
      O.negative === 0 && (E = O, f && (f.words[b] = 1));
      for (var y = b - 1; y >= 0; y--) {
        var R = (E.words[S.length + y] | 0) * 67108864 + (E.words[S.length + y - 1] | 0);
        for (R = Math.min(R / _ | 0, 67108863), E._ishlnsubmul(S, R, y); E.negative !== 0; )
          R--, E.negative = 0, E._ishlnsubmul(S, 1, y), E.isZero() || (E.negative ^= 1);
        f && (f.words[y] = R);
      }
      return f && f._strip(), E._strip(), h !== "div" && g !== 0 && E.iushrn(g), {
        div: f || null,
        mod: E
      };
    }, s.prototype.divmod = function(c, h, g) {
      if (r(!c.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var E, S, _;
      return this.negative !== 0 && c.negative === 0 ? (_ = this.neg().divmod(c, h), h !== "mod" && (E = _.div.neg()), h !== "div" && (S = _.mod.neg(), g && S.negative !== 0 && S.iadd(c)), {
        div: E,
        mod: S
      }) : this.negative === 0 && c.negative !== 0 ? (_ = this.divmod(c.neg(), h), h !== "mod" && (E = _.div.neg()), {
        div: E,
        mod: _.mod
      }) : this.negative & c.negative ? (_ = this.neg().divmod(c.neg(), h), h !== "div" && (S = _.mod.neg(), g && S.negative !== 0 && S.isub(c)), {
        div: _.div,
        mod: S
      }) : c.length > this.length || this.cmp(c) < 0 ? {
        div: new s(0),
        mod: this
      } : c.length === 1 ? h === "div" ? {
        div: this.divn(c.words[0]),
        mod: null
      } : h === "mod" ? {
        div: null,
        mod: new s(this.modrn(c.words[0]))
      } : {
        div: this.divn(c.words[0]),
        mod: new s(this.modrn(c.words[0]))
      } : this._wordDiv(c, h);
    }, s.prototype.div = function(c) {
      return this.divmod(c, "div", !1).div;
    }, s.prototype.mod = function(c) {
      return this.divmod(c, "mod", !1).mod;
    }, s.prototype.umod = function(c) {
      return this.divmod(c, "mod", !0).mod;
    }, s.prototype.divRound = function(c) {
      var h = this.divmod(c);
      if (h.mod.isZero())
        return h.div;
      var g = h.div.negative !== 0 ? h.mod.isub(c) : h.mod, E = c.ushrn(1), S = c.andln(1), _ = g.cmp(E);
      return _ < 0 || S === 1 && _ === 0 ? h.div : h.div.negative !== 0 ? h.div.isubn(1) : h.div.iaddn(1);
    }, s.prototype.modrn = function(c) {
      var h = c < 0;
      h && (c = -c), r(c <= 67108863);
      for (var g = (1 << 26) % c, E = 0, S = this.length - 1; S >= 0; S--)
        E = (g * E + (this.words[S] | 0)) % c;
      return h ? -E : E;
    }, s.prototype.modn = function(c) {
      return this.modrn(c);
    }, s.prototype.idivn = function(c) {
      var h = c < 0;
      h && (c = -c), r(c <= 67108863);
      for (var g = 0, E = this.length - 1; E >= 0; E--) {
        var S = (this.words[E] | 0) + g * 67108864;
        this.words[E] = S / c | 0, g = S % c;
      }
      return this._strip(), h ? this.ineg() : this;
    }, s.prototype.divn = function(c) {
      return this.clone().idivn(c);
    }, s.prototype.egcd = function(c) {
      r(c.negative === 0), r(!c.isZero());
      var h = this, g = c.clone();
      h.negative !== 0 ? h = h.umod(c) : h = h.clone();
      for (var E = new s(1), S = new s(0), _ = new s(0), P = new s(1), b = 0; h.isEven() && g.isEven(); )
        h.iushrn(1), g.iushrn(1), ++b;
      for (var f = g.clone(), v = h.clone(); !h.isZero(); ) {
        for (var O = 0, y = 1; !(h.words[0] & y) && O < 26; ++O, y <<= 1)
          ;
        if (O > 0)
          for (h.iushrn(O); O-- > 0; )
            (E.isOdd() || S.isOdd()) && (E.iadd(f), S.isub(v)), E.iushrn(1), S.iushrn(1);
        for (var R = 0, L = 1; !(g.words[0] & L) && R < 26; ++R, L <<= 1)
          ;
        if (R > 0)
          for (g.iushrn(R); R-- > 0; )
            (_.isOdd() || P.isOdd()) && (_.iadd(f), P.isub(v)), _.iushrn(1), P.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), E.isub(_), S.isub(P)) : (g.isub(h), _.isub(E), P.isub(S));
      }
      return {
        a: _,
        b: P,
        gcd: g.iushln(b)
      };
    }, s.prototype._invmp = function(c) {
      r(c.negative === 0), r(!c.isZero());
      var h = this, g = c.clone();
      h.negative !== 0 ? h = h.umod(c) : h = h.clone();
      for (var E = new s(1), S = new s(0), _ = g.clone(); h.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
        for (var P = 0, b = 1; !(h.words[0] & b) && P < 26; ++P, b <<= 1)
          ;
        if (P > 0)
          for (h.iushrn(P); P-- > 0; )
            E.isOdd() && E.iadd(_), E.iushrn(1);
        for (var f = 0, v = 1; !(g.words[0] & v) && f < 26; ++f, v <<= 1)
          ;
        if (f > 0)
          for (g.iushrn(f); f-- > 0; )
            S.isOdd() && S.iadd(_), S.iushrn(1);
        h.cmp(g) >= 0 ? (h.isub(g), E.isub(S)) : (g.isub(h), S.isub(E));
      }
      var O;
      return h.cmpn(1) === 0 ? O = E : O = S, O.cmpn(0) < 0 && O.iadd(c), O;
    }, s.prototype.gcd = function(c) {
      if (this.isZero())
        return c.abs();
      if (c.isZero())
        return this.abs();
      var h = this.clone(), g = c.clone();
      h.negative = 0, g.negative = 0;
      for (var E = 0; h.isEven() && g.isEven(); E++)
        h.iushrn(1), g.iushrn(1);
      do {
        for (; h.isEven(); )
          h.iushrn(1);
        for (; g.isEven(); )
          g.iushrn(1);
        var S = h.cmp(g);
        if (S < 0) {
          var _ = h;
          h = g, g = _;
        } else if (S === 0 || g.cmpn(1) === 0)
          break;
        h.isub(g);
      } while (!0);
      return g.iushln(E);
    }, s.prototype.invm = function(c) {
      return this.egcd(c).a.umod(c);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(c) {
      return this.words[0] & c;
    }, s.prototype.bincn = function(c) {
      r(typeof c == "number");
      var h = c % 26, g = (c - h) / 26, E = 1 << h;
      if (this.length <= g)
        return this._expand(g + 1), this.words[g] |= E, this;
      for (var S = E, _ = g; S !== 0 && _ < this.length; _++) {
        var P = this.words[_] | 0;
        P += S, S = P >>> 26, P &= 67108863, this.words[_] = P;
      }
      return S !== 0 && (this.words[_] = S, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(c) {
      var h = c < 0;
      if (this.negative !== 0 && !h)
        return -1;
      if (this.negative === 0 && h)
        return 1;
      this._strip();
      var g;
      if (this.length > 1)
        g = 1;
      else {
        h && (c = -c), r(c <= 67108863, "Number is too big");
        var E = this.words[0] | 0;
        g = E === c ? 0 : E < c ? -1 : 1;
      }
      return this.negative !== 0 ? -g | 0 : g;
    }, s.prototype.cmp = function(c) {
      if (this.negative !== 0 && c.negative === 0)
        return -1;
      if (this.negative === 0 && c.negative !== 0)
        return 1;
      var h = this.ucmp(c);
      return this.negative !== 0 ? -h | 0 : h;
    }, s.prototype.ucmp = function(c) {
      if (this.length > c.length)
        return 1;
      if (this.length < c.length)
        return -1;
      for (var h = 0, g = this.length - 1; g >= 0; g--) {
        var E = this.words[g] | 0, S = c.words[g] | 0;
        if (E !== S) {
          E < S ? h = -1 : E > S && (h = 1);
          break;
        }
      }
      return h;
    }, s.prototype.gtn = function(c) {
      return this.cmpn(c) === 1;
    }, s.prototype.gt = function(c) {
      return this.cmp(c) === 1;
    }, s.prototype.gten = function(c) {
      return this.cmpn(c) >= 0;
    }, s.prototype.gte = function(c) {
      return this.cmp(c) >= 0;
    }, s.prototype.ltn = function(c) {
      return this.cmpn(c) === -1;
    }, s.prototype.lt = function(c) {
      return this.cmp(c) === -1;
    }, s.prototype.lten = function(c) {
      return this.cmpn(c) <= 0;
    }, s.prototype.lte = function(c) {
      return this.cmp(c) <= 0;
    }, s.prototype.eqn = function(c) {
      return this.cmpn(c) === 0;
    }, s.prototype.eq = function(c) {
      return this.cmp(c) === 0;
    }, s.red = function(c) {
      return new K(c);
    }, s.prototype.toRed = function(c) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), c.convertTo(this)._forceRed(c);
    }, s.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(c) {
      return this.red = c, this;
    }, s.prototype.forceRed = function(c) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(c);
    }, s.prototype.redAdd = function(c) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, c);
    }, s.prototype.redIAdd = function(c) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, c);
    }, s.prototype.redSub = function(c) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, c);
    }, s.prototype.redISub = function(c) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, c);
    }, s.prototype.redShl = function(c) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, c);
    }, s.prototype.redMul = function(c) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.mul(this, c);
    }, s.prototype.redIMul = function(c) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.imul(this, c);
    }, s.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(c) {
      return r(this.red && !c.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, c);
    };
    var N = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function U(C, c) {
      this.name = C, this.p = new s(c, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    U.prototype._tmp = function() {
      var c = new s(null);
      return c.words = new Array(Math.ceil(this.n / 13)), c;
    }, U.prototype.ireduce = function(c) {
      var h = c, g;
      do
        this.split(h, this.tmp), h = this.imulK(h), h = h.iadd(this.tmp), g = h.bitLength();
      while (g > this.n);
      var E = g < this.n ? -1 : h.ucmp(this.p);
      return E === 0 ? (h.words[0] = 0, h.length = 1) : E > 0 ? h.isub(this.p) : h.strip !== void 0 ? h.strip() : h._strip(), h;
    }, U.prototype.split = function(c, h) {
      c.iushrn(this.n, 0, h);
    }, U.prototype.imulK = function(c) {
      return c.imul(this.k);
    };
    function W() {
      U.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(W, U), W.prototype.split = function(c, h) {
      for (var g = 4194303, E = Math.min(c.length, 9), S = 0; S < E; S++)
        h.words[S] = c.words[S];
      if (h.length = E, c.length <= 9) {
        c.words[0] = 0, c.length = 1;
        return;
      }
      var _ = c.words[9];
      for (h.words[h.length++] = _ & g, S = 10; S < c.length; S++) {
        var P = c.words[S] | 0;
        c.words[S - 10] = (P & g) << 4 | _ >>> 22, _ = P;
      }
      _ >>>= 22, c.words[S - 10] = _, _ === 0 && c.length > 10 ? c.length -= 10 : c.length -= 9;
    }, W.prototype.imulK = function(c) {
      c.words[c.length] = 0, c.words[c.length + 1] = 0, c.length += 2;
      for (var h = 0, g = 0; g < c.length; g++) {
        var E = c.words[g] | 0;
        h += E * 977, c.words[g] = h & 67108863, h = E * 64 + (h / 67108864 | 0);
      }
      return c.words[c.length - 1] === 0 && (c.length--, c.words[c.length - 1] === 0 && c.length--), c;
    };
    function G() {
      U.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(G, U);
    function Y() {
      U.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(Y, U);
    function ue() {
      U.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(ue, U), ue.prototype.imulK = function(c) {
      for (var h = 0, g = 0; g < c.length; g++) {
        var E = (c.words[g] | 0) * 19 + h, S = E & 67108863;
        E >>>= 26, c.words[g] = S, h = E;
      }
      return h !== 0 && (c.words[c.length++] = h), c;
    }, s._prime = function(c) {
      if (N[c])
        return N[c];
      var h;
      if (c === "k256")
        h = new W();
      else if (c === "p224")
        h = new G();
      else if (c === "p192")
        h = new Y();
      else if (c === "p25519")
        h = new ue();
      else
        throw new Error("Unknown prime " + c);
      return N[c] = h, h;
    };
    function K(C) {
      if (typeof C == "string") {
        var c = s._prime(C);
        this.m = c.p, this.prime = c;
      } else
        r(C.gtn(1), "modulus must be greater than 1"), this.m = C, this.prime = null;
    }
    K.prototype._verify1 = function(c) {
      r(c.negative === 0, "red works only with positives"), r(c.red, "red works only with red numbers");
    }, K.prototype._verify2 = function(c, h) {
      r((c.negative | h.negative) === 0, "red works only with positives"), r(
        c.red && c.red === h.red,
        "red works only with red numbers"
      );
    }, K.prototype.imod = function(c) {
      return this.prime ? this.prime.ireduce(c)._forceRed(this) : (d(c, c.umod(this.m)._forceRed(this)), c);
    }, K.prototype.neg = function(c) {
      return c.isZero() ? c.clone() : this.m.sub(c)._forceRed(this);
    }, K.prototype.add = function(c, h) {
      this._verify2(c, h);
      var g = c.add(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
    }, K.prototype.iadd = function(c, h) {
      this._verify2(c, h);
      var g = c.iadd(h);
      return g.cmp(this.m) >= 0 && g.isub(this.m), g;
    }, K.prototype.sub = function(c, h) {
      this._verify2(c, h);
      var g = c.sub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
    }, K.prototype.isub = function(c, h) {
      this._verify2(c, h);
      var g = c.isub(h);
      return g.cmpn(0) < 0 && g.iadd(this.m), g;
    }, K.prototype.shl = function(c, h) {
      return this._verify1(c), this.imod(c.ushln(h));
    }, K.prototype.imul = function(c, h) {
      return this._verify2(c, h), this.imod(c.imul(h));
    }, K.prototype.mul = function(c, h) {
      return this._verify2(c, h), this.imod(c.mul(h));
    }, K.prototype.isqr = function(c) {
      return this.imul(c, c.clone());
    }, K.prototype.sqr = function(c) {
      return this.mul(c, c);
    }, K.prototype.sqrt = function(c) {
      if (c.isZero())
        return c.clone();
      var h = this.m.andln(3);
      if (r(h % 2 === 1), h === 3) {
        var g = this.m.add(new s(1)).iushrn(2);
        return this.pow(c, g);
      }
      for (var E = this.m.subn(1), S = 0; !E.isZero() && E.andln(1) === 0; )
        S++, E.iushrn(1);
      r(!E.isZero());
      var _ = new s(1).toRed(this), P = _.redNeg(), b = this.m.subn(1).iushrn(1), f = this.m.bitLength();
      for (f = new s(2 * f * f).toRed(this); this.pow(f, b).cmp(P) !== 0; )
        f.redIAdd(P);
      for (var v = this.pow(f, E), O = this.pow(c, E.addn(1).iushrn(1)), y = this.pow(c, E), R = S; y.cmp(_) !== 0; ) {
        for (var L = y, F = 0; L.cmp(_) !== 0; F++)
          L = L.redSqr();
        r(F < R);
        var $ = this.pow(v, new s(1).iushln(R - F - 1));
        O = O.redMul($), v = $.redSqr(), y = y.redMul(v), R = F;
      }
      return O;
    }, K.prototype.invm = function(c) {
      var h = c._invmp(this.m);
      return h.negative !== 0 ? (h.negative = 0, this.imod(h).redNeg()) : this.imod(h);
    }, K.prototype.pow = function(c, h) {
      if (h.isZero())
        return new s(1).toRed(this);
      if (h.cmpn(1) === 0)
        return c.clone();
      var g = 4, E = new Array(1 << g);
      E[0] = new s(1).toRed(this), E[1] = c;
      for (var S = 2; S < E.length; S++)
        E[S] = this.mul(E[S - 1], c);
      var _ = E[0], P = 0, b = 0, f = h.bitLength() % 26;
      for (f === 0 && (f = 26), S = h.length - 1; S >= 0; S--) {
        for (var v = h.words[S], O = f - 1; O >= 0; O--) {
          var y = v >> O & 1;
          if (_ !== E[0] && (_ = this.sqr(_)), y === 0 && P === 0) {
            b = 0;
            continue;
          }
          P <<= 1, P |= y, b++, !(b !== g && (S !== 0 || O !== 0)) && (_ = this.mul(_, E[P]), b = 0, P = 0);
        }
        f = 26;
      }
      return _;
    }, K.prototype.convertTo = function(c) {
      var h = c.umod(this.m);
      return h === c ? h.clone() : h;
    }, K.prototype.convertFrom = function(c) {
      var h = c.clone();
      return h.red = null, h;
    }, s.mont = function(c) {
      return new le(c);
    };
    function le(C) {
      K.call(this, C), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(le, K), le.prototype.convertTo = function(c) {
      return this.imod(c.ushln(this.shift));
    }, le.prototype.convertFrom = function(c) {
      var h = this.imod(c.mul(this.rinv));
      return h.red = null, h;
    }, le.prototype.imul = function(c, h) {
      if (c.isZero() || h.isZero())
        return c.words[0] = 0, c.length = 1, c;
      var g = c.imul(h), E = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), S = g.isub(E).iushrn(this.shift), _ = S;
      return S.cmp(this.m) >= 0 ? _ = S.isub(this.m) : S.cmpn(0) < 0 && (_ = S.iadd(this.m)), _._forceRed(this);
    }, le.prototype.mul = function(c, h) {
      if (c.isZero() || h.isZero())
        return new s(0)._forceRed(this);
      var g = c.mul(h), E = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), S = g.isub(E).iushrn(this.shift), _ = S;
      return S.cmp(this.m) >= 0 ? _ = S.isub(this.m) : S.cmpn(0) < 0 && (_ = S.iadd(this.m)), _._forceRed(this);
    }, le.prototype.invm = function(c) {
      var h = this.imod(c._invmp(this.m).mul(this.r2));
      return h._forceRed(this);
    };
  })(n, bi);
})(ay);
var Y4 = ay.exports;
const ye = /* @__PURE__ */ _s(Y4), X4 = "logger/5.7.0";
let Ng = !1, Dg = !1;
const Cc = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let Bg = Cc.default, yp = null;
function Z4() {
  try {
    const n = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
      try {
        if ("test".normalize(e) !== "test")
          throw new Error("bad normalize");
      } catch {
        n.push(e);
      }
    }), n.length)
      throw new Error("missing " + n.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (n) {
    return n.message;
  }
  return null;
}
const Fg = Z4();
var ud;
(function(n) {
  n.DEBUG = "DEBUG", n.INFO = "INFO", n.WARNING = "WARNING", n.ERROR = "ERROR", n.OFF = "OFF";
})(ud || (ud = {}));
var ur;
(function(n) {
  n.UNKNOWN_ERROR = "UNKNOWN_ERROR", n.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", n.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", n.NETWORK_ERROR = "NETWORK_ERROR", n.SERVER_ERROR = "SERVER_ERROR", n.TIMEOUT = "TIMEOUT", n.BUFFER_OVERRUN = "BUFFER_OVERRUN", n.NUMERIC_FAULT = "NUMERIC_FAULT", n.MISSING_NEW = "MISSING_NEW", n.INVALID_ARGUMENT = "INVALID_ARGUMENT", n.MISSING_ARGUMENT = "MISSING_ARGUMENT", n.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", n.CALL_EXCEPTION = "CALL_EXCEPTION", n.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", n.NONCE_EXPIRED = "NONCE_EXPIRED", n.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", n.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", n.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", n.ACTION_REJECTED = "ACTION_REJECTED";
})(ur || (ur = {}));
const Lg = "0123456789abcdef";
let D = class Ht {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1
    });
  }
  _log(e, t) {
    const r = e.toLowerCase();
    Cc[r] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(Bg > Cc[r]) && console.log.apply(console, t);
  }
  debug(...e) {
    this._log(Ht.levels.DEBUG, e);
  }
  info(...e) {
    this._log(Ht.levels.INFO, e);
  }
  warn(...e) {
    this._log(Ht.levels.WARNING, e);
  }
  makeError(e, t, r) {
    if (Dg)
      return this.makeError("censored error", t, {});
    t || (t = Ht.errors.UNKNOWN_ERROR), r || (r = {});
    const i = [];
    Object.keys(r).forEach((u) => {
      const l = r[u];
      try {
        if (l instanceof Uint8Array) {
          let d = "";
          for (let p = 0; p < l.length; p++)
            d += Lg[l[p] >> 4], d += Lg[l[p] & 15];
          i.push(u + "=Uint8Array(0x" + d + ")");
        } else
          i.push(u + "=" + JSON.stringify(l));
      } catch {
        i.push(u + "=" + JSON.stringify(r[u].toString()));
      }
    }), i.push(`code=${t}`), i.push(`version=${this.version}`);
    const s = e;
    let a = "";
    switch (t) {
      case ur.NUMERIC_FAULT: {
        a = "NUMERIC_FAULT";
        const u = e;
        switch (u) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            a += "-" + u;
            break;
          case "negative-power":
          case "negative-width":
            a += "-unsupported";
            break;
          case "unbound-bitwise-result":
            a += "-unbound-result";
            break;
        }
        break;
      }
      case ur.CALL_EXCEPTION:
      case ur.INSUFFICIENT_FUNDS:
      case ur.MISSING_NEW:
      case ur.NONCE_EXPIRED:
      case ur.REPLACEMENT_UNDERPRICED:
      case ur.TRANSACTION_REPLACED:
      case ur.UNPREDICTABLE_GAS_LIMIT:
        a = t;
        break;
    }
    a && (e += " [ See: https://links.ethers.org/v5-errors-" + a + " ]"), i.length && (e += " (" + i.join(", ") + ")");
    const o = new Error(e);
    return o.reason = s, o.code = t, Object.keys(r).forEach(function(u) {
      o[u] = r[u];
    }), o;
  }
  throwError(e, t, r) {
    throw this.makeError(e, t, r);
  }
  throwArgumentError(e, t, r) {
    return this.throwError(e, Ht.errors.INVALID_ARGUMENT, {
      argument: t,
      value: r
    });
  }
  assert(e, t, r, i) {
    e || this.throwError(t, r, i);
  }
  assertArgument(e, t, r, i) {
    e || this.throwArgumentError(t, r, i);
  }
  checkNormalize(e) {
    Fg && this.throwError("platform missing String.prototype.normalize", Ht.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: Fg
    });
  }
  checkSafeUint53(e, t) {
    typeof e == "number" && (t == null && (t = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(t, Ht.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: e
    }), e % 1 && this.throwError(t, Ht.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: e
    }));
  }
  checkArgumentCount(e, t, r) {
    r ? r = ": " + r : r = "", e < t && this.throwError("missing argument" + r, Ht.errors.MISSING_ARGUMENT, {
      count: e,
      expectedCount: t
    }), e > t && this.throwError("too many arguments" + r, Ht.errors.UNEXPECTED_ARGUMENT, {
      count: e,
      expectedCount: t
    });
  }
  checkNew(e, t) {
    (e === Object || e == null) && this.throwError("missing new", Ht.errors.MISSING_NEW, { name: t.name });
  }
  checkAbstract(e, t) {
    e === t ? this.throwError("cannot instantiate abstract class " + JSON.stringify(t.name) + " directly; use a sub-class", Ht.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: "new" }) : (e === Object || e == null) && this.throwError("missing new", Ht.errors.MISSING_NEW, { name: t.name });
  }
  static globalLogger() {
    return yp || (yp = new Ht(X4)), yp;
  }
  static setCensorship(e, t) {
    if (!e && t && this.globalLogger().throwError("cannot permanently disable censorship", Ht.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), Ng) {
      if (!e)
        return;
      this.globalLogger().throwError("error censorship permanent", Ht.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    Dg = !!e, Ng = !!t;
  }
  static setLogLevel(e) {
    const t = Cc[e.toLowerCase()];
    if (t == null) {
      Ht.globalLogger().warn("invalid log level - " + e);
      return;
    }
    Bg = t;
  }
  static from(e) {
    return new Ht(e);
  }
};
D.errors = ur;
D.levels = ud;
const eS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ErrorCode() {
    return ur;
  },
  get LogLevel() {
    return ud;
  },
  Logger: D
}, Symbol.toStringTag, { value: "Module" })), tS = "bytes/5.7.0", Pt = new D(tS);
function X1(n) {
  return !!n.toHexString;
}
function po(n) {
  return n.slice || (n.slice = function() {
    const e = Array.prototype.slice.call(arguments);
    return po(new Uint8Array(Array.prototype.slice.apply(n, e)));
  }), n;
}
function Il(n) {
  return _e(n) && !(n.length % 2) || Da(n);
}
function $g(n) {
  return typeof n == "number" && n == n && n % 1 === 0;
}
function Da(n) {
  if (n == null)
    return !1;
  if (n.constructor === Uint8Array)
    return !0;
  if (typeof n == "string" || !$g(n.length) || n.length < 0)
    return !1;
  for (let e = 0; e < n.length; e++) {
    const t = n[e];
    if (!$g(t) || t < 0 || t >= 256)
      return !1;
  }
  return !0;
}
function q(n, e) {
  if (e || (e = {}), typeof n == "number") {
    Pt.checkSafeUint53(n, "invalid arrayify value");
    const t = [];
    for (; n; )
      t.unshift(n & 255), n = parseInt(String(n / 256));
    return t.length === 0 && t.push(0), po(new Uint8Array(t));
  }
  if (e.allowMissingPrefix && typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), X1(n) && (n = n.toHexString()), _e(n)) {
    let t = n.substring(2);
    t.length % 2 && (e.hexPad === "left" ? t = "0" + t : e.hexPad === "right" ? t += "0" : Pt.throwArgumentError("hex data is odd-length", "value", n));
    const r = [];
    for (let i = 0; i < t.length; i += 2)
      r.push(parseInt(t.substring(i, i + 2), 16));
    return po(new Uint8Array(r));
  }
  return Da(n) ? po(new Uint8Array(n)) : Pt.throwArgumentError("invalid arrayify value", "value", n);
}
function Ge(n) {
  const e = n.map((i) => q(i)), t = e.reduce((i, s) => i + s.length, 0), r = new Uint8Array(t);
  return e.reduce((i, s) => (r.set(s, i), i + s.length), 0), po(r);
}
function Qr(n) {
  let e = q(n);
  if (e.length === 0)
    return e;
  let t = 0;
  for (; t < e.length && e[t] === 0; )
    t++;
  return t && (e = e.slice(t)), e;
}
function Eu(n, e) {
  n = q(n), n.length > e && Pt.throwArgumentError("value out of range", "value", arguments[0]);
  const t = new Uint8Array(e);
  return t.set(n, e - n.length), po(t);
}
function _e(n, e) {
  return !(typeof n != "string" || !n.match(/^0x[0-9A-Fa-f]*$/) || e && n.length !== 2 + 2 * e);
}
const mp = "0123456789abcdef";
function J(n, e) {
  if (e || (e = {}), typeof n == "number") {
    Pt.checkSafeUint53(n, "invalid hexlify value");
    let t = "";
    for (; n; )
      t = mp[n & 15] + t, n = Math.floor(n / 16);
    return t.length ? (t.length % 2 && (t = "0" + t), "0x" + t) : "0x00";
  }
  if (typeof n == "bigint")
    return n = n.toString(16), n.length % 2 ? "0x0" + n : "0x" + n;
  if (e.allowMissingPrefix && typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), X1(n))
    return n.toHexString();
  if (_e(n))
    return n.length % 2 && (e.hexPad === "left" ? n = "0x0" + n.substring(2) : e.hexPad === "right" ? n += "0" : Pt.throwArgumentError("hex data is odd-length", "value", n)), n.toLowerCase();
  if (Da(n)) {
    let t = "0x";
    for (let r = 0; r < n.length; r++) {
      let i = n[r];
      t += mp[(i & 240) >> 4] + mp[i & 15];
    }
    return t;
  }
  return Pt.throwArgumentError("invalid hexlify value", "value", n);
}
function ni(n) {
  if (typeof n != "string")
    n = J(n);
  else if (!_e(n) || n.length % 2)
    return null;
  return (n.length - 2) / 2;
}
function Bt(n, e, t) {
  return typeof n != "string" ? n = J(n) : (!_e(n) || n.length % 2) && Pt.throwArgumentError("invalid hexData", "value", n), e = 2 + 2 * e, t != null ? "0x" + n.substring(e, 2 + 2 * t) : "0x" + n.substring(e);
}
function Sn(n) {
  let e = "0x";
  return n.forEach((t) => {
    e += J(t).substring(2);
  }), e;
}
function rf(n) {
  const e = Z1(J(n, { hexPad: "left" }));
  return e === "0x" ? "0x0" : e;
}
function Z1(n) {
  typeof n != "string" && (n = J(n)), _e(n) || Pt.throwArgumentError("invalid hex string", "value", n), n = n.substring(2);
  let e = 0;
  for (; e < n.length && n[e] === "0"; )
    e++;
  return "0x" + n.substring(e);
}
function Le(n, e) {
  for (typeof n != "string" ? n = J(n) : _e(n) || Pt.throwArgumentError("invalid hex string", "value", n), n.length > 2 * e + 2 && Pt.throwArgumentError("value out of range", "value", arguments[1]); n.length < 2 * e + 2; )
    n = "0x0" + n.substring(2);
  return n;
}
function Ba(n) {
  const e = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (Il(n)) {
    let t = q(n);
    t.length === 64 ? (e.v = 27 + (t[32] >> 7), t[32] &= 127, e.r = J(t.slice(0, 32)), e.s = J(t.slice(32, 64))) : t.length === 65 ? (e.r = J(t.slice(0, 32)), e.s = J(t.slice(32, 64)), e.v = t[64]) : Pt.throwArgumentError("invalid signature string", "signature", n), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : Pt.throwArgumentError("signature invalid v byte", "signature", n)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (t[32] |= 128), e._vs = J(t.slice(32, 64));
  } else {
    if (e.r = n.r, e.s = n.s, e.v = n.v, e.recoveryParam = n.recoveryParam, e._vs = n._vs, e._vs != null) {
      const i = Eu(q(e._vs), 32);
      e._vs = J(i);
      const s = i[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && Pt.throwArgumentError("signature recoveryParam mismatch _vs", "signature", n), i[0] &= 127;
      const a = J(i);
      e.s == null ? e.s = a : e.s !== a && Pt.throwArgumentError("signature v mismatch _vs", "signature", n);
    }
    if (e.recoveryParam == null)
      e.v == null ? Pt.throwArgumentError("signature missing v and recoveryParam", "signature", n) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
    else if (e.v == null)
      e.v = 27 + e.recoveryParam;
    else {
      const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
      e.recoveryParam !== i && Pt.throwArgumentError("signature recoveryParam mismatch v", "signature", n);
    }
    e.r == null || !_e(e.r) ? Pt.throwArgumentError("signature missing or invalid r", "signature", n) : e.r = Le(e.r, 32), e.s == null || !_e(e.s) ? Pt.throwArgumentError("signature missing or invalid s", "signature", n) : e.s = Le(e.s, 32);
    const t = q(e.s);
    t[0] >= 128 && Pt.throwArgumentError("signature s out of range", "signature", n), e.recoveryParam && (t[0] |= 128);
    const r = J(t);
    e._vs && (_e(e._vs) || Pt.throwArgumentError("signature invalid _vs", "signature", n), e._vs = Le(e._vs, 32)), e._vs == null ? e._vs = r : e._vs !== r && Pt.throwArgumentError("signature _vs mismatch v and s", "signature", n);
  }
  return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
}
function Th(n) {
  return n = Ba(n), J(Ge([
    n.r,
    n.s,
    n.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
const nS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayify: q,
  concat: Ge,
  hexConcat: Sn,
  hexDataLength: ni,
  hexDataSlice: Bt,
  hexStripZeros: Z1,
  hexValue: rf,
  hexZeroPad: Le,
  hexlify: J,
  isBytes: Da,
  isBytesLike: Il,
  isHexString: _e,
  joinSignature: Th,
  splitSignature: Ba,
  stripZeros: Qr,
  zeroPad: Eu
}, Symbol.toStringTag, { value: "Module" })), ew = "bignumber/5.7.0";
var Wu = ye.BN;
const yi = new D(ew), bp = {}, Ug = 9007199254740991;
function rS(n) {
  return n != null && (H.isBigNumber(n) || typeof n == "number" && n % 1 === 0 || typeof n == "string" && !!n.match(/^-?[0-9]+$/) || _e(n) || typeof n == "bigint" || Da(n));
}
let jg = !1;
class H {
  constructor(e, t) {
    e !== bp && yi.throwError("cannot call constructor directly; use BigNumber.from", D.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = t, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(e) {
    return Nn(we(this).fromTwos(e));
  }
  toTwos(e) {
    return Nn(we(this).toTwos(e));
  }
  abs() {
    return this._hex[0] === "-" ? H.from(this._hex.substring(1)) : this;
  }
  add(e) {
    return Nn(we(this).add(we(e)));
  }
  sub(e) {
    return Nn(we(this).sub(we(e)));
  }
  div(e) {
    return H.from(e).isZero() && ar("division-by-zero", "div"), Nn(we(this).div(we(e)));
  }
  mul(e) {
    return Nn(we(this).mul(we(e)));
  }
  mod(e) {
    const t = we(e);
    return t.isNeg() && ar("division-by-zero", "mod"), Nn(we(this).umod(t));
  }
  pow(e) {
    const t = we(e);
    return t.isNeg() && ar("negative-power", "pow"), Nn(we(this).pow(t));
  }
  and(e) {
    const t = we(e);
    return (this.isNegative() || t.isNeg()) && ar("unbound-bitwise-result", "and"), Nn(we(this).and(t));
  }
  or(e) {
    const t = we(e);
    return (this.isNegative() || t.isNeg()) && ar("unbound-bitwise-result", "or"), Nn(we(this).or(t));
  }
  xor(e) {
    const t = we(e);
    return (this.isNegative() || t.isNeg()) && ar("unbound-bitwise-result", "xor"), Nn(we(this).xor(t));
  }
  mask(e) {
    return (this.isNegative() || e < 0) && ar("negative-width", "mask"), Nn(we(this).maskn(e));
  }
  shl(e) {
    return (this.isNegative() || e < 0) && ar("negative-width", "shl"), Nn(we(this).shln(e));
  }
  shr(e) {
    return (this.isNegative() || e < 0) && ar("negative-width", "shr"), Nn(we(this).shrn(e));
  }
  eq(e) {
    return we(this).eq(we(e));
  }
  lt(e) {
    return we(this).lt(we(e));
  }
  lte(e) {
    return we(this).lte(we(e));
  }
  gt(e) {
    return we(this).gt(we(e));
  }
  gte(e) {
    return we(this).gte(we(e));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return we(this).isZero();
  }
  toNumber() {
    try {
      return we(this).toNumber();
    } catch {
      ar("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return yi.throwError("this platform does not support BigInt", D.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? jg || (jg = !0, yi.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? yi.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", D.errors.UNEXPECTED_ARGUMENT, {}) : yi.throwError("BigNumber.toString does not accept parameters", D.errors.UNEXPECTED_ARGUMENT, {})), we(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(e) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(e) {
    if (e instanceof H)
      return e;
    if (typeof e == "string")
      return e.match(/^-?0x[0-9a-f]+$/i) ? new H(bp, Ku(e)) : e.match(/^-?[0-9]+$/) ? new H(bp, Ku(new Wu(e))) : yi.throwArgumentError("invalid BigNumber string", "value", e);
    if (typeof e == "number")
      return e % 1 && ar("underflow", "BigNumber.from", e), (e >= Ug || e <= -Ug) && ar("overflow", "BigNumber.from", e), H.from(String(e));
    const t = e;
    if (typeof t == "bigint")
      return H.from(t.toString());
    if (Da(t))
      return H.from(J(t));
    if (t)
      if (t.toHexString) {
        const r = t.toHexString();
        if (typeof r == "string")
          return H.from(r);
      } else {
        let r = t._hex;
        if (r == null && t.type === "BigNumber" && (r = t.hex), typeof r == "string" && (_e(r) || r[0] === "-" && _e(r.substring(1))))
          return H.from(r);
      }
    return yi.throwArgumentError("invalid BigNumber value", "value", e);
  }
  static isBigNumber(e) {
    return !!(e && e._isBigNumber);
  }
}
function Ku(n) {
  if (typeof n != "string")
    return Ku(n.toString(16));
  if (n[0] === "-")
    return n = n.substring(1), n[0] === "-" && yi.throwArgumentError("invalid hex", "value", n), n = Ku(n), n === "0x00" ? n : "-" + n;
  if (n.substring(0, 2) !== "0x" && (n = "0x" + n), n === "0x")
    return "0x00";
  for (n.length % 2 && (n = "0x0" + n.substring(2)); n.length > 4 && n.substring(0, 4) === "0x00"; )
    n = "0x" + n.substring(4);
  return n;
}
function Nn(n) {
  return H.from(Ku(n));
}
function we(n) {
  const e = H.from(n).toHexString();
  return e[0] === "-" ? new Wu("-" + e.substring(3), 16) : new Wu(e.substring(2), 16);
}
function ar(n, e, t) {
  const r = { fault: n, operation: e };
  return t != null && (r.value = t), yi.throwError(n, D.errors.NUMERIC_FAULT, r);
}
function iS(n) {
  return new Wu(n, 36).toString(16);
}
function sS(n) {
  return new Wu(n, 16).toString(36);
}
const Cn = new D(ew), Su = {}, tw = H.from(0), nw = H.from(-1);
function rw(n, e, t, r) {
  const i = { fault: e, operation: t };
  return r !== void 0 && (i.value = r), Cn.throwError(n, D.errors.NUMERIC_FAULT, i);
}
let Cu = "0";
for (; Cu.length < 256; )
  Cu += Cu;
function oy(n) {
  if (typeof n != "number")
    try {
      n = H.from(n).toNumber();
    } catch {
    }
  return typeof n == "number" && n >= 0 && n <= 256 && !(n % 1) ? "1" + Cu.substring(0, n) : Cn.throwArgumentError("invalid decimal size", "decimals", n);
}
function _c(n, e) {
  e == null && (e = 0);
  const t = oy(e);
  n = H.from(n);
  const r = n.lt(tw);
  r && (n = n.mul(nw));
  let i = n.mod(t).toString();
  for (; i.length < t.length - 1; )
    i = "0" + i;
  i = i.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const s = n.div(t).toString();
  return t.length === 1 ? n = s : n = s + "." + i, r && (n = "-" + n), n;
}
function Ur(n, e) {
  e == null && (e = 0);
  const t = oy(e);
  (typeof n != "string" || !n.match(/^-?[0-9.]+$/)) && Cn.throwArgumentError("invalid decimal value", "value", n);
  const r = n.substring(0, 1) === "-";
  r && (n = n.substring(1)), n === "." && Cn.throwArgumentError("missing value", "value", n);
  const i = n.split(".");
  i.length > 2 && Cn.throwArgumentError("too many decimal points", "value", n);
  let s = i[0], a = i[1];
  for (s || (s = "0"), a || (a = "0"); a[a.length - 1] === "0"; )
    a = a.substring(0, a.length - 1);
  for (a.length > t.length - 1 && rw("fractional component exceeds decimals", "underflow", "parseFixed"), a === "" && (a = "0"); a.length < t.length - 1; )
    a += "0";
  const o = H.from(s), u = H.from(a);
  let l = o.mul(t).add(u);
  return r && (l = l.mul(nw)), l;
}
class ho {
  constructor(e, t, r, i) {
    e !== Su && Cn.throwError("cannot use FixedFormat constructor; use FixedFormat.from", D.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.signed = t, this.width = r, this.decimals = i, this.name = (t ? "" : "u") + "fixed" + String(r) + "x" + String(i), this._multiplier = oy(i), Object.freeze(this);
  }
  static from(e) {
    if (e instanceof ho)
      return e;
    typeof e == "number" && (e = `fixed128x${e}`);
    let t = !0, r = 128, i = 18;
    if (typeof e == "string") {
      if (e !== "fixed")
        if (e === "ufixed")
          t = !1;
        else {
          const s = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          s || Cn.throwArgumentError("invalid fixed format", "format", e), t = s[1] !== "u", r = parseInt(s[2]), i = parseInt(s[3]);
        }
    } else if (e) {
      const s = (a, o, u) => e[a] == null ? u : (typeof e[a] !== o && Cn.throwArgumentError("invalid fixed format (" + a + " not " + o + ")", "format." + a, e[a]), e[a]);
      t = s("signed", "boolean", t), r = s("width", "number", r), i = s("decimals", "number", i);
    }
    return r % 8 && Cn.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", r), i > 80 && Cn.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", i), new ho(Su, t, r, i);
  }
}
class sn {
  constructor(e, t, r, i) {
    e !== Su && Cn.throwError("cannot use FixedNumber constructor; use FixedNumber.from", D.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.format = i, this._hex = t, this._value = r, this._isFixedNumber = !0, Object.freeze(this);
  }
  _checkFormat(e) {
    this.format.name !== e.format.name && Cn.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", e);
  }
  addUnsafe(e) {
    this._checkFormat(e);
    const t = Ur(this._value, this.format.decimals), r = Ur(e._value, e.format.decimals);
    return sn.fromValue(t.add(r), this.format.decimals, this.format);
  }
  subUnsafe(e) {
    this._checkFormat(e);
    const t = Ur(this._value, this.format.decimals), r = Ur(e._value, e.format.decimals);
    return sn.fromValue(t.sub(r), this.format.decimals, this.format);
  }
  mulUnsafe(e) {
    this._checkFormat(e);
    const t = Ur(this._value, this.format.decimals), r = Ur(e._value, e.format.decimals);
    return sn.fromValue(t.mul(r).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(e) {
    this._checkFormat(e);
    const t = Ur(this._value, this.format.decimals), r = Ur(e._value, e.format.decimals);
    return sn.fromValue(t.mul(this.format._multiplier).div(r), this.format.decimals, this.format);
  }
  floor() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let t = sn.from(e[0], this.format);
    const r = !e[1].match(/^(0*)$/);
    return this.isNegative() && r && (t = t.subUnsafe(Vg.toFormat(t.format))), t;
  }
  ceiling() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let t = sn.from(e[0], this.format);
    const r = !e[1].match(/^(0*)$/);
    return !this.isNegative() && r && (t = t.addUnsafe(Vg.toFormat(t.format))), t;
  }
  // @TODO: Support other rounding algorithms
  round(e) {
    e == null && (e = 0);
    const t = this.toString().split(".");
    if (t.length === 1 && t.push("0"), (e < 0 || e > 80 || e % 1) && Cn.throwArgumentError("invalid decimal count", "decimals", e), t[1].length <= e)
      return this;
    const r = sn.from("1" + Cu.substring(0, e), this.format), i = aS.toFormat(this.format);
    return this.mulUnsafe(r).addUnsafe(i).floor().divUnsafe(r);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(e) {
    if (e == null)
      return this._hex;
    e % 8 && Cn.throwArgumentError("invalid byte width", "width", e);
    const t = H.from(this._hex).fromTwos(this.format.width).toTwos(e).toHexString();
    return Le(t, e / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(e) {
    return sn.fromString(this._value, e);
  }
  static fromValue(e, t, r) {
    return r == null && t != null && !rS(t) && (r = t, t = null), t == null && (t = 0), r == null && (r = "fixed"), sn.fromString(_c(e, t), ho.from(r));
  }
  static fromString(e, t) {
    t == null && (t = "fixed");
    const r = ho.from(t), i = Ur(e, r.decimals);
    !r.signed && i.lt(tw) && rw("unsigned value cannot be negative", "overflow", "value", e);
    let s = null;
    r.signed ? s = i.toTwos(r.width).toHexString() : (s = i.toHexString(), s = Le(s, r.width / 8));
    const a = _c(i, r.decimals);
    return new sn(Su, s, a, r);
  }
  static fromBytes(e, t) {
    t == null && (t = "fixed");
    const r = ho.from(t);
    if (q(e).length > r.width / 8)
      throw new Error("overflow");
    let i = H.from(e);
    r.signed && (i = i.fromTwos(r.width));
    const s = i.toTwos((r.signed ? 0 : 1) + r.width).toHexString(), a = _c(i, r.decimals);
    return new sn(Su, s, a, r);
  }
  static from(e, t) {
    if (typeof e == "string")
      return sn.fromString(e, t);
    if (Da(e))
      return sn.fromBytes(e, t);
    try {
      return sn.fromValue(e, 0, t);
    } catch (r) {
      if (r.code !== D.errors.INVALID_ARGUMENT)
        throw r;
    }
    return Cn.throwArgumentError("invalid FixedNumber value", "value", e);
  }
  static isFixedNumber(e) {
    return !!(e && e._isFixedNumber);
  }
}
const Vg = sn.from(1), aS = sn.from("0.5"), oS = "properties/5.7.0";
var uS = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const ld = new D(oS);
function j(n, e, t) {
  Object.defineProperty(n, e, {
    enumerable: !0,
    value: t,
    writable: !1
  });
}
function Rr(n, e) {
  for (let t = 0; t < 32; t++) {
    if (n[e])
      return n[e];
    if (!n.prototype || typeof n.prototype != "object")
      break;
    n = Object.getPrototypeOf(n.prototype).constructor;
  }
  return null;
}
function Rt(n) {
  return uS(this, void 0, void 0, function* () {
    const e = Object.keys(n).map((r) => {
      const i = n[r];
      return Promise.resolve(i).then((s) => ({ key: r, value: s }));
    });
    return (yield Promise.all(e)).reduce((r, i) => (r[i.key] = i.value, r), {});
  });
}
function uy(n, e) {
  (!n || typeof n != "object") && ld.throwArgumentError("invalid object", "object", n), Object.keys(n).forEach((t) => {
    e[t] || ld.throwArgumentError("invalid object key - " + t, "transaction:" + t, n);
  });
}
function zt(n) {
  const e = {};
  for (const t in n)
    e[t] = n[t];
  return e;
}
const lS = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function iw(n) {
  if (n == null || lS[typeof n])
    return !0;
  if (Array.isArray(n) || typeof n == "object") {
    if (!Object.isFrozen(n))
      return !1;
    const e = Object.keys(n);
    for (let t = 0; t < e.length; t++) {
      let r = null;
      try {
        r = n[e[t]];
      } catch {
        continue;
      }
      if (!iw(r))
        return !1;
    }
    return !0;
  }
  return ld.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n);
}
function cS(n) {
  if (iw(n))
    return n;
  if (Array.isArray(n))
    return Object.freeze(n.map((e) => xs(e)));
  if (typeof n == "object") {
    const e = {};
    for (const t in n) {
      const r = n[t];
      r !== void 0 && j(e, t, xs(r));
    }
    return e;
  }
  return ld.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n);
}
function xs(n) {
  return cS(n);
}
class Ms {
  constructor(e) {
    for (const t in e)
      this[t] = xs(e[t]);
  }
}
const dS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Description: Ms,
  checkProperties: uy,
  deepCopy: xs,
  defineReadOnly: j,
  getStatic: Rr,
  resolveProperties: Rt,
  shallowCopy: zt
}, Symbol.toStringTag, { value: "Module" })), Ol = "abi/5.7.0", Se = new D(Ol), ma = {};
let zg = { calldata: !0, memory: !0, storage: !0 }, fS = { calldata: !0, memory: !0 };
function ic(n, e) {
  if (n === "bytes" || n === "string") {
    if (zg[e])
      return !0;
  } else if (n === "address") {
    if (e === "payable")
      return !0;
  } else if ((n.indexOf("[") >= 0 || n === "tuple") && fS[e])
    return !0;
  return (zg[e] || e === "payable") && Se.throwArgumentError("invalid modifier", "name", e), !1;
}
function pS(n, e) {
  let t = n;
  function r(o) {
    Se.throwArgumentError(`unexpected character at position ${o}`, "param", n);
  }
  n = n.replace(/\s/g, " ");
  function i(o) {
    let u = { type: "", name: "", parent: o, state: { allowType: !0 } };
    return e && (u.indexed = !1), u;
  }
  let s = { type: "", name: "", state: { allowType: !0 } }, a = s;
  for (let o = 0; o < n.length; o++) {
    let u = n[o];
    switch (u) {
      case "(":
        a.state.allowType && a.type === "" ? a.type = "tuple" : a.state.allowParams || r(o), a.state.allowType = !1, a.type = Ya(a.type), a.components = [i(a)], a = a.components[0];
        break;
      case ")":
        delete a.state, a.name === "indexed" && (e || r(o), a.indexed = !0, a.name = ""), ic(a.type, a.name) && (a.name = ""), a.type = Ya(a.type);
        let l = a;
        a = a.parent, a || r(o), delete l.parent, a.state.allowParams = !1, a.state.allowName = !0, a.state.allowArray = !0;
        break;
      case ",":
        delete a.state, a.name === "indexed" && (e || r(o), a.indexed = !0, a.name = ""), ic(a.type, a.name) && (a.name = ""), a.type = Ya(a.type);
        let d = i(a.parent);
        a.parent.components.push(d), delete a.parent, a = d;
        break;
      case " ":
        a.state.allowType && a.type !== "" && (a.type = Ya(a.type), delete a.state.allowType, a.state.allowName = !0, a.state.allowParams = !0), a.state.allowName && a.name !== "" && (a.name === "indexed" ? (e || r(o), a.indexed && r(o), a.indexed = !0, a.name = "") : ic(a.type, a.name) ? a.name = "" : a.state.allowName = !1);
        break;
      case "[":
        a.state.allowArray || r(o), a.type += u, a.state.allowArray = !1, a.state.allowName = !1, a.state.readArray = !0;
        break;
      case "]":
        a.state.readArray || r(o), a.type += u, a.state.readArray = !1, a.state.allowArray = !0, a.state.allowName = !0;
        break;
      default:
        a.state.allowType ? (a.type += u, a.state.allowParams = !0, a.state.allowArray = !0) : a.state.allowName ? (a.name += u, delete a.state.allowArray) : a.state.readArray ? a.type += u : r(o);
    }
  }
  return a.parent && Se.throwArgumentError("unexpected eof", "param", n), delete s.state, a.name === "indexed" ? (e || r(t.length - 7), a.indexed && r(t.length - 7), a.indexed = !0, a.name = "") : ic(a.type, a.name) && (a.name = ""), s.type = Ya(s.type), s;
}
function Mc(n, e) {
  for (let t in e)
    j(n, t, e[t]);
}
const Ie = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
}), hS = new RegExp(/^(.*)\[([0-9]*)\]$/);
class Wt {
  constructor(e, t) {
    e !== ma && Se.throwError("use fromString", D.errors.UNSUPPORTED_OPERATION, {
      operation: "new ParamType()"
    }), Mc(this, t);
    let r = this.type.match(hS);
    r ? Mc(this, {
      arrayLength: parseInt(r[2] || "-1"),
      arrayChildren: Wt.fromObject({
        type: r[1],
        components: this.components
      }),
      baseType: "array"
    }) : Mc(this, {
      arrayLength: null,
      arrayChildren: null,
      baseType: this.components != null ? "tuple" : this.type
    }), this._isParamType = !0, Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(e) {
    if (e || (e = Ie.sighash), Ie[e] || Se.throwArgumentError("invalid format type", "format", e), e === Ie.json) {
      let r = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      return typeof this.indexed == "boolean" && (r.indexed = this.indexed), this.components && (r.components = this.components.map((i) => JSON.parse(i.format(e)))), JSON.stringify(r);
    }
    let t = "";
    return this.baseType === "array" ? (t += this.arrayChildren.format(e), t += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (e !== Ie.sighash && (t += this.type), t += "(" + this.components.map((r) => r.format(e)).join(e === Ie.full ? ", " : ",") + ")") : t += this.type, e !== Ie.sighash && (this.indexed === !0 && (t += " indexed"), e === Ie.full && this.name && (t += " " + this.name)), t;
  }
  static from(e, t) {
    return typeof e == "string" ? Wt.fromString(e, t) : Wt.fromObject(e);
  }
  static fromObject(e) {
    return Wt.isParamType(e) ? e : new Wt(ma, {
      name: e.name || null,
      type: Ya(e.type),
      indexed: e.indexed == null ? null : !!e.indexed,
      components: e.components ? e.components.map(Wt.fromObject) : null
    });
  }
  static fromString(e, t) {
    function r(i) {
      return Wt.fromObject({
        name: i.name,
        type: i.type,
        indexed: i.indexed,
        components: i.components
      });
    }
    return r(pS(e, !!t));
  }
  static isParamType(e) {
    return !!(e != null && e._isParamType);
  }
}
function Ju(n, e) {
  return mS(n).map((t) => Wt.fromString(t, e));
}
class Wr {
  constructor(e, t) {
    e !== ma && Se.throwError("use a static from method", D.errors.UNSUPPORTED_OPERATION, {
      operation: "new Fragment()"
    }), Mc(this, t), this._isFragment = !0, Object.freeze(this);
  }
  static from(e) {
    return Wr.isFragment(e) ? e : typeof e == "string" ? Wr.fromString(e) : Wr.fromObject(e);
  }
  static fromObject(e) {
    if (Wr.isFragment(e))
      return e;
    switch (e.type) {
      case "function":
        return _r.fromObject(e);
      case "event":
        return qr.fromObject(e);
      case "constructor":
        return Cr.fromObject(e);
      case "error":
        return wi.fromObject(e);
      case "fallback":
      case "receive":
        return null;
    }
    return Se.throwArgumentError("invalid fragment object", "value", e);
  }
  static fromString(e) {
    return e = e.replace(/\s/g, " "), e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), e = e.trim(), e.split(" ")[0] === "event" ? qr.fromString(e.substring(5).trim()) : e.split(" ")[0] === "function" ? _r.fromString(e.substring(8).trim()) : e.split("(")[0].trim() === "constructor" ? Cr.fromString(e.trim()) : e.split(" ")[0] === "error" ? wi.fromString(e.substring(5).trim()) : Se.throwArgumentError("unsupported fragment", "value", e);
  }
  static isFragment(e) {
    return !!(e && e._isFragment);
  }
}
class qr extends Wr {
  format(e) {
    if (e || (e = Ie.sighash), Ie[e] || Se.throwArgumentError("invalid format type", "format", e), e === Ie.json)
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
    let t = "";
    return e !== Ie.sighash && (t += "event "), t += this.name + "(" + this.inputs.map((r) => r.format(e)).join(e === Ie.full ? ", " : ",") + ") ", e !== Ie.sighash && this.anonymous && (t += "anonymous "), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? qr.fromString(e) : qr.fromObject(e);
  }
  static fromObject(e) {
    if (qr.isEventFragment(e))
      return e;
    e.type !== "event" && Se.throwArgumentError("invalid event object", "value", e);
    const t = {
      name: Qu(e.name),
      anonymous: e.anonymous,
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
      type: "event"
    };
    return new qr(ma, t);
  }
  static fromString(e) {
    let t = e.match(Yu);
    t || Se.throwArgumentError("invalid event string", "value", e);
    let r = !1;
    return t[3].split(" ").forEach((i) => {
      switch (i.trim()) {
        case "anonymous":
          r = !0;
          break;
        case "":
          break;
        default:
          Se.warn("unknown modifier: " + i);
      }
    }), qr.fromObject({
      name: t[1].trim(),
      anonymous: r,
      inputs: Ju(t[2], !0),
      type: "event"
    });
  }
  static isEventFragment(e) {
    return e && e._isFragment && e.type === "event";
  }
}
function sw(n, e) {
  e.gas = null;
  let t = n.split("@");
  return t.length !== 1 ? (t.length > 2 && Se.throwArgumentError("invalid human-readable ABI signature", "value", n), t[1].match(/^[0-9]+$/) || Se.throwArgumentError("invalid human-readable ABI signature gas", "value", n), e.gas = H.from(t[1]), t[0]) : n;
}
function aw(n, e) {
  e.constant = !1, e.payable = !1, e.stateMutability = "nonpayable", n.split(" ").forEach((t) => {
    switch (t.trim()) {
      case "constant":
        e.constant = !0;
        break;
      case "payable":
        e.payable = !0, e.stateMutability = "payable";
        break;
      case "nonpayable":
        e.payable = !1, e.stateMutability = "nonpayable";
        break;
      case "pure":
        e.constant = !0, e.stateMutability = "pure";
        break;
      case "view":
        e.constant = !0, e.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + t);
    }
  });
}
function ow(n) {
  let e = {
    constant: !1,
    payable: !0,
    stateMutability: "payable"
  };
  return n.stateMutability != null ? (e.stateMutability = n.stateMutability, e.constant = e.stateMutability === "view" || e.stateMutability === "pure", n.constant != null && !!n.constant !== e.constant && Se.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", n), e.payable = e.stateMutability === "payable", n.payable != null && !!n.payable !== e.payable && Se.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", n)) : n.payable != null ? (e.payable = !!n.payable, n.constant == null && !e.payable && n.type !== "constructor" && Se.throwArgumentError("unable to determine stateMutability", "value", n), e.constant = !!n.constant, e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable", e.payable && e.constant && Se.throwArgumentError("cannot have constant payable function", "value", n)) : n.constant != null ? (e.constant = !!n.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : n.type !== "constructor" && Se.throwArgumentError("unable to determine stateMutability", "value", n), e;
}
class Cr extends Wr {
  format(e) {
    if (e || (e = Ie.sighash), Ie[e] || Se.throwArgumentError("invalid format type", "format", e), e === Ie.json)
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
    e === Ie.sighash && Se.throwError("cannot format a constructor for sighash", D.errors.UNSUPPORTED_OPERATION, {
      operation: "format(sighash)"
    });
    let t = "constructor(" + this.inputs.map((r) => r.format(e)).join(e === Ie.full ? ", " : ",") + ") ";
    return this.stateMutability && this.stateMutability !== "nonpayable" && (t += this.stateMutability + " "), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? Cr.fromString(e) : Cr.fromObject(e);
  }
  static fromObject(e) {
    if (Cr.isConstructorFragment(e))
      return e;
    e.type !== "constructor" && Se.throwArgumentError("invalid constructor object", "value", e);
    let t = ow(e);
    t.constant && Se.throwArgumentError("constructor cannot be constant", "value", e);
    const r = {
      name: null,
      type: e.type,
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? H.from(e.gas) : null
    };
    return new Cr(ma, r);
  }
  static fromString(e) {
    let t = { type: "constructor" };
    e = sw(e, t);
    let r = e.match(Yu);
    return (!r || r[1].trim() !== "constructor") && Se.throwArgumentError("invalid constructor string", "value", e), t.inputs = Ju(r[2].trim(), !1), aw(r[3].trim(), t), Cr.fromObject(t);
  }
  static isConstructorFragment(e) {
    return e && e._isFragment && e.type === "constructor";
  }
}
class _r extends Cr {
  format(e) {
    if (e || (e = Ie.sighash), Ie[e] || Se.throwArgumentError("invalid format type", "format", e), e === Ie.json)
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        outputs: this.outputs.map((r) => JSON.parse(r.format(e)))
      });
    let t = "";
    return e !== Ie.sighash && (t += "function "), t += this.name + "(" + this.inputs.map((r) => r.format(e)).join(e === Ie.full ? ", " : ",") + ") ", e !== Ie.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (t += this.stateMutability + " ") : this.constant && (t += "view "), this.outputs && this.outputs.length && (t += "returns (" + this.outputs.map((r) => r.format(e)).join(", ") + ") "), this.gas != null && (t += "@" + this.gas.toString() + " ")), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? _r.fromString(e) : _r.fromObject(e);
  }
  static fromObject(e) {
    if (_r.isFunctionFragment(e))
      return e;
    e.type !== "function" && Se.throwArgumentError("invalid function object", "value", e);
    let t = ow(e);
    const r = {
      type: e.type,
      name: Qu(e.name),
      constant: t.constant,
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
      outputs: e.outputs ? e.outputs.map(Wt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? H.from(e.gas) : null
    };
    return new _r(ma, r);
  }
  static fromString(e) {
    let t = { type: "function" };
    e = sw(e, t);
    let r = e.split(" returns ");
    r.length > 2 && Se.throwArgumentError("invalid function string", "value", e);
    let i = r[0].match(Yu);
    if (i || Se.throwArgumentError("invalid function signature", "value", e), t.name = i[1].trim(), t.name && Qu(t.name), t.inputs = Ju(i[2], !1), aw(i[3].trim(), t), r.length > 1) {
      let s = r[1].match(Yu);
      (s[1].trim() != "" || s[3].trim() != "") && Se.throwArgumentError("unexpected tokens", "value", e), t.outputs = Ju(s[2], !1);
    } else
      t.outputs = [];
    return _r.fromObject(t);
  }
  static isFunctionFragment(e) {
    return e && e._isFragment && e.type === "function";
  }
}
function Gg(n) {
  const e = n.format();
  return (e === "Error(string)" || e === "Panic(uint256)") && Se.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", n), n;
}
class wi extends Wr {
  format(e) {
    if (e || (e = Ie.sighash), Ie[e] || Se.throwArgumentError("invalid format type", "format", e), e === Ie.json)
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
    let t = "";
    return e !== Ie.sighash && (t += "error "), t += this.name + "(" + this.inputs.map((r) => r.format(e)).join(e === Ie.full ? ", " : ",") + ") ", t.trim();
  }
  static from(e) {
    return typeof e == "string" ? wi.fromString(e) : wi.fromObject(e);
  }
  static fromObject(e) {
    if (wi.isErrorFragment(e))
      return e;
    e.type !== "error" && Se.throwArgumentError("invalid error object", "value", e);
    const t = {
      type: e.type,
      name: Qu(e.name),
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : []
    };
    return Gg(new wi(ma, t));
  }
  static fromString(e) {
    let t = { type: "error" }, r = e.match(Yu);
    return r || Se.throwArgumentError("invalid error signature", "value", e), t.name = r[1].trim(), t.name && Qu(t.name), t.inputs = Ju(r[2], !1), Gg(wi.fromObject(t));
  }
  static isErrorFragment(e) {
    return e && e._isFragment && e.type === "error";
  }
}
function Ya(n) {
  return n.match(/^uint($|[^1-9])/) ? n = "uint256" + n.substring(4) : n.match(/^int($|[^1-9])/) && (n = "int256" + n.substring(3)), n;
}
const yS = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function Qu(n) {
  return (!n || !n.match(yS)) && Se.throwArgumentError(`invalid identifier "${n}"`, "value", n), n;
}
const Yu = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function mS(n) {
  n = n.trim();
  let e = [], t = "", r = 0;
  for (let i = 0; i < n.length; i++) {
    let s = n[i];
    s === "," && r === 0 ? (e.push(t), t = "") : (t += s, s === "(" ? r++ : s === ")" && (r--, r === -1 && Se.throwArgumentError("unbalanced parenthesis", "value", n)));
  }
  return t && e.push(t), e;
}
const ly = new D(Ol);
function uw(n) {
  const e = [], t = function(r, i) {
    if (Array.isArray(i))
      for (let s in i) {
        const a = r.slice();
        a.push(s);
        try {
          t(a, i[s]);
        } catch (o) {
          e.push({ path: a, error: o });
        }
      }
  };
  return t([], n), e;
}
class Hi {
  constructor(e, t, r, i) {
    this.name = e, this.type = t, this.localName = r, this.dynamic = i;
  }
  _throwError(e, t) {
    ly.throwArgumentError(e, this.localName, t);
  }
}
class Ah {
  constructor(e) {
    j(this, "wordSize", e || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(e);
  }
  get data() {
    return Sn(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(e) {
    return this._data.push(e), this._dataLength += e.length, e.length;
  }
  appendWriter(e) {
    return this._writeData(Ge(e._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(e) {
    let t = q(e);
    const r = t.length % this.wordSize;
    return r && (t = Ge([t, this._padding.slice(r)])), this._writeData(t);
  }
  _getValue(e) {
    let t = q(H.from(e));
    return t.length > this.wordSize && ly.throwError("value out-of-bounds", D.errors.BUFFER_OVERRUN, {
      length: this.wordSize,
      offset: t.length
    }), t.length % this.wordSize && (t = Ge([this._padding.slice(t.length % this.wordSize), t])), t;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(e) {
    return this._writeData(this._getValue(e));
  }
  writeUpdatableValue() {
    const e = this._data.length;
    return this._data.push(this._padding), this._dataLength += this.wordSize, (t) => {
      this._data[e] = this._getValue(t);
    };
  }
}
class cd {
  constructor(e, t, r, i) {
    j(this, "_data", q(e)), j(this, "wordSize", t || 32), j(this, "_coerceFunc", r), j(this, "allowLoose", i), this._offset = 0;
  }
  get data() {
    return J(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(e, t) {
    let r = e.match("^u?int([0-9]+)$");
    return r && parseInt(r[1]) <= 48 && (t = t.toNumber()), t;
  }
  coerce(e, t) {
    return this._coerceFunc ? this._coerceFunc(e, t) : cd.coerce(e, t);
  }
  _peekBytes(e, t, r) {
    let i = Math.ceil(t / this.wordSize) * this.wordSize;
    return this._offset + i > this._data.length && (this.allowLoose && r && this._offset + t <= this._data.length ? i = t : ly.throwError("data out-of-bounds", D.errors.BUFFER_OVERRUN, {
      length: this._data.length,
      offset: this._offset + i
    })), this._data.slice(this._offset, this._offset + i);
  }
  subReader(e) {
    return new cd(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(e, t) {
    let r = this._peekBytes(0, e, !!t);
    return this._offset += r.length, r.slice(0, e);
  }
  readValue() {
    return H.from(this.readBytes(this.wordSize));
  }
}
const ba = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
function lw() {
  throw new Error("setTimeout has not been defined");
}
function cw() {
  throw new Error("clearTimeout has not been defined");
}
var rs = lw, is = cw;
typeof ba.setTimeout == "function" && (rs = setTimeout);
typeof ba.clearTimeout == "function" && (is = clearTimeout);
function dw(n) {
  if (rs === setTimeout)
    return setTimeout(n, 0);
  if ((rs === lw || !rs) && setTimeout)
    return rs = setTimeout, setTimeout(n, 0);
  try {
    return rs(n, 0);
  } catch {
    try {
      return rs.call(null, n, 0);
    } catch {
      return rs.call(this, n, 0);
    }
  }
}
function bS(n) {
  if (is === clearTimeout)
    return clearTimeout(n);
  if ((is === cw || !is) && clearTimeout)
    return is = clearTimeout, clearTimeout(n);
  try {
    return is(n);
  } catch {
    try {
      return is.call(null, n);
    } catch {
      return is.call(this, n);
    }
  }
}
var Ti = [], yo = !1, sa, Pc = -1;
function gS() {
  !yo || !sa || (yo = !1, sa.length ? Ti = sa.concat(Ti) : Pc = -1, Ti.length && fw());
}
function fw() {
  if (!yo) {
    var n = dw(gS);
    yo = !0;
    for (var e = Ti.length; e; ) {
      for (sa = Ti, Ti = []; ++Pc < e; )
        sa && sa[Pc].run();
      Pc = -1, e = Ti.length;
    }
    sa = null, yo = !1, bS(n);
  }
}
function xS(n) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
  Ti.push(new pw(n, e)), Ti.length === 1 && !yo && dw(fw);
}
function pw(n, e) {
  this.fun = n, this.array = e;
}
pw.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var vS = "browser", wS = "browser", TS = !0, AS = {}, ES = [], SS = "", CS = {}, _S = {}, MS = {};
function Fa() {
}
var PS = Fa, RS = Fa, IS = Fa, OS = Fa, kS = Fa, NS = Fa, DS = Fa;
function BS(n) {
  throw new Error("process.binding is not supported");
}
function FS() {
  return "/";
}
function LS(n) {
  throw new Error("process.chdir is not supported");
}
function $S() {
  return 0;
}
var Xa = ba.performance || {}, US = Xa.now || Xa.mozNow || Xa.msNow || Xa.oNow || Xa.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function jS(n) {
  var e = US.call(Xa) * 1e-3, t = Math.floor(e), r = Math.floor(e % 1 * 1e9);
  return n && (t = t - n[0], r = r - n[1], r < 0 && (t--, r += 1e9)), [t, r];
}
var VS = /* @__PURE__ */ new Date();
function zS() {
  var n = /* @__PURE__ */ new Date(), e = n - VS;
  return e / 1e3;
}
var Rc = {
  nextTick: xS,
  title: vS,
  browser: TS,
  env: AS,
  argv: ES,
  version: SS,
  versions: CS,
  on: PS,
  addListener: RS,
  once: IS,
  off: OS,
  removeListener: kS,
  removeAllListeners: NS,
  emit: DS,
  binding: BS,
  cwd: FS,
  chdir: LS,
  umask: $S,
  hrtime: jS,
  platform: wS,
  release: _S,
  config: MS,
  uptime: zS
}, hw = { exports: {} };
(function(n) {
  (function() {
    var e = "input is invalid type", t = "finalize already called", r = typeof window == "object", i = r ? window : {};
    i.JS_SHA3_NO_WINDOW && (r = !1);
    var s = !r && typeof self == "object", a = !i.JS_SHA3_NO_NODE_JS && typeof Rc == "object" && Rc.versions && Rc.versions.node;
    a ? i = bi : s && (i = self);
    var o = !i.JS_SHA3_NO_COMMON_JS && !0 && n.exports, u = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", l = "0123456789abcdef".split(""), d = [31, 7936, 2031616, 520093696], p = [4, 1024, 262144, 67108864], m = [1, 256, 65536, 16777216], w = [6, 1536, 393216, 100663296], x = [0, 8, 16, 24], T = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], A = [224, 256, 384, 512], M = [128, 256], I = ["hex", "buffer", "arrayBuffer", "array", "digest"], B = {
      128: 168,
      256: 136
    };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(y) {
      return Object.prototype.toString.call(y) === "[object Array]";
    }), u && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(y) {
      return typeof y == "object" && y.buffer && y.buffer.constructor === ArrayBuffer;
    });
    for (var k = function(y, R, L) {
      return function(F) {
        return new f(y, R, y).update(F)[L]();
      };
    }, N = function(y, R, L) {
      return function(F, $) {
        return new f(y, R, $).update(F)[L]();
      };
    }, U = function(y, R, L) {
      return function(F, $, te, Q) {
        return c["cshake" + y].update(F, $, te, Q)[L]();
      };
    }, W = function(y, R, L) {
      return function(F, $, te, Q) {
        return c["kmac" + y].update(F, $, te, Q)[L]();
      };
    }, G = function(y, R, L, F) {
      for (var $ = 0; $ < I.length; ++$) {
        var te = I[$];
        y[te] = R(L, F, te);
      }
      return y;
    }, Y = function(y, R) {
      var L = k(y, R, "hex");
      return L.create = function() {
        return new f(y, R, y);
      }, L.update = function(F) {
        return L.create().update(F);
      }, G(L, k, y, R);
    }, ue = function(y, R) {
      var L = N(y, R, "hex");
      return L.create = function(F) {
        return new f(y, R, F);
      }, L.update = function(F, $) {
        return L.create($).update(F);
      }, G(L, N, y, R);
    }, K = function(y, R) {
      var L = B[y], F = U(y, R, "hex");
      return F.create = function($, te, Q) {
        return !te && !Q ? c["shake" + y].create($) : new f(y, R, $).bytepad([te, Q], L);
      }, F.update = function($, te, Q, X) {
        return F.create(te, Q, X).update($);
      }, G(F, U, y, R);
    }, le = function(y, R) {
      var L = B[y], F = W(y, R, "hex");
      return F.create = function($, te, Q) {
        return new v(y, R, te).bytepad(["KMAC", Q], L).bytepad([$], L);
      }, F.update = function($, te, Q, X) {
        return F.create($, Q, X).update(te);
      }, G(F, W, y, R);
    }, C = [
      { name: "keccak", padding: m, bits: A, createMethod: Y },
      { name: "sha3", padding: w, bits: A, createMethod: Y },
      { name: "shake", padding: d, bits: M, createMethod: ue },
      { name: "cshake", padding: p, bits: M, createMethod: K },
      { name: "kmac", padding: p, bits: M, createMethod: le }
    ], c = {}, h = [], g = 0; g < C.length; ++g)
      for (var E = C[g], S = E.bits, _ = 0; _ < S.length; ++_) {
        var P = E.name + "_" + S[_];
        if (h.push(P), c[P] = E.createMethod(S[_], E.padding), E.name !== "sha3") {
          var b = E.name + S[_];
          h.push(b), c[b] = c[P];
        }
      }
    function f(y, R, L) {
      this.blocks = [], this.s = [], this.padding = R, this.outputBits = L, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (y << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = L >> 5, this.extraBytes = (L & 31) >> 3;
      for (var F = 0; F < 50; ++F)
        this.s[F] = 0;
    }
    f.prototype.update = function(y) {
      if (this.finalized)
        throw new Error(t);
      var R, L = typeof y;
      if (L !== "string") {
        if (L === "object") {
          if (y === null)
            throw new Error(e);
          if (u && y.constructor === ArrayBuffer)
            y = new Uint8Array(y);
          else if (!Array.isArray(y) && (!u || !ArrayBuffer.isView(y)))
            throw new Error(e);
        } else
          throw new Error(e);
        R = !0;
      }
      for (var F = this.blocks, $ = this.byteCount, te = y.length, Q = this.blockCount, X = 0, St = this.s, ne, he; X < te; ) {
        if (this.reset)
          for (this.reset = !1, F[0] = this.block, ne = 1; ne < Q + 1; ++ne)
            F[ne] = 0;
        if (R)
          for (ne = this.start; X < te && ne < $; ++X)
            F[ne >> 2] |= y[X] << x[ne++ & 3];
        else
          for (ne = this.start; X < te && ne < $; ++X)
            he = y.charCodeAt(X), he < 128 ? F[ne >> 2] |= he << x[ne++ & 3] : he < 2048 ? (F[ne >> 2] |= (192 | he >> 6) << x[ne++ & 3], F[ne >> 2] |= (128 | he & 63) << x[ne++ & 3]) : he < 55296 || he >= 57344 ? (F[ne >> 2] |= (224 | he >> 12) << x[ne++ & 3], F[ne >> 2] |= (128 | he >> 6 & 63) << x[ne++ & 3], F[ne >> 2] |= (128 | he & 63) << x[ne++ & 3]) : (he = 65536 + ((he & 1023) << 10 | y.charCodeAt(++X) & 1023), F[ne >> 2] |= (240 | he >> 18) << x[ne++ & 3], F[ne >> 2] |= (128 | he >> 12 & 63) << x[ne++ & 3], F[ne >> 2] |= (128 | he >> 6 & 63) << x[ne++ & 3], F[ne >> 2] |= (128 | he & 63) << x[ne++ & 3]);
        if (this.lastByteIndex = ne, ne >= $) {
          for (this.start = ne - $, this.block = F[Q], ne = 0; ne < Q; ++ne)
            St[ne] ^= F[ne];
          O(St), this.reset = !0;
        } else
          this.start = ne;
      }
      return this;
    }, f.prototype.encode = function(y, R) {
      var L = y & 255, F = 1, $ = [L];
      for (y = y >> 8, L = y & 255; L > 0; )
        $.unshift(L), y = y >> 8, L = y & 255, ++F;
      return R ? $.push(F) : $.unshift(F), this.update($), $.length;
    }, f.prototype.encodeString = function(y) {
      var R, L = typeof y;
      if (L !== "string") {
        if (L === "object") {
          if (y === null)
            throw new Error(e);
          if (u && y.constructor === ArrayBuffer)
            y = new Uint8Array(y);
          else if (!Array.isArray(y) && (!u || !ArrayBuffer.isView(y)))
            throw new Error(e);
        } else
          throw new Error(e);
        R = !0;
      }
      var F = 0, $ = y.length;
      if (R)
        F = $;
      else
        for (var te = 0; te < y.length; ++te) {
          var Q = y.charCodeAt(te);
          Q < 128 ? F += 1 : Q < 2048 ? F += 2 : Q < 55296 || Q >= 57344 ? F += 3 : (Q = 65536 + ((Q & 1023) << 10 | y.charCodeAt(++te) & 1023), F += 4);
        }
      return F += this.encode(F * 8), this.update(y), F;
    }, f.prototype.bytepad = function(y, R) {
      for (var L = this.encode(R), F = 0; F < y.length; ++F)
        L += this.encodeString(y[F]);
      var $ = R - L % R, te = [];
      return te.length = $, this.update(te), this;
    }, f.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var y = this.blocks, R = this.lastByteIndex, L = this.blockCount, F = this.s;
        if (y[R >> 2] |= this.padding[R & 3], this.lastByteIndex === this.byteCount)
          for (y[0] = y[L], R = 1; R < L + 1; ++R)
            y[R] = 0;
        for (y[L - 1] |= 2147483648, R = 0; R < L; ++R)
          F[R] ^= y[R];
        O(F);
      }
    }, f.prototype.toString = f.prototype.hex = function() {
      this.finalize();
      for (var y = this.blockCount, R = this.s, L = this.outputBlocks, F = this.extraBytes, $ = 0, te = 0, Q = "", X; te < L; ) {
        for ($ = 0; $ < y && te < L; ++$, ++te)
          X = R[$], Q += l[X >> 4 & 15] + l[X & 15] + l[X >> 12 & 15] + l[X >> 8 & 15] + l[X >> 20 & 15] + l[X >> 16 & 15] + l[X >> 28 & 15] + l[X >> 24 & 15];
        te % y === 0 && (O(R), $ = 0);
      }
      return F && (X = R[$], Q += l[X >> 4 & 15] + l[X & 15], F > 1 && (Q += l[X >> 12 & 15] + l[X >> 8 & 15]), F > 2 && (Q += l[X >> 20 & 15] + l[X >> 16 & 15])), Q;
    }, f.prototype.arrayBuffer = function() {
      this.finalize();
      var y = this.blockCount, R = this.s, L = this.outputBlocks, F = this.extraBytes, $ = 0, te = 0, Q = this.outputBits >> 3, X;
      F ? X = new ArrayBuffer(L + 1 << 2) : X = new ArrayBuffer(Q);
      for (var St = new Uint32Array(X); te < L; ) {
        for ($ = 0; $ < y && te < L; ++$, ++te)
          St[te] = R[$];
        te % y === 0 && O(R);
      }
      return F && (St[$] = R[$], X = X.slice(0, Q)), X;
    }, f.prototype.buffer = f.prototype.arrayBuffer, f.prototype.digest = f.prototype.array = function() {
      this.finalize();
      for (var y = this.blockCount, R = this.s, L = this.outputBlocks, F = this.extraBytes, $ = 0, te = 0, Q = [], X, St; te < L; ) {
        for ($ = 0; $ < y && te < L; ++$, ++te)
          X = te << 2, St = R[$], Q[X] = St & 255, Q[X + 1] = St >> 8 & 255, Q[X + 2] = St >> 16 & 255, Q[X + 3] = St >> 24 & 255;
        te % y === 0 && O(R);
      }
      return F && (X = te << 2, St = R[$], Q[X] = St & 255, F > 1 && (Q[X + 1] = St >> 8 & 255), F > 2 && (Q[X + 2] = St >> 16 & 255)), Q;
    };
    function v(y, R, L) {
      f.call(this, y, R, L);
    }
    v.prototype = new f(), v.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), f.prototype.finalize.call(this);
    };
    var O = function(y) {
      var R, L, F, $, te, Q, X, St, ne, he, Os, He, qe, ks, We, Ke, Ns, Je, Qe, Ds, Ye, Xe, Bs, Ze, et, Fs, tt, nt, Ls, rt, it, $s, st, at, Us, ot, ut, js, lt, ct, Vs, dt, ft, zs, pt, ht, Gs, yt, mt, Hs, bt, gt, qs, xt, vt, Ws, wt, Tt, Ki, Ji, Qi, Yi, Xi;
      for (F = 0; F < 48; F += 2)
        $ = y[0] ^ y[10] ^ y[20] ^ y[30] ^ y[40], te = y[1] ^ y[11] ^ y[21] ^ y[31] ^ y[41], Q = y[2] ^ y[12] ^ y[22] ^ y[32] ^ y[42], X = y[3] ^ y[13] ^ y[23] ^ y[33] ^ y[43], St = y[4] ^ y[14] ^ y[24] ^ y[34] ^ y[44], ne = y[5] ^ y[15] ^ y[25] ^ y[35] ^ y[45], he = y[6] ^ y[16] ^ y[26] ^ y[36] ^ y[46], Os = y[7] ^ y[17] ^ y[27] ^ y[37] ^ y[47], He = y[8] ^ y[18] ^ y[28] ^ y[38] ^ y[48], qe = y[9] ^ y[19] ^ y[29] ^ y[39] ^ y[49], R = He ^ (Q << 1 | X >>> 31), L = qe ^ (X << 1 | Q >>> 31), y[0] ^= R, y[1] ^= L, y[10] ^= R, y[11] ^= L, y[20] ^= R, y[21] ^= L, y[30] ^= R, y[31] ^= L, y[40] ^= R, y[41] ^= L, R = $ ^ (St << 1 | ne >>> 31), L = te ^ (ne << 1 | St >>> 31), y[2] ^= R, y[3] ^= L, y[12] ^= R, y[13] ^= L, y[22] ^= R, y[23] ^= L, y[32] ^= R, y[33] ^= L, y[42] ^= R, y[43] ^= L, R = Q ^ (he << 1 | Os >>> 31), L = X ^ (Os << 1 | he >>> 31), y[4] ^= R, y[5] ^= L, y[14] ^= R, y[15] ^= L, y[24] ^= R, y[25] ^= L, y[34] ^= R, y[35] ^= L, y[44] ^= R, y[45] ^= L, R = St ^ (He << 1 | qe >>> 31), L = ne ^ (qe << 1 | He >>> 31), y[6] ^= R, y[7] ^= L, y[16] ^= R, y[17] ^= L, y[26] ^= R, y[27] ^= L, y[36] ^= R, y[37] ^= L, y[46] ^= R, y[47] ^= L, R = he ^ ($ << 1 | te >>> 31), L = Os ^ (te << 1 | $ >>> 31), y[8] ^= R, y[9] ^= L, y[18] ^= R, y[19] ^= L, y[28] ^= R, y[29] ^= L, y[38] ^= R, y[39] ^= L, y[48] ^= R, y[49] ^= L, ks = y[0], We = y[1], ht = y[11] << 4 | y[10] >>> 28, Gs = y[10] << 4 | y[11] >>> 28, nt = y[20] << 3 | y[21] >>> 29, Ls = y[21] << 3 | y[20] >>> 29, Ji = y[31] << 9 | y[30] >>> 23, Qi = y[30] << 9 | y[31] >>> 23, dt = y[40] << 18 | y[41] >>> 14, ft = y[41] << 18 | y[40] >>> 14, at = y[2] << 1 | y[3] >>> 31, Us = y[3] << 1 | y[2] >>> 31, Ke = y[13] << 12 | y[12] >>> 20, Ns = y[12] << 12 | y[13] >>> 20, yt = y[22] << 10 | y[23] >>> 22, mt = y[23] << 10 | y[22] >>> 22, rt = y[33] << 13 | y[32] >>> 19, it = y[32] << 13 | y[33] >>> 19, Yi = y[42] << 2 | y[43] >>> 30, Xi = y[43] << 2 | y[42] >>> 30, xt = y[5] << 30 | y[4] >>> 2, vt = y[4] << 30 | y[5] >>> 2, ot = y[14] << 6 | y[15] >>> 26, ut = y[15] << 6 | y[14] >>> 26, Je = y[25] << 11 | y[24] >>> 21, Qe = y[24] << 11 | y[25] >>> 21, Hs = y[34] << 15 | y[35] >>> 17, bt = y[35] << 15 | y[34] >>> 17, $s = y[45] << 29 | y[44] >>> 3, st = y[44] << 29 | y[45] >>> 3, Ze = y[6] << 28 | y[7] >>> 4, et = y[7] << 28 | y[6] >>> 4, Ws = y[17] << 23 | y[16] >>> 9, wt = y[16] << 23 | y[17] >>> 9, js = y[26] << 25 | y[27] >>> 7, lt = y[27] << 25 | y[26] >>> 7, Ds = y[36] << 21 | y[37] >>> 11, Ye = y[37] << 21 | y[36] >>> 11, gt = y[47] << 24 | y[46] >>> 8, qs = y[46] << 24 | y[47] >>> 8, zs = y[8] << 27 | y[9] >>> 5, pt = y[9] << 27 | y[8] >>> 5, Fs = y[18] << 20 | y[19] >>> 12, tt = y[19] << 20 | y[18] >>> 12, Tt = y[29] << 7 | y[28] >>> 25, Ki = y[28] << 7 | y[29] >>> 25, ct = y[38] << 8 | y[39] >>> 24, Vs = y[39] << 8 | y[38] >>> 24, Xe = y[48] << 14 | y[49] >>> 18, Bs = y[49] << 14 | y[48] >>> 18, y[0] = ks ^ ~Ke & Je, y[1] = We ^ ~Ns & Qe, y[10] = Ze ^ ~Fs & nt, y[11] = et ^ ~tt & Ls, y[20] = at ^ ~ot & js, y[21] = Us ^ ~ut & lt, y[30] = zs ^ ~ht & yt, y[31] = pt ^ ~Gs & mt, y[40] = xt ^ ~Ws & Tt, y[41] = vt ^ ~wt & Ki, y[2] = Ke ^ ~Je & Ds, y[3] = Ns ^ ~Qe & Ye, y[12] = Fs ^ ~nt & rt, y[13] = tt ^ ~Ls & it, y[22] = ot ^ ~js & ct, y[23] = ut ^ ~lt & Vs, y[32] = ht ^ ~yt & Hs, y[33] = Gs ^ ~mt & bt, y[42] = Ws ^ ~Tt & Ji, y[43] = wt ^ ~Ki & Qi, y[4] = Je ^ ~Ds & Xe, y[5] = Qe ^ ~Ye & Bs, y[14] = nt ^ ~rt & $s, y[15] = Ls ^ ~it & st, y[24] = js ^ ~ct & dt, y[25] = lt ^ ~Vs & ft, y[34] = yt ^ ~Hs & gt, y[35] = mt ^ ~bt & qs, y[44] = Tt ^ ~Ji & Yi, y[45] = Ki ^ ~Qi & Xi, y[6] = Ds ^ ~Xe & ks, y[7] = Ye ^ ~Bs & We, y[16] = rt ^ ~$s & Ze, y[17] = it ^ ~st & et, y[26] = ct ^ ~dt & at, y[27] = Vs ^ ~ft & Us, y[36] = Hs ^ ~gt & zs, y[37] = bt ^ ~qs & pt, y[46] = Ji ^ ~Yi & xt, y[47] = Qi ^ ~Xi & vt, y[8] = Xe ^ ~ks & Ke, y[9] = Bs ^ ~We & Ns, y[18] = $s ^ ~Ze & Fs, y[19] = st ^ ~et & tt, y[28] = dt ^ ~at & ot, y[29] = ft ^ ~Us & ut, y[38] = gt ^ ~zs & ht, y[39] = qs ^ ~pt & Gs, y[48] = Yi ^ ~xt & Ws, y[49] = Xi ^ ~vt & wt, y[0] ^= T[F], y[1] ^= T[F + 1];
    };
    if (o)
      n.exports = c;
    else
      for (g = 0; g < h.length; ++g)
        i[h[g]] = c[h[g]];
  })();
})(hw);
var GS = hw.exports;
const HS = /* @__PURE__ */ _s(GS);
function De(n) {
  return "0x" + HS.keccak_256(q(n));
}
const qS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256: De
}, Symbol.toStringTag, { value: "Module" })), WS = "rlp/5.7.0", Vr = new D(WS);
function Hg(n) {
  const e = [];
  for (; n; )
    e.unshift(n & 255), n >>= 8;
  return e;
}
function qg(n, e, t) {
  let r = 0;
  for (let i = 0; i < t; i++)
    r = r * 256 + n[e + i];
  return r;
}
function yw(n) {
  if (Array.isArray(n)) {
    let r = [];
    if (n.forEach(function(s) {
      r = r.concat(yw(s));
    }), r.length <= 55)
      return r.unshift(192 + r.length), r;
    const i = Hg(r.length);
    return i.unshift(247 + i.length), i.concat(r);
  }
  Il(n) || Vr.throwArgumentError("RLP object must be BytesLike", "object", n);
  const e = Array.prototype.slice.call(q(n));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const t = Hg(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
function vs(n) {
  return J(yw(n));
}
function Wg(n, e, t, r) {
  const i = [];
  for (; t < e + 1 + r; ) {
    const s = mw(n, t);
    i.push(s.result), t += s.consumed, t > e + 1 + r && Vr.throwError("child data too short", D.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + r, result: i };
}
function mw(n, e) {
  if (n.length === 0 && Vr.throwError("data too short", D.errors.BUFFER_OVERRUN, {}), n[e] >= 248) {
    const t = n[e] - 247;
    e + 1 + t > n.length && Vr.throwError("data short segment too short", D.errors.BUFFER_OVERRUN, {});
    const r = qg(n, e + 1, t);
    return e + 1 + t + r > n.length && Vr.throwError("data long segment too short", D.errors.BUFFER_OVERRUN, {}), Wg(n, e, e + 1 + t, t + r);
  } else if (n[e] >= 192) {
    const t = n[e] - 192;
    return e + 1 + t > n.length && Vr.throwError("data array too short", D.errors.BUFFER_OVERRUN, {}), Wg(n, e, e + 1, t);
  } else if (n[e] >= 184) {
    const t = n[e] - 183;
    e + 1 + t > n.length && Vr.throwError("data array too short", D.errors.BUFFER_OVERRUN, {});
    const r = qg(n, e + 1, t);
    e + 1 + t + r > n.length && Vr.throwError("data array too short", D.errors.BUFFER_OVERRUN, {});
    const i = J(n.slice(e + 1 + t, e + 1 + t + r));
    return { consumed: 1 + t + r, result: i };
  } else if (n[e] >= 128) {
    const t = n[e] - 128;
    e + 1 + t > n.length && Vr.throwError("data too short", D.errors.BUFFER_OVERRUN, {});
    const r = J(n.slice(e + 1, e + 1 + t));
    return { consumed: 1 + t, result: r };
  }
  return { consumed: 1, result: J(n[e]) };
}
function kl(n) {
  const e = q(n), t = mw(e, 0);
  return t.consumed !== e.length && Vr.throwArgumentError("invalid rlp data", "data", n), t.result;
}
const KS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: kl,
  encode: vs
}, Symbol.toStringTag, { value: "Module" })), JS = "address/5.7.0", us = new D(JS);
function Kg(n) {
  _e(n, 20) || us.throwArgumentError("invalid address", "address", n), n = n.toLowerCase();
  const e = n.substring(2).split(""), t = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    t[i] = e[i].charCodeAt(0);
  const r = q(De(t));
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const QS = 9007199254740991;
function YS(n) {
  return Math.log10 ? Math.log10(n) : Math.log(n) / Math.LN10;
}
const cy = {};
for (let n = 0; n < 10; n++)
  cy[String(n)] = String(n);
for (let n = 0; n < 26; n++)
  cy[String.fromCharCode(65 + n)] = String(10 + n);
const Jg = Math.floor(YS(QS));
function bw(n) {
  n = n.toUpperCase(), n = n.substring(4) + n.substring(0, 2) + "00";
  let e = n.split("").map((r) => cy[r]).join("");
  for (; e.length >= Jg; ) {
    let r = e.substring(0, Jg);
    e = parseInt(r, 10) % 97 + e.substring(r.length);
  }
  let t = String(98 - parseInt(e, 10) % 97);
  for (; t.length < 2; )
    t = "0" + t;
  return t;
}
function Fe(n) {
  let e = null;
  if (typeof n != "string" && us.throwArgumentError("invalid address", "address", n), n.match(/^(0x)?[0-9a-fA-F]{40}$/))
    n.substring(0, 2) !== "0x" && (n = "0x" + n), e = Kg(n), n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== n && us.throwArgumentError("bad address checksum", "address", n);
  else if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (n.substring(2, 4) !== bw(n) && us.throwArgumentError("bad icap checksum", "address", n), e = iS(n.substring(4)); e.length < 40; )
      e = "0" + e;
    e = Kg("0x" + e);
  } else
    us.throwArgumentError("invalid address", "address", n);
  return e;
}
function XS(n) {
  try {
    return Fe(n), !0;
  } catch {
  }
  return !1;
}
function ZS(n) {
  let e = sS(Fe(n).substring(2)).toUpperCase();
  for (; e.length < 30; )
    e = "0" + e;
  return "XE" + bw("XE00" + e) + e;
}
function dy(n) {
  let e = null;
  try {
    e = Fe(n.from);
  } catch {
    us.throwArgumentError("missing from address", "transaction", n);
  }
  const t = Qr(q(H.from(n.nonce).toHexString()));
  return Fe(Bt(De(vs([e, t])), 12));
}
function eC(n, e, t) {
  return ni(e) !== 32 && us.throwArgumentError("salt must be 32 bytes", "salt", e), ni(t) !== 32 && us.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", t), Fe(Bt(De(Ge(["0xff", Fe(n), e, t])), 12));
}
const tC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAddress: Fe,
  getContractAddress: dy,
  getCreate2Address: eC,
  getIcapAddress: ZS,
  isAddress: XS
}, Symbol.toStringTag, { value: "Module" }));
class nC extends Hi {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, t) {
    try {
      t = Fe(t);
    } catch (r) {
      this._throwError(r.message, t);
    }
    return e.writeValue(t);
  }
  decode(e) {
    return Fe(Le(e.readValue().toHexString(), 20));
  }
}
class rC extends Hi {
  constructor(e) {
    super(e.name, e.type, void 0, e.dynamic), this.coder = e;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, t) {
    return this.coder.encode(e, t);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
const ao = new D(Ol);
function gw(n, e, t) {
  let r = null;
  if (Array.isArray(t))
    r = t;
  else if (t && typeof t == "object") {
    let u = {};
    r = e.map((l) => {
      const d = l.localName;
      return d || ao.throwError("cannot encode object for signature with missing names", D.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: l,
        value: t
      }), u[d] && ao.throwError("cannot encode object for signature with duplicate names", D.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: l,
        value: t
      }), u[d] = !0, t[d];
    });
  } else
    ao.throwArgumentError("invalid tuple value", "tuple", t);
  e.length !== r.length && ao.throwArgumentError("types/value length mismatch", "tuple", t);
  let i = new Ah(n.wordSize), s = new Ah(n.wordSize), a = [];
  e.forEach((u, l) => {
    let d = r[l];
    if (u.dynamic) {
      let p = s.length;
      u.encode(s, d);
      let m = i.writeUpdatableValue();
      a.push((w) => {
        m(w + p);
      });
    } else
      u.encode(i, d);
  }), a.forEach((u) => {
    u(i.length);
  });
  let o = n.appendWriter(i);
  return o += n.appendWriter(s), o;
}
function xw(n, e) {
  let t = [], r = n.subReader(0);
  e.forEach((s) => {
    let a = null;
    if (s.dynamic) {
      let o = n.readValue(), u = r.subReader(o.toNumber());
      try {
        a = s.decode(u);
      } catch (l) {
        if (l.code === D.errors.BUFFER_OVERRUN)
          throw l;
        a = l, a.baseType = s.name, a.name = s.localName, a.type = s.type;
      }
    } else
      try {
        a = s.decode(n);
      } catch (o) {
        if (o.code === D.errors.BUFFER_OVERRUN)
          throw o;
        a = o, a.baseType = s.name, a.name = s.localName, a.type = s.type;
      }
    a != null && t.push(a);
  });
  const i = e.reduce((s, a) => {
    const o = a.localName;
    return o && (s[o] || (s[o] = 0), s[o]++), s;
  }, {});
  e.forEach((s, a) => {
    let o = s.localName;
    if (!o || i[o] !== 1 || (o === "length" && (o = "_length"), t[o] != null))
      return;
    const u = t[a];
    u instanceof Error ? Object.defineProperty(t, o, {
      enumerable: !0,
      get: () => {
        throw u;
      }
    }) : t[o] = u;
  });
  for (let s = 0; s < t.length; s++) {
    const a = t[s];
    a instanceof Error && Object.defineProperty(t, s, {
      enumerable: !0,
      get: () => {
        throw a;
      }
    });
  }
  return Object.freeze(t);
}
class iC extends Hi {
  constructor(e, t, r) {
    const i = e.type + "[" + (t >= 0 ? t : "") + "]", s = t === -1 || e.dynamic;
    super("array", i, r, s), this.coder = e, this.length = t;
  }
  defaultValue() {
    const e = this.coder.defaultValue(), t = [];
    for (let r = 0; r < this.length; r++)
      t.push(e);
    return t;
  }
  encode(e, t) {
    Array.isArray(t) || this._throwError("expected array value", t);
    let r = this.length;
    r === -1 && (r = t.length, e.writeValue(t.length)), ao.checkArgumentCount(t.length, r, "coder array" + (this.localName ? " " + this.localName : ""));
    let i = [];
    for (let s = 0; s < t.length; s++)
      i.push(this.coder);
    return gw(e, i, t);
  }
  decode(e) {
    let t = this.length;
    t === -1 && (t = e.readValue().toNumber(), t * 32 > e._data.length && ao.throwError("insufficient data length", D.errors.BUFFER_OVERRUN, {
      length: e._data.length,
      count: t
    }));
    let r = [];
    for (let i = 0; i < t; i++)
      r.push(new rC(this.coder));
    return e.coerce(this.name, xw(e, r));
  }
}
class sC extends Hi {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    return e.writeValue(t ? 1 : 0);
  }
  decode(e) {
    return e.coerce(this.type, !e.readValue().isZero());
  }
}
class vw extends Hi {
  constructor(e, t) {
    super(e, e, t, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, t) {
    t = q(t);
    let r = e.writeValue(t.length);
    return r += e.writeBytes(t), r;
  }
  decode(e) {
    return e.readBytes(e.readValue().toNumber(), !0);
  }
}
class aC extends vw {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return e.coerce(this.name, J(super.decode(e)));
  }
}
class oC extends Hi {
  constructor(e, t) {
    let r = "bytes" + String(e);
    super(r, r, t, !1), this.size = e;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(e, t) {
    let r = q(t);
    return r.length !== this.size && this._throwError("incorrect data length", t), e.writeBytes(r);
  }
  decode(e) {
    return e.coerce(this.name, J(e.readBytes(this.size)));
  }
}
class uC extends Hi {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, t) {
    return t != null && this._throwError("not null", t), e.writeBytes([]);
  }
  decode(e) {
    return e.readBytes(0), e.coerce(this.name, null);
  }
}
const lC = "0x0000000000000000000000000000000000000000", cC = /* @__PURE__ */ H.from(-1), fy = /* @__PURE__ */ H.from(0), dC = /* @__PURE__ */ H.from(1), fC = /* @__PURE__ */ H.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), ww = "0x0000000000000000000000000000000000000000000000000000000000000000";
class pC extends Hi {
  constructor(e, t, r) {
    const i = (t ? "int" : "uint") + e * 8;
    super(i, i, r, !1), this.size = e, this.signed = t;
  }
  defaultValue() {
    return 0;
  }
  encode(e, t) {
    let r = H.from(t), i = fC.mask(e.wordSize * 8);
    if (this.signed) {
      let s = i.mask(this.size * 8 - 1);
      (r.gt(s) || r.lt(s.add(dC).mul(cC))) && this._throwError("value out-of-bounds", t);
    } else
      (r.lt(fy) || r.gt(i.mask(this.size * 8))) && this._throwError("value out-of-bounds", t);
    return r = r.toTwos(this.size * 8).mask(this.size * 8), this.signed && (r = r.fromTwos(this.size * 8).toTwos(8 * e.wordSize)), e.writeValue(r);
  }
  decode(e) {
    let t = e.readValue().mask(this.size * 8);
    return this.signed && (t = t.fromTwos(this.size * 8)), e.coerce(this.name, t);
  }
}
const hC = "strings/5.7.0", Tw = new D(hC);
var ri;
(function(n) {
  n.current = "", n.NFC = "NFC", n.NFD = "NFD", n.NFKC = "NFKC", n.NFKD = "NFKD";
})(ri || (ri = {}));
var Ln;
(function(n) {
  n.UNEXPECTED_CONTINUE = "unexpected continuation byte", n.BAD_PREFIX = "bad codepoint prefix", n.OVERRUN = "string overrun", n.MISSING_CONTINUE = "missing continuation byte", n.OUT_OF_RANGE = "out of UTF-8 range", n.UTF16_SURROGATE = "UTF-16 surrogate", n.OVERLONG = "overlong representation";
})(Ln || (Ln = {}));
function yC(n, e, t, r, i) {
  return Tw.throwArgumentError(`invalid codepoint at offset ${e}; ${n}`, "bytes", t);
}
function Aw(n, e, t, r, i) {
  if (n === Ln.BAD_PREFIX || n === Ln.UNEXPECTED_CONTINUE) {
    let s = 0;
    for (let a = e + 1; a < t.length && t[a] >> 6 === 2; a++)
      s++;
    return s;
  }
  return n === Ln.OVERRUN ? t.length - e - 1 : 0;
}
function mC(n, e, t, r, i) {
  return n === Ln.OVERLONG ? (r.push(i), 0) : (r.push(65533), Aw(n, e, t));
}
const Ew = Object.freeze({
  error: yC,
  ignore: Aw,
  replace: mC
});
function py(n, e) {
  e == null && (e = Ew.error), n = q(n);
  const t = [];
  let r = 0;
  for (; r < n.length; ) {
    const i = n[r++];
    if (!(i >> 7)) {
      t.push(i);
      continue;
    }
    let s = null, a = null;
    if ((i & 224) === 192)
      s = 1, a = 127;
    else if ((i & 240) === 224)
      s = 2, a = 2047;
    else if ((i & 248) === 240)
      s = 3, a = 65535;
    else {
      (i & 192) === 128 ? r += e(Ln.UNEXPECTED_CONTINUE, r - 1, n, t) : r += e(Ln.BAD_PREFIX, r - 1, n, t);
      continue;
    }
    if (r - 1 + s >= n.length) {
      r += e(Ln.OVERRUN, r - 1, n, t);
      continue;
    }
    let o = i & (1 << 8 - s - 1) - 1;
    for (let u = 0; u < s; u++) {
      let l = n[r];
      if ((l & 192) != 128) {
        r += e(Ln.MISSING_CONTINUE, r, n, t), o = null;
        break;
      }
      o = o << 6 | l & 63, r++;
    }
    if (o !== null) {
      if (o > 1114111) {
        r += e(Ln.OUT_OF_RANGE, r - 1 - s, n, t, o);
        continue;
      }
      if (o >= 55296 && o <= 57343) {
        r += e(Ln.UTF16_SURROGATE, r - 1 - s, n, t, o);
        continue;
      }
      if (o <= a) {
        r += e(Ln.OVERLONG, r - 1 - s, n, t, o);
        continue;
      }
      t.push(o);
    }
  }
  return t;
}
function Lt(n, e = ri.current) {
  e != ri.current && (Tw.checkNormalize(), n = n.normalize(e));
  let t = [];
  for (let r = 0; r < n.length; r++) {
    const i = n.charCodeAt(r);
    if (i < 128)
      t.push(i);
    else if (i < 2048)
      t.push(i >> 6 | 192), t.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      r++;
      const s = n.charCodeAt(r);
      if (r >= n.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const a = 65536 + ((i & 1023) << 10) + (s & 1023);
      t.push(a >> 18 | 240), t.push(a >> 12 & 63 | 128), t.push(a >> 6 & 63 | 128), t.push(a & 63 | 128);
    } else
      t.push(i >> 12 | 224), t.push(i >> 6 & 63 | 128), t.push(i & 63 | 128);
  }
  return q(t);
}
function gp(n) {
  const e = "0000" + n.toString(16);
  return "\\u" + e.substring(e.length - 4);
}
function bC(n, e) {
  return '"' + py(n, e).map((t) => {
    if (t < 256) {
      switch (t) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (t >= 32 && t < 127)
        return String.fromCharCode(t);
    }
    return t <= 65535 ? gp(t) : (t -= 65536, gp((t >> 10 & 1023) + 55296) + gp((t & 1023) + 56320));
  }).join("") + '"';
}
function Eh(n) {
  return n.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function Ps(n, e) {
  return Eh(py(n, e));
}
function dd(n, e = ri.current) {
  return py(Lt(n, e));
}
function gC(n) {
  const e = Lt(n);
  if (e.length > 31)
    throw new Error("bytes32 string must be less than 32 bytes");
  return J(Ge([e, ww]).slice(0, 32));
}
function xC(n) {
  const e = q(n);
  if (e.length !== 32)
    throw new Error("invalid bytes32 - not 32 bytes long");
  if (e[31] !== 0)
    throw new Error("invalid bytes32 string - no null terminator");
  let t = 31;
  for (; e[t - 1] === 0; )
    t--;
  return Ps(e.slice(0, t));
}
function vC(n) {
  if (n.length % 4 !== 0)
    throw new Error("bad data");
  let e = [];
  for (let t = 0; t < n.length; t += 4)
    e.push(parseInt(n.substring(t, t + 4), 16));
  return e;
}
function hy(n, e) {
  e || (e = function(i) {
    return [parseInt(i, 16)];
  });
  let t = 0, r = {};
  return n.split(",").forEach((i) => {
    let s = i.split(":");
    t += parseInt(s[0], 16), r[t] = e(s[1]);
  }), r;
}
function Sw(n) {
  let e = 0;
  return n.split(",").map((t) => {
    let r = t.split("-");
    r.length === 1 ? r[1] = "0" : r[1] === "" && (r[1] = "1");
    let i = e + parseInt(r[0], 16);
    return e = parseInt(r[1], 16), { l: i, h: e };
  });
}
function yy(n, e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    if (t += i.l, n >= t && n <= t + i.h && (n - t) % (i.d || 1) === 0) {
      if (i.e && i.e.indexOf(n - t) !== -1)
        continue;
      return i;
    }
  }
  return null;
}
const wC = Sw("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"), TC = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((n) => parseInt(n, 16)), AC = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
], EC = hy("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"), SC = hy("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"), CC = hy("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", vC), _C = Sw("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function MC(n) {
  return n.reduce((e, t) => (t.forEach((r) => {
    e.push(r);
  }), e), []);
}
function PC(n) {
  return !!yy(n, wC);
}
function RC(n) {
  let e = yy(n, AC);
  if (e)
    return [n + e.s];
  let t = EC[n];
  if (t)
    return t;
  let r = SC[n];
  if (r)
    return [n + r[0]];
  let i = CC[n];
  return i || null;
}
function IC(n) {
  return !!yy(n, _C);
}
function OC(n) {
  if (n.match(/^[a-z0-9-]*$/i) && n.length <= 59)
    return n.toLowerCase();
  let e = dd(n);
  e = MC(e.map((r) => {
    if (TC.indexOf(r) >= 0)
      return [];
    if (r >= 65024 && r <= 65039)
      return [];
    let i = RC(r);
    return i || [r];
  })), e = dd(Eh(e), ri.NFKC), e.forEach((r) => {
    if (IC(r))
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
  }), e.forEach((r) => {
    if (PC(r))
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
  });
  let t = Eh(e);
  if (t.substring(0, 1) === "-" || t.substring(2, 4) === "--" || t.substring(t.length - 1) === "-")
    throw new Error("invalid hyphen");
  return t;
}
const kC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get UnicodeNormalizationForm() {
    return ri;
  },
  Utf8ErrorFuncs: Ew,
  get Utf8ErrorReason() {
    return Ln;
  },
  _toEscapedUtf8String: bC,
  formatBytes32String: gC,
  nameprep: OC,
  parseBytes32String: xC,
  toUtf8Bytes: Lt,
  toUtf8CodePoints: dd,
  toUtf8String: Ps
}, Symbol.toStringTag, { value: "Module" }));
class NC extends vw {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, t) {
    return super.encode(e, Lt(t));
  }
  decode(e) {
    return Ps(super.decode(e));
  }
}
class sc extends Hi {
  constructor(e, t) {
    let r = !1;
    const i = [];
    e.forEach((a) => {
      a.dynamic && (r = !0), i.push(a.type);
    });
    const s = "tuple(" + i.join(",") + ")";
    super("tuple", s, t, r), this.coders = e;
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((r) => {
      e.push(r.defaultValue());
    });
    const t = this.coders.reduce((r, i) => {
      const s = i.localName;
      return s && (r[s] || (r[s] = 0), r[s]++), r;
    }, {});
    return this.coders.forEach((r, i) => {
      let s = r.localName;
      !s || t[s] !== 1 || (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]));
    }), Object.freeze(e);
  }
  encode(e, t) {
    return gw(e, this.coders, t);
  }
  decode(e) {
    return e.coerce(this.name, xw(e, this.coders));
  }
}
const ac = new D(Ol), DC = new RegExp(/^bytes([0-9]*)$/), BC = new RegExp(/^(u?int)([0-9]*)$/);
class Cw {
  constructor(e) {
    j(this, "coerceFunc", e || null);
  }
  _getCoder(e) {
    switch (e.baseType) {
      case "address":
        return new nC(e.name);
      case "bool":
        return new sC(e.name);
      case "string":
        return new NC(e.name);
      case "bytes":
        return new aC(e.name);
      case "array":
        return new iC(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
      case "tuple":
        return new sc((e.components || []).map((r) => this._getCoder(r)), e.name);
      case "":
        return new uC(e.name);
    }
    let t = e.type.match(BC);
    if (t) {
      let r = parseInt(t[2] || "256");
      return (r === 0 || r > 256 || r % 8 !== 0) && ac.throwArgumentError("invalid " + t[1] + " bit length", "param", e), new pC(r / 8, t[1] === "int", e.name);
    }
    if (t = e.type.match(DC), t) {
      let r = parseInt(t[1]);
      return (r === 0 || r > 32) && ac.throwArgumentError("invalid bytes length", "param", e), new oC(r, e.name);
    }
    return ac.throwArgumentError("invalid type", "type", e.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(e, t) {
    return new cd(e, this._getWordSize(), this.coerceFunc, t);
  }
  _getWriter() {
    return new Ah(this._getWordSize());
  }
  getDefaultValue(e) {
    const t = e.map((i) => this._getCoder(Wt.from(i)));
    return new sc(t, "_").defaultValue();
  }
  encode(e, t) {
    e.length !== t.length && ac.throwError("types/values length mismatch", D.errors.INVALID_ARGUMENT, {
      count: { types: e.length, values: t.length },
      value: { types: e, values: t }
    });
    const r = e.map((a) => this._getCoder(Wt.from(a))), i = new sc(r, "_"), s = this._getWriter();
    return i.encode(s, t), s.data;
  }
  decode(e, t, r) {
    const i = e.map((a) => this._getCoder(Wt.from(a)));
    return new sc(i, "_").decode(this._getReader(q(t), r));
  }
}
const _w = new Cw();
function ls(n) {
  return De(Lt(n));
}
const Mw = "hash/5.7.0";
function my(n) {
  n = atob(n);
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push(n.charCodeAt(t));
  return q(e);
}
function by(n) {
  n = q(n);
  let e = "";
  for (let t = 0; t < n.length; t++)
    e += String.fromCharCode(n[t]);
  return btoa(e);
}
const FC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: my,
  encode: by
}, Symbol.toStringTag, { value: "Module" }));
function Pw(n, e) {
  e == null && (e = 1);
  const t = [], r = t.forEach, i = function(s, a) {
    r.call(s, function(o) {
      a > 0 && Array.isArray(o) ? i(o, a - 1) : t.push(o);
    });
  };
  return i(n, e), t;
}
function LC(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = n[t];
    e[r[0]] = r[1];
  }
  return e;
}
function $C(n) {
  let e = 0;
  function t() {
    return n[e++] << 8 | n[e++];
  }
  let r = t(), i = 1, s = [0, 1];
  for (let N = 1; N < r; N++)
    s.push(i += t());
  let a = t(), o = e;
  e += a;
  let u = 0, l = 0;
  function d() {
    return u == 0 && (l = l << 8 | n[e++], u = 8), l >> --u & 1;
  }
  const p = 31, m = Math.pow(2, p), w = m >>> 1, x = w >> 1, T = m - 1;
  let A = 0;
  for (let N = 0; N < p; N++)
    A = A << 1 | d();
  let M = [], I = 0, B = m;
  for (; ; ) {
    let N = Math.floor(((A - I + 1) * i - 1) / B), U = 0, W = r;
    for (; W - U > 1; ) {
      let ue = U + W >>> 1;
      N < s[ue] ? W = ue : U = ue;
    }
    if (U == 0)
      break;
    M.push(U);
    let G = I + Math.floor(B * s[U] / i), Y = I + Math.floor(B * s[U + 1] / i) - 1;
    for (; !((G ^ Y) & w); )
      A = A << 1 & T | d(), G = G << 1 & T, Y = Y << 1 & T | 1;
    for (; G & ~Y & x; )
      A = A & w | A << 1 & T >>> 1 | d(), G = G << 1 ^ w, Y = (Y ^ w) << 1 | w | 1;
    I = G, B = 1 + Y - G;
  }
  let k = r - 4;
  return M.map((N) => {
    switch (N - k) {
      case 3:
        return k + 65792 + (n[o++] << 16 | n[o++] << 8 | n[o++]);
      case 2:
        return k + 256 + (n[o++] << 8 | n[o++]);
      case 1:
        return k + n[o++];
      default:
        return N - 1;
    }
  });
}
function UC(n) {
  let e = 0;
  return () => n[e++];
}
function jC(n) {
  return UC($C(n));
}
function VC(n) {
  return n & 1 ? ~n >> 1 : n >> 1;
}
function zC(n, e) {
  let t = Array(n);
  for (let r = 0; r < n; r++)
    t[r] = 1 + e();
  return t;
}
function Qg(n, e) {
  let t = Array(n);
  for (let r = 0, i = -1; r < n; r++)
    t[r] = i += 1 + e();
  return t;
}
function GC(n, e) {
  let t = Array(n);
  for (let r = 0, i = 0; r < n; r++)
    t[r] = i += VC(e());
  return t;
}
function fd(n, e) {
  let t = Qg(n(), n), r = n(), i = Qg(r, n), s = zC(r, n);
  for (let a = 0; a < r; a++)
    for (let o = 0; o < s[a]; o++)
      t.push(i[a] + o);
  return e ? t.map((a) => e[a]) : t;
}
function HC(n) {
  let e = [];
  for (; ; ) {
    let t = n();
    if (t == 0)
      break;
    e.push(WC(t, n));
  }
  for (; ; ) {
    let t = n() - 1;
    if (t < 0)
      break;
    e.push(KC(t, n));
  }
  return LC(Pw(e));
}
function qC(n) {
  let e = [];
  for (; ; ) {
    let t = n();
    if (t == 0)
      break;
    e.push(t);
  }
  return e;
}
function Rw(n, e, t) {
  let r = Array(n).fill(void 0).map(() => []);
  for (let i = 0; i < e; i++)
    GC(n, t).forEach((s, a) => r[a].push(s));
  return r;
}
function WC(n, e) {
  let t = 1 + e(), r = e(), i = qC(e), s = Rw(i.length, 1 + n, e);
  return Pw(s.map((a, o) => {
    const u = a[0], l = a.slice(1);
    return Array(i[o]).fill(void 0).map((d, p) => {
      let m = p * r;
      return [u + p * t, l.map((w) => w + m)];
    });
  }));
}
function KC(n, e) {
  let t = 1 + e();
  return Rw(t, 1 + n, e).map((i) => [i[0], i.slice(1)]);
}
function JC(n) {
  let e = fd(n).sort((r, i) => r - i);
  return t();
  function t() {
    let r = [];
    for (; ; ) {
      let l = fd(n, e);
      if (l.length == 0)
        break;
      r.push({ set: new Set(l), node: t() });
    }
    r.sort((l, d) => d.set.size - l.set.size);
    let i = n(), s = i % 3;
    i = i / 3 | 0;
    let a = !!(i & 1);
    i >>= 1;
    let o = i == 1, u = i == 2;
    return { branches: r, valid: s, fe0f: a, save: o, check: u };
  }
}
function QC() {
  return jC(my("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const sf = QC(), YC = new Set(fd(sf)), XC = new Set(fd(sf)), ZC = HC(sf), e_ = JC(sf), Yg = 45, Xg = 95;
function Iw(n) {
  return dd(n);
}
function t_(n) {
  return n.filter((e) => e != 65039);
}
function Ow(n) {
  for (let e of n.split(".")) {
    let t = Iw(e);
    try {
      for (let r = t.lastIndexOf(Xg) - 1; r >= 0; r--)
        if (t[r] !== Xg)
          throw new Error("underscore only allowed at start");
      if (t.length >= 4 && t.every((r) => r < 128) && t[2] === Yg && t[3] === Yg)
        throw new Error("invalid label extension");
    } catch (r) {
      throw new Error(`Invalid label "${e}": ${r.message}`);
    }
  }
  return n;
}
function n_(n) {
  return Ow(r_(n, t_));
}
function r_(n, e) {
  let t = Iw(n).reverse(), r = [];
  for (; t.length; ) {
    let i = s_(t);
    if (i) {
      r.push(...e(i));
      continue;
    }
    let s = t.pop();
    if (YC.has(s)) {
      r.push(s);
      continue;
    }
    if (XC.has(s))
      continue;
    let a = ZC[s];
    if (a) {
      r.push(...a);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`);
  }
  return Ow(i_(String.fromCodePoint(...r)));
}
function i_(n) {
  return n.normalize("NFC");
}
function s_(n, e) {
  var t;
  let r = e_, i, s, a = [], o = n.length;
  for (e && (e.length = 0); o; ) {
    let u = n[--o];
    if (r = (t = r.branches.find((l) => l.set.has(u))) === null || t === void 0 ? void 0 : t.node, !r)
      break;
    if (r.save)
      s = u;
    else if (r.check && u === s)
      break;
    a.push(u), r.fe0f && (a.push(65039), o > 0 && n[o - 1] == 65039 && o--), r.valid && (i = a.slice(), r.valid == 2 && i.splice(1, 1), e && e.push(...n.slice(o).reverse()), n.length = o);
  }
  return i;
}
const a_ = new D(Mw), kw = new Uint8Array(32);
kw.fill(0);
function Zg(n) {
  if (n.length === 0)
    throw new Error("invalid ENS name; empty component");
  return n;
}
function af(n) {
  const e = Lt(n_(n)), t = [];
  if (n.length === 0)
    return t;
  let r = 0;
  for (let i = 0; i < e.length; i++)
    e[i] === 46 && (t.push(Zg(e.slice(r, i))), r = i + 1);
  if (r >= e.length)
    throw new Error("invalid ENS name; empty component");
  return t.push(Zg(e.slice(r))), t;
}
function o_(n) {
  return af(n).map((e) => Ps(e)).join(".");
}
function u_(n) {
  try {
    return af(n).length !== 0;
  } catch {
  }
  return !1;
}
function _u(n) {
  typeof n != "string" && a_.throwArgumentError("invalid ENS name; not a string", "name", n);
  let e = kw;
  const t = af(n);
  for (; t.length; )
    e = De(Ge([e, De(t.pop())]));
  return J(e);
}
function Nw(n) {
  return J(Ge(af(n).map((e) => {
    if (e.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const t = new Uint8Array(e.length + 1);
    return t.set(e, 1), t[0] = t.length - 1, t;
  }))) + "00";
}
const Dw = `Ethereum Signed Message:
`;
function gy(n) {
  return typeof n == "string" && (n = Lt(n)), De(Ge([
    Lt(Dw),
    Lt(String(n.length)),
    n
  ]));
}
var l_ = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const _t = new D(Mw), Bw = new Uint8Array(32);
Bw.fill(0);
const c_ = H.from(-1), Fw = H.from(0), Lw = H.from(1), d_ = H.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function f_(n) {
  const e = q(n), t = e.length % 32;
  return t ? Sn([e, Bw.slice(t)]) : J(e);
}
const p_ = Le(Lw.toHexString(), 32), h_ = Le(Fw.toHexString(), 32), ex = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, xp = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function tx(n) {
  return function(e) {
    return typeof e != "string" && _t.throwArgumentError(`invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, e), e;
  };
}
const y_ = {
  name: tx("name"),
  version: tx("version"),
  chainId: function(n) {
    try {
      return H.from(n).toString();
    } catch {
    }
    return _t.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", n);
  },
  verifyingContract: function(n) {
    try {
      return Fe(n).toLowerCase();
    } catch {
    }
    return _t.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", n);
  },
  salt: function(n) {
    try {
      const e = q(n);
      if (e.length !== 32)
        throw new Error("bad length");
      return J(e);
    } catch {
    }
    return _t.throwArgumentError('invalid domain value "salt"', "domain.salt", n);
  }
};
function vp(n) {
  {
    const e = n.match(/^(u?)int(\d*)$/);
    if (e) {
      const t = e[1] === "", r = parseInt(e[2] || "256");
      (r % 8 !== 0 || r > 256 || e[2] && e[2] !== String(r)) && _t.throwArgumentError("invalid numeric width", "type", n);
      const i = d_.mask(t ? r - 1 : r), s = t ? i.add(Lw).mul(c_) : Fw;
      return function(a) {
        const o = H.from(a);
        return (o.lt(s) || o.gt(i)) && _t.throwArgumentError(`value out-of-bounds for ${n}`, "value", a), Le(o.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const e = n.match(/^bytes(\d+)$/);
    if (e) {
      const t = parseInt(e[1]);
      return (t === 0 || t > 32 || e[1] !== String(t)) && _t.throwArgumentError("invalid bytes width", "type", n), function(r) {
        return q(r).length !== t && _t.throwArgumentError(`invalid length for ${n}`, "value", r), f_(r);
      };
    }
  }
  switch (n) {
    case "address":
      return function(e) {
        return Le(Fe(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? p_ : h_;
      };
    case "bytes":
      return function(e) {
        return De(e);
      };
    case "string":
      return function(e) {
        return ls(e);
      };
  }
  return null;
}
function nx(n, e) {
  return `${n}(${e.map(({ name: t, type: r }) => r + " " + t).join(",")})`;
}
class an {
  constructor(e) {
    j(this, "types", Object.freeze(xs(e))), j(this, "_encoderCache", {}), j(this, "_types", {});
    const t = {}, r = {}, i = {};
    Object.keys(e).forEach((o) => {
      t[o] = {}, r[o] = [], i[o] = {};
    });
    for (const o in e) {
      const u = {};
      e[o].forEach((l) => {
        u[l.name] && _t.throwArgumentError(`duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(o)}`, "types", e), u[l.name] = !0;
        const d = l.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        d === o && _t.throwArgumentError(`circular type reference to ${JSON.stringify(d)}`, "types", e), !vp(d) && (r[d] || _t.throwArgumentError(`unknown type ${JSON.stringify(d)}`, "types", e), r[d].push(o), t[o][d] = !0);
      });
    }
    const s = Object.keys(r).filter((o) => r[o].length === 0);
    s.length === 0 ? _t.throwArgumentError("missing primary type", "types", e) : s.length > 1 && _t.throwArgumentError(`ambiguous primary types or unused types: ${s.map((o) => JSON.stringify(o)).join(", ")}`, "types", e), j(this, "primaryType", s[0]);
    function a(o, u) {
      u[o] && _t.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`, "types", e), u[o] = !0, Object.keys(t[o]).forEach((l) => {
        r[l] && (a(l, u), Object.keys(u).forEach((d) => {
          i[d][l] = !0;
        }));
      }), delete u[o];
    }
    a(this.primaryType, {});
    for (const o in i) {
      const u = Object.keys(i[o]);
      u.sort(), this._types[o] = nx(o, e[o]) + u.map((l) => nx(l, e[l])).join("");
    }
  }
  getEncoder(e) {
    let t = this._encoderCache[e];
    return t || (t = this._encoderCache[e] = this._getEncoder(e)), t;
  }
  _getEncoder(e) {
    {
      const i = vp(e);
      if (i)
        return i;
    }
    const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (t) {
      const i = t[1], s = this.getEncoder(i), a = parseInt(t[3]);
      return (o) => {
        a >= 0 && o.length !== a && _t.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", o);
        let u = o.map(s);
        return this._types[i] && (u = u.map(De)), De(Sn(u));
      };
    }
    const r = this.types[e];
    if (r) {
      const i = ls(this._types[e]);
      return (s) => {
        const a = r.map(({ name: o, type: u }) => {
          const l = this.getEncoder(u)(s[o]);
          return this._types[u] ? De(l) : l;
        });
        return a.unshift(i), Sn(a);
      };
    }
    return _t.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  encodeType(e) {
    const t = this._types[e];
    return t || _t.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), t;
  }
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  hashStruct(e, t) {
    return De(this.encodeData(e, t));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, t, r) {
    if (vp(e))
      return r(e, t);
    const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (i) {
      const a = i[1], o = parseInt(i[3]);
      return o >= 0 && t.length !== o && _t.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", t), t.map((u) => this._visit(a, u, r));
    }
    const s = this.types[e];
    return s ? s.reduce((a, { name: o, type: u }) => (a[o] = this._visit(u, t[o], r), a), {}) : _t.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  static from(e) {
    return new an(e);
  }
  static getPrimaryType(e) {
    return an.from(e).primaryType;
  }
  static hashStruct(e, t, r) {
    return an.from(t).hashStruct(e, r);
  }
  static hashDomain(e) {
    const t = [];
    for (const r in e) {
      const i = ex[r];
      i || _t.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e), t.push({ name: r, type: i });
    }
    return t.sort((r, i) => xp.indexOf(r.name) - xp.indexOf(i.name)), an.hashStruct("EIP712Domain", { EIP712Domain: t }, e);
  }
  static encode(e, t, r) {
    return Sn([
      "0x1901",
      an.hashDomain(e),
      an.from(t).hash(r)
    ]);
  }
  static hash(e, t, r) {
    return De(an.encode(e, t, r));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(e, t, r, i) {
    return l_(this, void 0, void 0, function* () {
      e = zt(e);
      const s = {};
      e.verifyingContract && !_e(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
      const a = an.from(t);
      a.visit(r, (o, u) => (o === "address" && !_e(u, 20) && (s[u] = "0x"), u));
      for (const o in s)
        s[o] = yield i(o);
      return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), r = a.visit(r, (o, u) => o === "address" && s[u] ? s[u] : u), { domain: e, value: r };
    });
  }
  static getPayload(e, t, r) {
    an.hashDomain(e);
    const i = {}, s = [];
    xp.forEach((u) => {
      const l = e[u];
      l != null && (i[u] = y_[u](l), s.push({ name: u, type: ex[u] }));
    });
    const a = an.from(t), o = zt(t);
    return o.EIP712Domain ? _t.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", t) : o.EIP712Domain = s, a.encode(r), {
      types: o,
      domain: i,
      primaryType: a.primaryType,
      message: a.visit(r, (u, l) => {
        if (u.match(/^bytes(\d*)/))
          return J(q(l));
        if (u.match(/^u?int/))
          return H.from(l).toString();
        switch (u) {
          case "address":
            return l.toLowerCase();
          case "bool":
            return !!l;
          case "string":
            return typeof l != "string" && _t.throwArgumentError("invalid string", "value", l), l;
        }
        return _t.throwArgumentError("unsupported type", "type", u);
      })
    };
  }
}
const m_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _TypedDataEncoder: an,
  dnsEncode: Nw,
  ensNormalize: o_,
  hashMessage: gy,
  id: ls,
  isValidName: u_,
  messagePrefix: Dw,
  namehash: _u
}, Symbol.toStringTag, { value: "Module" })), Ct = new D(Ol);
class $w extends Ms {
}
class Uw extends Ms {
}
class b_ extends Ms {
}
class pd extends Ms {
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const g_ = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function rx(n, e) {
  const t = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
  return t.error = e, t;
}
class Sh {
  constructor(e) {
    let t = [];
    typeof e == "string" ? t = JSON.parse(e) : t = e, j(this, "fragments", t.map((r) => Wr.from(r)).filter((r) => r != null)), j(this, "_abiCoder", Rr(new.target, "getAbiCoder")()), j(this, "functions", {}), j(this, "errors", {}), j(this, "events", {}), j(this, "structs", {}), this.fragments.forEach((r) => {
      let i = null;
      switch (r.type) {
        case "constructor":
          if (this.deploy) {
            Ct.warn("duplicate definition - constructor");
            return;
          }
          j(this, "deploy", r);
          return;
        case "function":
          i = this.functions;
          break;
        case "event":
          i = this.events;
          break;
        case "error":
          i = this.errors;
          break;
        default:
          return;
      }
      let s = r.format();
      if (i[s]) {
        Ct.warn("duplicate definition - " + s);
        return;
      }
      i[s] = r;
    }), this.deploy || j(this, "deploy", Cr.from({
      payable: !1,
      type: "constructor"
    })), j(this, "_isInterface", !0);
  }
  format(e) {
    e || (e = Ie.full), e === Ie.sighash && Ct.throwArgumentError("interface does not support formatting sighash", "format", e);
    const t = this.fragments.map((r) => r.format(e));
    return e === Ie.json ? JSON.stringify(t.map((r) => JSON.parse(r))) : t;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return _w;
  }
  static getAddress(e) {
    return Fe(e);
  }
  static getSighash(e) {
    return Bt(ls(e.format()), 0, 4);
  }
  static getEventTopic(e) {
    return ls(e.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(e) {
    if (_e(e)) {
      for (const r in this.functions)
        if (e === this.getSighash(r))
          return this.functions[r];
      Ct.throwArgumentError("no matching function", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(), i = Object.keys(this.functions).filter((s) => s.split(
        "("
        /* fix:) */
      )[0] === r);
      return i.length === 0 ? Ct.throwArgumentError("no matching function", "name", r) : i.length > 1 && Ct.throwArgumentError("multiple matching functions", "name", r), this.functions[i[0]];
    }
    const t = this.functions[_r.fromString(e).format()];
    return t || Ct.throwArgumentError("no matching function", "signature", e), t;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(e) {
    if (_e(e)) {
      const r = e.toLowerCase();
      for (const i in this.events)
        if (r === this.getEventTopic(i))
          return this.events[i];
      Ct.throwArgumentError("no matching event", "topichash", r);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(), i = Object.keys(this.events).filter((s) => s.split(
        "("
        /* fix:) */
      )[0] === r);
      return i.length === 0 ? Ct.throwArgumentError("no matching event", "name", r) : i.length > 1 && Ct.throwArgumentError("multiple matching events", "name", r), this.events[i[0]];
    }
    const t = this.events[qr.fromString(e).format()];
    return t || Ct.throwArgumentError("no matching event", "signature", e), t;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(e) {
    if (_e(e)) {
      const r = Rr(this.constructor, "getSighash");
      for (const i in this.errors) {
        const s = this.errors[i];
        if (e === r(s))
          return this.errors[i];
      }
      Ct.throwArgumentError("no matching error", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(), i = Object.keys(this.errors).filter((s) => s.split(
        "("
        /* fix:) */
      )[0] === r);
      return i.length === 0 ? Ct.throwArgumentError("no matching error", "name", r) : i.length > 1 && Ct.throwArgumentError("multiple matching errors", "name", r), this.errors[i[0]];
    }
    const t = this.errors[_r.fromString(e).format()];
    return t || Ct.throwArgumentError("no matching error", "signature", e), t;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(e) {
    if (typeof e == "string")
      try {
        e = this.getFunction(e);
      } catch (t) {
        try {
          e = this.getError(e);
        } catch {
          throw t;
        }
      }
    return Rr(this.constructor, "getSighash")(e);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(e) {
    return typeof e == "string" && (e = this.getEvent(e)), Rr(this.constructor, "getEventTopic")(e);
  }
  _decodeParams(e, t) {
    return this._abiCoder.decode(e, t);
  }
  _encodeParams(e, t) {
    return this._abiCoder.encode(e, t);
  }
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  decodeErrorResult(e, t) {
    typeof e == "string" && (e = this.getError(e));
    const r = q(t);
    return J(r.slice(0, 4)) !== this.getSighash(e) && Ct.throwArgumentError(`data signature does not match error ${e.name}.`, "data", J(r)), this._decodeParams(e.inputs, r.slice(4));
  }
  encodeErrorResult(e, t) {
    return typeof e == "string" && (e = this.getError(e)), J(Ge([
      this.getSighash(e),
      this._encodeParams(e.inputs, t || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(e, t) {
    typeof e == "string" && (e = this.getFunction(e));
    const r = q(t);
    return J(r.slice(0, 4)) !== this.getSighash(e) && Ct.throwArgumentError(`data signature does not match function ${e.name}.`, "data", J(r)), this._decodeParams(e.inputs, r.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(e, t) {
    return typeof e == "string" && (e = this.getFunction(e)), J(Ge([
      this.getSighash(e),
      this._encodeParams(e.inputs, t || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(e, t) {
    typeof e == "string" && (e = this.getFunction(e));
    let r = q(t), i = null, s = "", a = null, o = null, u = null;
    switch (r.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(e.outputs, r);
        } catch {
        }
        break;
      case 4: {
        const l = J(r.slice(0, 4)), d = g_[l];
        if (d)
          a = this._abiCoder.decode(d.inputs, r.slice(4)), o = d.name, u = d.signature, d.reason && (i = a[0]), o === "Error" ? s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(a[0])}` : o === "Panic" && (s = `; VM Exception while processing transaction: reverted with panic code ${a[0]}`);
        else
          try {
            const p = this.getError(l);
            a = this._abiCoder.decode(p.inputs, r.slice(4)), o = p.name, u = p.format();
          } catch {
          }
        break;
      }
    }
    return Ct.throwError("call revert exception" + s, D.errors.CALL_EXCEPTION, {
      method: e.format(),
      data: J(t),
      errorArgs: a,
      errorName: o,
      errorSignature: u,
      reason: i
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(e, t) {
    return typeof e == "string" && (e = this.getFunction(e)), J(this._abiCoder.encode(e.outputs, t || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, t) {
    typeof e == "string" && (e = this.getEvent(e)), t.length > e.inputs.length && Ct.throwError("too many arguments for " + e.format(), D.errors.UNEXPECTED_ARGUMENT, {
      argument: "values",
      value: t
    });
    let r = [];
    e.anonymous || r.push(this.getEventTopic(e));
    const i = (s, a) => s.type === "string" ? ls(a) : s.type === "bytes" ? De(J(a)) : (s.type === "bool" && typeof a == "boolean" && (a = a ? "0x01" : "0x00"), s.type.match(/^u?int/) && (a = H.from(a).toHexString()), s.type === "address" && this._abiCoder.encode(["address"], [a]), Le(J(a), 32));
    for (t.forEach((s, a) => {
      let o = e.inputs[a];
      if (!o.indexed) {
        s != null && Ct.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + o.name, s);
        return;
      }
      s == null ? r.push(null) : o.baseType === "array" || o.baseType === "tuple" ? Ct.throwArgumentError("filtering with tuples or arrays not supported", "contract." + o.name, s) : Array.isArray(s) ? r.push(s.map((u) => i(o, u))) : r.push(i(o, s));
    }); r.length && r[r.length - 1] === null; )
      r.pop();
    return r;
  }
  encodeEventLog(e, t) {
    typeof e == "string" && (e = this.getEvent(e));
    const r = [], i = [], s = [];
    return e.anonymous || r.push(this.getEventTopic(e)), t.length !== e.inputs.length && Ct.throwArgumentError("event arguments/values mismatch", "values", t), e.inputs.forEach((a, o) => {
      const u = t[o];
      if (a.indexed)
        if (a.type === "string")
          r.push(ls(u));
        else if (a.type === "bytes")
          r.push(De(u));
        else {
          if (a.baseType === "tuple" || a.baseType === "array")
            throw new Error("not implemented");
          r.push(this._abiCoder.encode([a.type], [u]));
        }
      else
        i.push(a), s.push(u);
    }), {
      data: this._abiCoder.encode(i, s),
      topics: r
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, t, r) {
    if (typeof e == "string" && (e = this.getEvent(e)), r != null && !e.anonymous) {
      let m = this.getEventTopic(e);
      (!_e(r[0], 32) || r[0].toLowerCase() !== m) && Ct.throwError("fragment/topic mismatch", D.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: m, value: r[0] }), r = r.slice(1);
    }
    let i = [], s = [], a = [];
    e.inputs.forEach((m, w) => {
      m.indexed ? m.type === "string" || m.type === "bytes" || m.baseType === "tuple" || m.baseType === "array" ? (i.push(Wt.fromObject({ type: "bytes32", name: m.name })), a.push(!0)) : (i.push(m), a.push(!1)) : (s.push(m), a.push(!1));
    });
    let o = r != null ? this._abiCoder.decode(i, Ge(r)) : null, u = this._abiCoder.decode(s, t, !0), l = [], d = 0, p = 0;
    e.inputs.forEach((m, w) => {
      if (m.indexed)
        if (o == null)
          l[w] = new pd({ _isIndexed: !0, hash: null });
        else if (a[w])
          l[w] = new pd({ _isIndexed: !0, hash: o[p++] });
        else
          try {
            l[w] = o[p++];
          } catch (x) {
            l[w] = x;
          }
      else
        try {
          l[w] = u[d++];
        } catch (x) {
          l[w] = x;
        }
      if (m.name && l[m.name] == null) {
        const x = l[w];
        x instanceof Error ? Object.defineProperty(l, m.name, {
          enumerable: !0,
          get: () => {
            throw rx(`property ${JSON.stringify(m.name)}`, x);
          }
        }) : l[m.name] = x;
      }
    });
    for (let m = 0; m < l.length; m++) {
      const w = l[m];
      w instanceof Error && Object.defineProperty(l, m, {
        enumerable: !0,
        get: () => {
          throw rx(`index ${m}`, w);
        }
      });
    }
    return Object.freeze(l);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(e) {
    let t = this.getFunction(e.data.substring(0, 10).toLowerCase());
    return t ? new Uw({
      args: this._abiCoder.decode(t.inputs, "0x" + e.data.substring(10)),
      functionFragment: t,
      name: t.name,
      signature: t.format(),
      sighash: this.getSighash(t),
      value: H.from(e.value || "0")
    }) : null;
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(e) {
    let t = this.getEvent(e.topics[0]);
    return !t || t.anonymous ? null : new $w({
      eventFragment: t,
      name: t.name,
      signature: t.format(),
      topic: this.getEventTopic(t),
      args: this.decodeEventLog(t, e.data, e.topics)
    });
  }
  parseError(e) {
    const t = J(e);
    let r = this.getError(t.substring(0, 10).toLowerCase());
    return r ? new b_({
      args: this._abiCoder.decode(r.inputs, "0x" + t.substring(10)),
      errorFragment: r,
      name: r.name,
      signature: r.format(),
      sighash: this.getSighash(r)
    }) : null;
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(e) {
    return !!(e && e._isInterface);
  }
}
const x_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbiCoder: Cw,
  ConstructorFragment: Cr,
  ErrorFragment: wi,
  EventFragment: qr,
  FormatTypes: Ie,
  Fragment: Wr,
  FunctionFragment: _r,
  Indexed: pd,
  Interface: Sh,
  LogDescription: $w,
  ParamType: Wt,
  TransactionDescription: Uw,
  checkResultErrors: uw,
  defaultAbiCoder: _w
}, Symbol.toStringTag, { value: "Module" })), v_ = "abstract-provider/5.7.0";
var w_ = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const T_ = new D(v_);
class A_ extends Ms {
  static isForkEvent(e) {
    return !!(e && e._isForkEvent);
  }
}
let xy = class jw {
  constructor() {
    T_.checkAbstract(new.target, jw), j(this, "_isProvider", !0);
  }
  getFeeData() {
    return w_(this, void 0, void 0, function* () {
      const { block: e, gasPrice: t } = yield Rt({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((a) => null)
      });
      let r = null, i = null, s = null;
      return e && e.baseFeePerGas && (r = e.baseFeePerGas, s = H.from("1500000000"), i = e.baseFeePerGas.mul(2).add(s)), { lastBaseFeePerGas: r, maxFeePerGas: i, maxPriorityFeePerGas: s, gasPrice: t };
    });
  }
  // Alias for "on"
  addListener(e, t) {
    return this.on(e, t);
  }
  // Alias for "off"
  removeListener(e, t) {
    return this.off(e, t);
  }
  static isProvider(e) {
    return !!(e && e._isProvider);
  }
};
const E_ = "abstract-signer/5.7.0";
var vr = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const or = new D(E_), S_ = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
], C_ = [
  D.errors.INSUFFICIENT_FUNDS,
  D.errors.NONCE_EXPIRED,
  D.errors.REPLACEMENT_UNDERPRICED
];
class La {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    or.checkAbstract(new.target, La), j(this, "_isSigner", !0);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(e) {
    return vr(this, void 0, void 0, function* () {
      return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e);
    });
  }
  getTransactionCount(e) {
    return vr(this, void 0, void 0, function* () {
      return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(e) {
    return vr(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const t = yield Rt(this.checkTransaction(e));
      return yield this.provider.estimateGas(t);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(e, t) {
    return vr(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const r = yield Rt(this.checkTransaction(e));
      return yield this.provider.call(r, t);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(e) {
    return vr(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const t = yield this.populateTransaction(e), r = yield this.signTransaction(t);
      return yield this.provider.sendTransaction(r);
    });
  }
  getChainId() {
    return vr(this, void 0, void 0, function* () {
      return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId;
    });
  }
  getGasPrice() {
    return vr(this, void 0, void 0, function* () {
      return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return vr(this, void 0, void 0, function* () {
      return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
    });
  }
  resolveName(e) {
    return vr(this, void 0, void 0, function* () {
      return this._checkProvider("resolveName"), yield this.provider.resolveName(e);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(e) {
    for (const r in e)
      S_.indexOf(r) === -1 && or.throwArgumentError("invalid transaction key: " + r, "transaction", e);
    const t = zt(e);
    return t.from == null ? t.from = this.getAddress() : t.from = Promise.all([
      Promise.resolve(t.from),
      this.getAddress()
    ]).then((r) => (r[0].toLowerCase() !== r[1].toLowerCase() && or.throwArgumentError("from address mismatch", "transaction", e), r[0])), t;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(e) {
    return vr(this, void 0, void 0, function* () {
      const t = yield Rt(this.checkTransaction(e));
      t.to != null && (t.to = Promise.resolve(t.to).then((i) => vr(this, void 0, void 0, function* () {
        if (i == null)
          return null;
        const s = yield this.resolveName(i);
        return s == null && or.throwArgumentError("provided ENS name resolves to null", "tx.to", i), s;
      })), t.to.catch((i) => {
      }));
      const r = t.maxFeePerGas != null || t.maxPriorityFeePerGas != null;
      if (t.gasPrice != null && (t.type === 2 || r) ? or.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e) : (t.type === 0 || t.type === 1) && r && or.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e), (t.type === 2 || t.type == null) && t.maxFeePerGas != null && t.maxPriorityFeePerGas != null)
        t.type = 2;
      else if (t.type === 0 || t.type === 1)
        t.gasPrice == null && (t.gasPrice = this.getGasPrice());
      else {
        const i = yield this.getFeeData();
        if (t.type == null)
          if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
            if (t.type = 2, t.gasPrice != null) {
              const s = t.gasPrice;
              delete t.gasPrice, t.maxFeePerGas = s, t.maxPriorityFeePerGas = s;
            } else
              t.maxFeePerGas == null && (t.maxFeePerGas = i.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
          else
            i.gasPrice != null ? (r && or.throwError("network does not support EIP-1559", D.errors.UNSUPPORTED_OPERATION, {
              operation: "populateTransaction"
            }), t.gasPrice == null && (t.gasPrice = i.gasPrice), t.type = 0) : or.throwError("failed to get consistent fee data", D.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
        else
          t.type === 2 && (t.maxFeePerGas == null && (t.maxFeePerGas = i.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
      }
      return t.nonce == null && (t.nonce = this.getTransactionCount("pending")), t.gasLimit == null && (t.gasLimit = this.estimateGas(t).catch((i) => {
        if (C_.indexOf(i.code) >= 0)
          throw i;
        return or.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", D.errors.UNPREDICTABLE_GAS_LIMIT, {
          error: i,
          tx: t
        });
      })), t.chainId == null ? t.chainId = this.getChainId() : t.chainId = Promise.all([
        Promise.resolve(t.chainId),
        this.getChainId()
      ]).then((i) => (i[1] !== 0 && i[0] !== i[1] && or.throwArgumentError("chainId address mismatch", "transaction", e), i[0])), yield Rt(t);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(e) {
    this.provider || or.throwError("missing provider", D.errors.UNSUPPORTED_OPERATION, {
      operation: e || "_checkProvider"
    });
  }
  static isSigner(e) {
    return !!(e && e._isSigner);
  }
}
class vy extends La {
  constructor(e, t) {
    super(), j(this, "address", e), j(this, "provider", t || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(e, t) {
    return Promise.resolve().then(() => {
      or.throwError(e, D.errors.UNSUPPORTED_OPERATION, { operation: t });
    });
  }
  signMessage(e) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(e) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(e, t, r) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(e) {
    return new vy(this.address, e);
  }
}
var Vw = {}, Ee = {}, Nl = zw;
function zw(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
zw.equal = function(e, t, r) {
  if (e != t)
    throw new Error(r || "Assertion failed: " + e + " != " + t);
};
var Ch = { exports: {} };
typeof Object.create == "function" ? Ch.exports = function(e, t) {
  t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Ch.exports = function(e, t) {
  if (t) {
    e.super_ = t;
    var r = function() {
    };
    r.prototype = t.prototype, e.prototype = new r(), e.prototype.constructor = e;
  }
};
var __ = Ch.exports, M_ = Nl, P_ = __;
Ee.inherits = P_;
function R_(n, e) {
  return (n.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= n.length ? !1 : (n.charCodeAt(e + 1) & 64512) === 56320;
}
function I_(n, e) {
  if (Array.isArray(n))
    return n.slice();
  if (!n)
    return [];
  var t = [];
  if (typeof n == "string")
    if (e) {
      if (e === "hex")
        for (n = n.replace(/[^a-z0-9]+/ig, ""), n.length % 2 !== 0 && (n = "0" + n), i = 0; i < n.length; i += 2)
          t.push(parseInt(n[i] + n[i + 1], 16));
    } else
      for (var r = 0, i = 0; i < n.length; i++) {
        var s = n.charCodeAt(i);
        s < 128 ? t[r++] = s : s < 2048 ? (t[r++] = s >> 6 | 192, t[r++] = s & 63 | 128) : R_(n, i) ? (s = 65536 + ((s & 1023) << 10) + (n.charCodeAt(++i) & 1023), t[r++] = s >> 18 | 240, t[r++] = s >> 12 & 63 | 128, t[r++] = s >> 6 & 63 | 128, t[r++] = s & 63 | 128) : (t[r++] = s >> 12 | 224, t[r++] = s >> 6 & 63 | 128, t[r++] = s & 63 | 128);
      }
  else
    for (i = 0; i < n.length; i++)
      t[i] = n[i] | 0;
  return t;
}
Ee.toArray = I_;
function O_(n) {
  for (var e = "", t = 0; t < n.length; t++)
    e += Hw(n[t].toString(16));
  return e;
}
Ee.toHex = O_;
function Gw(n) {
  var e = n >>> 24 | n >>> 8 & 65280 | n << 8 & 16711680 | (n & 255) << 24;
  return e >>> 0;
}
Ee.htonl = Gw;
function k_(n, e) {
  for (var t = "", r = 0; r < n.length; r++) {
    var i = n[r];
    e === "little" && (i = Gw(i)), t += qw(i.toString(16));
  }
  return t;
}
Ee.toHex32 = k_;
function Hw(n) {
  return n.length === 1 ? "0" + n : n;
}
Ee.zero2 = Hw;
function qw(n) {
  return n.length === 7 ? "0" + n : n.length === 6 ? "00" + n : n.length === 5 ? "000" + n : n.length === 4 ? "0000" + n : n.length === 3 ? "00000" + n : n.length === 2 ? "000000" + n : n.length === 1 ? "0000000" + n : n;
}
Ee.zero8 = qw;
function N_(n, e, t, r) {
  var i = t - e;
  M_(i % 4 === 0);
  for (var s = new Array(i / 4), a = 0, o = e; a < s.length; a++, o += 4) {
    var u;
    r === "big" ? u = n[o] << 24 | n[o + 1] << 16 | n[o + 2] << 8 | n[o + 3] : u = n[o + 3] << 24 | n[o + 2] << 16 | n[o + 1] << 8 | n[o], s[a] = u >>> 0;
  }
  return s;
}
Ee.join32 = N_;
function D_(n, e) {
  for (var t = new Array(n.length * 4), r = 0, i = 0; r < n.length; r++, i += 4) {
    var s = n[r];
    e === "big" ? (t[i] = s >>> 24, t[i + 1] = s >>> 16 & 255, t[i + 2] = s >>> 8 & 255, t[i + 3] = s & 255) : (t[i + 3] = s >>> 24, t[i + 2] = s >>> 16 & 255, t[i + 1] = s >>> 8 & 255, t[i] = s & 255);
  }
  return t;
}
Ee.split32 = D_;
function B_(n, e) {
  return n >>> e | n << 32 - e;
}
Ee.rotr32 = B_;
function F_(n, e) {
  return n << e | n >>> 32 - e;
}
Ee.rotl32 = F_;
function L_(n, e) {
  return n + e >>> 0;
}
Ee.sum32 = L_;
function $_(n, e, t) {
  return n + e + t >>> 0;
}
Ee.sum32_3 = $_;
function U_(n, e, t, r) {
  return n + e + t + r >>> 0;
}
Ee.sum32_4 = U_;
function j_(n, e, t, r, i) {
  return n + e + t + r + i >>> 0;
}
Ee.sum32_5 = j_;
function V_(n, e, t, r) {
  var i = n[e], s = n[e + 1], a = r + s >>> 0, o = (a < r ? 1 : 0) + t + i;
  n[e] = o >>> 0, n[e + 1] = a;
}
Ee.sum64 = V_;
function z_(n, e, t, r) {
  var i = e + r >>> 0, s = (i < e ? 1 : 0) + n + t;
  return s >>> 0;
}
Ee.sum64_hi = z_;
function G_(n, e, t, r) {
  var i = e + r;
  return i >>> 0;
}
Ee.sum64_lo = G_;
function H_(n, e, t, r, i, s, a, o) {
  var u = 0, l = e;
  l = l + r >>> 0, u += l < e ? 1 : 0, l = l + s >>> 0, u += l < s ? 1 : 0, l = l + o >>> 0, u += l < o ? 1 : 0;
  var d = n + t + i + a + u;
  return d >>> 0;
}
Ee.sum64_4_hi = H_;
function q_(n, e, t, r, i, s, a, o) {
  var u = e + r + s + o;
  return u >>> 0;
}
Ee.sum64_4_lo = q_;
function W_(n, e, t, r, i, s, a, o, u, l) {
  var d = 0, p = e;
  p = p + r >>> 0, d += p < e ? 1 : 0, p = p + s >>> 0, d += p < s ? 1 : 0, p = p + o >>> 0, d += p < o ? 1 : 0, p = p + l >>> 0, d += p < l ? 1 : 0;
  var m = n + t + i + a + u + d;
  return m >>> 0;
}
Ee.sum64_5_hi = W_;
function K_(n, e, t, r, i, s, a, o, u, l) {
  var d = e + r + s + o + l;
  return d >>> 0;
}
Ee.sum64_5_lo = K_;
function J_(n, e, t) {
  var r = e << 32 - t | n >>> t;
  return r >>> 0;
}
Ee.rotr64_hi = J_;
function Q_(n, e, t) {
  var r = n << 32 - t | e >>> t;
  return r >>> 0;
}
Ee.rotr64_lo = Q_;
function Y_(n, e, t) {
  return n >>> t;
}
Ee.shr64_hi = Y_;
function X_(n, e, t) {
  var r = n << 32 - t | e >>> t;
  return r >>> 0;
}
Ee.shr64_lo = X_;
var zo = {}, ix = Ee, Z_ = Nl;
function of() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
zo.BlockHash = of;
of.prototype.update = function(e, t) {
  if (e = ix.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var r = e.length % this._delta8;
    this.pending = e.slice(e.length - r, e.length), this.pending.length === 0 && (this.pending = null), e = ix.join32(e, 0, e.length - r, this.endian);
    for (var i = 0; i < e.length; i += this._delta32)
      this._update(e, i, i + this._delta32);
  }
  return this;
};
of.prototype.digest = function(e) {
  return this.update(this._pad()), Z_(this.pending === null), this._digest(e);
};
of.prototype._pad = function() {
  var e = this.pendingTotal, t = this._delta8, r = t - (e + this.padLength) % t, i = new Array(r + this.padLength);
  i[0] = 128;
  for (var s = 1; s < r; s++)
    i[s] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var a = 8; a < this.padLength; a++)
      i[s++] = 0;
    i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = e >>> 24 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 8 & 255, i[s++] = e & 255;
  } else
    for (i[s++] = e & 255, i[s++] = e >>> 8 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, a = 8; a < this.padLength; a++)
      i[s++] = 0;
  return i;
};
var Go = {}, ci = {}, e7 = Ee, Yr = e7.rotr32;
function t7(n, e, t, r) {
  if (n === 0)
    return Ww(e, t, r);
  if (n === 1 || n === 3)
    return Jw(e, t, r);
  if (n === 2)
    return Kw(e, t, r);
}
ci.ft_1 = t7;
function Ww(n, e, t) {
  return n & e ^ ~n & t;
}
ci.ch32 = Ww;
function Kw(n, e, t) {
  return n & e ^ n & t ^ e & t;
}
ci.maj32 = Kw;
function Jw(n, e, t) {
  return n ^ e ^ t;
}
ci.p32 = Jw;
function n7(n) {
  return Yr(n, 2) ^ Yr(n, 13) ^ Yr(n, 22);
}
ci.s0_256 = n7;
function r7(n) {
  return Yr(n, 6) ^ Yr(n, 11) ^ Yr(n, 25);
}
ci.s1_256 = r7;
function i7(n) {
  return Yr(n, 7) ^ Yr(n, 18) ^ n >>> 3;
}
ci.g0_256 = i7;
function s7(n) {
  return Yr(n, 17) ^ Yr(n, 19) ^ n >>> 10;
}
ci.g1_256 = s7;
var wo = Ee, a7 = zo, o7 = ci, wp = wo.rotl32, eu = wo.sum32, u7 = wo.sum32_5, l7 = o7.ft_1, Qw = a7.BlockHash, c7 = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function ii() {
  if (!(this instanceof ii))
    return new ii();
  Qw.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
wo.inherits(ii, Qw);
var d7 = ii;
ii.blockSize = 512;
ii.outSize = 160;
ii.hmacStrength = 80;
ii.padLength = 64;
ii.prototype._update = function(e, t) {
  for (var r = this.W, i = 0; i < 16; i++)
    r[i] = e[t + i];
  for (; i < r.length; i++)
    r[i] = wp(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
  var s = this.h[0], a = this.h[1], o = this.h[2], u = this.h[3], l = this.h[4];
  for (i = 0; i < r.length; i++) {
    var d = ~~(i / 20), p = u7(wp(s, 5), l7(d, a, o, u), l, r[i], c7[d]);
    l = u, u = o, o = wp(a, 30), a = s, s = p;
  }
  this.h[0] = eu(this.h[0], s), this.h[1] = eu(this.h[1], a), this.h[2] = eu(this.h[2], o), this.h[3] = eu(this.h[3], u), this.h[4] = eu(this.h[4], l);
};
ii.prototype._digest = function(e) {
  return e === "hex" ? wo.toHex32(this.h, "big") : wo.split32(this.h, "big");
};
var To = Ee, f7 = zo, Ho = ci, p7 = Nl, wr = To.sum32, h7 = To.sum32_4, y7 = To.sum32_5, m7 = Ho.ch32, b7 = Ho.maj32, g7 = Ho.s0_256, x7 = Ho.s1_256, v7 = Ho.g0_256, w7 = Ho.g1_256, Yw = f7.BlockHash, T7 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function si() {
  if (!(this instanceof si))
    return new si();
  Yw.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = T7, this.W = new Array(64);
}
To.inherits(si, Yw);
var Xw = si;
si.blockSize = 512;
si.outSize = 256;
si.hmacStrength = 192;
si.padLength = 64;
si.prototype._update = function(e, t) {
  for (var r = this.W, i = 0; i < 16; i++)
    r[i] = e[t + i];
  for (; i < r.length; i++)
    r[i] = h7(w7(r[i - 2]), r[i - 7], v7(r[i - 15]), r[i - 16]);
  var s = this.h[0], a = this.h[1], o = this.h[2], u = this.h[3], l = this.h[4], d = this.h[5], p = this.h[6], m = this.h[7];
  for (p7(this.k.length === r.length), i = 0; i < r.length; i++) {
    var w = y7(m, x7(l), m7(l, d, p), this.k[i], r[i]), x = wr(g7(s), b7(s, a, o));
    m = p, p = d, d = l, l = wr(u, w), u = o, o = a, a = s, s = wr(w, x);
  }
  this.h[0] = wr(this.h[0], s), this.h[1] = wr(this.h[1], a), this.h[2] = wr(this.h[2], o), this.h[3] = wr(this.h[3], u), this.h[4] = wr(this.h[4], l), this.h[5] = wr(this.h[5], d), this.h[6] = wr(this.h[6], p), this.h[7] = wr(this.h[7], m);
};
si.prototype._digest = function(e) {
  return e === "hex" ? To.toHex32(this.h, "big") : To.split32(this.h, "big");
};
var _h = Ee, Zw = Xw;
function ki() {
  if (!(this instanceof ki))
    return new ki();
  Zw.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
_h.inherits(ki, Zw);
var A7 = ki;
ki.blockSize = 512;
ki.outSize = 224;
ki.hmacStrength = 192;
ki.padLength = 64;
ki.prototype._digest = function(e) {
  return e === "hex" ? _h.toHex32(this.h.slice(0, 7), "big") : _h.split32(this.h.slice(0, 7), "big");
};
var zn = Ee, E7 = zo, S7 = Nl, Xr = zn.rotr64_hi, Zr = zn.rotr64_lo, e6 = zn.shr64_hi, t6 = zn.shr64_lo, es = zn.sum64, Tp = zn.sum64_hi, Ap = zn.sum64_lo, C7 = zn.sum64_4_hi, _7 = zn.sum64_4_lo, M7 = zn.sum64_5_hi, P7 = zn.sum64_5_lo, n6 = E7.BlockHash, R7 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function Br() {
  if (!(this instanceof Br))
    return new Br();
  n6.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = R7, this.W = new Array(160);
}
zn.inherits(Br, n6);
var r6 = Br;
Br.blockSize = 1024;
Br.outSize = 512;
Br.hmacStrength = 192;
Br.padLength = 128;
Br.prototype._prepareBlock = function(e, t) {
  for (var r = this.W, i = 0; i < 32; i++)
    r[i] = e[t + i];
  for (; i < r.length; i += 2) {
    var s = j7(r[i - 4], r[i - 3]), a = V7(r[i - 4], r[i - 3]), o = r[i - 14], u = r[i - 13], l = $7(r[i - 30], r[i - 29]), d = U7(r[i - 30], r[i - 29]), p = r[i - 32], m = r[i - 31];
    r[i] = C7(
      s,
      a,
      o,
      u,
      l,
      d,
      p,
      m
    ), r[i + 1] = _7(
      s,
      a,
      o,
      u,
      l,
      d,
      p,
      m
    );
  }
};
Br.prototype._update = function(e, t) {
  this._prepareBlock(e, t);
  var r = this.W, i = this.h[0], s = this.h[1], a = this.h[2], o = this.h[3], u = this.h[4], l = this.h[5], d = this.h[6], p = this.h[7], m = this.h[8], w = this.h[9], x = this.h[10], T = this.h[11], A = this.h[12], M = this.h[13], I = this.h[14], B = this.h[15];
  S7(this.k.length === r.length);
  for (var k = 0; k < r.length; k += 2) {
    var N = I, U = B, W = F7(m, w), G = L7(m, w), Y = I7(m, w, x, T, A), ue = O7(m, w, x, T, A, M), K = this.k[k], le = this.k[k + 1], C = r[k], c = r[k + 1], h = M7(
      N,
      U,
      W,
      G,
      Y,
      ue,
      K,
      le,
      C,
      c
    ), g = P7(
      N,
      U,
      W,
      G,
      Y,
      ue,
      K,
      le,
      C,
      c
    );
    N = D7(i, s), U = B7(i, s), W = k7(i, s, a, o, u), G = N7(i, s, a, o, u, l);
    var E = Tp(N, U, W, G), S = Ap(N, U, W, G);
    I = A, B = M, A = x, M = T, x = m, T = w, m = Tp(d, p, h, g), w = Ap(p, p, h, g), d = u, p = l, u = a, l = o, a = i, o = s, i = Tp(h, g, E, S), s = Ap(h, g, E, S);
  }
  es(this.h, 0, i, s), es(this.h, 2, a, o), es(this.h, 4, u, l), es(this.h, 6, d, p), es(this.h, 8, m, w), es(this.h, 10, x, T), es(this.h, 12, A, M), es(this.h, 14, I, B);
};
Br.prototype._digest = function(e) {
  return e === "hex" ? zn.toHex32(this.h, "big") : zn.split32(this.h, "big");
};
function I7(n, e, t, r, i) {
  var s = n & t ^ ~n & i;
  return s < 0 && (s += 4294967296), s;
}
function O7(n, e, t, r, i, s) {
  var a = e & r ^ ~e & s;
  return a < 0 && (a += 4294967296), a;
}
function k7(n, e, t, r, i) {
  var s = n & t ^ n & i ^ t & i;
  return s < 0 && (s += 4294967296), s;
}
function N7(n, e, t, r, i, s) {
  var a = e & r ^ e & s ^ r & s;
  return a < 0 && (a += 4294967296), a;
}
function D7(n, e) {
  var t = Xr(n, e, 28), r = Xr(e, n, 2), i = Xr(e, n, 7), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function B7(n, e) {
  var t = Zr(n, e, 28), r = Zr(e, n, 2), i = Zr(e, n, 7), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function F7(n, e) {
  var t = Xr(n, e, 14), r = Xr(n, e, 18), i = Xr(e, n, 9), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function L7(n, e) {
  var t = Zr(n, e, 14), r = Zr(n, e, 18), i = Zr(e, n, 9), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function $7(n, e) {
  var t = Xr(n, e, 1), r = Xr(n, e, 8), i = e6(n, e, 7), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function U7(n, e) {
  var t = Zr(n, e, 1), r = Zr(n, e, 8), i = t6(n, e, 7), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function j7(n, e) {
  var t = Xr(n, e, 19), r = Xr(e, n, 29), i = e6(n, e, 6), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function V7(n, e) {
  var t = Zr(n, e, 19), r = Zr(e, n, 29), i = t6(n, e, 6), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
var Mh = Ee, i6 = r6;
function Ni() {
  if (!(this instanceof Ni))
    return new Ni();
  i6.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
Mh.inherits(Ni, i6);
var z7 = Ni;
Ni.blockSize = 1024;
Ni.outSize = 384;
Ni.hmacStrength = 192;
Ni.padLength = 128;
Ni.prototype._digest = function(e) {
  return e === "hex" ? Mh.toHex32(this.h.slice(0, 12), "big") : Mh.split32(this.h.slice(0, 12), "big");
};
Go.sha1 = d7;
Go.sha224 = A7;
Go.sha256 = Xw;
Go.sha384 = z7;
Go.sha512 = r6;
var s6 = {}, ga = Ee, G7 = zo, oc = ga.rotl32, sx = ga.sum32, tu = ga.sum32_3, ax = ga.sum32_4, a6 = G7.BlockHash;
function ai() {
  if (!(this instanceof ai))
    return new ai();
  a6.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
ga.inherits(ai, a6);
s6.ripemd160 = ai;
ai.blockSize = 512;
ai.outSize = 160;
ai.hmacStrength = 192;
ai.padLength = 64;
ai.prototype._update = function(e, t) {
  for (var r = this.h[0], i = this.h[1], s = this.h[2], a = this.h[3], o = this.h[4], u = r, l = i, d = s, p = a, m = o, w = 0; w < 80; w++) {
    var x = sx(
      oc(
        ax(r, ox(w, i, s, a), e[W7[w] + t], H7(w)),
        J7[w]
      ),
      o
    );
    r = o, o = a, a = oc(s, 10), s = i, i = x, x = sx(
      oc(
        ax(u, ox(79 - w, l, d, p), e[K7[w] + t], q7(w)),
        Q7[w]
      ),
      m
    ), u = m, m = p, p = oc(d, 10), d = l, l = x;
  }
  x = tu(this.h[1], s, p), this.h[1] = tu(this.h[2], a, m), this.h[2] = tu(this.h[3], o, u), this.h[3] = tu(this.h[4], r, l), this.h[4] = tu(this.h[0], i, d), this.h[0] = x;
};
ai.prototype._digest = function(e) {
  return e === "hex" ? ga.toHex32(this.h, "little") : ga.split32(this.h, "little");
};
function ox(n, e, t, r) {
  return n <= 15 ? e ^ t ^ r : n <= 31 ? e & t | ~e & r : n <= 47 ? (e | ~t) ^ r : n <= 63 ? e & r | t & ~r : e ^ (t | ~r);
}
function H7(n) {
  return n <= 15 ? 0 : n <= 31 ? 1518500249 : n <= 47 ? 1859775393 : n <= 63 ? 2400959708 : 2840853838;
}
function q7(n) {
  return n <= 15 ? 1352829926 : n <= 31 ? 1548603684 : n <= 47 ? 1836072691 : n <= 63 ? 2053994217 : 0;
}
var W7 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], K7 = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], J7 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], Q7 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], Y7 = Ee, X7 = Nl;
function Ao(n, e, t) {
  if (!(this instanceof Ao))
    return new Ao(n, e, t);
  this.Hash = n, this.blockSize = n.blockSize / 8, this.outSize = n.outSize / 8, this.inner = null, this.outer = null, this._init(Y7.toArray(e, t));
}
var Z7 = Ao;
Ao.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), X7(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++)
    e.push(0);
  for (t = 0; t < e.length; t++)
    e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++)
    e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
Ao.prototype.update = function(e, t) {
  return this.inner.update(e, t), this;
};
Ao.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(n) {
  var e = n;
  e.utils = Ee, e.common = zo, e.sha = Go, e.ripemd = s6, e.hmac = Z7, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(Vw);
const Dn = /* @__PURE__ */ _s(Vw);
function qo(n, e, t) {
  return t = {
    path: e,
    exports: {},
    require: function(r, i) {
      return eM(r, i ?? t.path);
    }
  }, n(t, t.exports), t.exports;
}
function eM() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var wy = o6;
function o6(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
o6.equal = function(e, t, r) {
  if (e != t)
    throw new Error(r || "Assertion failed: " + e + " != " + t);
};
var Ir = qo(function(n, e) {
  var t = e;
  function r(a, o) {
    if (Array.isArray(a))
      return a.slice();
    if (!a)
      return [];
    var u = [];
    if (typeof a != "string") {
      for (var l = 0; l < a.length; l++)
        u[l] = a[l] | 0;
      return u;
    }
    if (o === "hex") {
      a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a);
      for (var l = 0; l < a.length; l += 2)
        u.push(parseInt(a[l] + a[l + 1], 16));
    } else
      for (var l = 0; l < a.length; l++) {
        var d = a.charCodeAt(l), p = d >> 8, m = d & 255;
        p ? u.push(p, m) : u.push(m);
      }
    return u;
  }
  t.toArray = r;
  function i(a) {
    return a.length === 1 ? "0" + a : a;
  }
  t.zero2 = i;
  function s(a) {
    for (var o = "", u = 0; u < a.length; u++)
      o += i(a[u].toString(16));
    return o;
  }
  t.toHex = s, t.encode = function(o, u) {
    return u === "hex" ? s(o) : o;
  };
}), rr = qo(function(n, e) {
  var t = e;
  t.assert = wy, t.toArray = Ir.toArray, t.zero2 = Ir.zero2, t.toHex = Ir.toHex, t.encode = Ir.encode;
  function r(u, l, d) {
    var p = new Array(Math.max(u.bitLength(), d) + 1);
    p.fill(0);
    for (var m = 1 << l + 1, w = u.clone(), x = 0; x < p.length; x++) {
      var T, A = w.andln(m - 1);
      w.isOdd() ? (A > (m >> 1) - 1 ? T = (m >> 1) - A : T = A, w.isubn(T)) : T = 0, p[x] = T, w.iushrn(1);
    }
    return p;
  }
  t.getNAF = r;
  function i(u, l) {
    var d = [
      [],
      []
    ];
    u = u.clone(), l = l.clone();
    for (var p = 0, m = 0, w; u.cmpn(-p) > 0 || l.cmpn(-m) > 0; ) {
      var x = u.andln(3) + p & 3, T = l.andln(3) + m & 3;
      x === 3 && (x = -1), T === 3 && (T = -1);
      var A;
      x & 1 ? (w = u.andln(7) + p & 7, (w === 3 || w === 5) && T === 2 ? A = -x : A = x) : A = 0, d[0].push(A);
      var M;
      T & 1 ? (w = l.andln(7) + m & 7, (w === 3 || w === 5) && x === 2 ? M = -T : M = T) : M = 0, d[1].push(M), 2 * p === A + 1 && (p = 1 - p), 2 * m === M + 1 && (m = 1 - m), u.iushrn(1), l.iushrn(1);
    }
    return d;
  }
  t.getJSF = i;
  function s(u, l, d) {
    var p = "_" + l;
    u.prototype[l] = function() {
      return this[p] !== void 0 ? this[p] : this[p] = d.call(this);
    };
  }
  t.cachedProperty = s;
  function a(u) {
    return typeof u == "string" ? t.toArray(u, "hex") : u;
  }
  t.parseBytes = a;
  function o(u) {
    return new ye(u, "hex", "le");
  }
  t.intFromLE = o;
}), hd = rr.getNAF, tM = rr.getJSF, yd = rr.assert;
function Rs(n, e) {
  this.type = n, this.p = new ye(e.p, 16), this.red = e.prime ? ye.red(e.prime) : ye.mont(this.p), this.zero = new ye(0).toRed(this.red), this.one = new ye(1).toRed(this.red), this.two = new ye(2).toRed(this.red), this.n = e.n && new ye(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var t = this.n && this.p.div(this.n);
  !t || t.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var $a = Rs;
Rs.prototype.point = function() {
  throw new Error("Not implemented");
};
Rs.prototype.validate = function() {
  throw new Error("Not implemented");
};
Rs.prototype._fixedNafMul = function(e, t) {
  yd(e.precomputed);
  var r = e._getDoubles(), i = hd(t, 1, this._bitLength), s = (1 << r.step + 1) - (r.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var a = [], o, u;
  for (o = 0; o < i.length; o += r.step) {
    u = 0;
    for (var l = o + r.step - 1; l >= o; l--)
      u = (u << 1) + i[l];
    a.push(u);
  }
  for (var d = this.jpoint(null, null, null), p = this.jpoint(null, null, null), m = s; m > 0; m--) {
    for (o = 0; o < a.length; o++)
      u = a[o], u === m ? p = p.mixedAdd(r.points[o]) : u === -m && (p = p.mixedAdd(r.points[o].neg()));
    d = d.add(p);
  }
  return d.toP();
};
Rs.prototype._wnafMul = function(e, t) {
  var r = 4, i = e._getNAFPoints(r);
  r = i.wnd;
  for (var s = i.points, a = hd(t, r, this._bitLength), o = this.jpoint(null, null, null), u = a.length - 1; u >= 0; u--) {
    for (var l = 0; u >= 0 && a[u] === 0; u--)
      l++;
    if (u >= 0 && l++, o = o.dblp(l), u < 0)
      break;
    var d = a[u];
    yd(d !== 0), e.type === "affine" ? d > 0 ? o = o.mixedAdd(s[d - 1 >> 1]) : o = o.mixedAdd(s[-d - 1 >> 1].neg()) : d > 0 ? o = o.add(s[d - 1 >> 1]) : o = o.add(s[-d - 1 >> 1].neg());
  }
  return e.type === "affine" ? o.toP() : o;
};
Rs.prototype._wnafMulAdd = function(e, t, r, i, s) {
  var a = this._wnafT1, o = this._wnafT2, u = this._wnafT3, l = 0, d, p, m;
  for (d = 0; d < i; d++) {
    m = t[d];
    var w = m._getNAFPoints(e);
    a[d] = w.wnd, o[d] = w.points;
  }
  for (d = i - 1; d >= 1; d -= 2) {
    var x = d - 1, T = d;
    if (a[x] !== 1 || a[T] !== 1) {
      u[x] = hd(r[x], a[x], this._bitLength), u[T] = hd(r[T], a[T], this._bitLength), l = Math.max(u[x].length, l), l = Math.max(u[T].length, l);
      continue;
    }
    var A = [
      t[x],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      t[T]
      /* 7 */
    ];
    t[x].y.cmp(t[T].y) === 0 ? (A[1] = t[x].add(t[T]), A[2] = t[x].toJ().mixedAdd(t[T].neg())) : t[x].y.cmp(t[T].y.redNeg()) === 0 ? (A[1] = t[x].toJ().mixedAdd(t[T]), A[2] = t[x].add(t[T].neg())) : (A[1] = t[x].toJ().mixedAdd(t[T]), A[2] = t[x].toJ().mixedAdd(t[T].neg()));
    var M = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], I = tM(r[x], r[T]);
    for (l = Math.max(I[0].length, l), u[x] = new Array(l), u[T] = new Array(l), p = 0; p < l; p++) {
      var B = I[0][p] | 0, k = I[1][p] | 0;
      u[x][p] = M[(B + 1) * 3 + (k + 1)], u[T][p] = 0, o[x] = A;
    }
  }
  var N = this.jpoint(null, null, null), U = this._wnafT4;
  for (d = l; d >= 0; d--) {
    for (var W = 0; d >= 0; ) {
      var G = !0;
      for (p = 0; p < i; p++)
        U[p] = u[p][d] | 0, U[p] !== 0 && (G = !1);
      if (!G)
        break;
      W++, d--;
    }
    if (d >= 0 && W++, N = N.dblp(W), d < 0)
      break;
    for (p = 0; p < i; p++) {
      var Y = U[p];
      Y !== 0 && (Y > 0 ? m = o[p][Y - 1 >> 1] : Y < 0 && (m = o[p][-Y - 1 >> 1].neg()), m.type === "affine" ? N = N.mixedAdd(m) : N = N.add(m));
    }
  }
  for (d = 0; d < i; d++)
    o[d] = null;
  return s ? N : N.toP();
};
function br(n, e) {
  this.curve = n, this.type = e, this.precomputed = null;
}
Rs.BasePoint = br;
br.prototype.eq = function() {
  throw new Error("Not implemented");
};
br.prototype.validate = function() {
  return this.curve.validate(this);
};
Rs.prototype.decodePoint = function(e, t) {
  e = rr.toArray(e, t);
  var r = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
    e[0] === 6 ? yd(e[e.length - 1] % 2 === 0) : e[0] === 7 && yd(e[e.length - 1] % 2 === 1);
    var i = this.point(
      e.slice(1, 1 + r),
      e.slice(1 + r, 1 + 2 * r)
    );
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r)
    return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
  throw new Error("Unknown point format");
};
br.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
br.prototype._encode = function(e) {
  var t = this.curve.p.byteLength(), r = this.getX().toArray("be", t);
  return e ? [this.getY().isEven() ? 2 : 3].concat(r) : [4].concat(r, this.getY().toArray("be", t));
};
br.prototype.encode = function(e, t) {
  return rr.encode(this._encode(t), e);
};
br.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var t = {
    doubles: null,
    naf: null,
    beta: null
  };
  return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this;
};
br.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
br.prototype._getDoubles = function(e, t) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var r = [this], i = this, s = 0; s < t; s += e) {
    for (var a = 0; a < e; a++)
      i = i.dbl();
    r.push(i);
  }
  return {
    step: e,
    points: r
  };
};
br.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var t = [this], r = (1 << e) - 1, i = r === 1 ? null : this.dbl(), s = 1; s < r; s++)
    t[s] = t[s - 1].add(i);
  return {
    wnd: e,
    points: t
  };
};
br.prototype._getBeta = function() {
  return null;
};
br.prototype.dblp = function(e) {
  for (var t = this, r = 0; r < e; r++)
    t = t.dbl();
  return t;
};
var Ty = qo(function(n) {
  typeof Object.create == "function" ? n.exports = function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : n.exports = function(t, r) {
    if (r) {
      t.super_ = r;
      var i = function() {
      };
      i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
    }
  };
}), nM = rr.assert;
function gr(n) {
  $a.call(this, "short", n), this.a = new ye(n.a, 16).toRed(this.red), this.b = new ye(n.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(n), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
Ty(gr, $a);
var rM = gr;
gr.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, r;
    if (e.beta)
      t = new ye(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      t = i[0].cmp(i[1]) < 0 ? i[0] : i[1], t = t.toRed(this.red);
    }
    if (e.lambda)
      r = new ye(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(t)) === 0 ? r = s[0] : (r = s[1], nM(this.g.mul(r).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var a;
    return e.basis ? a = e.basis.map(function(o) {
      return {
        a: new ye(o.a, 16),
        b: new ye(o.b, 16)
      };
    }) : a = this._getEndoBasis(r), {
      beta: t,
      lambda: r,
      basis: a
    };
  }
};
gr.prototype._getEndoRoots = function(e) {
  var t = e === this.p ? this.red : ye.mont(e), r = new ye(2).toRed(t).redInvm(), i = r.redNeg(), s = new ye(3).toRed(t).redNeg().redSqrt().redMul(r), a = i.redAdd(s).fromRed(), o = i.redSub(s).fromRed();
  return [a, o];
};
gr.prototype._getEndoBasis = function(e) {
  for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r = e, i = this.n.clone(), s = new ye(1), a = new ye(0), o = new ye(0), u = new ye(1), l, d, p, m, w, x, T, A = 0, M, I; r.cmpn(0) !== 0; ) {
    var B = i.div(r);
    M = i.sub(B.mul(r)), I = o.sub(B.mul(s));
    var k = u.sub(B.mul(a));
    if (!p && M.cmp(t) < 0)
      l = T.neg(), d = s, p = M.neg(), m = I;
    else if (p && ++A === 2)
      break;
    T = M, i = r, r = M, o = s, s = I, u = a, a = k;
  }
  w = M.neg(), x = I;
  var N = p.sqr().add(m.sqr()), U = w.sqr().add(x.sqr());
  return U.cmp(N) >= 0 && (w = l, x = d), p.negative && (p = p.neg(), m = m.neg()), w.negative && (w = w.neg(), x = x.neg()), [
    { a: p, b: m },
    { a: w, b: x }
  ];
};
gr.prototype._endoSplit = function(e) {
  var t = this.endo.basis, r = t[0], i = t[1], s = i.b.mul(e).divRound(this.n), a = r.b.neg().mul(e).divRound(this.n), o = s.mul(r.a), u = a.mul(i.a), l = s.mul(r.b), d = a.mul(i.b), p = e.sub(o).sub(u), m = l.add(d).neg();
  return { k1: p, k2: m };
};
gr.prototype.pointFromX = function(e, t) {
  e = new ye(e, 16), e.red || (e = e.toRed(this.red));
  var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = r.redSqrt();
  if (i.redSqr().redSub(r).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (t && !s || !t && s) && (i = i.redNeg()), this.point(e, i);
};
gr.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var t = e.x, r = e.y, i = this.a.redMul(t), s = t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);
  return r.redSqr().redISub(s).cmpn(0) === 0;
};
gr.prototype._endoWnafMulAdd = function(e, t, r) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, a = 0; a < e.length; a++) {
    var o = this._endoSplit(t[a]), u = e[a], l = u._getBeta();
    o.k1.negative && (o.k1.ineg(), u = u.neg(!0)), o.k2.negative && (o.k2.ineg(), l = l.neg(!0)), i[a * 2] = u, i[a * 2 + 1] = l, s[a * 2] = o.k1, s[a * 2 + 1] = o.k2;
  }
  for (var d = this._wnafMulAdd(1, i, s, a * 2, r), p = 0; p < a * 2; p++)
    i[p] = null, s[p] = null;
  return d;
};
function tn(n, e, t, r) {
  $a.BasePoint.call(this, n, "affine"), e === null && t === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new ye(e, 16), this.y = new ye(t, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
Ty(tn, $a.BasePoint);
gr.prototype.point = function(e, t, r) {
  return new tn(this, e, t, r);
};
gr.prototype.pointFromJSON = function(e, t) {
  return tn.fromJSON(this, e, t);
};
tn.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var r = this.curve, i = function(s) {
        return r.point(s.x.redMul(r.endo.beta), s.y);
      };
      e.beta = t, t.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(i)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(i)
        }
      };
    }
    return t;
  }
};
tn.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
tn.fromJSON = function(e, t, r) {
  typeof t == "string" && (t = JSON.parse(t));
  var i = e.point(t[0], t[1], r);
  if (!t[2])
    return i;
  function s(o) {
    return e.point(o[0], o[1], r);
  }
  var a = t[2];
  return i.precomputed = {
    beta: null,
    doubles: a.doubles && {
      step: a.doubles.step,
      points: [i].concat(a.doubles.points.map(s))
    },
    naf: a.naf && {
      wnd: a.naf.wnd,
      points: [i].concat(a.naf.points.map(s))
    }
  }, i;
};
tn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
tn.prototype.isInfinity = function() {
  return this.inf;
};
tn.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var r = t.redSqr().redISub(this.x).redISub(e.x), i = t.redMul(this.x.redSub(r)).redISub(this.y);
  return this.curve.point(r, i);
};
tn.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var t = this.curve.a, r = this.x.redSqr(), i = e.redInvm(), s = r.redAdd(r).redIAdd(r).redIAdd(t).redMul(i), a = s.redSqr().redISub(this.x.redAdd(this.x)), o = s.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, o);
};
tn.prototype.getX = function() {
  return this.x.fromRed();
};
tn.prototype.getY = function() {
  return this.y.fromRed();
};
tn.prototype.mul = function(e) {
  return e = new ye(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
tn.prototype.mulAdd = function(e, t, r) {
  var i = [this, t], s = [e, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
tn.prototype.jmulAdd = function(e, t, r) {
  var i = [this, t], s = [e, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
tn.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
tn.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var r = this.precomputed, i = function(s) {
      return s.neg();
    };
    t.precomputed = {
      naf: r.naf && {
        wnd: r.naf.wnd,
        points: r.naf.points.map(i)
      },
      doubles: r.doubles && {
        step: r.doubles.step,
        points: r.doubles.points.map(i)
      }
    };
  }
  return t;
};
tn.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function fn(n, e, t, r) {
  $a.BasePoint.call(this, n, "jacobian"), e === null && t === null && r === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new ye(0)) : (this.x = new ye(e, 16), this.y = new ye(t, 16), this.z = new ye(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
Ty(fn, $a.BasePoint);
gr.prototype.jpoint = function(e, t, r) {
  return new fn(this, e, t, r);
};
fn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), t = e.redSqr(), r = this.x.redMul(t), i = this.y.redMul(t).redMul(e);
  return this.curve.point(r, i);
};
fn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
fn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var t = e.z.redSqr(), r = this.z.redSqr(), i = this.x.redMul(t), s = e.x.redMul(r), a = this.y.redMul(t.redMul(e.z)), o = e.y.redMul(r.redMul(this.z)), u = i.redSub(s), l = a.redSub(o);
  if (u.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var d = u.redSqr(), p = d.redMul(u), m = i.redMul(d), w = l.redSqr().redIAdd(p).redISub(m).redISub(m), x = l.redMul(m.redISub(w)).redISub(a.redMul(p)), T = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(w, x, T);
};
fn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var t = this.z.redSqr(), r = this.x, i = e.x.redMul(t), s = this.y, a = e.y.redMul(t).redMul(this.z), o = r.redSub(i), u = s.redSub(a);
  if (o.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = o.redSqr(), d = l.redMul(o), p = r.redMul(l), m = u.redSqr().redIAdd(d).redISub(p).redISub(p), w = u.redMul(p.redISub(m)).redISub(s.redMul(d)), x = this.z.redMul(o);
  return this.curve.jpoint(m, w, x);
};
fn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (t = 0; t < e; t++)
      r = r.dbl();
    return r;
  }
  var i = this.curve.a, s = this.curve.tinv, a = this.x, o = this.y, u = this.z, l = u.redSqr().redSqr(), d = o.redAdd(o);
  for (t = 0; t < e; t++) {
    var p = a.redSqr(), m = d.redSqr(), w = m.redSqr(), x = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l)), T = a.redMul(m), A = x.redSqr().redISub(T.redAdd(T)), M = T.redISub(A), I = x.redMul(M);
    I = I.redIAdd(I).redISub(w);
    var B = d.redMul(u);
    t + 1 < e && (l = l.redMul(w)), a = A, u = B, d = I;
  }
  return this.curve.jpoint(a, d.redMul(s), u);
};
fn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
fn.prototype._zeroDbl = function() {
  var e, t, r;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), a = s.redSqr(), o = this.x.redAdd(s).redSqr().redISub(i).redISub(a);
    o = o.redIAdd(o);
    var u = i.redAdd(i).redIAdd(i), l = u.redSqr().redISub(o).redISub(o), d = a.redIAdd(a);
    d = d.redIAdd(d), d = d.redIAdd(d), e = l, t = u.redMul(o.redISub(l)).redISub(d), r = this.y.redAdd(this.y);
  } else {
    var p = this.x.redSqr(), m = this.y.redSqr(), w = m.redSqr(), x = this.x.redAdd(m).redSqr().redISub(p).redISub(w);
    x = x.redIAdd(x);
    var T = p.redAdd(p).redIAdd(p), A = T.redSqr(), M = w.redIAdd(w);
    M = M.redIAdd(M), M = M.redIAdd(M), e = A.redISub(x).redISub(x), t = T.redMul(x.redISub(e)).redISub(M), r = this.y.redMul(this.z), r = r.redIAdd(r);
  }
  return this.curve.jpoint(e, t, r);
};
fn.prototype._threeDbl = function() {
  var e, t, r;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), a = s.redSqr(), o = this.x.redAdd(s).redSqr().redISub(i).redISub(a);
    o = o.redIAdd(o);
    var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), l = u.redSqr().redISub(o).redISub(o);
    e = l;
    var d = a.redIAdd(a);
    d = d.redIAdd(d), d = d.redIAdd(d), t = u.redMul(o.redISub(l)).redISub(d), r = this.y.redAdd(this.y);
  } else {
    var p = this.z.redSqr(), m = this.y.redSqr(), w = this.x.redMul(m), x = this.x.redSub(p).redMul(this.x.redAdd(p));
    x = x.redAdd(x).redIAdd(x);
    var T = w.redIAdd(w);
    T = T.redIAdd(T);
    var A = T.redAdd(T);
    e = x.redSqr().redISub(A), r = this.y.redAdd(this.z).redSqr().redISub(m).redISub(p);
    var M = m.redSqr();
    M = M.redIAdd(M), M = M.redIAdd(M), M = M.redIAdd(M), t = x.redMul(T.redISub(e)).redISub(M);
  }
  return this.curve.jpoint(e, t, r);
};
fn.prototype._dbl = function() {
  var e = this.curve.a, t = this.x, r = this.y, i = this.z, s = i.redSqr().redSqr(), a = t.redSqr(), o = r.redSqr(), u = a.redAdd(a).redIAdd(a).redIAdd(e.redMul(s)), l = t.redAdd(t);
  l = l.redIAdd(l);
  var d = l.redMul(o), p = u.redSqr().redISub(d.redAdd(d)), m = d.redISub(p), w = o.redSqr();
  w = w.redIAdd(w), w = w.redIAdd(w), w = w.redIAdd(w);
  var x = u.redMul(m).redISub(w), T = r.redAdd(r).redMul(i);
  return this.curve.jpoint(p, x, T);
};
fn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), t = this.y.redSqr(), r = this.z.redSqr(), i = t.redSqr(), s = e.redAdd(e).redIAdd(e), a = s.redSqr(), o = this.x.redAdd(t).redSqr().redISub(e).redISub(i);
  o = o.redIAdd(o), o = o.redAdd(o).redIAdd(o), o = o.redISub(a);
  var u = o.redSqr(), l = i.redIAdd(i);
  l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
  var d = s.redIAdd(o).redSqr().redISub(a).redISub(u).redISub(l), p = t.redMul(d);
  p = p.redIAdd(p), p = p.redIAdd(p);
  var m = this.x.redMul(u).redISub(p);
  m = m.redIAdd(m), m = m.redIAdd(m);
  var w = this.y.redMul(d.redMul(l.redISub(d)).redISub(o.redMul(u)));
  w = w.redIAdd(w), w = w.redIAdd(w), w = w.redIAdd(w);
  var x = this.z.redAdd(o).redSqr().redISub(r).redISub(u);
  return this.curve.jpoint(m, w, x);
};
fn.prototype.mul = function(e, t) {
  return e = new ye(e, t), this.curve._wnafMul(this, e);
};
fn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var t = this.z.redSqr(), r = e.z.redSqr();
  if (this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0) !== 0)
    return !1;
  var i = t.redMul(this.z), s = r.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
fn.prototype.eqXToP = function(e) {
  var t = this.z.redSqr(), r = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(r) === 0)
    return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(t); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (r.redIAdd(s), this.x.cmp(r) === 0)
      return !0;
  }
};
fn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
fn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Ic = qo(function(n, e) {
  var t = e;
  t.base = $a, t.short = rM, t.mont = /*RicMoo:ethers:require(./mont)*/
  null, t.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), Oc = qo(function(n, e) {
  var t = e, r = rr.assert;
  function i(o) {
    o.type === "short" ? this.curve = new Ic.short(o) : o.type === "edwards" ? this.curve = new Ic.edwards(o) : this.curve = new Ic.mont(o), this.g = this.curve.g, this.n = this.curve.n, this.hash = o.hash, r(this.g.validate(), "Invalid curve"), r(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = i;
  function s(o, u) {
    Object.defineProperty(t, o, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var l = new i(u);
        return Object.defineProperty(t, o, {
          configurable: !0,
          enumerable: !0,
          value: l
        }), l;
      }
    });
  }
  s("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Dn.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), s("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Dn.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), s("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Dn.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), s("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Dn.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), s("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Dn.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), s("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Dn.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), s("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Dn.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var a;
  try {
    a = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    a = void 0;
  }
  s("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Dn.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      a
    ]
  });
});
function ws(n) {
  if (!(this instanceof ws))
    return new ws(n);
  this.hash = n.hash, this.predResist = !!n.predResist, this.outLen = this.hash.outSize, this.minEntropy = n.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = Ir.toArray(n.entropy, n.entropyEnc || "hex"), t = Ir.toArray(n.nonce, n.nonceEnc || "hex"), r = Ir.toArray(n.pers, n.persEnc || "hex");
  wy(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, t, r);
}
var u6 = ws;
ws.prototype._init = function(e, t, r) {
  var i = e.concat(t).concat(r);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
};
ws.prototype._hmac = function() {
  return new Dn.hmac(this.hash, this.K);
};
ws.prototype._update = function(e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
ws.prototype.reseed = function(e, t, r, i) {
  typeof t != "string" && (i = r, r = t, t = null), e = Ir.toArray(e, t), r = Ir.toArray(r, i), wy(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(r || [])), this._reseed = 1;
};
ws.prototype.generate = function(e, t, r, i) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof t != "string" && (i = r, r = t, t = null), r && (r = Ir.toArray(r, i || "hex"), this._update(r));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var a = s.slice(0, e);
  return this._update(r), this._reseed++, Ir.encode(a, t);
};
var Ph = rr.assert;
function Tn(n, e) {
  this.ec = n, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var Ay = Tn;
Tn.fromPublic = function(e, t, r) {
  return t instanceof Tn ? t : new Tn(e, {
    pub: t,
    pubEnc: r
  });
};
Tn.fromPrivate = function(e, t, r) {
  return t instanceof Tn ? t : new Tn(e, {
    priv: t,
    privEnc: r
  });
};
Tn.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
Tn.prototype.getPublic = function(e, t) {
  return typeof e == "string" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;
};
Tn.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
Tn.prototype._importPrivate = function(e, t) {
  this.priv = new ye(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
Tn.prototype._importPublic = function(e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? Ph(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Ph(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
Tn.prototype.derive = function(e) {
  return e.validate() || Ph(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
Tn.prototype.sign = function(e, t, r) {
  return this.ec.sign(e, this, t, r);
};
Tn.prototype.verify = function(e, t) {
  return this.ec.verify(e, t, this);
};
Tn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var iM = rr.assert;
function uf(n, e) {
  if (n instanceof uf)
    return n;
  this._importDER(n, e) || (iM(n.r && n.s, "Signature without r or s"), this.r = new ye(n.r, 16), this.s = new ye(n.s, 16), n.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = n.recoveryParam);
}
var lf = uf;
function sM() {
  this.place = 0;
}
function Ep(n, e) {
  var t = n[e.place++];
  if (!(t & 128))
    return t;
  var r = t & 15;
  if (r === 0 || r > 4)
    return !1;
  for (var i = 0, s = 0, a = e.place; s < r; s++, a++)
    i <<= 8, i |= n[a], i >>>= 0;
  return i <= 127 ? !1 : (e.place = a, i);
}
function ux(n) {
  for (var e = 0, t = n.length - 1; !n[e] && !(n[e + 1] & 128) && e < t; )
    e++;
  return e === 0 ? n : n.slice(e);
}
uf.prototype._importDER = function(e, t) {
  e = rr.toArray(e, t);
  var r = new sM();
  if (e[r.place++] !== 48)
    return !1;
  var i = Ep(e, r);
  if (i === !1 || i + r.place !== e.length || e[r.place++] !== 2)
    return !1;
  var s = Ep(e, r);
  if (s === !1)
    return !1;
  var a = e.slice(r.place, s + r.place);
  if (r.place += s, e[r.place++] !== 2)
    return !1;
  var o = Ep(e, r);
  if (o === !1 || e.length !== o + r.place)
    return !1;
  var u = e.slice(r.place, o + r.place);
  if (a[0] === 0)
    if (a[1] & 128)
      a = a.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new ye(a), this.s = new ye(u), this.recoveryParam = null, !0;
};
function Sp(n, e) {
  if (e < 128) {
    n.push(e);
    return;
  }
  var t = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (n.push(t | 128); --t; )
    n.push(e >>> (t << 3) & 255);
  n.push(e);
}
uf.prototype.toDER = function(e) {
  var t = this.r.toArray(), r = this.s.toArray();
  for (t[0] & 128 && (t = [0].concat(t)), r[0] & 128 && (r = [0].concat(r)), t = ux(t), r = ux(r); !r[0] && !(r[1] & 128); )
    r = r.slice(1);
  var i = [2];
  Sp(i, t.length), i = i.concat(t), i.push(2), Sp(i, r.length);
  var s = i.concat(r), a = [48];
  return Sp(a, s.length), a = a.concat(s), rr.encode(a, e);
};
var aM = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), l6 = rr.assert;
function yr(n) {
  if (!(this instanceof yr))
    return new yr(n);
  typeof n == "string" && (l6(
    Object.prototype.hasOwnProperty.call(Oc, n),
    "Unknown curve " + n
  ), n = Oc[n]), n instanceof Oc.PresetCurve && (n = { curve: n }), this.curve = n.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = n.curve.g, this.g.precompute(n.curve.n.bitLength() + 1), this.hash = n.hash || n.curve.hash;
}
var oM = yr;
yr.prototype.keyPair = function(e) {
  return new Ay(this, e);
};
yr.prototype.keyFromPrivate = function(e, t) {
  return Ay.fromPrivate(this, e, t);
};
yr.prototype.keyFromPublic = function(e, t) {
  return Ay.fromPublic(this, e, t);
};
yr.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var t = new u6({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || aM(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), r = this.n.byteLength(), i = this.n.sub(new ye(2)); ; ) {
    var s = new ye(t.generate(r));
    if (!(s.cmp(i) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
yr.prototype._truncateToN = function(e, t) {
  var r = e.byteLength() * 8 - this.n.bitLength();
  return r > 0 && (e = e.ushrn(r)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
yr.prototype.sign = function(e, t, r, i) {
  typeof r == "object" && (i = r, r = null), i || (i = {}), t = this.keyFromPrivate(t, r), e = this._truncateToN(new ye(e, 16));
  for (var s = this.n.byteLength(), a = t.getPrivate().toArray("be", s), o = e.toArray("be", s), u = new u6({
    hash: this.hash,
    entropy: a,
    nonce: o,
    pers: i.pers,
    persEnc: i.persEnc || "utf8"
  }), l = this.n.sub(new ye(1)), d = 0; ; d++) {
    var p = i.k ? i.k(d) : new ye(u.generate(this.n.byteLength()));
    if (p = this._truncateToN(p, !0), !(p.cmpn(1) <= 0 || p.cmp(l) >= 0)) {
      var m = this.g.mul(p);
      if (!m.isInfinity()) {
        var w = m.getX(), x = w.umod(this.n);
        if (x.cmpn(0) !== 0) {
          var T = p.invm(this.n).mul(x.mul(t.getPrivate()).iadd(e));
          if (T = T.umod(this.n), T.cmpn(0) !== 0) {
            var A = (m.getY().isOdd() ? 1 : 0) | (w.cmp(x) !== 0 ? 2 : 0);
            return i.canonical && T.cmp(this.nh) > 0 && (T = this.n.sub(T), A ^= 1), new lf({ r: x, s: T, recoveryParam: A });
          }
        }
      }
    }
  }
};
yr.prototype.verify = function(e, t, r, i) {
  e = this._truncateToN(new ye(e, 16)), r = this.keyFromPublic(r, i), t = new lf(t, "hex");
  var s = t.r, a = t.s;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0)
    return !1;
  var o = a.invm(this.n), u = o.mul(e).umod(this.n), l = o.mul(s).umod(this.n), d;
  return this.curve._maxwellTrick ? (d = this.g.jmulAdd(u, r.getPublic(), l), d.isInfinity() ? !1 : d.eqXToP(s)) : (d = this.g.mulAdd(u, r.getPublic(), l), d.isInfinity() ? !1 : d.getX().umod(this.n).cmp(s) === 0);
};
yr.prototype.recoverPubKey = function(n, e, t, r) {
  l6((3 & t) === t, "The recovery param is more than two bits"), e = new lf(e, r);
  var i = this.n, s = new ye(n), a = e.r, o = e.s, u = t & 1, l = t >> 1;
  if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
    throw new Error("Unable to find sencond key candinate");
  l ? a = this.curve.pointFromX(a.add(this.curve.n), u) : a = this.curve.pointFromX(a, u);
  var d = e.r.invm(i), p = i.sub(s).mul(d).umod(i), m = o.mul(d).umod(i);
  return this.g.mulAdd(p, a, m);
};
yr.prototype.getKeyRecoveryParam = function(n, e, t, r) {
  if (e = new lf(e, r), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(n, e, i);
    } catch {
      continue;
    }
    if (s.eq(t))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var uM = qo(function(n, e) {
  var t = e;
  t.version = "6.5.4", t.utils = rr, t.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, t.curve = Ic, t.curves = Oc, t.ec = oM, t.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), lM = uM.ec;
const cM = "signing-key/5.7.0", Rh = new D(cM);
let Cp = null;
function zr() {
  return Cp || (Cp = new lM("secp256k1")), Cp;
}
class ca {
  constructor(e) {
    j(this, "curve", "secp256k1"), j(this, "privateKey", J(e)), ni(this.privateKey) !== 32 && Rh.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const t = zr().keyFromPrivate(q(this.privateKey));
    j(this, "publicKey", "0x" + t.getPublic(!1, "hex")), j(this, "compressedPublicKey", "0x" + t.getPublic(!0, "hex")), j(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const t = zr().keyFromPublic(q(this.publicKey)), r = zr().keyFromPublic(q(e));
    return "0x" + t.pub.add(r.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const t = zr().keyFromPrivate(q(this.privateKey)), r = q(e);
    r.length !== 32 && Rh.throwArgumentError("bad digest length", "digest", e);
    const i = t.sign(r, { canonical: !0 });
    return Ba({
      recoveryParam: i.recoveryParam,
      r: Le("0x" + i.r.toString(16), 32),
      s: Le("0x" + i.s.toString(16), 32)
    });
  }
  computeSharedSecret(e) {
    const t = zr().keyFromPrivate(q(this.privateKey)), r = zr().keyFromPublic(q(Ey(e)));
    return Le("0x" + t.derive(r.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function c6(n, e) {
  const t = Ba(e), r = { r: q(t.r), s: q(t.s) };
  return "0x" + zr().recoverPubKey(q(n), r, t.recoveryParam).encode("hex", !1);
}
function Ey(n, e) {
  const t = q(n);
  if (t.length === 32) {
    const r = new ca(t);
    return e ? "0x" + zr().keyFromPrivate(t).getPublic(!0, "hex") : r.publicKey;
  } else {
    if (t.length === 33)
      return e ? J(t) : "0x" + zr().keyFromPublic(t).getPublic(!1, "hex");
    if (t.length === 65)
      return e ? "0x" + zr().keyFromPublic(t).getPublic(!0, "hex") : J(t);
  }
  return Rh.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const dM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SigningKey: ca,
  computePublicKey: Ey,
  recoverPublicKey: c6
}, Symbol.toStringTag, { value: "Module" })), fM = "transactions/5.7.0", vn = new D(fM);
var Ih;
(function(n) {
  n[n.legacy = 0] = "legacy", n[n.eip2930 = 1] = "eip2930", n[n.eip1559 = 2] = "eip1559";
})(Ih || (Ih = {}));
function Sy(n) {
  return n === "0x" ? null : Fe(n);
}
function gn(n) {
  return n === "0x" ? fy : H.from(n);
}
const pM = [
  { name: "nonce", maxLength: 32, numeric: !0 },
  { name: "gasPrice", maxLength: 32, numeric: !0 },
  { name: "gasLimit", maxLength: 32, numeric: !0 },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: !0 },
  { name: "data" }
], hM = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  type: !0,
  value: !0
};
function ps(n) {
  const e = Ey(n);
  return Fe(Bt(De(Bt(e, 1)), 12));
}
function Wo(n, e) {
  return ps(c6(q(n), e));
}
function Qn(n, e) {
  const t = Qr(H.from(n).toHexString());
  return t.length > 32 && vn.throwArgumentError("invalid length for " + e, "transaction:" + e, n), t;
}
function _p(n, e) {
  return {
    address: Fe(n),
    storageKeys: (e || []).map((t, r) => (ni(t) !== 32 && vn.throwArgumentError("invalid access list storageKey", `accessList[${n}:${r}]`, t), t.toLowerCase()))
  };
}
function Ua(n) {
  if (Array.isArray(n))
    return n.map((t, r) => Array.isArray(t) ? (t.length > 2 && vn.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${r}]`, t), _p(t[0], t[1])) : _p(t.address, t.storageKeys));
  const e = Object.keys(n).map((t) => {
    const r = n[t].reduce((i, s) => (i[s] = !0, i), {});
    return _p(t, Object.keys(r).sort());
  });
  return e.sort((t, r) => t.address.localeCompare(r.address)), e;
}
function d6(n) {
  return Ua(n).map((e) => [e.address, e.storageKeys]);
}
function f6(n, e) {
  if (n.gasPrice != null) {
    const r = H.from(n.gasPrice), i = H.from(n.maxFeePerGas || 0);
    r.eq(i) || vn.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
      gasPrice: r,
      maxFeePerGas: i
    });
  }
  const t = [
    Qn(n.chainId || 0, "chainId"),
    Qn(n.nonce || 0, "nonce"),
    Qn(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Qn(n.maxFeePerGas || 0, "maxFeePerGas"),
    Qn(n.gasLimit || 0, "gasLimit"),
    n.to != null ? Fe(n.to) : "0x",
    Qn(n.value || 0, "value"),
    n.data || "0x",
    d6(n.accessList || [])
  ];
  if (e) {
    const r = Ba(e);
    t.push(Qn(r.recoveryParam, "recoveryParam")), t.push(Qr(r.r)), t.push(Qr(r.s));
  }
  return Sn(["0x02", vs(t)]);
}
function p6(n, e) {
  const t = [
    Qn(n.chainId || 0, "chainId"),
    Qn(n.nonce || 0, "nonce"),
    Qn(n.gasPrice || 0, "gasPrice"),
    Qn(n.gasLimit || 0, "gasLimit"),
    n.to != null ? Fe(n.to) : "0x",
    Qn(n.value || 0, "value"),
    n.data || "0x",
    d6(n.accessList || [])
  ];
  if (e) {
    const r = Ba(e);
    t.push(Qn(r.recoveryParam, "recoveryParam")), t.push(Qr(r.r)), t.push(Qr(r.s));
  }
  return Sn(["0x01", vs(t)]);
}
function yM(n, e) {
  uy(n, hM);
  const t = [];
  pM.forEach(function(a) {
    let o = n[a.name] || [];
    const u = {};
    a.numeric && (u.hexPad = "left"), o = q(J(o, u)), a.length && o.length !== a.length && o.length > 0 && vn.throwArgumentError("invalid length for " + a.name, "transaction:" + a.name, o), a.maxLength && (o = Qr(o), o.length > a.maxLength && vn.throwArgumentError("invalid length for " + a.name, "transaction:" + a.name, o)), t.push(J(o));
  });
  let r = 0;
  if (n.chainId != null ? (r = n.chainId, typeof r != "number" && vn.throwArgumentError("invalid transaction.chainId", "transaction", n)) : e && !Il(e) && e.v > 28 && (r = Math.floor((e.v - 35) / 2)), r !== 0 && (t.push(J(r)), t.push("0x"), t.push("0x")), !e)
    return vs(t);
  const i = Ba(e);
  let s = 27 + i.recoveryParam;
  return r !== 0 ? (t.pop(), t.pop(), t.pop(), s += r * 2 + 8, i.v > 28 && i.v !== s && vn.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e)) : i.v !== s && vn.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e), t.push(J(s)), t.push(Qr(q(i.r))), t.push(Qr(q(i.s))), vs(t);
}
function Oh(n, e) {
  if (n.type == null || n.type === 0)
    return n.accessList != null && vn.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", n), yM(n, e);
  switch (n.type) {
    case 1:
      return p6(n, e);
    case 2:
      return f6(n, e);
  }
  return vn.throwError(`unsupported transaction type: ${n.type}`, D.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: n.type
  });
}
function h6(n, e, t) {
  try {
    const r = gn(e[0]).toNumber();
    if (r !== 0 && r !== 1)
      throw new Error("bad recid");
    n.v = r;
  } catch {
    vn.throwArgumentError("invalid v for transaction type: 1", "v", e[0]);
  }
  n.r = Le(e[1], 32), n.s = Le(e[2], 32);
  try {
    const r = De(t(n));
    n.from = Wo(r, { r: n.r, s: n.s, recoveryParam: n.v });
  } catch {
  }
}
function mM(n) {
  const e = kl(n.slice(1));
  e.length !== 9 && e.length !== 12 && vn.throwArgumentError("invalid component count for transaction type: 2", "payload", J(n));
  const t = gn(e[2]), r = gn(e[3]), i = {
    type: 2,
    chainId: gn(e[0]).toNumber(),
    nonce: gn(e[1]).toNumber(),
    maxPriorityFeePerGas: t,
    maxFeePerGas: r,
    gasPrice: null,
    gasLimit: gn(e[4]),
    to: Sy(e[5]),
    value: gn(e[6]),
    data: e[7],
    accessList: Ua(e[8])
  };
  return e.length === 9 || (i.hash = De(n), h6(i, e.slice(9), f6)), i;
}
function bM(n) {
  const e = kl(n.slice(1));
  e.length !== 8 && e.length !== 11 && vn.throwArgumentError("invalid component count for transaction type: 1", "payload", J(n));
  const t = {
    type: 1,
    chainId: gn(e[0]).toNumber(),
    nonce: gn(e[1]).toNumber(),
    gasPrice: gn(e[2]),
    gasLimit: gn(e[3]),
    to: Sy(e[4]),
    value: gn(e[5]),
    data: e[6],
    accessList: Ua(e[7])
  };
  return e.length === 8 || (t.hash = De(n), h6(t, e.slice(8), p6)), t;
}
function gM(n) {
  const e = kl(n);
  e.length !== 9 && e.length !== 6 && vn.throwArgumentError("invalid raw transaction", "rawTransaction", n);
  const t = {
    nonce: gn(e[0]).toNumber(),
    gasPrice: gn(e[1]),
    gasLimit: gn(e[2]),
    to: Sy(e[3]),
    value: gn(e[4]),
    data: e[5],
    chainId: 0
  };
  if (e.length === 6)
    return t;
  try {
    t.v = H.from(e[6]).toNumber();
  } catch {
    return t;
  }
  if (t.r = Le(e[7], 32), t.s = Le(e[8], 32), H.from(t.r).isZero() && H.from(t.s).isZero())
    t.chainId = t.v, t.v = 0;
  else {
    t.chainId = Math.floor((t.v - 35) / 2), t.chainId < 0 && (t.chainId = 0);
    let r = t.v - 27;
    const i = e.slice(0, 6);
    t.chainId !== 0 && (i.push(J(t.chainId)), i.push("0x"), i.push("0x"), r -= t.chainId * 2 + 8);
    const s = De(vs(i));
    try {
      t.from = Wo(s, { r: J(t.r), s: J(t.s), recoveryParam: r });
    } catch {
    }
    t.hash = De(n);
  }
  return t.type = null, t;
}
function y6(n) {
  const e = q(n);
  if (e[0] > 127)
    return gM(e);
  switch (e[0]) {
    case 1:
      return bM(e);
    case 2:
      return mM(e);
  }
  return vn.throwError(`unsupported transaction type: ${e[0]}`, D.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: e[0]
  });
}
const xM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TransactionTypes() {
    return Ih;
  },
  accessListify: Ua,
  computeAddress: ps,
  parse: y6,
  recoverAddress: Wo,
  serialize: Oh
}, Symbol.toStringTag, { value: "Module" })), vM = "contracts/5.7.0";
var xa = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const Nt = new D(vM);
function md(n, e) {
  return xa(this, void 0, void 0, function* () {
    const t = yield e;
    typeof t != "string" && Nt.throwArgumentError("invalid address or ENS name", "name", t);
    try {
      return Fe(t);
    } catch {
    }
    n || Nt.throwError("a provider or signer is needed to resolve ENS names", D.errors.UNSUPPORTED_OPERATION, {
      operation: "resolveName"
    });
    const r = yield n.resolveName(t);
    return r == null && Nt.throwArgumentError("resolver or addr is not configured for ENS name", "name", t), r;
  });
}
function kc(n, e, t) {
  return xa(this, void 0, void 0, function* () {
    return Array.isArray(t) ? yield Promise.all(t.map((r, i) => kc(n, Array.isArray(e) ? e[i] : e[r.name], r))) : t.type === "address" ? yield md(n, e) : t.type === "tuple" ? yield kc(n, e, t.components) : t.baseType === "array" ? Array.isArray(e) ? yield Promise.all(e.map((r) => kc(n, r, t.arrayChildren))) : Promise.reject(Nt.makeError("invalid value for array", D.errors.INVALID_ARGUMENT, {
      argument: "value",
      value: e
    })) : e;
  });
}
function cf(n, e, t) {
  return xa(this, void 0, void 0, function* () {
    let r = {};
    t.length === e.inputs.length + 1 && typeof t[t.length - 1] == "object" && (r = zt(t.pop())), Nt.checkArgumentCount(t.length, e.inputs.length, "passed to contract"), n.signer ? r.from ? r.from = Rt({
      override: md(n.signer, r.from),
      signer: n.signer.getAddress()
    }).then((l) => xa(this, void 0, void 0, function* () {
      return Fe(l.signer) !== l.override && Nt.throwError("Contract with a Signer cannot override from", D.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.from"
      }), l.override;
    })) : r.from = n.signer.getAddress() : r.from && (r.from = md(n.provider, r.from));
    const i = yield Rt({
      args: kc(n.signer || n.provider, t, e.inputs),
      address: n.resolvedAddress,
      overrides: Rt(r) || {}
    }), s = n.interface.encodeFunctionData(e, i.args), a = {
      data: s,
      to: i.address
    }, o = i.overrides;
    if (o.nonce != null && (a.nonce = H.from(o.nonce).toNumber()), o.gasLimit != null && (a.gasLimit = H.from(o.gasLimit)), o.gasPrice != null && (a.gasPrice = H.from(o.gasPrice)), o.maxFeePerGas != null && (a.maxFeePerGas = H.from(o.maxFeePerGas)), o.maxPriorityFeePerGas != null && (a.maxPriorityFeePerGas = H.from(o.maxPriorityFeePerGas)), o.from != null && (a.from = o.from), o.type != null && (a.type = o.type), o.accessList != null && (a.accessList = Ua(o.accessList)), a.gasLimit == null && e.gas != null) {
      let l = 21e3;
      const d = q(s);
      for (let p = 0; p < d.length; p++)
        l += 4, d[p] && (l += 64);
      a.gasLimit = H.from(e.gas).add(l);
    }
    if (o.value) {
      const l = H.from(o.value);
      !l.isZero() && !e.payable && Nt.throwError("non-payable method cannot override value", D.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.value",
        value: r.value
      }), a.value = l;
    }
    o.customData && (a.customData = zt(o.customData)), o.ccipReadEnabled && (a.ccipReadEnabled = !!o.ccipReadEnabled), delete r.nonce, delete r.gasLimit, delete r.gasPrice, delete r.from, delete r.value, delete r.type, delete r.accessList, delete r.maxFeePerGas, delete r.maxPriorityFeePerGas, delete r.customData, delete r.ccipReadEnabled;
    const u = Object.keys(r).filter((l) => r[l] != null);
    return u.length && Nt.throwError(`cannot override ${u.map((l) => JSON.stringify(l)).join(",")}`, D.errors.UNSUPPORTED_OPERATION, {
      operation: "overrides",
      overrides: u
    }), a;
  });
}
function wM(n, e) {
  return function(...t) {
    return cf(n, e, t);
  };
}
function TM(n, e) {
  const t = n.signer || n.provider;
  return function(...r) {
    return xa(this, void 0, void 0, function* () {
      t || Nt.throwError("estimate require a provider or signer", D.errors.UNSUPPORTED_OPERATION, {
        operation: "estimateGas"
      });
      const i = yield cf(n, e, r);
      return yield t.estimateGas(i);
    });
  };
}
function AM(n, e) {
  const t = e.wait.bind(e);
  e.wait = (r) => t(r).then((i) => (i.events = i.logs.map((s) => {
    let a = xs(s), o = null;
    try {
      o = n.interface.parseLog(s);
    } catch {
    }
    return o && (a.args = o.args, a.decode = (u, l) => n.interface.decodeEventLog(o.eventFragment, u, l), a.event = o.name, a.eventSignature = o.signature), a.removeListener = () => n.provider, a.getBlock = () => n.provider.getBlock(i.blockHash), a.getTransaction = () => n.provider.getTransaction(i.transactionHash), a.getTransactionReceipt = () => Promise.resolve(i), a;
  }), i));
}
function m6(n, e, t) {
  const r = n.signer || n.provider;
  return function(...i) {
    return xa(this, void 0, void 0, function* () {
      let s;
      if (i.length === e.inputs.length + 1 && typeof i[i.length - 1] == "object") {
        const u = zt(i.pop());
        u.blockTag != null && (s = yield u.blockTag), delete u.blockTag, i.push(u);
      }
      n.deployTransaction != null && (yield n._deployed(s));
      const a = yield cf(n, e, i), o = yield r.call(a, s);
      try {
        let u = n.interface.decodeFunctionResult(e, o);
        return t && e.outputs.length === 1 && (u = u[0]), u;
      } catch (u) {
        throw u.code === D.errors.CALL_EXCEPTION && (u.address = n.address, u.args = i, u.transaction = a), u;
      }
    });
  };
}
function EM(n, e) {
  return function(...t) {
    return xa(this, void 0, void 0, function* () {
      n.signer || Nt.throwError("sending a transaction requires a signer", D.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction"
      }), n.deployTransaction != null && (yield n._deployed());
      const r = yield cf(n, e, t), i = yield n.signer.sendTransaction(r);
      return AM(n, i), i;
    });
  };
}
function lx(n, e, t) {
  return e.constant ? m6(n, e, t) : EM(n, e);
}
function b6(n) {
  return n.address && (n.topics == null || n.topics.length === 0) ? "*" : (n.address || "*") + "@" + (n.topics ? n.topics.map((e) => Array.isArray(e) ? e.join("|") : e).join(":") : "");
}
class Xu {
  constructor(e, t) {
    j(this, "tag", e), j(this, "filter", t), this._listeners = [];
  }
  addListener(e, t) {
    this._listeners.push({ listener: e, once: t });
  }
  removeListener(e) {
    let t = !1;
    this._listeners = this._listeners.filter((r) => t || r.listener !== e ? !0 : (t = !0, !1));
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((e) => e.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(e) {
    const t = this.listenerCount();
    return this._listeners = this._listeners.filter((r) => {
      const i = e.slice();
      return setTimeout(() => {
        r.listener.apply(this, i);
      }, 0), !r.once;
    }), t;
  }
  prepareEvent(e) {
  }
  // Returns the array that will be applied to an emit
  getEmit(e) {
    return [e];
  }
}
class SM extends Xu {
  constructor() {
    super("error", null);
  }
}
class cx extends Xu {
  constructor(e, t, r, i) {
    const s = {
      address: e
    };
    let a = t.getEventTopic(r);
    i ? (a !== i[0] && Nt.throwArgumentError("topic mismatch", "topics", i), s.topics = i.slice()) : s.topics = [a], super(b6(s), s), j(this, "address", e), j(this, "interface", t), j(this, "fragment", r);
  }
  prepareEvent(e) {
    super.prepareEvent(e), e.event = this.fragment.name, e.eventSignature = this.fragment.format(), e.decode = (t, r) => this.interface.decodeEventLog(this.fragment, t, r);
    try {
      e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics);
    } catch (t) {
      e.args = null, e.decodeError = t;
    }
  }
  getEmit(e) {
    const t = uw(e.args);
    if (t.length)
      throw t[0].error;
    const r = (e.args || []).slice();
    return r.push(e), r;
  }
}
class dx extends Xu {
  constructor(e, t) {
    super("*", { address: e }), j(this, "address", e), j(this, "interface", t);
  }
  prepareEvent(e) {
    super.prepareEvent(e);
    try {
      const t = this.interface.parseLog(e);
      e.event = t.name, e.eventSignature = t.signature, e.decode = (r, i) => this.interface.decodeEventLog(t.eventFragment, r, i), e.args = t.args;
    } catch {
    }
  }
}
class CM {
  constructor(e, t, r) {
    j(this, "interface", Rr(new.target, "getInterface")(t)), r == null ? (j(this, "provider", null), j(this, "signer", null)) : La.isSigner(r) ? (j(this, "provider", r.provider || null), j(this, "signer", r)) : xy.isProvider(r) ? (j(this, "provider", r), j(this, "signer", null)) : Nt.throwArgumentError("invalid signer or provider", "signerOrProvider", r), j(this, "callStatic", {}), j(this, "estimateGas", {}), j(this, "functions", {}), j(this, "populateTransaction", {}), j(this, "filters", {});
    {
      const a = {};
      Object.keys(this.interface.events).forEach((o) => {
        const u = this.interface.events[o];
        j(this.filters, o, (...l) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(u, l)
        })), a[u.name] || (a[u.name] = []), a[u.name].push(o);
      }), Object.keys(a).forEach((o) => {
        const u = a[o];
        u.length === 1 ? j(this.filters, o, this.filters[u[0]]) : Nt.warn(`Duplicate definition of ${o} (${u.join(", ")})`);
      });
    }
    if (j(this, "_runningEvents", {}), j(this, "_wrappedEmits", {}), e == null && Nt.throwArgumentError("invalid contract address or ENS name", "addressOrName", e), j(this, "address", e), this.provider)
      j(this, "resolvedAddress", md(this.provider, e));
    else
      try {
        j(this, "resolvedAddress", Promise.resolve(Fe(e)));
      } catch {
        Nt.throwError("provider is required to use ENS name as contract address", D.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    this.resolvedAddress.catch((a) => {
    });
    const i = {}, s = {};
    Object.keys(this.interface.functions).forEach((a) => {
      const o = this.interface.functions[a];
      if (s[a]) {
        Nt.warn(`Duplicate ABI entry for ${JSON.stringify(a)}`);
        return;
      }
      s[a] = !0;
      {
        const u = o.name;
        i[`%${u}`] || (i[`%${u}`] = []), i[`%${u}`].push(a);
      }
      this[a] == null && j(this, a, lx(this, o, !0)), this.functions[a] == null && j(this.functions, a, lx(this, o, !1)), this.callStatic[a] == null && j(this.callStatic, a, m6(this, o, !0)), this.populateTransaction[a] == null && j(this.populateTransaction, a, wM(this, o)), this.estimateGas[a] == null && j(this.estimateGas, a, TM(this, o));
    }), Object.keys(i).forEach((a) => {
      const o = i[a];
      if (o.length > 1)
        return;
      a = a.substring(1);
      const u = o[0];
      try {
        this[a] == null && j(this, a, this[u]);
      } catch {
      }
      this.functions[a] == null && j(this.functions, a, this.functions[u]), this.callStatic[a] == null && j(this.callStatic, a, this.callStatic[u]), this.populateTransaction[a] == null && j(this.populateTransaction, a, this.populateTransaction[u]), this.estimateGas[a] == null && j(this.estimateGas, a, this.estimateGas[u]);
    });
  }
  static getContractAddress(e) {
    return dy(e);
  }
  static getInterface(e) {
    return Sh.isInterface(e) ? e : new Sh(e);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(e) {
    return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, e).then((t) => (t === "0x" && Nt.throwError("contract not deployed", D.errors.UNSUPPORTED_OPERATION, {
      contractAddress: this.address,
      operation: "getDeployed"
    }), this))), this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(e) {
    this.signer || Nt.throwError("sending a transactions require a signer", D.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    const t = zt(e || {});
    return ["from", "to"].forEach(function(r) {
      t[r] != null && Nt.throwError("cannot override " + r, D.errors.UNSUPPORTED_OPERATION, { operation: r });
    }), t.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(t));
  }
  // Reconnect to a different signer or provider
  connect(e) {
    typeof e == "string" && (e = new vy(e, this.provider));
    const t = new this.constructor(this.address, this.interface, e);
    return this.deployTransaction && j(t, "deployTransaction", this.deployTransaction), t;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(e) {
    return new this.constructor(e, this.interface, this.signer || this.provider);
  }
  static isIndexed(e) {
    return pd.isIndexed(e);
  }
  _normalizeRunningEvent(e) {
    return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e;
  }
  _getRunningEvent(e) {
    if (typeof e == "string") {
      if (e === "error")
        return this._normalizeRunningEvent(new SM());
      if (e === "event")
        return this._normalizeRunningEvent(new Xu("event", null));
      if (e === "*")
        return this._normalizeRunningEvent(new dx(this.address, this.interface));
      const t = this.interface.getEvent(e);
      return this._normalizeRunningEvent(new cx(this.address, this.interface, t));
    }
    if (e.topics && e.topics.length > 0) {
      try {
        const r = e.topics[0];
        if (typeof r != "string")
          throw new Error("invalid topic");
        const i = this.interface.getEvent(r);
        return this._normalizeRunningEvent(new cx(this.address, this.interface, i, e.topics));
      } catch {
      }
      const t = {
        address: this.address,
        topics: e.topics
      };
      return this._normalizeRunningEvent(new Xu(b6(t), t));
    }
    return this._normalizeRunningEvent(new dx(this.address, this.interface));
  }
  _checkRunningEvents(e) {
    if (e.listenerCount() === 0) {
      delete this._runningEvents[e.tag];
      const t = this._wrappedEmits[e.tag];
      t && e.filter && (this.provider.off(e.filter, t), delete this._wrappedEmits[e.tag]);
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(e, t, r) {
    const i = xs(t);
    return i.removeListener = () => {
      r && (e.removeListener(r), this._checkRunningEvents(e));
    }, i.getBlock = () => this.provider.getBlock(t.blockHash), i.getTransaction = () => this.provider.getTransaction(t.transactionHash), i.getTransactionReceipt = () => this.provider.getTransactionReceipt(t.transactionHash), e.prepareEvent(i), i;
  }
  _addEventListener(e, t, r) {
    if (this.provider || Nt.throwError("events require a provider or a signer with a provider", D.errors.UNSUPPORTED_OPERATION, { operation: "once" }), e.addListener(t, r), this._runningEvents[e.tag] = e, !this._wrappedEmits[e.tag]) {
      const i = (s) => {
        let a = this._wrapEvent(e, s, t);
        if (a.decodeError == null)
          try {
            const o = e.getEmit(a);
            this.emit(e.filter, ...o);
          } catch (o) {
            a.decodeError = o.error;
          }
        e.filter != null && this.emit("event", a), a.decodeError != null && this.emit("error", a.decodeError, a);
      };
      this._wrappedEmits[e.tag] = i, e.filter != null && this.provider.on(e.filter, i);
    }
  }
  queryFilter(e, t, r) {
    const i = this._getRunningEvent(e), s = zt(i.filter);
    return typeof t == "string" && _e(t, 32) ? (r != null && Nt.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", r), s.blockHash = t) : (s.fromBlock = t ?? 0, s.toBlock = r ?? "latest"), this.provider.getLogs(s).then((a) => a.map((o) => this._wrapEvent(i, o, null)));
  }
  on(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !1), this;
  }
  once(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !0), this;
  }
  emit(e, ...t) {
    if (!this.provider)
      return !1;
    const r = this._getRunningEvent(e), i = r.run(t) > 0;
    return this._checkRunningEvents(r), i;
  }
  listenerCount(e) {
    return this.provider ? e == null ? Object.keys(this._runningEvents).reduce((t, r) => t + this._runningEvents[r].listenerCount(), 0) : this._getRunningEvent(e).listenerCount() : 0;
  }
  listeners(e) {
    if (!this.provider)
      return [];
    if (e == null) {
      const t = [];
      for (let r in this._runningEvents)
        this._runningEvents[r].listeners().forEach((i) => {
          t.push(i);
        });
      return t;
    }
    return this._getRunningEvent(e).listeners();
  }
  removeAllListeners(e) {
    if (!this.provider)
      return this;
    if (e == null) {
      for (const r in this._runningEvents) {
        const i = this._runningEvents[r];
        i.removeAllListeners(), this._checkRunningEvents(i);
      }
      return this;
    }
    const t = this._getRunningEvent(e);
    return t.removeAllListeners(), this._checkRunningEvents(t), this;
  }
  off(e, t) {
    if (!this.provider)
      return this;
    const r = this._getRunningEvent(e);
    return r.removeListener(t), this._checkRunningEvents(r), this;
  }
  removeListener(e, t) {
    return this.off(e, t);
  }
}
class g6 extends CM {
}
class Cy {
  constructor(e) {
    j(this, "alphabet", e), j(this, "base", e.length), j(this, "_alphabetMap", {}), j(this, "_leader", e.charAt(0));
    for (let t = 0; t < e.length; t++)
      this._alphabetMap[e.charAt(t)] = t;
  }
  encode(e) {
    let t = q(e);
    if (t.length === 0)
      return "";
    let r = [0];
    for (let s = 0; s < t.length; ++s) {
      let a = t[s];
      for (let o = 0; o < r.length; ++o)
        a += r[o] << 8, r[o] = a % this.base, a = a / this.base | 0;
      for (; a > 0; )
        r.push(a % this.base), a = a / this.base | 0;
    }
    let i = "";
    for (let s = 0; t[s] === 0 && s < t.length - 1; ++s)
      i += this._leader;
    for (let s = r.length - 1; s >= 0; --s)
      i += this.alphabet[r[s]];
    return i;
  }
  decode(e) {
    if (typeof e != "string")
      throw new TypeError("Expected String");
    let t = [];
    if (e.length === 0)
      return new Uint8Array(t);
    t.push(0);
    for (let r = 0; r < e.length; r++) {
      let i = this._alphabetMap[e[r]];
      if (i === void 0)
        throw new Error("Non-base" + this.base + " character");
      let s = i;
      for (let a = 0; a < t.length; ++a)
        s += t[a] * this.base, t[a] = s & 255, s >>= 8;
      for (; s > 0; )
        t.push(s & 255), s >>= 8;
    }
    for (let r = 0; e[r] === this._leader && r < e.length - 1; ++r)
      t.push(0);
    return q(new Uint8Array(t.reverse()));
  }
}
const _M = new Cy("abcdefghijklmnopqrstuvwxyz234567"), Eo = new Cy("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), MM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Base32: _M,
  Base58: Eo,
  BaseX: Cy
}, Symbol.toStringTag, { value: "Module" }));
var So;
(function(n) {
  n.sha256 = "sha256", n.sha512 = "sha512";
})(So || (So = {}));
const PM = "sha2/5.7.0", RM = new D(PM);
function x6(n) {
  return "0x" + Dn.ripemd160().update(q(n)).digest("hex");
}
function Di(n) {
  return "0x" + Dn.sha256().update(q(n)).digest("hex");
}
function IM(n) {
  return "0x" + Dn.sha512().update(q(n)).digest("hex");
}
function Zu(n, e, t) {
  return So[n] || RM.throwError("unsupported algorithm " + n, D.errors.UNSUPPORTED_OPERATION, {
    operation: "hmac",
    algorithm: n
  }), "0x" + Dn.hmac(Dn[n], q(e)).update(q(t)).digest("hex");
}
const OM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get SupportedAlgorithm() {
    return So;
  },
  computeHmac: Zu,
  ripemd160: x6,
  sha256: Di,
  sha512: IM
}, Symbol.toStringTag, { value: "Module" }));
function _y(n, e, t, r, i) {
  n = q(n), e = q(e);
  let s, a = 1;
  const o = new Uint8Array(r), u = new Uint8Array(e.length + 4);
  u.set(e);
  let l, d;
  for (let p = 1; p <= a; p++) {
    u[e.length] = p >> 24 & 255, u[e.length + 1] = p >> 16 & 255, u[e.length + 2] = p >> 8 & 255, u[e.length + 3] = p & 255;
    let m = q(Zu(i, n, u));
    s || (s = m.length, d = new Uint8Array(s), a = Math.ceil(r / s), l = r - (a - 1) * s), d.set(m);
    for (let T = 1; T < t; T++) {
      m = q(Zu(i, n, m));
      for (let A = 0; A < s; A++)
        d[A] ^= m[A];
    }
    const w = (p - 1) * s, x = p === a ? l : s;
    o.set(q(d).slice(0, x), w);
  }
  return J(o);
}
const kM = "wordlists/5.7.0", NM = new D(kM);
class Dl {
  constructor(e) {
    NM.checkAbstract(new.target, Dl), j(this, "locale", e);
  }
  // Subclasses may override this
  split(e) {
    return e.toLowerCase().split(/ +/g);
  }
  // Subclasses may override this
  join(e) {
    return e.join(" ");
  }
  static check(e) {
    const t = [];
    for (let r = 0; r < 2048; r++) {
      const i = e.getWord(r);
      if (r !== e.getWordIndex(i))
        return "0x";
      t.push(i);
    }
    return ls(t.join(`
`) + `
`);
  }
  static register(e, t) {
    t || (t = e.locale);
  }
}
const DM = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let Mu = null;
function fx(n) {
  if (Mu == null && (Mu = DM.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), Dl.check(n) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"))
    throw Mu = null, new Error("BIP39 Wordlist for en (English) FAILED");
}
class BM extends Dl {
  constructor() {
    super("en");
  }
  getWord(e) {
    return fx(this), Mu[e];
  }
  getWordIndex(e) {
    return fx(this), Mu.indexOf(e);
  }
}
const v6 = new BM();
Dl.register(v6);
const px = {
  en: v6
}, FM = "hdnode/5.7.0", el = new D(FM), LM = H.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), $M = Lt("Bitcoin seed"), Za = 2147483648;
function w6(n) {
  return (1 << n) - 1 << 8 - n;
}
function UM(n) {
  return (1 << n) - 1;
}
function uc(n) {
  return Le(J(n), 32);
}
function hx(n) {
  return Eo.encode(Ge([n, Bt(Di(Di(n)), 0, 4)]));
}
function My(n) {
  if (n == null)
    return px.en;
  if (typeof n == "string") {
    const e = px[n];
    return e == null && el.throwArgumentError("unknown locale", "wordlist", n), e;
  }
  return n;
}
const za = {}, Co = "m/44'/60'/0'/0/0";
class Yn {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(e, t, r, i, s, a, o, u) {
    if (e !== za)
      throw new Error("HDNode constructor cannot be called directly");
    if (t) {
      const l = new ca(t);
      j(this, "privateKey", l.privateKey), j(this, "publicKey", l.compressedPublicKey);
    } else
      j(this, "privateKey", null), j(this, "publicKey", J(r));
    j(this, "parentFingerprint", i), j(this, "fingerprint", Bt(x6(Di(this.publicKey)), 0, 4)), j(this, "address", ps(this.publicKey)), j(this, "chainCode", s), j(this, "index", a), j(this, "depth", o), u == null ? (j(this, "mnemonic", null), j(this, "path", null)) : typeof u == "string" ? (j(this, "mnemonic", null), j(this, "path", u)) : (j(this, "mnemonic", u), j(this, "path", u.path));
  }
  get extendedKey() {
    if (this.depth >= 256)
      throw new Error("Depth too large!");
    return hx(Ge([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      J(this.depth),
      this.parentFingerprint,
      Le(J(this.index), 4),
      this.chainCode,
      this.privateKey != null ? Ge(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new Yn(za, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(e) {
    if (e > 4294967295)
      throw new Error("invalid index - " + String(e));
    let t = this.path;
    t && (t += "/" + (e & ~Za));
    const r = new Uint8Array(37);
    if (e & Za) {
      if (!this.privateKey)
        throw new Error("cannot derive child of neutered node");
      r.set(q(this.privateKey), 1), t && (t += "'");
    } else
      r.set(q(this.publicKey));
    for (let p = 24; p >= 0; p -= 8)
      r[33 + (p >> 3)] = e >> 24 - p & 255;
    const i = q(Zu(So.sha512, this.chainCode, r)), s = i.slice(0, 32), a = i.slice(32);
    let o = null, u = null;
    this.privateKey ? o = uc(H.from(s).add(this.privateKey).mod(LM)) : u = new ca(J(s))._addPoint(this.publicKey);
    let l = t;
    const d = this.mnemonic;
    return d && (l = Object.freeze({
      phrase: d.phrase,
      path: t,
      locale: d.locale || "en"
    })), new Yn(za, o, u, this.fingerprint, uc(a), e, this.depth + 1, l);
  }
  derivePath(e) {
    const t = e.split("/");
    if (t.length === 0 || t[0] === "m" && this.depth !== 0)
      throw new Error("invalid path - " + e);
    t[0] === "m" && t.shift();
    let r = this;
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      if (s.match(/^[0-9]+'$/)) {
        const a = parseInt(s.substring(0, s.length - 1));
        if (a >= Za)
          throw new Error("invalid path index - " + s);
        r = r._derive(Za + a);
      } else if (s.match(/^[0-9]+$/)) {
        const a = parseInt(s);
        if (a >= Za)
          throw new Error("invalid path index - " + s);
        r = r._derive(a);
      } else
        throw new Error("invalid path component - " + s);
    }
    return r;
  }
  static _fromSeed(e, t) {
    const r = q(e);
    if (r.length < 16 || r.length > 64)
      throw new Error("invalid seed");
    const i = q(Zu(So.sha512, $M, r));
    return new Yn(za, uc(i.slice(0, 32)), null, "0x00000000", uc(i.slice(32)), 0, 0, t);
  }
  static fromMnemonic(e, t, r) {
    return r = My(r), e = ff(df(e, r), r), Yn._fromSeed(T6(e, t), {
      phrase: e,
      path: "m",
      locale: r.locale
    });
  }
  static fromSeed(e) {
    return Yn._fromSeed(e, null);
  }
  static fromExtendedKey(e) {
    const t = Eo.decode(e);
    (t.length !== 82 || hx(t.slice(0, 78)) !== e) && el.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    const r = t[4], i = J(t.slice(5, 9)), s = parseInt(J(t.slice(9, 13)).substring(2), 16), a = J(t.slice(13, 45)), o = t.slice(45, 78);
    switch (J(t.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new Yn(za, null, J(o), i, a, s, r, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (o[0] !== 0)
          break;
        return new Yn(za, J(o.slice(1)), null, i, a, s, r, null);
    }
    return el.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function T6(n, e) {
  e || (e = "");
  const t = Lt("mnemonic" + e, ri.NFKD);
  return _y(Lt(n, ri.NFKD), t, 2048, 64, "sha512");
}
function df(n, e) {
  e = My(e), el.checkNormalize();
  const t = e.split(n);
  if (t.length % 3 !== 0)
    throw new Error("invalid mnemonic");
  const r = q(new Uint8Array(Math.ceil(11 * t.length / 8)));
  let i = 0;
  for (let l = 0; l < t.length; l++) {
    let d = e.getWordIndex(t[l].normalize("NFKD"));
    if (d === -1)
      throw new Error("invalid mnemonic");
    for (let p = 0; p < 11; p++)
      d & 1 << 10 - p && (r[i >> 3] |= 1 << 7 - i % 8), i++;
  }
  const s = 32 * t.length / 3, a = t.length / 3, o = w6(a);
  if ((q(Di(r.slice(0, s / 8)))[0] & o) !== (r[r.length - 1] & o))
    throw new Error("invalid checksum");
  return J(r.slice(0, s / 8));
}
function ff(n, e) {
  if (e = My(e), n = q(n), n.length % 4 !== 0 || n.length < 16 || n.length > 32)
    throw new Error("invalid entropy");
  const t = [0];
  let r = 11;
  for (let a = 0; a < n.length; a++)
    r > 8 ? (t[t.length - 1] <<= 8, t[t.length - 1] |= n[a], r -= 8) : (t[t.length - 1] <<= r, t[t.length - 1] |= n[a] >> 8 - r, t.push(n[a] & UM(8 - r)), r += 3);
  const i = n.length / 4, s = q(Di(n))[0] & w6(i);
  return t[t.length - 1] <<= i, t[t.length - 1] |= s >> 8 - i, e.join(t.map((a) => e.getWord(a)));
}
function jM(n, e) {
  try {
    return df(n, e), !0;
  } catch {
  }
  return !1;
}
function VM(n) {
  return (typeof n != "number" || n < 0 || n >= Za || n % 1) && el.throwArgumentError("invalid account index", "index", n), `m/44'/60'/${n}'/0/0`;
}
const zM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HDNode: Yn,
  defaultPath: Co,
  entropyToMnemonic: ff,
  getAccountPath: VM,
  isValidMnemonic: jM,
  mnemonicToEntropy: df,
  mnemonicToSeed: T6
}, Symbol.toStringTag, { value: "Module" })), GM = "random/5.7.0", kh = new D(GM);
function HM() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof ba < "u")
    return ba;
  throw new Error("unable to locate global object");
}
const yx = HM();
let Nc = yx.crypto || yx.msCrypto;
(!Nc || !Nc.getRandomValues) && (kh.warn("WARNING: Missing strong random number source"), Nc = {
  getRandomValues: function(n) {
    return kh.throwError("no secure random source avaialble", D.errors.UNSUPPORTED_OPERATION, {
      operation: "crypto.getRandomValues"
    });
  }
});
function oo(n) {
  (n <= 0 || n > 1024 || n % 1 || n != n) && kh.throwArgumentError("invalid length", "length", n);
  const e = new Uint8Array(n);
  return Nc.getRandomValues(e), q(e);
}
function qM(n) {
  n = n.slice();
  for (let e = n.length - 1; e > 0; e--) {
    const t = Math.floor(Math.random() * (e + 1)), r = n[e];
    n[e] = n[t], n[t] = r;
  }
  return n;
}
const WM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  randomBytes: oo,
  shuffled: qM
}, Symbol.toStringTag, { value: "Module" }));
var A6 = { exports: {} };
(function(n, e) {
  (function(t) {
    function r(b) {
      return parseInt(b) === b;
    }
    function i(b) {
      if (!r(b.length))
        return !1;
      for (var f = 0; f < b.length; f++)
        if (!r(b[f]) || b[f] < 0 || b[f] > 255)
          return !1;
      return !0;
    }
    function s(b, f) {
      if (b.buffer && ArrayBuffer.isView(b) && b.name === "Uint8Array")
        return f && (b.slice ? b = b.slice() : b = Array.prototype.slice.call(b)), b;
      if (Array.isArray(b)) {
        if (!i(b))
          throw new Error("Array contains invalid value: " + b);
        return new Uint8Array(b);
      }
      if (r(b.length) && i(b))
        return new Uint8Array(b);
      throw new Error("unsupported array-like object");
    }
    function a(b) {
      return new Uint8Array(b);
    }
    function o(b, f, v, O, y) {
      (O != null || y != null) && (b.slice ? b = b.slice(O, y) : b = Array.prototype.slice.call(b, O, y)), f.set(b, v);
    }
    var u = function() {
      function b(v) {
        var O = [], y = 0;
        for (v = encodeURI(v); y < v.length; ) {
          var R = v.charCodeAt(y++);
          R === 37 ? (O.push(parseInt(v.substr(y, 2), 16)), y += 2) : O.push(R);
        }
        return s(O);
      }
      function f(v) {
        for (var O = [], y = 0; y < v.length; ) {
          var R = v[y];
          R < 128 ? (O.push(String.fromCharCode(R)), y++) : R > 191 && R < 224 ? (O.push(String.fromCharCode((R & 31) << 6 | v[y + 1] & 63)), y += 2) : (O.push(String.fromCharCode((R & 15) << 12 | (v[y + 1] & 63) << 6 | v[y + 2] & 63)), y += 3);
        }
        return O.join("");
      }
      return {
        toBytes: b,
        fromBytes: f
      };
    }(), l = function() {
      function b(O) {
        for (var y = [], R = 0; R < O.length; R += 2)
          y.push(parseInt(O.substr(R, 2), 16));
        return y;
      }
      var f = "0123456789abcdef";
      function v(O) {
        for (var y = [], R = 0; R < O.length; R++) {
          var L = O[R];
          y.push(f[(L & 240) >> 4] + f[L & 15]);
        }
        return y.join("");
      }
      return {
        toBytes: b,
        fromBytes: v
      };
    }(), d = { 16: 10, 24: 12, 32: 14 }, p = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145], m = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], w = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], x = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986], T = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766], A = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126], M = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436], I = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890], B = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935], k = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600], N = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480], U = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795], W = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855], G = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150], Y = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function ue(b) {
      for (var f = [], v = 0; v < b.length; v += 4)
        f.push(
          b[v] << 24 | b[v + 1] << 16 | b[v + 2] << 8 | b[v + 3]
        );
      return f;
    }
    var K = function(b) {
      if (!(this instanceof K))
        throw Error("AES must be instanitated with `new`");
      Object.defineProperty(this, "key", {
        value: s(b, !0)
      }), this._prepare();
    };
    K.prototype._prepare = function() {
      var b = d[this.key.length];
      if (b == null)
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      this._Ke = [], this._Kd = [];
      for (var f = 0; f <= b; f++)
        this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (var v = (b + 1) * 4, O = this.key.length / 4, y = ue(this.key), R, f = 0; f < O; f++)
        R = f >> 2, this._Ke[R][f % 4] = y[f], this._Kd[b - R][f % 4] = y[f];
      for (var L = 0, F = O, $; F < v; ) {
        if ($ = y[O - 1], y[0] ^= m[$ >> 16 & 255] << 24 ^ m[$ >> 8 & 255] << 16 ^ m[$ & 255] << 8 ^ m[$ >> 24 & 255] ^ p[L] << 24, L += 1, O != 8)
          for (var f = 1; f < O; f++)
            y[f] ^= y[f - 1];
        else {
          for (var f = 1; f < O / 2; f++)
            y[f] ^= y[f - 1];
          $ = y[O / 2 - 1], y[O / 2] ^= m[$ & 255] ^ m[$ >> 8 & 255] << 8 ^ m[$ >> 16 & 255] << 16 ^ m[$ >> 24 & 255] << 24;
          for (var f = O / 2 + 1; f < O; f++)
            y[f] ^= y[f - 1];
        }
        for (var f = 0, te, Q; f < O && F < v; )
          te = F >> 2, Q = F % 4, this._Ke[te][Q] = y[f], this._Kd[b - te][Q] = y[f++], F++;
      }
      for (var te = 1; te < b; te++)
        for (var Q = 0; Q < 4; Q++)
          $ = this._Kd[te][Q], this._Kd[te][Q] = U[$ >> 24 & 255] ^ W[$ >> 16 & 255] ^ G[$ >> 8 & 255] ^ Y[$ & 255];
    }, K.prototype.encrypt = function(b) {
      if (b.length != 16)
        throw new Error("invalid plaintext size (must be 16 bytes)");
      for (var f = this._Ke.length - 1, v = [0, 0, 0, 0], O = ue(b), y = 0; y < 4; y++)
        O[y] ^= this._Ke[0][y];
      for (var R = 1; R < f; R++) {
        for (var y = 0; y < 4; y++)
          v[y] = x[O[y] >> 24 & 255] ^ T[O[(y + 1) % 4] >> 16 & 255] ^ A[O[(y + 2) % 4] >> 8 & 255] ^ M[O[(y + 3) % 4] & 255] ^ this._Ke[R][y];
        O = v.slice();
      }
      for (var L = a(16), F, y = 0; y < 4; y++)
        F = this._Ke[f][y], L[4 * y] = (m[O[y] >> 24 & 255] ^ F >> 24) & 255, L[4 * y + 1] = (m[O[(y + 1) % 4] >> 16 & 255] ^ F >> 16) & 255, L[4 * y + 2] = (m[O[(y + 2) % 4] >> 8 & 255] ^ F >> 8) & 255, L[4 * y + 3] = (m[O[(y + 3) % 4] & 255] ^ F) & 255;
      return L;
    }, K.prototype.decrypt = function(b) {
      if (b.length != 16)
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      for (var f = this._Kd.length - 1, v = [0, 0, 0, 0], O = ue(b), y = 0; y < 4; y++)
        O[y] ^= this._Kd[0][y];
      for (var R = 1; R < f; R++) {
        for (var y = 0; y < 4; y++)
          v[y] = I[O[y] >> 24 & 255] ^ B[O[(y + 3) % 4] >> 16 & 255] ^ k[O[(y + 2) % 4] >> 8 & 255] ^ N[O[(y + 1) % 4] & 255] ^ this._Kd[R][y];
        O = v.slice();
      }
      for (var L = a(16), F, y = 0; y < 4; y++)
        F = this._Kd[f][y], L[4 * y] = (w[O[y] >> 24 & 255] ^ F >> 24) & 255, L[4 * y + 1] = (w[O[(y + 3) % 4] >> 16 & 255] ^ F >> 16) & 255, L[4 * y + 2] = (w[O[(y + 2) % 4] >> 8 & 255] ^ F >> 8) & 255, L[4 * y + 3] = (w[O[(y + 1) % 4] & 255] ^ F) & 255;
      return L;
    };
    var le = function(b) {
      if (!(this instanceof le))
        throw Error("AES must be instanitated with `new`");
      this.description = "Electronic Code Block", this.name = "ecb", this._aes = new K(b);
    };
    le.prototype.encrypt = function(b) {
      if (b = s(b), b.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var f = a(b.length), v = a(16), O = 0; O < b.length; O += 16)
        o(b, v, 0, O, O + 16), v = this._aes.encrypt(v), o(v, f, O);
      return f;
    }, le.prototype.decrypt = function(b) {
      if (b = s(b), b.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var f = a(b.length), v = a(16), O = 0; O < b.length; O += 16)
        o(b, v, 0, O, O + 16), v = this._aes.decrypt(v), o(v, f, O);
      return f;
    };
    var C = function(b, f) {
      if (!(this instanceof C))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Block Chaining", this.name = "cbc", !f)
        f = a(16);
      else if (f.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastCipherblock = s(f, !0), this._aes = new K(b);
    };
    C.prototype.encrypt = function(b) {
      if (b = s(b), b.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var f = a(b.length), v = a(16), O = 0; O < b.length; O += 16) {
        o(b, v, 0, O, O + 16);
        for (var y = 0; y < 16; y++)
          v[y] ^= this._lastCipherblock[y];
        this._lastCipherblock = this._aes.encrypt(v), o(this._lastCipherblock, f, O);
      }
      return f;
    }, C.prototype.decrypt = function(b) {
      if (b = s(b), b.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var f = a(b.length), v = a(16), O = 0; O < b.length; O += 16) {
        o(b, v, 0, O, O + 16), v = this._aes.decrypt(v);
        for (var y = 0; y < 16; y++)
          f[O + y] = v[y] ^ this._lastCipherblock[y];
        o(b, this._lastCipherblock, 0, O, O + 16);
      }
      return f;
    };
    var c = function(b, f, v) {
      if (!(this instanceof c))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Feedback", this.name = "cfb", !f)
        f = a(16);
      else if (f.length != 16)
        throw new Error("invalid initialation vector size (must be 16 size)");
      v || (v = 1), this.segmentSize = v, this._shiftRegister = s(f, !0), this._aes = new K(b);
    };
    c.prototype.encrypt = function(b) {
      if (b.length % this.segmentSize != 0)
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      for (var f = s(b, !0), v, O = 0; O < f.length; O += this.segmentSize) {
        v = this._aes.encrypt(this._shiftRegister);
        for (var y = 0; y < this.segmentSize; y++)
          f[O + y] ^= v[y];
        o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(f, this._shiftRegister, 16 - this.segmentSize, O, O + this.segmentSize);
      }
      return f;
    }, c.prototype.decrypt = function(b) {
      if (b.length % this.segmentSize != 0)
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      for (var f = s(b, !0), v, O = 0; O < f.length; O += this.segmentSize) {
        v = this._aes.encrypt(this._shiftRegister);
        for (var y = 0; y < this.segmentSize; y++)
          f[O + y] ^= v[y];
        o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(b, this._shiftRegister, 16 - this.segmentSize, O, O + this.segmentSize);
      }
      return f;
    };
    var h = function(b, f) {
      if (!(this instanceof h))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Output Feedback", this.name = "ofb", !f)
        f = a(16);
      else if (f.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastPrecipher = s(f, !0), this._lastPrecipherIndex = 16, this._aes = new K(b);
    };
    h.prototype.encrypt = function(b) {
      for (var f = s(b, !0), v = 0; v < f.length; v++)
        this._lastPrecipherIndex === 16 && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), f[v] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      return f;
    }, h.prototype.decrypt = h.prototype.encrypt;
    var g = function(b) {
      if (!(this instanceof g))
        throw Error("Counter must be instanitated with `new`");
      b !== 0 && !b && (b = 1), typeof b == "number" ? (this._counter = a(16), this.setValue(b)) : this.setBytes(b);
    };
    g.prototype.setValue = function(b) {
      if (typeof b != "number" || parseInt(b) != b)
        throw new Error("invalid counter value (must be an integer)");
      for (var f = 15; f >= 0; --f)
        this._counter[f] = b % 256, b = b >> 8;
    }, g.prototype.setBytes = function(b) {
      if (b = s(b, !0), b.length != 16)
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      this._counter = b;
    }, g.prototype.increment = function() {
      for (var b = 15; b >= 0; b--)
        if (this._counter[b] === 255)
          this._counter[b] = 0;
        else {
          this._counter[b]++;
          break;
        }
    };
    var E = function(b, f) {
      if (!(this instanceof E))
        throw Error("AES must be instanitated with `new`");
      this.description = "Counter", this.name = "ctr", f instanceof g || (f = new g(f)), this._counter = f, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new K(b);
    };
    E.prototype.encrypt = function(b) {
      for (var f = s(b, !0), v = 0; v < f.length; v++)
        this._remainingCounterIndex === 16 && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), f[v] ^= this._remainingCounter[this._remainingCounterIndex++];
      return f;
    }, E.prototype.decrypt = E.prototype.encrypt;
    function S(b) {
      b = s(b, !0);
      var f = 16 - b.length % 16, v = a(b.length + f);
      o(b, v);
      for (var O = b.length; O < v.length; O++)
        v[O] = f;
      return v;
    }
    function _(b) {
      if (b = s(b, !0), b.length < 16)
        throw new Error("PKCS#7 invalid length");
      var f = b[b.length - 1];
      if (f > 16)
        throw new Error("PKCS#7 padding byte out of range");
      for (var v = b.length - f, O = 0; O < f; O++)
        if (b[v + O] !== f)
          throw new Error("PKCS#7 invalid padding byte");
      var y = a(v);
      return o(b, y, 0, 0, v), y;
    }
    var P = {
      AES: K,
      Counter: g,
      ModeOfOperation: {
        ecb: le,
        cbc: C,
        cfb: c,
        ofb: h,
        ctr: E
      },
      utils: {
        hex: l,
        utf8: u
      },
      padding: {
        pkcs7: {
          pad: S,
          strip: _
        }
      },
      _arrayTest: {
        coerceArray: s,
        createArray: a,
        copyArray: o
      }
    };
    n.exports = P;
  })();
})(A6);
var KM = A6.exports;
const Kr = /* @__PURE__ */ _s(KM), E6 = "json-wallets/5.7.0";
function da(n) {
  return typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), q(n);
}
function nu(n, e) {
  for (n = String(n); n.length < e; )
    n = "0" + n;
  return n;
}
function Py(n) {
  return typeof n == "string" ? Lt(n, ri.NFKC) : q(n);
}
function Dt(n, e) {
  let t = n;
  const r = e.toLowerCase().split("/");
  for (let i = 0; i < r.length; i++) {
    let s = null;
    for (const a in t)
      if (a.toLowerCase() === r[i]) {
        s = t[a];
        break;
      }
    if (s === null)
      return null;
    t = s;
  }
  return t;
}
function JM(n) {
  const e = q(n);
  e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
  const t = J(e);
  return [
    t.substring(2, 10),
    t.substring(10, 14),
    t.substring(14, 18),
    t.substring(18, 22),
    t.substring(22, 34)
  ].join("-");
}
const QM = new D(E6);
class YM extends Ms {
  isCrowdsaleAccount(e) {
    return !!(e && e._isCrowdsaleAccount);
  }
}
function Ry(n, e) {
  const t = JSON.parse(n);
  e = Py(e);
  const r = Fe(Dt(t, "ethaddr")), i = da(Dt(t, "encseed"));
  (!i || i.length % 16 !== 0) && QM.throwArgumentError("invalid encseed", "json", n);
  const s = q(_y(e, e, 2e3, 32, "sha256")).slice(0, 16), a = i.slice(0, 16), o = i.slice(16), u = new Kr.ModeOfOperation.cbc(s, a), l = Kr.padding.pkcs7.strip(q(u.decrypt(o)));
  let d = "";
  for (let w = 0; w < l.length; w++)
    d += String.fromCharCode(l[w]);
  const p = Lt(d), m = De(p);
  return new YM({
    _isCrowdsaleAccount: !0,
    address: r,
    privateKey: m
  });
}
function pf(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return e.encseed && e.ethaddr;
}
function hf(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return !(!e.version || parseInt(e.version) !== e.version || parseInt(e.version) !== 3);
}
function XM(n) {
  if (pf(n))
    try {
      return Fe(JSON.parse(n).ethaddr);
    } catch {
      return null;
    }
  if (hf(n))
    try {
      return Fe(JSON.parse(n).address);
    } catch {
      return null;
    }
  return null;
}
var S6 = { exports: {} };
(function(n, e) {
  (function(t) {
    function i(T) {
      const A = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let M = 1779033703, I = 3144134277, B = 1013904242, k = 2773480762, N = 1359893119, U = 2600822924, W = 528734635, G = 1541459225;
      const Y = new Uint32Array(64);
      function ue(E) {
        let S = 0, _ = E.length;
        for (; _ >= 64; ) {
          let P = M, b = I, f = B, v = k, O = N, y = U, R = W, L = G, F, $, te, Q, X;
          for ($ = 0; $ < 16; $++)
            te = S + $ * 4, Y[$] = (E[te] & 255) << 24 | (E[te + 1] & 255) << 16 | (E[te + 2] & 255) << 8 | E[te + 3] & 255;
          for ($ = 16; $ < 64; $++)
            F = Y[$ - 2], Q = (F >>> 17 | F << 32 - 17) ^ (F >>> 19 | F << 32 - 19) ^ F >>> 10, F = Y[$ - 15], X = (F >>> 7 | F << 32 - 7) ^ (F >>> 18 | F << 32 - 18) ^ F >>> 3, Y[$] = (Q + Y[$ - 7] | 0) + (X + Y[$ - 16] | 0) | 0;
          for ($ = 0; $ < 64; $++)
            Q = (((O >>> 6 | O << 32 - 6) ^ (O >>> 11 | O << 32 - 11) ^ (O >>> 25 | O << 32 - 25)) + (O & y ^ ~O & R) | 0) + (L + (A[$] + Y[$] | 0) | 0) | 0, X = ((P >>> 2 | P << 32 - 2) ^ (P >>> 13 | P << 32 - 13) ^ (P >>> 22 | P << 32 - 22)) + (P & b ^ P & f ^ b & f) | 0, L = R, R = y, y = O, O = v + Q | 0, v = f, f = b, b = P, P = Q + X | 0;
          M = M + P | 0, I = I + b | 0, B = B + f | 0, k = k + v | 0, N = N + O | 0, U = U + y | 0, W = W + R | 0, G = G + L | 0, S += 64, _ -= 64;
        }
      }
      ue(T);
      let K, le = T.length % 64, C = T.length / 536870912 | 0, c = T.length << 3, h = le < 56 ? 56 : 120, g = T.slice(T.length - le, T.length);
      for (g.push(128), K = le + 1; K < h; K++)
        g.push(0);
      return g.push(C >>> 24 & 255), g.push(C >>> 16 & 255), g.push(C >>> 8 & 255), g.push(C >>> 0 & 255), g.push(c >>> 24 & 255), g.push(c >>> 16 & 255), g.push(c >>> 8 & 255), g.push(c >>> 0 & 255), ue(g), [
        M >>> 24 & 255,
        M >>> 16 & 255,
        M >>> 8 & 255,
        M >>> 0 & 255,
        I >>> 24 & 255,
        I >>> 16 & 255,
        I >>> 8 & 255,
        I >>> 0 & 255,
        B >>> 24 & 255,
        B >>> 16 & 255,
        B >>> 8 & 255,
        B >>> 0 & 255,
        k >>> 24 & 255,
        k >>> 16 & 255,
        k >>> 8 & 255,
        k >>> 0 & 255,
        N >>> 24 & 255,
        N >>> 16 & 255,
        N >>> 8 & 255,
        N >>> 0 & 255,
        U >>> 24 & 255,
        U >>> 16 & 255,
        U >>> 8 & 255,
        U >>> 0 & 255,
        W >>> 24 & 255,
        W >>> 16 & 255,
        W >>> 8 & 255,
        W >>> 0 & 255,
        G >>> 24 & 255,
        G >>> 16 & 255,
        G >>> 8 & 255,
        G >>> 0 & 255
      ];
    }
    function s(T, A, M) {
      T = T.length <= 64 ? T : i(T);
      const I = 64 + A.length + 4, B = new Array(I), k = new Array(64);
      let N, U = [];
      for (N = 0; N < 64; N++)
        B[N] = 54;
      for (N = 0; N < T.length; N++)
        B[N] ^= T[N];
      for (N = 0; N < A.length; N++)
        B[64 + N] = A[N];
      for (N = I - 4; N < I; N++)
        B[N] = 0;
      for (N = 0; N < 64; N++)
        k[N] = 92;
      for (N = 0; N < T.length; N++)
        k[N] ^= T[N];
      function W() {
        for (let G = I - 1; G >= I - 4; G--) {
          if (B[G]++, B[G] <= 255)
            return;
          B[G] = 0;
        }
      }
      for (; M >= 32; )
        W(), U = U.concat(i(k.concat(i(B)))), M -= 32;
      return M > 0 && (W(), U = U.concat(i(k.concat(i(B))).slice(0, M))), U;
    }
    function a(T, A, M, I, B) {
      let k;
      for (d(T, (2 * M - 1) * 16, B, 0, 16), k = 0; k < 2 * M; k++)
        l(T, k * 16, B, 16), u(B, I), d(B, 0, T, A + k * 16, 16);
      for (k = 0; k < M; k++)
        d(T, A + k * 2 * 16, T, k * 16, 16);
      for (k = 0; k < M; k++)
        d(T, A + (k * 2 + 1) * 16, T, (k + M) * 16, 16);
    }
    function o(T, A) {
      return T << A | T >>> 32 - A;
    }
    function u(T, A) {
      d(T, 0, A, 0, 16);
      for (let M = 8; M > 0; M -= 2)
        A[4] ^= o(A[0] + A[12], 7), A[8] ^= o(A[4] + A[0], 9), A[12] ^= o(A[8] + A[4], 13), A[0] ^= o(A[12] + A[8], 18), A[9] ^= o(A[5] + A[1], 7), A[13] ^= o(A[9] + A[5], 9), A[1] ^= o(A[13] + A[9], 13), A[5] ^= o(A[1] + A[13], 18), A[14] ^= o(A[10] + A[6], 7), A[2] ^= o(A[14] + A[10], 9), A[6] ^= o(A[2] + A[14], 13), A[10] ^= o(A[6] + A[2], 18), A[3] ^= o(A[15] + A[11], 7), A[7] ^= o(A[3] + A[15], 9), A[11] ^= o(A[7] + A[3], 13), A[15] ^= o(A[11] + A[7], 18), A[1] ^= o(A[0] + A[3], 7), A[2] ^= o(A[1] + A[0], 9), A[3] ^= o(A[2] + A[1], 13), A[0] ^= o(A[3] + A[2], 18), A[6] ^= o(A[5] + A[4], 7), A[7] ^= o(A[6] + A[5], 9), A[4] ^= o(A[7] + A[6], 13), A[5] ^= o(A[4] + A[7], 18), A[11] ^= o(A[10] + A[9], 7), A[8] ^= o(A[11] + A[10], 9), A[9] ^= o(A[8] + A[11], 13), A[10] ^= o(A[9] + A[8], 18), A[12] ^= o(A[15] + A[14], 7), A[13] ^= o(A[12] + A[15], 9), A[14] ^= o(A[13] + A[12], 13), A[15] ^= o(A[14] + A[13], 18);
      for (let M = 0; M < 16; ++M)
        T[M] += A[M];
    }
    function l(T, A, M, I) {
      for (let B = 0; B < I; B++)
        M[B] ^= T[A + B];
    }
    function d(T, A, M, I, B) {
      for (; B--; )
        M[I++] = T[A++];
    }
    function p(T) {
      if (!T || typeof T.length != "number")
        return !1;
      for (let A = 0; A < T.length; A++) {
        const M = T[A];
        if (typeof M != "number" || M % 1 || M < 0 || M >= 256)
          return !1;
      }
      return !0;
    }
    function m(T, A) {
      if (typeof T != "number" || T % 1)
        throw new Error("invalid " + A);
      return T;
    }
    function w(T, A, M, I, B, k, N) {
      if (M = m(M, "N"), I = m(I, "r"), B = m(B, "p"), k = m(k, "dkLen"), M === 0 || M & M - 1)
        throw new Error("N must be power of 2");
      if (M > 2147483647 / 128 / I)
        throw new Error("N too large");
      if (I > 2147483647 / 128 / B)
        throw new Error("r too large");
      if (!p(T))
        throw new Error("password must be an array or buffer");
      if (T = Array.prototype.slice.call(T), !p(A))
        throw new Error("salt must be an array or buffer");
      A = Array.prototype.slice.call(A);
      let U = s(T, A, B * 128 * I);
      const W = new Uint32Array(B * 32 * I);
      for (let O = 0; O < W.length; O++) {
        const y = O * 4;
        W[O] = (U[y + 3] & 255) << 24 | (U[y + 2] & 255) << 16 | (U[y + 1] & 255) << 8 | (U[y + 0] & 255) << 0;
      }
      const G = new Uint32Array(64 * I), Y = new Uint32Array(32 * I * M), ue = 32 * I, K = new Uint32Array(16), le = new Uint32Array(16), C = B * M * 2;
      let c = 0, h = null, g = !1, E = 0, S = 0, _, P;
      const b = N ? parseInt(1e3 / I) : 4294967295, f = typeof setImmediate < "u" ? setImmediate : setTimeout, v = function() {
        if (g)
          return N(new Error("cancelled"), c / C);
        let O;
        switch (E) {
          case 0:
            P = S * 32 * I, d(W, P, G, 0, ue), E = 1, _ = 0;
          case 1:
            O = M - _, O > b && (O = b);
            for (let R = 0; R < O; R++)
              d(G, 0, Y, (_ + R) * ue, ue), a(G, ue, I, K, le);
            if (_ += O, c += O, N) {
              const R = parseInt(1e3 * c / C);
              if (R !== h) {
                if (g = N(null, c / C), g)
                  break;
                h = R;
              }
            }
            if (_ < M)
              break;
            _ = 0, E = 2;
          case 2:
            O = M - _, O > b && (O = b);
            for (let R = 0; R < O; R++) {
              const L = (2 * I - 1) * 16, F = G[L] & M - 1;
              l(Y, F * ue, G, ue), a(G, ue, I, K, le);
            }
            if (_ += O, c += O, N) {
              const R = parseInt(1e3 * c / C);
              if (R !== h) {
                if (g = N(null, c / C), g)
                  break;
                h = R;
              }
            }
            if (_ < M)
              break;
            if (d(G, 0, W, P, ue), S++, S < B) {
              E = 0;
              break;
            }
            U = [];
            for (let R = 0; R < W.length; R++)
              U.push(W[R] >> 0 & 255), U.push(W[R] >> 8 & 255), U.push(W[R] >> 16 & 255), U.push(W[R] >> 24 & 255);
            const y = s(T, U, k);
            return N && N(null, 1, y), y;
        }
        N && f(v);
      };
      if (!N)
        for (; ; ) {
          const O = v();
          if (O != null)
            return O;
        }
      v();
    }
    const x = {
      scrypt: function(T, A, M, I, B, k, N) {
        return new Promise(function(U, W) {
          let G = 0;
          N && N(0), w(T, A, M, I, B, k, function(Y, ue, K) {
            if (Y)
              W(Y);
            else if (K)
              N && G !== 1 && N(1), U(new Uint8Array(K));
            else if (N && ue !== G)
              return G = ue, N(ue);
          });
        });
      },
      syncScrypt: function(T, A, M, I, B, k) {
        return new Uint8Array(w(T, A, M, I, B, k));
      }
    };
    n.exports = x;
  })();
})(S6);
var ZM = S6.exports;
const Iy = /* @__PURE__ */ _s(ZM);
var e9 = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const Nh = new D(E6);
function mx(n) {
  return n != null && n.mnemonic && n.mnemonic.phrase;
}
class t9 extends Ms {
  isKeystoreAccount(e) {
    return !!(e && e._isKeystoreAccount);
  }
}
function n9(n, e, t) {
  if (Dt(n, "crypto/cipher") === "aes-128-ctr") {
    const i = da(Dt(n, "crypto/cipherparams/iv")), s = new Kr.Counter(i), a = new Kr.ModeOfOperation.ctr(e, s);
    return q(a.decrypt(t));
  }
  return null;
}
function C6(n, e) {
  const t = da(Dt(n, "crypto/ciphertext"));
  if (J(De(Ge([e.slice(16, 32), t]))).substring(2) !== Dt(n, "crypto/mac").toLowerCase())
    throw new Error("invalid password");
  const i = n9(n, e.slice(0, 16), t);
  i || Nh.throwError("unsupported cipher", D.errors.UNSUPPORTED_OPERATION, {
    operation: "decrypt"
  });
  const s = e.slice(32, 64), a = ps(i);
  if (n.address) {
    let u = n.address.toLowerCase();
    if (u.substring(0, 2) !== "0x" && (u = "0x" + u), Fe(u) !== a)
      throw new Error("address mismatch");
  }
  const o = {
    _isKeystoreAccount: !0,
    address: a,
    privateKey: J(i)
  };
  if (Dt(n, "x-ethers/version") === "0.1") {
    const u = da(Dt(n, "x-ethers/mnemonicCiphertext")), l = da(Dt(n, "x-ethers/mnemonicCounter")), d = new Kr.Counter(l), p = new Kr.ModeOfOperation.ctr(s, d), m = Dt(n, "x-ethers/path") || Co, w = Dt(n, "x-ethers/locale") || "en", x = q(p.decrypt(u));
    try {
      const T = ff(x, w), A = Yn.fromMnemonic(T, null, w).derivePath(m);
      if (A.privateKey != o.privateKey)
        throw new Error("mnemonic mismatch");
      o.mnemonic = A.mnemonic;
    } catch (T) {
      if (T.code !== D.errors.INVALID_ARGUMENT || T.argument !== "wordlist")
        throw T;
    }
  }
  return new t9(o);
}
function _6(n, e, t, r, i) {
  return q(_y(n, e, t, r, i));
}
function r9(n, e, t, r, i) {
  return Promise.resolve(_6(n, e, t, r, i));
}
function M6(n, e, t, r, i) {
  const s = Py(e), a = Dt(n, "crypto/kdf");
  if (a && typeof a == "string") {
    const o = function(u, l) {
      return Nh.throwArgumentError("invalid key-derivation function parameters", u, l);
    };
    if (a.toLowerCase() === "scrypt") {
      const u = da(Dt(n, "crypto/kdfparams/salt")), l = parseInt(Dt(n, "crypto/kdfparams/n")), d = parseInt(Dt(n, "crypto/kdfparams/r")), p = parseInt(Dt(n, "crypto/kdfparams/p"));
      (!l || !d || !p) && o("kdf", a), l & l - 1 && o("N", l);
      const m = parseInt(Dt(n, "crypto/kdfparams/dklen"));
      return m !== 32 && o("dklen", m), r(s, u, l, d, p, 64, i);
    } else if (a.toLowerCase() === "pbkdf2") {
      const u = da(Dt(n, "crypto/kdfparams/salt"));
      let l = null;
      const d = Dt(n, "crypto/kdfparams/prf");
      d === "hmac-sha256" ? l = "sha256" : d === "hmac-sha512" ? l = "sha512" : o("prf", d);
      const p = parseInt(Dt(n, "crypto/kdfparams/c")), m = parseInt(Dt(n, "crypto/kdfparams/dklen"));
      return m !== 32 && o("dklen", m), t(s, u, p, m, l);
    }
  }
  return Nh.throwArgumentError("unsupported key-derivation function", "kdf", a);
}
function P6(n, e) {
  const t = JSON.parse(n), r = M6(t, e, _6, Iy.syncScrypt);
  return C6(t, r);
}
function R6(n, e, t) {
  return e9(this, void 0, void 0, function* () {
    const r = JSON.parse(n), i = yield M6(r, e, r9, Iy.scrypt, t);
    return C6(r, i);
  });
}
function I6(n, e, t, r) {
  try {
    if (Fe(n.address) !== ps(n.privateKey))
      throw new Error("address/privateKey mismatch");
    if (mx(n)) {
      const A = n.mnemonic;
      if (Yn.fromMnemonic(A.phrase, null, A.locale).derivePath(A.path || Co).privateKey != n.privateKey)
        throw new Error("mnemonic mismatch");
    }
  } catch (A) {
    return Promise.reject(A);
  }
  typeof t == "function" && !r && (r = t, t = {}), t || (t = {});
  const i = q(n.privateKey), s = Py(e);
  let a = null, o = null, u = null;
  if (mx(n)) {
    const A = n.mnemonic;
    a = q(df(A.phrase, A.locale || "en")), o = A.path || Co, u = A.locale || "en";
  }
  let l = t.client;
  l || (l = "ethers.js");
  let d = null;
  t.salt ? d = q(t.salt) : d = oo(32);
  let p = null;
  if (t.iv) {
    if (p = q(t.iv), p.length !== 16)
      throw new Error("invalid iv");
  } else
    p = oo(16);
  let m = null;
  if (t.uuid) {
    if (m = q(t.uuid), m.length !== 16)
      throw new Error("invalid uuid");
  } else
    m = oo(16);
  let w = 1 << 17, x = 8, T = 1;
  return t.scrypt && (t.scrypt.N && (w = t.scrypt.N), t.scrypt.r && (x = t.scrypt.r), t.scrypt.p && (T = t.scrypt.p)), Iy.scrypt(s, d, w, x, T, 64, r).then((A) => {
    A = q(A);
    const M = A.slice(0, 16), I = A.slice(16, 32), B = A.slice(32, 64), k = new Kr.Counter(p), N = new Kr.ModeOfOperation.ctr(M, k), U = q(N.encrypt(i)), W = De(Ge([I, U])), G = {
      address: n.address.substring(2).toLowerCase(),
      id: JM(m),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: J(p).substring(2)
        },
        ciphertext: J(U).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: J(d).substring(2),
          n: w,
          dklen: 32,
          p: T,
          r: x
        },
        mac: W.substring(2)
      }
    };
    if (a) {
      const Y = oo(16), ue = new Kr.Counter(Y), K = new Kr.ModeOfOperation.ctr(B, ue), le = q(K.encrypt(a)), C = /* @__PURE__ */ new Date(), c = C.getUTCFullYear() + "-" + nu(C.getUTCMonth() + 1, 2) + "-" + nu(C.getUTCDate(), 2) + "T" + nu(C.getUTCHours(), 2) + "-" + nu(C.getUTCMinutes(), 2) + "-" + nu(C.getUTCSeconds(), 2) + ".0Z";
      G["x-ethers"] = {
        client: l,
        gethFilename: "UTC--" + c + "--" + G.address,
        mnemonicCounter: J(Y).substring(2),
        mnemonicCiphertext: J(le).substring(2),
        path: o,
        locale: u,
        version: "0.1"
      };
    }
    return JSON.stringify(G);
  });
}
function O6(n, e, t) {
  if (pf(n)) {
    t && t(0);
    const r = Ry(n, e);
    return t && t(1), Promise.resolve(r);
  }
  return hf(n) ? R6(n, e, t) : Promise.reject(new Error("invalid JSON wallet"));
}
function k6(n, e) {
  if (pf(n))
    return Ry(n, e);
  if (hf(n))
    return P6(n, e);
  throw new Error("invalid JSON wallet");
}
const i9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decryptCrowdsale: Ry,
  decryptJsonWallet: O6,
  decryptJsonWalletSync: k6,
  decryptKeystore: R6,
  decryptKeystoreSync: P6,
  encryptKeystore: I6,
  getJsonWalletAddress: XM,
  isCrowdsaleWallet: pf,
  isKeystoreWallet: hf
}, Symbol.toStringTag, { value: "Module" })), s9 = "wallet/5.7.0";
var bx = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const Ga = new D(s9);
function a9(n) {
  return n != null && _e(n.privateKey, 32) && n.address != null;
}
function o9(n) {
  const e = n.mnemonic;
  return e && e.phrase;
}
class ra extends La {
  constructor(e, t) {
    if (super(), a9(e)) {
      const r = new ca(e.privateKey);
      if (j(this, "_signingKey", () => r), j(this, "address", ps(this.publicKey)), this.address !== Fe(e.address) && Ga.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), o9(e)) {
        const i = e.mnemonic;
        j(this, "_mnemonic", () => ({
          phrase: i.phrase,
          path: i.path || Co,
          locale: i.locale || "en"
        }));
        const s = this.mnemonic, a = Yn.fromMnemonic(s.phrase, null, s.locale).derivePath(s.path);
        ps(a.privateKey) !== this.address && Ga.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
      } else
        j(this, "_mnemonic", () => null);
    } else {
      if (ca.isSigningKey(e))
        e.curve !== "secp256k1" && Ga.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), j(this, "_signingKey", () => e);
      else {
        typeof e == "string" && e.match(/^[0-9a-f]*$/i) && e.length === 64 && (e = "0x" + e);
        const r = new ca(e);
        j(this, "_signingKey", () => r);
      }
      j(this, "_mnemonic", () => null), j(this, "address", ps(this.publicKey));
    }
    t && !xy.isProvider(t) && Ga.throwArgumentError("invalid provider", "provider", t), j(this, "provider", t || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(e) {
    return new ra(this, e);
  }
  signTransaction(e) {
    return Rt(e).then((t) => {
      t.from != null && (Fe(t.from) !== this.address && Ga.throwArgumentError("transaction from address mismatch", "transaction.from", e.from), delete t.from);
      const r = this._signingKey().signDigest(De(Oh(t)));
      return Oh(t, r);
    });
  }
  signMessage(e) {
    return bx(this, void 0, void 0, function* () {
      return Th(this._signingKey().signDigest(gy(e)));
    });
  }
  _signTypedData(e, t, r) {
    return bx(this, void 0, void 0, function* () {
      const i = yield an.resolveNames(e, t, r, (s) => (this.provider == null && Ga.throwError("cannot resolve ENS names without a provider", D.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName",
        value: s
      }), this.provider.resolveName(s)));
      return Th(this._signingKey().signDigest(an.hash(i.domain, t, i.value)));
    });
  }
  encrypt(e, t, r) {
    if (typeof t == "function" && !r && (r = t, t = {}), r && typeof r != "function")
      throw new Error("invalid callback");
    return t || (t = {}), I6(this, e, t, r);
  }
  /**
   *  Static methods to create Wallet instances.
   */
  static createRandom(e) {
    let t = oo(16);
    e || (e = {}), e.extraEntropy && (t = q(Bt(De(Ge([t, e.extraEntropy])), 0, 16)));
    const r = ff(t, e.locale);
    return ra.fromMnemonic(r, e.path, e.locale);
  }
  static fromEncryptedJson(e, t, r) {
    return O6(e, t, r).then((i) => new ra(i));
  }
  static fromEncryptedJsonSync(e, t) {
    return new ra(k6(e, t));
  }
  static fromMnemonic(e, t, r) {
    return t || (t = Co), new ra(Yn.fromMnemonic(e, null, r).derivePath(t));
  }
}
function u9(n, e) {
  return Wo(gy(n), e);
}
function l9(n, e, t, r) {
  return Wo(an.hash(n, e, t), r);
}
const c9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Wallet: ra,
  verifyMessage: u9,
  verifyTypedData: l9
}, Symbol.toStringTag, { value: "Module" })), d9 = "networks/5.7.1", gx = new D(d9);
function f9(n) {
  return n && typeof n.renetwork == "function";
}
function gi(n) {
  const e = function(t, r) {
    r == null && (r = {});
    const i = [];
    if (t.InfuraProvider && r.infura !== "-")
      try {
        i.push(new t.InfuraProvider(n, r.infura));
      } catch {
      }
    if (t.EtherscanProvider && r.etherscan !== "-")
      try {
        i.push(new t.EtherscanProvider(n, r.etherscan));
      } catch {
      }
    if (t.AlchemyProvider && r.alchemy !== "-")
      try {
        i.push(new t.AlchemyProvider(n, r.alchemy));
      } catch {
      }
    if (t.PocketProvider && r.pocket !== "-") {
      const s = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const a = new t.PocketProvider(n, r.pocket);
        a.network && s.indexOf(a.network.name) === -1 && i.push(a);
      } catch {
      }
    }
    if (t.CloudflareProvider && r.cloudflare !== "-")
      try {
        i.push(new t.CloudflareProvider(n));
      } catch {
      }
    if (t.AnkrProvider && r.ankr !== "-")
      try {
        const s = ["ropsten"], a = new t.AnkrProvider(n, r.ankr);
        a.network && s.indexOf(a.network.name) === -1 && i.push(a);
      } catch {
      }
    if (i.length === 0)
      return null;
    if (t.FallbackProvider) {
      let s = 1;
      return r.quorum != null ? s = r.quorum : n === "homestead" && (s = 2), new t.FallbackProvider(i, s);
    }
    return i[0];
  };
  return e.renetwork = function(t) {
    return gi(t);
  }, e;
}
function bd(n, e) {
  const t = function(r, i) {
    return r.JsonRpcProvider ? new r.JsonRpcProvider(n, e) : null;
  };
  return t.renetwork = function(r) {
    return bd(n, r);
  }, t;
}
const xx = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: gi("homestead")
}, vx = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: gi("ropsten")
}, wx = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: bd("https://www.ethercluster.com/mordor", "classicMordor")
}, lc = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead: xx,
  mainnet: xx,
  morden: { chainId: 2, name: "morden" },
  ropsten: vx,
  testnet: vx,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: gi("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: gi("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: gi("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: gi("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: bd("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor: wx,
  classicTestnet: wx,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: bd("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: gi("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: gi("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function p9(n) {
  if (n == null)
    return null;
  if (typeof n == "number") {
    for (const r in lc) {
      const i = lc[r];
      if (i.chainId === n)
        return {
          name: i.name,
          chainId: i.chainId,
          ensAddress: i.ensAddress || null,
          _defaultProvider: i._defaultProvider || null
        };
    }
    return {
      chainId: n,
      name: "unknown"
    };
  }
  if (typeof n == "string") {
    const r = lc[n];
    return r == null ? null : {
      name: r.name,
      chainId: r.chainId,
      ensAddress: r.ensAddress,
      _defaultProvider: r._defaultProvider || null
    };
  }
  const e = lc[n.name];
  if (!e)
    return typeof n.chainId != "number" && gx.throwArgumentError("invalid network chainId", "network", n), n;
  n.chainId !== 0 && n.chainId !== e.chainId && gx.throwArgumentError("network chainId mismatch", "network", n);
  let t = n._defaultProvider || null;
  return t == null && e._defaultProvider && (f9(e._defaultProvider) ? t = e._defaultProvider.renetwork(n) : t = e._defaultProvider), {
    name: n.name,
    chainId: e.chainId,
    ensAddress: n.ensAddress || e.ensAddress || null,
    _defaultProvider: t
  };
}
const h9 = "web/5.7.1";
var y9 = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
function m9(n, e) {
  return y9(this, void 0, void 0, function* () {
    e == null && (e = {});
    const t = {
      method: e.method || "GET",
      headers: e.headers || {},
      body: e.body || void 0
    };
    if (e.skipFetchSetup !== !0 && (t.mode = "cors", t.cache = "no-cache", t.credentials = "same-origin", t.redirect = "follow", t.referrer = "client"), e.fetchOptions != null) {
      const a = e.fetchOptions;
      a.mode && (t.mode = a.mode), a.cache && (t.cache = a.cache), a.credentials && (t.credentials = a.credentials), a.redirect && (t.redirect = a.redirect), a.referrer && (t.referrer = a.referrer);
    }
    const r = yield fetch(n, t), i = yield r.arrayBuffer(), s = {};
    return r.headers.forEach ? r.headers.forEach((a, o) => {
      s[o.toLowerCase()] = a;
    }) : r.headers.keys().forEach((a) => {
      s[a.toLowerCase()] = r.headers.get(a);
    }), {
      headers: s,
      statusCode: r.status,
      statusMessage: r.statusText,
      body: q(new Uint8Array(i))
    };
  });
}
var b9 = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const Er = new D(h9);
function Tx(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function ts(n, e) {
  if (n == null)
    return null;
  if (typeof n == "string")
    return n;
  if (Il(n)) {
    if (e && (e.split("/")[0] === "text" || e.split(";")[0].trim() === "application/json"))
      try {
        return Ps(n);
      } catch {
      }
    return J(n);
  }
  return n;
}
function g9(n) {
  return Lt(n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))));
}
function N6(n, e, t) {
  const r = typeof n == "object" && n.throttleLimit != null ? n.throttleLimit : 12;
  Er.assertArgument(r > 0 && r % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", r);
  const i = typeof n == "object" ? n.throttleCallback : null, s = typeof n == "object" && typeof n.throttleSlotInterval == "number" ? n.throttleSlotInterval : 100;
  Er.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
  const a = typeof n == "object" ? !!n.errorPassThrough : !1, o = {};
  let u = null;
  const l = {
    method: "GET"
  };
  let d = !1, p = 2 * 60 * 1e3;
  if (typeof n == "string")
    u = n;
  else if (typeof n == "object") {
    if ((n == null || n.url == null) && Er.throwArgumentError("missing URL", "connection.url", n), u = n.url, typeof n.timeout == "number" && n.timeout > 0 && (p = n.timeout), n.headers)
      for (const M in n.headers)
        o[M.toLowerCase()] = { key: M, value: String(n.headers[M]) }, ["if-none-match", "if-modified-since"].indexOf(M.toLowerCase()) >= 0 && (d = !0);
    if (l.allowGzip = !!n.allowGzip, n.user != null && n.password != null) {
      u.substring(0, 6) !== "https:" && n.allowInsecureAuthentication !== !0 && Er.throwError("basic authentication requires a secure https url", D.errors.INVALID_ARGUMENT, { argument: "url", url: u, user: n.user, password: "[REDACTED]" });
      const M = n.user + ":" + n.password;
      o.authorization = {
        key: "Authorization",
        value: "Basic " + by(Lt(M))
      };
    }
    n.skipFetchSetup != null && (l.skipFetchSetup = !!n.skipFetchSetup), n.fetchOptions != null && (l.fetchOptions = zt(n.fetchOptions));
  }
  const m = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), w = u ? u.match(m) : null;
  if (w)
    try {
      const M = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": w[1] || "text/plain" },
        body: w[2] ? my(w[3]) : g9(w[3])
      };
      let I = M.body;
      return t && (I = t(M.body, M)), Promise.resolve(I);
    } catch (M) {
      Er.throwError("processing response error", D.errors.SERVER_ERROR, {
        body: ts(w[1], w[2]),
        error: M,
        requestBody: null,
        requestMethod: "GET",
        url: u
      });
    }
  e && (l.method = "POST", l.body = e, o["content-type"] == null && (o["content-type"] = { key: "Content-Type", value: "application/octet-stream" }), o["content-length"] == null && (o["content-length"] = { key: "Content-Length", value: String(e.length) }));
  const x = {};
  Object.keys(o).forEach((M) => {
    const I = o[M];
    x[I.key] = I.value;
  }), l.headers = x;
  const T = function() {
    let M = null;
    return { promise: new Promise(function(k, N) {
      p && (M = setTimeout(() => {
        M != null && (M = null, N(Er.makeError("timeout", D.errors.TIMEOUT, {
          requestBody: ts(l.body, x["content-type"]),
          requestMethod: l.method,
          timeout: p,
          url: u
        })));
      }, p));
    }), cancel: function() {
      M != null && (clearTimeout(M), M = null);
    } };
  }(), A = function() {
    return b9(this, void 0, void 0, function* () {
      for (let M = 0; M < r; M++) {
        let I = null;
        try {
          if (I = yield m9(u, l), M < r) {
            if (I.statusCode === 301 || I.statusCode === 302) {
              const k = I.headers.location || "";
              if (l.method === "GET" && k.match(/^https:/)) {
                u = I.headers.location;
                continue;
              }
            } else if (I.statusCode === 429) {
              let k = !0;
              if (i && (k = yield i(M, u)), k) {
                let N = 0;
                const U = I.headers["retry-after"];
                typeof U == "string" && U.match(/^[1-9][0-9]*$/) ? N = parseInt(U) * 1e3 : N = s * parseInt(String(Math.random() * Math.pow(2, M))), yield Tx(N);
                continue;
              }
            }
          }
        } catch (k) {
          I = k.response, I == null && (T.cancel(), Er.throwError("missing response", D.errors.SERVER_ERROR, {
            requestBody: ts(l.body, x["content-type"]),
            requestMethod: l.method,
            serverError: k,
            url: u
          }));
        }
        let B = I.body;
        if (d && I.statusCode === 304 ? B = null : !a && (I.statusCode < 200 || I.statusCode >= 300) && (T.cancel(), Er.throwError("bad response", D.errors.SERVER_ERROR, {
          status: I.statusCode,
          headers: I.headers,
          body: ts(B, I.headers ? I.headers["content-type"] : null),
          requestBody: ts(l.body, x["content-type"]),
          requestMethod: l.method,
          url: u
        })), t)
          try {
            const k = yield t(B, I);
            return T.cancel(), k;
          } catch (k) {
            if (k.throttleRetry && M < r) {
              let N = !0;
              if (i && (N = yield i(M, u)), N) {
                const U = s * parseInt(String(Math.random() * Math.pow(2, M)));
                yield Tx(U);
                continue;
              }
            }
            T.cancel(), Er.throwError("processing response error", D.errors.SERVER_ERROR, {
              body: ts(B, I.headers ? I.headers["content-type"] : null),
              error: k,
              requestBody: ts(l.body, x["content-type"]),
              requestMethod: l.method,
              url: u
            });
          }
        return T.cancel(), B;
      }
      return Er.throwError("failed response", D.errors.SERVER_ERROR, {
        requestBody: ts(l.body, x["content-type"]),
        requestMethod: l.method,
        url: u
      });
    });
  }();
  return Promise.race([T.promise, A]);
}
function yf(n, e, t) {
  let r = (s, a) => {
    let o = null;
    if (s != null)
      try {
        o = JSON.parse(Ps(s));
      } catch (u) {
        Er.throwError("invalid JSON", D.errors.SERVER_ERROR, {
          body: s,
          error: u
        });
      }
    return t && (o = t(o, a)), o;
  }, i = null;
  if (e != null) {
    i = Lt(e);
    const s = typeof n == "string" ? { url: n } : zt(n);
    s.headers ? Object.keys(s.headers).filter((o) => o.toLowerCase() === "content-type").length !== 0 || (s.headers = zt(s.headers), s.headers["content-type"] = "application/json") : s.headers = { "content-type": "application/json" }, n = s;
  }
  return N6(n, i, r);
}
function uo(n, e) {
  return e || (e = {}), e = zt(e), e.floor == null && (e.floor = 0), e.ceiling == null && (e.ceiling = 1e4), e.interval == null && (e.interval = 250), new Promise(function(t, r) {
    let i = null, s = !1;
    const a = () => s ? !1 : (s = !0, i && clearTimeout(i), !0);
    e.timeout && (i = setTimeout(() => {
      a() && r(new Error("timeout"));
    }, e.timeout));
    const o = e.retryLimit;
    let u = 0;
    function l() {
      return n().then(function(d) {
        if (d !== void 0)
          a() && t(d);
        else if (e.oncePoll)
          e.oncePoll.once("poll", l);
        else if (e.onceBlock)
          e.onceBlock.once("block", l);
        else if (!s) {
          if (u++, u > o) {
            a() && r(new Error("retry limit reached"));
            return;
          }
          let p = e.interval * parseInt(String(Math.random() * Math.pow(2, u)));
          p < e.floor && (p = e.floor), p > e.ceiling && (p = e.ceiling), setTimeout(l, p);
        }
        return null;
      }, function(d) {
        a() && r(d);
      });
    }
    l();
  });
}
const x9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _fetchData: N6,
  fetchJson: yf,
  poll: uo
}, Symbol.toStringTag, { value: "Module" }));
var gd = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Dh = {};
for (var cc = 0; cc < gd.length; cc++) {
  var Mp = gd.charAt(cc);
  if (Dh[Mp] !== void 0)
    throw new TypeError(Mp + " is ambiguous");
  Dh[Mp] = cc;
}
function mo(n) {
  var e = n >> 25;
  return (n & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059;
}
function D6(n) {
  for (var e = 1, t = 0; t < n.length; ++t) {
    var r = n.charCodeAt(t);
    if (r < 33 || r > 126)
      return "Invalid prefix (" + n + ")";
    e = mo(e) ^ r >> 5;
  }
  for (e = mo(e), t = 0; t < n.length; ++t) {
    var i = n.charCodeAt(t);
    e = mo(e) ^ i & 31;
  }
  return e;
}
function v9(n, e, t) {
  if (t = t || 90, n.length + 7 + e.length > t)
    throw new TypeError("Exceeds length limit");
  n = n.toLowerCase();
  var r = D6(n);
  if (typeof r == "string")
    throw new Error(r);
  for (var i = n + "1", s = 0; s < e.length; ++s) {
    var a = e[s];
    if (a >> 5)
      throw new Error("Non 5-bit word");
    r = mo(r) ^ a, i += gd.charAt(a);
  }
  for (s = 0; s < 6; ++s)
    r = mo(r);
  for (r ^= 1, s = 0; s < 6; ++s) {
    var o = r >> (5 - s) * 5 & 31;
    i += gd.charAt(o);
  }
  return i;
}
function B6(n, e) {
  if (e = e || 90, n.length < 8)
    return n + " too short";
  if (n.length > e)
    return "Exceeds length limit";
  var t = n.toLowerCase(), r = n.toUpperCase();
  if (n !== t && n !== r)
    return "Mixed-case string " + n;
  n = t;
  var i = n.lastIndexOf("1");
  if (i === -1)
    return "No separator character for " + n;
  if (i === 0)
    return "Missing prefix for " + n;
  var s = n.slice(0, i), a = n.slice(i + 1);
  if (a.length < 6)
    return "Data too short";
  var o = D6(s);
  if (typeof o == "string")
    return o;
  for (var u = [], l = 0; l < a.length; ++l) {
    var d = a.charAt(l), p = Dh[d];
    if (p === void 0)
      return "Unknown character " + d;
    o = mo(o) ^ p, !(l + 6 >= a.length) && u.push(p);
  }
  return o !== 1 ? "Invalid checksum for " + n : { prefix: s, words: u };
}
function w9() {
  var n = B6.apply(null, arguments);
  if (typeof n == "object")
    return n;
}
function T9(n) {
  var e = B6.apply(null, arguments);
  if (typeof e == "object")
    return e;
  throw new Error(e);
}
function mf(n, e, t, r) {
  for (var i = 0, s = 0, a = (1 << t) - 1, o = [], u = 0; u < n.length; ++u)
    for (i = i << e | n[u], s += e; s >= t; )
      s -= t, o.push(i >> s & a);
  if (r)
    s > 0 && o.push(i << t - s & a);
  else {
    if (s >= e)
      return "Excess padding";
    if (i << t - s & a)
      return "Non-zero padding";
  }
  return o;
}
function A9(n) {
  var e = mf(n, 8, 5, !0);
  if (Array.isArray(e))
    return e;
}
function E9(n) {
  var e = mf(n, 8, 5, !0);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
function S9(n) {
  var e = mf(n, 5, 8, !1);
  if (Array.isArray(e))
    return e;
}
function C9(n) {
  var e = mf(n, 5, 8, !1);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
var _9 = {
  decodeUnsafe: w9,
  decode: T9,
  encode: v9,
  toWordsUnsafe: A9,
  toWords: E9,
  fromWordsUnsafe: S9,
  fromWords: C9
};
const Ax = /* @__PURE__ */ _s(_9), Oy = "providers/5.7.2", ru = new D(Oy);
class ie {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const e = {}, t = this.address.bind(this), r = this.bigNumber.bind(this), i = this.blockTag.bind(this), s = this.data.bind(this), a = this.hash.bind(this), o = this.hex.bind(this), u = this.number.bind(this), l = this.type.bind(this), d = (p) => this.data(p, !0);
    return e.transaction = {
      hash: a,
      type: l,
      accessList: ie.allowNull(this.accessList.bind(this), null),
      blockHash: ie.allowNull(a, null),
      blockNumber: ie.allowNull(u, null),
      transactionIndex: ie.allowNull(u, null),
      confirmations: ie.allowNull(u, null),
      from: t,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: ie.allowNull(r),
      maxPriorityFeePerGas: ie.allowNull(r),
      maxFeePerGas: ie.allowNull(r),
      gasLimit: r,
      to: ie.allowNull(t, null),
      value: r,
      nonce: u,
      data: s,
      r: ie.allowNull(this.uint256),
      s: ie.allowNull(this.uint256),
      v: ie.allowNull(u),
      creates: ie.allowNull(t, null),
      raw: ie.allowNull(s)
    }, e.transactionRequest = {
      from: ie.allowNull(t),
      nonce: ie.allowNull(u),
      gasLimit: ie.allowNull(r),
      gasPrice: ie.allowNull(r),
      maxPriorityFeePerGas: ie.allowNull(r),
      maxFeePerGas: ie.allowNull(r),
      to: ie.allowNull(t),
      value: ie.allowNull(r),
      data: ie.allowNull(d),
      type: ie.allowNull(u),
      accessList: ie.allowNull(this.accessList.bind(this), null)
    }, e.receiptLog = {
      transactionIndex: u,
      blockNumber: u,
      transactionHash: a,
      address: t,
      topics: ie.arrayOf(a),
      data: s,
      logIndex: u,
      blockHash: a
    }, e.receipt = {
      to: ie.allowNull(this.address, null),
      from: ie.allowNull(this.address, null),
      contractAddress: ie.allowNull(t, null),
      transactionIndex: u,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: ie.allowNull(o),
      gasUsed: r,
      logsBloom: ie.allowNull(s),
      blockHash: a,
      transactionHash: a,
      logs: ie.arrayOf(this.receiptLog.bind(this)),
      blockNumber: u,
      confirmations: ie.allowNull(u, null),
      cumulativeGasUsed: r,
      effectiveGasPrice: ie.allowNull(r),
      status: ie.allowNull(u),
      type: l
    }, e.block = {
      hash: ie.allowNull(a),
      parentHash: a,
      number: u,
      timestamp: u,
      nonce: ie.allowNull(o),
      difficulty: this.difficulty.bind(this),
      gasLimit: r,
      gasUsed: r,
      miner: ie.allowNull(t),
      extraData: s,
      transactions: ie.allowNull(ie.arrayOf(a)),
      baseFeePerGas: ie.allowNull(r)
    }, e.blockWithTransactions = zt(e.block), e.blockWithTransactions.transactions = ie.allowNull(ie.arrayOf(this.transactionResponse.bind(this))), e.filter = {
      fromBlock: ie.allowNull(i, void 0),
      toBlock: ie.allowNull(i, void 0),
      blockHash: ie.allowNull(a, void 0),
      address: ie.allowNull(t, void 0),
      topics: ie.allowNull(this.topics.bind(this), void 0)
    }, e.filterLog = {
      blockNumber: ie.allowNull(u),
      blockHash: ie.allowNull(a),
      transactionIndex: u,
      removed: ie.allowNull(this.boolean.bind(this)),
      address: t,
      data: ie.allowFalsish(s, "0x"),
      topics: ie.arrayOf(a),
      transactionHash: a,
      logIndex: u
    }, e;
  }
  accessList(e) {
    return Ua(e || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(e) {
    return e === "0x" ? 0 : H.from(e).toNumber();
  }
  type(e) {
    return e === "0x" || e == null ? 0 : H.from(e).toNumber();
  }
  // Strict! Used on input.
  bigNumber(e) {
    return H.from(e);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(e) {
    if (typeof e == "boolean")
      return e;
    if (typeof e == "string") {
      if (e = e.toLowerCase(), e === "true")
        return !0;
      if (e === "false")
        return !1;
    }
    throw new Error("invalid boolean - " + e);
  }
  hex(e, t) {
    return typeof e == "string" && (!t && e.substring(0, 2) !== "0x" && (e = "0x" + e), _e(e)) ? e.toLowerCase() : ru.throwArgumentError("invalid hash", "value", e);
  }
  data(e, t) {
    const r = this.hex(e, t);
    if (r.length % 2 !== 0)
      throw new Error("invalid data; odd-length - " + e);
    return r;
  }
  // Requires an address
  // Strict! Used on input.
  address(e) {
    return Fe(e);
  }
  callAddress(e) {
    if (!_e(e, 32))
      return null;
    const t = Fe(Bt(e, 12));
    return t === lC ? null : t;
  }
  contractAddress(e) {
    return dy(e);
  }
  // Strict! Used on input.
  blockTag(e) {
    if (e == null)
      return "latest";
    if (e === "earliest")
      return "0x0";
    switch (e) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return e;
    }
    if (typeof e == "number" || _e(e))
      return rf(e);
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(e, t) {
    const r = this.hex(e, t);
    return ni(r) !== 32 ? ru.throwArgumentError("invalid hash", "value", e) : r;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(e) {
    if (e == null)
      return null;
    const t = H.from(e);
    try {
      return t.toNumber();
    } catch {
    }
    return null;
  }
  uint256(e) {
    if (!_e(e))
      throw new Error("invalid uint256");
    return Le(e, 32);
  }
  _block(e, t) {
    e.author != null && e.miner == null && (e.miner = e.author);
    const r = e._difficulty != null ? e._difficulty : e.difficulty, i = ie.check(t, e);
    return i._difficulty = r == null ? null : H.from(r), i;
  }
  block(e) {
    return this._block(e, this.formats.block);
  }
  blockWithTransactions(e) {
    return this._block(e, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(e) {
    return ie.check(this.formats.transactionRequest, e);
  }
  transactionResponse(e) {
    e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas), e.to && H.from(e.to).isZero() && (e.to = "0x0000000000000000000000000000000000000000"), e.input != null && e.data == null && (e.data = e.input), e.to == null && e.creates == null && (e.creates = this.contractAddress(e)), (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = []);
    const t = ie.check(this.formats.transaction, e);
    if (e.chainId != null) {
      let r = e.chainId;
      _e(r) && (r = H.from(r).toNumber()), t.chainId = r;
    } else {
      let r = e.networkId;
      r == null && t.v == null && (r = e.chainId), _e(r) && (r = H.from(r).toNumber()), typeof r != "number" && t.v != null && (r = (t.v - 35) / 2, r < 0 && (r = 0), r = parseInt(r)), typeof r != "number" && (r = 0), t.chainId = r;
    }
    return t.blockHash && t.blockHash.replace(/0/g, "") === "x" && (t.blockHash = null), t;
  }
  transaction(e) {
    return y6(e);
  }
  receiptLog(e) {
    return ie.check(this.formats.receiptLog, e);
  }
  receipt(e) {
    const t = ie.check(this.formats.receipt, e);
    if (t.root != null)
      if (t.root.length <= 4) {
        const r = H.from(t.root).toNumber();
        r === 0 || r === 1 ? (t.status != null && t.status !== r && ru.throwArgumentError("alt-root-status/status mismatch", "value", { root: t.root, status: t.status }), t.status = r, delete t.root) : ru.throwArgumentError("invalid alt-root-status", "value.root", t.root);
      } else
        t.root.length !== 66 && ru.throwArgumentError("invalid root hash", "value.root", t.root);
    return t.status != null && (t.byzantium = !0), t;
  }
  topics(e) {
    return Array.isArray(e) ? e.map((t) => this.topics(t)) : e != null ? this.hash(e, !0) : null;
  }
  filter(e) {
    return ie.check(this.formats.filter, e);
  }
  filterLog(e) {
    return ie.check(this.formats.filterLog, e);
  }
  static check(e, t) {
    const r = {};
    for (const i in e)
      try {
        const s = e[i](t[i]);
        s !== void 0 && (r[i] = s);
      } catch (s) {
        throw s.checkKey = i, s.checkValue = t[i], s;
      }
    return r;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(e, t) {
    return function(r) {
      return r == null ? t : e(r);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(e, t) {
    return function(r) {
      return r ? e(r) : t;
    };
  }
  // Requires an Array satisfying check
  static arrayOf(e) {
    return function(t) {
      if (!Array.isArray(t))
        throw new Error("not an array");
      const r = [];
      return t.forEach(function(i) {
        r.push(e(i));
      }), r;
    };
  }
}
var pe = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const ge = new D(Oy), M9 = 10;
function Ex(n) {
  return n == null ? "null" : (ni(n) !== 32 && ge.throwArgumentError("invalid topic", "topic", n), n.toLowerCase());
}
function Sx(n) {
  for (n = n.slice(); n.length > 0 && n[n.length - 1] == null; )
    n.pop();
  return n.map((e) => {
    if (Array.isArray(e)) {
      const t = {};
      e.forEach((i) => {
        t[Ex(i)] = !0;
      });
      const r = Object.keys(t);
      return r.sort(), r.join("|");
    } else
      return Ex(e);
  }).join("&");
}
function P9(n) {
  return n === "" ? [] : n.split(/&/g).map((e) => {
    if (e === "")
      return [];
    const t = e.split("|").map((r) => r === "null" ? null : r);
    return t.length === 1 ? t[0] : t;
  });
}
function Ha(n) {
  if (typeof n == "string") {
    if (n = n.toLowerCase(), ni(n) === 32)
      return "tx:" + n;
    if (n.indexOf(":") === -1)
      return n;
  } else {
    if (Array.isArray(n))
      return "filter:*:" + Sx(n);
    if (A_.isForkEvent(n))
      throw ge.warn("not implemented"), new Error("not implemented");
    if (n && typeof n == "object")
      return "filter:" + (n.address || "*") + ":" + Sx(n.topics || []);
  }
  throw new Error("invalid event - " + n);
}
function iu() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function Cx(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
const R9 = ["block", "network", "pending", "poll"];
class I9 {
  constructor(e, t, r) {
    j(this, "tag", e), j(this, "listener", t), j(this, "once", r), this._lastBlockNumber = -2, this._inflight = !1;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const e = this.tag.split(":");
    return e[0] !== "tx" ? null : e[1];
  }
  get filter() {
    const e = this.tag.split(":");
    if (e[0] !== "filter")
      return null;
    const t = e[1], r = P9(e[2]), i = {};
    return r.length > 0 && (i.topics = r), t && t !== "*" && (i.address = t), i;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || R9.indexOf(this.tag) >= 0;
  }
}
const O9 = {
  0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
  60: { symbol: "eth", ilk: "eth" },
  61: { symbol: "etc", ilk: "eth" },
  700: { symbol: "xdai", ilk: "eth" }
};
function Pp(n) {
  return Le(H.from(n).toHexString(), 32);
}
function _x(n) {
  return Eo.encode(Ge([n, Bt(Di(Di(n)), 0, 4)]));
}
const F6 = new RegExp("^(ipfs)://(.*)$", "i"), Mx = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  F6,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function Dc(n, e) {
  try {
    return Ps(tl(n, e));
  } catch {
  }
  return null;
}
function tl(n, e) {
  if (n === "0x")
    return null;
  const t = H.from(Bt(n, e, e + 32)).toNumber(), r = H.from(Bt(n, t, t + 32)).toNumber();
  return Bt(n, t + 32, t + 32 + r);
}
function Rp(n) {
  return n.match(/^ipfs:\/\/ipfs\//i) ? n = n.substring(12) : n.match(/^ipfs:\/\//i) ? n = n.substring(7) : ge.throwArgumentError("unsupported IPFS format", "link", n), `https://gateway.ipfs.io/ipfs/${n}`;
}
function Px(n) {
  const e = q(n);
  if (e.length > 32)
    throw new Error("internal; should not happen");
  const t = new Uint8Array(32);
  return t.set(e, 32 - e.length), t;
}
function k9(n) {
  if (n.length % 32 === 0)
    return n;
  const e = new Uint8Array(Math.ceil(n.length / 32) * 32);
  return e.set(n), e;
}
function L6(n) {
  const e = [];
  let t = 0;
  for (let r = 0; r < n.length; r++)
    e.push(null), t += 32;
  for (let r = 0; r < n.length; r++) {
    const i = q(n[r]);
    e[r] = Px(t), e.push(Px(i.length)), e.push(k9(i)), t += 32 + Math.ceil(i.length / 32) * 32;
  }
  return Sn(e);
}
class Rx {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(e, t, r, i) {
    j(this, "provider", e), j(this, "name", r), j(this, "address", e.formatter.address(t)), j(this, "_resolvedAddress", i);
  }
  supportsWildcard() {
    return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
      to: this.address,
      data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
    }).then((e) => H.from(e).eq(1)).catch((e) => {
      if (e.code === D.errors.CALL_EXCEPTION)
        return !1;
      throw this._supportsEip2544 = null, e;
    })), this._supportsEip2544;
  }
  _fetch(e, t) {
    return pe(this, void 0, void 0, function* () {
      const r = {
        to: this.address,
        ccipReadEnabled: !0,
        data: Sn([e, _u(this.name), t || "0x"])
      };
      let i = !1;
      (yield this.supportsWildcard()) && (i = !0, r.data = Sn(["0x9061b923", L6([Nw(this.name), r.data])]));
      try {
        let s = yield this.provider.call(r);
        return q(s).length % 32 === 4 && ge.throwError("resolver threw error", D.errors.CALL_EXCEPTION, {
          transaction: r,
          data: s
        }), i && (s = tl(s, 0)), s;
      } catch (s) {
        if (s.code === D.errors.CALL_EXCEPTION)
          return null;
        throw s;
      }
    });
  }
  _fetchBytes(e, t) {
    return pe(this, void 0, void 0, function* () {
      const r = yield this._fetch(e, t);
      return r != null ? tl(r, 0) : null;
    });
  }
  _getAddress(e, t) {
    const r = O9[String(e)];
    if (r == null && ge.throwError(`unsupported coin type: ${e}`, D.errors.UNSUPPORTED_OPERATION, {
      operation: `getAddress(${e})`
    }), r.ilk === "eth")
      return this.provider.formatter.address(t);
    const i = q(t);
    if (r.p2pkh != null) {
      const s = t.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75)
          return _x(Ge([[r.p2pkh], "0x" + s[2]]));
      }
    }
    if (r.p2sh != null) {
      const s = t.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75)
          return _x(Ge([[r.p2sh], "0x" + s[2]]));
      }
    }
    if (r.prefix != null) {
      const s = i[1];
      let a = i[0];
      if (a === 0 ? s !== 20 && s !== 32 && (a = -1) : a = -1, a >= 0 && i.length === 2 + s && s >= 1 && s <= 75) {
        const o = Ax.toWords(i.slice(2));
        return o.unshift(a), Ax.encode(r.prefix, o);
      }
    }
    return null;
  }
  getAddress(e) {
    return pe(this, void 0, void 0, function* () {
      if (e == null && (e = 60), e === 60)
        try {
          const i = yield this._fetch("0x3b3b57de");
          return i === "0x" || i === ww ? null : this.provider.formatter.callAddress(i);
        } catch (i) {
          if (i.code === D.errors.CALL_EXCEPTION)
            return null;
          throw i;
        }
      const t = yield this._fetchBytes("0xf1cb7e06", Pp(e));
      if (t == null || t === "0x")
        return null;
      const r = this._getAddress(e, t);
      return r == null && ge.throwError("invalid or unsupported coin data", D.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${e})`,
        coinType: e,
        data: t
      }), r;
    });
  }
  getAvatar() {
    return pe(this, void 0, void 0, function* () {
      const e = [{ type: "name", content: this.name }];
      try {
        const t = yield this.getText("avatar");
        if (t == null)
          return null;
        for (let r = 0; r < Mx.length; r++) {
          const i = t.match(Mx[r]);
          if (i == null)
            continue;
          const s = i[1].toLowerCase();
          switch (s) {
            case "https":
              return e.push({ type: "url", content: t }), { linkage: e, url: t };
            case "data":
              return e.push({ type: "data", content: t }), { linkage: e, url: t };
            case "ipfs":
              return e.push({ type: "ipfs", content: t }), { linkage: e, url: Rp(t) };
            case "erc721":
            case "erc1155": {
              const a = s === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              e.push({ type: s, content: t });
              const o = this._resolvedAddress || (yield this.getAddress()), u = (i[2] || "").split("/");
              if (u.length !== 2)
                return null;
              const l = yield this.provider.formatter.address(u[0]), d = Le(H.from(u[1]).toHexString(), 32);
              if (s === "erc721") {
                const T = this.provider.formatter.callAddress(yield this.provider.call({
                  to: l,
                  data: Sn(["0x6352211e", d])
                }));
                if (o !== T)
                  return null;
                e.push({ type: "owner", content: T });
              } else if (s === "erc1155") {
                const T = H.from(yield this.provider.call({
                  to: l,
                  data: Sn(["0x00fdd58e", Le(o, 32), d])
                }));
                if (T.isZero())
                  return null;
                e.push({ type: "balance", content: T.toString() });
              }
              const p = {
                to: this.provider.formatter.address(u[0]),
                data: Sn([a, d])
              };
              let m = Dc(yield this.provider.call(p), 0);
              if (m == null)
                return null;
              e.push({ type: "metadata-url-base", content: m }), s === "erc1155" && (m = m.replace("{id}", d.substring(2)), e.push({ type: "metadata-url-expanded", content: m })), m.match(/^ipfs:/i) && (m = Rp(m)), e.push({ type: "metadata-url", content: m });
              const w = yield yf(m);
              if (!w)
                return null;
              e.push({ type: "metadata", content: JSON.stringify(w) });
              let x = w.image;
              if (typeof x != "string")
                return null;
              if (!x.match(/^(https:\/\/|data:)/i)) {
                if (x.match(F6) == null)
                  return null;
                e.push({ type: "url-ipfs", content: x }), x = Rp(x);
              }
              return e.push({ type: "url", content: x }), { linkage: e, url: x };
            }
          }
        }
      } catch {
      }
      return null;
    });
  }
  getContentHash() {
    return pe(this, void 0, void 0, function* () {
      const e = yield this._fetchBytes("0xbc1c58d1");
      if (e == null || e === "0x")
        return null;
      const t = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (t) {
        const a = parseInt(t[3], 16);
        if (t[4].length === a * 2)
          return "ipfs://" + Eo.encode("0x" + t[1]);
      }
      const r = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (r) {
        const a = parseInt(r[3], 16);
        if (r[4].length === a * 2)
          return "ipns://" + Eo.encode("0x" + r[1]);
      }
      const i = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (i && i[1].length === 32 * 2)
        return "bzz://" + i[1];
      const s = e.match(/^0x90b2c605([0-9a-f]*)$/);
      if (s && s[1].length === 34 * 2) {
        const a = { "=": "", "+": "-", "/": "_" };
        return "sia://" + by("0x" + s[1]).replace(/[=+\/]/g, (u) => a[u]);
      }
      return ge.throwError("invalid or unsupported content hash data", D.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: e
      });
    });
  }
  getText(e) {
    return pe(this, void 0, void 0, function* () {
      let t = Lt(e);
      t = Ge([Pp(64), Pp(t.length), t]), t.length % 32 !== 0 && (t = Ge([t, Le("0x", 32 - e.length % 32)]));
      const r = yield this._fetchBytes("0x59d1d43c", J(t));
      return r == null || r === "0x" ? null : Ps(r);
    });
  }
}
let Ip = null, N9 = 1;
class D9 extends xy {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(e) {
    if (super(), this._events = [], this._emitted = { block: -2 }, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), j(this, "anyNetwork", e === "any"), this.anyNetwork && (e = this.detectNetwork()), e instanceof Promise)
      this._networkPromise = e, e.catch((t) => {
      }), this._ready().catch((t) => {
      });
    else {
      const t = Rr(new.target, "getNetwork")(e);
      t ? (j(this, "_network", t), this.emit("network", t, null)) : ge.throwArgumentError("invalid network", "network", e);
    }
    this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0;
  }
  _ready() {
    return pe(this, void 0, void 0, function* () {
      if (this._network == null) {
        let e = null;
        if (this._networkPromise)
          try {
            e = yield this._networkPromise;
          } catch {
          }
        e == null && (e = yield this.detectNetwork()), e || ge.throwError("no network detected", D.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = e : j(this, "_network", e), this.emit("network", e, null));
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return uo(() => this._ready().then((e) => e, (e) => {
      if (!(e.code === D.errors.NETWORK_ERROR && e.event === "noNetwork"))
        throw e;
    }));
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    return Ip == null && (Ip = new ie()), Ip;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(e) {
    return p9(e ?? "homestead");
  }
  ccipReadFetch(e, t, r) {
    return pe(this, void 0, void 0, function* () {
      if (this.disableCcipRead || r.length === 0)
        return null;
      const i = e.to.toLowerCase(), s = t.toLowerCase(), a = [];
      for (let o = 0; o < r.length; o++) {
        const u = r[o], l = u.replace("{sender}", i).replace("{data}", s), d = u.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: s, sender: i }), p = yield yf({ url: l, errorPassThrough: !0 }, d, (w, x) => (w.status = x.statusCode, w));
        if (p.data)
          return p.data;
        const m = p.message || "unknown error";
        if (p.status >= 400 && p.status < 500)
          return ge.throwError(`response not found during CCIP fetch: ${m}`, D.errors.SERVER_ERROR, { url: u, errorMessage: m });
        a.push(m);
      }
      return ge.throwError(`error encountered during CCIP fetch: ${a.map((o) => JSON.stringify(o)).join(", ")}`, D.errors.SERVER_ERROR, {
        urls: r,
        errorMessages: a
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(e) {
    return pe(this, void 0, void 0, function* () {
      if (yield this._ready(), e > 0)
        for (; this._internalBlockNumber; ) {
          const i = this._internalBlockNumber;
          try {
            const s = yield i;
            if (iu() - s.respTime <= e)
              return s.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === i)
              break;
          }
        }
      const t = iu(), r = Rt({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((i) => null, (i) => i)
      }).then(({ blockNumber: i, networkError: s }) => {
        if (s)
          throw this._internalBlockNumber === r && (this._internalBlockNumber = null), s;
        const a = iu();
        return i = H.from(i).toNumber(), i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber), this._maxInternalBlockNumber = i, this._setFastBlockNumber(i), { blockNumber: i, reqTime: t, respTime: a };
      });
      return this._internalBlockNumber = r, r.catch((i) => {
        this._internalBlockNumber === r && (this._internalBlockNumber = null);
      }), (yield r).blockNumber;
    });
  }
  poll() {
    return pe(this, void 0, void 0, function* () {
      const e = N9++, t = [];
      let r = null;
      try {
        r = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (i) {
        this.emit("error", i);
        return;
      }
      if (this._setFastBlockNumber(r), this.emit("poll", e, r), r === this._lastBlockNumber) {
        this.emit("didPoll", e);
        return;
      }
      if (this._emitted.block === -2 && (this._emitted.block = r - 1), Math.abs(this._emitted.block - r) > 1e3)
        ge.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${r})`), this.emit("error", ge.makeError("network block skew detected", D.errors.NETWORK_ERROR, {
          blockNumber: r,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        })), this.emit("block", r);
      else
        for (let i = this._emitted.block + 1; i <= r; i++)
          this.emit("block", i);
      this._emitted.block !== r && (this._emitted.block = r, Object.keys(this._emitted).forEach((i) => {
        if (i === "block")
          return;
        const s = this._emitted[i];
        s !== "pending" && r - s > 12 && delete this._emitted[i];
      })), this._lastBlockNumber === -2 && (this._lastBlockNumber = r - 1), this._events.forEach((i) => {
        switch (i.type) {
          case "tx": {
            const s = i.hash;
            let a = this.getTransactionReceipt(s).then((o) => (!o || o.blockNumber == null || (this._emitted["t:" + s] = o.blockNumber, this.emit(s, o)), null)).catch((o) => {
              this.emit("error", o);
            });
            t.push(a);
            break;
          }
          case "filter": {
            if (!i._inflight) {
              i._inflight = !0, i._lastBlockNumber === -2 && (i._lastBlockNumber = r - 1);
              const s = i.filter;
              s.fromBlock = i._lastBlockNumber + 1, s.toBlock = r;
              const a = s.toBlock - this._maxFilterBlockRange;
              a > s.fromBlock && (s.fromBlock = a), s.fromBlock < 0 && (s.fromBlock = 0);
              const o = this.getLogs(s).then((u) => {
                i._inflight = !1, u.length !== 0 && u.forEach((l) => {
                  l.blockNumber > i._lastBlockNumber && (i._lastBlockNumber = l.blockNumber), this._emitted["b:" + l.blockHash] = l.blockNumber, this._emitted["t:" + l.transactionHash] = l.blockNumber, this.emit(s, l);
                });
              }).catch((u) => {
                this.emit("error", u), i._inflight = !1;
              });
              t.push(o);
            }
            break;
          }
        }
      }), this._lastBlockNumber = r, Promise.all(t).then(() => {
        this.emit("didPoll", e);
      }).catch((i) => {
        this.emit("error", i);
      });
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(e) {
    this._lastBlockNumber = e - 1, this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return pe(this, void 0, void 0, function* () {
      return ge.throwError("provider does not support network detection", D.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return pe(this, void 0, void 0, function* () {
      const e = yield this._ready(), t = yield this.detectNetwork();
      if (e.chainId !== t.chainId) {
        if (this.anyNetwork)
          return this._network = t, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", t, e), yield Cx(0), this._network;
        const r = ge.makeError("underlying network changed", D.errors.NETWORK_ERROR, {
          event: "changed",
          network: e,
          detectedNetwork: t
        });
        throw this.emit("error", r), r;
      }
      return e;
    });
  }
  get blockNumber() {
    return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((e) => {
      this._setFastBlockNumber(e);
    }, (e) => {
    }), this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(e) {
    e && !this._poller ? (this._poller = setInterval(() => {
      this.poll();
    }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
      this.poll(), this._bootstrapPoll = setTimeout(() => {
        this._poller || this.poll(), this._bootstrapPoll = null;
      }, this.pollingInterval);
    }, 0))) : !e && this._poller && (clearInterval(this._poller), this._poller = null);
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(e) {
    if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e)
      throw new Error("invalid polling interval");
    this._pollingInterval = e, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
      this.poll();
    }, this._pollingInterval));
  }
  _getFastBlockNumber() {
    const e = iu();
    return e - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = e, this._fastBlockNumberPromise = this.getBlockNumber().then((t) => ((this._fastBlockNumber == null || t > this._fastBlockNumber) && (this._fastBlockNumber = t), this._fastBlockNumber))), this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(e) {
    this._fastBlockNumber != null && e < this._fastBlockNumber || (this._fastQueryDate = iu(), (this._fastBlockNumber == null || e > this._fastBlockNumber) && (this._fastBlockNumber = e, this._fastBlockNumberPromise = Promise.resolve(e)));
  }
  waitForTransaction(e, t, r) {
    return pe(this, void 0, void 0, function* () {
      return this._waitForTransaction(e, t ?? 1, r || 0, null);
    });
  }
  _waitForTransaction(e, t, r, i) {
    return pe(this, void 0, void 0, function* () {
      const s = yield this.getTransactionReceipt(e);
      return (s ? s.confirmations : 0) >= t ? s : new Promise((a, o) => {
        const u = [];
        let l = !1;
        const d = function() {
          return l ? !0 : (l = !0, u.forEach((m) => {
            m();
          }), !1);
        }, p = (m) => {
          m.confirmations < t || d() || a(m);
        };
        if (this.on(e, p), u.push(() => {
          this.removeListener(e, p);
        }), i) {
          let m = i.startBlock, w = null;
          const x = (T) => pe(this, void 0, void 0, function* () {
            l || (yield Cx(1e3), this.getTransactionCount(i.from).then((A) => pe(this, void 0, void 0, function* () {
              if (!l) {
                if (A <= i.nonce)
                  m = T;
                else {
                  {
                    const M = yield this.getTransaction(e);
                    if (M && M.blockNumber != null)
                      return;
                  }
                  for (w == null && (w = m - 3, w < i.startBlock && (w = i.startBlock)); w <= T; ) {
                    if (l)
                      return;
                    const M = yield this.getBlockWithTransactions(w);
                    for (let I = 0; I < M.transactions.length; I++) {
                      const B = M.transactions[I];
                      if (B.hash === e)
                        return;
                      if (B.from === i.from && B.nonce === i.nonce) {
                        if (l)
                          return;
                        const k = yield this.waitForTransaction(B.hash, t);
                        if (d())
                          return;
                        let N = "replaced";
                        B.data === i.data && B.to === i.to && B.value.eq(i.value) ? N = "repriced" : B.data === "0x" && B.from === B.to && B.value.isZero() && (N = "cancelled"), o(ge.makeError("transaction was replaced", D.errors.TRANSACTION_REPLACED, {
                          cancelled: N === "replaced" || N === "cancelled",
                          reason: N,
                          replacement: this._wrapTransaction(B),
                          hash: e,
                          receipt: k
                        }));
                        return;
                      }
                    }
                    w++;
                  }
                }
                l || this.once("block", x);
              }
            }), (A) => {
              l || this.once("block", x);
            }));
          });
          if (l)
            return;
          this.once("block", x), u.push(() => {
            this.removeListener("block", x);
          });
        }
        if (typeof r == "number" && r > 0) {
          const m = setTimeout(() => {
            d() || o(ge.makeError("timeout exceeded", D.errors.TIMEOUT, { timeout: r }));
          }, r);
          m.unref && m.unref(), u.push(() => {
            clearTimeout(m);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return pe(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const e = yield this.perform("getGasPrice", {});
      try {
        return H.from(e);
      } catch (t) {
        return ge.throwError("bad result from backend", D.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result: e,
          error: t
        });
      }
    });
  }
  getBalance(e, t) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Rt({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(t)
      }), i = yield this.perform("getBalance", r);
      try {
        return H.from(i);
      } catch (s) {
        return ge.throwError("bad result from backend", D.errors.SERVER_ERROR, {
          method: "getBalance",
          params: r,
          result: i,
          error: s
        });
      }
    });
  }
  getTransactionCount(e, t) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Rt({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(t)
      }), i = yield this.perform("getTransactionCount", r);
      try {
        return H.from(i).toNumber();
      } catch (s) {
        return ge.throwError("bad result from backend", D.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params: r,
          result: i,
          error: s
        });
      }
    });
  }
  getCode(e, t) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Rt({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(t)
      }), i = yield this.perform("getCode", r);
      try {
        return J(i);
      } catch (s) {
        return ge.throwError("bad result from backend", D.errors.SERVER_ERROR, {
          method: "getCode",
          params: r,
          result: i,
          error: s
        });
      }
    });
  }
  getStorageAt(e, t, r) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield Rt({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(r),
        position: Promise.resolve(t).then((a) => rf(a))
      }), s = yield this.perform("getStorageAt", i);
      try {
        return J(s);
      } catch (a) {
        return ge.throwError("bad result from backend", D.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params: i,
          result: s,
          error: a
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(e, t, r) {
    if (t != null && ni(t) !== 32)
      throw new Error("invalid response - sendTransaction");
    const i = e;
    return t != null && e.hash !== t && ge.throwError("Transaction hash mismatch from Provider.sendTransaction.", D.errors.UNKNOWN_ERROR, { expectedHash: e.hash, returnedHash: t }), i.wait = (s, a) => pe(this, void 0, void 0, function* () {
      s == null && (s = 1), a == null && (a = 0);
      let o;
      s !== 0 && r != null && (o = {
        data: e.data,
        from: e.from,
        nonce: e.nonce,
        to: e.to,
        value: e.value,
        startBlock: r
      });
      const u = yield this._waitForTransaction(e.hash, s, a, o);
      return u == null && s === 0 ? null : (this._emitted["t:" + e.hash] = u.blockNumber, u.status === 0 && ge.throwError("transaction failed", D.errors.CALL_EXCEPTION, {
        transactionHash: e.hash,
        transaction: e,
        receipt: u
      }), u);
    }), i;
  }
  sendTransaction(e) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Promise.resolve(e).then((s) => J(s)), r = this.formatter.transaction(e);
      r.confirmations == null && (r.confirmations = 0);
      const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const s = yield this.perform("sendTransaction", { signedTransaction: t });
        return this._wrapTransaction(r, s, i);
      } catch (s) {
        throw s.transaction = r, s.transactionHash = r.hash, s;
      }
    });
  }
  _getTransactionRequest(e) {
    return pe(this, void 0, void 0, function* () {
      const t = yield e, r = {};
      return ["from", "to"].forEach((i) => {
        t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => s ? this._getAddress(s) : null));
      }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((i) => {
        t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => s ? H.from(s) : null));
      }), ["type"].forEach((i) => {
        t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => s ?? null));
      }), t.accessList && (r.accessList = this.formatter.accessList(t.accessList)), ["data"].forEach((i) => {
        t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => s ? J(s) : null));
      }), this.formatter.transactionRequest(yield Rt(r));
    });
  }
  _getFilter(e) {
    return pe(this, void 0, void 0, function* () {
      e = yield e;
      const t = {};
      return e.address != null && (t.address = this._getAddress(e.address)), ["blockHash", "topics"].forEach((r) => {
        e[r] != null && (t[r] = e[r]);
      }), ["fromBlock", "toBlock"].forEach((r) => {
        e[r] != null && (t[r] = this._getBlockTag(e[r]));
      }), this.formatter.filter(yield Rt(t));
    });
  }
  _call(e, t, r) {
    return pe(this, void 0, void 0, function* () {
      r >= M9 && ge.throwError("CCIP read exceeded maximum redirections", D.errors.SERVER_ERROR, {
        redirects: r,
        transaction: e
      });
      const i = e.to, s = yield this.perform("call", { transaction: e, blockTag: t });
      if (r >= 0 && t === "latest" && i != null && s.substring(0, 10) === "0x556f1830" && ni(s) % 32 === 4)
        try {
          const a = Bt(s, 4), o = Bt(a, 0, 32);
          H.from(o).eq(i) || ge.throwError("CCIP Read sender did not match", D.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const u = [], l = H.from(Bt(a, 32, 64)).toNumber(), d = H.from(Bt(a, l, l + 32)).toNumber(), p = Bt(a, l + 32);
          for (let M = 0; M < d; M++) {
            const I = Dc(p, M * 32);
            I == null && ge.throwError("CCIP Read contained corrupt URL string", D.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: e,
              data: s
            }), u.push(I);
          }
          const m = tl(a, 64);
          H.from(Bt(a, 100, 128)).isZero() || ge.throwError("CCIP Read callback selector included junk", D.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const w = Bt(a, 96, 100), x = tl(a, 128), T = yield this.ccipReadFetch(e, m, u);
          T == null && ge.throwError("CCIP Read disabled or provided no URLs", D.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const A = {
            to: i,
            data: Sn([w, L6([T, x])])
          };
          return this._call(A, t, r + 1);
        } catch (a) {
          if (a.code === D.errors.SERVER_ERROR)
            throw a;
        }
      try {
        return J(s);
      } catch (a) {
        return ge.throwError("bad result from backend", D.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction: e, blockTag: t },
          result: s,
          error: a
        });
      }
    });
  }
  call(e, t) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Rt({
        transaction: this._getTransactionRequest(e),
        blockTag: this._getBlockTag(t),
        ccipReadEnabled: Promise.resolve(e.ccipReadEnabled)
      });
      return this._call(r.transaction, r.blockTag, r.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(e) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Rt({
        transaction: this._getTransactionRequest(e)
      }), r = yield this.perform("estimateGas", t);
      try {
        return H.from(r);
      } catch (i) {
        return ge.throwError("bad result from backend", D.errors.SERVER_ERROR, {
          method: "estimateGas",
          params: t,
          result: r,
          error: i
        });
      }
    });
  }
  _getAddress(e) {
    return pe(this, void 0, void 0, function* () {
      e = yield e, typeof e != "string" && ge.throwArgumentError("invalid address or ENS name", "name", e);
      const t = yield this.resolveName(e);
      return t == null && ge.throwError("ENS name not configured", D.errors.UNSUPPORTED_OPERATION, {
        operation: `resolveName(${JSON.stringify(e)})`
      }), t;
    });
  }
  _getBlock(e, t) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork(), e = yield e;
      let r = -128;
      const i = {
        includeTransactions: !!t
      };
      if (_e(e, 32))
        i.blockHash = e;
      else
        try {
          i.blockTag = yield this._getBlockTag(e), _e(i.blockTag) && (r = parseInt(i.blockTag.substring(2), 16));
        } catch {
          ge.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", e);
        }
      return uo(() => pe(this, void 0, void 0, function* () {
        const s = yield this.perform("getBlock", i);
        if (s == null)
          return i.blockHash != null && this._emitted["b:" + i.blockHash] == null || i.blockTag != null && r > this._emitted.block ? null : void 0;
        if (t) {
          let a = null;
          for (let u = 0; u < s.transactions.length; u++) {
            const l = s.transactions[u];
            if (l.blockNumber == null)
              l.confirmations = 0;
            else if (l.confirmations == null) {
              a == null && (a = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
              let d = a - l.blockNumber + 1;
              d <= 0 && (d = 1), l.confirmations = d;
            }
          }
          const o = this.formatter.blockWithTransactions(s);
          return o.transactions = o.transactions.map((u) => this._wrapTransaction(u)), o;
        }
        return this.formatter.block(s);
      }), { oncePoll: this });
    });
  }
  getBlock(e) {
    return this._getBlock(e, !1);
  }
  getBlockWithTransactions(e) {
    return this._getBlock(e, !0);
  }
  getTransaction(e) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork(), e = yield e;
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return uo(() => pe(this, void 0, void 0, function* () {
        const r = yield this.perform("getTransaction", t);
        if (r == null)
          return this._emitted["t:" + e] == null ? null : void 0;
        const i = this.formatter.transactionResponse(r);
        if (i.blockNumber == null)
          i.confirmations = 0;
        else if (i.confirmations == null) {
          let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
          a <= 0 && (a = 1), i.confirmations = a;
        }
        return this._wrapTransaction(i);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(e) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork(), e = yield e;
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return uo(() => pe(this, void 0, void 0, function* () {
        const r = yield this.perform("getTransactionReceipt", t);
        if (r == null)
          return this._emitted["t:" + e] == null ? null : void 0;
        if (r.blockHash == null)
          return;
        const i = this.formatter.receipt(r);
        if (i.blockNumber == null)
          i.confirmations = 0;
        else if (i.confirmations == null) {
          let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
          a <= 0 && (a = 1), i.confirmations = a;
        }
        return i;
      }), { oncePoll: this });
    });
  }
  getLogs(e) {
    return pe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Rt({ filter: this._getFilter(e) }), r = yield this.perform("getLogs", t);
      return r.forEach((i) => {
        i.removed == null && (i.removed = !1);
      }), ie.arrayOf(this.formatter.filterLog.bind(this.formatter))(r);
    });
  }
  getEtherPrice() {
    return pe(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(e) {
    return pe(this, void 0, void 0, function* () {
      if (e = yield e, typeof e == "number" && e < 0) {
        e % 1 && ge.throwArgumentError("invalid BlockTag", "blockTag", e);
        let t = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        return t += e, t < 0 && (t = 0), this.formatter.blockTag(t);
      }
      return this.formatter.blockTag(e);
    });
  }
  getResolver(e) {
    return pe(this, void 0, void 0, function* () {
      let t = e;
      for (; ; ) {
        if (t === "" || t === "." || e !== "eth" && t === "eth")
          return null;
        const r = yield this._getResolver(t, "getResolver");
        if (r != null) {
          const i = new Rx(this, r, e);
          return t !== e && !(yield i.supportsWildcard()) ? null : i;
        }
        t = t.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(e, t) {
    return pe(this, void 0, void 0, function* () {
      t == null && (t = "ENS");
      const r = yield this.getNetwork();
      r.ensAddress || ge.throwError("network does not support ENS", D.errors.UNSUPPORTED_OPERATION, { operation: t, network: r.name });
      try {
        const i = yield this.call({
          to: r.ensAddress,
          data: "0x0178b8bf" + _u(e).substring(2)
        });
        return this.formatter.callAddress(i);
      } catch {
      }
      return null;
    });
  }
  resolveName(e) {
    return pe(this, void 0, void 0, function* () {
      e = yield e;
      try {
        return Promise.resolve(this.formatter.address(e));
      } catch (r) {
        if (_e(e))
          throw r;
      }
      typeof e != "string" && ge.throwArgumentError("invalid ENS name", "name", e);
      const t = yield this.getResolver(e);
      return t ? yield t.getAddress() : null;
    });
  }
  lookupAddress(e) {
    return pe(this, void 0, void 0, function* () {
      e = yield e, e = this.formatter.address(e);
      const t = e.substring(2).toLowerCase() + ".addr.reverse", r = yield this._getResolver(t, "lookupAddress");
      if (r == null)
        return null;
      const i = Dc(yield this.call({
        to: r,
        data: "0x691f3431" + _u(t).substring(2)
      }), 0);
      return (yield this.resolveName(i)) != e ? null : i;
    });
  }
  getAvatar(e) {
    return pe(this, void 0, void 0, function* () {
      let t = null;
      if (_e(e)) {
        const s = this.formatter.address(e).substring(2).toLowerCase() + ".addr.reverse", a = yield this._getResolver(s, "getAvatar");
        if (!a)
          return null;
        t = new Rx(this, a, s);
        try {
          const o = yield t.getAvatar();
          if (o)
            return o.url;
        } catch (o) {
          if (o.code !== D.errors.CALL_EXCEPTION)
            throw o;
        }
        try {
          const o = Dc(yield this.call({
            to: a,
            data: "0x691f3431" + _u(s).substring(2)
          }), 0);
          t = yield this.getResolver(o);
        } catch (o) {
          if (o.code !== D.errors.CALL_EXCEPTION)
            throw o;
          return null;
        }
      } else if (t = yield this.getResolver(e), !t)
        return null;
      const r = yield t.getAvatar();
      return r == null ? null : r.url;
    });
  }
  perform(e, t) {
    return ge.throwError(e + " not implemented", D.errors.NOT_IMPLEMENTED, { operation: e });
  }
  _startEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _stopEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _addEventListener(e, t, r) {
    const i = new I9(Ha(e), t, r);
    return this._events.push(i), this._startEvent(i), this;
  }
  on(e, t) {
    return this._addEventListener(e, t, !1);
  }
  once(e, t) {
    return this._addEventListener(e, t, !0);
  }
  emit(e, ...t) {
    let r = !1, i = [], s = Ha(e);
    return this._events = this._events.filter((a) => a.tag !== s ? !0 : (setTimeout(() => {
      a.listener.apply(this, t);
    }, 0), r = !0, a.once ? (i.push(a), !1) : !0)), i.forEach((a) => {
      this._stopEvent(a);
    }), r;
  }
  listenerCount(e) {
    if (!e)
      return this._events.length;
    let t = Ha(e);
    return this._events.filter((r) => r.tag === t).length;
  }
  listeners(e) {
    if (e == null)
      return this._events.map((r) => r.listener);
    let t = Ha(e);
    return this._events.filter((r) => r.tag === t).map((r) => r.listener);
  }
  off(e, t) {
    if (t == null)
      return this.removeAllListeners(e);
    const r = [];
    let i = !1, s = Ha(e);
    return this._events = this._events.filter((a) => a.tag !== s || a.listener != t || i ? !0 : (i = !0, r.push(a), !1)), r.forEach((a) => {
      this._stopEvent(a);
    }), this;
  }
  removeAllListeners(e) {
    let t = [];
    if (e == null)
      t = this._events, this._events = [];
    else {
      const r = Ha(e);
      this._events = this._events.filter((i) => i.tag !== r ? !0 : (t.push(i), !1));
    }
    return t.forEach((r) => {
      this._stopEvent(r);
    }), this;
  }
}
var mi = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(d) {
      try {
        l(r.next(d));
      } catch (p) {
        a(p);
      }
    }
    function u(d) {
      try {
        l(r.throw(d));
      } catch (p) {
        a(p);
      }
    }
    function l(d) {
      d.done ? s(d.value) : i(d.value).then(o, u);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const Vt = new D(Oy), B9 = ["call", "estimateGas"];
function Pu(n, e) {
  if (n == null)
    return null;
  if (typeof n.message == "string" && n.message.match("reverted")) {
    const t = _e(n.data) ? n.data : null;
    if (!e || t)
      return { message: n.message, data: t };
  }
  if (typeof n == "object") {
    for (const t in n) {
      const r = Pu(n[t], e);
      if (r)
        return r;
    }
    return null;
  }
  if (typeof n == "string")
    try {
      return Pu(JSON.parse(n), e);
    } catch {
    }
  return null;
}
function $6(n, e, t) {
  const r = t.transaction || t.signedTransaction;
  if (n === "call") {
    const s = Pu(e, !0);
    if (s)
      return s.data;
    Vt.throwError("missing revert data in call exception; Transaction reverted without a reason string", D.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction: r,
      error: e
    });
  }
  if (n === "estimateGas") {
    let s = Pu(e.body, !1);
    s == null && (s = Pu(e, !1)), s && Vt.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", D.errors.UNPREDICTABLE_GAS_LIMIT, {
      reason: s.message,
      method: n,
      transaction: r,
      error: e
    });
  }
  let i = e.message;
  throw e.code === D.errors.SERVER_ERROR && e.error && typeof e.error.message == "string" ? i = e.error.message : typeof e.body == "string" ? i = e.body : typeof e.responseText == "string" && (i = e.responseText), i = (i || "").toLowerCase(), i.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && Vt.throwError("insufficient funds for intrinsic transaction cost", D.errors.INSUFFICIENT_FUNDS, {
    error: e,
    method: n,
    transaction: r
  }), i.match(/nonce (is )?too low/i) && Vt.throwError("nonce has already been used", D.errors.NONCE_EXPIRED, {
    error: e,
    method: n,
    transaction: r
  }), i.match(/replacement transaction underpriced|transaction gas price.*too low/i) && Vt.throwError("replacement fee too low", D.errors.REPLACEMENT_UNDERPRICED, {
    error: e,
    method: n,
    transaction: r
  }), i.match(/only replay-protected/i) && Vt.throwError("legacy pre-eip-155 transactions not supported", D.errors.UNSUPPORTED_OPERATION, {
    error: e,
    method: n,
    transaction: r
  }), B9.indexOf(n) >= 0 && i.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && Vt.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", D.errors.UNPREDICTABLE_GAS_LIMIT, {
    error: e,
    method: n,
    transaction: r
  }), e;
}
function Ix(n) {
  return new Promise(function(e) {
    setTimeout(e, n);
  });
}
function F9(n) {
  if (n.error) {
    const e = new Error(n.error.message);
    throw e.code = n.error.code, e.data = n.error.data, e;
  }
  return n.result;
}
function su(n) {
  return n && n.toLowerCase();
}
const Bh = {};
class U6 extends La {
  constructor(e, t, r) {
    if (super(), e !== Bh)
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    j(this, "provider", t), r == null && (r = 0), typeof r == "string" ? (j(this, "_address", this.provider.formatter.address(r)), j(this, "_index", null)) : typeof r == "number" ? (j(this, "_index", r), j(this, "_address", null)) : Vt.throwArgumentError("invalid address or index", "addressOrIndex", r);
  }
  connect(e) {
    return Vt.throwError("cannot alter JSON-RPC Signer connection", D.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new L9(Bh, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then((e) => (e.length <= this._index && Vt.throwError("unknown account #" + this._index, D.errors.UNSUPPORTED_OPERATION, {
      operation: "getAddress"
    }), this.provider.formatter.address(e[this._index])));
  }
  sendUncheckedTransaction(e) {
    e = zt(e);
    const t = this.getAddress().then((r) => (r && (r = r.toLowerCase()), r));
    if (e.gasLimit == null) {
      const r = zt(e);
      r.from = t, e.gasLimit = this.provider.estimateGas(r);
    }
    return e.to != null && (e.to = Promise.resolve(e.to).then((r) => mi(this, void 0, void 0, function* () {
      if (r == null)
        return null;
      const i = yield this.provider.resolveName(r);
      return i == null && Vt.throwArgumentError("provided ENS name resolves to null", "tx.to", r), i;
    }))), Rt({
      tx: Rt(e),
      sender: t
    }).then(({ tx: r, sender: i }) => {
      r.from != null ? r.from.toLowerCase() !== i && Vt.throwArgumentError("from address mismatch", "transaction", e) : r.from = i;
      const s = this.provider.constructor.hexlifyTransaction(r, { from: !0 });
      return this.provider.send("eth_sendTransaction", [s]).then((a) => a, (a) => (typeof a.message == "string" && a.message.match(/user denied/i) && Vt.throwError("user rejected transaction", D.errors.ACTION_REJECTED, {
        action: "sendTransaction",
        transaction: r
      }), $6("sendTransaction", a, s)));
    });
  }
  signTransaction(e) {
    return Vt.throwError("signing transactions is unsupported", D.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(e) {
    return mi(this, void 0, void 0, function* () {
      const t = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), r = yield this.sendUncheckedTransaction(e);
      try {
        return yield uo(() => mi(this, void 0, void 0, function* () {
          const i = yield this.provider.getTransaction(r);
          if (i !== null)
            return this.provider._wrapTransaction(i, r, t);
        }), { oncePoll: this.provider });
      } catch (i) {
        throw i.transactionHash = r, i;
      }
    });
  }
  signMessage(e) {
    return mi(this, void 0, void 0, function* () {
      const t = typeof e == "string" ? Lt(e) : e, r = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [J(t), r.toLowerCase()]);
      } catch (i) {
        throw typeof i.message == "string" && i.message.match(/user denied/i) && Vt.throwError("user rejected signing", D.errors.ACTION_REJECTED, {
          action: "signMessage",
          from: r,
          messageData: e
        }), i;
      }
    });
  }
  _legacySignMessage(e) {
    return mi(this, void 0, void 0, function* () {
      const t = typeof e == "string" ? Lt(e) : e, r = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [r.toLowerCase(), J(t)]);
      } catch (i) {
        throw typeof i.message == "string" && i.message.match(/user denied/i) && Vt.throwError("user rejected signing", D.errors.ACTION_REJECTED, {
          action: "_legacySignMessage",
          from: r,
          messageData: e
        }), i;
      }
    });
  }
  _signTypedData(e, t, r) {
    return mi(this, void 0, void 0, function* () {
      const i = yield an.resolveNames(e, t, r, (a) => this.provider.resolveName(a)), s = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          s.toLowerCase(),
          JSON.stringify(an.getPayload(i.domain, t, i.value))
        ]);
      } catch (a) {
        throw typeof a.message == "string" && a.message.match(/user denied/i) && Vt.throwError("user rejected signing", D.errors.ACTION_REJECTED, {
          action: "_signTypedData",
          from: s,
          messageData: { domain: i.domain, types: t, value: i.value }
        }), a;
      }
    });
  }
  unlock(e) {
    return mi(this, void 0, void 0, function* () {
      const t = this.provider, r = yield this.getAddress();
      return t.send("personal_unlockAccount", [r.toLowerCase(), e, null]);
    });
  }
}
class L9 extends U6 {
  sendTransaction(e) {
    return this.sendUncheckedTransaction(e).then((t) => ({
      hash: t,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (r) => this.provider.waitForTransaction(t, r)
    }));
  }
}
const $9 = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0
};
class U9 extends D9 {
  constructor(e, t) {
    let r = t;
    r == null && (r = new Promise((i, s) => {
      setTimeout(() => {
        this.detectNetwork().then((a) => {
          i(a);
        }, (a) => {
          s(a);
        });
      }, 0);
    })), super(r), e || (e = Rr(this.constructor, "defaultUrl")()), typeof e == "string" ? j(this, "connection", Object.freeze({
      url: e
    })) : j(this, "connection", Object.freeze(zt(e))), this._nextId = 42;
  }
  get _cache() {
    return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
      this._cache.detectNetwork = null;
    }, 0)), this._cache.detectNetwork;
  }
  _uncachedDetectNetwork() {
    return mi(this, void 0, void 0, function* () {
      yield Ix(0);
      let e = null;
      try {
        e = yield this.send("eth_chainId", []);
      } catch {
        try {
          e = yield this.send("net_version", []);
        } catch {
        }
      }
      if (e != null) {
        const t = Rr(this.constructor, "getNetwork");
        try {
          return t(H.from(e).toNumber());
        } catch (r) {
          return Vt.throwError("could not detect network", D.errors.NETWORK_ERROR, {
            chainId: e,
            event: "invalidNetwork",
            serverError: r
          });
        }
      }
      return Vt.throwError("could not detect network", D.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(e) {
    return new U6(Bh, this, e);
  }
  getUncheckedSigner(e) {
    return this.getSigner(e).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((e) => e.map((t) => this.formatter.address(t)));
  }
  send(e, t) {
    const r = {
      method: e,
      params: t,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: xs(r),
      provider: this
    });
    const i = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0;
    if (i && this._cache[e])
      return this._cache[e];
    const s = yf(this.connection, JSON.stringify(r), F9).then((a) => (this.emit("debug", {
      action: "response",
      request: r,
      response: a,
      provider: this
    }), a), (a) => {
      throw this.emit("debug", {
        action: "response",
        error: a,
        request: r,
        provider: this
      }), a;
    });
    return i && (this._cache[e] = s, setTimeout(() => {
      this._cache[e] = null;
    }, 0)), s;
  }
  prepareRequest(e, t) {
    switch (e) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [su(t.address), t.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [su(t.address), t.blockTag]];
      case "getCode":
        return ["eth_getCode", [su(t.address), t.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [su(t.address), Le(t.position, 32), t.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [t.signedTransaction]];
      case "getBlock":
        return t.blockTag ? ["eth_getBlockByNumber", [t.blockTag, !!t.includeTransactions]] : t.blockHash ? ["eth_getBlockByHash", [t.blockHash, !!t.includeTransactions]] : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [t.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [t.transactionHash]];
      case "call":
        return ["eth_call", [Rr(this.constructor, "hexlifyTransaction")(t.transaction, { from: !0 }), t.blockTag]];
      case "estimateGas":
        return ["eth_estimateGas", [Rr(this.constructor, "hexlifyTransaction")(t.transaction, { from: !0 })]];
      case "getLogs":
        return t.filter && t.filter.address != null && (t.filter.address = su(t.filter.address)), ["eth_getLogs", [t.filter]];
    }
    return null;
  }
  perform(e, t) {
    return mi(this, void 0, void 0, function* () {
      if (e === "call" || e === "estimateGas") {
        const i = t.transaction;
        if (i && i.type != null && H.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
          const s = yield this.getFeeData();
          s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (t = zt(t), t.transaction = zt(i), delete t.transaction.type);
        }
      }
      const r = this.prepareRequest(e, t);
      r == null && Vt.throwError(e + " not implemented", D.errors.NOT_IMPLEMENTED, { operation: e });
      try {
        return yield this.send(r[0], r[1]);
      } catch (i) {
        return $6(e, i, t);
      }
    });
  }
  _startEvent(e) {
    e.tag === "pending" && this._startPending(), super._startEvent(e);
  }
  _startPending() {
    if (this._pendingFilter != null)
      return;
    const e = this, t = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = t, t.then(function(r) {
      function i() {
        e.send("eth_getFilterChanges", [r]).then(function(s) {
          if (e._pendingFilter != t)
            return null;
          let a = Promise.resolve();
          return s.forEach(function(o) {
            e._emitted["t:" + o.toLowerCase()] = "pending", a = a.then(function() {
              return e.getTransaction(o).then(function(u) {
                return e.emit("pending", u), null;
              });
            });
          }), a.then(function() {
            return Ix(1e3);
          });
        }).then(function() {
          if (e._pendingFilter != t) {
            e.send("eth_uninstallFilter", [r]);
            return;
          }
          return setTimeout(function() {
            i();
          }, 0), null;
        }).catch((s) => {
        });
      }
      return i(), r;
    }).catch((r) => {
    });
  }
  _stopEvent(e) {
    e.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(e);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(e, t) {
    const r = zt($9);
    if (t)
      for (const s in t)
        t[s] && (r[s] = !0);
    uy(e, r);
    const i = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(s) {
      if (e[s] == null)
        return;
      const a = rf(H.from(e[s]));
      s === "gasLimit" && (s = "gas"), i[s] = a;
    }), ["from", "to", "data"].forEach(function(s) {
      e[s] != null && (i[s] = J(e[s]));
    }), e.accessList && (i.accessList = Ua(e.accessList)), i;
  }
}
const j9 = "solidity/5.7.0", V9 = new RegExp("^bytes([0-9]+)$"), z9 = new RegExp("^(u?int)([0-9]*)$"), G9 = new RegExp("^(.*)\\[([0-9]*)\\]$"), H9 = "0000000000000000000000000000000000000000000000000000000000000000", eo = new D(j9);
function j6(n, e, t) {
  switch (n) {
    case "address":
      return t ? Eu(e, 32) : q(e);
    case "string":
      return Lt(e);
    case "bytes":
      return q(e);
    case "bool":
      return e = e ? "0x01" : "0x00", t ? Eu(e, 32) : q(e);
  }
  let r = n.match(z9);
  if (r) {
    let i = parseInt(r[2] || "256");
    return (r[2] && String(i) !== r[2] || i % 8 !== 0 || i === 0 || i > 256) && eo.throwArgumentError("invalid number type", "type", n), t && (i = 256), e = H.from(e).toTwos(i), Eu(e, i / 8);
  }
  if (r = n.match(V9), r) {
    const i = parseInt(r[1]);
    return (String(i) !== r[1] || i === 0 || i > 32) && eo.throwArgumentError("invalid bytes type", "type", n), q(e).byteLength !== i && eo.throwArgumentError(`invalid value for ${n}`, "value", e), t ? q((e + H9).substring(0, 66)) : e;
  }
  if (r = n.match(G9), r && Array.isArray(e)) {
    const i = r[1];
    parseInt(r[2] || String(e.length)) != e.length && eo.throwArgumentError(`invalid array length for ${n}`, "value", e);
    const a = [];
    return e.forEach(function(o) {
      a.push(j6(i, o, !0));
    }), Ge(a);
  }
  return eo.throwArgumentError("invalid type", "type", n);
}
function ky(n, e) {
  n.length != e.length && eo.throwArgumentError("wrong number of values; expected ${ types.length }", "values", e);
  const t = [];
  return n.forEach(function(r, i) {
    t.push(j6(r, e[i]));
  }), J(Ge(t));
}
function q9(n, e) {
  return De(ky(n, e));
}
function W9(n, e) {
  return Di(ky(n, e));
}
const K9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256: q9,
  pack: ky,
  sha256: W9
}, Symbol.toStringTag, { value: "Module" })), J9 = "units/5.7.0", V6 = new D(J9), z6 = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function Q9(n) {
  const e = String(n).split(".");
  (e.length > 2 || !e[0].match(/^-?[0-9]*$/) || e[1] && !e[1].match(/^[0-9]*$/) || n === "." || n === "-.") && V6.throwArgumentError("invalid value", "value", n);
  let t = e[0], r = "";
  for (t.substring(0, 1) === "-" && (r = "-", t = t.substring(1)); t.substring(0, 1) === "0"; )
    t = t.substring(1);
  t === "" && (t = "0");
  let i = "";
  for (e.length === 2 && (i = "." + (e[1] || "0")); i.length > 2 && i[i.length - 1] === "0"; )
    i = i.substring(0, i.length - 1);
  const s = [];
  for (; t.length; )
    if (t.length <= 3) {
      s.unshift(t);
      break;
    } else {
      const a = t.length - 3;
      s.unshift(t.substring(a)), t = t.substring(0, a);
    }
  return r + s.join(",") + i;
}
function xd(n, e) {
  if (typeof e == "string") {
    const t = z6.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return _c(n, e ?? 18);
}
function G6(n, e) {
  if (typeof n != "string" && V6.throwArgumentError("value must be a string", "value", n), typeof e == "string") {
    const t = z6.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return Ur(n, e ?? 18);
}
function H6(n) {
  return xd(n, 18);
}
function ea(n) {
  return G6(n, 18);
}
const Y9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commify: Q9,
  formatEther: H6,
  formatUnits: xd,
  parseEther: ea,
  parseUnits: G6
}, Symbol.toStringTag, { value: "Module" })), Ny = JSON, X9 = (n) => n.toUpperCase(), Z9 = (n) => {
  const e = {};
  return n.forEach((t, r) => {
    e[r] = t;
  }), e;
}, eP = (n, e, t) => n.document ? n : {
  document: n,
  variables: e,
  requestHeaders: t,
  signal: void 0
}, tP = (n, e, t) => n.query ? n : {
  query: n,
  variables: e,
  requestHeaders: t,
  signal: void 0
}, nP = (n, e) => n.documents ? n : {
  documents: n,
  requestHeaders: e,
  signal: void 0
};
function Bc(n, e) {
  if (!!!n)
    throw new Error(e);
}
function rP(n) {
  return typeof n == "object" && n !== null;
}
function iP(n, e) {
  if (!!!n)
    throw new Error(
      e ?? "Unexpected invariant triggered."
    );
}
const sP = /\r\n|[\n\r]/g;
function Fh(n, e) {
  let t = 0, r = 1;
  for (const i of n.body.matchAll(sP)) {
    if (typeof i.index == "number" || iP(!1), i.index >= e)
      break;
    t = i.index + i[0].length, r += 1;
  }
  return {
    line: r,
    column: e + 1 - t
  };
}
function aP(n) {
  return q6(
    n.source,
    Fh(n.source, n.start)
  );
}
function q6(n, e) {
  const t = n.locationOffset.column - 1, r = "".padStart(t) + n.body, i = e.line - 1, s = n.locationOffset.line - 1, a = e.line + s, o = e.line === 1 ? t : 0, u = e.column + o, l = `${n.name}:${a}:${u}
`, d = r.split(/\r\n|[\n\r]/g), p = d[i];
  if (p.length > 120) {
    const m = Math.floor(u / 80), w = u % 80, x = [];
    for (let T = 0; T < p.length; T += 80)
      x.push(p.slice(T, T + 80));
    return l + Ox([
      [`${a} |`, x[0]],
      ...x.slice(1, m + 1).map((T) => ["|", T]),
      ["|", "^".padStart(w)],
      ["|", x[m + 1]]
    ]);
  }
  return l + Ox([
    // Lines specified like this: ["prefix", "string"],
    [`${a - 1} |`, d[i - 1]],
    [`${a} |`, p],
    ["|", "^".padStart(u)],
    [`${a + 1} |`, d[i + 1]]
  ]);
}
function Ox(n) {
  const e = n.filter(([r, i]) => i !== void 0), t = Math.max(...e.map(([r]) => r.length));
  return e.map(([r, i]) => r.padStart(t) + (i ? " " + i : "")).join(`
`);
}
function oP(n) {
  const e = n[0];
  return e == null || "kind" in e || "length" in e ? {
    nodes: e,
    source: n[1],
    positions: n[2],
    path: n[3],
    originalError: n[4],
    extensions: n[5]
  } : e;
}
class Dy extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(e, ...t) {
    var r, i, s;
    const { nodes: a, source: o, positions: u, path: l, originalError: d, extensions: p } = oP(t);
    super(e), this.name = "GraphQLError", this.path = l ?? void 0, this.originalError = d ?? void 0, this.nodes = kx(
      Array.isArray(a) ? a : a ? [a] : void 0
    );
    const m = kx(
      (r = this.nodes) === null || r === void 0 ? void 0 : r.map((x) => x.loc).filter((x) => x != null)
    );
    this.source = o ?? (m == null || (i = m[0]) === null || i === void 0 ? void 0 : i.source), this.positions = u ?? m?.map((x) => x.start), this.locations = u && o ? u.map((x) => Fh(o, x)) : m?.map((x) => Fh(x.source, x.start));
    const w = rP(
      d?.extensions
    ) ? d?.extensions : void 0;
    this.extensions = (s = p ?? w) !== null && s !== void 0 ? s : /* @__PURE__ */ Object.create(null), Object.defineProperties(this, {
      message: {
        writable: !0,
        enumerable: !0
      },
      name: {
        enumerable: !1
      },
      nodes: {
        enumerable: !1
      },
      source: {
        enumerable: !1
      },
      positions: {
        enumerable: !1
      },
      originalError: {
        enumerable: !1
      }
    }), d != null && d.stack ? Object.defineProperty(this, "stack", {
      value: d.stack,
      writable: !0,
      configurable: !0
    }) : Error.captureStackTrace ? Error.captureStackTrace(this, Dy) : Object.defineProperty(this, "stack", {
      value: Error().stack,
      writable: !0,
      configurable: !0
    });
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let e = this.message;
    if (this.nodes)
      for (const t of this.nodes)
        t.loc && (e += `

` + aP(t.loc));
    else if (this.source && this.locations)
      for (const t of this.locations)
        e += `

` + q6(this.source, t);
    return e;
  }
  toJSON() {
    const e = {
      message: this.message
    };
    return this.locations != null && (e.locations = this.locations), this.path != null && (e.path = this.path), this.extensions != null && Object.keys(this.extensions).length > 0 && (e.extensions = this.extensions), e;
  }
}
function kx(n) {
  return n === void 0 || n.length === 0 ? void 0 : n;
}
function Xt(n, e, t) {
  return new Dy(`Syntax Error: ${t}`, {
    source: n,
    positions: [e]
  });
}
class uP {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(e, t, r) {
    this.start = e.start, this.end = t.end, this.startToken = e, this.endToken = t, this.source = r;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class W6 {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(e, t, r, i, s, a) {
    this.kind = e, this.start = t, this.end = r, this.line = i, this.column = s, this.value = a, this.prev = null, this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const K6 = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
}, lP = new Set(Object.keys(K6));
function Nx(n) {
  const e = n?.kind;
  return typeof e == "string" && lP.has(e);
}
var lo;
(function(n) {
  n.QUERY = "query", n.MUTATION = "mutation", n.SUBSCRIPTION = "subscription";
})(lo || (lo = {}));
var Lh;
(function(n) {
  n.QUERY = "QUERY", n.MUTATION = "MUTATION", n.SUBSCRIPTION = "SUBSCRIPTION", n.FIELD = "FIELD", n.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION", n.FRAGMENT_SPREAD = "FRAGMENT_SPREAD", n.INLINE_FRAGMENT = "INLINE_FRAGMENT", n.VARIABLE_DEFINITION = "VARIABLE_DEFINITION", n.SCHEMA = "SCHEMA", n.SCALAR = "SCALAR", n.OBJECT = "OBJECT", n.FIELD_DEFINITION = "FIELD_DEFINITION", n.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION", n.INTERFACE = "INTERFACE", n.UNION = "UNION", n.ENUM = "ENUM", n.ENUM_VALUE = "ENUM_VALUE", n.INPUT_OBJECT = "INPUT_OBJECT", n.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION";
})(Lh || (Lh = {}));
var ce;
(function(n) {
  n.NAME = "Name", n.DOCUMENT = "Document", n.OPERATION_DEFINITION = "OperationDefinition", n.VARIABLE_DEFINITION = "VariableDefinition", n.SELECTION_SET = "SelectionSet", n.FIELD = "Field", n.ARGUMENT = "Argument", n.FRAGMENT_SPREAD = "FragmentSpread", n.INLINE_FRAGMENT = "InlineFragment", n.FRAGMENT_DEFINITION = "FragmentDefinition", n.VARIABLE = "Variable", n.INT = "IntValue", n.FLOAT = "FloatValue", n.STRING = "StringValue", n.BOOLEAN = "BooleanValue", n.NULL = "NullValue", n.ENUM = "EnumValue", n.LIST = "ListValue", n.OBJECT = "ObjectValue", n.OBJECT_FIELD = "ObjectField", n.DIRECTIVE = "Directive", n.NAMED_TYPE = "NamedType", n.LIST_TYPE = "ListType", n.NON_NULL_TYPE = "NonNullType", n.SCHEMA_DEFINITION = "SchemaDefinition", n.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition", n.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition", n.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition", n.FIELD_DEFINITION = "FieldDefinition", n.INPUT_VALUE_DEFINITION = "InputValueDefinition", n.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition", n.UNION_TYPE_DEFINITION = "UnionTypeDefinition", n.ENUM_TYPE_DEFINITION = "EnumTypeDefinition", n.ENUM_VALUE_DEFINITION = "EnumValueDefinition", n.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition", n.DIRECTIVE_DEFINITION = "DirectiveDefinition", n.SCHEMA_EXTENSION = "SchemaExtension", n.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension", n.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension", n.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension", n.UNION_TYPE_EXTENSION = "UnionTypeExtension", n.ENUM_TYPE_EXTENSION = "EnumTypeExtension", n.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension";
})(ce || (ce = {}));
function $h(n) {
  return n === 9 || n === 32;
}
function nl(n) {
  return n >= 48 && n <= 57;
}
function J6(n) {
  return n >= 97 && n <= 122 || // A-Z
  n >= 65 && n <= 90;
}
function Q6(n) {
  return J6(n) || n === 95;
}
function cP(n) {
  return J6(n) || nl(n) || n === 95;
}
function dP(n) {
  var e;
  let t = Number.MAX_SAFE_INTEGER, r = null, i = -1;
  for (let a = 0; a < n.length; ++a) {
    var s;
    const o = n[a], u = fP(o);
    u !== o.length && (r = (s = r) !== null && s !== void 0 ? s : a, i = a, a !== 0 && u < t && (t = u));
  }
  return n.map((a, o) => o === 0 ? a : a.slice(t)).slice(
    (e = r) !== null && e !== void 0 ? e : 0,
    i + 1
  );
}
function fP(n) {
  let e = 0;
  for (; e < n.length && $h(n.charCodeAt(e)); )
    ++e;
  return e;
}
function pP(n, e) {
  const t = n.replace(/"""/g, '\\"""'), r = t.split(/\r\n|[\n\r]/g), i = r.length === 1, s = r.length > 1 && r.slice(1).every((w) => w.length === 0 || $h(w.charCodeAt(0))), a = t.endsWith('\\"""'), o = n.endsWith('"') && !a, u = n.endsWith("\\"), l = o || u, d = !(e != null && e.minimize) && // add leading and trailing new lines only if it improves readability
  (!i || n.length > 70 || l || s || a);
  let p = "";
  const m = i && $h(n.charCodeAt(0));
  return (d && !m || s) && (p += `
`), p += t, (d || l) && (p += `
`), '"""' + p + '"""';
}
var V;
(function(n) {
  n.SOF = "<SOF>", n.EOF = "<EOF>", n.BANG = "!", n.DOLLAR = "$", n.AMP = "&", n.PAREN_L = "(", n.PAREN_R = ")", n.SPREAD = "...", n.COLON = ":", n.EQUALS = "=", n.AT = "@", n.BRACKET_L = "[", n.BRACKET_R = "]", n.BRACE_L = "{", n.PIPE = "|", n.BRACE_R = "}", n.NAME = "Name", n.INT = "Int", n.FLOAT = "Float", n.STRING = "String", n.BLOCK_STRING = "BlockString", n.COMMENT = "Comment";
})(V || (V = {}));
class hP {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(e) {
    const t = new W6(V.SOF, 0, 0, 0, 0);
    this.source = e, this.lastToken = t, this.token = t, this.line = 1, this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return this.lastToken = this.token, this.token = this.lookahead();
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let e = this.token;
    if (e.kind !== V.EOF)
      do
        if (e.next)
          e = e.next;
        else {
          const t = mP(this, e.end);
          e.next = t, t.prev = e, e = t;
        }
      while (e.kind === V.COMMENT);
    return e;
  }
}
function yP(n) {
  return n === V.BANG || n === V.DOLLAR || n === V.AMP || n === V.PAREN_L || n === V.PAREN_R || n === V.SPREAD || n === V.COLON || n === V.EQUALS || n === V.AT || n === V.BRACKET_L || n === V.BRACKET_R || n === V.BRACE_L || n === V.PIPE || n === V.BRACE_R;
}
function Ko(n) {
  return n >= 0 && n <= 55295 || n >= 57344 && n <= 1114111;
}
function bf(n, e) {
  return Y6(n.charCodeAt(e)) && X6(n.charCodeAt(e + 1));
}
function Y6(n) {
  return n >= 55296 && n <= 56319;
}
function X6(n) {
  return n >= 56320 && n <= 57343;
}
function va(n, e) {
  const t = n.source.body.codePointAt(e);
  if (t === void 0)
    return V.EOF;
  if (t >= 32 && t <= 126) {
    const r = String.fromCodePoint(t);
    return r === '"' ? `'"'` : `"${r}"`;
  }
  return "U+" + t.toString(16).toUpperCase().padStart(4, "0");
}
function Ut(n, e, t, r, i) {
  const s = n.line, a = 1 + t - n.lineStart;
  return new W6(e, t, r, s, a, i);
}
function mP(n, e) {
  const t = n.source.body, r = t.length;
  let i = e;
  for (; i < r; ) {
    const s = t.charCodeAt(i);
    switch (s) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++i;
        continue;
      case 10:
        ++i, ++n.line, n.lineStart = i;
        continue;
      case 13:
        t.charCodeAt(i + 1) === 10 ? i += 2 : ++i, ++n.line, n.lineStart = i;
        continue;
      case 35:
        return bP(n, i);
      case 33:
        return Ut(n, V.BANG, i, i + 1);
      case 36:
        return Ut(n, V.DOLLAR, i, i + 1);
      case 38:
        return Ut(n, V.AMP, i, i + 1);
      case 40:
        return Ut(n, V.PAREN_L, i, i + 1);
      case 41:
        return Ut(n, V.PAREN_R, i, i + 1);
      case 46:
        if (t.charCodeAt(i + 1) === 46 && t.charCodeAt(i + 2) === 46)
          return Ut(n, V.SPREAD, i, i + 3);
        break;
      case 58:
        return Ut(n, V.COLON, i, i + 1);
      case 61:
        return Ut(n, V.EQUALS, i, i + 1);
      case 64:
        return Ut(n, V.AT, i, i + 1);
      case 91:
        return Ut(n, V.BRACKET_L, i, i + 1);
      case 93:
        return Ut(n, V.BRACKET_R, i, i + 1);
      case 123:
        return Ut(n, V.BRACE_L, i, i + 1);
      case 124:
        return Ut(n, V.PIPE, i, i + 1);
      case 125:
        return Ut(n, V.BRACE_R, i, i + 1);
      case 34:
        return t.charCodeAt(i + 1) === 34 && t.charCodeAt(i + 2) === 34 ? AP(n, i) : xP(n, i);
    }
    if (nl(s) || s === 45)
      return gP(n, i, s);
    if (Q6(s))
      return EP(n, i);
    throw Xt(
      n.source,
      i,
      s === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Ko(s) || bf(t, i) ? `Unexpected character: ${va(n, i)}.` : `Invalid character: ${va(n, i)}.`
    );
  }
  return Ut(n, V.EOF, r, r);
}
function bP(n, e) {
  const t = n.source.body, r = t.length;
  let i = e + 1;
  for (; i < r; ) {
    const s = t.charCodeAt(i);
    if (s === 10 || s === 13)
      break;
    if (Ko(s))
      ++i;
    else if (bf(t, i))
      i += 2;
    else
      break;
  }
  return Ut(
    n,
    V.COMMENT,
    e,
    i,
    t.slice(e + 1, i)
  );
}
function gP(n, e, t) {
  const r = n.source.body;
  let i = e, s = t, a = !1;
  if (s === 45 && (s = r.charCodeAt(++i)), s === 48) {
    if (s = r.charCodeAt(++i), nl(s))
      throw Xt(
        n.source,
        i,
        `Invalid number, unexpected digit after 0: ${va(
          n,
          i
        )}.`
      );
  } else
    i = Op(n, i, s), s = r.charCodeAt(i);
  if (s === 46 && (a = !0, s = r.charCodeAt(++i), i = Op(n, i, s), s = r.charCodeAt(i)), (s === 69 || s === 101) && (a = !0, s = r.charCodeAt(++i), (s === 43 || s === 45) && (s = r.charCodeAt(++i)), i = Op(n, i, s), s = r.charCodeAt(i)), s === 46 || Q6(s))
    throw Xt(
      n.source,
      i,
      `Invalid number, expected digit but got: ${va(
        n,
        i
      )}.`
    );
  return Ut(
    n,
    a ? V.FLOAT : V.INT,
    e,
    i,
    r.slice(e, i)
  );
}
function Op(n, e, t) {
  if (!nl(t))
    throw Xt(
      n.source,
      e,
      `Invalid number, expected digit but got: ${va(
        n,
        e
      )}.`
    );
  const r = n.source.body;
  let i = e + 1;
  for (; nl(r.charCodeAt(i)); )
    ++i;
  return i;
}
function xP(n, e) {
  const t = n.source.body, r = t.length;
  let i = e + 1, s = i, a = "";
  for (; i < r; ) {
    const o = t.charCodeAt(i);
    if (o === 34)
      return a += t.slice(s, i), Ut(n, V.STRING, e, i + 1, a);
    if (o === 92) {
      a += t.slice(s, i);
      const u = t.charCodeAt(i + 1) === 117 ? t.charCodeAt(i + 2) === 123 ? vP(n, i) : wP(n, i) : TP(n, i);
      a += u.value, i += u.size, s = i;
      continue;
    }
    if (o === 10 || o === 13)
      break;
    if (Ko(o))
      ++i;
    else if (bf(t, i))
      i += 2;
    else
      throw Xt(
        n.source,
        i,
        `Invalid character within String: ${va(
          n,
          i
        )}.`
      );
  }
  throw Xt(n.source, i, "Unterminated string.");
}
function vP(n, e) {
  const t = n.source.body;
  let r = 0, i = 3;
  for (; i < 12; ) {
    const s = t.charCodeAt(e + i++);
    if (s === 125) {
      if (i < 5 || !Ko(r))
        break;
      return {
        value: String.fromCodePoint(r),
        size: i
      };
    }
    if (r = r << 4 | hu(s), r < 0)
      break;
  }
  throw Xt(
    n.source,
    e,
    `Invalid Unicode escape sequence: "${t.slice(
      e,
      e + i
    )}".`
  );
}
function wP(n, e) {
  const t = n.source.body, r = Dx(t, e + 2);
  if (Ko(r))
    return {
      value: String.fromCodePoint(r),
      size: 6
    };
  if (Y6(r) && t.charCodeAt(e + 6) === 92 && t.charCodeAt(e + 7) === 117) {
    const i = Dx(t, e + 8);
    if (X6(i))
      return {
        value: String.fromCodePoint(r, i),
        size: 12
      };
  }
  throw Xt(
    n.source,
    e,
    `Invalid Unicode escape sequence: "${t.slice(e, e + 6)}".`
  );
}
function Dx(n, e) {
  return hu(n.charCodeAt(e)) << 12 | hu(n.charCodeAt(e + 1)) << 8 | hu(n.charCodeAt(e + 2)) << 4 | hu(n.charCodeAt(e + 3));
}
function hu(n) {
  return n >= 48 && n <= 57 ? n - 48 : n >= 65 && n <= 70 ? n - 55 : n >= 97 && n <= 102 ? n - 87 : -1;
}
function TP(n, e) {
  const t = n.source.body;
  switch (t.charCodeAt(e + 1)) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: `
`,
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw Xt(
    n.source,
    e,
    `Invalid character escape sequence: "${t.slice(
      e,
      e + 2
    )}".`
  );
}
function AP(n, e) {
  const t = n.source.body, r = t.length;
  let i = n.lineStart, s = e + 3, a = s, o = "";
  const u = [];
  for (; s < r; ) {
    const l = t.charCodeAt(s);
    if (l === 34 && t.charCodeAt(s + 1) === 34 && t.charCodeAt(s + 2) === 34) {
      o += t.slice(a, s), u.push(o);
      const d = Ut(
        n,
        V.BLOCK_STRING,
        e,
        s + 3,
        // Return a string of the lines joined with U+000A.
        dP(u).join(`
`)
      );
      return n.line += u.length - 1, n.lineStart = i, d;
    }
    if (l === 92 && t.charCodeAt(s + 1) === 34 && t.charCodeAt(s + 2) === 34 && t.charCodeAt(s + 3) === 34) {
      o += t.slice(a, s), a = s + 1, s += 4;
      continue;
    }
    if (l === 10 || l === 13) {
      o += t.slice(a, s), u.push(o), l === 13 && t.charCodeAt(s + 1) === 10 ? s += 2 : ++s, o = "", a = s, i = s;
      continue;
    }
    if (Ko(l))
      ++s;
    else if (bf(t, s))
      s += 2;
    else
      throw Xt(
        n.source,
        s,
        `Invalid character within String: ${va(
          n,
          s
        )}.`
      );
  }
  throw Xt(n.source, s, "Unterminated string.");
}
function EP(n, e) {
  const t = n.source.body, r = t.length;
  let i = e + 1;
  for (; i < r; ) {
    const s = t.charCodeAt(i);
    if (cP(s))
      ++i;
    else
      break;
  }
  return Ut(
    n,
    V.NAME,
    e,
    i,
    t.slice(e, i)
  );
}
const SP = 10, Z6 = 2;
function eT(n) {
  return gf(n, []);
}
function gf(n, e) {
  switch (typeof n) {
    case "string":
      return JSON.stringify(n);
    case "function":
      return n.name ? `[function ${n.name}]` : "[function]";
    case "object":
      return CP(n, e);
    default:
      return String(n);
  }
}
function CP(n, e) {
  if (n === null)
    return "null";
  if (e.includes(n))
    return "[Circular]";
  const t = [...e, n];
  if (_P(n)) {
    const r = n.toJSON();
    if (r !== n)
      return typeof r == "string" ? r : gf(r, t);
  } else if (Array.isArray(n))
    return PP(n, t);
  return MP(n, t);
}
function _P(n) {
  return typeof n.toJSON == "function";
}
function MP(n, e) {
  const t = Object.entries(n);
  return t.length === 0 ? "{}" : e.length > Z6 ? "[" + RP(n) + "]" : "{ " + t.map(
    ([i, s]) => i + ": " + gf(s, e)
  ).join(", ") + " }";
}
function PP(n, e) {
  if (n.length === 0)
    return "[]";
  if (e.length > Z6)
    return "[Array]";
  const t = Math.min(SP, n.length), r = n.length - t, i = [];
  for (let s = 0; s < t; ++s)
    i.push(gf(n[s], e));
  return r === 1 ? i.push("... 1 more item") : r > 1 && i.push(`... ${r} more items`), "[" + i.join(", ") + "]";
}
function RP(n) {
  const e = Object.prototype.toString.call(n).replace(/^\[object /, "").replace(/]$/, "");
  if (e === "Object" && typeof n.constructor == "function") {
    const t = n.constructor.name;
    if (typeof t == "string" && t !== "")
      return t;
  }
  return e;
}
const IP = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  // eslint-disable-next-line no-undef
  function(e, t) {
    return e instanceof t;
  }
);
class tT {
  constructor(e, t = "GraphQL request", r = {
    line: 1,
    column: 1
  }) {
    typeof e == "string" || Bc(!1, `Body must be a string. Received: ${eT(e)}.`), this.body = e, this.name = t, this.locationOffset = r, this.locationOffset.line > 0 || Bc(
      !1,
      "line in locationOffset is 1-indexed and must be positive."
    ), this.locationOffset.column > 0 || Bc(
      !1,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function OP(n) {
  return IP(n, tT);
}
function kP(n, e) {
  return new NP(n, e).parseDocument();
}
class NP {
  constructor(e, t = {}) {
    const r = OP(e) ? e : new tT(e);
    this._lexer = new hP(r), this._options = t, this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const e = this.expectToken(V.NAME);
    return this.node(e, {
      kind: ce.NAME,
      value: e.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: ce.DOCUMENT,
      definitions: this.many(
        V.SOF,
        this.parseDefinition,
        V.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(V.BRACE_L))
      return this.parseOperationDefinition();
    const e = this.peekDescription(), t = e ? this._lexer.lookahead() : this._lexer.token;
    if (t.kind === V.NAME) {
      switch (t.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (e)
        throw Xt(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      switch (t.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(t);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const e = this._lexer.token;
    if (this.peek(V.BRACE_L))
      return this.node(e, {
        kind: ce.OPERATION_DEFINITION,
        operation: lo.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    const t = this.parseOperationType();
    let r;
    return this.peek(V.NAME) && (r = this.parseName()), this.node(e, {
      kind: ce.OPERATION_DEFINITION,
      operation: t,
      name: r,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const e = this.expectToken(V.NAME);
    switch (e.value) {
      case "query":
        return lo.QUERY;
      case "mutation":
        return lo.MUTATION;
      case "subscription":
        return lo.SUBSCRIPTION;
    }
    throw this.unexpected(e);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      V.PAREN_L,
      this.parseVariableDefinition,
      V.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: ce.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(V.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(V.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const e = this._lexer.token;
    return this.expectToken(V.DOLLAR), this.node(e, {
      kind: ce.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: ce.SELECTION_SET,
      selections: this.many(
        V.BRACE_L,
        this.parseSelection,
        V.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(V.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const e = this._lexer.token, t = this.parseName();
    let r, i;
    return this.expectOptionalToken(V.COLON) ? (r = t, i = this.parseName()) : i = t, this.node(e, {
      kind: ce.FIELD,
      alias: r,
      name: i,
      arguments: this.parseArguments(!1),
      directives: this.parseDirectives(!1),
      selectionSet: this.peek(V.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(e) {
    const t = e ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(V.PAREN_L, t, V.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(e = !1) {
    const t = this._lexer.token, r = this.parseName();
    return this.expectToken(V.COLON), this.node(t, {
      kind: ce.ARGUMENT,
      name: r,
      value: this.parseValueLiteral(e)
    });
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const e = this._lexer.token;
    this.expectToken(V.SPREAD);
    const t = this.expectOptionalKeyword("on");
    return !t && this.peek(V.NAME) ? this.node(e, {
      kind: ce.FRAGMENT_SPREAD,
      name: this.parseFragmentName(),
      directives: this.parseDirectives(!1)
    }) : this.node(e, {
      kind: ce.INLINE_FRAGMENT,
      typeCondition: t ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const e = this._lexer.token;
    return this.expectKeyword("fragment"), this._options.allowLegacyFragmentVariables === !0 ? this.node(e, {
      kind: ce.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      variableDefinitions: this.parseVariableDefinitions(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    }) : this.node(e, {
      kind: ce.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(!1),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on")
      throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(e) {
    const t = this._lexer.token;
    switch (t.kind) {
      case V.BRACKET_L:
        return this.parseList(e);
      case V.BRACE_L:
        return this.parseObject(e);
      case V.INT:
        return this.advanceLexer(), this.node(t, {
          kind: ce.INT,
          value: t.value
        });
      case V.FLOAT:
        return this.advanceLexer(), this.node(t, {
          kind: ce.FLOAT,
          value: t.value
        });
      case V.STRING:
      case V.BLOCK_STRING:
        return this.parseStringLiteral();
      case V.NAME:
        switch (this.advanceLexer(), t.value) {
          case "true":
            return this.node(t, {
              kind: ce.BOOLEAN,
              value: !0
            });
          case "false":
            return this.node(t, {
              kind: ce.BOOLEAN,
              value: !1
            });
          case "null":
            return this.node(t, {
              kind: ce.NULL
            });
          default:
            return this.node(t, {
              kind: ce.ENUM,
              value: t.value
            });
        }
      case V.DOLLAR:
        if (e)
          if (this.expectToken(V.DOLLAR), this._lexer.token.kind === V.NAME) {
            const r = this._lexer.token.value;
            throw Xt(
              this._lexer.source,
              t.start,
              `Unexpected variable "$${r}" in constant value.`
            );
          } else
            throw this.unexpected(t);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const e = this._lexer.token;
    return this.advanceLexer(), this.node(e, {
      kind: ce.STRING,
      value: e.value,
      block: e.kind === V.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(e) {
    const t = () => this.parseValueLiteral(e);
    return this.node(this._lexer.token, {
      kind: ce.LIST,
      values: this.any(V.BRACKET_L, t, V.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(e) {
    const t = () => this.parseObjectField(e);
    return this.node(this._lexer.token, {
      kind: ce.OBJECT,
      fields: this.any(V.BRACE_L, t, V.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(e) {
    const t = this._lexer.token, r = this.parseName();
    return this.expectToken(V.COLON), this.node(t, {
      kind: ce.OBJECT_FIELD,
      name: r,
      value: this.parseValueLiteral(e)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(e) {
    const t = [];
    for (; this.peek(V.AT); )
      t.push(this.parseDirective(e));
    return t;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(e) {
    const t = this._lexer.token;
    return this.expectToken(V.AT), this.node(t, {
      kind: ce.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(e)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const e = this._lexer.token;
    let t;
    if (this.expectOptionalToken(V.BRACKET_L)) {
      const r = this.parseTypeReference();
      this.expectToken(V.BRACKET_R), t = this.node(e, {
        kind: ce.LIST_TYPE,
        type: r
      });
    } else
      t = this.parseNamedType();
    return this.expectOptionalToken(V.BANG) ? this.node(e, {
      kind: ce.NON_NULL_TYPE,
      type: t
    }) : t;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: ce.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(V.STRING) || this.peek(V.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription())
      return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("schema");
    const r = this.parseConstDirectives(), i = this.many(
      V.BRACE_L,
      this.parseOperationTypeDefinition,
      V.BRACE_R
    );
    return this.node(e, {
      kind: ce.SCHEMA_DEFINITION,
      description: t,
      directives: r,
      operationTypes: i
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const e = this._lexer.token, t = this.parseOperationType();
    this.expectToken(V.COLON);
    const r = this.parseNamedType();
    return this.node(e, {
      kind: ce.OPERATION_TYPE_DEFINITION,
      operation: t,
      type: r
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("scalar");
    const r = this.parseName(), i = this.parseConstDirectives();
    return this.node(e, {
      kind: ce.SCALAR_TYPE_DEFINITION,
      description: t,
      name: r,
      directives: i
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("type");
    const r = this.parseName(), i = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    return this.node(e, {
      kind: ce.OBJECT_TYPE_DEFINITION,
      description: t,
      name: r,
      interfaces: i,
      directives: s,
      fields: a
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(V.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      V.BRACE_L,
      this.parseFieldDefinition,
      V.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const e = this._lexer.token, t = this.parseDescription(), r = this.parseName(), i = this.parseArgumentDefs();
    this.expectToken(V.COLON);
    const s = this.parseTypeReference(), a = this.parseConstDirectives();
    return this.node(e, {
      kind: ce.FIELD_DEFINITION,
      description: t,
      name: r,
      arguments: i,
      type: s,
      directives: a
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      V.PAREN_L,
      this.parseInputValueDef,
      V.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const e = this._lexer.token, t = this.parseDescription(), r = this.parseName();
    this.expectToken(V.COLON);
    const i = this.parseTypeReference();
    let s;
    this.expectOptionalToken(V.EQUALS) && (s = this.parseConstValueLiteral());
    const a = this.parseConstDirectives();
    return this.node(e, {
      kind: ce.INPUT_VALUE_DEFINITION,
      description: t,
      name: r,
      type: i,
      defaultValue: s,
      directives: a
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("interface");
    const r = this.parseName(), i = this.parseImplementsInterfaces(), s = this.parseConstDirectives(), a = this.parseFieldsDefinition();
    return this.node(e, {
      kind: ce.INTERFACE_TYPE_DEFINITION,
      description: t,
      name: r,
      interfaces: i,
      directives: s,
      fields: a
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("union");
    const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseUnionMemberTypes();
    return this.node(e, {
      kind: ce.UNION_TYPE_DEFINITION,
      description: t,
      name: r,
      directives: i,
      types: s
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(V.EQUALS) ? this.delimitedMany(V.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("enum");
    const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseEnumValuesDefinition();
    return this.node(e, {
      kind: ce.ENUM_TYPE_DEFINITION,
      description: t,
      name: r,
      directives: i,
      values: s
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      V.BRACE_L,
      this.parseEnumValueDefinition,
      V.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const e = this._lexer.token, t = this.parseDescription(), r = this.parseEnumValueName(), i = this.parseConstDirectives();
    return this.node(e, {
      kind: ce.ENUM_VALUE_DEFINITION,
      description: t,
      name: r,
      directives: i
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null")
      throw Xt(
        this._lexer.source,
        this._lexer.token.start,
        `${dc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("input");
    const r = this.parseName(), i = this.parseConstDirectives(), s = this.parseInputFieldsDefinition();
    return this.node(e, {
      kind: ce.INPUT_OBJECT_TYPE_DEFINITION,
      description: t,
      name: r,
      directives: i,
      fields: s
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      V.BRACE_L,
      this.parseInputValueDef,
      V.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const e = this._lexer.lookahead();
    if (e.kind === V.NAME)
      switch (e.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(e);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("schema");
    const t = this.parseConstDirectives(), r = this.optionalMany(
      V.BRACE_L,
      this.parseOperationTypeDefinition,
      V.BRACE_R
    );
    if (t.length === 0 && r.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ce.SCHEMA_EXTENSION,
      directives: t,
      operationTypes: r
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("scalar");
    const t = this.parseName(), r = this.parseConstDirectives();
    if (r.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ce.SCALAR_TYPE_EXTENSION,
      name: t,
      directives: r
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("type");
    const t = this.parseName(), r = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), s = this.parseFieldsDefinition();
    if (r.length === 0 && i.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ce.OBJECT_TYPE_EXTENSION,
      name: t,
      interfaces: r,
      directives: i,
      fields: s
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("interface");
    const t = this.parseName(), r = this.parseImplementsInterfaces(), i = this.parseConstDirectives(), s = this.parseFieldsDefinition();
    if (r.length === 0 && i.length === 0 && s.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ce.INTERFACE_TYPE_EXTENSION,
      name: t,
      interfaces: r,
      directives: i,
      fields: s
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("union");
    const t = this.parseName(), r = this.parseConstDirectives(), i = this.parseUnionMemberTypes();
    if (r.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ce.UNION_TYPE_EXTENSION,
      name: t,
      directives: r,
      types: i
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("enum");
    const t = this.parseName(), r = this.parseConstDirectives(), i = this.parseEnumValuesDefinition();
    if (r.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ce.ENUM_TYPE_EXTENSION,
      name: t,
      directives: r,
      values: i
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword("extend"), this.expectKeyword("input");
    const t = this.parseName(), r = this.parseConstDirectives(), i = this.parseInputFieldsDefinition();
    if (r.length === 0 && i.length === 0)
      throw this.unexpected();
    return this.node(e, {
      kind: ce.INPUT_OBJECT_TYPE_EXTENSION,
      name: t,
      directives: r,
      fields: i
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const e = this._lexer.token, t = this.parseDescription();
    this.expectKeyword("directive"), this.expectToken(V.AT);
    const r = this.parseName(), i = this.parseArgumentDefs(), s = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const a = this.parseDirectiveLocations();
    return this.node(e, {
      kind: ce.DIRECTIVE_DEFINITION,
      description: t,
      name: r,
      arguments: i,
      repeatable: s,
      locations: a
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(V.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const e = this._lexer.token, t = this.parseName();
    if (Object.prototype.hasOwnProperty.call(Lh, t.value))
      return t;
    throw this.unexpected(e);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(e, t) {
    return this._options.noLocation !== !0 && (t.loc = new uP(
      e,
      this._lexer.lastToken,
      this._lexer.source
    )), t;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(e) {
    return this._lexer.token.kind === e;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(e) {
    const t = this._lexer.token;
    if (t.kind === e)
      return this.advanceLexer(), t;
    throw Xt(
      this._lexer.source,
      t.start,
      `Expected ${nT(e)}, found ${dc(t)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(e) {
    return this._lexer.token.kind === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(e) {
    const t = this._lexer.token;
    if (t.kind === V.NAME && t.value === e)
      this.advanceLexer();
    else
      throw Xt(
        this._lexer.source,
        t.start,
        `Expected "${e}", found ${dc(t)}.`
      );
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(e) {
    const t = this._lexer.token;
    return t.kind === V.NAME && t.value === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(e) {
    const t = e ?? this._lexer.token;
    return Xt(
      this._lexer.source,
      t.start,
      `Unexpected ${dc(t)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(e, t, r) {
    this.expectToken(e);
    const i = [];
    for (; !this.expectOptionalToken(r); )
      i.push(t.call(this));
    return i;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(e, t, r) {
    if (this.expectOptionalToken(e)) {
      const i = [];
      do
        i.push(t.call(this));
      while (!this.expectOptionalToken(r));
      return i;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(e, t, r) {
    this.expectToken(e);
    const i = [];
    do
      i.push(t.call(this));
    while (!this.expectOptionalToken(r));
    return i;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(e, t) {
    this.expectOptionalToken(e);
    const r = [];
    do
      r.push(t.call(this));
    while (this.expectOptionalToken(e));
    return r;
  }
  advanceLexer() {
    const { maxTokens: e } = this._options, t = this._lexer.advance();
    if (e !== void 0 && t.kind !== V.EOF && (++this._tokenCounter, this._tokenCounter > e))
      throw Xt(
        this._lexer.source,
        t.start,
        `Document contains more that ${e} tokens. Parsing aborted.`
      );
  }
}
function dc(n) {
  const e = n.value;
  return nT(n.kind) + (e != null ? ` "${e}"` : "");
}
function nT(n) {
  return yP(n) ? `"${n}"` : n;
}
function DP(n) {
  return `"${n.replace(BP, FP)}"`;
}
const BP = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function FP(n) {
  return LP[n.charCodeAt(0)];
}
const LP = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
], $P = Object.freeze({});
function UP(n, e, t = K6) {
  const r = /* @__PURE__ */ new Map();
  for (const M of Object.values(ce))
    r.set(M, jP(e, M));
  let i, s = Array.isArray(n), a = [n], o = -1, u = [], l = n, d, p;
  const m = [], w = [];
  do {
    o++;
    const M = o === a.length, I = M && u.length !== 0;
    if (M) {
      if (d = w.length === 0 ? void 0 : m[m.length - 1], l = p, p = w.pop(), I)
        if (s) {
          l = l.slice();
          let k = 0;
          for (const [N, U] of u) {
            const W = N - k;
            U === null ? (l.splice(W, 1), k++) : l[W] = U;
          }
        } else {
          l = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(l)
          );
          for (const [k, N] of u)
            l[k] = N;
        }
      o = i.index, a = i.keys, u = i.edits, s = i.inArray, i = i.prev;
    } else if (p) {
      if (d = s ? o : a[o], l = p[d], l == null)
        continue;
      m.push(d);
    }
    let B;
    if (!Array.isArray(l)) {
      var x, T;
      Nx(l) || Bc(!1, `Invalid AST Node: ${eT(l)}.`);
      const k = M ? (x = r.get(l.kind)) === null || x === void 0 ? void 0 : x.leave : (T = r.get(l.kind)) === null || T === void 0 ? void 0 : T.enter;
      if (B = k?.call(e, l, d, p, m, w), B === $P)
        break;
      if (B === !1) {
        if (!M) {
          m.pop();
          continue;
        }
      } else if (B !== void 0 && (u.push([d, B]), !M))
        if (Nx(B))
          l = B;
        else {
          m.pop();
          continue;
        }
    }
    if (B === void 0 && I && u.push([d, l]), M)
      m.pop();
    else {
      var A;
      i = {
        inArray: s,
        index: o,
        keys: a,
        edits: u,
        prev: i
      }, s = Array.isArray(l), a = s ? l : (A = t[l.kind]) !== null && A !== void 0 ? A : [], o = -1, u = [], p && w.push(p), p = l;
    }
  } while (i !== void 0);
  return u.length !== 0 ? u[u.length - 1][1] : n;
}
function jP(n, e) {
  const t = n[e];
  return typeof t == "object" ? t : typeof t == "function" ? {
    enter: t,
    leave: void 0
  } : {
    enter: n.enter,
    leave: n.leave
  };
}
function VP(n) {
  return UP(n, GP);
}
const zP = 80, GP = {
  Name: {
    leave: (n) => n.value
  },
  Variable: {
    leave: (n) => "$" + n.name
  },
  // Document
  Document: {
    leave: (n) => re(n.definitions, `

`)
  },
  OperationDefinition: {
    leave(n) {
      const e = Te("(", re(n.variableDefinitions, ", "), ")"), t = re(
        [
          n.operation,
          re([n.name, e]),
          re(n.directives, " ")
        ],
        " "
      );
      return (t === "query" ? "" : t + " ") + n.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable: n, type: e, defaultValue: t, directives: r }) => n + ": " + e + Te(" = ", t) + Te(" ", re(r, " "))
  },
  SelectionSet: {
    leave: ({ selections: n }) => Tr(n)
  },
  Field: {
    leave({ alias: n, name: e, arguments: t, directives: r, selectionSet: i }) {
      const s = Te("", n, ": ") + e;
      let a = s + Te("(", re(t, ", "), ")");
      return a.length > zP && (a = s + Te(`(
`, Fc(re(t, `
`)), `
)`)), re([a, re(r, " "), i], " ");
    }
  },
  Argument: {
    leave: ({ name: n, value: e }) => n + ": " + e
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name: n, directives: e }) => "..." + n + Te(" ", re(e, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition: n, directives: e, selectionSet: t }) => re(
      [
        "...",
        Te("on ", n),
        re(e, " "),
        t
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name: n, typeCondition: e, variableDefinitions: t, directives: r, selectionSet: i }) => (
      // or removed in the future.
      `fragment ${n}${Te("(", re(t, ", "), ")")} on ${e} ${Te("", re(r, " "), " ")}` + i
    )
  },
  // Value
  IntValue: {
    leave: ({ value: n }) => n
  },
  FloatValue: {
    leave: ({ value: n }) => n
  },
  StringValue: {
    leave: ({ value: n, block: e }) => e ? pP(n) : DP(n)
  },
  BooleanValue: {
    leave: ({ value: n }) => n ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: n }) => n
  },
  ListValue: {
    leave: ({ values: n }) => "[" + re(n, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields: n }) => "{" + re(n, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: n, value: e }) => n + ": " + e
  },
  // Directive
  Directive: {
    leave: ({ name: n, arguments: e }) => "@" + n + Te("(", re(e, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name: n }) => n
  },
  ListType: {
    leave: ({ type: n }) => "[" + n + "]"
  },
  NonNullType: {
    leave: ({ type: n }) => n + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description: n, directives: e, operationTypes: t }) => Te("", n, `
`) + re(["schema", re(e, " "), Tr(t)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation: n, type: e }) => n + ": " + e
  },
  ScalarTypeDefinition: {
    leave: ({ description: n, name: e, directives: t }) => Te("", n, `
`) + re(["scalar", e, re(t, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description: n, name: e, interfaces: t, directives: r, fields: i }) => Te("", n, `
`) + re(
      [
        "type",
        e,
        Te("implements ", re(t, " & ")),
        re(r, " "),
        Tr(i)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description: n, name: e, arguments: t, type: r, directives: i }) => Te("", n, `
`) + e + (Bx(t) ? Te(`(
`, Fc(re(t, `
`)), `
)`) : Te("(", re(t, ", "), ")")) + ": " + r + Te(" ", re(i, " "))
  },
  InputValueDefinition: {
    leave: ({ description: n, name: e, type: t, defaultValue: r, directives: i }) => Te("", n, `
`) + re(
      [e + ": " + t, Te("= ", r), re(i, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description: n, name: e, interfaces: t, directives: r, fields: i }) => Te("", n, `
`) + re(
      [
        "interface",
        e,
        Te("implements ", re(t, " & ")),
        re(r, " "),
        Tr(i)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description: n, name: e, directives: t, types: r }) => Te("", n, `
`) + re(
      ["union", e, re(t, " "), Te("= ", re(r, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description: n, name: e, directives: t, values: r }) => Te("", n, `
`) + re(["enum", e, re(t, " "), Tr(r)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description: n, name: e, directives: t }) => Te("", n, `
`) + re([e, re(t, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description: n, name: e, directives: t, fields: r }) => Te("", n, `
`) + re(["input", e, re(t, " "), Tr(r)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description: n, name: e, arguments: t, repeatable: r, locations: i }) => Te("", n, `
`) + "directive @" + e + (Bx(t) ? Te(`(
`, Fc(re(t, `
`)), `
)`) : Te("(", re(t, ", "), ")")) + (r ? " repeatable" : "") + " on " + re(i, " | ")
  },
  SchemaExtension: {
    leave: ({ directives: n, operationTypes: e }) => re(
      ["extend schema", re(n, " "), Tr(e)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name: n, directives: e }) => re(["extend scalar", n, re(e, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: n, interfaces: e, directives: t, fields: r }) => re(
      [
        "extend type",
        n,
        Te("implements ", re(e, " & ")),
        re(t, " "),
        Tr(r)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name: n, interfaces: e, directives: t, fields: r }) => re(
      [
        "extend interface",
        n,
        Te("implements ", re(e, " & ")),
        re(t, " "),
        Tr(r)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name: n, directives: e, types: t }) => re(
      [
        "extend union",
        n,
        re(e, " "),
        Te("= ", re(t, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name: n, directives: e, values: t }) => re(["extend enum", n, re(e, " "), Tr(t)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: n, directives: e, fields: t }) => re(["extend input", n, re(e, " "), Tr(t)], " ")
  }
};
function re(n, e = "") {
  var t;
  return (t = n?.filter((r) => r).join(e)) !== null && t !== void 0 ? t : "";
}
function Tr(n) {
  return Te(`{
`, Fc(re(n, `
`)), `
}`);
}
function Te(n, e, t = "") {
  return e != null && e !== "" ? n + e + t : "";
}
function Fc(n) {
  return Te("  ", n.replace(/\n/g, `
  `));
}
function Bx(n) {
  var e;
  return (e = n?.some((t) => t.includes(`
`))) !== null && e !== void 0 ? e : !1;
}
const Fx = (n) => {
  let e;
  const t = n.definitions.filter((r) => r.kind === "OperationDefinition");
  return t.length === 1 && (e = t[0]?.name?.value), e;
}, kp = (n) => {
  if (typeof n == "string") {
    let t;
    try {
      const r = kP(n);
      t = Fx(r);
    } catch {
    }
    return { query: n, operationName: t };
  }
  const e = Fx(n);
  return { query: VP(n), operationName: e };
};
class Ru extends Error {
  constructor(e, t) {
    const r = `${Ru.extractMessage(e)}: ${JSON.stringify({
      response: e,
      request: t
    })}`;
    super(r), Object.setPrototypeOf(this, Ru.prototype), this.response = e, this.request = t, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, Ru);
  }
  static extractMessage(e) {
    return e.errors?.[0]?.message ?? `GraphQL Error (Code: ${e.status})`;
  }
}
var Uh = { exports: {} };
(function(n, e) {
  var t = typeof self < "u" ? self : bi, r = function() {
    function s() {
      this.fetch = !1, this.DOMException = t.DOMException;
    }
    return s.prototype = t, new s();
  }();
  (function(s) {
    (function(a) {
      var o = {
        searchParams: "URLSearchParams" in s,
        iterable: "Symbol" in s && "iterator" in Symbol,
        blob: "FileReader" in s && "Blob" in s && function() {
          try {
            return new Blob(), !0;
          } catch {
            return !1;
          }
        }(),
        formData: "FormData" in s,
        arrayBuffer: "ArrayBuffer" in s
      };
      function u(c) {
        return c && DataView.prototype.isPrototypeOf(c);
      }
      if (o.arrayBuffer)
        var l = [
          "[object Int8Array]",
          "[object Uint8Array]",
          "[object Uint8ClampedArray]",
          "[object Int16Array]",
          "[object Uint16Array]",
          "[object Int32Array]",
          "[object Uint32Array]",
          "[object Float32Array]",
          "[object Float64Array]"
        ], d = ArrayBuffer.isView || function(c) {
          return c && l.indexOf(Object.prototype.toString.call(c)) > -1;
        };
      function p(c) {
        if (typeof c != "string" && (c = String(c)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(c))
          throw new TypeError("Invalid character in header field name");
        return c.toLowerCase();
      }
      function m(c) {
        return typeof c != "string" && (c = String(c)), c;
      }
      function w(c) {
        var h = {
          next: function() {
            var g = c.shift();
            return { done: g === void 0, value: g };
          }
        };
        return o.iterable && (h[Symbol.iterator] = function() {
          return h;
        }), h;
      }
      function x(c) {
        this.map = {}, c instanceof x ? c.forEach(function(h, g) {
          this.append(g, h);
        }, this) : Array.isArray(c) ? c.forEach(function(h) {
          this.append(h[0], h[1]);
        }, this) : c && Object.getOwnPropertyNames(c).forEach(function(h) {
          this.append(h, c[h]);
        }, this);
      }
      x.prototype.append = function(c, h) {
        c = p(c), h = m(h);
        var g = this.map[c];
        this.map[c] = g ? g + ", " + h : h;
      }, x.prototype.delete = function(c) {
        delete this.map[p(c)];
      }, x.prototype.get = function(c) {
        return c = p(c), this.has(c) ? this.map[c] : null;
      }, x.prototype.has = function(c) {
        return this.map.hasOwnProperty(p(c));
      }, x.prototype.set = function(c, h) {
        this.map[p(c)] = m(h);
      }, x.prototype.forEach = function(c, h) {
        for (var g in this.map)
          this.map.hasOwnProperty(g) && c.call(h, this.map[g], g, this);
      }, x.prototype.keys = function() {
        var c = [];
        return this.forEach(function(h, g) {
          c.push(g);
        }), w(c);
      }, x.prototype.values = function() {
        var c = [];
        return this.forEach(function(h) {
          c.push(h);
        }), w(c);
      }, x.prototype.entries = function() {
        var c = [];
        return this.forEach(function(h, g) {
          c.push([g, h]);
        }), w(c);
      }, o.iterable && (x.prototype[Symbol.iterator] = x.prototype.entries);
      function T(c) {
        if (c.bodyUsed)
          return Promise.reject(new TypeError("Already read"));
        c.bodyUsed = !0;
      }
      function A(c) {
        return new Promise(function(h, g) {
          c.onload = function() {
            h(c.result);
          }, c.onerror = function() {
            g(c.error);
          };
        });
      }
      function M(c) {
        var h = new FileReader(), g = A(h);
        return h.readAsArrayBuffer(c), g;
      }
      function I(c) {
        var h = new FileReader(), g = A(h);
        return h.readAsText(c), g;
      }
      function B(c) {
        for (var h = new Uint8Array(c), g = new Array(h.length), E = 0; E < h.length; E++)
          g[E] = String.fromCharCode(h[E]);
        return g.join("");
      }
      function k(c) {
        if (c.slice)
          return c.slice(0);
        var h = new Uint8Array(c.byteLength);
        return h.set(new Uint8Array(c)), h.buffer;
      }
      function N() {
        return this.bodyUsed = !1, this._initBody = function(c) {
          this._bodyInit = c, c ? typeof c == "string" ? this._bodyText = c : o.blob && Blob.prototype.isPrototypeOf(c) ? this._bodyBlob = c : o.formData && FormData.prototype.isPrototypeOf(c) ? this._bodyFormData = c : o.searchParams && URLSearchParams.prototype.isPrototypeOf(c) ? this._bodyText = c.toString() : o.arrayBuffer && o.blob && u(c) ? (this._bodyArrayBuffer = k(c.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : o.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(c) || d(c)) ? this._bodyArrayBuffer = k(c) : this._bodyText = c = Object.prototype.toString.call(c) : this._bodyText = "", this.headers.get("content-type") || (typeof c == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : o.searchParams && URLSearchParams.prototype.isPrototypeOf(c) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
        }, o.blob && (this.blob = function() {
          var c = T(this);
          if (c)
            return c;
          if (this._bodyBlob)
            return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? T(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(M);
        }), this.text = function() {
          var c = T(this);
          if (c)
            return c;
          if (this._bodyBlob)
            return I(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(B(this._bodyArrayBuffer));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText);
        }, o.formData && (this.formData = function() {
          return this.text().then(Y);
        }), this.json = function() {
          return this.text().then(JSON.parse);
        }, this;
      }
      var U = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
      function W(c) {
        var h = c.toUpperCase();
        return U.indexOf(h) > -1 ? h : c;
      }
      function G(c, h) {
        h = h || {};
        var g = h.body;
        if (c instanceof G) {
          if (c.bodyUsed)
            throw new TypeError("Already read");
          this.url = c.url, this.credentials = c.credentials, h.headers || (this.headers = new x(c.headers)), this.method = c.method, this.mode = c.mode, this.signal = c.signal, !g && c._bodyInit != null && (g = c._bodyInit, c.bodyUsed = !0);
        } else
          this.url = String(c);
        if (this.credentials = h.credentials || this.credentials || "same-origin", (h.headers || !this.headers) && (this.headers = new x(h.headers)), this.method = W(h.method || this.method || "GET"), this.mode = h.mode || this.mode || null, this.signal = h.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && g)
          throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(g);
      }
      G.prototype.clone = function() {
        return new G(this, { body: this._bodyInit });
      };
      function Y(c) {
        var h = new FormData();
        return c.trim().split("&").forEach(function(g) {
          if (g) {
            var E = g.split("="), S = E.shift().replace(/\+/g, " "), _ = E.join("=").replace(/\+/g, " ");
            h.append(decodeURIComponent(S), decodeURIComponent(_));
          }
        }), h;
      }
      function ue(c) {
        var h = new x(), g = c.replace(/\r?\n[\t ]+/g, " ");
        return g.split(/\r?\n/).forEach(function(E) {
          var S = E.split(":"), _ = S.shift().trim();
          if (_) {
            var P = S.join(":").trim();
            h.append(_, P);
          }
        }), h;
      }
      N.call(G.prototype);
      function K(c, h) {
        h || (h = {}), this.type = "default", this.status = h.status === void 0 ? 200 : h.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in h ? h.statusText : "OK", this.headers = new x(h.headers), this.url = h.url || "", this._initBody(c);
      }
      N.call(K.prototype), K.prototype.clone = function() {
        return new K(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new x(this.headers),
          url: this.url
        });
      }, K.error = function() {
        var c = new K(null, { status: 0, statusText: "" });
        return c.type = "error", c;
      };
      var le = [301, 302, 303, 307, 308];
      K.redirect = function(c, h) {
        if (le.indexOf(h) === -1)
          throw new RangeError("Invalid status code");
        return new K(null, { status: h, headers: { location: c } });
      }, a.DOMException = s.DOMException;
      try {
        new a.DOMException();
      } catch {
        a.DOMException = function(h, g) {
          this.message = h, this.name = g;
          var E = Error(h);
          this.stack = E.stack;
        }, a.DOMException.prototype = Object.create(Error.prototype), a.DOMException.prototype.constructor = a.DOMException;
      }
      function C(c, h) {
        return new Promise(function(g, E) {
          var S = new G(c, h);
          if (S.signal && S.signal.aborted)
            return E(new a.DOMException("Aborted", "AbortError"));
          var _ = new XMLHttpRequest();
          function P() {
            _.abort();
          }
          _.onload = function() {
            var b = {
              status: _.status,
              statusText: _.statusText,
              headers: ue(_.getAllResponseHeaders() || "")
            };
            b.url = "responseURL" in _ ? _.responseURL : b.headers.get("X-Request-URL");
            var f = "response" in _ ? _.response : _.responseText;
            g(new K(f, b));
          }, _.onerror = function() {
            E(new TypeError("Network request failed"));
          }, _.ontimeout = function() {
            E(new TypeError("Network request failed"));
          }, _.onabort = function() {
            E(new a.DOMException("Aborted", "AbortError"));
          }, _.open(S.method, S.url, !0), S.credentials === "include" ? _.withCredentials = !0 : S.credentials === "omit" && (_.withCredentials = !1), "responseType" in _ && o.blob && (_.responseType = "blob"), S.headers.forEach(function(b, f) {
            _.setRequestHeader(f, b);
          }), S.signal && (S.signal.addEventListener("abort", P), _.onreadystatechange = function() {
            _.readyState === 4 && S.signal.removeEventListener("abort", P);
          }), _.send(typeof S._bodyInit > "u" ? null : S._bodyInit);
        });
      }
      return C.polyfill = !0, s.fetch || (s.fetch = C, s.Headers = x, s.Request = G, s.Response = K), a.Headers = x, a.Request = G, a.Response = K, a.fetch = C, Object.defineProperty(a, "__esModule", { value: !0 }), a;
    })({});
  })(r), r.fetch.ponyfill = !0, delete r.fetch.polyfill;
  var i = r;
  e = i.fetch, e.default = i.fetch, e.fetch = i.fetch, e.Headers = i.Headers, e.Request = i.Request, e.Response = i.Response, n.exports = e;
})(Uh, Uh.exports);
var vd = Uh.exports;
const Lc = /* @__PURE__ */ _s(vd), HP = /* @__PURE__ */ R5({
  __proto__: null,
  default: Lc
}, [vd]), qa = (n) => {
  let e = {};
  return n && (typeof Headers < "u" && n instanceof Headers || HP && vd.Headers && n instanceof vd.Headers ? e = Z9(n) : Array.isArray(n) ? n.forEach(([t, r]) => {
    t && r !== void 0 && (e[t] = r);
  }) : e = n), e;
}, Lx = (n) => n.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim(), qP = (n) => {
  if (!Array.isArray(n.query)) {
    const r = n, i = [`query=${encodeURIComponent(Lx(r.query))}`];
    return n.variables && i.push(`variables=${encodeURIComponent(r.jsonSerializer.stringify(r.variables))}`), r.operationName && i.push(`operationName=${encodeURIComponent(r.operationName)}`), i.join("&");
  }
  if (typeof n.variables < "u" && !Array.isArray(n.variables))
    throw new Error("Cannot create query with given variable type, array expected");
  const e = n, t = n.query.reduce((r, i, s) => (r.push({
    query: Lx(i),
    variables: e.variables ? e.jsonSerializer.stringify(e.variables[s]) : void 0
  }), r), []);
  return `query=${encodeURIComponent(e.jsonSerializer.stringify(t))}`;
}, WP = (n) => async (e) => {
  const { url: t, query: r, variables: i, operationName: s, fetch: a, fetchOptions: o, middleware: u } = e, l = { ...e.headers };
  let d = "", p;
  n === "POST" ? (p = JP(r, i, s, o.jsonSerializer), typeof p == "string" && (l["Content-Type"] = "application/json")) : d = qP({
    query: r,
    variables: i,
    operationName: s,
    jsonSerializer: o.jsonSerializer ?? Ny
  });
  const m = {
    method: n,
    headers: l,
    body: p,
    ...o
  };
  let w = t, x = m;
  if (u) {
    const T = await Promise.resolve(u({ ...m, url: t, operationName: s, variables: i })), { url: A, ...M } = T;
    w = A, x = M;
  }
  return d && (w = `${w}?${d}`), await a(w, x);
};
class KP {
  constructor(e, t = {}) {
    this.url = e, this.requestConfig = t, this.rawRequest = async (...r) => {
      const [i, s, a] = r, o = tP(i, s, a), { headers: u, fetch: l = Lc, method: d = "POST", requestMiddleware: p, responseMiddleware: m, ...w } = this.requestConfig, { url: x } = this;
      o.signal !== void 0 && (w.signal = o.signal);
      const { operationName: T } = kp(o.query);
      return Np({
        url: x,
        query: o.query,
        variables: o.variables,
        headers: {
          ...qa(Dp(u)),
          ...qa(o.requestHeaders)
        },
        operationName: T,
        fetch: l,
        method: d,
        fetchOptions: w,
        middleware: p
      }).then((A) => (m && m(A), A)).catch((A) => {
        throw m && m(A), A;
      });
    };
  }
  async request(e, ...t) {
    const [r, i] = t, s = eP(e, r, i), { headers: a, fetch: o = Lc, method: u = "POST", requestMiddleware: l, responseMiddleware: d, ...p } = this.requestConfig, { url: m } = this;
    s.signal !== void 0 && (p.signal = s.signal);
    const { query: w, operationName: x } = kp(s.document);
    return Np({
      url: m,
      query: w,
      variables: s.variables,
      headers: {
        ...qa(Dp(a)),
        ...qa(s.requestHeaders)
      },
      operationName: x,
      fetch: o,
      method: u,
      fetchOptions: p,
      middleware: l
    }).then((T) => (d && d(T), T.data)).catch((T) => {
      throw d && d(T), T;
    });
  }
  // prettier-ignore
  batchRequests(e, t) {
    const r = nP(e, t), { headers: i, ...s } = this.requestConfig;
    r.signal !== void 0 && (s.signal = r.signal);
    const a = r.documents.map(({ document: u }) => kp(u).query), o = r.documents.map(({ variables: u }) => u);
    return Np({
      url: this.url,
      query: a,
      // @ts-expect-error TODO reconcile batch variables into system.
      variables: o,
      headers: {
        ...qa(Dp(i)),
        ...qa(r.requestHeaders)
      },
      operationName: void 0,
      fetch: this.requestConfig.fetch ?? Lc,
      method: this.requestConfig.method || "POST",
      fetchOptions: s,
      middleware: this.requestConfig.requestMiddleware
    }).then((u) => (this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(u), u.data)).catch((u) => {
      throw this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(u), u;
    });
  }
  setHeaders(e) {
    return this.requestConfig.headers = e, this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(e, t) {
    const { headers: r } = this.requestConfig;
    return r ? r[e] = t : this.requestConfig.headers = { [e]: t }, this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(e) {
    return this.url = e, this;
  }
}
const Np = async (n) => {
  const { query: e, variables: t, fetchOptions: r } = n, i = WP(X9(n.method ?? "post")), s = Array.isArray(n.query), a = await i(n), o = await QP(a, r.jsonSerializer ?? Ny), u = Array.isArray(o) ? !o.some(({ data: d }) => !d) : !!o.data, l = Array.isArray(o) || !o.errors || Array.isArray(o.errors) && !o.errors.length || r.errorPolicy === "all" || r.errorPolicy === "ignore";
  if (a.ok && l && u) {
    const { errors: d, ...p } = (Array.isArray(o), o), m = r.errorPolicy === "ignore" ? p : o;
    return {
      ...s ? { data: m } : m,
      headers: a.headers,
      status: a.status
    };
  } else {
    const d = typeof o == "string" ? {
      error: o
    } : o;
    throw new Ru(
      // @ts-expect-error TODO
      { ...d, status: a.status, headers: a.headers },
      { query: e, variables: t }
    );
  }
}, JP = (n, e, t, r) => {
  const i = r ?? Ny;
  if (!Array.isArray(n))
    return i.stringify({ query: n, variables: e, operationName: t });
  if (typeof e < "u" && !Array.isArray(e))
    throw new Error("Cannot create request body with given variable type, array expected");
  const s = n.reduce((a, o, u) => (a.push({ query: o, variables: e ? e[u] : void 0 }), a), []);
  return i.stringify(s);
}, QP = async (n, e) => {
  let t;
  return n.headers.forEach((r, i) => {
    i.toLowerCase() === "content-type" && (t = r);
  }), t && (t.toLowerCase().startsWith("application/json") || t.toLowerCase().startsWith("application/graphql+json") || t.toLowerCase().startsWith("application/graphql-response+json")) ? e.parse(await n.text()) : n.text();
}, Dp = (n) => typeof n == "function" ? n() : n, Bp = (n, ...e) => n.reduce((t, r, i) => `${t}${r}${i in e ? String(e[i]) : ""}`, "");
var YP = Object.defineProperty, XP = Object.getOwnPropertyDescriptor, ZP = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? XP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && YP(e, t, i), i;
}, eR = (n, e) => (t, r) => e(t, r, n);
const By = me.createInterface("SymmetricService"), tR = "0x765de816845861e75a25fca122bb6898b8b1282a";
let rl = class {
  constructor(n) {
    this.configuration = n;
  }
  static register(n) {
    be.singleton(By, rl).register(n);
  }
  // _poolId: poolid is constant and will be provided by backend.
  // ethers: just pass directly imported ethers
  indexVolumeAndFees = async () => {
    const n = "https://api.thegraph.com/subgraphs/name/centfinance/symmetric-v2-celo", e = new KP(n), t = Math.floor(Number(new Date((/* @__PURE__ */ new Date()).getTime() - 24 * 60 * 60 * 1e3)) / 1e3), r = Bp`
      query getSwaps($poolId: String!, $startTime: Int!) {
        swaps(where: { and: [{ poolId: $poolId }, { timestamp_gte: $startTime }] }) {
          tokenOut
          tokenAmountOut
          timestamp
        }
      }
    `, i = {
      poolId: this.configuration.kGcUSD,
      startTime: t
    }, s = Bp`
      query getPoolData($poolId: String!) {
        pool(id: $poolId) {
          swapFee
          totalSwapFee
          totalLiquidity
          totalSwapVolume
        }
      }
    `, a = {
      poolId: this.configuration.kGcUSD
    }, o = Bp`
      query getPrice($tokenAddress: String!) {
        token(id: $tokenAddress) {
          latestPrice {
            price
            pricingAsset
          }
        }
      }
    `, { swaps: u } = await e.request(r, i), { pool: l } = await e.request(s, a), d = {}, p = {};
    u.forEach((I) => {
      const B = d[I.tokenOut] ?? "0", k = ea(B), N = ea(I.tokenAmountOut);
      d[I.tokenOut] = H6(H.from(N).add(k));
    });
    const m = Object.keys(d);
    await Promise.all(
      m.map(async (I) => {
        const B = {
          tokenAddress: I
        };
        if (I === tR) {
          p[I] = "1";
          return;
        }
        const N = (await e.request(o, B)).token.latestPrice.price;
        p[I] = N;
      })
    );
    const w = m.reduce((I, B) => ea(d[B] ?? "0").mul(ea(p[B]?.toString().slice(0, 20) ?? "0")).add(I), H.from(0)), x = w.mul(ea(l.swapFee.toString())).div(ea("1")), T = xd(w, "36"), A = xd(x, "36"), M = l.totalLiquidity;
    return { volumeParsed: T, swapFeeParsed: A, tvl: M };
  };
};
rl = ZP([
  eR(0, Cs)
], rl);
function Dr(n) {
  return Dr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Dr(n);
}
function nR(n, e) {
  if (Dr(n) !== "object" || n === null)
    return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (Dr(r) !== "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function rT(n) {
  var e = nR(n, "string");
  return Dr(e) === "symbol" ? e : String(e);
}
function rR(n, e, t) {
  return e = rT(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function $n(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && r.push.apply(r, Object.getOwnPropertySymbols(t).filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.forEach(function(i) {
      rR(n, i, t[i]);
    });
  }
  return n;
}
function qi(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function $x(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, rT(r.key), r);
  }
}
function Wi(n, e, t) {
  return e && $x(n.prototype, e), t && $x(n, t), Object.defineProperty(n, "prototype", {
    writable: !1
  }), n;
}
function wa(n) {
  if (n === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function il(n, e) {
  if (e && (Dr(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return wa(n);
}
function _o(n) {
  return _o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _o(n);
}
function jh(n, e) {
  return jh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, jh(n, e);
}
function xf(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  n.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: n,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(n, "prototype", {
    writable: !1
  }), e && jh(n, e);
}
function Vh(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++)
    r[t] = n[t];
  return r;
}
function iR(n) {
  if (Array.isArray(n))
    return Vh(n);
}
function sR(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
    return Array.from(n);
}
function iT(n, e) {
  if (n) {
    if (typeof n == "string")
      return Vh(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return Vh(n, e);
  }
}
function aR() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function oR(n) {
  return iR(n) || sR(n) || iT(n) || aR();
}
function uR(n) {
  if (Array.isArray(n))
    return n;
}
function lR(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var r, i, s, a, o = [], u = !0, l = !1;
    try {
      if (s = (t = t.call(n)).next, e === 0) {
        if (Object(t) !== t)
          return;
        u = !1;
      } else
        for (; !(u = (r = s.call(t)).done) && (o.push(r.value), o.length !== e); u = !0)
          ;
    } catch (d) {
      l = !0, i = d;
    } finally {
      try {
        if (!u && t.return != null && (a = t.return(), Object(a) !== a))
          return;
      } finally {
        if (l)
          throw i;
      }
    }
    return o;
  }
}
function cR() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Ux(n, e) {
  return uR(n) || lR(n, e) || iT(n, e) || cR();
}
var dR = {
  type: "logger",
  log: function(e) {
    this.output("log", e);
  },
  warn: function(e) {
    this.output("warn", e);
  },
  error: function(e) {
    this.output("error", e);
  },
  output: function(e, t) {
    var r;
    console && console[e] && (r = console)[e].apply(r, oR(t));
  }
}, fR = /* @__PURE__ */ function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    qi(this, n), this.init(e, t);
  }
  return Wi(n, [{
    key: "init",
    value: function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = r.prefix || "i18next:", this.logger = t || dR, this.options = r, this.debug = r.debug;
    }
  }, {
    key: "setDebug",
    value: function(t) {
      this.debug = t;
    }
  }, {
    key: "log",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(t, r, i, s) {
      return s && !this.debug ? null : (typeof t[0] == "string" && (t[0] = "".concat(i).concat(this.prefix, " ").concat(t[0])), this.logger[r](t));
    }
  }, {
    key: "create",
    value: function(t) {
      return new n(this.logger, $n({}, {
        prefix: "".concat(this.prefix, ":").concat(t, ":")
      }, this.options));
    }
  }]), n;
}(), Ai = new fR(), Ts = /* @__PURE__ */ function() {
  function n() {
    qi(this, n), this.observers = {};
  }
  return Wi(n, [{
    key: "on",
    value: function(t, r) {
      var i = this;
      return t.split(" ").forEach(function(s) {
        i.observers[s] = i.observers[s] || [], i.observers[s].push(r);
      }), this;
    }
  }, {
    key: "off",
    value: function(t, r) {
      if (this.observers[t]) {
        if (!r) {
          delete this.observers[t];
          return;
        }
        this.observers[t] = this.observers[t].filter(function(i) {
          return i !== r;
        });
      }
    }
  }, {
    key: "emit",
    value: function(t) {
      for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)
        i[s - 1] = arguments[s];
      if (this.observers[t]) {
        var a = [].concat(this.observers[t]);
        a.forEach(function(u) {
          u.apply(void 0, i);
        });
      }
      if (this.observers["*"]) {
        var o = [].concat(this.observers["*"]);
        o.forEach(function(u) {
          u.apply(u, [t].concat(i));
        });
      }
    }
  }]), n;
}();
function au() {
  var n, e, t = new Promise(function(r, i) {
    n = r, e = i;
  });
  return t.resolve = n, t.reject = e, t;
}
function Fp(n) {
  return n == null ? "" : "" + n;
}
function pR(n, e, t) {
  n.forEach(function(r) {
    e[r] && (t[r] = e[r]);
  });
}
function Fy(n, e, t) {
  function r(o) {
    return o && o.indexOf("###") > -1 ? o.replace(/###/g, ".") : o;
  }
  function i() {
    return !n || typeof n == "string";
  }
  for (var s = typeof e != "string" ? [].concat(e) : e.split("."); s.length > 1; ) {
    if (i())
      return {};
    var a = r(s.shift());
    !n[a] && t && (n[a] = new t()), n = n[a];
  }
  return i() ? {} : {
    obj: n,
    k: r(s.shift())
  };
}
function jx(n, e, t) {
  var r = Fy(n, e, Object), i = r.obj, s = r.k;
  i[s] = t;
}
function hR(n, e, t, r) {
  var i = Fy(n, e, Object), s = i.obj, a = i.k;
  s[a] = s[a] || [], r && (s[a] = s[a].concat(t)), r || s[a].push(t);
}
function wd(n, e) {
  var t = Fy(n, e), r = t.obj, i = t.k;
  if (r)
    return r[i];
}
function Vx(n, e, t) {
  var r = wd(n, t);
  return r !== void 0 ? r : wd(e, t);
}
function sT(n, e, t) {
  for (var r in e)
    r in n ? typeof n[r] == "string" || n[r] instanceof String || typeof e[r] == "string" || e[r] instanceof String ? t && (n[r] = e[r]) : sT(n[r], e[r], t) : n[r] = e[r];
  return n;
}
function Wa(n) {
  return n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var yR = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function mR(n) {
  return typeof n == "string" ? n.replace(/[&<>"'\/]/g, function(e) {
    return yR[e];
  }) : n;
}
var bR = /* @__PURE__ */ function(n) {
  xf(e, n);
  function e(t) {
    var r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return qi(this, e), r = il(this, _o(e).call(this)), Ts.call(wa(r)), r.data = t || {}, r.options = i, r.options.keySeparator === void 0 && (r.options.keySeparator = "."), r;
  }
  return Wi(e, [{
    key: "addNamespaces",
    value: function(r) {
      this.options.ns.indexOf(r) < 0 && this.options.ns.push(r);
    }
  }, {
    key: "removeNamespaces",
    value: function(r) {
      var i = this.options.ns.indexOf(r);
      i > -1 && this.options.ns.splice(i, 1);
    }
  }, {
    key: "getResource",
    value: function(r, i, s) {
      var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, o = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator, u = [r, i];
      return s && typeof s != "string" && (u = u.concat(s)), s && typeof s == "string" && (u = u.concat(o ? s.split(o) : s)), r.indexOf(".") > -1 && (u = r.split(".")), wd(this.data, u);
    }
  }, {
    key: "addResource",
    value: function(r, i, s, a) {
      var o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, u = this.options.keySeparator;
      u === void 0 && (u = ".");
      var l = [r, i];
      s && (l = l.concat(u ? s.split(u) : s)), r.indexOf(".") > -1 && (l = r.split("."), a = i, i = l[1]), this.addNamespaces(i), jx(this.data, l, a), o.silent || this.emit("added", r, i, s, a);
    }
  }, {
    key: "addResources",
    value: function(r, i, s) {
      var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var o in s)
        (typeof s[o] == "string" || Object.prototype.toString.apply(s[o]) === "[object Array]") && this.addResource(r, i, o, s[o], {
          silent: !0
        });
      a.silent || this.emit("added", r, i, s);
    }
  }, {
    key: "addResourceBundle",
    value: function(r, i, s, a, o) {
      var u = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, l = [r, i];
      r.indexOf(".") > -1 && (l = r.split("."), a = s, s = i, i = l[1]), this.addNamespaces(i);
      var d = wd(this.data, l) || {};
      a ? sT(d, s, o) : d = $n({}, d, s), jx(this.data, l, d), u.silent || this.emit("added", r, i, s);
    }
  }, {
    key: "removeResourceBundle",
    value: function(r, i) {
      this.hasResourceBundle(r, i) && delete this.data[r][i], this.removeNamespaces(i), this.emit("removed", r, i);
    }
  }, {
    key: "hasResourceBundle",
    value: function(r, i) {
      return this.getResource(r, i) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(r, i) {
      return i || (i = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? $n({}, {}, this.getResource(r, i)) : this.getResource(r, i);
    }
  }, {
    key: "getDataByLanguage",
    value: function(r) {
      return this.data[r];
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), e;
}(Ts), aT = {
  processors: {},
  addPostProcessor: function(e) {
    this.processors[e.name] = e;
  },
  handle: function(e, t, r, i, s) {
    var a = this;
    return e.forEach(function(o) {
      a.processors[o] && (t = a.processors[o].process(t, r, i, s));
    }), t;
  }
}, zx = /* @__PURE__ */ function(n) {
  xf(e, n);
  function e(t) {
    var r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return qi(this, e), r = il(this, _o(e).call(this)), Ts.call(wa(r)), pR(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, wa(r)), r.options = i, r.options.keySeparator === void 0 && (r.options.keySeparator = "."), r.logger = Ai.create("translator"), r;
  }
  return Wi(e, [{
    key: "changeLanguage",
    value: function(r) {
      r && (this.language = r);
    }
  }, {
    key: "exists",
    value: function(r) {
      var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, s = this.resolve(r, i);
      return s && s.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(r, i) {
      var s = i.nsSeparator || this.options.nsSeparator;
      s === void 0 && (s = ":");
      var a = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, o = i.ns || this.options.defaultNS;
      if (s && r.indexOf(s) > -1) {
        var u = r.split(s);
        (s !== a || s === a && this.options.ns.indexOf(u[0]) > -1) && (o = u.shift()), r = u.join(a);
      }
      return typeof o == "string" && (o = [o]), {
        key: r,
        namespaces: o
      };
    }
  }, {
    key: "translate",
    value: function(r, i) {
      var s = this;
      if (Dr(i) !== "object" && this.options.overloadTranslationOptionHandler && (i = this.options.overloadTranslationOptionHandler(arguments)), i || (i = {}), r == null)
        return "";
      Array.isArray(r) || (r = [String(r)]);
      var a = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, o = this.extractFromKey(r[r.length - 1], i), u = o.key, l = o.namespaces, d = l[l.length - 1], p = i.lng || this.language, m = i.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (p && p.toLowerCase() === "cimode") {
        if (m) {
          var w = i.nsSeparator || this.options.nsSeparator;
          return d + w + u;
        }
        return u;
      }
      var x = this.resolve(r, i), T = x && x.res, A = x && x.usedKey || u, M = x && x.exactUsedKey || u, I = Object.prototype.toString.apply(T), B = ["[object Number]", "[object Function]", "[object RegExp]"], k = i.joinArrays !== void 0 ? i.joinArrays : this.options.joinArrays, N = !this.i18nFormat || this.i18nFormat.handleAsObject, U = typeof T != "string" && typeof T != "boolean" && typeof T != "number";
      if (N && T && U && B.indexOf(I) < 0 && !(typeof k == "string" && I === "[object Array]")) {
        if (!i.returnObjects && !this.options.returnObjects)
          return this.logger.warn("accessing an object - but returnObjects options is not enabled!"), this.options.returnedObjectHandler ? this.options.returnedObjectHandler(A, T, i) : "key '".concat(u, " (").concat(this.language, ")' returned an object instead of string.");
        if (a) {
          var W = I === "[object Array]", G = W ? [] : {}, Y = W ? M : A;
          for (var ue in T)
            if (Object.prototype.hasOwnProperty.call(T, ue)) {
              var K = "".concat(Y).concat(a).concat(ue);
              G[ue] = this.translate(K, $n({}, i, {
                joinArrays: !1,
                ns: l
              })), G[ue] === K && (G[ue] = T[ue]);
            }
          T = G;
        }
      } else if (N && typeof k == "string" && I === "[object Array]")
        T = T.join(k), T && (T = this.extendTranslation(T, r, i));
      else {
        var le = !1, C = !1;
        if (!this.isValidLookup(T) && i.defaultValue !== void 0) {
          if (le = !0, i.count !== void 0) {
            var c = this.pluralResolver.getSuffix(p, i.count);
            T = i["defaultValue".concat(c)];
          }
          T || (T = i.defaultValue);
        }
        this.isValidLookup(T) || (C = !0, T = u);
        var h = i.defaultValue && i.defaultValue !== T && this.options.updateMissing;
        if (C || le || h) {
          this.logger.log(h ? "updateKey" : "missingKey", p, d, u, h ? i.defaultValue : T);
          var g = [], E = this.languageUtils.getFallbackCodes(this.options.fallbackLng, i.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && E && E[0])
            for (var S = 0; S < E.length; S++)
              g.push(E[S]);
          else
            this.options.saveMissingTo === "all" ? g = this.languageUtils.toResolveHierarchy(i.lng || this.language) : g.push(i.lng || this.language);
          var _ = function(f, v) {
            s.options.missingKeyHandler ? s.options.missingKeyHandler(f, d, v, h ? i.defaultValue : T, h, i) : s.backendConnector && s.backendConnector.saveMissing && s.backendConnector.saveMissing(f, d, v, h ? i.defaultValue : T, h, i), s.emit("missingKey", f, d, v, T);
          };
          if (this.options.saveMissing) {
            var P = i.count !== void 0 && typeof i.count != "string";
            this.options.saveMissingPlurals && P ? g.forEach(function(b) {
              var f = s.pluralResolver.getPluralFormsOfKey(b, u);
              f.forEach(function(v) {
                return _([b], v);
              });
            }) : _(g, u);
          }
        }
        T = this.extendTranslation(T, r, i, x), C && T === u && this.options.appendNamespaceToMissingKey && (T = "".concat(d, ":").concat(u)), C && this.options.parseMissingKeyHandler && (T = this.options.parseMissingKeyHandler(T));
      }
      return T;
    }
  }, {
    key: "extendTranslation",
    value: function(r, i, s, a) {
      var o = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        r = this.i18nFormat.parse(r, s, a.usedLng, a.usedNS, a.usedKey, {
          resolved: a
        });
      else if (!s.skipInterpolation) {
        s.interpolation && this.interpolator.init($n({}, s, {
          interpolation: $n({}, this.options.interpolation, s.interpolation)
        }));
        var u = s.replace && typeof s.replace != "string" ? s.replace : s;
        this.options.interpolation.defaultVariables && (u = $n({}, this.options.interpolation.defaultVariables, u)), r = this.interpolator.interpolate(r, u, s.lng || this.language, s), s.nest !== !1 && (r = this.interpolator.nest(r, function() {
          return o.translate.apply(o, arguments);
        }, s)), s.interpolation && this.interpolator.reset();
      }
      var l = s.postProcess || this.options.postProcess, d = typeof l == "string" ? [l] : l;
      return r != null && d && d.length && s.applyPostProcessor !== !1 && (r = aT.handle(d, r, i, this.options && this.options.postProcessPassResolved ? $n({
        i18nResolved: a
      }, s) : s, this)), r;
    }
  }, {
    key: "resolve",
    value: function(r) {
      var i = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a, o, u, l, d;
      return typeof r == "string" && (r = [r]), r.forEach(function(p) {
        if (!i.isValidLookup(a)) {
          var m = i.extractFromKey(p, s), w = m.key;
          o = w;
          var x = m.namespaces;
          i.options.fallbackNS && (x = x.concat(i.options.fallbackNS));
          var T = s.count !== void 0 && typeof s.count != "string", A = s.context !== void 0 && typeof s.context == "string" && s.context !== "", M = s.lngs ? s.lngs : i.languageUtils.toResolveHierarchy(s.lng || i.language, s.fallbackLng);
          x.forEach(function(I) {
            i.isValidLookup(a) || (d = I, i.utils && i.utils.hasLoadedNamespace && !i.utils.hasLoadedNamespace(d) && i.logger.warn('key "'.concat(o, '" for namespace "').concat(d, `" won't get resolved as namespace was not yet loaded`), "This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"), M.forEach(function(B) {
              if (!i.isValidLookup(a)) {
                l = B;
                var k = w, N = [k];
                if (i.i18nFormat && i.i18nFormat.addLookupKeys)
                  i.i18nFormat.addLookupKeys(N, w, B, I, s);
                else {
                  var U;
                  T && (U = i.pluralResolver.getSuffix(B, s.count)), T && A && N.push(k + U), A && N.push(k += "".concat(i.options.contextSeparator).concat(s.context)), T && N.push(k += U);
                }
                for (var W; W = N.pop(); )
                  i.isValidLookup(a) || (u = W, a = i.getResource(B, I, W, s));
              }
            }));
          });
        }
      }), {
        res: a,
        usedKey: o,
        exactUsedKey: u,
        usedLng: l,
        usedNS: d
      };
    }
  }, {
    key: "isValidLookup",
    value: function(r) {
      return r !== void 0 && !(!this.options.returnNull && r === null) && !(!this.options.returnEmptyString && r === "");
    }
  }, {
    key: "getResource",
    value: function(r, i, s) {
      var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(r, i, s, a) : this.resourceStore.getResource(r, i, s, a);
    }
  }]), e;
}(Ts);
function Lp(n) {
  return n.charAt(0).toUpperCase() + n.slice(1);
}
var gR = /* @__PURE__ */ function() {
  function n(e) {
    qi(this, n), this.options = e, this.whitelist = this.options.whitelist || !1, this.logger = Ai.create("languageUtils");
  }
  return Wi(n, [{
    key: "getScriptPartFromCode",
    value: function(t) {
      if (!t || t.indexOf("-") < 0)
        return null;
      var r = t.split("-");
      return r.length === 2 ? null : (r.pop(), this.formatLanguageCode(r.join("-")));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(t) {
      if (!t || t.indexOf("-") < 0)
        return t;
      var r = t.split("-");
      return this.formatLanguageCode(r[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(t) {
      if (typeof t == "string" && t.indexOf("-") > -1) {
        var r = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], i = t.split("-");
        return this.options.lowerCaseLng ? i = i.map(function(s) {
          return s.toLowerCase();
        }) : i.length === 2 ? (i[0] = i[0].toLowerCase(), i[1] = i[1].toUpperCase(), r.indexOf(i[1].toLowerCase()) > -1 && (i[1] = Lp(i[1].toLowerCase()))) : i.length === 3 && (i[0] = i[0].toLowerCase(), i[1].length === 2 && (i[1] = i[1].toUpperCase()), i[0] !== "sgn" && i[2].length === 2 && (i[2] = i[2].toUpperCase()), r.indexOf(i[1].toLowerCase()) > -1 && (i[1] = Lp(i[1].toLowerCase())), r.indexOf(i[2].toLowerCase()) > -1 && (i[2] = Lp(i[2].toLowerCase()))), i.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
    }
  }, {
    key: "isWhitelisted",
    value: function(t) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitWhitelist) && (t = this.getLanguagePartFromCode(t)), !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(t) > -1;
    }
  }, {
    key: "getFallbackCodes",
    value: function(t, r) {
      if (!t)
        return [];
      if (typeof t == "string" && (t = [t]), Object.prototype.toString.apply(t) === "[object Array]")
        return t;
      if (!r)
        return t.default || [];
      var i = t[r];
      return i || (i = t[this.getScriptPartFromCode(r)]), i || (i = t[this.formatLanguageCode(r)]), i || (i = t.default), i || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(t, r) {
      var i = this, s = this.getFallbackCodes(r || this.options.fallbackLng || [], t), a = [], o = function(l) {
        l && (i.isWhitelisted(l) ? a.push(l) : i.logger.warn("rejecting non-whitelisted language code: ".concat(l)));
      };
      return typeof t == "string" && t.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(t))) : typeof t == "string" && o(this.formatLanguageCode(t)), s.forEach(function(u) {
        a.indexOf(u) < 0 && o(i.formatLanguageCode(u));
      }), a;
    }
  }]), n;
}(), xR = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "id", "ja", "jbo", "ka", "kk", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he"],
  nr: [1, 2, 20, 21],
  fc: 22
}], vR = {
  1: function(e) {
    return +(e > 1);
  },
  2: function(e) {
    return +(e != 1);
  },
  3: function(e) {
    return 0;
  },
  4: function(e) {
    return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
  },
  5: function(e) {
    return e === 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5;
  },
  6: function(e) {
    return e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2;
  },
  7: function(e) {
    return e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
  },
  8: function(e) {
    return e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3;
  },
  9: function(e) {
    return +(e >= 2);
  },
  10: function(e) {
    return e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4;
  },
  11: function(e) {
    return e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3;
  },
  12: function(e) {
    return +(e % 10 != 1 || e % 100 == 11);
  },
  13: function(e) {
    return +(e !== 0);
  },
  14: function(e) {
    return e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3;
  },
  15: function(e) {
    return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
  },
  16: function(e) {
    return e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2;
  },
  17: function(e) {
    return e == 1 || e % 10 == 1 ? 0 : 1;
  },
  18: function(e) {
    return e == 0 ? 0 : e == 1 ? 1 : 2;
  },
  19: function(e) {
    return e == 1 ? 0 : e === 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3;
  },
  20: function(e) {
    return e == 1 ? 0 : e === 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2;
  },
  21: function(e) {
    return e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0;
  },
  22: function(e) {
    return e === 1 ? 0 : e === 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3;
  }
};
function wR() {
  var n = {};
  return xR.forEach(function(e) {
    e.lngs.forEach(function(t) {
      n[t] = {
        numbers: e.nr,
        plurals: vR[e.fc]
      };
    });
  }), n;
}
var TR = /* @__PURE__ */ function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    qi(this, n), this.languageUtils = e, this.options = t, this.logger = Ai.create("pluralResolver"), this.rules = wR();
  }
  return Wi(n, [{
    key: "addRule",
    value: function(t, r) {
      this.rules[t] = r;
    }
  }, {
    key: "getRule",
    value: function(t) {
      return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)];
    }
  }, {
    key: "needsPlural",
    value: function(t) {
      var r = this.getRule(t);
      return r && r.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(t, r) {
      var i = this, s = [], a = this.getRule(t);
      return a && a.numbers.forEach(function(o) {
        var u = i.getSuffix(t, o);
        s.push("".concat(r).concat(u));
      }), s;
    }
  }, {
    key: "getSuffix",
    value: function(t, r) {
      var i = this, s = this.getRule(t);
      if (s) {
        var a = s.noAbs ? s.plurals(r) : s.plurals(Math.abs(r)), o = s.numbers[a];
        this.options.simplifyPluralSuffix && s.numbers.length === 2 && s.numbers[0] === 1 && (o === 2 ? o = "plural" : o === 1 && (o = ""));
        var u = function() {
          return i.options.prepend && o.toString() ? i.options.prepend + o.toString() : o.toString();
        };
        return this.options.compatibilityJSON === "v1" ? o === 1 ? "" : typeof o == "number" ? "_plural_".concat(o.toString()) : u() : (
          /* v2 */
          this.options.compatibilityJSON === "v2" || /* v3 - gettext index */
          this.options.simplifyPluralSuffix && s.numbers.length === 2 && s.numbers[0] === 1 ? u() : this.options.prepend && a.toString() ? this.options.prepend + a.toString() : a.toString()
        );
      }
      return this.logger.warn("no plural rule found for: ".concat(t)), "";
    }
  }]), n;
}(), AR = /* @__PURE__ */ function() {
  function n() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    qi(this, n), this.logger = Ai.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || function(t) {
      return t;
    }, this.init(e);
  }
  return Wi(n, [{
    key: "init",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      t.interpolation || (t.interpolation = {
        escapeValue: !0
      });
      var r = t.interpolation;
      this.escape = r.escape !== void 0 ? r.escape : mR, this.escapeValue = r.escapeValue !== void 0 ? r.escapeValue : !0, this.useRawValueToEscape = r.useRawValueToEscape !== void 0 ? r.useRawValueToEscape : !1, this.prefix = r.prefix ? Wa(r.prefix) : r.prefixEscaped || "{{", this.suffix = r.suffix ? Wa(r.suffix) : r.suffixEscaped || "}}", this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ",", this.unescapePrefix = r.unescapeSuffix ? "" : r.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : r.unescapeSuffix || "", this.nestingPrefix = r.nestingPrefix ? Wa(r.nestingPrefix) : r.nestingPrefixEscaped || Wa("$t("), this.nestingSuffix = r.nestingSuffix ? Wa(r.nestingSuffix) : r.nestingSuffixEscaped || Wa(")"), this.maxReplaces = r.maxReplaces ? r.maxReplaces : 1e3, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var t = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(t, "g");
      var r = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(r, "g");
      var i = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(i, "g");
    }
  }, {
    key: "interpolate",
    value: function(t, r, i, s) {
      var a = this, o, u, l, d = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function p(A) {
        return A.replace(/\$/g, "$$$$");
      }
      var m = function(M) {
        if (M.indexOf(a.formatSeparator) < 0)
          return Vx(r, d, M);
        var I = M.split(a.formatSeparator), B = I.shift().trim(), k = I.join(a.formatSeparator).trim();
        return a.format(Vx(r, d, B), k, i);
      };
      this.resetRegExp();
      var w = s && s.missingInterpolationHandler || this.options.missingInterpolationHandler;
      for (l = 0; o = this.regexpUnescape.exec(t); ) {
        if (u = m(o[1].trim()), u === void 0)
          if (typeof w == "function") {
            var x = w(t, o, s);
            u = typeof x == "string" ? x : "";
          } else
            this.logger.warn("missed to pass in variable ".concat(o[1], " for interpolating ").concat(t)), u = "";
        else
          typeof u != "string" && !this.useRawValueToEscape && (u = Fp(u));
        if (t = t.replace(o[0], p(u)), this.regexpUnescape.lastIndex = 0, l++, l >= this.maxReplaces)
          break;
      }
      for (l = 0; o = this.regexp.exec(t); ) {
        if (u = m(o[1].trim()), u === void 0)
          if (typeof w == "function") {
            var T = w(t, o, s);
            u = typeof T == "string" ? T : "";
          } else
            this.logger.warn("missed to pass in variable ".concat(o[1], " for interpolating ").concat(t)), u = "";
        else
          typeof u != "string" && !this.useRawValueToEscape && (u = Fp(u));
        if (u = this.escapeValue ? p(this.escape(u)) : p(u), t = t.replace(o[0], u), this.regexp.lastIndex = 0, l++, l >= this.maxReplaces)
          break;
      }
      return t;
    }
  }, {
    key: "nest",
    value: function(t, r) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s, a, o = $n({}, i);
      o.applyPostProcessor = !1, delete o.defaultValue;
      function u(l, d) {
        if (l.indexOf(",") < 0)
          return l;
        var p = l.split(",");
        l = p.shift();
        var m = p.join(",");
        m = this.interpolate(m, o), m = m.replace(/'/g, '"');
        try {
          o = JSON.parse(m), d && (o = $n({}, d, o));
        } catch (w) {
          this.logger.error("failed parsing options string in nesting for key ".concat(l), w);
        }
        return delete o.defaultValue, l;
      }
      for (; s = this.nestingRegexp.exec(t); ) {
        if (a = r(u.call(this, s[1].trim(), o), o), a && s[0] === t && typeof a != "string")
          return a;
        typeof a != "string" && (a = Fp(a)), a || (this.logger.warn("missed to resolve ".concat(s[1], " for nesting ").concat(t)), a = ""), t = t.replace(s[0], a), this.regexp.lastIndex = 0;
      }
      return t;
    }
  }]), n;
}();
function ER(n, e) {
  for (var t = n.indexOf(e); t !== -1; )
    n.splice(t, 1), t = n.indexOf(e);
}
var SR = /* @__PURE__ */ function(n) {
  xf(e, n);
  function e(t, r, i) {
    var s, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return qi(this, e), s = il(this, _o(e).call(this)), Ts.call(wa(s)), s.backend = t, s.store = r, s.services = i, s.languageUtils = i.languageUtils, s.options = a, s.logger = Ai.create("backendConnector"), s.state = {}, s.queue = [], s.backend && s.backend.init && s.backend.init(i, a.backend, a), s;
  }
  return Wi(e, [{
    key: "queueLoad",
    value: function(r, i, s, a) {
      var o = this, u = [], l = [], d = [], p = [];
      return r.forEach(function(m) {
        var w = !0;
        i.forEach(function(x) {
          var T = "".concat(m, "|").concat(x);
          !s.reload && o.store.hasResourceBundle(m, x) ? o.state[T] = 2 : o.state[T] < 0 || (o.state[T] === 1 ? l.indexOf(T) < 0 && l.push(T) : (o.state[T] = 1, w = !1, l.indexOf(T) < 0 && l.push(T), u.indexOf(T) < 0 && u.push(T), p.indexOf(x) < 0 && p.push(x)));
        }), w || d.push(m);
      }), (u.length || l.length) && this.queue.push({
        pending: l,
        loaded: {},
        errors: [],
        callback: a
      }), {
        toLoad: u,
        pending: l,
        toLoadLanguages: d,
        toLoadNamespaces: p
      };
    }
  }, {
    key: "loaded",
    value: function(r, i, s) {
      var a = r.split("|"), o = Ux(a, 2), u = o[0], l = o[1];
      i && this.emit("failedLoading", u, l, i), s && this.store.addResourceBundle(u, l, s), this.state[r] = i ? -1 : 2;
      var d = {};
      this.queue.forEach(function(p) {
        hR(p.loaded, [u], l), ER(p.pending, r), i && p.errors.push(i), p.pending.length === 0 && !p.done && (Object.keys(p.loaded).forEach(function(m) {
          d[m] || (d[m] = []), p.loaded[m].length && p.loaded[m].forEach(function(w) {
            d[m].indexOf(w) < 0 && d[m].push(w);
          });
        }), p.done = !0, p.errors.length ? p.callback(p.errors) : p.callback());
      }), this.emit("loaded", d), this.queue = this.queue.filter(function(p) {
        return !p.done;
      });
    }
  }, {
    key: "read",
    value: function(r, i, s) {
      var a = this, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 250, l = arguments.length > 5 ? arguments[5] : void 0;
      return r.length ? this.backend[s](r, i, function(d, p) {
        if (d && p && o < 5) {
          setTimeout(function() {
            a.read.call(a, r, i, s, o + 1, u * 2, l);
          }, u);
          return;
        }
        l(d, p);
      }) : l(null, {});
    }
    /* eslint consistent-return: 0 */
  }, {
    key: "prepareLoading",
    value: function(r, i) {
      var s = this, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), o && o();
      typeof r == "string" && (r = this.languageUtils.toResolveHierarchy(r)), typeof i == "string" && (i = [i]);
      var u = this.queueLoad(r, i, a, o);
      if (!u.toLoad.length)
        return u.pending.length || o(), null;
      u.toLoad.forEach(function(l) {
        s.loadOne(l);
      });
    }
  }, {
    key: "load",
    value: function(r, i, s) {
      this.prepareLoading(r, i, {}, s);
    }
  }, {
    key: "reload",
    value: function(r, i, s) {
      this.prepareLoading(r, i, {
        reload: !0
      }, s);
    }
  }, {
    key: "loadOne",
    value: function(r) {
      var i = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", a = r.split("|"), o = Ux(a, 2), u = o[0], l = o[1];
      this.read(u, l, "read", null, null, function(d, p) {
        d && i.logger.warn("".concat(s, "loading namespace ").concat(l, " for language ").concat(u, " failed"), d), !d && p && i.logger.log("".concat(s, "loaded namespace ").concat(l, " for language ").concat(u), p), i.loaded(r, d, p);
      });
    }
  }, {
    key: "saveMissing",
    value: function(r, i, s, a, o) {
      var u = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(i)) {
        this.logger.warn('did not save key "'.concat(s, '" for namespace "').concat(i, '" as the namespace was not yet loaded'), "This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      this.backend && this.backend.create && this.backend.create(
        r,
        i,
        s,
        a,
        null,
        $n({}, u, {
          isUpdate: o
        })
      ), !(!r || !r[0]) && this.store.addResource(r[0], i, s, a);
    }
  }]), e;
}(Ts);
function CR() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    // string or array of namespaces
    whitelist: !1,
    // array with whitelisted languages
    nonExplicitWhitelist: !1,
    load: "all",
    // | currentOnly | languageOnly
    preload: !1,
    // array with preload languages
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    // allow bundling certain languages that are not remotely fetched
    saveMissing: !1,
    // enable to send missing values
    updateMissing: !1,
    // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
    saveMissingTo: "fallback",
    // 'current' || 'all'
    saveMissingPlurals: !0,
    // will save all forms not only singular key
    missingKeyHandler: !1,
    // function(lng, ns, key, fallbackValue) -> override if prefer on handling
    missingInterpolationHandler: !1,
    // function(str, match)
    postProcess: !1,
    // string or array of postProcessor names
    postProcessPassResolved: !1,
    // pass resolved object into 'options.i18nResolved' for postprocessor
    returnNull: !0,
    // allows null value as valid translation
    returnEmptyString: !0,
    // allows empty string value as valid translation
    returnObjects: !1,
    joinArrays: !1,
    // or string to join array
    returnedObjectHandler: !1,
    // function(key, value, options) triggered if key returns object but returnObjects is set to false
    parseMissingKeyHandler: !1,
    // function(key) parsed a key that was not found in t() before returning
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      var t = {};
      if (Dr(e[1]) === "object" && (t = e[1]), typeof e[1] == "string" && (t.defaultValue = e[1]), typeof e[2] == "string" && (t.tDescription = e[2]), Dr(e[2]) === "object" || Dr(e[3]) === "object") {
        var r = e[3] || e[2];
        Object.keys(r).forEach(function(i) {
          t[i] = r[i];
        });
      }
      return t;
    },
    interpolation: {
      escapeValue: !0,
      format: function(e, t, r) {
        return e;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      // prefixEscaped: '{{',
      // suffixEscaped: '}}',
      // unescapeSuffix: '',
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      // nestingPrefixEscaped: '$t(',
      // nestingSuffixEscaped: ')',
      // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
      maxReplaces: 1e3
      // max replaces to prevent endless loop
    }
  };
}
function Gx(n) {
  return typeof n.ns == "string" && (n.ns = [n.ns]), typeof n.fallbackLng == "string" && (n.fallbackLng = [n.fallbackLng]), typeof n.fallbackNS == "string" && (n.fallbackNS = [n.fallbackNS]), n.whitelist && n.whitelist.indexOf("cimode") < 0 && (n.whitelist = n.whitelist.concat(["cimode"])), n;
}
function fc() {
}
var _R = /* @__PURE__ */ function(n) {
  xf(e, n);
  function e() {
    var t, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = arguments.length > 1 ? arguments[1] : void 0;
    if (qi(this, e), t = il(this, _o(e).call(this)), Ts.call(wa(t)), t.options = Gx(r), t.services = {}, t.logger = Ai, t.modules = {
      external: []
    }, i && !t.isInitialized && !r.isClone) {
      if (!t.options.initImmediate)
        return t.init(r, i), il(t, wa(t));
      setTimeout(function() {
        t.init(r, i);
      }, 0);
    }
    return t;
  }
  return Wi(e, [{
    key: "init",
    value: function() {
      var r = this, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
      typeof i == "function" && (s = i, i = {}), this.options = $n({}, CR(), this.options, Gx(i)), this.format = this.options.interpolation.format, s || (s = fc);
      function a(m) {
        return m ? typeof m == "function" ? new m() : m : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? Ai.init(a(this.modules.logger), this.options) : Ai.init(null, this.options);
        var o = new gR(this.options);
        this.store = new bR(this.options.resources, this.options);
        var u = this.services;
        u.logger = Ai, u.resourceStore = this.store, u.languageUtils = o, u.pluralResolver = new TR(o, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), u.interpolator = new AR(this.options), u.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, u.backendConnector = new SR(a(this.modules.backend), u.resourceStore, u, this.options), u.backendConnector.on("*", function(m) {
          for (var w = arguments.length, x = new Array(w > 1 ? w - 1 : 0), T = 1; T < w; T++)
            x[T - 1] = arguments[T];
          r.emit.apply(r, [m].concat(x));
        }), this.modules.languageDetector && (u.languageDetector = a(this.modules.languageDetector), u.languageDetector.init(u, this.options.detection, this.options)), this.modules.i18nFormat && (u.i18nFormat = a(this.modules.i18nFormat), u.i18nFormat.init && u.i18nFormat.init(this)), this.translator = new zx(this.services, this.options), this.translator.on("*", function(m) {
          for (var w = arguments.length, x = new Array(w > 1 ? w - 1 : 0), T = 1; T < w; T++)
            x[T - 1] = arguments[T];
          r.emit.apply(r, [m].concat(x));
        }), this.modules.external.forEach(function(m) {
          m.init && m.init(r);
        });
      }
      var l = ["getResource", "addResource", "addResources", "addResourceBundle", "removeResourceBundle", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      l.forEach(function(m) {
        r[m] = function() {
          var w;
          return (w = r.store)[m].apply(w, arguments);
        };
      });
      var d = au(), p = function() {
        r.changeLanguage(r.options.lng, function(w, x) {
          r.isInitialized = !0, r.logger.log("initialized", r.options), r.emit("initialized", r.options), d.resolve(x), s(w, x);
        });
      };
      return this.options.resources || !this.options.initImmediate ? p() : setTimeout(p, 0), d;
    }
    /* eslint consistent-return: 0 */
  }, {
    key: "loadResources",
    value: function() {
      var r = this, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : fc;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (this.language && this.language.toLowerCase() === "cimode")
          return i();
        var s = [], a = function(l) {
          if (l) {
            var d = r.services.languageUtils.toResolveHierarchy(l);
            d.forEach(function(p) {
              s.indexOf(p) < 0 && s.push(p);
            });
          }
        };
        if (this.language)
          a(this.language);
        else {
          var o = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          o.forEach(function(u) {
            return a(u);
          });
        }
        this.options.preload && this.options.preload.forEach(function(u) {
          return a(u);
        }), this.services.backendConnector.load(s, this.options.ns, i);
      } else
        i(null);
    }
  }, {
    key: "reloadResources",
    value: function(r, i, s) {
      var a = au();
      return r || (r = this.languages), i || (i = this.options.ns), s || (s = fc), this.services.backendConnector.reload(r, i, function(o) {
        a.resolve(), s(o);
      }), a;
    }
  }, {
    key: "use",
    value: function(r) {
      return r.type === "backend" && (this.modules.backend = r), (r.type === "logger" || r.log && r.warn && r.error) && (this.modules.logger = r), r.type === "languageDetector" && (this.modules.languageDetector = r), r.type === "i18nFormat" && (this.modules.i18nFormat = r), r.type === "postProcessor" && aT.addPostProcessor(r), r.type === "3rdParty" && this.modules.external.push(r), this;
    }
  }, {
    key: "changeLanguage",
    value: function(r, i) {
      var s = this, a = au();
      this.emit("languageChanging", r);
      var o = function(d, p) {
        s.translator.changeLanguage(p), p && (s.emit("languageChanged", p), s.logger.log("languageChanged", p)), a.resolve(function() {
          return s.t.apply(s, arguments);
        }), i && i(d, function() {
          return s.t.apply(s, arguments);
        });
      }, u = function(d) {
        d && (s.language = d, s.languages = s.services.languageUtils.toResolveHierarchy(d), s.translator.language || s.translator.changeLanguage(d), s.services.languageDetector && s.services.languageDetector.cacheUserLanguage(d)), s.loadResources(function(p) {
          o(p, d);
        });
      };
      return !r && this.services.languageDetector && !this.services.languageDetector.async ? u(this.services.languageDetector.detect()) : !r && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(u) : u(r), a;
    }
  }, {
    key: "getFixedT",
    value: function(r, i) {
      var s = this, a = function o(u, l) {
        var d;
        if (Dr(l) !== "object") {
          for (var p = arguments.length, m = new Array(p > 2 ? p - 2 : 0), w = 2; w < p; w++)
            m[w - 2] = arguments[w];
          d = s.options.overloadTranslationOptionHandler([u, l].concat(m));
        } else
          d = $n({}, l);
        return d.lng = d.lng || o.lng, d.lngs = d.lngs || o.lngs, d.ns = d.ns || o.ns, s.t(u, d);
      };
      return typeof r == "string" ? a.lng = r : a.lngs = r, a.ns = i, a;
    }
  }, {
    key: "t",
    value: function() {
      var r;
      return this.translator && (r = this.translator).translate.apply(r, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var r;
      return this.translator && (r = this.translator).exists.apply(r, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(r) {
      this.options.defaultNS = r;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(r) {
      var i = this;
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var s = this.languages[0], a = this.options ? this.options.fallbackLng : !1, o = this.languages[this.languages.length - 1];
      if (s.toLowerCase() === "cimode")
        return !0;
      var u = function(d, p) {
        var m = i.services.backendConnector.state["".concat(d, "|").concat(p)];
        return m === -1 || m === 2;
      };
      return !!(this.hasResourceBundle(s, r) || !this.services.backendConnector.backend || u(s, r) && (!a || u(o, r)));
    }
  }, {
    key: "loadNamespaces",
    value: function(r, i) {
      var s = this, a = au();
      return this.options.ns ? (typeof r == "string" && (r = [r]), r.forEach(function(o) {
        s.options.ns.indexOf(o) < 0 && s.options.ns.push(o);
      }), this.loadResources(function(o) {
        a.resolve(), i && i(o);
      }), a) : (i && i(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(r, i) {
      var s = au();
      typeof r == "string" && (r = [r]);
      var a = this.options.preload || [], o = r.filter(function(u) {
        return a.indexOf(u) < 0;
      });
      return o.length ? (this.options.preload = a.concat(o), this.loadResources(function(u) {
        s.resolve(), i && i(u);
      }), s) : (i && i(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(r) {
      if (r || (r = this.languages && this.languages.length > 0 ? this.languages[0] : this.language), !r)
        return "rtl";
      var i = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
      return i.indexOf(this.services.languageUtils.getLanguagePartFromCode(r)) >= 0 ? "rtl" : "ltr";
    }
    /* eslint class-methods-use-this: 0 */
  }, {
    key: "createInstance",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = arguments.length > 1 ? arguments[1] : void 0;
      return new e(r, i);
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var r = this, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fc, a = $n({}, this.options, i, {
        isClone: !0
      }), o = new e(a), u = ["store", "services", "language"];
      return u.forEach(function(l) {
        o[l] = r[l];
      }), o.translator = new zx(o.services, o.options), o.translator.on("*", function(l) {
        for (var d = arguments.length, p = new Array(d > 1 ? d - 1 : 0), m = 1; m < d; m++)
          p[m - 1] = arguments[m];
        o.emit.apply(o, [l].concat(p));
      }), o.init(a, s), o.translator.options = o.options, o;
    }
  }]), e;
}(Ts);
new _R();
function On(n, e, t, r) {
  var i = arguments.length, s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, r);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (a = n[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function cs(n, e) {
  return function(t, r) {
    e(t, r, n);
  };
}
const Ta = {
  I18N_EA_CHANNEL: "i18n:locale:changed",
  I18N_SIGNAL: "aurelia-translation-signal",
  RT_SIGNAL: "aurelia-relativetime-signal"
};
var Hx;
(function(n) {
  n.translationValueConverterName = "t", n.dateFormatValueConverterName = "df", n.numberFormatValueConverterName = "nf", n.relativeTimeValueConverterName = "rt";
})(Hx || (Hx = {}));
function Ly(n, e) {
  const t = e.ast.expression;
  if (!(t instanceof Uu)) {
    const r = new Uu(t, n, e.ast.args);
    e.ast.expression = r;
  }
}
let qx = class {
  bind(e, t) {
    Ly("df", t);
  }
};
qx = On([qn("df")], qx);
const MR = /* @__PURE__ */ me.createInterface("I18nInitOptions"), PR = /* @__PURE__ */ me.createInterface("I18nextWrapper");
var Wx;
(function(n) {
  n[n.Second = 1e3] = "Second", n[n.Minute = 6e4] = "Minute", n[n.Hour = 36e5] = "Hour", n[n.Day = 864e5] = "Day", n[n.Week = 6048e5] = "Week", n[n.Month = 2592e6] = "Month", n[n.Year = 31536e6] = "Year";
})(Wx || (Wx = {}));
class RR {
  constructor(e) {
    this.value = void 0;
    const t = /\[([a-z\-, ]*)\]/gi;
    this.attributes = [];
    const r = t.exec(e);
    r && (e = e.replace(r[0], ""), this.attributes = r[1].split(",")), this.key = e;
  }
}
const ja = /* @__PURE__ */ me.createInterface("I18N");
let zh = class {
  constructor(e, t, r, i) {
    this.ea = r, this.i = /* @__PURE__ */ new Set(), this.i18next = e.i18next, this.initPromise = this.h(t), this.u = i;
  }
  evaluate(e, t) {
    const r = e.split(";"), i = [];
    for (const s of r) {
      const a = new RR(s), o = a.key, u = this.tr(o, t);
      this.options.skipTranslationOnMissingKey && u === o ? console.warn(`Couldn't find translation for key: ${o}`) : (a.value = u, i.push(a));
    }
    return i;
  }
  tr(e, t) {
    return this.i18next.t(e, t);
  }
  getLocale() {
    return this.i18next.language;
  }
  async setLocale(e) {
    const r = {
      oldLocale: this.getLocale(),
      newLocale: e
    };
    await this.i18next.changeLanguage(e), this.ea.publish(Ta.I18N_EA_CHANNEL, r), this.i.forEach((i) => i.handleLocaleChange(r)), this.u.dispatchSignal(Ta.I18N_SIGNAL);
  }
  createNumberFormat(e, t) {
    return Intl.NumberFormat(t || this.getLocale(), e);
  }
  nf(e, t, r) {
    return this.createNumberFormat(t, r).format(e);
  }
  createDateTimeFormat(e, t) {
    return Intl.DateTimeFormat(t || this.getLocale(), e);
  }
  df(e, t, r) {
    return this.createDateTimeFormat(t, r).format(e);
  }
  uf(e, t) {
    const r = this.nf(3333.3333333333335, void 0, t);
    let i = r[1];
    const s = r[5];
    i === "." && (i = "\\.");
    const a = e.replace(new RegExp(i, "g"), "").replace(/[^\d.,-]/g, "").replace(s, ".");
    return Number(a);
  }
  createRelativeTimeFormat(e, t) {
    return new Intl.RelativeTimeFormat(t || this.getLocale(), e);
  }
  rt(e, t, r) {
    let i = e.getTime() - this.now();
    const s = this.options.rtEpsilon * (i > 0 ? 1 : 0), a = this.createRelativeTimeFormat(t, r);
    let o = i / 31536e6;
    return Math.abs(o + s) >= 1 ? a.format(Math.round(o), "year") : (o = i / 2592e6, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "month") : (o = i / 6048e5, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "week") : (o = i / 864e5, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "day") : (o = i / 36e5, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "hour") : (o = i / 6e4, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "minute") : (i = Math.abs(i) < 1e3 ? 1e3 : i, o = i / 1e3, a.format(Math.round(o), "second")))))));
  }
  subscribeLocaleChange(e) {
    this.i.add(e);
  }
  now() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  async h(e) {
    const t = {
      lng: "en",
      fallbackLng: ["en"],
      debug: !1,
      plugins: [],
      rtEpsilon: 0.01,
      skipTranslationOnMissingKey: !1
    };
    this.options = {
      ...t,
      ...e
    };
    for (const r of this.options.plugins)
      this.i18next.use(r);
    await this.i18next.init(this.options);
  }
};
On([HE], zh.prototype, "i18next", void 0);
zh = On([cs(0, PR), cs(1, MR), cs(2, Gd), cs(3, Wd)], zh);
let Kx = class {
  constructor(e) {
    this.i18n = e, this.signals = [Ta.I18N_SIGNAL];
  }
  toView(e, t, r) {
    if (!e && e !== 0 || typeof e == "string" && e.trim() === "")
      return e;
    if (typeof e == "string") {
      const i = Number(e), s = new Date(Number.isInteger(i) ? i : e);
      if (isNaN(s.getTime()))
        return e;
      e = s;
    }
    return this.i18n.df(e, t, r);
  }
};
Kx = On([Al("df"), cs(0, ja)], Kx);
let Jx = class {
  bind(e, t) {
    Ly("nf", t);
  }
};
Jx = On([qn("nf")], Jx);
let Qx = class {
  constructor(e) {
    this.i18n = e, this.signals = [Ta.I18N_SIGNAL];
  }
  toView(e, t, r) {
    return typeof e != "number" ? e : this.i18n.nf(e, t, r);
  }
};
Qx = On([Al("nf"), cs(0, ja)], Qx);
let Yx = class {
  bind(e, t) {
    Ly("rt", t);
  }
};
Yx = On([qn("rt")], Yx);
let Xx = class {
  constructor(e) {
    this.i18n = e, this.signals = [Ta.I18N_SIGNAL, Ta.RT_SIGNAL];
  }
  toView(e, t, r) {
    return e instanceof Date ? this.i18n.rt(e, t, r) : e;
  }
};
Xx = On([Al("rt"), cs(0, ja)], Xx);
let Zx = class {
  bind(e, t) {
    const r = t.ast.expression;
    if (!(r instanceof Uu)) {
      const i = new Uu(r, "t", t.ast.args);
      t.ast.expression = i;
    }
  }
};
Zx = On([qn("t")], Zx);
const IR = ["textContent", "innerHTML", "prepend", "append"], OR = /* @__PURE__ */ new Map([["text", "textContent"], ["html", "innerHTML"]]), kR = {
  optional: !0
}, NR = {
  reusable: !1,
  preempt: !0
};
class Bi {
  constructor(e, t, r, i, s) {
    this.isBound = !1, this._ = IR, this.T = null, this.parameter = null, this.boundFn = !1, this.l = t, this.B = e, this.target = s, this.i18n = t.get(ja), this.p = i, this.I = /* @__PURE__ */ new Set(), this.oL = r, this.i18n.subscribeLocaleChange(this), this.C = i.domWriteQueue;
  }
  static create({ parser: e, observerLocator: t, context: r, controller: i, target: s, instruction: a, platform: o, isParameterContext: u }) {
    const l = this.P({
      observerLocator: t,
      context: r,
      controller: i,
      target: s,
      platform: o
    }), d = typeof a.from == "string" ? e.parse(a.from, 16) : a.from;
    if (u)
      l.useParameter(d);
    else {
      const p = d instanceof T0 ? e.parse(d.value, 1) : void 0;
      l.ast = p || d;
    }
  }
  static P({ observerLocator: e, context: t, controller: r, target: i, platform: s }) {
    let a = r.bindings && r.bindings.find((o) => o instanceof Bi && o.target === i);
    return a || (a = new Bi(r, t, e, s, i), r.addBinding(a)), a;
  }
  bind(e) {
    if (!this.isBound) {
      if (!this.ast)
        throw new Error("key expression is missing");
      this.s = e, this.M = this.ast instanceof Mv, this.A = z(this.ast, e, this, this), this.L(), this.parameter?.bind(e), this.updateTranslations(), this.isBound = !0;
    }
  }
  unbind() {
    this.isBound && (dr(this.ast, this.s, this), this.parameter?.unbind(), this.I.clear(), this.T !== null && (this.T.cancel(), this.T = null), this.s = void 0, this.obs.clearAll());
  }
  handleChange(e, t) {
    this.obs.version++, this.A = this.M ? z(this.ast, this.s, this, this) : e, this.obs.clear(), this.L(), this.updateTranslations();
  }
  handleLocaleChange() {
    this.updateTranslations();
  }
  useParameter(e) {
    if (this.parameter != null)
      throw new Error("This translation parameter has already been specified.");
    this.parameter = new $y(this, e, () => this.updateTranslations());
  }
  updateTranslations() {
    const e = this.i18n.evaluate(this.A, this.parameter?.value), t = /* @__PURE__ */ Object.create(null), r = [], i = this.T;
    this.I.clear();
    for (const a of e) {
      const o = a.value, u = this.R(a.attributes);
      for (const l of u)
        if (this.N(l))
          t[l] = o;
        else {
          const d = fo.for(this.target, kR), p = d?.viewModel ? this.oL.getAccessor(d.viewModel, l) : this.oL.getAccessor(this.target, l);
          this.B.state !== 1 && (p.type & 4) > 0 ? r.push(new DR(p, o, this.target, l)) : p.setValue(o, this.target, l), this.I.add(p);
        }
    }
    let s = !1;
    Object.keys(t).length > 0 && (s = this.B.state !== 1, s || this.V(t)), (r.length > 0 || s) && (this.T = this.C.queueTask(() => {
      this.T = null;
      for (const a of r)
        a.run();
      s && this.V(t);
    }, NR)), i?.cancel();
  }
  R(e) {
    e.length === 0 && (e = this.target.tagName === "IMG" ? ["src"] : ["textContent"]);
    for (const [t, r] of OR) {
      const i = e.findIndex((s) => s === t);
      i > -1 && e.splice(i, 1, r);
    }
    return e;
  }
  N(e) {
    return this._.includes(e);
  }
  V(e) {
    const t = Qf(this.target.childNodes), r = [], i = "au-i18n";
    for (const a of t)
      Reflect.get(a, i) || r.push(a);
    const s = this.F(e, i, r);
    this.target.innerHTML = "";
    for (const a of Qf(s.content.childNodes))
      this.target.appendChild(a);
  }
  F(e, t, r) {
    const i = this.p.document.createElement("template");
    if (this.O(i, e.prepend, t), !this.O(i, e.innerHTML ?? e.textContent, t))
      for (const s of r)
        i.content.append(s);
    return this.O(i, e.append, t), i;
  }
  O(e, t, r) {
    if (t != null) {
      const i = this.p.document.createElement("div");
      i.innerHTML = t;
      for (const s of Qf(i.childNodes))
        Reflect.set(s, r, !0), e.content.append(s);
      return !0;
    }
    return !1;
  }
  L() {
    const e = this.A ?? (this.A = ""), t = typeof e;
    if (t !== "string")
      throw new Error(`Expected the i18n key to be a string, but got ${e} of type ${t}`);
  }
}
Fr(Bi);
li(!0)(Bi);
ka(Bi, () => "updateTranslations");
class DR {
  constructor(e, t, r, i) {
    this.accessor = e, this.v = t, this.el = r, this.attr = i;
  }
  run() {
    this.accessor.setValue(this.v, this.el, this.attr);
  }
}
class $y {
  constructor(e, t, r) {
    this.owner = e, this.ast = t, this.updater = r, this.isBound = !1, this.boundFn = !1, this.oL = e.oL, this.l = e.l;
  }
  handleChange(e, t) {
    this.isBound && (this.obs.version++, this.value = z(this.ast, this.s, this, this), this.obs.clear(), this.updater());
  }
  bind(e) {
    this.isBound || (this.s = e, Or(this.ast, e, this), this.value = z(this.ast, e, this, this), this.isBound = !0);
  }
  unbind() {
    this.isBound && (dr(this.ast, this.s, this), this.s = void 0, this.obs.clearAll());
  }
}
Fr($y);
li(!0)($y);
const oT = "tpt", sl = "t-params.bind";
let e2 = class {
  [sl](e, t, r) {
    return new hr(e, t, "", sl);
  }
};
e2 = On([Gi({
  pattern: sl,
  symbols: ""
})], e2);
class BR {
  constructor(e, t) {
    this.from = e, this.to = t, this.type = oT, this.mode = 2;
  }
}
let t2 = class {
  constructor() {
    this.type = 0;
  }
  get name() {
    return sl;
  }
  build(e, t, r) {
    const i = e.attr;
    let s = i.target;
    return e.bindable == null ? s = r.map(e.node, s) ?? er(s) : s = e.bindable.property, new BR(t.parse(i.rawValue, 16), s);
  }
};
t2 = On([Wn(sl)], t2);
let n2 = class {
  render(e, t, r, i, s, a) {
    Bi.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: r,
      isParameterContext: !0,
      platform: i
    });
  }
};
n2 = On([Gt(oT)], n2);
const FR = "tt";
let r2 = class {
  render(e, t, r, i, s, a) {
    Bi.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: r,
      platform: i
    });
  }
};
r2 = On([Gt(FR)], r2);
const LR = "tbt";
let i2 = class {
  render(e, t, r, i, s, a) {
    Bi.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: r,
      platform: i
    });
  }
};
i2 = On([Gt(LR)], i2);
let s2 = class {
  constructor(e) {
    this.i18n = e, this.signals = [Ta.I18N_SIGNAL];
  }
  toView(e, t) {
    return this.i18n.tr(e, t);
  }
};
s2 = On([Al("t"), cs(0, ja)], s2);
Array.prototype.sum = function() {
  return this.reduce((n, e) => n + e, 0);
};
const $R = {
  authDomain: "kolektivo-36b63.firebaseapp.com",
  projectId: "kolektivo-36b63",
  storageBucket: "kolektivo-36b63.appspot.com",
  messagingSenderId: "324595180464",
  appId: "1:324595180464:web:69e6b83cdba3bf2d30ac75",
  measurementId: "G-7BSHV1Y6VS"
}, Bl = me.createInterface("CacheService");
class vf {
  cache = /* @__PURE__ */ new Map();
  setItem(e, t) {
    this.cache.set(e, t);
  }
  getItem(e) {
    return this.cache.get(e);
  }
  static register(e) {
    be.singleton(Bl, vf).register(e);
  }
}
const a2 = (n, e) => {
  const t = n[e];
  return t ? typeof t == "function" ? t() : Promise.resolve(t) : new Promise((r, i) => {
    (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(i.bind(null, new Error("Unknown variable dynamic import: " + e)));
  });
};
function uT(n) {
  return function(e, t, r) {
    const i = `${e.constructor.name}_${t}`, s = r.value;
    return r.value = function(...a) {
      const { storage: o } = n.call(this), u = `${i}_${JSON.stringify(a)}`;
      let l = o.getItem(u);
      return l || (l = s?.apply(this, a), o.setItem(u, l), l);
    }, r;
  };
}
const wf = me.createInterface(), UR = "https://primedao.mypinata.cloud//", o2 = Number({}.KOL_CHAIN_ID ?? 42220), jR = {}.KOL_CHAIN_URL ?? "https://celo-mainnet.infura.io/v3/29bc61de607c4369a2535498fd21fd00", u2 = {}.KOL_CHAIN ?? "Celo", VR = {}.KOL_SCAN_LINK ?? "https://explorer.celo.org/{type}/{address}", to = "chartData";
var zR = Object.defineProperty, GR = Object.getOwnPropertyDescriptor, lT = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? GR(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && zR(e, t, i), i;
}, l2 = (n, e) => (t, r) => e(t, r, n);
const Jo = me.createInterface();
let Mo = class {
  constructor(n, e) {
    this.cacheService = n, this.readOnlyProvider = e;
  }
  static register(n) {
    be.singleton(Jo, Mo).register(n);
  }
  /**
   * get a Promise of a PopulatedTransaction that can be used to sign
   * and manually send transactions.
   * Uses the `populateTransaction` method supplied by ethers.js.
   *
   * @param contract
   * @param subFunctionName the name of the contract function
   * @param params
   * @returns
   */
  callPopulateTransaction(n, e, ...t) {
    return n.populateTransaction[e].call(t);
  }
  async getContract(n, e, t, r) {
    const a = (await a2(/* @__PURE__ */ Object.assign({ "../../contracts/governance/celo.json": () => Promise.resolve().then(() => DD), "../../contracts/map/celo.json": () => Promise.resolve().then(() => FD), "../../contracts/monetary/celo.json": () => Promise.resolve().then(() => $D) }), `../../contracts/${n}/celo.json`)).contracts[e];
    let o = a.abi;
    if (o || (o = "ERC20"), typeof o == "string") {
      const u = o;
      o = await this.getSharedAbi(n, u);
    }
    if (t = t ?? a.address, !t)
      throw new Error(`ContractService: requested contract has no address: ${e}`);
    return new g6(t, o, r ?? this.readOnlyProvider);
  }
  async getSharedAbi(n, e) {
    return (await a2(/* @__PURE__ */ Object.assign({ "../../contracts/governance/sharedAbis.json": () => Promise.resolve().then(() => jD), "../../contracts/map/sharedAbis.json": () => Promise.resolve().then(() => zD), "../../contracts/monetary/sharedAbis.json": () => Promise.resolve().then(() => HD) }), `../../contracts/${n}/sharedAbis.json`))[e];
  }
};
lT([
  uT(function() {
    return { storage: this.cacheService };
  })
], Mo.prototype, "getContract", 1);
Mo = lT([
  l2(0, Bl),
  l2(1, wf)
], Mo);
const cT = me.createInterface(), HR = "https://raw.githubusercontent.com/Kolektivo/tokenlists/main/tokenlist.json", qR = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  globalThis.fetch !== void 0 ? await fetch(HR, {
    method: "GET",
    headers: { accept: "application/json" }
  }).then(async (n) => await n.json()).then((n) => n.tokens) : []
);
var WR = Object.defineProperty, KR = Object.getOwnPropertyDescriptor, JR = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? KR(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && WR(e, t, i), i;
}, QR = (n, e) => (t, r) => e(t, r, n);
const dT = me.createInterface(), Uy = me.createInterface();
let al = class {
  constructor(n) {
    this.container = n;
  }
  static register(n) {
    n.register(be.singleton(Uy, al));
  }
  fireStore;
  async connect() {
    const { getFirestore: n } = await Promise.resolve().then(() => H2);
    return this.fireStore ??= n(await this.container.get(dT)), this.fireStore;
  }
  async getDocs(n, e, t, r) {
    const { getDocs: i, query: s, collection: a, where: o, orderBy: u } = await Promise.resolve().then(() => H2);
    return (await i(s(a(await this.connect(), n), o(r.fieldPath, r.opStr, r.value), u(e, t)))).docs.map((d) => d.data());
  }
};
al = JR([
  QR(0, No)
], al);
var YR = Object.defineProperty, XR = Object.getOwnPropertyDescriptor, ZR = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? XR(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && YR(e, t, i), i;
}, eI = (n, e) => (t, r) => e(t, r, n);
const Fl = me.createInterface("NumberService");
let ol = class {
  constructor(n) {
    this.i18n = n;
  }
  static register(n) {
    n.register(be.singleton(Fl, ol));
  }
  /**
   * Returns a string from a number or BigNumber.
   * @param value
   * @param format
   */
  toString(n, e) {
    if (n === null || typeof n > "u" || typeof n == "string")
      return n;
    if (H.isBigNumber(n) && (n = n.toNumber()), Number.isNaN(n))
      return "NaN";
    const t = e?.useGrouping ?? !0, r = e?.isPercentage ?? !1, i = e?.isCurrency ?? !1;
    let s = this.fromString(e?.fractionDigits);
    isNaN(s) && (s = 2);
    const a = i ? { style: "currency", currency: "USD" } : r ? { style: "percent" } : { style: "decimal" };
    return this.i18n.nf(
      n,
      Object.assign(a, {
        useGrouping: t,
        minimumFractionDigits: s,
        maximumFractionDigits: s
      })
    );
  }
  /**
   * returns number from string.
   * @param value the value
   */
  fromString(n) {
    return n === null || typeof n > "u" ? NaN : typeof n == "number" ? n : this.i18n.uf(n);
  }
};
ol = ZR([
  eI(0, ja)
], ol);
var tI = Object.defineProperty, nI = Object.getOwnPropertyDescriptor, fT = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? nI(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && tI(e, t, i), i;
}, $p = (n, e) => (t, r) => e(t, r, n);
const jy = me.createInterface();
let Po = class {
  constructor(n, e, t) {
    this.cacheService = n, this.contractService = e, this.readonlyProvider = t;
  }
  static register(n) {
    be.singleton(jy, Po).register(n);
  }
  async getTokenContract(n, e, t) {
    const r = e ? await this.contractService.getSharedAbi("monetary", "ERC721") : await this.contractService.getSharedAbi("monetary", "ERC20");
    return new g6(n, r, t ?? this.readonlyProvider);
  }
};
fT([
  uT(function() {
    return { storage: this.cacheService };
  })
], Po.prototype, "getTokenContract", 1);
Po = fT([
  $p(0, Bl),
  $p(1, Jo),
  $p(2, wf)
], Po);
var Iu = /* @__PURE__ */ ((n) => (n[n.Low = 0] = "Low", n[n.Medium = 1] = "Medium", n[n.High = 2] = "High", n))(Iu || {});
const rI = me.createInterface();
var iI = Object.defineProperty, sI = Object.getOwnPropertyDescriptor, aI = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? sI(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && iI(e, t, i), i;
}, oI = (n, e) => (t, r) => e(t, r, n);
const Vy = me.createInterface();
let Td = class {
  constructor(n) {
    this.client = n;
  }
  static register(n) {
    n.register(be.singleton(Vy, Td));
  }
  async all(n) {
    const e = [];
    for await (const t of n)
      e.push(t);
    return e;
  }
  save(n, e = !0) {
    return typeof n == "string" ? this.client.add(
      { content: n },
      {
        pin: e
      }
    ).then((t) => t.cid) : this.client.dag.put(n, {
      pin: e
    });
  }
  async get(n, e = !1, t) {
    const r = (await Promise.resolve().then(() => UB)).CID.asCID(n);
    if (r) {
      if (!e) {
        const i = this.client.cat(n), s = (await Promise.resolve().then(() => VB)).concat(await this.all(i));
        return (await Promise.resolve().then(() => mF)).toString(s);
      }
      return JSON.stringify((await this.client.dag.get(r, { path: t })).value);
    }
  }
};
Td = aI([
  oI(0, rI)
], Td);
const uI = "@kolektivo/dapp", lI = "A collection of institutional technologies that open up new opportunities for local communities to govern and finance their own regenerative economies.", cI = "1.0.0", dI = {
  type: "git",
  url: "https://github.com/Kolektivo/dapp"
}, fI = "CL Cybernetix GmbH", pI = "./", hI = "MIT", yI = {
  node: ">=16.0.0"
}, mI = {
  http: !1
}, bI = {
  "lint:js": "eslint src --ext .js,.ts",
  "lint:fix": "eslint src  --fix",
  "lint:scss:fix": 'stylelint "src/**/*.scss" --fix',
  "lint:scss": 'stylelint "src/**/*.scss"',
  "lint:html": "htmlhint -c .htmlhintrc src design-system ",
  lint: "npm run lint:js && npm run lint:html",
  clean: "npx -y rimraf node_modules package-lock.json && npm i",
  dev: "vite",
  start: "vite",
  typecheck: "tsc",
  build: "tsc && vite build",
  "build:chart-data-script": "vite build --config vite.config-lib.ts",
  "build:dev:chart-data-script": "vite build --config vite.config-lib.ts --mode development",
  "build:dev": "vite build --mode development",
  "preview-build": "vite preview --open",
  postinstall: "node build/postinstall/index.mjs",
  test: "exit 0",
  "test:ui": "vitest --ui",
  coverage: "vitest run --coverage",
  e2e: "playwright test",
  "e2e:watch": "playwright test --watch",
  "e2e:ci": "URL=$npm_config_url playwright test",
  "vercel:deploy": "vercel --token $npm_config_token",
  "vercel:deploy:production": "vercel --prod --token $npm_config_token",
  "vercel:alias": "vercel alias set $npm_config_deployment $npm_config_branch --token $npm_config_token --scope $npm_config_scope"
}, gI = {
  "@aurelia/i18n": "dev",
  "@aurelia/router-lite": "dev",
  "@aurelia/validation-html": "dev",
  "@celo-tools/celo-ethers-wrapper": "^0.4.0",
  "@dethcrypto/eth-sdk": "^0.3.3",
  "@dethcrypto/eth-sdk-client": "^0.1.6",
  "@lottiefiles/lottie-player": "^1.7.1",
  "@material-design-icons/svg": "^0.14.3",
  "@metamask/detect-provider": "^2.0.0",
  "@metamask/providers": "^10.2.1",
  "@walletconnect/web3-provider": "^1.8.0",
  aurelia: "dev",
  "browserify-zlib": "^0.2.0",
  buffer: "^6.0.3",
  "chart.js": "^4.2.1",
  cids: "^1.1.9",
  ethers: "^5",
  events: "^3.3.0",
  firebase: "^9.17.2",
  "graphql-request": "^6.0.0",
  "i18next-chained-backend": "^4.2.0",
  "i18next-http-backend": "^2.2.0",
  "i18next-intervalplural-postprocessor": "^3.0.0",
  "i18next-localstorage-backend": "^4.1.0",
  "ipfs-core": "^0.18.0",
  "ipfs-http-client": "^60.0.0",
  "lit-js-sdk": "^1.2.17",
  process: "^0.11.10",
  "stream-browserify": "^3.0.0",
  uint8arrays: "^4.0.3",
  util: "^0.12.5",
  web3modal: "^1.9.12"
}, xI = {
  "@aurelia/plugin-conventions": "dev",
  "@aurelia/testing": "dev",
  "@esbuild-plugins/node-globals-polyfill": "^0.2.3",
  "@playwright/test": "^1.31.2",
  "@rollup/plugin-inject": "^5.0.3",
  "@typechain/ethers-v5": "^10.2.0",
  "@types/node": "^18.15.3",
  "@typescript-eslint/eslint-plugin": "^5.55.0",
  "@typescript-eslint/parser": "^5.55.0",
  "@vitest/ui": "^0.29.3",
  "cross-env": "^7.0.3",
  eslint: "^8.36.0",
  "eslint-config-prettier": "^8.7.0",
  "eslint-import-resolver-typescript": "^3.5.3",
  "eslint-plugin-cypress": "^2.12.1",
  "eslint-plugin-import": "^2.27.5",
  "eslint-plugin-prettier": "^4.2.1",
  "eslint-plugin-simple-import-sort": "^10.0.0",
  "eslint-plugin-unused-imports": "^2.0.0",
  "fs-extra": "^11.1.0",
  glob: "^9.3.0",
  "happy-dom": "^8.9.0",
  "html-loader": "^4.2.0",
  htmlhint: "^1.1.4",
  "http-browserify": "1.7.0",
  "https-browserify": "^1.0.0",
  postcss: "^8.4.21",
  "postcss-loader": "^7.1.0",
  "rollup-plugin-html": "^0.2.1",
  "rollup-plugin-polyfill-node": "^0.12.0",
  "rollup-plugin-swc": "^0.2.1",
  "rollup-plugin-visualizer": "^5.9.0",
  "rollup-pluginutils": "^2.8.2",
  sass: "^1.59.3",
  stylelint: "^15.2.0",
  "stylelint-config-standard": "^30.0.1",
  "stylelint-config-standard-scss": "^7.0.1",
  "stylelint-prettier": "^3.0.0",
  tslib: "^2.5.0",
  typescript: "~4.9.5",
  vercel: "latest",
  vite: "^4.2.0",
  vitest: "^0.29.3",
  "vitest-mock-extended": "^1.1.0"
}, vI = {
  terser: "npm:@swc/core"
}, wI = {
  name: uI,
  description: lI,
  version: cI,
  repository: dI,
  author: fI,
  homepage: pI,
  license: hI,
  engines: yI,
  browser: mI,
  scripts: bI,
  dependencies: gI,
  devDependencies: xI,
  resolutions: vI
}, zy = me.createInterface("BrowserStorageService");
class Gy {
  addVersion(e, t) {
    return {
      data: e,
      _version: t
    };
  }
  getKey(e) {
    return `${wI.name}.${e}`;
  }
  set(e, t, r, i) {
    const s = typeof i == "string" ? this.addVersion(r, i) : r;
    e.setItem(this.getKey(t), JSON.stringify(s));
  }
  get(e, t, r, i) {
    const s = e.getItem(this.getKey(t));
    if (typeof s == "string")
      try {
        const a = JSON.parse(s);
        if (typeof i == "string") {
          const o = a;
          return o._version === i ? o.data : r;
        } else
          return a;
      } catch {
        return r;
      }
    return r;
  }
  remove(e, t) {
    e.removeItem(this.getKey(t));
  }
  lsSet(e, t, r) {
    this.set(localStorage, e, t, r);
  }
  lsGet(e, t, r) {
    return this.get(localStorage, e, t, r);
  }
  lsRemove(e) {
    this.remove(localStorage, e);
  }
  ssSet(e, t, r) {
    this.set(sessionStorage, e, t, r);
  }
  ssGet(e, t, r) {
    return this.get(sessionStorage, e, t, r);
  }
  ssRemove(e) {
    this.remove(sessionStorage, e);
  }
  static register(e) {
    be.singleton(zy, Gy).register(e);
  }
}
var Gh = /* @__PURE__ */ ((n) => (n[n.MONETARY_CONTROLLER = 1] = "MONETARY_CONTROLLER", n[n.RESERVE_DELEGATE = 2] = "RESERVE_DELEGATE", n[n.RESERVE_VETO_DELEGATE = 3] = "RESERVE_VETO_DELEGATE", n[n.TOPOLOGY_DELEGATE = 4] = "TOPOLOGY_DELEGATE", n[n.ECOLOGY_DELEGATE = 5] = "ECOLOGY_DELEGATE", n[n.ECOLOGY_DELEGATE_PROPOSER = 6] = "ECOLOGY_DELEGATE_PROPOSER", n[n.RESERVE_ARBITRAGEUR = 7] = "RESERVE_ARBITRAGEUR", n[n.LOCAL_MULTI_SIG_MEMBER = 8] = "LOCAL_MULTI_SIG_MEMBER", n[n.TREASURY_DELEGATE = 101] = "TREASURY_DELEGATE", n[n.TREASURY_VETO_DELEGATE = 102] = "TREASURY_VETO_DELEGATE", n[n.TREASURY_ARBITRAGEUR = 103] = "TREASURY_ARBITRAGEUR", n[n.KOLEKTIVO_MULTI_SIG_MEMBER = 104] = "KOLEKTIVO_MULTI_SIG_MEMBER", n))(Gh || {});
const TI = me.createInterface();
var AI = Object.defineProperty, EI = Object.getOwnPropertyDescriptor, SI = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? EI(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && AI(e, t, i), i;
}, Up = (n, e) => (t, r) => e(t, r, n);
const pT = me.createInterface("EncryptionService");
let Ad = class {
  constructor(n, e, t) {
    this.logger = n, this.container = e, this.config = t, this.logger.scopeTo("EncryptionService");
  }
  client;
  static register(n) {
    be.singleton(pT, Ad).register(n);
  }
  authSig;
  encryptedSymmetricKey;
  get chain() {
    return this.config.chain.toLowerCase();
  }
  getAccessControlConditions(n) {
    return [
      {
        contractAddress: n,
        standardContractType: "ERC1155",
        chain: this.chain,
        method: "balanceOfBatch",
        parameters: [":userAddress,:userAddress", `${Gh.RESERVE_DELEGATE},${Gh.ECOLOGY_DELEGATE_PROPOSER}`],
        returnValueTest: {
          comparator: ">",
          value: "0"
        }
      }
    ];
  }
  async connect() {
    if (this.client)
      return;
    const n = await this.container.get(TI);
    return this.client = n, await this.client.connect();
  }
  async encrypt(n, e, t, r) {
    if (await this.connect(), !this.client)
      return;
    const i = {
      web3: e,
      account: t.toLowerCase(),
      chainId: this.config.chainId,
      expiration: new Date(Date.now() + 3e5)
      // 5 minutes
    };
    this.authSig = await this.client.getAuthSig(i);
    const { encryptedString: s, symmetricKey: a } = await this.client.encryptString(n);
    return this.encryptedSymmetricKey = this.client.uint8arrayToString(
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      await this.client.saveEncryptionKey({
        accessControlConditions: this.getAccessControlConditions(r),
        symmetricKey: a,
        authSig: this.authSig,
        chain: this.chain
      }),
      "base16"
    ), { encryptedString: s, symmetricKey: a };
  }
  async decryptAs(n, e) {
    if (await this.connect(), !this.client)
      throw new Error("No encryption client connected");
    const t = await this.client.getEncryptionKey({
      accessControlConditions: this.getAccessControlConditions(e),
      toDecrypt: this.encryptedSymmetricKey,
      chain: this.chain,
      authSig: this.authSig
    }), r = await this.client.decryptString(n, t);
    try {
      return JSON.parse(r);
    } catch {
      this.logger.info("Failed to parse data from LIT");
    }
    return r;
  }
};
Ad = SI([
  Up(0, Ra),
  Up(1, No),
  Up(2, Cs)
], Ad);
var Mr = /* @__PURE__ */ ((n) => (n[n["1h"] = 0] = "1h", n[n["1d"] = 1] = "1d", n[n["1w"] = 2] = "1w", n[n["1m"] = 3] = "1m", n[n["1y"] = 4] = "1y", n))(Mr || {}), Hy = {};
const CI = /* @__PURE__ */ kt(x_), _I = /* @__PURE__ */ kt(tC), MI = /* @__PURE__ */ kt(FC), PI = /* @__PURE__ */ kt(MM), RI = /* @__PURE__ */ kt(nS), II = /* @__PURE__ */ kt(m_), OI = /* @__PURE__ */ kt(zM), kI = /* @__PURE__ */ kt(i9), NI = /* @__PURE__ */ kt(qS), DI = /* @__PURE__ */ kt(eS), c2 = /* @__PURE__ */ kt(OM), BI = /* @__PURE__ */ kt(K9), FI = /* @__PURE__ */ kt(WM), LI = /* @__PURE__ */ kt(dS), $I = /* @__PURE__ */ kt(KS), UI = /* @__PURE__ */ kt(dM), d2 = /* @__PURE__ */ kt(kC), jI = /* @__PURE__ */ kt(xM), VI = /* @__PURE__ */ kt(Y9), zI = /* @__PURE__ */ kt(c9), GI = /* @__PURE__ */ kt(x9);
(function(n) {
  var e = bi && bi.__createBinding || (Object.create ? function(K, le, C, c) {
    c === void 0 && (c = C), Object.defineProperty(K, c, { enumerable: !0, get: function() {
      return le[C];
    } });
  } : function(K, le, C, c) {
    c === void 0 && (c = C), K[c] = le[C];
  }), t = bi && bi.__setModuleDefault || (Object.create ? function(K, le) {
    Object.defineProperty(K, "default", { enumerable: !0, value: le });
  } : function(K, le) {
    K.default = le;
  }), r = bi && bi.__importStar || function(K) {
    if (K && K.__esModule)
      return K;
    var le = {};
    if (K != null)
      for (var C in K)
        C !== "default" && Object.prototype.hasOwnProperty.call(K, C) && e(le, K, C);
    return t(le, K), le;
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), n.formatBytes32String = n.Utf8ErrorFuncs = n.toUtf8String = n.toUtf8CodePoints = n.toUtf8Bytes = n._toEscapedUtf8String = n.nameprep = n.hexDataSlice = n.hexDataLength = n.hexZeroPad = n.hexValue = n.hexStripZeros = n.hexConcat = n.isHexString = n.hexlify = n.base64 = n.base58 = n.TransactionDescription = n.LogDescription = n.Interface = n.SigningKey = n.HDNode = n.defaultPath = n.isBytesLike = n.isBytes = n.zeroPad = n.stripZeros = n.concat = n.arrayify = n.shallowCopy = n.resolveProperties = n.getStatic = n.defineReadOnly = n.deepCopy = n.checkProperties = n.poll = n.fetchJson = n._fetchData = n.RLP = n.Logger = n.checkResultErrors = n.FormatTypes = n.ParamType = n.FunctionFragment = n.EventFragment = n.ErrorFragment = n.ConstructorFragment = n.Fragment = n.defaultAbiCoder = n.AbiCoder = void 0, n.Indexed = n.Utf8ErrorReason = n.UnicodeNormalizationForm = n.SupportedAlgorithm = n.mnemonicToSeed = n.isValidMnemonic = n.entropyToMnemonic = n.mnemonicToEntropy = n.getAccountPath = n.verifyTypedData = n.verifyMessage = n.recoverPublicKey = n.computePublicKey = n.recoverAddress = n.computeAddress = n.getJsonWalletAddress = n.TransactionTypes = n.serializeTransaction = n.parseTransaction = n.accessListify = n.joinSignature = n.splitSignature = n.soliditySha256 = n.solidityKeccak256 = n.solidityPack = n.shuffled = n.randomBytes = n.sha512 = n.sha256 = n.ripemd160 = n.keccak256 = n.computeHmac = n.commify = n.parseUnits = n.formatUnits = n.parseEther = n.formatEther = n.isAddress = n.getCreate2Address = n.getContractAddress = n.getIcapAddress = n.getAddress = n._TypedDataEncoder = n.id = n.isValidName = n.namehash = n.hashMessage = n.dnsEncode = n.parseBytes32String = void 0;
  var i = CI;
  Object.defineProperty(n, "AbiCoder", { enumerable: !0, get: function() {
    return i.AbiCoder;
  } }), Object.defineProperty(n, "checkResultErrors", { enumerable: !0, get: function() {
    return i.checkResultErrors;
  } }), Object.defineProperty(n, "ConstructorFragment", { enumerable: !0, get: function() {
    return i.ConstructorFragment;
  } }), Object.defineProperty(n, "defaultAbiCoder", { enumerable: !0, get: function() {
    return i.defaultAbiCoder;
  } }), Object.defineProperty(n, "ErrorFragment", { enumerable: !0, get: function() {
    return i.ErrorFragment;
  } }), Object.defineProperty(n, "EventFragment", { enumerable: !0, get: function() {
    return i.EventFragment;
  } }), Object.defineProperty(n, "FormatTypes", { enumerable: !0, get: function() {
    return i.FormatTypes;
  } }), Object.defineProperty(n, "Fragment", { enumerable: !0, get: function() {
    return i.Fragment;
  } }), Object.defineProperty(n, "FunctionFragment", { enumerable: !0, get: function() {
    return i.FunctionFragment;
  } }), Object.defineProperty(n, "Indexed", { enumerable: !0, get: function() {
    return i.Indexed;
  } }), Object.defineProperty(n, "Interface", { enumerable: !0, get: function() {
    return i.Interface;
  } }), Object.defineProperty(n, "LogDescription", { enumerable: !0, get: function() {
    return i.LogDescription;
  } }), Object.defineProperty(n, "ParamType", { enumerable: !0, get: function() {
    return i.ParamType;
  } }), Object.defineProperty(n, "TransactionDescription", { enumerable: !0, get: function() {
    return i.TransactionDescription;
  } });
  var s = _I;
  Object.defineProperty(n, "getAddress", { enumerable: !0, get: function() {
    return s.getAddress;
  } }), Object.defineProperty(n, "getCreate2Address", { enumerable: !0, get: function() {
    return s.getCreate2Address;
  } }), Object.defineProperty(n, "getContractAddress", { enumerable: !0, get: function() {
    return s.getContractAddress;
  } }), Object.defineProperty(n, "getIcapAddress", { enumerable: !0, get: function() {
    return s.getIcapAddress;
  } }), Object.defineProperty(n, "isAddress", { enumerable: !0, get: function() {
    return s.isAddress;
  } });
  var a = r(MI);
  n.base64 = a;
  var o = PI;
  Object.defineProperty(n, "base58", { enumerable: !0, get: function() {
    return o.Base58;
  } });
  var u = RI;
  Object.defineProperty(n, "arrayify", { enumerable: !0, get: function() {
    return u.arrayify;
  } }), Object.defineProperty(n, "concat", { enumerable: !0, get: function() {
    return u.concat;
  } }), Object.defineProperty(n, "hexConcat", { enumerable: !0, get: function() {
    return u.hexConcat;
  } }), Object.defineProperty(n, "hexDataSlice", { enumerable: !0, get: function() {
    return u.hexDataSlice;
  } }), Object.defineProperty(n, "hexDataLength", { enumerable: !0, get: function() {
    return u.hexDataLength;
  } }), Object.defineProperty(n, "hexlify", { enumerable: !0, get: function() {
    return u.hexlify;
  } }), Object.defineProperty(n, "hexStripZeros", { enumerable: !0, get: function() {
    return u.hexStripZeros;
  } }), Object.defineProperty(n, "hexValue", { enumerable: !0, get: function() {
    return u.hexValue;
  } }), Object.defineProperty(n, "hexZeroPad", { enumerable: !0, get: function() {
    return u.hexZeroPad;
  } }), Object.defineProperty(n, "isBytes", { enumerable: !0, get: function() {
    return u.isBytes;
  } }), Object.defineProperty(n, "isBytesLike", { enumerable: !0, get: function() {
    return u.isBytesLike;
  } }), Object.defineProperty(n, "isHexString", { enumerable: !0, get: function() {
    return u.isHexString;
  } }), Object.defineProperty(n, "joinSignature", { enumerable: !0, get: function() {
    return u.joinSignature;
  } }), Object.defineProperty(n, "zeroPad", { enumerable: !0, get: function() {
    return u.zeroPad;
  } }), Object.defineProperty(n, "splitSignature", { enumerable: !0, get: function() {
    return u.splitSignature;
  } }), Object.defineProperty(n, "stripZeros", { enumerable: !0, get: function() {
    return u.stripZeros;
  } });
  var l = II;
  Object.defineProperty(n, "_TypedDataEncoder", { enumerable: !0, get: function() {
    return l._TypedDataEncoder;
  } }), Object.defineProperty(n, "dnsEncode", { enumerable: !0, get: function() {
    return l.dnsEncode;
  } }), Object.defineProperty(n, "hashMessage", { enumerable: !0, get: function() {
    return l.hashMessage;
  } }), Object.defineProperty(n, "id", { enumerable: !0, get: function() {
    return l.id;
  } }), Object.defineProperty(n, "isValidName", { enumerable: !0, get: function() {
    return l.isValidName;
  } }), Object.defineProperty(n, "namehash", { enumerable: !0, get: function() {
    return l.namehash;
  } });
  var d = OI;
  Object.defineProperty(n, "defaultPath", { enumerable: !0, get: function() {
    return d.defaultPath;
  } }), Object.defineProperty(n, "entropyToMnemonic", { enumerable: !0, get: function() {
    return d.entropyToMnemonic;
  } }), Object.defineProperty(n, "getAccountPath", { enumerable: !0, get: function() {
    return d.getAccountPath;
  } }), Object.defineProperty(n, "HDNode", { enumerable: !0, get: function() {
    return d.HDNode;
  } }), Object.defineProperty(n, "isValidMnemonic", { enumerable: !0, get: function() {
    return d.isValidMnemonic;
  } }), Object.defineProperty(n, "mnemonicToEntropy", { enumerable: !0, get: function() {
    return d.mnemonicToEntropy;
  } }), Object.defineProperty(n, "mnemonicToSeed", { enumerable: !0, get: function() {
    return d.mnemonicToSeed;
  } });
  var p = kI;
  Object.defineProperty(n, "getJsonWalletAddress", { enumerable: !0, get: function() {
    return p.getJsonWalletAddress;
  } });
  var m = NI;
  Object.defineProperty(n, "keccak256", { enumerable: !0, get: function() {
    return m.keccak256;
  } });
  var w = DI;
  Object.defineProperty(n, "Logger", { enumerable: !0, get: function() {
    return w.Logger;
  } });
  var x = c2;
  Object.defineProperty(n, "computeHmac", { enumerable: !0, get: function() {
    return x.computeHmac;
  } }), Object.defineProperty(n, "ripemd160", { enumerable: !0, get: function() {
    return x.ripemd160;
  } }), Object.defineProperty(n, "sha256", { enumerable: !0, get: function() {
    return x.sha256;
  } }), Object.defineProperty(n, "sha512", { enumerable: !0, get: function() {
    return x.sha512;
  } });
  var T = BI;
  Object.defineProperty(n, "solidityKeccak256", { enumerable: !0, get: function() {
    return T.keccak256;
  } }), Object.defineProperty(n, "solidityPack", { enumerable: !0, get: function() {
    return T.pack;
  } }), Object.defineProperty(n, "soliditySha256", { enumerable: !0, get: function() {
    return T.sha256;
  } });
  var A = FI;
  Object.defineProperty(n, "randomBytes", { enumerable: !0, get: function() {
    return A.randomBytes;
  } }), Object.defineProperty(n, "shuffled", { enumerable: !0, get: function() {
    return A.shuffled;
  } });
  var M = LI;
  Object.defineProperty(n, "checkProperties", { enumerable: !0, get: function() {
    return M.checkProperties;
  } }), Object.defineProperty(n, "deepCopy", { enumerable: !0, get: function() {
    return M.deepCopy;
  } }), Object.defineProperty(n, "defineReadOnly", { enumerable: !0, get: function() {
    return M.defineReadOnly;
  } }), Object.defineProperty(n, "getStatic", { enumerable: !0, get: function() {
    return M.getStatic;
  } }), Object.defineProperty(n, "resolveProperties", { enumerable: !0, get: function() {
    return M.resolveProperties;
  } }), Object.defineProperty(n, "shallowCopy", { enumerable: !0, get: function() {
    return M.shallowCopy;
  } });
  var I = r($I);
  n.RLP = I;
  var B = UI;
  Object.defineProperty(n, "computePublicKey", { enumerable: !0, get: function() {
    return B.computePublicKey;
  } }), Object.defineProperty(n, "recoverPublicKey", { enumerable: !0, get: function() {
    return B.recoverPublicKey;
  } }), Object.defineProperty(n, "SigningKey", { enumerable: !0, get: function() {
    return B.SigningKey;
  } });
  var k = d2;
  Object.defineProperty(n, "formatBytes32String", { enumerable: !0, get: function() {
    return k.formatBytes32String;
  } }), Object.defineProperty(n, "nameprep", { enumerable: !0, get: function() {
    return k.nameprep;
  } }), Object.defineProperty(n, "parseBytes32String", { enumerable: !0, get: function() {
    return k.parseBytes32String;
  } }), Object.defineProperty(n, "_toEscapedUtf8String", { enumerable: !0, get: function() {
    return k._toEscapedUtf8String;
  } }), Object.defineProperty(n, "toUtf8Bytes", { enumerable: !0, get: function() {
    return k.toUtf8Bytes;
  } }), Object.defineProperty(n, "toUtf8CodePoints", { enumerable: !0, get: function() {
    return k.toUtf8CodePoints;
  } }), Object.defineProperty(n, "toUtf8String", { enumerable: !0, get: function() {
    return k.toUtf8String;
  } }), Object.defineProperty(n, "Utf8ErrorFuncs", { enumerable: !0, get: function() {
    return k.Utf8ErrorFuncs;
  } });
  var N = jI;
  Object.defineProperty(n, "accessListify", { enumerable: !0, get: function() {
    return N.accessListify;
  } }), Object.defineProperty(n, "computeAddress", { enumerable: !0, get: function() {
    return N.computeAddress;
  } }), Object.defineProperty(n, "parseTransaction", { enumerable: !0, get: function() {
    return N.parse;
  } }), Object.defineProperty(n, "recoverAddress", { enumerable: !0, get: function() {
    return N.recoverAddress;
  } }), Object.defineProperty(n, "serializeTransaction", { enumerable: !0, get: function() {
    return N.serialize;
  } }), Object.defineProperty(n, "TransactionTypes", { enumerable: !0, get: function() {
    return N.TransactionTypes;
  } });
  var U = VI;
  Object.defineProperty(n, "commify", { enumerable: !0, get: function() {
    return U.commify;
  } }), Object.defineProperty(n, "formatEther", { enumerable: !0, get: function() {
    return U.formatEther;
  } }), Object.defineProperty(n, "parseEther", { enumerable: !0, get: function() {
    return U.parseEther;
  } }), Object.defineProperty(n, "formatUnits", { enumerable: !0, get: function() {
    return U.formatUnits;
  } }), Object.defineProperty(n, "parseUnits", { enumerable: !0, get: function() {
    return U.parseUnits;
  } });
  var W = zI;
  Object.defineProperty(n, "verifyMessage", { enumerable: !0, get: function() {
    return W.verifyMessage;
  } }), Object.defineProperty(n, "verifyTypedData", { enumerable: !0, get: function() {
    return W.verifyTypedData;
  } });
  var G = GI;
  Object.defineProperty(n, "_fetchData", { enumerable: !0, get: function() {
    return G._fetchData;
  } }), Object.defineProperty(n, "fetchJson", { enumerable: !0, get: function() {
    return G.fetchJson;
  } }), Object.defineProperty(n, "poll", { enumerable: !0, get: function() {
    return G.poll;
  } });
  var Y = c2;
  Object.defineProperty(n, "SupportedAlgorithm", { enumerable: !0, get: function() {
    return Y.SupportedAlgorithm;
  } });
  var ue = d2;
  Object.defineProperty(n, "UnicodeNormalizationForm", { enumerable: !0, get: function() {
    return ue.UnicodeNormalizationForm;
  } }), Object.defineProperty(n, "Utf8ErrorReason", { enumerable: !0, get: function() {
    return ue.Utf8ErrorReason;
  } });
})(Hy);
function HI(n, e) {
  if (typeof n != "number" || Number.isInteger(n) || isNaN(n))
    return n;
  const t = n.toString().split(".");
  return +`${t[0]}.${t[1].slice(0, e)}`;
}
function hT(n) {
  switch (n) {
    case Mr["1d"]:
      return "hour";
    case Mr["1h"]:
      return "minute";
    case Mr["1m"]:
    case Mr["1w"]:
    case Mr["1y"]:
      return "day";
  }
}
function yT(n) {
  const e = /* @__PURE__ */ new Date();
  switch (n) {
    case Mr["1h"]:
      e.setMinutes(e.getMinutes() - 60);
      break;
    case Mr["1d"]:
      e.setHours(e.getHours() - 24);
      break;
    case Mr["1w"]:
      e.setDate(e.getDate() - 7);
      break;
    case Mr["1m"]:
      e.setMonth(e.getMonth() - 1);
      break;
    case Mr["1y"]:
      e.setFullYear(e.getFullYear() - 1);
      break;
  }
  return e.getTime();
}
const qI = (n, e) => {
  for (const t in e) {
    const r = new RegExp("{" + t + "}", "gm");
    n = n.replace(r, e[t]);
  }
  return n;
}, f2 = (n, e) => {
  const t = typeof n;
  return (t === "string" || t === "number") && (n = HI(Number(n), Number(e))), Hy.parseUnits(n.toString(), e);
}, Ve = (n, e) => Hy.formatUnits(n.toString(), e), qy = me.createInterface();
function WI({ mustBeMetaMask: n = !1, silent: e = !1, timeout: t = 3e3 } = {}) {
  i();
  let r = !1;
  return new Promise((s) => {
    window.ethereum ? a() : (window.addEventListener("ethereum#initialized", a, { once: !0 }), setTimeout(() => {
      a();
    }, t));
    function a() {
      if (r)
        return;
      r = !0, window.removeEventListener("ethereum#initialized", a);
      const { ethereum: o } = window;
      o && (!n || o.isMetaMask) ? s(o) : (!e && console.error("@metamask/detect-provider:", n && o ? "Non-MetaMask window.ethereum detected." : "Unable to detect window.ethereum."), s(null));
    }
  });
  function i() {
    if (typeof n != "boolean")
      throw new Error("@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.");
    if (typeof e != "boolean")
      throw new Error("@metamask/detect-provider: Expected option 'silent' to be a boolean.");
    if (typeof t != "number")
      throw new Error("@metamask/detect-provider: Expected option 'timeout' to be a number.");
  }
}
var KI = WI;
const JI = /* @__PURE__ */ _s(KI);
var QI = Object.defineProperty, YI = Object.getOwnPropertyDescriptor, XI = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? YI(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && QI(e, t, i), i;
}, ou = (n, e) => (t, r) => e(t, r, n);
const mT = me.createInterface("EthereumService");
let ul = class {
  constructor(n, e, t, r, i) {
    this.eventAggregator = n, this.logger = e, this.configuration = t, this.readOnlyProvider = r, this.walletConnector = i, this.logger = e.scopeTo("EthereumService");
  }
  static register(n) {
    be.singleton(mT, ul).register(n);
  }
  get targetedChainId() {
    return this.configuration.chainId;
  }
  lastBlock;
  async connect(n) {
    return n ? await this.walletConnector.connectTo(n) : await this.walletConnector.connect();
  }
  async getMetaMaskProvider() {
    const n = await JI({ mustBeMetaMask: !0 });
    if (!n)
      return null;
    if (await n._metamask.isUnlocked() && (await n.request({ method: "eth_accounts" })).length)
      return n;
  }
  async getAccountsForProvider(n) {
    return La.isSigner(n) ? [await n.getAddress()] : await n.listAccounts();
  }
  /**
   *
   * @param web3ModalProvider should be a Web3Provider
   * @returns
   */
  async switchToTargetedNetwork(n) {
    try {
      return await n.provider.request?.({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: `0x${this.targetedChainId.toString(16)}` }]
      }), n.provider;
    } catch (e) {
      if (e.code !== 4902)
        return;
      throw new Error(`The ${this.configuration.chain} network is not installed in your Metamask configuration`);
    }
  }
  async addTokenToMetamask(n, e, t, r, i) {
    try {
      await n.request({
        method: "wallet_watchAsset",
        params: {
          type: "ERC20",
          // Initially only supports ERC20, but eventually more!
          options: {
            address: e,
            // The address that the token is at.
            symbol: t,
            // A ticker symbol or shorthand, up to 5 chars.
            decimals: r,
            // The number of decimals in the token
            image: i
            // A string url of the token logo
          }
        }
      });
    } catch (s) {
      this.logger.error(s);
    }
  }
  async getBlock(n) {
    const e = await this.readOnlyProvider.getBlock(n);
    return e.blockDate = new Date(e.timestamp * 1e3), e;
  }
  getEtherscanLink(n, e = !1) {
    return qI(this.configuration.scanLink, { type: e ? "tx" : "address", address: n });
  }
};
ul = XI([
  ou(0, Gd),
  ou(1, Ra),
  ou(2, Cs),
  ou(3, wf),
  ou(4, qy)
], ul);
var ZI = Object.defineProperty, eO = Object.getOwnPropertyDescriptor, tO = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? eO(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && ZI(e, t, i), i;
}, nO = (n, e) => (t, r) => e(t, r, n);
const bT = me.createInterface("HttpService"), gT = { accept: "application/json" }, rO = { "content-type": "application/json", ...gT };
let Ed = class {
  constructor(n) {
    this.logger = n, this.logger = n.scopeTo("HttpService");
  }
  static register(n) {
    n.register(be.singleton(bT, Ed));
  }
  async call(n, e, t) {
    const r = await fetch(n, {
      body: e,
      method: e ? "POST" : "GET",
      headers: e ? rO : gT,
      ...t
    });
    if (r.ok)
      return await r.json();
    const i = new Error(await r.text());
    return this.logger.error({ response: r, error: i }), Promise.reject(i);
  }
};
Ed = tO([
  nO(0, Ra)
], Ed);
var iO = Object.defineProperty, sO = Object.getOwnPropertyDescriptor, aO = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? sO(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && iO(e, t, i), i;
}, p2 = (n, e) => (t, r) => e(t, r, n);
const xT = me.createInterface("ObserverService");
let Sd = class {
  constructor(n, e) {
    this.locator = n, this.cacheService = e;
  }
  static register(n) {
    n.register(be.singleton(xT, Sd));
  }
  /**
   * Make a object property observable and subscribe to changes in its value.
   * Viewmodels should use @watch.
   * @param obj object having the property to observe
   * @param property property to observe
   * @param method ISubscriber, handles changes in the property's values
   * @returns method to unsubscribe.  Singletons, such as services, don't need to call this.
   */
  // @cache<ObserverService>(function () {
  //   return { storage: this.cacheService };
  // })
  listen(n, e, t) {
    const r = this.locator.getObserver(n, e), i = {
      handleChange: t
    };
    return r.subscribe(i), () => r.unsubscribe(i);
  }
};
Sd = aO([
  p2(0, Ia),
  p2(1, Bl)
], Sd);
var oO = Object.defineProperty, uO = Object.getOwnPropertyDescriptor, lO = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? uO(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && oO(e, t, i), i;
}, cO = (n, e) => (t, r) => e(t, r, n);
const vT = me.createInterface("TimingService");
let Cd = class {
  constructor(n) {
    this.config = n;
  }
  static register(n) {
    be.singleton(vT, Cd).register(n);
  }
  startTimer(n) {
    this.config.isDevelopment && console.time(n);
  }
  endTimer(n) {
    this.config.isDevelopment && console.timeEnd(n);
  }
};
Cd = lO([
  cO(0, Cs)
], Cd);
var dO = Object.defineProperty, fO = Object.getOwnPropertyDescriptor, pO = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? fO(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && dO(e, t, i), i;
}, Kn = (n, e) => (t, r) => e(t, r, n);
const hO = me.createInterface();
let Hh = class {
  constructor(n, e, t, r, i, s, a, o, u, l, d, p, m) {
    this.httpService = n, this.numberService = e, this.ethereumService = t, this.browserStorageService = r, this.timingService = i, this.cacheService = s, this.observerService = a, this.encryptionService = o, this.contractService = u, this.tokenService = l, this.ipfsService = d, this.symmetricService = p, this.configuration = m;
  }
  static register(n) {
    n.register(be.singleton(hO, Hh)).register(Sd).register(Cd).register(vf).register(al).register(Ed).register(ol).register(ul).register(Ad).register(Gy).register(Td).register(Mo).register(rl).register(Po);
  }
};
Hh = pO([
  Kn(0, bT),
  Kn(1, Fl),
  Kn(2, mT),
  Kn(3, zy),
  Kn(4, vT),
  Kn(5, Bl),
  Kn(6, xT),
  Kn(7, pT),
  Kn(8, Jo),
  Kn(9, jy),
  Kn(10, Vy),
  Kn(11, By),
  Kn(12, Cs)
], Hh);
me.createInterface("DateServiceIntl");
var yO = Object.defineProperty, mO = Object.getOwnPropertyDescriptor, bO = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? mO(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && yO(e, t, i), i;
};
let h2 = class {
  disposables;
  constructor() {
    this.disposables = new Array();
  }
  push(n) {
    return this.disposables.push(n);
  }
  dispose(n) {
    if (n)
      this._dispose(n);
    else {
      for (n of this.disposables)
        n.dispose();
      this.disposables.length = 0;
    }
  }
  _dispose(n) {
    n.dispose(), this.disposables.splice(this.disposables.indexOf(n), 1);
  }
};
h2 = bO([
  xv()
], h2);
var gO = Object.defineProperty, xO = Object.getOwnPropertyDescriptor, vO = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? xO(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && gO(e, t, i), i;
}, wO = (n, e) => (t, r) => e(t, r, n);
const TO = me.createInterface("TransactionsService");
let _d = class {
  constructor(n) {
    this.eventAggregator = n;
  }
  static blocksToConfirm = 1;
  static register(n) {
    be.singleton(TO, _d).register(n);
  }
  async send(n) {
    let e;
    try {
      this.eventAggregator.publish("transaction.sending");
      const t = await n();
      return this.eventAggregator.publish("transaction.sent", t), e = await t.wait(1), this.eventAggregator.publish("transaction.mined", { message: "Transaction was mined", receipt: e }), e = await t.wait(_d.blocksToConfirm), this.eventAggregator.publish("transaction.confirmed", { message: "Transaction was confirmed", receipt: e }), e;
    } catch (t) {
      return this.eventAggregator.publish("transaction.failed", t), null;
    }
  }
};
_d = vO([
  wO(0, Gd)
], _d);
var AO = Object.defineProperty, EO = Object.getOwnPropertyDescriptor, SO = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? EO(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && AO(e, t, i), i;
}, uu = (n, e) => (t, r) => e(t, r, n);
const Wy = me.createInterface("IContractStore");
let Md = class {
  constructor(n, e, t, r, i) {
    this.contractService = n, this.tokenService = e, this.logger = t, this.numberService = r, this.tokenInfo = i;
  }
  static register(n) {
    n.register(be.singleton(Wy, Md));
  }
  async getAsset(n, e, t, r, i, s) {
    let a;
    e && (a = Number(e));
    const u = (await this.tokenInfo.tokens).find((A) => A.address === n && A.id == a);
    if (!u) {
      this.logger.error(`No token info was found for ${n}`);
      return;
    }
    const l = await this.tokenService.getTokenContract(n, u.id);
    if (s || (u.id ? s = await t.oraclePerERC721Id(n, u.id) : s = await t.oraclePerERC20(n)), !s || H.from(s).isZero())
      return;
    const p = await (await this.contractService.getContract("monetary", "Oracle", s)).getData();
    if (!p[1])
      return;
    u.price = this.numberService.fromString(Ve(p[0], 18));
    let m = f2(1, 18), w;
    u.id || (w = await l.totalSupply(), m = await l.balanceOf(r));
    let x;
    u.id ? x = Iu.Low : x = await t.assetTypeOfERC20(n), i && this.populateTransactionsForAsset(i, l, r, u);
    const T = {
      quantity: m,
      token: u,
      total: 0,
      type: x,
      totalSupply: w
    };
    return T.total = u.id ? u.price : this.numberService.fromString(Ve(T.quantity, 18)) * u.price, T;
  }
  async populateTransactionsForAsset(n, e, t, r) {
    const i = await e.queryFilter(e.filters.Transfer(void 0, t)), s = await this.mapTransactions(i, "deposit", r);
    n.push(...s);
    const a = await e.queryFilter(e.filters.Transfer(t)), o = await this.mapTransactions(a, "withdrawl", r);
    n.push(...o);
  }
  async mapTransactions(n, e, t) {
    return await Promise.all(
      n.map(async (r) => {
        const i = await r.getBlock();
        return {
          address: e === "deposit" ? r.args.from : r.args.to,
          amount: "amount" in r.args ? r.args.amount : f2(1, 18),
          date: i.timestamp,
          id: r.transactionHash,
          token: t,
          type: e
        };
      })
    );
  }
};
Md = SO([
  uu(0, Jo),
  uu(1, jy),
  uu(2, Ra),
  uu(3, Fl),
  uu(4, cT)
], Md);
var CO = Object.defineProperty, _O = Object.getOwnPropertyDescriptor, MO = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? _O(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && CO(e, t, i), i;
}, PO = (n, e) => (t, r) => e(t, r, n);
const Ky = me.createInterface("DataStore");
let Pd = class {
  constructor(n) {
    this.firebaseService = n;
  }
  static register(n) {
    n.register(be.singleton(Ky, Pd));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async getDocs(...n) {
    return this.firebaseService.getDocs(...n);
  }
};
Pd = MO([
  PO(0, Uy)
], Pd);
function Tf(n = "") {
  const e = /* @__PURE__ */ new WeakMap();
  return function(t, r, i) {
    const s = t[r];
    if (typeof s != "function")
      throw new Error(`ER: @callOnce: > ${String(r)}`);
    i.value = function(...a) {
      if (e.has(this))
        return e.get(this);
      const o = s.apply(this, a);
      return e.set(this, o), o;
    };
  };
}
var RO = Object.defineProperty, IO = Object.getOwnPropertyDescriptor, Af = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? IO(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && RO(e, t, i), i;
}, Ka = (n, e) => (t, r) => e(t, r, n);
const wT = me.createInterface("ReserveStore");
let Aa = class {
  constructor(n, e, t, r, i, s) {
    this.contractStore = n, this.contractService = e, this.numberService = t, this.symmetricService = r, this.configuration = i, this.dataStore = s;
  }
  reserveValue;
  kCurMarketCap;
  backing;
  kCurPrice;
  kCurSupply;
  transactions = [];
  reserveAssets = [];
  kCurReserveDistribution;
  kCurMentoDistribution;
  kCurPrimaryPoolDistribution;
  kCurPriceFloor;
  kCurPriceCeiling;
  minBacking;
  kGuilderCurrentPrice;
  kGuilderTotalSupply;
  kGuilderSpread;
  kGuilderInflationRate;
  kGuilderTobinTax;
  kGuilderPriceParity;
  kGuilderValueRatio;
  primaryPoolData;
  static register(n) {
    n.register(be.singleton(wT, Aa));
  }
  get kCurCirculatingDistribution() {
    return 1 - ((this.kCurReserveDistribution ?? 0) + (this.kCurMentoDistribution ?? 0) + (this.kCurPrimaryPoolDistribution ?? 0));
  }
  get currentCollateralizationRatio() {
    return this.numberService.fromString(Ve(this.backing ?? 0, 2));
  }
  get currentLeverageRatio() {
    return this.backing ? this.calculateLeverage(this.backing) : 0;
  }
  get maxLeverageRatio() {
    return 1 / this.numberService.fromString(Ve(this.minBacking ?? 0, 4)) * 100;
  }
  get minCollateralizationRatio() {
    return this.numberService.fromString(Ve(this.minBacking ?? 0, 4));
  }
  get minCollateralizationValue() {
    return this.kCurMarketCap ? this.minCollateralizationRatio * this.numberService.fromString(Ve(this.kCurMarketCap, 18)) : 0;
  }
  get maxLeverageMultiplier() {
    return `${Math.round(this.maxLeverageRatio / 100 * 100) / 100}x`;
  }
  get kCurTotalValue() {
    return this.numberService.fromString(Ve(this.kCurMarketCap ?? 0, 18));
  }
  get kGuilderMarketCap() {
    return this.kGuilderCurrentPrice ? this.kGuilderCurrentPrice * this.numberService.fromString(Ve(this.kGuilderTotalSupply ?? 0, 18)) : 0;
  }
  async loadAssets() {
    const n = await this.getReserveContract(), e = n.address;
    if (!e)
      return;
    const t = (await Promise.all([
      n.allRegisteredERC20s().then((i) => i.map((s) => ({ tokenId: void 0, address: s }))),
      n.allRegisteredERC721Ids().then((i) => i.map((s) => ({ tokenId: s.id, address: s.erc721 })))
    ])).flatMap((i) => i);
    this.reserveAssets = (await Promise.all(t.map((i) => this.contractStore.getAsset(i.address, i.tokenId, n, e, this.transactions).catch()))).filter(Boolean), this.reserveAssets = await Promise.all(
      this.reserveAssets.map(async (i) => ({ ...i, type: await n.riskLevelOfERC20(i.token.address) }))
    ), this.loadkCurData();
    const r = await n.reserveStatus();
    this.reserveValue = r[0], this.kCurMarketCap = r[1], this.backing = r[2], this.minBacking = await n.minBacking();
  }
  async loadkCur() {
    if (await this.loadAssets(), await this.loadkCurData(), !this.kCurSupply)
      return;
    const n = this.numberService.fromString(Ve(this.kCurSupply, 18)), e = await this.contractService.getContract("monetary", "CuracaoReserveToken"), t = await this.contractService.getContract("monetary", "KolektivoMultiSig"), r = await e.balanceOf(t.address);
    this.kCurReserveDistribution = this.numberService.fromString(Ve(r, 18)) / n;
    const i = await this.contractService.getContract("monetary", "ProxyPool"), s = this.numberService.fromString(Ve(await i.ceilingMultiplier(), 4)), u = (await (await this.getReserveContract()).reserveStatus())[0], l = this.numberService.fromString(Ve(u, 18)) / this.numberService.fromString(Ve(this.kCurSupply, 18));
    this.kCurPriceFloor = l, this.kCurPriceCeiling = l * s;
    const d = await this.contractService.getContract("monetary", "MentoReserve"), p = await e.balanceOf(d.address);
    this.kCurMentoDistribution = this.numberService.fromString(Ve(p, 18)) / n, this.kCurPrimaryPoolDistribution = 0;
  }
  async loadkGuilder() {
    if (await this.loadkCurData(), this.kGuilderCurrentPrice = 0.558, !(await this.getReserveContract()).address)
      return;
    const t = await this.contractService.getContract("monetary", "KolektivoGuilder"), r = await t.totalSupply(), i = await this.contractService.getContract("monetary", "Exchange"), s = await i.spread(), o = await (await this.contractService.getContract("monetary", "MentoReserve")).tobinTax(), [u, l] = await i.getBuyAndSellBuckets(!0), d = (this.kCurPrice ?? 0) * this.numberService.fromString(Ve(l, 18)) / (this.kGuilderCurrentPrice * this.numberService.fromString(Ve(u, 18))), [p] = await t.getInflationParameters();
    this.kGuilderValueRatio = d, this.kGuilderTotalSupply = r, this.kGuilderSpread = this.numberService.fromString(Ve(s, 25)), this.kGuilderInflationRate = this.numberService.fromString(Ve(p, 25)), this.kGuilderTobinTax = this.numberService.fromString(Ve(o, 18)), this.kGuilderPriceParity = 0;
  }
  async loadkCurData() {
    if (this.kCurPrice || this.kCurSupply)
      return;
    const n = await this.getReserveContract(), e = await n.token();
    if (!e)
      return;
    const t = n.address;
    if (!t)
      return;
    const r = await n.tokenOracle();
    if (!r)
      return;
    const i = await this.contractStore.getAsset(e, void 0, n, t, void 0, r);
    this.kCurPrice = i?.token.price, this.kCurSupply = i?.totalSupply;
  }
  getReserveContract() {
    return this.contractService.getContract("monetary", "Reserve");
  }
  async getReserveValueOverTime(n) {
    const [e, t] = await Promise.all([this.getData("reserve", n), this.getReserveContract().then((r) => r.reserveStatus())]);
    return e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      value: t[0]
    }), e;
  }
  async getkGuilderValueRatioOverTime(n) {
    const [e] = await Promise.all([this.getData("kGuilder", n), this.loadkCurData(), this.loadkGuilder()]);
    return e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      value: this.kGuilderValueRatio
    }), e;
  }
  async getLeverageRatioValueOverTime(n) {
    const [e, [t, r]] = await Promise.all([
      this.getData("kCurRatio", n),
      this.getReserveContract().then((i) => Promise.all([i.reserveStatus(), i.minBacking()]))
    ]);
    return e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      currentLeverageRatio: this.calculateLeverage(t[2]),
      maxLeverageRatio: 1 / (this.numberService.fromString(Ve(r, 2)) / 100) * 100
    }), e;
  }
  async getkCurSupplyData(n) {
    const [e] = await Promise.all([this.getData("kCurSupply", n), this.loadkCur()]);
    return e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      kCurCirculatingDistribution: this.kCurCirculatingDistribution,
      kCurMentoDistribution: this.kCurMentoDistribution,
      kCurPrimaryPoolDistribution: this.kCurPrimaryPoolDistribution,
      kCurReserveDistribution: this.kCurReserveDistribution
    }), e;
  }
  async loadPrimaryPoolData() {
    const n = await this.symmetricService.indexVolumeAndFees();
    this.primaryPoolData = [
      {
        tokens: [
          { symbol: "kCUR", icon: "https://assets.website-files.com/5fcaa3a6fcb269f7778d1f87/60a957ee7011916564689917_LOGO_MARK_color.svg" },
          { symbol: "cUSD", icon: "https://assets.coingecko.com/coins/images/6319/thumb/USD_Coin_icon.png?1547042389" }
        ],
        fees: Number(n.swapFeeParsed),
        tvl: Number(n.tvl),
        volume: Number(n.volumeParsed)
      }
    ];
  }
  async getkCurPriceOverTime(n) {
    const [e] = await Promise.all([this.getData("kCurPrice", n), this.loadkCurData(), this.loadAssets(), this.loadkCur()]);
    return e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      kCurPrice: this.kCurPrice,
      kCurPriceCeiling: this.kCurPriceCeiling,
      kCurPriceFloor: this.kCurPriceFloor
    }), e;
  }
  get lowRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === Iu.Low) ?? [];
  }
  get moderateRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === Iu.Medium) ?? [];
  }
  get highRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === Iu.High) ?? [];
  }
  async getRiskOverTime(n) {
    const [e, [t, r]] = await Promise.all([
      this.getData("risk", n),
      this.getReserveContract().then((i) => Promise.all([i.reserveStatus(), i.minBacking()])),
      this.loadAssets()
    ]);
    return this.kCurMarketCap = t[1], this.minBacking = r, e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      minCollateralValue: this.minCollateralizationValue,
      marketCap: (this.kCurPrice ?? 0) * this.numberService.fromString(Ve(this.kCurSupply ?? 0, 18)),
      lowRisk: this.lowRiskAssets.map((i) => i.total).sum(),
      moderateRisk: this.moderateRiskAssets.map((i) => i.total).sum(),
      highRisk: this.highRiskAssets.map((i) => i.total).sum()
    }), e;
  }
  async getData(n, e) {
    const t = yT(e), r = await this.dataStore.getDocs(`${this.configuration.firebaseCollection}/${n}/${hT(e)}`, "createdAt", "desc", {
      fieldPath: "createdAt",
      opStr: ">=",
      value: t
    });
    return r.sort((i, s) => new Date(i.createdAt).getTime() - new Date(s.createdAt).getTime()), r;
  }
  calculateLeverage(n) {
    return 1 / this.numberService.fromString(Ve(n, 4)) * 100;
  }
};
Af([
  Tf()
], Aa.prototype, "loadAssets", 1);
Af([
  Tf()
], Aa.prototype, "loadkCur", 1);
Af([
  Tf()
], Aa.prototype, "loadkGuilder", 1);
Aa = Af([
  Ka(0, Wy),
  Ka(1, Jo),
  Ka(2, Fl),
  Ka(3, By),
  Ka(4, Cs),
  Ka(5, Ky)
], Aa);
var OO = Object.defineProperty, kO = Object.getOwnPropertyDescriptor, TT = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? kO(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && OO(e, t, i), i;
}, lu = (n, e) => (t, r) => e(t, r, n);
const NO = me.createInterface("TreasuryStore");
let ll = class {
  constructor(n, e, t, r, i) {
    this.numberService = n, this.contractStore = e, this.contractService = t, this.configuration = r, this.dataStore = i;
  }
  totalSupply;
  totalValuation;
  treasuryDistribution;
  reservesDistribution;
  treasuryContract;
  lastRebaseTime;
  treasuryAssets = [];
  transactions = [];
  static register(n) {
    n.register(be.singleton(NO, ll));
  }
  get treasuryValue() {
    return this.treasuryAssets?.length === 0 ? 0 : this.treasuryAssets?.map((n) => n?.total ?? 0).sum() ?? 0;
  }
  async loadTokenData() {
    if (this.totalValuation && this.totalSupply)
      return;
    const n = await this.getTreasuryContract();
    this.totalValuation = await n.totalValuation(), this.totalSupply = await n.totalSupply(), this.treasuryDistribution = (await this.getDistributionPercentage("Treasury")).toNumber(), this.reservesDistribution = (await this.getDistributionPercentage("Reserve")).toNumber();
  }
  async loadAssets() {
    const n = await this.getTreasuryContract(), e = n.address;
    if (!e)
      return;
    const t = (await Promise.all([
      n.allRegisteredERC20s().then((r) => r.map((i) => ({ tokenId: void 0, address: i }))),
      n.allRegisteredERC721Ids().then((r) => r.map((i) => ({ tokenId: i.id, address: i.erc721 })))
    ])).flatMap((r) => r);
    this.treasuryAssets = (await Promise.all(t.map((r) => this.contractStore.getAsset(r.address, r.tokenId, n, e, this.transactions).catch()))).filter(Boolean);
  }
  async getValueOverTime(n) {
    const e = yT(n), r = (await this.dataStore.getDocs(`${this.configuration.firebaseCollection}/ktt/${hT(n)}`, "createdAt", "desc", {
      fieldPath: "createdAt",
      opStr: ">=",
      value: e
    })).map((a) => ({
      createdAt: Number(new Date(a.createdAt)),
      value: this.numberService.fromString(Ve(a.value, 18))
    }));
    r.sort((a, o) => new Date(a.createdAt).getTime() - new Date(o.createdAt).getTime());
    const s = await (await this.getTreasuryContract()).totalValuation();
    return r.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      value: this.numberService.fromString(Ve(s, 18))
    }), r;
  }
  async getLastRebaseTime() {
    const n = await this.getTreasuryContract(), e = await n.queryFilter(n.filters.Rebase());
    e.sort((t, r) => r.blockNumber - t.blockNumber), this.lastRebaseTime = e[0] && new Date((await e[0].getBlock()).timestamp * 1e3);
  }
  get circulatingDistribution() {
    return this.treasuryDistribution == null || this.reservesDistribution == null ? 0 : 1 - (this.treasuryDistribution + this.reservesDistribution);
  }
  get currentPrice() {
    return !this.totalSupply || !this.totalValuation ? 0 : Number(Ve(this.totalSupply, 18)) / Number(Ve(this.totalValuation, 18));
  }
  async getTreasuryContract() {
    return this.treasuryContract ? this.treasuryContract : (this.treasuryContract = await this.contractService.getContract("monetary", "Treasury"), this.treasuryContract);
  }
  async getDistributionPercentage(n) {
    const e = (await this.contractService.getContract("monetary", n)).address;
    return !e || !this.totalSupply ? H.from(0) : (await (await this.getTreasuryContract()).balanceOf(e)).div(this.totalSupply);
  }
};
TT([
  Tf()
], ll.prototype, "loadAssets", 1);
ll = TT([
  lu(0, Fl),
  lu(1, Wy),
  lu(2, Jo),
  lu(3, Cs),
  lu(4, Ky)
], ll);
var DO = Object.defineProperty, BO = Object.getOwnPropertyDescriptor, FO = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? BO(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && DO(e, t, i), i;
}, LO = (n, e) => (t, r) => e(t, r, n);
const $O = me.createInterface();
let y2 = class {
  constructor(n) {
    this.walletConnector = n;
  }
  provider;
  async connect(n) {
    this.provider = n ? await this.walletConnector.connectTo(n) : await this.walletConnector.connect();
  }
};
y2 = FO([
  LO(0, qy)
], y2);
const UO = new D("CeloNetworks"), m2 = [
  {
    name: "celo",
    chainId: 42220
  },
  {
    name: "alfajores",
    chainId: 44787
  },
  {
    name: "baklava",
    chainId: 62320
  }
];
function qh(n) {
  {
    if (n == null)
      return null;
    if (typeof n == "number") {
      const e = m2.filter((t) => t.chainId === n);
      return e.length ? { name: e[0].name, chainId: e[0].chainId } : {
        name: "unknown",
        chainId: n
      };
    }
    if (typeof n == "string") {
      const e = m2.filter((t) => t.name === n);
      return e.length ? { name: e[0].name, chainId: e[0].chainId } : null;
    }
    if (typeof n.name == "string" && typeof n.chainId == "number") {
      const e = qh(n.name), t = qh(n.chainId);
      if (e == null && t == null)
        return {
          name: n.name,
          chainId: n.chainId
        };
      if (e && t && e.name === t.name && e.chainId === t.chainId)
        return e;
    }
    return UO.throwArgumentError("network chainId mismatch", "network", n);
  }
}
const jO = new D("celo/transactions");
function VO(n) {
  const e = kl(n);
  e.length !== 12 && e.length !== 9 && jO.throwArgumentError("invalid raw transaction", "rawTransaction", n);
  const t = {
    nonce: cu(e[0]).toNumber(),
    gasPrice: cu(e[1]),
    gasLimit: cu(e[2]),
    feeCurrency: jp(e[3]),
    gatewayFeeRecipient: jp(e[4]),
    gatewayFee: cu(e[5]),
    to: jp(e[6]),
    value: cu(e[7]),
    data: e[8],
    chainId: 0
  };
  if (e.length === 9)
    return t;
  try {
    t.v = H.from(e[9]).toNumber();
  } catch (r) {
    return console.log(r), t;
  }
  if (t.r = Le(e[10], 32), t.s = Le(e[11], 32), H.from(t.r).isZero() && H.from(t.s).isZero())
    t.chainId = t.v, t.v = 0;
  else {
    t.chainId = Math.floor((t.v - 35) / 2), t.chainId < 0 && (t.chainId = 0);
    let r = t.v - 27;
    const i = e.slice(0, 6);
    t.chainId !== 0 && (i.push(J(t.chainId)), i.push("0x"), i.push("0x"), r -= t.chainId * 2 + 8);
    const s = De(vs(i));
    try {
      t.from = Wo(s, {
        r: J(t.r),
        s: J(t.s),
        recoveryParam: r
      });
    } catch (a) {
      console.log(a);
    }
    t.hash = De(n);
  }
  return t;
}
function jp(n) {
  if (n !== "0x")
    try {
      return Fe(n);
    } catch {
      return n;
    }
}
function cu(n) {
  return n === "0x" ? fy : H.from(n);
}
const zO = new D("CeloProvider");
class GO extends U9 {
  constructor(e, t) {
    super(e, t);
    const r = this.formatter.formats.block;
    r.gasLimit = () => H.from(0), r.nonce = () => "", r.difficulty = () => 0;
    const i = this.formatter.formats.blockWithTransactions;
    i.gasLimit = () => H.from(0), i.nonce = () => "", i.difficulty = () => 0;
  }
  /**
   * Override to parse transaction correctly
   * https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/base-provider.ts
   */
  async sendTransaction(e) {
    await this.getNetwork();
    const t = await Promise.resolve(e), r = J(t), i = VO(t);
    try {
      const s = await this.perform("sendTransaction", {
        signedTransaction: r
      });
      return this._wrapTransaction(i, s);
    } catch (s) {
      throw s.transaction = i, s.transactionHash = i.hash, s;
    }
  }
  /**
   * Override to handle alternative gas currencies
   * getGasPrice in https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/base-provider.ts
   */
  async getGasPrice(e) {
    await this.getNetwork();
    const t = e ? { feeCurrencyAddress: e } : {};
    return H.from(await this.perform("getGasPrice", t));
  }
  /**
   * Override to handle alternative gas currencies
   * prepareRequest in https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts
   */
  prepareRequest(e, t) {
    return e === "getGasPrice" ? ["eth_gasPrice", t.feeCurrencyAddress ? [t.feeCurrencyAddress] : []] : super.prepareRequest(e, t);
  }
  static getNetwork(e) {
    const t = qh(e ?? "celo");
    return t ?? zO.throwError(`unknown network: ${JSON.stringify(t)}`, D.errors.UNSUPPORTED_OPERATION, {
      operation: "getNetwork",
      value: e
    });
  }
}
D.errors.INSUFFICIENT_FUNDS, D.errors.NONCE_EXPIRED, D.errors.REPLACEMENT_UNDERPRICED;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const AT = function(n) {
  const e = [];
  let t = 0;
  for (let r = 0; r < n.length; r++) {
    let i = n.charCodeAt(r);
    i < 128 ? e[t++] = i : i < 2048 ? (e[t++] = i >> 6 | 192, e[t++] = i & 63 | 128) : (i & 64512) === 55296 && r + 1 < n.length && (n.charCodeAt(r + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (n.charCodeAt(++r) & 1023), e[t++] = i >> 18 | 240, e[t++] = i >> 12 & 63 | 128, e[t++] = i >> 6 & 63 | 128, e[t++] = i & 63 | 128) : (e[t++] = i >> 12 | 224, e[t++] = i >> 6 & 63 | 128, e[t++] = i & 63 | 128);
  }
  return e;
}, HO = function(n) {
  const e = [];
  let t = 0, r = 0;
  for (; t < n.length; ) {
    const i = n[t++];
    if (i < 128)
      e[r++] = String.fromCharCode(i);
    else if (i > 191 && i < 224) {
      const s = n[t++];
      e[r++] = String.fromCharCode((i & 31) << 6 | s & 63);
    } else if (i > 239 && i < 365) {
      const s = n[t++], a = n[t++], o = n[t++], u = ((i & 7) << 18 | (s & 63) << 12 | (a & 63) << 6 | o & 63) - 65536;
      e[r++] = String.fromCharCode(55296 + (u >> 10)), e[r++] = String.fromCharCode(56320 + (u & 1023));
    } else {
      const s = n[t++], a = n[t++];
      e[r++] = String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | a & 63);
    }
  }
  return e.join("");
}, ET = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(n, e) {
    if (!Array.isArray(n))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const t = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, r = [];
    for (let i = 0; i < n.length; i += 3) {
      const s = n[i], a = i + 1 < n.length, o = a ? n[i + 1] : 0, u = i + 2 < n.length, l = u ? n[i + 2] : 0, d = s >> 2, p = (s & 3) << 4 | o >> 4;
      let m = (o & 15) << 2 | l >> 6, w = l & 63;
      u || (w = 64, a || (m = 64)), r.push(t[d], t[p], t[m], t[w]);
    }
    return r.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(n, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? btoa(n) : this.encodeByteArray(AT(n), e);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(n, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? atob(n) : HO(this.decodeStringToByteArray(n, e));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(n, e) {
    this.init_();
    const t = e ? this.charToByteMapWebSafe_ : this.charToByteMap_, r = [];
    for (let i = 0; i < n.length; ) {
      const s = t[n.charAt(i++)], o = i < n.length ? t[n.charAt(i)] : 0;
      ++i;
      const l = i < n.length ? t[n.charAt(i)] : 64;
      ++i;
      const p = i < n.length ? t[n.charAt(i)] : 64;
      if (++i, s == null || o == null || l == null || p == null)
        throw new qO();
      const m = s << 2 | o >> 4;
      if (r.push(m), l !== 64) {
        const w = o << 4 & 240 | l >> 2;
        if (r.push(w), p !== 64) {
          const x = l << 6 & 192 | p;
          r.push(x);
        }
      }
    }
    return r;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let n = 0; n < this.ENCODED_VALS.length; n++)
        this.byteToCharMap_[n] = this.ENCODED_VALS.charAt(n), this.charToByteMap_[this.byteToCharMap_[n]] = n, this.byteToCharMapWebSafe_[n] = this.ENCODED_VALS_WEBSAFE.charAt(n), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[n]] = n, n >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(n)] = n, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(n)] = n);
    }
  }
};
class qO extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const WO = function(n) {
  const e = AT(n);
  return ET.encodeByteArray(e, !0);
}, Rd = function(n) {
  return WO(n).replace(/\./g, "");
}, KO = function(n) {
  try {
    return ET.decodeString(n, !0);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function JO() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof ba < "u")
    return ba;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const QO = () => JO().__FIREBASE_DEFAULTS__, YO = () => {
  if (typeof Rc > "u" || typeof { ALLUSERSPROFILE: "C:\\ProgramData", AMDRMPATH: "C:\\Program Files\\AMD\\RyzenMaster\\", ANDROID_HOME: "C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk", APPDATA: "C:\\Users\\Brandon\\AppData\\Roaming", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\LOCAL\\crashpad_69816_UMDFRXVUQLXCAMHW", CLASSPATH: ".;", COLOR: "1", COLORTERM: "truecolor", COMMONPROGRAMFILES: "C:\\Program Files\\Common Files", COMPUTERNAME: "DESKTOP-72OQKP6", COMSPEC: "C:\\WINDOWS\\system32\\cmd.exe", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "133168882361134091", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\WINDOWS\\notepad.exe", EXEPATH: "C:\\Program Files\\Git\\bin", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", GIT_ASKPASS: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", HOME: "C:\\Users\\Brandon", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\Brandon", INIT_CWD: "C:\\Users\\Brandon\\source\\repos\\dapp\\scripts\\update-chart-data", INTEL_DEV_REDIST: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\", JAVA_HOME: "C:\\Program Files\\Microsoft\\jdk-11.0.17.8-hotspot\\", LANG: "en_US.UTF-8", LOCALAPPDATA: "C:\\Users\\Brandon\\AppData\\Local", LOGONSERVER: "\\\\DESKTOP-72OQKP6", MIC_LD_LIBRARY_PATH: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\compiler\\lib\\mic", MSYSTEM: "MINGW64", MYSQLCONNECTOR_ASSEMBLIESPATH: "C:\\Program Files (x86)\\MySQL\\Connector NET 8.0\\Assemblies\\v4.5.2", NODE: "C:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NUMBER_OF_PROCESSORS: "32", NVM_HOME: "C:\\Users\\Brandon\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", OcpApimSubscriptionKey: "15752dea34354b65bb7b54bca0da1b8d", OneDrive: "C:\\Users\\Brandon\\OneDrive - Grey & Co Salon", PATH: "C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\Brandon\\bin;C:\\Users\\Brandon\\source\\repos\\dapp\\node_modules\\.bin;C:\\Users\\Brandon\\source\\repos\\node_modules\\.bin;C:\\Users\\Brandon\\source\\node_modules\\.bin;C:\\Users\\Brandon\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Microsoft\\jdk-11.0.17.8-hotspot\\bin;C:\\Program Files\\Microsoft\\jdk-17.0.5.8-hotspot\\bin;C:\\Program Files\\Common Files\\Oracle\\Java\\javapath;C:\\Program Files (x86)\\Razer Chroma SDK\\bin;C:\\Program Files\\Razer Chroma SDK\\bin;C:\\Program Files (x86)\\Razer\\ChromaBroadcast\\bin;C:\\Program Files\\Razer\\ChromaBroadcast\\bin;C:\\Python39\\Scripts;C:\\Python39;C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\redist\\intel64\\compiler;C:\\Python27;C:\\Python27\\Scripts;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\Program Files\\dotnet;C:\\Program Files\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\130\\Tools\\Binn;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\130\\DTS\\Binn;C:\\WINDOWS\\System32\\OpenSSH;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn;C:\\Program Files\\Microsoft VS Code Insiders\\bin;C:\\Program Files\\Java\\jdk1.8.0_231\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\platform-tools;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\DTS\\Binn;C:\\Program Files\\gradle-6.3\\bin;C:\\flutter\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\tools;C:\\Program Files\\MongoDB\\Server\\4.2\\bin;C:\\Program Files\\Microsoft\\Azure Functions Core Tools;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHu;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\npm;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\L;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files (x8;C:\\Program Files (x86)\\dotnet;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Program Files\\Git\\cmd;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\WINDOWS\\System32\\OpenSSH;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\ProgramData\\DockerDesktop\\version-bin;C:\\Program Files\\Amazon\\AWSCLIV2;C:\\Program Files (x86)\\dotnet-core-uninstall;C:\\Program Files\\Azure Data Studio\\bin;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Brandon\\AppData\\Local\\pnpm;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Users\\Brandon\\AppData\\Local\\JetBrains\\Toolbox\\scripts;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\.dotnet\\tools;C:\\ProgramData\\chocolatey\\lib\\deno;C:\\Program Files\\Azure Data Studio\\bin;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW;.CPL", PLINK_PROTOCOL: "ssh", PNPM_HOME: "C:\\Users\\Brandon\\AppData\\Local\\pnpm", PREFERRED_WORKSPACE_MANAGER: "yarn", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "AMD64 Family 23 Model 113 Stepping 0, AuthenticAMD", PROCESSOR_LEVEL: "23", PROCESSOR_REVISION: "7100", PROGRAMFILES: "C:\\Program Files", PSModulePath: "C:\\Users\\Brandon\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\PowerShell\\Modules\\", PUBLIC: "C:\\Users\\Public", PWD: "C:/Users/Brandon/source/repos/dapp", ProgramData: "C:\\ProgramData", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", SESSIONNAME: "Console", SHLVL: "0", SYSTEMDRIVE: "C:", SYSTEMROOT: "C:\\WINDOWS", TEMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", TERM: "xterm-256color", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.78.0", TMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", USERDOMAIN: "DESKTOP-72OQKP6", USERDOMAIN_ROAMINGPROFILE: "DESKTOP-72OQKP6", USERNAME: "Brandon", USERPROFILE: "C:\\Users\\Brandon", VS160PROCOMNTOOLS: "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\Common7\\Tools\\", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node", VSCODE_GIT_ASKPASS_MAIN: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-b178cbeab5-sock", VSCODE_INJECTION: "1", WINDIR: "C:\\WINDOWS", "asl.log": "Destination=file", npm_command: "run-script", npm_config_cache: "C:\\Users\\Brandon\\AppData\\Local\\npm-cache", npm_config_global_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_globalconfig: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\etc\\npmrc", npm_config_init_module: "C:\\Users\\Brandon\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\Brandon\\source\\repos\\dapp", npm_config_metrics_registry: "https://registry.npmjs.org/", npm_config_node_gyp: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_script_shell: "C:\\Program Files\\git\\bin\\bash.exe", npm_config_shamefully_hoist: "true", npm_config_user_agent: "npm/9.6.5 node/v20.0.0 win32 x64 workspaces/false", npm_config_userconfig: "C:\\Users\\Brandon\\.npmrc", npm_execpath: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build:chart-data-script", npm_lifecycle_script: "vite build --config vite.config-lib.ts", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_engines_node: ">=16.0.0", npm_package_json: "C:\\Users\\Brandon\\source\\repos\\dapp\\package.json", npm_package_name: "@kolektivo/dapp", npm_package_version: "1.0.0" } > "u")
    return;
  const n = { ALLUSERSPROFILE: "C:\\ProgramData", AMDRMPATH: "C:\\Program Files\\AMD\\RyzenMaster\\", ANDROID_HOME: "C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk", APPDATA: "C:\\Users\\Brandon\\AppData\\Roaming", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\LOCAL\\crashpad_69816_UMDFRXVUQLXCAMHW", CLASSPATH: ".;", COLOR: "1", COLORTERM: "truecolor", COMMONPROGRAMFILES: "C:\\Program Files\\Common Files", COMPUTERNAME: "DESKTOP-72OQKP6", COMSPEC: "C:\\WINDOWS\\system32\\cmd.exe", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "133168882361134091", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\WINDOWS\\notepad.exe", EXEPATH: "C:\\Program Files\\Git\\bin", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", GIT_ASKPASS: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", HOME: "C:\\Users\\Brandon", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\Brandon", INIT_CWD: "C:\\Users\\Brandon\\source\\repos\\dapp\\scripts\\update-chart-data", INTEL_DEV_REDIST: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\", JAVA_HOME: "C:\\Program Files\\Microsoft\\jdk-11.0.17.8-hotspot\\", LANG: "en_US.UTF-8", LOCALAPPDATA: "C:\\Users\\Brandon\\AppData\\Local", LOGONSERVER: "\\\\DESKTOP-72OQKP6", MIC_LD_LIBRARY_PATH: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\compiler\\lib\\mic", MSYSTEM: "MINGW64", MYSQLCONNECTOR_ASSEMBLIESPATH: "C:\\Program Files (x86)\\MySQL\\Connector NET 8.0\\Assemblies\\v4.5.2", NODE: "C:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NUMBER_OF_PROCESSORS: "32", NVM_HOME: "C:\\Users\\Brandon\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", OcpApimSubscriptionKey: "15752dea34354b65bb7b54bca0da1b8d", OneDrive: "C:\\Users\\Brandon\\OneDrive - Grey & Co Salon", PATH: "C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\Brandon\\bin;C:\\Users\\Brandon\\source\\repos\\dapp\\node_modules\\.bin;C:\\Users\\Brandon\\source\\repos\\node_modules\\.bin;C:\\Users\\Brandon\\source\\node_modules\\.bin;C:\\Users\\Brandon\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Microsoft\\jdk-11.0.17.8-hotspot\\bin;C:\\Program Files\\Microsoft\\jdk-17.0.5.8-hotspot\\bin;C:\\Program Files\\Common Files\\Oracle\\Java\\javapath;C:\\Program Files (x86)\\Razer Chroma SDK\\bin;C:\\Program Files\\Razer Chroma SDK\\bin;C:\\Program Files (x86)\\Razer\\ChromaBroadcast\\bin;C:\\Program Files\\Razer\\ChromaBroadcast\\bin;C:\\Python39\\Scripts;C:\\Python39;C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\redist\\intel64\\compiler;C:\\Python27;C:\\Python27\\Scripts;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\Program Files\\dotnet;C:\\Program Files\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\130\\Tools\\Binn;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\130\\DTS\\Binn;C:\\WINDOWS\\System32\\OpenSSH;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn;C:\\Program Files\\Microsoft VS Code Insiders\\bin;C:\\Program Files\\Java\\jdk1.8.0_231\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\platform-tools;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\DTS\\Binn;C:\\Program Files\\gradle-6.3\\bin;C:\\flutter\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\tools;C:\\Program Files\\MongoDB\\Server\\4.2\\bin;C:\\Program Files\\Microsoft\\Azure Functions Core Tools;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHu;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\npm;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\L;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files (x8;C:\\Program Files (x86)\\dotnet;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Program Files\\Git\\cmd;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\WINDOWS\\System32\\OpenSSH;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\ProgramData\\DockerDesktop\\version-bin;C:\\Program Files\\Amazon\\AWSCLIV2;C:\\Program Files (x86)\\dotnet-core-uninstall;C:\\Program Files\\Azure Data Studio\\bin;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Brandon\\AppData\\Local\\pnpm;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Users\\Brandon\\AppData\\Local\\JetBrains\\Toolbox\\scripts;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\.dotnet\\tools;C:\\ProgramData\\chocolatey\\lib\\deno;C:\\Program Files\\Azure Data Studio\\bin;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW;.CPL", PLINK_PROTOCOL: "ssh", PNPM_HOME: "C:\\Users\\Brandon\\AppData\\Local\\pnpm", PREFERRED_WORKSPACE_MANAGER: "yarn", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "AMD64 Family 23 Model 113 Stepping 0, AuthenticAMD", PROCESSOR_LEVEL: "23", PROCESSOR_REVISION: "7100", PROGRAMFILES: "C:\\Program Files", PSModulePath: "C:\\Users\\Brandon\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\PowerShell\\Modules\\", PUBLIC: "C:\\Users\\Public", PWD: "C:/Users/Brandon/source/repos/dapp", ProgramData: "C:\\ProgramData", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", SESSIONNAME: "Console", SHLVL: "0", SYSTEMDRIVE: "C:", SYSTEMROOT: "C:\\WINDOWS", TEMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", TERM: "xterm-256color", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.78.0", TMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", USERDOMAIN: "DESKTOP-72OQKP6", USERDOMAIN_ROAMINGPROFILE: "DESKTOP-72OQKP6", USERNAME: "Brandon", USERPROFILE: "C:\\Users\\Brandon", VS160PROCOMNTOOLS: "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\Common7\\Tools\\", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node", VSCODE_GIT_ASKPASS_MAIN: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-b178cbeab5-sock", VSCODE_INJECTION: "1", WINDIR: "C:\\WINDOWS", "asl.log": "Destination=file", npm_command: "run-script", npm_config_cache: "C:\\Users\\Brandon\\AppData\\Local\\npm-cache", npm_config_global_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_globalconfig: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\etc\\npmrc", npm_config_init_module: "C:\\Users\\Brandon\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\Brandon\\source\\repos\\dapp", npm_config_metrics_registry: "https://registry.npmjs.org/", npm_config_node_gyp: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_script_shell: "C:\\Program Files\\git\\bin\\bash.exe", npm_config_shamefully_hoist: "true", npm_config_user_agent: "npm/9.6.5 node/v20.0.0 win32 x64 workspaces/false", npm_config_userconfig: "C:\\Users\\Brandon\\.npmrc", npm_execpath: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build:chart-data-script", npm_lifecycle_script: "vite build --config vite.config-lib.ts", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_engines_node: ">=16.0.0", npm_package_json: "C:\\Users\\Brandon\\source\\repos\\dapp\\package.json", npm_package_name: "@kolektivo/dapp", npm_package_version: "1.0.0" }.__FIREBASE_DEFAULTS__;
  if (n)
    return JSON.parse(n);
}, XO = () => {
  if (typeof document > "u")
    return;
  let n;
  try {
    n = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const e = n && KO(n[1]);
  return e && JSON.parse(e);
}, ST = () => {
  try {
    return QO() || YO() || XO();
  } catch (n) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${n}`);
    return;
  }
}, ZO = (n) => {
  var e, t;
  return (t = (e = ST()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || t === void 0 ? void 0 : t[n];
}, ek = (n) => {
  const e = ZO(n);
  if (!e)
    return;
  const t = e.lastIndexOf(":");
  if (t <= 0 || t + 1 === e.length)
    throw new Error(`Invalid host ${e} with no separate hostname and port!`);
  const r = parseInt(e.substring(t + 1), 10);
  return e[0] === "[" ? [e.substring(1, t - 1), r] : [e.substring(0, t), r];
}, tk = () => {
  var n;
  return (n = ST()) === null || n === void 0 ? void 0 : n.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class nk {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
  /**
   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(e) {
    return (t, r) => {
      t ? this.reject(t) : this.resolve(r), typeof e == "function" && (this.promise.catch(() => {
      }), e.length === 1 ? e(t) : e(t, r));
    };
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function rk(n, e) {
  if (n.uid)
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  const t = {
    alg: "none",
    type: "JWT"
  }, r = e || "demo-project", i = n.iat || 0, s = n.sub || n.user_id;
  if (!s)
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  const a = Object.assign({
    // Set all required fields to decent defaults
    iss: `https://securetoken.google.com/${r}`,
    aud: r,
    iat: i,
    exp: i + 3600,
    auth_time: i,
    sub: s,
    user_id: s,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, n), o = "";
  return [
    Rd(JSON.stringify(t)),
    Rd(JSON.stringify(a)),
    o
  ].join(".");
}
function ik() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function sk() {
  return new Promise((n, e) => {
    try {
      let t = !0;
      const r = "validate-browser-context-for-indexeddb-analytics-module", i = self.indexedDB.open(r);
      i.onsuccess = () => {
        i.result.close(), t || self.indexedDB.deleteDatabase(r), n(!0);
      }, i.onupgradeneeded = () => {
        t = !1;
      }, i.onerror = () => {
        var s;
        e(((s = i.error) === null || s === void 0 ? void 0 : s.message) || "");
      };
    } catch (t) {
      e(t);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ak = "FirebaseError";
class Qo extends Error {
  constructor(e, t, r) {
    super(t), this.code = e, this.customData = r, this.name = ak, Object.setPrototypeOf(this, Qo.prototype), Error.captureStackTrace && Error.captureStackTrace(this, CT.prototype.create);
  }
}
class CT {
  constructor(e, t, r) {
    this.service = e, this.serviceName = t, this.errors = r;
  }
  create(e, ...t) {
    const r = t[0] || {}, i = `${this.service}/${e}`, s = this.errors[e], a = s ? ok(s, r) : "Error", o = `${this.serviceName}: ${a} (${i}).`;
    return new Qo(i, o, r);
  }
}
function ok(n, e) {
  return n.replace(uk, (t, r) => {
    const i = e[r];
    return i != null ? String(i) : `<${r}?>`;
  });
}
const uk = /\{\$([^}]+)}/g;
function Wh(n, e) {
  if (n === e)
    return !0;
  const t = Object.keys(n), r = Object.keys(e);
  for (const i of t) {
    if (!r.includes(i))
      return !1;
    const s = n[i], a = e[i];
    if (b2(s) && b2(a)) {
      if (!Wh(s, a))
        return !1;
    } else if (s !== a)
      return !1;
  }
  for (const i of r)
    if (!t.includes(i))
      return !1;
  return !0;
}
function b2(n) {
  return n !== null && typeof n == "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function oi(n) {
  return n && n._delegate ? n._delegate : n;
}
class cl {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(e, t, r) {
    this.name = e, this.instanceFactory = t, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(e) {
    return this.instantiationMode = e, this;
  }
  setMultipleInstances(e) {
    return this.multipleInstances = e, this;
  }
  setServiceProps(e) {
    return this.serviceProps = e, this;
  }
  setInstanceCreatedCallback(e) {
    return this.onInstanceCreated = e, this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ta = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lk {
  constructor(e, t) {
    this.name = e, this.container = t, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide mulitple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(e) {
    const t = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(t)) {
      const r = new nk();
      if (this.instancesDeferred.set(t, r), this.isInitialized(t) || this.shouldAutoInitialize())
        try {
          const i = this.getOrInitializeService({
            instanceIdentifier: t
          });
          i && r.resolve(i);
        } catch {
        }
    }
    return this.instancesDeferred.get(t).promise;
  }
  getImmediate(e) {
    var t;
    const r = this.normalizeInstanceIdentifier(e?.identifier), i = (t = e?.optional) !== null && t !== void 0 ? t : !1;
    if (this.isInitialized(r) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: r
        });
      } catch (s) {
        if (i)
          return null;
        throw s;
      }
    else {
      if (i)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name)
      throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = e, !!this.shouldAutoInitialize()) {
      if (dk(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: ta });
        } catch {
        }
      for (const [t, r] of this.instancesDeferred.entries()) {
        const i = this.normalizeInstanceIdentifier(t);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: i
          });
          r.resolve(s);
        } catch {
        }
      }
    }
  }
  clearInstance(e = ta) {
    this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const e = Array.from(this.instances.values());
    await Promise.all([
      ...e.filter((t) => "INTERNAL" in t).map((t) => t.INTERNAL.delete()),
      ...e.filter((t) => "_delete" in t).map((t) => t._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(e = ta) {
    return this.instances.has(e);
  }
  getOptions(e = ta) {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    const { options: t = {} } = e, r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(r))
      throw Error(`${this.name}(${r}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const i = this.getOrInitializeService({
      instanceIdentifier: r,
      options: t
    });
    for (const [s, a] of this.instancesDeferred.entries()) {
      const o = this.normalizeInstanceIdentifier(s);
      r === o && a.resolve(i);
    }
    return i;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(e, t) {
    var r;
    const i = this.normalizeInstanceIdentifier(t), s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : /* @__PURE__ */ new Set();
    s.add(e), this.onInitCallbacks.set(i, s);
    const a = this.instances.get(i);
    return a && e(a, i), () => {
      s.delete(e);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(e, t) {
    const r = this.onInitCallbacks.get(t);
    if (r)
      for (const i of r)
        try {
          i(e, t);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: e, options: t = {} }) {
    let r = this.instances.get(e);
    if (!r && this.component && (r = this.component.instanceFactory(this.container, {
      instanceIdentifier: ck(e),
      options: t
    }), this.instances.set(e, r), this.instancesOptions.set(e, t), this.invokeOnInitCallbacks(r, e), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, e, r);
      } catch {
      }
    return r || null;
  }
  normalizeInstanceIdentifier(e = ta) {
    return this.component ? this.component.multipleInstances ? e : ta : e;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function ck(n) {
  return n === ta ? void 0 : n;
}
function dk(n) {
  return n.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fk {
  constructor(e) {
    this.name = e, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(e) {
    const t = this.getProvider(e.name);
    if (t.isComponentSet())
      throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
    t.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(e) {
    if (this.providers.has(e))
      return this.providers.get(e);
    const t = new lk(e, this);
    return this.providers.set(e, t), t;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var $e;
(function(n) {
  n[n.DEBUG = 0] = "DEBUG", n[n.VERBOSE = 1] = "VERBOSE", n[n.INFO = 2] = "INFO", n[n.WARN = 3] = "WARN", n[n.ERROR = 4] = "ERROR", n[n.SILENT = 5] = "SILENT";
})($e || ($e = {}));
const pk = {
  debug: $e.DEBUG,
  verbose: $e.VERBOSE,
  info: $e.INFO,
  warn: $e.WARN,
  error: $e.ERROR,
  silent: $e.SILENT
}, hk = $e.INFO, yk = {
  [$e.DEBUG]: "log",
  [$e.VERBOSE]: "log",
  [$e.INFO]: "info",
  [$e.WARN]: "warn",
  [$e.ERROR]: "error"
}, mk = (n, e, ...t) => {
  if (e < n.logLevel)
    return;
  const r = (/* @__PURE__ */ new Date()).toISOString(), i = yk[e];
  if (i)
    console[i](`[${r}]  ${n.name}:`, ...t);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
};
class _T {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(e) {
    this.name = e, this._logLevel = hk, this._logHandler = mk, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(e) {
    if (!(e in $e))
      throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
    this._logLevel = e;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(e) {
    this._logLevel = typeof e == "string" ? pk[e] : e;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(e) {
    if (typeof e != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = e;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(e) {
    this._userLogHandler = e;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.DEBUG, ...e), this._logHandler(this, $e.DEBUG, ...e);
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.VERBOSE, ...e), this._logHandler(this, $e.VERBOSE, ...e);
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.INFO, ...e), this._logHandler(this, $e.INFO, ...e);
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.WARN, ...e), this._logHandler(this, $e.WARN, ...e);
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.ERROR, ...e), this._logHandler(this, $e.ERROR, ...e);
  }
}
const bk = (n, e) => e.some((t) => n instanceof t);
let g2, x2;
function gk() {
  return g2 || (g2 = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function xk() {
  return x2 || (x2 = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const MT = /* @__PURE__ */ new WeakMap(), Kh = /* @__PURE__ */ new WeakMap(), PT = /* @__PURE__ */ new WeakMap(), Vp = /* @__PURE__ */ new WeakMap(), Jy = /* @__PURE__ */ new WeakMap();
function vk(n) {
  const e = new Promise((t, r) => {
    const i = () => {
      n.removeEventListener("success", s), n.removeEventListener("error", a);
    }, s = () => {
      t(hs(n.result)), i();
    }, a = () => {
      r(n.error), i();
    };
    n.addEventListener("success", s), n.addEventListener("error", a);
  });
  return e.then((t) => {
    t instanceof IDBCursor && MT.set(t, n);
  }).catch(() => {
  }), Jy.set(e, n), e;
}
function wk(n) {
  if (Kh.has(n))
    return;
  const e = new Promise((t, r) => {
    const i = () => {
      n.removeEventListener("complete", s), n.removeEventListener("error", a), n.removeEventListener("abort", a);
    }, s = () => {
      t(), i();
    }, a = () => {
      r(n.error || new DOMException("AbortError", "AbortError")), i();
    };
    n.addEventListener("complete", s), n.addEventListener("error", a), n.addEventListener("abort", a);
  });
  Kh.set(n, e);
}
let Jh = {
  get(n, e, t) {
    if (n instanceof IDBTransaction) {
      if (e === "done")
        return Kh.get(n);
      if (e === "objectStoreNames")
        return n.objectStoreNames || PT.get(n);
      if (e === "store")
        return t.objectStoreNames[1] ? void 0 : t.objectStore(t.objectStoreNames[0]);
    }
    return hs(n[e]);
  },
  set(n, e, t) {
    return n[e] = t, !0;
  },
  has(n, e) {
    return n instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in n;
  }
};
function Tk(n) {
  Jh = n(Jh);
}
function Ak(n) {
  return n === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...t) {
    const r = n.call(zp(this), e, ...t);
    return PT.set(r, e.sort ? e.sort() : [e]), hs(r);
  } : xk().includes(n) ? function(...e) {
    return n.apply(zp(this), e), hs(MT.get(this));
  } : function(...e) {
    return hs(n.apply(zp(this), e));
  };
}
function Ek(n) {
  return typeof n == "function" ? Ak(n) : (n instanceof IDBTransaction && wk(n), bk(n, gk()) ? new Proxy(n, Jh) : n);
}
function hs(n) {
  if (n instanceof IDBRequest)
    return vk(n);
  if (Vp.has(n))
    return Vp.get(n);
  const e = Ek(n);
  return e !== n && (Vp.set(n, e), Jy.set(e, n)), e;
}
const zp = (n) => Jy.get(n);
function Sk(n, e, { blocked: t, upgrade: r, blocking: i, terminated: s } = {}) {
  const a = indexedDB.open(n, e), o = hs(a);
  return r && a.addEventListener("upgradeneeded", (u) => {
    r(hs(a.result), u.oldVersion, u.newVersion, hs(a.transaction), u);
  }), t && a.addEventListener("blocked", (u) => t(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    u.oldVersion,
    u.newVersion,
    u
  )), o.then((u) => {
    s && u.addEventListener("close", () => s()), i && u.addEventListener("versionchange", (l) => i(l.oldVersion, l.newVersion, l));
  }).catch(() => {
  }), o;
}
const Ck = ["get", "getKey", "getAll", "getAllKeys", "count"], _k = ["put", "add", "delete", "clear"], Gp = /* @__PURE__ */ new Map();
function v2(n, e) {
  if (!(n instanceof IDBDatabase && !(e in n) && typeof e == "string"))
    return;
  if (Gp.get(e))
    return Gp.get(e);
  const t = e.replace(/FromIndex$/, ""), r = e !== t, i = _k.includes(t);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(t in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || Ck.includes(t))
  )
    return;
  const s = async function(a, ...o) {
    const u = this.transaction(a, i ? "readwrite" : "readonly");
    let l = u.store;
    return r && (l = l.index(o.shift())), (await Promise.all([
      l[t](...o),
      i && u.done
    ]))[0];
  };
  return Gp.set(e, s), s;
}
Tk((n) => ({
  ...n,
  get: (e, t, r) => v2(e, t) || n.get(e, t, r),
  has: (e, t) => !!v2(e, t) || n.has(e, t)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Mk {
  constructor(e) {
    this.container = e;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((t) => {
      if (Pk(t)) {
        const r = t.getImmediate();
        return `${r.library}/${r.version}`;
      } else
        return null;
    }).filter((t) => t).join(" ");
  }
}
function Pk(n) {
  const e = n.getComponent();
  return e?.type === "VERSION";
}
const Qh = "@firebase/app", w2 = "0.9.9";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ea = new _T("@firebase/app"), Rk = "@firebase/app-compat", Ik = "@firebase/analytics-compat", Ok = "@firebase/analytics", kk = "@firebase/app-check-compat", Nk = "@firebase/app-check", Dk = "@firebase/auth", Bk = "@firebase/auth-compat", Fk = "@firebase/database", Lk = "@firebase/database-compat", $k = "@firebase/functions", Uk = "@firebase/functions-compat", jk = "@firebase/installations", Vk = "@firebase/installations-compat", zk = "@firebase/messaging", Gk = "@firebase/messaging-compat", Hk = "@firebase/performance", qk = "@firebase/performance-compat", Wk = "@firebase/remote-config", Kk = "@firebase/remote-config-compat", Jk = "@firebase/storage", Qk = "@firebase/storage-compat", Yk = "@firebase/firestore", Xk = "@firebase/firestore-compat", Zk = "firebase", eN = "9.21.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yh = "[DEFAULT]", tN = {
  [Qh]: "fire-core",
  [Rk]: "fire-core-compat",
  [Ok]: "fire-analytics",
  [Ik]: "fire-analytics-compat",
  [Nk]: "fire-app-check",
  [kk]: "fire-app-check-compat",
  [Dk]: "fire-auth",
  [Bk]: "fire-auth-compat",
  [Fk]: "fire-rtdb",
  [Lk]: "fire-rtdb-compat",
  [$k]: "fire-fn",
  [Uk]: "fire-fn-compat",
  [jk]: "fire-iid",
  [Vk]: "fire-iid-compat",
  [zk]: "fire-fcm",
  [Gk]: "fire-fcm-compat",
  [Hk]: "fire-perf",
  [qk]: "fire-perf-compat",
  [Wk]: "fire-rc",
  [Kk]: "fire-rc-compat",
  [Jk]: "fire-gcs",
  [Qk]: "fire-gcs-compat",
  [Yk]: "fire-fst",
  [Xk]: "fire-fst-compat",
  "fire-js": "fire-js",
  [Zk]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Id = /* @__PURE__ */ new Map(), Xh = /* @__PURE__ */ new Map();
function nN(n, e) {
  try {
    n.container.addComponent(e);
  } catch (t) {
    Ea.debug(`Component ${e.name} failed to register with FirebaseApp ${n.name}`, t);
  }
}
function Od(n) {
  const e = n.name;
  if (Xh.has(e))
    return Ea.debug(`There were multiple attempts to register component ${e}.`), !1;
  Xh.set(e, n);
  for (const t of Id.values())
    nN(t, n);
  return !0;
}
function rN(n, e) {
  const t = n.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return t && t.triggerHeartbeat(), n.container.getProvider(e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const iN = {
  [
    "no-app"
    /* AppError.NO_APP */
  ]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  [
    "bad-app-name"
    /* AppError.BAD_APP_NAME */
  ]: "Illegal App name: '{$appName}",
  [
    "duplicate-app"
    /* AppError.DUPLICATE_APP */
  ]: "Firebase App named '{$appName}' already exists with different options or config",
  [
    "app-deleted"
    /* AppError.APP_DELETED */
  ]: "Firebase App named '{$appName}' already deleted",
  [
    "no-options"
    /* AppError.NO_OPTIONS */
  ]: "Need to provide options, when not being deployed to hosting via source.",
  [
    "invalid-app-argument"
    /* AppError.INVALID_APP_ARGUMENT */
  ]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  [
    "invalid-log-argument"
    /* AppError.INVALID_LOG_ARGUMENT */
  ]: "First argument to `onLog` must be null or a function.",
  [
    "idb-open"
    /* AppError.IDB_OPEN */
  ]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-get"
    /* AppError.IDB_GET */
  ]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-set"
    /* AppError.IDB_WRITE */
  ]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-delete"
    /* AppError.IDB_DELETE */
  ]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
}, ys = new CT("app", "Firebase", iN);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sN {
  constructor(e, t, r) {
    this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, t), this._name = t.name, this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new cl(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = e;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw ys.create("app-deleted", { appName: this._name });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const aN = eN;
function RT(n, e = {}) {
  let t = n;
  typeof e != "object" && (e = { name: e });
  const r = Object.assign({ name: Yh, automaticDataCollectionEnabled: !1 }, e), i = r.name;
  if (typeof i != "string" || !i)
    throw ys.create("bad-app-name", {
      appName: String(i)
    });
  if (t || (t = tk()), !t)
    throw ys.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const s = Id.get(i);
  if (s) {
    if (Wh(t, s.options) && Wh(r, s.config))
      return s;
    throw ys.create("duplicate-app", { appName: i });
  }
  const a = new fk(i);
  for (const u of Xh.values())
    a.addComponent(u);
  const o = new sN(t, r, a);
  return Id.set(i, o), o;
}
function oN(n = Yh) {
  const e = Id.get(n);
  if (!e && n === Yh)
    return RT();
  if (!e)
    throw ys.create("no-app", { appName: n });
  return e;
}
function bo(n, e, t) {
  var r;
  let i = (r = tN[n]) !== null && r !== void 0 ? r : n;
  t && (i += `-${t}`);
  const s = i.match(/\s|\//), a = e.match(/\s|\//);
  if (s || a) {
    const o = [
      `Unable to register library "${i}" with version "${e}":`
    ];
    s && o.push(`library name "${i}" contains illegal characters (whitespace or "/")`), s && a && o.push("and"), a && o.push(`version name "${e}" contains illegal characters (whitespace or "/")`), Ea.warn(o.join(" "));
    return;
  }
  Od(new cl(
    `${i}-version`,
    () => ({ library: i, version: e }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const uN = "firebase-heartbeat-database", lN = 1, dl = "firebase-heartbeat-store";
let Hp = null;
function IT() {
  return Hp || (Hp = Sk(uN, lN, {
    upgrade: (n, e) => {
      switch (e) {
        case 0:
          n.createObjectStore(dl);
      }
    }
  }).catch((n) => {
    throw ys.create("idb-open", {
      originalErrorMessage: n.message
    });
  })), Hp;
}
async function cN(n) {
  try {
    return (await IT()).transaction(dl).objectStore(dl).get(OT(n));
  } catch (e) {
    if (e instanceof Qo)
      Ea.warn(e.message);
    else {
      const t = ys.create("idb-get", {
        originalErrorMessage: e?.message
      });
      Ea.warn(t.message);
    }
  }
}
async function T2(n, e) {
  try {
    const r = (await IT()).transaction(dl, "readwrite");
    return await r.objectStore(dl).put(e, OT(n)), r.done;
  } catch (t) {
    if (t instanceof Qo)
      Ea.warn(t.message);
    else {
      const r = ys.create("idb-set", {
        originalErrorMessage: t?.message
      });
      Ea.warn(r.message);
    }
  }
}
function OT(n) {
  return `${n.name}!${n.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dN = 1024, fN = 30 * 24 * 60 * 60 * 1e3;
class pN {
  constructor(e) {
    this.container = e, this._heartbeatsCache = null;
    const t = this.container.getProvider("app").getImmediate();
    this._storage = new yN(t), this._heartbeatsCachePromise = this._storage.read().then((r) => (this._heartbeatsCache = r, r));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    const t = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), r = A2();
    if (this._heartbeatsCache === null && (this._heartbeatsCache = await this._heartbeatsCachePromise), !(this._heartbeatsCache.lastSentHeartbeatDate === r || this._heartbeatsCache.heartbeats.some((i) => i.date === r)))
      return this._heartbeatsCache.heartbeats.push({ date: r, agent: t }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((i) => {
        const s = new Date(i.date).valueOf();
        return Date.now() - s <= fN;
      }), this._storage.overwrite(this._heartbeatsCache);
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0)
      return "";
    const e = A2(), { heartbeatsToSend: t, unsentEntries: r } = hN(this._heartbeatsCache.heartbeats), i = Rd(JSON.stringify({ version: 2, heartbeats: t }));
    return this._heartbeatsCache.lastSentHeartbeatDate = e, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), i;
  }
}
function A2() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function hN(n, e = dN) {
  const t = [];
  let r = n.slice();
  for (const i of n) {
    const s = t.find((a) => a.agent === i.agent);
    if (s) {
      if (s.dates.push(i.date), E2(t) > e) {
        s.dates.pop();
        break;
      }
    } else if (t.push({
      agent: i.agent,
      dates: [i.date]
    }), E2(t) > e) {
      t.pop();
      break;
    }
    r = r.slice(1);
  }
  return {
    heartbeatsToSend: t,
    unsentEntries: r
  };
}
class yN {
  constructor(e) {
    this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return ik() ? sk().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    return await this._canUseIndexedDBPromise ? await cN(this.app) || { heartbeats: [] } : { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return T2(this.app, {
        lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : i.lastSentHeartbeatDate,
        heartbeats: e.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return T2(this.app, {
        lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : i.lastSentHeartbeatDate,
        heartbeats: [
          ...i.heartbeats,
          ...e.heartbeats
        ]
      });
    } else
      return;
  }
}
function E2(n) {
  return Rd(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: n })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function mN(n) {
  Od(new cl(
    "platform-logger",
    (e) => new Mk(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), Od(new cl(
    "heartbeat",
    (e) => new pN(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), bo(Qh, w2, n), bo(Qh, w2, "esm2017"), bo("fire-js", "");
}
mN("");
var bN = "firebase", gN = "9.21.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
bo(bN, gN, "app");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bn {
  constructor(e) {
    this.uid = e;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(e) {
    return e.uid === this.uid;
  }
}
Bn.UNAUTHENTICATED = new Bn(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
Bn.GOOGLE_CREDENTIALS = new Bn("google-credentials-uid"), Bn.FIRST_PARTY = new Bn("first-party-uid"), Bn.MOCK_USER = new Bn("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Yo = "9.21.0";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ro = new _T("@firebase/firestore");
function kd(n, ...e) {
  if (Ro.logLevel <= $e.DEBUG) {
    const t = e.map(Yy);
    Ro.debug(`Firestore (${Yo}): ${n}`, ...t);
  }
}
function Qy(n, ...e) {
  if (Ro.logLevel <= $e.ERROR) {
    const t = e.map(Yy);
    Ro.error(`Firestore (${Yo}): ${n}`, ...t);
  }
}
function kT(n, ...e) {
  if (Ro.logLevel <= $e.WARN) {
    const t = e.map(Yy);
    Ro.warn(`Firestore (${Yo}): ${n}`, ...t);
  }
}
function Yy(n) {
  if (typeof n == "string")
    return n;
  try {
    return e = n, JSON.stringify(e);
  } catch {
    return n;
  }
  /**
  * @license
  * Copyright 2020 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  var e;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ot(n = "Unexpected state") {
  const e = `FIRESTORE (${Yo}) INTERNAL ASSERTION FAILED: ` + n;
  throw Qy(e), new Error(e);
}
function As(n, e) {
  n || Ot();
}
function Ef(n, e) {
  return n;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const S2 = "ok", xN = "cancelled", Ou = "unknown", fe = "invalid-argument", vN = "deadline-exceeded", wN = "not-found", TN = "permission-denied", Zh = "unauthenticated", AN = "resource-exhausted", Sa = "failed-precondition", EN = "aborted", SN = "out-of-range", NT = "unimplemented", CN = "internal", _N = "unavailable";
class oe extends Qo {
  /** @hideconstructor */
  constructor(e, t) {
    super(e, t), this.code = e, this.message = t, // HACK: We write a toString property directly because Error is not a real
    // class and so inheritance does not work correctly. We could alternatively
    // do the same "back-door inheritance" trick that FirebaseError does.
    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DT {
  constructor(e, t) {
    this.user = t, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${e}`);
  }
}
class MN {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
    e.enqueueRetryable(() => t(Bn.UNAUTHENTICATED));
  }
  shutdown() {
  }
}
class PN {
  constructor(e) {
    this.token = e, /**
     * Stores the listener registered with setChangeListener()
     * This isn't actually necessary since the UID never changes, but we use this
     * to verify the listen contract is adhered to in tests.
     */
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(e, t) {
    this.changeListener = t, // Fire with initial user.
    e.enqueueRetryable(() => t(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class RN {
  constructor(e) {
    this.auth = null, e.onInit((t) => {
      this.auth = t;
    });
  }
  getToken() {
    return this.auth ? this.auth.getToken().then((e) => e ? (As(typeof e.accessToken == "string"), new DT(e.accessToken, new Bn(this.auth.getUid()))) : null) : Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
  }
  shutdown() {
  }
}
class IN {
  constructor(e, t, r) {
    this.t = e, this.i = t, this.o = r, this.type = "FirstParty", this.user = Bn.FIRST_PARTY, this.u = /* @__PURE__ */ new Map();
  }
  /**
   * Gets an authorization token, using a provided factory function, or return
   * null.
   */
  h() {
    return this.o ? this.o() : null;
  }
  get headers() {
    this.u.set("X-Goog-AuthUser", this.t);
    const e = this.h();
    return e && this.u.set("Authorization", e), this.i && this.u.set("X-Goog-Iam-Authorization-Token", this.i), this.u;
  }
}
class ON {
  constructor(e, t, r) {
    this.t = e, this.i = t, this.o = r;
  }
  getToken() {
    return Promise.resolve(new IN(this.t, this.i, this.o));
  }
  start(e, t) {
    e.enqueueRetryable(() => t(Bn.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
}
class kN {
  constructor(e) {
    this.value = e, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
}
class NN {
  constructor(e) {
    this.l = e, this.appCheck = null, e.onInit((t) => {
      this.appCheck = t;
    });
  }
  getToken() {
    return this.appCheck ? this.appCheck.getToken().then((e) => e ? (As(typeof e.token == "string"), new kN(e.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
  }
  shutdown() {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DN {
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(e, t, r, i, s, a, o, u) {
    this.databaseId = e, this.appId = t, this.persistenceKey = r, this.host = i, this.ssl = s, this.forceLongPolling = a, this.autoDetectLongPolling = o, this.useFetchStreams = u;
  }
}
class fl {
  constructor(e, t) {
    this.projectId = e, this.database = t || "(default)";
  }
  static empty() {
    return new fl("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(e) {
    return e instanceof fl && e.projectId === this.projectId && e.database === this.database;
  }
}
class pl {
  constructor(e, t, r) {
    t === void 0 ? t = 0 : t > e.length && Ot(), r === void 0 ? r = e.length - t : r > e.length - t && Ot(), this.segments = e, this.offset = t, this.len = r;
  }
  get length() {
    return this.len;
  }
  isEqual(e) {
    return pl.comparator(this, e) === 0;
  }
  child(e) {
    const t = this.segments.slice(this.offset, this.limit());
    return e instanceof pl ? e.forEach((r) => {
      t.push(r);
    }) : t.push(e), this.construct(t);
  }
  /** The index of one past the last segment of the path. */
  limit() {
    return this.offset + this.length;
  }
  popFirst(e) {
    return e = e === void 0 ? 1 : e, this.construct(this.segments, this.offset + e, this.length - e);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(e) {
    return this.segments[this.offset + e];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(e) {
    if (e.length < this.length)
      return !1;
    for (let t = 0; t < this.length; t++)
      if (this.get(t) !== e.get(t))
        return !1;
    return !0;
  }
  isImmediateParentOf(e) {
    if (this.length + 1 !== e.length)
      return !1;
    for (let t = 0; t < this.length; t++)
      if (this.get(t) !== e.get(t))
        return !1;
    return !0;
  }
  forEach(e) {
    for (let t = this.offset, r = this.limit(); t < r; t++)
      e(this.segments[t]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(e, t) {
    const r = Math.min(e.length, t.length);
    for (let i = 0; i < r; i++) {
      const s = e.get(i), a = t.get(i);
      if (s < a)
        return -1;
      if (s > a)
        return 1;
    }
    return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
  }
}
class Kt extends pl {
  construct(e, t, r) {
    return new Kt(e, t, r);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Creates a resource path from the given slash-delimited string. If multiple
   * arguments are provided, all components are combined. Leading and trailing
   * slashes from all components are ignored.
   */
  static fromString(...e) {
    const t = [];
    for (const r of e) {
      if (r.indexOf("//") >= 0)
        throw new oe(fe, `Invalid segment (${r}). Paths must not contain // in them.`);
      t.push(...r.split("/").filter((i) => i.length > 0));
    }
    return new Kt(t);
  }
  static emptyPath() {
    return new Kt([]);
  }
}
const BN = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class Zn extends pl {
  construct(e, t, r) {
    return new Zn(e, t, r);
  }
  /**
   * Returns true if the string could be used as a segment in a field path
   * without escaping.
   */
  static isValidIdentifier(e) {
    return BN.test(e);
  }
  canonicalString() {
    return this.toArray().map((e) => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), Zn.isValidIdentifier(e) || (e = "`" + e + "`"), e)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns true if this field references the key of a document.
   */
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  /**
   * The field designating the key of a document.
   */
  static keyField() {
    return new Zn(["__name__"]);
  }
  /**
   * Parses a field string from the given server-formatted string.
   *
   * - Splitting the empty string is not allowed (for now at least).
   * - Empty segments within the string (e.g. if there are two consecutive
   *   separators) are not allowed.
   *
   * TODO(b/37244157): we should make this more strict. Right now, it allows
   * non-identifier path components, even if they aren't escaped.
   */
  static fromServerFormat(e) {
    const t = [];
    let r = "", i = 0;
    const s = () => {
      if (r.length === 0)
        throw new oe(fe, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      t.push(r), r = "";
    };
    let a = !1;
    for (; i < e.length; ) {
      const o = e[i];
      if (o === "\\") {
        if (i + 1 === e.length)
          throw new oe(fe, "Path has trailing escape character: " + e);
        const u = e[i + 1];
        if (u !== "\\" && u !== "." && u !== "`")
          throw new oe(fe, "Path has invalid escape sequence: " + e);
        r += u, i += 2;
      } else
        o === "`" ? (a = !a, i++) : o !== "." || a ? (r += o, i++) : (s(), i++);
    }
    if (s(), a)
      throw new oe(fe, "Unterminated ` in path: " + e);
    return new Zn(t);
  }
  static emptyPath() {
    return new Zn([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ln {
  constructor(e) {
    this.path = e;
  }
  static fromPath(e) {
    return new ln(Kt.fromString(e));
  }
  static fromName(e) {
    return new ln(Kt.fromString(e).popFirst(5));
  }
  static empty() {
    return new ln(Kt.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  /** Returns true if the document is in the specified collectionId. */
  hasCollectionId(e) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === e;
  }
  /** Returns the collection group (i.e. the name of the parent collection) for this key. */
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  /** Returns the fully qualified path to the parent collection. */
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(e) {
    return e !== null && Kt.comparator(this.path, e.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(e, t) {
    return Kt.comparator(e.path, t.path);
  }
  static isDocumentKey(e) {
    return e.length % 2 == 0;
  }
  /**
   * Creates and returns a new document key with the given segments.
   *
   * @param segments - The segments of the path to the document
   * @returns A new instance of DocumentKey
   */
  static fromSegments(e) {
    return new ln(new Kt(e.slice()));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function BT(n, e, t) {
  if (!t)
    throw new oe(fe, `Function ${n}() cannot be called with an empty ${e}.`);
}
function C2(n) {
  if (!ln.isDocumentKey(n))
    throw new oe(fe, `Invalid document reference. Document references must have an even number of segments, but ${n} has ${n.length}.`);
}
function _2(n) {
  if (ln.isDocumentKey(n))
    throw new oe(fe, `Invalid collection reference. Collection references must have an odd number of segments, but ${n} has ${n.length}.`);
}
function Sf(n) {
  if (n === void 0)
    return "undefined";
  if (n === null)
    return "null";
  if (typeof n == "string")
    return n.length > 20 && (n = `${n.substring(0, 20)}...`), JSON.stringify(n);
  if (typeof n == "number" || typeof n == "boolean")
    return "" + n;
  if (typeof n == "object") {
    if (n instanceof Array)
      return "an array";
    {
      const e = (
        /** try to get the constructor name for an object. */
        function(t) {
          return t.constructor ? t.constructor.name : null;
        }(n)
      );
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof n == "function" ? "a function" : Ot();
}
function Ll(n, e) {
  if ("_delegate" in n && // Unwrap Compat types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (n = n._delegate), !(n instanceof e)) {
    if (e.name === n.constructor.name)
      throw new oe(fe, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const t = Sf(n);
      throw new oe(fe, `Expected type '${e.name}', but it was: ${t}`);
    }
  }
  return n;
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let pc = null;
function FN() {
  return pc === null ? pc = 268435456 + Math.round(2147483648 * Math.random()) : pc++, "0x" + pc.toString(16);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function LN(n) {
  return n == null;
}
function Nd(n) {
  return n === 0 && 1 / n == -1 / 0;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const $N = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery",
  RunAggregationQuery: "runAggregationQuery"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var M2, Ce;
function P2(n) {
  if (n === void 0)
    return Qy("RPC_ERROR", "HTTP error has no status"), Ou;
  switch (n) {
    case 200:
      return S2;
    case 400:
      return Sa;
    case 401:
      return Zh;
    case 403:
      return TN;
    case 404:
      return wN;
    case 409:
      return EN;
    case 416:
      return SN;
    case 429:
      return AN;
    case 499:
      return xN;
    case 500:
      return Ou;
    case 501:
      return NT;
    case 503:
      return _N;
    case 504:
      return vN;
    default:
      return n >= 200 && n < 300 ? S2 : n >= 400 && n < 500 ? Sa : n >= 500 && n < 600 ? CN : Ou;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(Ce = M2 || (M2 = {}))[Ce.OK = 0] = "OK", Ce[Ce.CANCELLED = 1] = "CANCELLED", Ce[Ce.UNKNOWN = 2] = "UNKNOWN", Ce[Ce.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Ce[Ce.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Ce[Ce.NOT_FOUND = 5] = "NOT_FOUND", Ce[Ce.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Ce[Ce.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Ce[Ce.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Ce[Ce.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Ce[Ce.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Ce[Ce.ABORTED = 10] = "ABORTED", Ce[Ce.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Ce[Ce.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Ce[Ce.INTERNAL = 13] = "INTERNAL", Ce[Ce.UNAVAILABLE = 14] = "UNAVAILABLE", Ce[Ce.DATA_LOSS = 15] = "DATA_LOSS";
class UN extends /**
 * Base class for all Rest-based connections to the backend (WebChannel and
 * HTTP).
 */
class {
  constructor(e) {
    this.databaseInfo = e, this.databaseId = e.databaseId;
    const t = e.ssl ? "https" : "http";
    this.m = t + "://" + e.host, this.p = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  get g() {
    return !1;
  }
  v(e, t, r, i, s) {
    const a = FN(), o = this.I(e, t);
    kd("RestConnection", `Sending RPC '${e}' ${a}:`, o, r);
    const u = {};
    return this.T(u, i, s), this.A(e, o, u, r).then((l) => (kd("RestConnection", `Received RPC '${e}' ${a}: `, l), l), (l) => {
      throw kT("RestConnection", `RPC '${e}' ${a} failed with error: `, l, "url: ", o, "request:", r), l;
    });
  }
  R(e, t, r, i, s, a) {
    return this.v(e, t, r, i, s);
  }
  /**
   * Modifies the headers for a request, adding any authorization token if
   * present and any additional headers for the request.
   */
  T(e, t, r) {
    e["X-Goog-Api-Client"] = "gl-js/ fire/" + Yo, // Content-Type: text/plain will avoid preflight requests which might
    // mess with CORS and redirects by proxies. If we add custom headers
    // we will need to change this code to potentially use the $httpOverwrite
    // parameter supported by ESF to avoid triggering preflight requests.
    e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), t && t.headers.forEach((i, s) => e[s] = i), r && r.headers.forEach((i, s) => e[s] = i);
  }
  I(e, t) {
    const r = $N[e];
    return `${this.m}/v1/${t}:${r}`;
  }
} {
  /**
   * @param databaseInfo - The connection info.
   * @param fetchImpl - `fetch` or a Polyfill that implements the fetch API.
   */
  constructor(e, t) {
    super(e), this.P = t;
  }
  V(e, t) {
    throw new Error("Not supported by FetchConnection");
  }
  async A(e, t, r, i) {
    var s;
    const a = JSON.stringify(i);
    let o;
    try {
      o = await this.P(t, {
        method: "POST",
        headers: r,
        body: a
      });
    } catch (u) {
      const l = u;
      throw new oe(P2(l.status), "Request failed with error: " + l.statusText);
    }
    if (!o.ok) {
      let u = await o.json();
      Array.isArray(u) && (u = u[0]);
      const l = (s = u?.error) === null || s === void 0 ? void 0 : s.message;
      throw new oe(P2(o.status), `Request failed with error: ${l ?? o.statusText}`);
    }
    return o.json();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function jN(n) {
  const e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof self < "u" && (self.crypto || self.msCrypto)
  ), t = new Uint8Array(n);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(t);
  else
    for (let r = 0; r < n; r++)
      t[r] = Math.floor(256 * Math.random());
  return t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VN {
  static D() {
    const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", t = Math.floor(256 / e.length) * e.length;
    let r = "";
    for (; r.length < 20; ) {
      const i = jN(40);
      for (let s = 0; s < i.length; ++s)
        r.length < 20 && i[s] < t && (r += e.charAt(i[s] % e.length));
    }
    return r;
  }
}
function Yt(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
function FT(n, e, t) {
  return n.length === e.length && n.every((r, i) => t(r, e[i]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function R2(n) {
  let e = 0;
  for (const t in n)
    Object.prototype.hasOwnProperty.call(n, t) && e++;
  return e;
}
function $l(n, e) {
  for (const t in n)
    Object.prototype.hasOwnProperty.call(n, t) && e(t, n[t]);
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zN extends Error {
  constructor() {
    super(...arguments), this.name = "Base64DecodeError";
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fi {
  constructor(e) {
    this.binaryString = e;
  }
  static fromBase64String(e) {
    const t = function(r) {
      try {
        return atob(r);
      } catch (i) {
        throw typeof DOMException < "u" && i instanceof DOMException ? new zN("Invalid base64 string: " + i) : i;
      }
    }(e);
    return new Fi(t);
  }
  static fromUint8Array(e) {
    const t = (
      /**
      * Helper function to convert an Uint8array to a binary string.
      */
      function(r) {
        let i = "";
        for (let s = 0; s < r.length; ++s)
          i += String.fromCharCode(r[s]);
        return i;
      }(e)
    );
    return new Fi(t);
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(e++),
        done: !1
      } : {
        value: void 0,
        done: !0
      }
    };
  }
  toBase64() {
    return e = this.binaryString, btoa(e);
    var e;
  }
  toUint8Array() {
    return function(e) {
      const t = new Uint8Array(e.length);
      for (let r = 0; r < e.length; r++)
        t[r] = e.charCodeAt(r);
      return t;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(e) {
    return Yt(this.binaryString, e.binaryString);
  }
  isEqual(e) {
    return this.binaryString === e.binaryString;
  }
}
Fi.EMPTY_BYTE_STRING = new Fi("");
const GN = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Ca(n) {
  if (As(!!n), typeof n == "string") {
    let e = 0;
    const t = GN.exec(n);
    if (As(!!t), t[1]) {
      let i = t[1];
      i = (i + "000000000").substr(0, 9), e = Number(i);
    }
    const r = new Date(n);
    return {
      seconds: Math.floor(r.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: qt(n.seconds),
    nanos: qt(n.nanos)
  };
}
function qt(n) {
  return typeof n == "number" ? n : typeof n == "string" ? Number(n) : 0;
}
function hl(n) {
  return typeof n == "string" ? Fi.fromBase64String(n) : Fi.fromUint8Array(n);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Un {
  /**
   * Creates a new timestamp.
   *
   * @param seconds - The number of seconds of UTC time since Unix epoch
   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   *     9999-12-31T23:59:59Z inclusive.
   * @param nanoseconds - The non-negative fractions of a second at nanosecond
   *     resolution. Negative second values with fractions must still have
   *     non-negative nanoseconds values that count forward in time. Must be
   *     from 0 to 999,999,999 inclusive.
   */
  constructor(e, t) {
    if (this.seconds = e, this.nanoseconds = t, t < 0)
      throw new oe(fe, "Timestamp nanoseconds out of range: " + t);
    if (t >= 1e9)
      throw new oe(fe, "Timestamp nanoseconds out of range: " + t);
    if (e < -62135596800)
      throw new oe(fe, "Timestamp seconds out of range: " + e);
    if (e >= 253402300800)
      throw new oe(fe, "Timestamp seconds out of range: " + e);
  }
  /**
   * Creates a new timestamp with the current date, with millisecond precision.
   *
   * @returns a new timestamp representing the current date.
   */
  static now() {
    return Un.fromMillis(Date.now());
  }
  /**
   * Creates a new timestamp from the given date.
   *
   * @param date - The date to initialize the `Timestamp` from.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     date.
   */
  static fromDate(e) {
    return Un.fromMillis(e.getTime());
  }
  /**
   * Creates a new timestamp from the given number of milliseconds.
   *
   * @param milliseconds - Number of milliseconds since Unix epoch
   *     1970-01-01T00:00:00Z.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     number of milliseconds.
   */
  static fromMillis(e) {
    const t = Math.floor(e / 1e3), r = Math.floor(1e6 * (e - 1e3 * t));
    return new Un(t, r);
  }
  /**
   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
   * causes a loss of precision since `Date` objects only support millisecond
   * precision.
   *
   * @returns JavaScript `Date` object representing the same point in time as
   *     this `Timestamp`, with millisecond precision.
   */
  toDate() {
    return new Date(this.toMillis());
  }
  /**
   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
   * epoch). This operation causes a loss of precision.
   *
   * @returns The point in time corresponding to this timestamp, represented as
   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
   */
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(e) {
    return this.seconds === e.seconds ? Yt(this.nanoseconds, e.nanoseconds) : Yt(this.seconds, e.seconds);
  }
  /**
   * Returns true if this `Timestamp` is equal to the provided one.
   *
   * @param other - The `Timestamp` to compare against.
   * @returns true if this `Timestamp` is equal to the provided one.
   */
  isEqual(e) {
    return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
  }
  /** Returns a textual representation of this `Timestamp`. */
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  /** Returns a JSON-serializable representation of this `Timestamp`. */
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  /**
   * Converts this object to a primitive string, which allows `Timestamp` objects
   * to be compared using the `>`, `<=`, `>=` and `>` operators.
   */
  valueOf() {
    const e = this.seconds - -62135596800;
    return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function LT(n) {
  var e, t;
  return ((t = (((e = n?.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || t === void 0 ? void 0 : t.stringValue) === "server_timestamp";
}
function $T(n) {
  const e = n.mapValue.fields.__previous_value__;
  return LT(e) ? $T(e) : e;
}
function yl(n) {
  const e = Ca(n.mapValue.fields.__local_write_time__.timestampValue);
  return new Un(e.seconds, e.nanos);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hc = {
  fields: {
    __type__: {
      stringValue: "__max__"
    }
  }
};
function _a(n) {
  return "nullValue" in n ? 0 : "booleanValue" in n ? 1 : "integerValue" in n || "doubleValue" in n ? 2 : "timestampValue" in n ? 3 : "stringValue" in n ? 5 : "bytesValue" in n ? 6 : "referenceValue" in n ? 7 : "geoPointValue" in n ? 8 : "arrayValue" in n ? 9 : "mapValue" in n ? LT(n) ? 4 : (
    /** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */
    function(e) {
      return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
    }(n) ? 9007199254740991 : 10
  ) : Ot();
}
function Dd(n, e) {
  if (n === e)
    return !0;
  const t = _a(n);
  if (t !== _a(e))
    return !1;
  switch (t) {
    case 0:
    case 9007199254740991:
      return !0;
    case 1:
      return n.booleanValue === e.booleanValue;
    case 4:
      return yl(n).isEqual(yl(e));
    case 3:
      return function(r, i) {
        if (typeof r.timestampValue == "string" && typeof i.timestampValue == "string" && r.timestampValue.length === i.timestampValue.length)
          return r.timestampValue === i.timestampValue;
        const s = Ca(r.timestampValue), a = Ca(i.timestampValue);
        return s.seconds === a.seconds && s.nanos === a.nanos;
      }(n, e);
    case 5:
      return n.stringValue === e.stringValue;
    case 6:
      return function(r, i) {
        return hl(r.bytesValue).isEqual(hl(i.bytesValue));
      }(n, e);
    case 7:
      return n.referenceValue === e.referenceValue;
    case 8:
      return function(r, i) {
        return qt(r.geoPointValue.latitude) === qt(i.geoPointValue.latitude) && qt(r.geoPointValue.longitude) === qt(i.geoPointValue.longitude);
      }(n, e);
    case 2:
      return function(r, i) {
        if ("integerValue" in r && "integerValue" in i)
          return qt(r.integerValue) === qt(i.integerValue);
        if ("doubleValue" in r && "doubleValue" in i) {
          const s = qt(r.doubleValue), a = qt(i.doubleValue);
          return s === a ? Nd(s) === Nd(a) : isNaN(s) && isNaN(a);
        }
        return !1;
      }(n, e);
    case 9:
      return FT(n.arrayValue.values || [], e.arrayValue.values || [], Dd);
    case 10:
      return function(r, i) {
        const s = r.mapValue.fields || {}, a = i.mapValue.fields || {};
        if (R2(s) !== R2(a))
          return !1;
        for (const o in s)
          if (s.hasOwnProperty(o) && (a[o] === void 0 || !Dd(s[o], a[o])))
            return !1;
        return !0;
      }(n, e);
    default:
      return Ot();
  }
}
function ml(n, e) {
  return (n.values || []).find((t) => Dd(t, e)) !== void 0;
}
function Bd(n, e) {
  if (n === e)
    return 0;
  const t = _a(n), r = _a(e);
  if (t !== r)
    return Yt(t, r);
  switch (t) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return Yt(n.booleanValue, e.booleanValue);
    case 2:
      return function(i, s) {
        const a = qt(i.integerValue || i.doubleValue), o = qt(s.integerValue || s.doubleValue);
        return a < o ? -1 : a > o ? 1 : a === o ? 0 : (
          // one or both are NaN.
          isNaN(a) ? isNaN(o) ? 0 : -1 : 1
        );
      }(n, e);
    case 3:
      return I2(n.timestampValue, e.timestampValue);
    case 4:
      return I2(yl(n), yl(e));
    case 5:
      return Yt(n.stringValue, e.stringValue);
    case 6:
      return function(i, s) {
        const a = hl(i), o = hl(s);
        return a.compareTo(o);
      }(n.bytesValue, e.bytesValue);
    case 7:
      return function(i, s) {
        const a = i.split("/"), o = s.split("/");
        for (let u = 0; u < a.length && u < o.length; u++) {
          const l = Yt(a[u], o[u]);
          if (l !== 0)
            return l;
        }
        return Yt(a.length, o.length);
      }(n.referenceValue, e.referenceValue);
    case 8:
      return function(i, s) {
        const a = Yt(qt(i.latitude), qt(s.latitude));
        return a !== 0 ? a : Yt(qt(i.longitude), qt(s.longitude));
      }(n.geoPointValue, e.geoPointValue);
    case 9:
      return function(i, s) {
        const a = i.values || [], o = s.values || [];
        for (let u = 0; u < a.length && u < o.length; ++u) {
          const l = Bd(a[u], o[u]);
          if (l)
            return l;
        }
        return Yt(a.length, o.length);
      }(n.arrayValue, e.arrayValue);
    case 10:
      return function(i, s) {
        if (i === hc && s === hc)
          return 0;
        if (i === hc)
          return 1;
        if (s === hc)
          return -1;
        const a = i.fields || {}, o = Object.keys(a), u = s.fields || {}, l = Object.keys(u);
        o.sort(), l.sort();
        for (let d = 0; d < o.length && d < l.length; ++d) {
          const p = Yt(o[d], l[d]);
          if (p !== 0)
            return p;
          const m = Bd(a[o[d]], u[l[d]]);
          if (m !== 0)
            return m;
        }
        return Yt(o.length, l.length);
      }(n.mapValue, e.mapValue);
    default:
      throw Ot();
  }
}
function I2(n, e) {
  if (typeof n == "string" && typeof e == "string" && n.length === e.length)
    return Yt(n, e);
  const t = Ca(n), r = Ca(e), i = Yt(t.seconds, r.seconds);
  return i !== 0 ? i : Yt(t.nanos, r.nanos);
}
function O2(n, e) {
  return {
    referenceValue: `projects/${n.projectId}/databases/${n.database}/documents/${e.path.canonicalString()}`
  };
}
function UT(n) {
  return !!n && "arrayValue" in n;
}
function k2(n) {
  return !!n && "nullValue" in n;
}
function N2(n) {
  return !!n && "doubleValue" in n && isNaN(Number(n.doubleValue));
}
function qp(n) {
  return !!n && "mapValue" in n;
}
function ku(n) {
  if (n.geoPointValue)
    return {
      geoPointValue: Object.assign({}, n.geoPointValue)
    };
  if (n.timestampValue && typeof n.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, n.timestampValue)
    };
  if (n.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return $l(n.mapValue.fields, (t, r) => e.mapValue.fields[t] = ku(r)), e;
  }
  if (n.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let t = 0; t < (n.arrayValue.values || []).length; ++t)
      e.arrayValue.values[t] = ku(n.arrayValue.values[t]);
    return e;
  }
  return Object.assign({}, n);
}
class D2 {
  constructor(e, t) {
    this.position = e, this.inclusive = t;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jT {
}
class $r extends jT {
  constructor(e, t, r) {
    super(), this.field = e, this.op = t, this.value = r;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, t, r) {
    return e.isKeyField() ? t === "in" || t === "not-in" ? this.createKeyFieldInFilter(e, t, r) : new HN(e, t, r) : t === "array-contains" ? new KN(e, r) : t === "in" ? new JN(e, r) : t === "not-in" ? new QN(e, r) : t === "array-contains-any" ? new YN(e, r) : new $r(e, t, r);
  }
  static createKeyFieldInFilter(e, t, r) {
    return t === "in" ? new qN(e, r) : new WN(e, r);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return this.op === "!=" ? t !== null && this.matchesComparison(Bd(t, this.value)) : t !== null && _a(this.value) === _a(t) && this.matchesComparison(Bd(t, this.value));
  }
  matchesComparison(e) {
    switch (this.op) {
      case "<":
        return e < 0;
      case "<=":
        return e <= 0;
      case "==":
        return e === 0;
      case "!=":
        return e !== 0;
      case ">":
        return e > 0;
      case ">=":
        return e >= 0;
      default:
        return Ot();
    }
  }
  isInequality() {
    return [
      "<",
      "<=",
      ">",
      ">=",
      "!=",
      "not-in"
      /* Operator.NOT_IN */
    ].indexOf(this.op) >= 0;
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
  getFirstInequalityField() {
    return this.isInequality() ? this.field : null;
  }
}
class Ul extends jT {
  constructor(e, t) {
    super(), this.filters = e, this.op = t, this.N = null;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, t) {
    return new Ul(e, t);
  }
  matches(e) {
    return this.op === "and" ? this.filters.find((t) => !t.matches(e)) === void 0 : this.filters.find((t) => t.matches(e)) !== void 0;
  }
  getFlattenedFilters() {
    return this.N !== null || (this.N = this.filters.reduce((e, t) => e.concat(t.getFlattenedFilters()), [])), this.N;
  }
  // Returns a mutable copy of `this.filters`
  getFilters() {
    return Object.assign([], this.filters);
  }
  getFirstInequalityField() {
    const e = this.F((t) => t.isInequality());
    return e !== null ? e.field : null;
  }
  // Performs a depth-first search to find and return the first FieldFilter in the composite filter
  // that satisfies the predicate. Returns `null` if none of the FieldFilters satisfy the
  // predicate.
  F(e) {
    for (const t of this.getFlattenedFilters())
      if (e(t))
        return t;
    return null;
  }
}
class HN extends $r {
  constructor(e, t, r) {
    super(e, t, r), this.key = ln.fromName(r.referenceValue);
  }
  matches(e) {
    const t = ln.comparator(e.key, this.key);
    return this.matchesComparison(t);
  }
}
class qN extends $r {
  constructor(e, t) {
    super(e, "in", t), this.keys = VT("in", t);
  }
  matches(e) {
    return this.keys.some((t) => t.isEqual(e.key));
  }
}
class WN extends $r {
  constructor(e, t) {
    super(e, "not-in", t), this.keys = VT("not-in", t);
  }
  matches(e) {
    return !this.keys.some((t) => t.isEqual(e.key));
  }
}
function VT(n, e) {
  var t;
  return (((t = e.arrayValue) === null || t === void 0 ? void 0 : t.values) || []).map((r) => ln.fromName(r.referenceValue));
}
class KN extends $r {
  constructor(e, t) {
    super(e, "array-contains", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return UT(t) && ml(t.arrayValue, this.value);
  }
}
class JN extends $r {
  constructor(e, t) {
    super(e, "in", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return t !== null && ml(this.value.arrayValue, t);
  }
}
class QN extends $r {
  constructor(e, t) {
    super(e, "not-in", t);
  }
  matches(e) {
    if (ml(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return !1;
    const t = e.data.field(this.field);
    return t !== null && !ml(this.value.arrayValue, t);
  }
}
class YN extends $r {
  constructor(e, t) {
    super(e, "array-contains-any", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return !(!UT(t) || !t.arrayValue.values) && t.arrayValue.values.some((r) => ml(this.value.arrayValue, r));
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Nu {
  constructor(e, t = "asc") {
    this.field = e, this.dir = t;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mn {
  constructor(e) {
    this.timestamp = e;
  }
  static fromTimestamp(e) {
    return new mn(e);
  }
  static min() {
    return new mn(new Un(0, 0));
  }
  static max() {
    return new mn(new Un(253402300799, 999999999));
  }
  compareTo(e) {
    return this.timestamp._compareTo(e.timestamp);
  }
  isEqual(e) {
    return this.timestamp.isEqual(e.timestamp);
  }
  /** Returns a number representation of the version for use in spec tests. */
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fd {
  constructor(e, t) {
    this.comparator = e, this.root = t || on.EMPTY;
  }
  // Returns a copy of the map, with the specified key/value added or replaced.
  insert(e, t) {
    return new Fd(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, on.BLACK, null, null));
  }
  // Returns a copy of the map, with the specified key removed.
  remove(e) {
    return new Fd(this.comparator, this.root.remove(e, this.comparator).copy(null, null, on.BLACK, null, null));
  }
  // Returns the value of the node with the given key, or null.
  get(e) {
    let t = this.root;
    for (; !t.isEmpty(); ) {
      const r = this.comparator(e, t.key);
      if (r === 0)
        return t.value;
      r < 0 ? t = t.left : r > 0 && (t = t.right);
    }
    return null;
  }
  // Returns the index of the element in this sorted map, or -1 if it doesn't
  // exist.
  indexOf(e) {
    let t = 0, r = this.root;
    for (; !r.isEmpty(); ) {
      const i = this.comparator(e, r.key);
      if (i === 0)
        return t + r.left.size;
      i < 0 ? r = r.left : (
        // Count all nodes left of the node plus the node itself
        (t += r.left.size + 1, r = r.right)
      );
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  // Returns the total number of nodes in the map.
  get size() {
    return this.root.size;
  }
  // Returns the minimum key in the map.
  minKey() {
    return this.root.minKey();
  }
  // Returns the maximum key in the map.
  maxKey() {
    return this.root.maxKey();
  }
  // Traverses the map in key order and calls the specified action function
  // for each key/value pair. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.root.inorderTraversal(e);
  }
  forEach(e) {
    this.inorderTraversal((t, r) => (e(t, r), !1));
  }
  toString() {
    const e = [];
    return this.inorderTraversal((t, r) => (e.push(`${t}:${r}`), !1)), `{${e.join(", ")}}`;
  }
  // Traverses the map in reverse key order and calls the specified action
  // function for each key/value pair. If action returns true, traversal is
  // aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.root.reverseTraversal(e);
  }
  // Returns an iterator over the SortedMap.
  getIterator() {
    return new yc(this.root, null, this.comparator, !1);
  }
  getIteratorFrom(e) {
    return new yc(this.root, e, this.comparator, !1);
  }
  getReverseIterator() {
    return new yc(this.root, null, this.comparator, !0);
  }
  getReverseIteratorFrom(e) {
    return new yc(this.root, e, this.comparator, !0);
  }
}
class yc {
  constructor(e, t, r, i) {
    this.isReverse = i, this.nodeStack = [];
    let s = 1;
    for (; !e.isEmpty(); )
      if (s = t ? r(e.key, t) : 1, // flip the comparison if we're going in reverse
      t && i && (s *= -1), s < 0)
        e = this.isReverse ? e.left : e.right;
      else {
        if (s === 0) {
          this.nodeStack.push(e);
          break;
        }
        this.nodeStack.push(e), e = this.isReverse ? e.right : e.left;
      }
  }
  getNext() {
    let e = this.nodeStack.pop();
    const t = {
      key: e.key,
      value: e.value
    };
    if (this.isReverse)
      for (e = e.left; !e.isEmpty(); )
        this.nodeStack.push(e), e = e.right;
    else
      for (e = e.right; !e.isEmpty(); )
        this.nodeStack.push(e), e = e.left;
    return t;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const e = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: e.key,
      value: e.value
    };
  }
}
class on {
  constructor(e, t, r, i, s) {
    this.key = e, this.value = t, this.color = r ?? on.RED, this.left = i ?? on.EMPTY, this.right = s ?? on.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  // Returns a copy of the current node, optionally replacing pieces of it.
  copy(e, t, r, i, s) {
    return new on(e ?? this.key, t ?? this.value, r ?? this.color, i ?? this.left, s ?? this.right);
  }
  isEmpty() {
    return !1;
  }
  // Traverses the tree in key order and calls the specified action function
  // for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e);
  }
  // Traverses the tree in reverse key order and calls the specified action
  // function for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
  }
  // Returns the minimum node in the tree.
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  // Returns the maximum key in the tree.
  minKey() {
    return this.min().key;
  }
  // Returns the maximum key in the tree.
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  // Returns new tree, with the key/value added.
  insert(e, t, r) {
    let i = this;
    const s = r(e, i.key);
    return i = s < 0 ? i.copy(null, null, null, i.left.insert(e, t, r), null) : s === 0 ? i.copy(null, t, null, null, null) : i.copy(null, null, null, null, i.right.insert(e, t, r)), i.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return on.EMPTY;
    let e = this;
    return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp();
  }
  // Returns new tree, with the specified item removed.
  remove(e, t) {
    let r, i = this;
    if (t(e, i.key) < 0)
      i.left.isEmpty() || i.left.isRed() || i.left.left.isRed() || (i = i.moveRedLeft()), i = i.copy(null, null, null, i.left.remove(e, t), null);
    else {
      if (i.left.isRed() && (i = i.rotateRight()), i.right.isEmpty() || i.right.isRed() || i.right.left.isRed() || (i = i.moveRedRight()), t(e, i.key) === 0) {
        if (i.right.isEmpty())
          return on.EMPTY;
        r = i.right.min(), i = i.copy(r.key, r.value, null, null, i.right.removeMin());
      }
      i = i.copy(null, null, null, null, i.right.remove(e, t));
    }
    return i.fixUp();
  }
  isRed() {
    return this.color;
  }
  // Returns new tree after performing any needed rotations.
  fixUp() {
    let e = this;
    return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e;
  }
  moveRedLeft() {
    let e = this.colorFlip();
    return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e;
  }
  moveRedRight() {
    let e = this.colorFlip();
    return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e;
  }
  rotateLeft() {
    const e = this.copy(null, null, on.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, e, null);
  }
  rotateRight() {
    const e = this.copy(null, null, on.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, e);
  }
  colorFlip() {
    const e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, e, t);
  }
  // For testing.
  checkMaxDepth() {
    const e = this.check();
    return Math.pow(2, e) <= this.size + 1;
  }
  // In a balanced RB tree, the black-depth (number of black nodes) from root to
  // leaves is equal on both sides.  This function verifies that or asserts.
  check() {
    if (this.isRed() && this.left.isRed() || this.right.isRed())
      throw Ot();
    const e = this.left.check();
    if (e !== this.right.check())
      throw Ot();
    return e + (this.isRed() ? 0 : 1);
  }
}
on.EMPTY = null, on.RED = !0, on.BLACK = !1;
on.EMPTY = new // Represents an empty node (a leaf node in the Red-Black Tree).
class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw Ot();
  }
  get value() {
    throw Ot();
  }
  get color() {
    throw Ot();
  }
  get left() {
    throw Ot();
  }
  get right() {
    throw Ot();
  }
  // Returns a copy of the current node.
  copy(n, e, t, r, i) {
    return this;
  }
  // Returns a copy of the tree, with the specified key/value added.
  insert(n, e, t) {
    return new on(n, e);
  }
  // Returns a copy of the tree, with the specified key removed.
  remove(n, e) {
    return this;
  }
  isEmpty() {
    return !0;
  }
  inorderTraversal(n) {
    return !1;
  }
  reverseTraversal(n) {
    return !1;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return !1;
  }
  // For testing.
  checkMaxDepth() {
    return !0;
  }
  check() {
    return 0;
  }
}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ld {
  constructor(e) {
    this.comparator = e, this.data = new Fd(this.comparator);
  }
  has(e) {
    return this.data.get(e) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(e) {
    return this.data.indexOf(e);
  }
  /** Iterates elements in order defined by "comparator" */
  forEach(e) {
    this.data.inorderTraversal((t, r) => (e(t), !1));
  }
  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
  forEachInRange(e, t) {
    const r = this.data.getIteratorFrom(e[0]);
    for (; r.hasNext(); ) {
      const i = r.getNext();
      if (this.comparator(i.key, e[1]) >= 0)
        return;
      t(i.key);
    }
  }
  /**
   * Iterates over `elem`s such that: start &lt;= elem until false is returned.
   */
  forEachWhile(e, t) {
    let r;
    for (r = t !== void 0 ? this.data.getIteratorFrom(t) : this.data.getIterator(); r.hasNext(); )
      if (!e(r.getNext().key))
        return;
  }
  /** Finds the least element greater than or equal to `elem`. */
  firstAfterOrEqual(e) {
    const t = this.data.getIteratorFrom(e);
    return t.hasNext() ? t.getNext().key : null;
  }
  getIterator() {
    return new B2(this.data.getIterator());
  }
  getIteratorFrom(e) {
    return new B2(this.data.getIteratorFrom(e));
  }
  /** Inserts or updates an element */
  add(e) {
    return this.copy(this.data.remove(e).insert(e, !0));
  }
  /** Deletes an element */
  delete(e) {
    return this.has(e) ? this.copy(this.data.remove(e)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(e) {
    let t = this;
    return t.size < e.size && (t = e, e = this), e.forEach((r) => {
      t = t.add(r);
    }), t;
  }
  isEqual(e) {
    if (!(e instanceof Ld) || this.size !== e.size)
      return !1;
    const t = this.data.getIterator(), r = e.data.getIterator();
    for (; t.hasNext(); ) {
      const i = t.getNext().key, s = r.getNext().key;
      if (this.comparator(i, s) !== 0)
        return !1;
    }
    return !0;
  }
  toArray() {
    const e = [];
    return this.forEach((t) => {
      e.push(t);
    }), e;
  }
  toString() {
    const e = [];
    return this.forEach((t) => e.push(t)), "SortedSet(" + e.toString() + ")";
  }
  copy(e) {
    const t = new Ld(this.comparator);
    return t.data = e, t;
  }
}
class B2 {
  constructor(e) {
    this.iter = e;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ma {
  constructor(e) {
    this.fields = e, // TODO(dimond): validation of FieldMask
    // Sort the field mask to support `FieldMask.isEqual()` and assert below.
    e.sort(Zn.comparator);
  }
  static empty() {
    return new Ma([]);
  }
  /**
   * Returns a new FieldMask object that is the result of adding all the given
   * fields paths to this field mask.
   */
  unionWith(e) {
    let t = new Ld(Zn.comparator);
    for (const r of this.fields)
      t = t.add(r);
    for (const r of e)
      t = t.add(r);
    return new Ma(t.toArray());
  }
  /**
   * Verifies that `fieldPath` is included by at least one field in this field
   * mask.
   *
   * This is an O(n) operation, where `n` is the size of the field mask.
   */
  covers(e) {
    for (const t of this.fields)
      if (t.isPrefixOf(e))
        return !0;
    return !1;
  }
  isEqual(e) {
    return FT(this.fields, e.fields, (t, r) => t.isEqual(r));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lr {
  constructor(e) {
    this.value = e;
  }
  static empty() {
    return new lr({
      mapValue: {}
    });
  }
  /**
   * Returns the value at the given path or null.
   *
   * @param path - the path to search
   * @returns The value at the path or null if the path is not set.
   */
  field(e) {
    if (e.isEmpty())
      return this.value;
    {
      let t = this.value;
      for (let r = 0; r < e.length - 1; ++r)
        if (t = (t.mapValue.fields || {})[e.get(r)], !qp(t))
          return null;
      return t = (t.mapValue.fields || {})[e.lastSegment()], t || null;
    }
  }
  /**
   * Sets the field to the provided value.
   *
   * @param path - The field path to set.
   * @param value - The value to set.
   */
  set(e, t) {
    this.getFieldsMap(e.popLast())[e.lastSegment()] = ku(t);
  }
  /**
   * Sets the provided fields to the provided values.
   *
   * @param data - A map of fields to values (or null for deletes).
   */
  setAll(e) {
    let t = Zn.emptyPath(), r = {}, i = [];
    e.forEach((a, o) => {
      if (!t.isImmediateParentOf(o)) {
        const u = this.getFieldsMap(t);
        this.applyChanges(u, r, i), r = {}, i = [], t = o.popLast();
      }
      a ? r[o.lastSegment()] = ku(a) : i.push(o.lastSegment());
    });
    const s = this.getFieldsMap(t);
    this.applyChanges(s, r, i);
  }
  /**
   * Removes the field at the specified path. If there is no field at the
   * specified path, nothing is changed.
   *
   * @param path - The field path to remove.
   */
  delete(e) {
    const t = this.field(e.popLast());
    qp(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()];
  }
  isEqual(e) {
    return Dd(this.value, e.value);
  }
  /**
   * Returns the map that contains the leaf element of `path`. If the parent
   * entry does not yet exist, or if it is not a map, a new map will be created.
   */
  getFieldsMap(e) {
    let t = this.value;
    t.mapValue.fields || (t.mapValue = {
      fields: {}
    });
    for (let r = 0; r < e.length; ++r) {
      let i = t.mapValue.fields[e.get(r)];
      qp(i) && i.mapValue.fields || (i = {
        mapValue: {
          fields: {}
        }
      }, t.mapValue.fields[e.get(r)] = i), t = i;
    }
    return t.mapValue.fields;
  }
  /**
   * Modifies `fieldsMap` by adding, replacing or deleting the specified
   * entries.
   */
  applyChanges(e, t, r) {
    $l(t, (i, s) => e[i] = s);
    for (const i of r)
      delete e[i];
  }
  clone() {
    return new lr(ku(this.value));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ss {
  constructor(e, t, r, i, s, a, o) {
    this.key = e, this.documentType = t, this.version = r, this.readTime = i, this.createTime = s, this.data = a, this.documentState = o;
  }
  /**
   * Creates a document with no known version or data, but which can serve as
   * base document for mutations.
   */
  static newInvalidDocument(e) {
    return new ss(
      e,
      0,
      /* version */
      mn.min(),
      /* readTime */
      mn.min(),
      /* createTime */
      mn.min(),
      lr.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist with the given data at the
   * given version.
   */
  static newFoundDocument(e, t, r, i) {
    return new ss(
      e,
      1,
      /* version */
      t,
      /* readTime */
      mn.min(),
      /* createTime */
      r,
      i,
      0
      /* DocumentState.SYNCED */
    );
  }
  /** Creates a new document that is known to not exist at the given version. */
  static newNoDocument(e, t) {
    return new ss(
      e,
      2,
      /* version */
      t,
      /* readTime */
      mn.min(),
      /* createTime */
      mn.min(),
      lr.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist at the given version but
   * whose data is not known (e.g. a document that was updated without a known
   * base document).
   */
  static newUnknownDocument(e, t) {
    return new ss(
      e,
      3,
      /* version */
      t,
      /* readTime */
      mn.min(),
      /* createTime */
      mn.min(),
      lr.empty(),
      2
      /* DocumentState.HAS_COMMITTED_MUTATIONS */
    );
  }
  /**
   * Changes the document type to indicate that it exists and that its version
   * and data are known.
   */
  convertToFoundDocument(e, t) {
    return !this.createTime.isEqual(mn.min()) || this.documentType !== 2 && this.documentType !== 0 || (this.createTime = e), this.version = e, this.documentType = 1, this.data = t, this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it doesn't exist at the given
   * version.
   */
  convertToNoDocument(e) {
    return this.version = e, this.documentType = 2, this.data = lr.empty(), this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it exists at a given version but
   * that its data is not known (e.g. a document that was updated without a known
   * base document).
   */
  convertToUnknownDocument(e) {
    return this.version = e, this.documentType = 3, this.data = lr.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = mn.min(), this;
  }
  setReadTime(e) {
    return this.readTime = e, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(e) {
    return e instanceof ss && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data);
  }
  mutableCopy() {
    return new ss(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class XN {
  constructor(e, t = null, r = [], i = [], s = null, a = null, o = null) {
    this.path = e, this.collectionGroup = t, this.orderBy = r, this.filters = i, this.limit = s, this.startAt = a, this.endAt = o, this.S = null;
  }
}
function F2(n, e = null, t = [], r = [], i = null, s = null, a = null) {
  return new XN(n, e, t, r, i, s, a);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xy {
  /**
   * Initializes a Query with a path and optional additional query constraints.
   * Path must currently be empty if this is a collection group query.
   */
  constructor(e, t = null, r = [], i = [], s = null, a = "F", o = null, u = null) {
    this.path = e, this.collectionGroup = t, this.explicitOrderBy = r, this.filters = i, this.limit = s, this.limitType = a, this.startAt = o, this.endAt = u, this.q = null, // The corresponding `Target` of this `Query` instance.
    this.O = null, this.startAt, this.endAt;
  }
}
function Zy(n) {
  return n.explicitOrderBy.length > 0 ? n.explicitOrderBy[0].field : null;
}
function Cf(n) {
  for (const e of n.filters) {
    const t = e.getFirstInequalityField();
    if (t !== null)
      return t;
  }
  return null;
}
function ZN(n) {
  return n.collectionGroup !== null;
}
function L2(n) {
  const e = Ef(n);
  if (e.q === null) {
    e.q = [];
    const t = Cf(e), r = Zy(e);
    if (t !== null && r === null)
      t.isKeyField() || e.q.push(new Nu(t)), e.q.push(new Nu(
        Zn.keyField(),
        "asc"
        /* Direction.ASCENDING */
      ));
    else {
      let i = !1;
      for (const s of e.explicitOrderBy)
        e.q.push(s), s.field.isKeyField() && (i = !0);
      if (!i) {
        const s = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.q.push(new Nu(Zn.keyField(), s));
      }
    }
  }
  return e.q;
}
function eD(n) {
  const e = Ef(n);
  if (!e.O)
    if (e.limitType === "F")
      e.O = F2(e.path, e.collectionGroup, L2(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t = [];
      for (const s of L2(e)) {
        const a = s.dir === "desc" ? "asc" : "desc";
        t.push(new Nu(s.field, a));
      }
      const r = e.endAt ? new D2(e.endAt.position, e.endAt.inclusive) : null, i = e.startAt ? new D2(e.startAt.position, e.startAt.inclusive) : null;
      e.O = F2(e.path, e.collectionGroup, t, e.filters, e.limit, r, i);
    }
  return e.O;
}
function e0(n, e) {
  e.getFirstInequalityField(), Cf(n);
  const t = n.filters.concat([e]);
  return new Xy(n.path, n.collectionGroup, n.explicitOrderBy.slice(), t, n.limit, n.limitType, n.startAt, n.endAt);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function tD(n, e) {
  return function(t) {
    return typeof t == "number" && Number.isInteger(t) && !Nd(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER;
  }(e) ? (
    /**
    * Returns an IntegerValue for `value`.
    */
    function(t) {
      return {
        integerValue: "" + t
      };
    }(e)
  ) : function(t, r) {
    if (t.useProto3Json) {
      if (isNaN(r))
        return {
          doubleValue: "NaN"
        };
      if (r === 1 / 0)
        return {
          doubleValue: "Infinity"
        };
      if (r === -1 / 0)
        return {
          doubleValue: "-Infinity"
        };
    }
    return {
      doubleValue: Nd(r) ? "-0" : r
    };
  }(n, e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _f {
  constructor() {
    this._ = void 0;
  }
}
class nD extends _f {
}
class rD extends _f {
  constructor(e) {
    super(), this.elements = e;
  }
}
class iD extends _f {
  constructor(e) {
    super(), this.elements = e;
  }
}
class sD extends _f {
  constructor(e, t) {
    super(), this.serializer = e, this.k = t;
  }
}
class _i {
  constructor(e, t) {
    this.updateTime = e, this.exists = t;
  }
  /** Creates a new empty Precondition. */
  static none() {
    return new _i();
  }
  /** Creates a new Precondition with an exists flag. */
  static exists(e) {
    return new _i(void 0, e);
  }
  /** Creates a new Precondition based on a version a document exists at. */
  static updateTime(e) {
    return new _i(e);
  }
  /** Returns whether this Precondition is empty. */
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(e) {
    return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime);
  }
}
class Mf {
}
class zT extends Mf {
  constructor(e, t, r, i = []) {
    super(), this.key = e, this.value = t, this.precondition = r, this.fieldTransforms = i, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
}
class em extends Mf {
  constructor(e, t, r, i, s = []) {
    super(), this.key = e, this.data = t, this.fieldMask = r, this.precondition = i, this.fieldTransforms = s, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
}
class tm extends Mf {
  constructor(e, t) {
    super(), this.key = e, this.precondition = t, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
class aD extends Mf {
  constructor(e, t) {
    super(), this.key = e, this.precondition = t, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const oD = (() => ({
  asc: "ASCENDING",
  desc: "DESCENDING"
}))(), uD = (() => ({
  "<": "LESS_THAN",
  "<=": "LESS_THAN_OR_EQUAL",
  ">": "GREATER_THAN",
  ">=": "GREATER_THAN_OR_EQUAL",
  "==": "EQUAL",
  "!=": "NOT_EQUAL",
  "array-contains": "ARRAY_CONTAINS",
  in: "IN",
  "not-in": "NOT_IN",
  "array-contains-any": "ARRAY_CONTAINS_ANY"
}))(), lD = (() => ({
  and: "AND",
  or: "OR"
}))();
class cD {
  constructor(e, t) {
    this.databaseId = e, this.useProto3Json = t;
  }
}
function t0(n, e) {
  return n.useProto3Json ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z` : {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function dD(n, e) {
  return n.useProto3Json ? e.toBase64() : e.toUint8Array();
}
function fD(n, e) {
  return t0(n, e.toTimestamp());
}
function $2(n) {
  return As(!!n), mn.fromTimestamp(function(e) {
    const t = Ca(e);
    return new Un(t.seconds, t.nanos);
  }(n));
}
function nm(n, e) {
  return function(t) {
    return new Kt(["projects", t.projectId, "databases", t.database]);
  }(n).child("documents").child(e).canonicalString();
}
function n0(n, e) {
  return nm(n.databaseId, e.path);
}
function pD(n, e) {
  const t = function(i) {
    const s = Kt.fromString(i);
    return As(HT(s)), s;
  }(e);
  if (t.get(1) !== n.databaseId.projectId)
    throw new oe(fe, "Tried to deserialize key from different project: " + t.get(1) + " vs " + n.databaseId.projectId);
  if (t.get(3) !== n.databaseId.database)
    throw new oe(fe, "Tried to deserialize key from different database: " + t.get(3) + " vs " + n.databaseId.database);
  return new ln((As((r = t).length > 4 && r.get(4) === "documents"), r.popFirst(5)));
  var r;
}
function U2(n, e) {
  return nm(n.databaseId, e);
}
function hD(n) {
  return new Kt(["projects", n.databaseId.projectId, "databases", n.databaseId.database]).canonicalString();
}
function j2(n, e, t) {
  return {
    name: n0(n, e),
    fields: t.value.mapValue.fields
  };
}
function yD(n, e) {
  let t;
  if (e instanceof zT)
    t = {
      update: j2(n, e.key, e.value)
    };
  else if (e instanceof tm)
    t = {
      delete: n0(n, e.key)
    };
  else if (e instanceof em)
    t = {
      update: j2(n, e.key, e.data),
      updateMask: vD(e.fieldMask)
    };
  else {
    if (!(e instanceof aD))
      return Ot();
    t = {
      verify: n0(n, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (t.updateTransforms = e.fieldTransforms.map((r) => function(i, s) {
    const a = s.transform;
    if (a instanceof nD)
      return {
        fieldPath: s.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (a instanceof rD)
      return {
        fieldPath: s.field.canonicalString(),
        appendMissingElements: {
          values: a.elements
        }
      };
    if (a instanceof iD)
      return {
        fieldPath: s.field.canonicalString(),
        removeAllFromArray: {
          values: a.elements
        }
      };
    if (a instanceof sD)
      return {
        fieldPath: s.field.canonicalString(),
        increment: a.k
      };
    throw Ot();
  }(0, r))), e.precondition.isNone || (t.currentDocument = function(r, i) {
    return i.updateTime !== void 0 ? {
      updateTime: fD(r, i.updateTime)
    } : i.exists !== void 0 ? {
      exists: i.exists
    } : Ot();
  }(n, e.precondition)), t;
}
function mD(n, e) {
  const t = {
    structuredQuery: {}
  }, r = e.path;
  e.collectionGroup !== null ? (t.parent = U2(n, r), t.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: !0
  }]) : (t.parent = U2(n, r.popLast()), t.structuredQuery.from = [{
    collectionId: r.lastSegment()
  }]);
  const i = function(u) {
    if (u.length !== 0)
      return GT(Ul.create(
        u,
        "and"
        /* CompositeOperator.AND */
      ));
  }(e.filters);
  i && (t.structuredQuery.where = i);
  const s = function(u) {
    if (u.length !== 0)
      return u.map((l) => (
        // visible for testing
        function(d) {
          return {
            field: no(d.field),
            direction: bD(d.dir)
          };
        }(l)
      ));
  }(e.orderBy);
  s && (t.structuredQuery.orderBy = s);
  const a = function(u, l) {
    return u.useProto3Json || LN(l) ? l : {
      value: l
    };
  }(n, e.limit);
  var o;
  return a !== null && (t.structuredQuery.limit = a), e.startAt && (t.structuredQuery.startAt = {
    before: (o = e.startAt).inclusive,
    values: o.position
  }), e.endAt && (t.structuredQuery.endAt = function(u) {
    return {
      before: !u.inclusive,
      values: u.position
    };
  }(e.endAt)), t;
}
function bD(n) {
  return oD[n];
}
function gD(n) {
  return uD[n];
}
function xD(n) {
  return lD[n];
}
function no(n) {
  return {
    fieldPath: n.canonicalString()
  };
}
function GT(n) {
  return n instanceof $r ? function(e) {
    if (e.op === "==") {
      if (N2(e.value))
        return {
          unaryFilter: {
            field: no(e.field),
            op: "IS_NAN"
          }
        };
      if (k2(e.value))
        return {
          unaryFilter: {
            field: no(e.field),
            op: "IS_NULL"
          }
        };
    } else if (e.op === "!=") {
      if (N2(e.value))
        return {
          unaryFilter: {
            field: no(e.field),
            op: "IS_NOT_NAN"
          }
        };
      if (k2(e.value))
        return {
          unaryFilter: {
            field: no(e.field),
            op: "IS_NOT_NULL"
          }
        };
    }
    return {
      fieldFilter: {
        field: no(e.field),
        op: gD(e.op),
        value: e.value
      }
    };
  }(n) : n instanceof Ul ? function(e) {
    const t = e.getFilters().map((r) => GT(r));
    return t.length === 1 ? t[0] : {
      compositeFilter: {
        op: xD(e.op),
        filters: t
      }
    };
  }(n) : Ot();
}
function vD(n) {
  const e = [];
  return n.fields.forEach((t) => e.push(t.canonicalString())), {
    fieldPaths: e
  };
}
function HT(n) {
  return n.length >= 4 && n.get(0) === "projects" && n.get(2) === "databases";
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function rm(n) {
  return new cD(
    n,
    /* useProto3Json= */
    !0
  );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wD extends class {
} {
  constructor(e, t, r, i) {
    super(), this.authCredentials = e, this.appCheckCredentials = t, this.connection = r, this.serializer = i, this.J = !1;
  }
  X() {
    if (this.J)
      throw new oe(Sa, "The client has already been terminated.");
  }
  /** Invokes the provided RPC with auth and AppCheck tokens. */
  v(e, t, r) {
    return this.X(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([i, s]) => this.connection.v(e, t, r, i, s)).catch((i) => {
      throw i.name === "FirebaseError" ? (i.code === Zh && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), i) : new oe(Ou, i.toString());
    });
  }
  /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
  R(e, t, r, i) {
    return this.X(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, a]) => this.connection.R(e, t, r, s, a, i)).catch((s) => {
      throw s.name === "FirebaseError" ? (s.code === Zh && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), s) : new oe(Ou, s.toString());
    });
  }
  terminate() {
    this.J = !0;
  }
}
async function im(n, e) {
  const t = Ef(n), r = hD(t.serializer) + "/documents", i = {
    writes: e.map((s) => yD(t.serializer, s))
  };
  await t.v("Commit", r, i);
}
async function TD(n, e) {
  const t = Ef(n), r = mD(t.serializer, eD(e));
  return (await t.R("RunQuery", r.parent, {
    structuredQuery: r.structuredQuery
  })).filter((i) => !!i.document).map((i) => function(s, a, o) {
    const u = pD(s, a.name), l = $2(a.updateTime), d = a.createTime ? $2(a.createTime) : mn.min(), p = new lr({
      mapValue: {
        fields: a.fields
      }
    }), m = ss.newFoundDocument(u, l, d, p);
    return o && m.setHasCommittedMutations(), o ? m.setHasCommittedMutations() : m;
  }(t.serializer, i.document, void 0));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Du = /* @__PURE__ */ new Map();
function Pf(n) {
  if (n._terminated)
    throw new oe(Sa, "The client has already been terminated.");
  if (!Du.has(n)) {
    kd("ComponentProvider", "Initializing Datastore");
    const s = function(u) {
      return new UN(u, fetch.bind(null));
    }((e = n._databaseId, t = n.app.options.appId || "", r = n._persistenceKey, i = n._freezeSettings(), new DN(e, t, r, i.host, i.ssl, i.experimentalForceLongPolling, i.experimentalAutoDetectLongPolling, i.useFetchStreams))), a = rm(n._databaseId), o = function(u, l, d, p) {
      return new wD(u, l, d, p);
    }(n._authCredentials, n._appCheckCredentials, s, a);
    Du.set(n, o);
  }
  var e, t, r, i;
  /**
  * @license
  * Copyright 2018 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  return Du.get(n);
}
class V2 {
  constructor(e) {
    var t;
    if (e.host === void 0) {
      if (e.ssl !== void 0)
        throw new oe(fe, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = !0;
    } else
      this.host = e.host, this.ssl = (t = e.ssl) === null || t === void 0 || t;
    if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, this.cache = e.localCache, e.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
        throw new oe(fe, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = e.cacheSizeBytes;
    }
    (function(r, i, s, a) {
      if (i === !0 && a === !0)
        throw new oe(fe, `${r} and ${s} cannot be used together.`);
    })("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalForceLongPolling ? this.experimentalAutoDetectLongPolling = !1 : e.experimentalAutoDetectLongPolling === void 0 ? this.experimentalAutoDetectLongPolling = !1 : (
      // For backwards compatibility, coerce the value to boolean even though
      // the TypeScript compiler has narrowed the type to boolean already.
      // noinspection PointlessBooleanExpressionJS
      this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling
    ), this.useFetchStreams = !!e.useFetchStreams;
  }
  isEqual(e) {
    return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xo {
  /** @hideconstructor */
  constructor(e, t, r, i) {
    this._authCredentials = e, this._appCheckCredentials = t, this._databaseId = r, this._app = i, /**
     * Whether it's a Firestore or Firestore Lite instance.
     */
    this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new V2({}), this._settingsFrozen = !1;
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app)
      throw new oe(Sa, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(e) {
    if (this._settingsFrozen)
      throw new oe(Sa, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new V2(e), e.credentials !== void 0 && (this._authCredentials = function(t) {
      if (!t)
        return new MN();
      switch (t.type) {
        case "firstParty":
          return new ON(t.sessionIndex || "0", t.iamToken || null, t.authTokenFactory || null);
        case "provider":
          return t.client;
        default:
          throw new oe(fe, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(e.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = !0, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    return function(e) {
      const t = Du.get(e);
      t && (kd("ComponentProvider", "Removing Datastore"), Du.delete(e), t.terminate());
    }(this), Promise.resolve();
  }
}
function AD(n, e) {
  const t = typeof n == "object" ? n : oN(), r = typeof n == "string" ? n : e || "(default)", i = rN(t, "firestore/lite").getImmediate({
    identifier: r
  });
  if (!i._initialized) {
    const s = ek("firestore");
    s && qT(i, ...s);
  }
  return i;
}
function qT(n, e, t, r = {}) {
  var i;
  const s = (n = Ll(n, Xo))._getSettings();
  if (s.host !== "firestore.googleapis.com" && s.host !== e && kT("Host has been set in both settings() and useEmulator(), emulator host will be used"), n._setSettings(Object.assign(Object.assign({}, s), {
    host: `${e}:${t}`,
    ssl: !1
  })), r.mockUserToken) {
    let a, o;
    if (typeof r.mockUserToken == "string")
      a = r.mockUserToken, o = Bn.MOCK_USER;
    else {
      a = rk(r.mockUserToken, (i = n._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const u = r.mockUserToken.sub || r.mockUserToken.user_id;
      if (!u)
        throw new oe(fe, "mockUserToken must contain 'sub' or 'user_id' field!");
      o = new Bn(u);
    }
    n._authCredentials = new PN(new DT(a, o));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Mn {
  /** @hideconstructor */
  constructor(e, t, r) {
    this.converter = t, this._key = r, /** The type of this Firestore reference. */
    this.type = "document", this.firestore = e;
  }
  get _path() {
    return this._key.path;
  }
  /**
   * The document's identifier within its collection.
   */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  get path() {
    return this._key.path.canonicalString();
  }
  /**
   * The collection this `DocumentReference` belongs to.
   */
  get parent() {
    return new Mi(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(e) {
    return new Mn(this.firestore, e, this._key);
  }
}
class Is {
  // This is the lite version of the Query class in the main SDK.
  /** @hideconstructor protected */
  constructor(e, t, r) {
    this.converter = t, this._query = r, /** The type of this Firestore reference. */
    this.type = "query", this.firestore = e;
  }
  withConverter(e) {
    return new Is(this.firestore, e, this._query);
  }
}
class Mi extends Is {
  /** @hideconstructor */
  constructor(e, t, r) {
    super(e, t, new Xy(r)), this._path = r, /** The type of this Firestore reference. */
    this.type = "collection";
  }
  /** The collection's identifier. */
  get id() {
    return this._query.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   */
  get path() {
    return this._query.path.canonicalString();
  }
  /**
   * A reference to the containing `DocumentReference` if this is a
   * subcollection. If this isn't a subcollection, the reference is null.
   */
  get parent() {
    const e = this._path.popLast();
    return e.isEmpty() ? null : new Mn(
      this.firestore,
      /* converter= */
      null,
      new ln(e)
    );
  }
  withConverter(e) {
    return new Mi(this.firestore, e, this._path);
  }
}
function r0(n, e, ...t) {
  if (n = oi(n), BT("collection", "path", e), n instanceof Xo) {
    const r = Kt.fromString(e, ...t);
    return _2(r), new Mi(
      n,
      /* converter= */
      null,
      r
    );
  }
  {
    if (!(n instanceof Mn || n instanceof Mi))
      throw new oe(fe, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = n._path.child(Kt.fromString(e, ...t));
    return _2(r), new Mi(
      n.firestore,
      /* converter= */
      null,
      r
    );
  }
}
function $c(n, e, ...t) {
  if (n = oi(n), // We allow omission of 'pathString' but explicitly prohibit passing in both
  // 'undefined' and 'null'.
  arguments.length === 1 && (e = VN.D()), BT("doc", "path", e), n instanceof Xo) {
    const r = Kt.fromString(e, ...t);
    return C2(r), new Mn(
      n,
      /* converter= */
      null,
      new ln(r)
    );
  }
  {
    if (!(n instanceof Mn || n instanceof Mi))
      throw new oe(fe, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = n._path.child(Kt.fromString(e, ...t));
    return C2(r), new Mn(n.firestore, n instanceof Mi ? n.converter : null, new ln(r));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pa {
  /** @hideconstructor */
  constructor(e) {
    this._byteString = e;
  }
  /**
   * Creates a new `Bytes` object from the given Base64 string, converting it to
   * bytes.
   *
   * @param base64 - The Base64 string used to create the `Bytes` object.
   */
  static fromBase64String(e) {
    try {
      return new Pa(Fi.fromBase64String(e));
    } catch (t) {
      throw new oe(fe, "Failed to construct data from Base64 string: " + t);
    }
  }
  /**
   * Creates a new `Bytes` object from the given Uint8Array.
   *
   * @param array - The Uint8Array used to create the `Bytes` object.
   */
  static fromUint8Array(e) {
    return new Pa(Fi.fromUint8Array(e));
  }
  /**
   * Returns the underlying bytes as a Base64-encoded string.
   *
   * @returns The Base64-encoded string created from the `Bytes` object.
   */
  toBase64() {
    return this._byteString.toBase64();
  }
  /**
   * Returns the underlying bytes in a new `Uint8Array`.
   *
   * @returns The Uint8Array created from the `Bytes` object.
   */
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  /**
   * Returns a string representation of the `Bytes` object.
   *
   * @returns A string representation of the `Bytes` object.
   */
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  /**
   * Returns true if this `Bytes` object is equal to the provided one.
   *
   * @param other - The `Bytes` object to compare against.
   * @returns true if this `Bytes` object is equal to the provided one.
   */
  isEqual(e) {
    return this._byteString.isEqual(e._byteString);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jl {
  /**
   * Creates a `FieldPath` from the provided field names. If more than one field
   * name is provided, the path will point to a nested field in a document.
   *
   * @param fieldNames - A list of field names.
   */
  constructor(...e) {
    for (let t = 0; t < e.length; ++t)
      if (e[t].length === 0)
        throw new oe(fe, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new Zn(e);
  }
  /**
   * Returns true if this `FieldPath` is equal to the provided one.
   *
   * @param other - The `FieldPath` to compare against.
   * @returns true if this `FieldPath` is equal to the provided one.
   */
  isEqual(e) {
    return this._internalPath.isEqual(e._internalPath);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Rf {
  /**
   * @param _methodName - The public API endpoint that returns this class.
   * @hideconstructor
   */
  constructor(e) {
    this._methodName = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class If {
  /**
   * Creates a new immutable `GeoPoint` object with the provided latitude and
   * longitude values.
   * @param latitude - The latitude as number between -90 and 90.
   * @param longitude - The longitude as number between -180 and 180.
   */
  constructor(e, t) {
    if (!isFinite(e) || e < -90 || e > 90)
      throw new oe(fe, "Latitude must be a number between -90 and 90, but was: " + e);
    if (!isFinite(t) || t < -180 || t > 180)
      throw new oe(fe, "Longitude must be a number between -180 and 180, but was: " + t);
    this._lat = e, this._long = t;
  }
  /**
   * The latitude of this `GeoPoint` instance.
   */
  get latitude() {
    return this._lat;
  }
  /**
   * The longitude of this `GeoPoint` instance.
   */
  get longitude() {
    return this._long;
  }
  /**
   * Returns true if this `GeoPoint` is equal to the provided one.
   *
   * @param other - The `GeoPoint` to compare against.
   * @returns true if this `GeoPoint` is equal to the provided one.
   */
  isEqual(e) {
    return this._lat === e._lat && this._long === e._long;
  }
  /** Returns a JSON-serializable representation of this GeoPoint. */
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  /**
   * Actually private to JS consumers of our API, so this function is prefixed
   * with an underscore.
   */
  _compareTo(e) {
    return Yt(this._lat, e._lat) || Yt(this._long, e._long);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ED = /^__.*__$/;
class SD {
  constructor(e, t, r) {
    this.data = e, this.fieldMask = t, this.fieldTransforms = r;
  }
  toMutation(e, t) {
    return this.fieldMask !== null ? new em(e, this.data, this.fieldMask, t, this.fieldTransforms) : new zT(e, this.data, t, this.fieldTransforms);
  }
}
class WT {
  constructor(e, t, r) {
    this.data = e, this.fieldMask = t, this.fieldTransforms = r;
  }
  toMutation(e, t) {
    return new em(e, this.data, this.fieldMask, t, this.fieldTransforms);
  }
}
function KT(n) {
  switch (n) {
    case 0:
    case 2:
    case 1:
      return !0;
    case 3:
    case 4:
      return !1;
    default:
      throw Ot();
  }
}
class sm {
  /**
   * Initializes a ParseContext with the given source and path.
   *
   * @param settings - The settings for the parser.
   * @param databaseId - The database ID of the Firestore instance.
   * @param serializer - The serializer to use to generate the Value proto.
   * @param ignoreUndefinedProperties - Whether to ignore undefined properties
   * rather than throw.
   * @param fieldTransforms - A mutable list of field transforms encountered
   * while parsing the data.
   * @param fieldMask - A mutable list of field paths encountered while parsing
   * the data.
   *
   * TODO(b/34871131): We don't support array paths right now, so path can be
   * null to indicate the context represents any location within an array (in
   * which case certain features will not work and errors will be somewhat
   * compromised).
   */
  constructor(e, t, r, i, s, a) {
    this.settings = e, this.databaseId = t, this.serializer = r, this.ignoreUndefinedProperties = i, // Minor hack: If fieldTransforms is undefined, we assume this is an
    // external call and we need to validate the entire path.
    s === void 0 && this.tt(), this.fieldTransforms = s || [], this.fieldMask = a || [];
  }
  get path() {
    return this.settings.path;
  }
  get et() {
    return this.settings.et;
  }
  /** Returns a new context with the specified settings overwritten. */
  nt(e) {
    return new sm(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  rt(e) {
    var t;
    const r = (t = this.path) === null || t === void 0 ? void 0 : t.child(e), i = this.nt({
      path: r,
      st: !1
    });
    return i.it(e), i;
  }
  ot(e) {
    var t;
    const r = (t = this.path) === null || t === void 0 ? void 0 : t.child(e), i = this.nt({
      path: r,
      st: !1
    });
    return i.tt(), i;
  }
  ut(e) {
    return this.nt({
      path: void 0,
      st: !0
    });
  }
  ct(e) {
    return $d(e, this.settings.methodName, this.settings.at || !1, this.path, this.settings.ht);
  }
  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
  contains(e) {
    return this.fieldMask.find((t) => e.isPrefixOf(t)) !== void 0 || this.fieldTransforms.find((t) => e.isPrefixOf(t.field)) !== void 0;
  }
  tt() {
    if (this.path)
      for (let e = 0; e < this.path.length; e++)
        this.it(this.path.get(e));
  }
  it(e) {
    if (e.length === 0)
      throw this.ct("Document fields must not be empty");
    if (KT(this.et) && ED.test(e))
      throw this.ct('Document fields cannot begin and end with "__"');
  }
}
class CD {
  constructor(e, t, r) {
    this.databaseId = e, this.ignoreUndefinedProperties = t, this.serializer = r || rm(e);
  }
  /** Creates a new top-level parse context. */
  lt(e, t, r, i = !1) {
    return new sm({
      et: e,
      methodName: t,
      ht: r,
      path: Zn.emptyPath(),
      st: !1,
      at: i
    }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
  }
}
function am(n) {
  const e = n._freezeSettings(), t = rm(n._databaseId);
  return new CD(n._databaseId, !!e.ignoreUndefinedProperties, t);
}
function JT(n, e, t, r, i, s = {}) {
  const a = n.lt(s.merge || s.mergeFields ? 2 : 0, e, t, i);
  om("Data must be an object, but it was:", a, r);
  const o = QT(r, a);
  let u, l;
  if (s.merge)
    u = new Ma(a.fieldMask), l = a.fieldTransforms;
  else if (s.mergeFields) {
    const d = [];
    for (const p of s.mergeFields) {
      const m = i0(e, p, t);
      if (!a.contains(m))
        throw new oe(fe, `Field '${m}' is specified in your field mask but missing from your input data.`);
      XT(d, m) || d.push(m);
    }
    u = new Ma(d), l = a.fieldTransforms.filter((p) => u.covers(p.field));
  } else
    u = null, l = a.fieldTransforms;
  return new SD(new lr(o), u, l);
}
class Of extends Rf {
  _toFieldTransform(e) {
    if (e.et !== 2)
      throw e.et === 1 ? e.ct(`${this._methodName}() can only appear at the top level of your update data`) : e.ct(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return e.fieldMask.push(e.path), null;
  }
  isEqual(e) {
    return e instanceof Of;
  }
}
function _D(n, e, t, r) {
  const i = n.lt(1, e, t);
  om("Data must be an object, but it was:", i, r);
  const s = [], a = lr.empty();
  $l(r, (u, l) => {
    const d = um(e, u, t);
    l = oi(l);
    const p = i.ot(d);
    if (l instanceof Of)
      s.push(d);
    else {
      const m = Vl(l, p);
      m != null && (s.push(d), a.set(d, m));
    }
  });
  const o = new Ma(s);
  return new WT(a, o, i.fieldTransforms);
}
function MD(n, e, t, r, i, s) {
  const a = n.lt(1, e, t), o = [i0(e, r, t)], u = [i];
  if (s.length % 2 != 0)
    throw new oe(fe, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let m = 0; m < s.length; m += 2)
    o.push(i0(e, s[m])), u.push(s[m + 1]);
  const l = [], d = lr.empty();
  for (let m = o.length - 1; m >= 0; --m)
    if (!XT(l, o[m])) {
      const w = o[m];
      let x = u[m];
      x = oi(x);
      const T = a.ot(w);
      if (x instanceof Of)
        l.push(w);
      else {
        const A = Vl(x, T);
        A != null && (l.push(w), d.set(w, A));
      }
    }
  const p = new Ma(l);
  return new WT(d, p, a.fieldTransforms);
}
function PD(n, e, t, r = !1) {
  return Vl(t, n.lt(r ? 4 : 3, e));
}
function Vl(n, e) {
  if (YT(
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    n = oi(n)
  ))
    return om("Unsupported field value:", e, n), QT(n, e);
  if (n instanceof Rf)
    return function(t, r) {
      if (!KT(r.et))
        throw r.ct(`${t._methodName}() can only be used with update() and set()`);
      if (!r.path)
        throw r.ct(`${t._methodName}() is not currently supported inside arrays`);
      const i = t._toFieldTransform(r);
      i && r.fieldTransforms.push(i);
    }(n, e), null;
  if (n === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    e.path && e.fieldMask.push(e.path), n instanceof Array
  ) {
    if (e.settings.st && e.et !== 4)
      throw e.ct("Nested arrays are not supported");
    return function(t, r) {
      const i = [];
      let s = 0;
      for (const a of t) {
        let o = Vl(a, r.ut(s));
        o == null && // Just include nulls in the array for fields being replaced with a
        // sentinel.
        (o = {
          nullValue: "NULL_VALUE"
        }), i.push(o), s++;
      }
      return {
        arrayValue: {
          values: i
        }
      };
    }(n, e);
  }
  return function(t, r) {
    if ((t = oi(t)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t == "number")
      return tD(r.serializer, t);
    if (typeof t == "boolean")
      return {
        booleanValue: t
      };
    if (typeof t == "string")
      return {
        stringValue: t
      };
    if (t instanceof Date) {
      const i = Un.fromDate(t);
      return {
        timestampValue: t0(r.serializer, i)
      };
    }
    if (t instanceof Un) {
      const i = new Un(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3));
      return {
        timestampValue: t0(r.serializer, i)
      };
    }
    if (t instanceof If)
      return {
        geoPointValue: {
          latitude: t.latitude,
          longitude: t.longitude
        }
      };
    if (t instanceof Pa)
      return {
        bytesValue: dD(r.serializer, t._byteString)
      };
    if (t instanceof Mn) {
      const i = r.databaseId, s = t.firestore._databaseId;
      if (!s.isEqual(i))
        throw r.ct(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${i.projectId}/${i.database}`);
      return {
        referenceValue: nm(t.firestore._databaseId || r.databaseId, t._key.path)
      };
    }
    throw r.ct(`Unsupported field value: ${Sf(t)}`);
  }(n, e);
}
function QT(n, e) {
  const t = {};
  return function(r) {
    for (const i in r)
      if (Object.prototype.hasOwnProperty.call(r, i))
        return !1;
    return !0;
  }(n) ? (
    // If we encounter an empty object, we explicitly add it to the update
    // mask to ensure that the server creates a map entry.
    e.path && e.path.length > 0 && e.fieldMask.push(e.path)
  ) : $l(n, (r, i) => {
    const s = Vl(i, e.rt(r));
    s != null && (t[r] = s);
  }), {
    mapValue: {
      fields: t
    }
  };
}
function YT(n) {
  return !(typeof n != "object" || n === null || n instanceof Array || n instanceof Date || n instanceof Un || n instanceof If || n instanceof Pa || n instanceof Mn || n instanceof Rf);
}
function om(n, e, t) {
  if (!YT(t) || !function(r) {
    return typeof r == "object" && r !== null && (Object.getPrototypeOf(r) === Object.prototype || Object.getPrototypeOf(r) === null);
  }(t)) {
    const r = Sf(t);
    throw r === "an object" ? e.ct(n + " a custom object") : e.ct(n + " " + r);
  }
}
function i0(n, e, t) {
  if (
    // If required, replace the FieldPath Compat class with with the firestore-exp
    // FieldPath.
    (e = oi(e)) instanceof jl
  )
    return e._internalPath;
  if (typeof e == "string")
    return um(n, e);
  throw $d(
    "Field path arguments must be of type string or ",
    n,
    /* hasConverter= */
    !1,
    /* path= */
    void 0,
    t
  );
}
const RD = new RegExp("[~\\*/\\[\\]]");
function um(n, e, t) {
  if (e.search(RD) >= 0)
    throw $d(
      `Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,
      n,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      t
    );
  try {
    return new jl(...e.split("."))._internalPath;
  } catch {
    throw $d(
      `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      n,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      t
    );
  }
}
function $d(n, e, t, r, i) {
  const s = r && !r.isEmpty(), a = i !== void 0;
  let o = `Function ${e}() called with invalid data`;
  t && (o += " (via `toFirestore()`)"), o += ". ";
  let u = "";
  return (s || a) && (u += " (found", s && (u += ` in field ${r}`), a && (u += ` in document ${i}`), u += ")"), new oe(fe, o + n + u);
}
function XT(n, e) {
  return n.some((t) => t.isEqual(e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ZT {
  // Note: This class is stripped down version of the DocumentSnapshot in
  // the legacy SDK. The changes are:
  // - No support for SnapshotMetadata.
  // - No support for SnapshotOptions.
  /** @hideconstructor protected */
  constructor(e, t, r, i, s) {
    this._firestore = e, this._userDataWriter = t, this._key = r, this._document = i, this._converter = s;
  }
  /** Property of the `DocumentSnapshot` that provides the document's ID. */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * The `DocumentReference` for the document included in the `DocumentSnapshot`.
   */
  get ref() {
    return new Mn(this._firestore, this._converter, this._key);
  }
  /**
   * Signals whether or not the document at the snapshot's location exists.
   *
   * @returns true if the document exists.
   */
  exists() {
    return this._document !== null;
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * @returns An `Object` containing all fields in the document or `undefined`
   * if the document doesn't exist.
   */
  data() {
    if (this._document) {
      if (this._converter) {
        const e = new lm(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          /* converter= */
          null
        );
        return this._converter.fromFirestore(e);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(e) {
    if (this._document) {
      const t = this._document.data.field(cm("DocumentSnapshot.get", e));
      if (t !== null)
        return this._userDataWriter.convertValue(t);
    }
  }
}
class lm extends ZT {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * @override
   * @returns An `Object` containing all fields in the document.
   */
  data() {
    return super.data();
  }
}
class e5 {
  /** @hideconstructor */
  constructor(e, t) {
    this._docs = t, this.query = e;
  }
  /** An array of all the documents in the `QuerySnapshot`. */
  get docs() {
    return [...this._docs];
  }
  /** The number of documents in the `QuerySnapshot`. */
  get size() {
    return this.docs.length;
  }
  /** True if there are no documents in the `QuerySnapshot`. */
  get empty() {
    return this.docs.length === 0;
  }
  /**
   * Enumerates all of the documents in the `QuerySnapshot`.
   *
   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
   * each document in the snapshot.
   * @param thisArg - The `this` binding for the callback.
   */
  forEach(e, t) {
    this._docs.forEach(e, t);
  }
}
function cm(n, e) {
  return typeof e == "string" ? um(n, e) : e instanceof jl ? e._internalPath : e._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dm {
}
class fm extends dm {
}
function t5(n, e, ...t) {
  let r = [];
  e instanceof dm && r.push(e), r = r.concat(t), function(i) {
    const s = i.filter((o) => o instanceof kf).length, a = i.filter((o) => o instanceof zl).length;
    if (s > 1 || s > 0 && a > 0)
      throw new oe(fe, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.");
  }(r);
  for (const i of r)
    n = i._apply(n);
  return n;
}
class zl extends fm {
  /**
   * @internal
   */
  constructor(e, t, r) {
    super(), this._field = e, this._op = t, this._value = r, /** The type of this query constraint */
    this.type = "where";
  }
  static _create(e, t, r) {
    return new zl(e, t, r);
  }
  _apply(e) {
    const t = this._parse(e);
    return r5(e._query, t), new Is(e.firestore, e.converter, e0(e._query, t));
  }
  _parse(e) {
    const t = am(e.firestore);
    return function(i, s, a, o, u, l, d) {
      let p;
      if (u.isKeyField()) {
        if (l === "array-contains" || l === "array-contains-any")
          throw new oe(fe, `Invalid Query. You can't perform '${l}' queries on documentId().`);
        if (l === "in" || l === "not-in") {
          G2(d, l);
          const m = [];
          for (const w of d)
            m.push(z2(o, i, w));
          p = {
            arrayValue: {
              values: m
            }
          };
        } else
          p = z2(o, i, d);
      } else
        l !== "in" && l !== "not-in" && l !== "array-contains-any" || G2(d, l), p = PD(
          a,
          s,
          d,
          /* allowArrays= */
          l === "in" || l === "not-in"
        );
      return $r.create(u, l, p);
    }(e._query, "where", t, e.firestore._databaseId, this._field, this._op, this._value);
  }
}
function n5(n, e, t) {
  const r = e, i = cm("where", n);
  return zl._create(i, r, t);
}
class kf extends dm {
  /**
   * @internal
   */
  constructor(e, t) {
    super(), this.type = e, this._queryConstraints = t;
  }
  static _create(e, t) {
    return new kf(e, t);
  }
  _parse(e) {
    const t = this._queryConstraints.map((r) => r._parse(e)).filter((r) => r.getFilters().length > 0);
    return t.length === 1 ? t[0] : Ul.create(t, this._getOperator());
  }
  _apply(e) {
    const t = this._parse(e);
    return t.getFilters().length === 0 ? e : (function(r, i) {
      let s = r;
      const a = i.getFlattenedFilters();
      for (const o of a)
        r5(s, o), s = e0(s, o);
    }(e._query, t), new Is(e.firestore, e.converter, e0(e._query, t)));
  }
  _getQueryConstraints() {
    return this._queryConstraints;
  }
  _getOperator() {
    return this.type === "and" ? "and" : "or";
  }
}
class Nf extends fm {
  /**
   * @internal
   */
  constructor(e, t) {
    super(), this._field = e, this._direction = t, /** The type of this query constraint */
    this.type = "orderBy";
  }
  static _create(e, t) {
    return new Nf(e, t);
  }
  _apply(e) {
    const t = function(r, i, s) {
      if (r.startAt !== null)
        throw new oe(fe, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (r.endAt !== null)
        throw new oe(fe, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const a = new Nu(i, s);
      return function(o, u) {
        if (Zy(o) === null) {
          const l = Cf(o);
          l !== null && i5(o, l, u.field);
        }
      }(r, a), a;
    }(e._query, this._field, this._direction);
    return new Is(e.firestore, e.converter, function(r, i) {
      const s = r.explicitOrderBy.concat([i]);
      return new Xy(r.path, r.collectionGroup, s, r.filters.slice(), r.limit, r.limitType, r.startAt, r.endAt);
    }(e._query, t));
  }
}
function ID(n, e = "asc") {
  const t = e, r = cm("orderBy", n);
  return Nf._create(r, t);
}
function z2(n, e, t) {
  if (typeof (t = oi(t)) == "string") {
    if (t === "")
      throw new oe(fe, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!ZN(e) && t.indexOf("/") !== -1)
      throw new oe(fe, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${t}' contains a '/' character.`);
    const r = e.path.child(Kt.fromString(t));
    if (!ln.isDocumentKey(r))
      throw new oe(fe, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`);
    return O2(n, new ln(r));
  }
  if (t instanceof Mn)
    return O2(n, t._key);
  throw new oe(fe, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${Sf(t)}.`);
}
function G2(n, e) {
  if (!Array.isArray(n) || n.length === 0)
    throw new oe(fe, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
}
function r5(n, e) {
  if (e.isInequality()) {
    const r = Cf(n), i = e.field;
    if (r !== null && !r.isEqual(i))
      throw new oe(fe, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${r.toString()}' and '${i.toString()}'`);
    const s = Zy(n);
    s !== null && i5(n, i, s);
  }
  const t = function(r, i) {
    for (const s of r)
      for (const a of s.getFlattenedFilters())
        if (i.indexOf(a.op) >= 0)
          return a.op;
    return null;
  }(n.filters, function(r) {
    switch (r) {
      case "!=":
        return [
          "!=",
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "array-contains-any":
      case "in":
        return [
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "not-in":
        return [
          "array-contains-any",
          "in",
          "not-in",
          "!="
          /* Operator.NOT_EQUAL */
        ];
      default:
        return [];
    }
  }(e.op));
  if (t !== null)
    throw t === e.op ? new oe(fe, `Invalid query. You cannot use more than one '${e.op.toString()}' filter.`) : new oe(fe, `Invalid query. You cannot use '${e.op.toString()}' filters with '${t.toString()}' filters.`);
}
function i5(n, e, t) {
  if (!t.isEqual(e))
    throw new oe(fe, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${t.toString()}' instead.`);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function s5(n, e, t) {
  let r;
  return r = n ? t && (t.merge || t.mergeFields) ? n.toFirestore(e, t) : n.toFirestore(e) : e, r;
}
class OD extends class {
  convertValue(e, t = "none") {
    switch (_a(e)) {
      case 0:
        return null;
      case 1:
        return e.booleanValue;
      case 2:
        return qt(e.integerValue || e.doubleValue);
      case 3:
        return this.convertTimestamp(e.timestampValue);
      case 4:
        return this.convertServerTimestamp(e, t);
      case 5:
        return e.stringValue;
      case 6:
        return this.convertBytes(hl(e.bytesValue));
      case 7:
        return this.convertReference(e.referenceValue);
      case 8:
        return this.convertGeoPoint(e.geoPointValue);
      case 9:
        return this.convertArray(e.arrayValue, t);
      case 10:
        return this.convertObject(e.mapValue, t);
      default:
        throw Ot();
    }
  }
  convertObject(e, t) {
    return this.convertObjectMap(e.fields, t);
  }
  /**
   * @internal
   */
  convertObjectMap(e, t = "none") {
    const r = {};
    return $l(e, (i, s) => {
      r[i] = this.convertValue(s, t);
    }), r;
  }
  convertGeoPoint(e) {
    return new If(qt(e.latitude), qt(e.longitude));
  }
  convertArray(e, t) {
    return (e.values || []).map((r) => this.convertValue(r, t));
  }
  convertServerTimestamp(e, t) {
    switch (t) {
      case "previous":
        const r = $T(e);
        return r == null ? null : this.convertValue(r, t);
      case "estimate":
        return this.convertTimestamp(yl(e));
      default:
        return null;
    }
  }
  convertTimestamp(e) {
    const t = Ca(e);
    return new Un(t.seconds, t.nanos);
  }
  convertDocumentKey(e, t) {
    const r = Kt.fromString(e);
    As(HT(r));
    const i = new fl(r.get(1), r.get(3)), s = new ln(r.popFirst(5));
    return i.isEqual(t) || // TODO(b/64130202): Somehow support foreign references.
    Qy(`Document ${s} contains a document reference within a different database (${i.projectId}/${i.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`), s;
  }
} {
  constructor(e) {
    super(), this.firestore = e;
  }
  convertBytes(e) {
    return new Pa(e);
  }
  convertReference(e) {
    const t = this.convertDocumentKey(e, this.firestore._databaseId);
    return new Mn(
      this.firestore,
      /* converter= */
      null,
      t
    );
  }
}
function s0(n) {
  (function(r) {
    if (r.limitType === "L" && r.explicitOrderBy.length === 0)
      throw new oe(NT, "limitToLast() queries require specifying at least one orderBy() clause");
  })((n = Ll(n, Is))._query);
  const e = Pf(n.firestore), t = new OD(n.firestore);
  return TD(e, n._query).then((r) => {
    const i = r.map((s) => new lm(n.firestore, t, s.key, s, n.converter));
    return n._query.limitType === "L" && // Limit to last queries reverse the orderBy constraint that was
    // specified by the user. As such, we need to reverse the order of the
    // results to return the documents in the expected order.
    i.reverse(), new e5(n, i);
  });
}
function a0(n, e, t) {
  const r = s5((n = Ll(n, Mn)).converter, e, t), i = JT(am(n.firestore), "setDoc", n._key, r, n.converter !== null, t);
  return im(Pf(n.firestore), [i.toMutation(n._key, _i.none())]);
}
function a5(n) {
  return im(Pf((n = Ll(n, Mn)).firestore), [new tm(n._key, _i.none())]);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class o5 {
  /** @hideconstructor */
  constructor(e, t) {
    this._firestore = e, this._commitHandler = t, this._mutations = [], this._committed = !1, this._dataReader = am(e);
  }
  set(e, t, r) {
    this._verifyNotCommitted();
    const i = Wp(e, this._firestore), s = s5(i.converter, t, r), a = JT(this._dataReader, "WriteBatch.set", i._key, s, i.converter !== null, r);
    return this._mutations.push(a.toMutation(i._key, _i.none())), this;
  }
  update(e, t, r, ...i) {
    this._verifyNotCommitted();
    const s = Wp(e, this._firestore);
    let a;
    return a = typeof (t = oi(t)) == "string" || t instanceof jl ? MD(this._dataReader, "WriteBatch.update", s._key, t, r, i) : _D(this._dataReader, "WriteBatch.update", s._key, t), this._mutations.push(a.toMutation(s._key, _i.exists(!0))), this;
  }
  /**
   * Deletes the document referred to by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be deleted.
   * @returns This `WriteBatch` instance. Used for chaining method calls.
   */
  delete(e) {
    this._verifyNotCommitted();
    const t = Wp(e, this._firestore);
    return this._mutations = this._mutations.concat(new tm(t._key, _i.none())), this;
  }
  /**
   * Commits all of the writes in this write batch as a single atomic unit.
   *
   * The result of these writes will only be reflected in document reads that
   * occur after the returned promise resolves. If the client is offline, the
   * write fails. If you would like to see local modifications or buffer writes
   * until the client is online, use the full Firestore SDK.
   *
   * @returns A `Promise` resolved once all of the writes in the batch have been
   * successfully written to the backend as an atomic unit (note that it won't
   * resolve while you're offline).
   */
  commit() {
    return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new oe(Sa, "A write batch can no longer be used after commit() has been called.");
  }
}
function Wp(n, e) {
  if ((n = oi(n)).firestore !== e)
    throw new oe(fe, "Provided document reference is from a different Firestore instance.");
  return n;
}
function u5(n) {
  const e = Pf(n = Ll(n, Xo));
  return new o5(n, (t) => im(e, t));
}
(function(n) {
  Yo = n;
})(`${aN}_lite`), Od(new cl("firestore/lite", (n, { instanceIdentifier: e, options: t }) => {
  const r = n.getProvider("app").getImmediate(), i = new Xo(new RN(n.getProvider("auth-internal")), new NN(n.getProvider("app-check-internal")), function(s, a) {
    if (!Object.prototype.hasOwnProperty.apply(s.options, ["projectId"]))
      throw new oe(fe, '"projectId" not provided in firebase.initializeApp.');
    return new fl(s.options.projectId, a);
  }(r, e), r);
  return t && i._setSettings(t), i;
}, "PUBLIC").setMultipleInstances(!0)), // RUNTIME_ENV and BUILD_TARGET are replaced by real values during the compilation
bo("firestore-lite", "3.11.0", ""), bo("firestore-lite", "3.11.0", "esm2017");
const H2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bytes: Pa,
  CollectionReference: Mi,
  DocumentReference: Mn,
  DocumentSnapshot: ZT,
  FieldPath: jl,
  FieldValue: Rf,
  Firestore: Xo,
  FirestoreError: oe,
  GeoPoint: If,
  Query: Is,
  QueryCompositeFilterConstraint: kf,
  QueryConstraint: fm,
  QueryDocumentSnapshot: lm,
  QueryFieldFilterConstraint: zl,
  QueryOrderByConstraint: Nf,
  QuerySnapshot: e5,
  Timestamp: Un,
  WriteBatch: o5,
  collection: r0,
  connectFirestoreEmulator: qT,
  deleteDoc: a5,
  doc: $c,
  getDocs: s0,
  getFirestore: AD,
  orderBy: ID,
  query: t5,
  setDoc: a0,
  where: n5,
  writeBatch: u5
}, Symbol.toStringTag, { value: "Module" }));
var nn = /* @__PURE__ */ ((n) => (n[n.minute = 0] = "minute", n[n.hour = 1] = "hour", n[n.day = 2] = "day", n))(nn || {});
const q2 = me.createContainer().register(be.instance(dT, RT({ ...$R, apiKey: globalThis.process.env.FIREBASE_API_KEY }))).register(be.instance(Vy, {})).register(Mo).register(ul).register(rl).register(be.instance($O, {})).register(be.instance(qy, {})).register(be.instance(zy, { lsGet: () => "", lsSet: () => "" })).register(al).register(Md).register(Po).register(Pd).register(
  be.instance(
    wf,
    new GO(
      { url: "https://celo-mainnet.infura.io/v3/724935fba337407c8f49b12c9a240b7a", skipFetchSetup: !0 },
      {
        name: u2.toLowerCase(),
        chainId: o2
      }
    )
  )
).register(
  be.instance(Cs, {
    chainId: o2,
    ipfsGateway: UR,
    chainUrl: jR,
    chain: u2,
    isDevelopment: !1,
    scanLink: VR,
    firebaseCollection: to
  })
).register(vf).register(ll).register(Aa).register(
  be.instance(cT, {
    tokens: qR
  })
).register(ol).register(be.instance(ja, { uf: (n) => Number(n) })).register(
  be.instance(Ia, {}),
  be.instance(Gd, {}),
  be.instance(Ra, {
    scopeTo: () => {
    },
    error: () => {
    }
  })
), kD = async () => {
  let n = !1;
  const e = 5, t = 1, r = 1, i = q2.get(wT);
  let s = "", a = 0, o = 0, u = 0, l = 0, d = 0, p = 0, m = 0, w = 0, x = 0, T = 0, A, M = 0, I = 0, B = 0, k = 0, N = 0;
  const W = await q2.get(Uy).connect(), G = Object.values(nn).filter((g) => typeof g == "number").map((g) => g), Y = async (g) => {
    const E = r0(W, `${to}/lastSync/${g}`);
    return (await s0(E)).docs[0]?.id;
  }, ue = async (g, E, S) => {
    S && await a5($c(W, `${to}/lastSync/${g}/${S}`)), await a0($c(W, `${to}/lastSync/${g}`, E.toString()), {});
  }, K = async (g, E, S, _) => {
    let P = _;
    typeof P != "object" && (P = { value: _ }), P.createdAt = S, await a0($c(W, `${to}/${g}/${E}`, S.toString()), P);
  }, le = async (g, E, S) => {
    const _ = u5(W);
    (await s0(t5(r0(W, `${to}/${g}/${E}`), n5("createdAt", "<", S)))).forEach((b) => _.delete(b.ref)), await _.commit();
  }, C = async () => {
    await i.loadAssets(), await i.loadkCur(), await i.loadkGuilder();
  }, c = (g) => {
    const E = /* @__PURE__ */ new Date();
    switch (g) {
      case 0:
        E.setMinutes(E.getMinutes() - 60, 0, 0);
        break;
      case 1:
        E.setHours(E.getHours() - 24, 0, 0, 0);
        break;
      case 2:
        return Number.MIN_VALUE;
    }
    return E.getTime();
  }, h = async () => {
    await C(), s = i.reserveValue?.toHexString() ?? "", a = i.currentLeverageRatio, o = i.maxLeverageRatio, u = i.kCurPrice ?? 0, d = i.kCurPriceFloor ?? 0, l = i.kCurPriceCeiling ?? 0, p = i.kCurReserveDistribution ?? 0, m = i.kCurMentoDistribution ?? 0, w = i.kCurPrimaryPoolDistribution ?? 0, x = i.kCurCirculatingDistribution, M = i.minCollateralizationValue, I = i.kCurTotalValue, B = i.lowRiskAssets.map((g) => g.total).sum(), k = i.moderateRiskAssets.map((g) => g.total).sum(), N = i.highRiskAssets.map((g) => g.total).sum(), T = i.kGuilderValueRatio ?? 0;
  };
  await Promise.all(
    G.map(async (g) => {
      const E = await Y(nn[g]), S = /* @__PURE__ */ new Date();
      let _ = /* @__PURE__ */ new Date();
      if (E && (_ = new Date(Number(E))), g === 0 ? (_.setUTCMinutes(_.getUTCMinutes() + e), _.setUTCSeconds(0, 0)) : g === 1 ? (_.setUTCHours(_.getUTCHours() + t), _.setUTCMinutes(0, 0, 0)) : (_.setUTCDate(_.getUTCDate() + r), _.setUTCHours(0, 0, 0, 0)), S >= _ || !E) {
        let P = /* @__PURE__ */ new Date();
        if (g === 0) {
          const b = 6e4 * e;
          P = new Date(Math.floor(S.getTime() / b) * b);
        } else
          g === 1 ? P.setUTCMinutes(0, 0, 0) : P.setUTCHours(0, 0, 0, 0);
        n || (n = !0, A = h()), A?.then(async () => {
          await K("kCurPrice", nn[g], P.getTime(), { kCurPrice: u, kCurPriceCeiling: l, kCurPriceFloor: d }), await K("kCurRatio", nn[g], P.getTime(), { currentLeverageRatio: a, maxLeverageRatio: o }), await K("kCurSupply", nn[g], P.getTime(), {
            kCurReserveDistribution: p,
            kCurMentoDistribution: m,
            kCurPrimaryPoolDistribution: w,
            kCurCirculatingDistribution: x
          }), await K("reserve", nn[g], P.getTime(), s), await K("risk", nn[g], P.getTime(), {
            minCollateralValue: M,
            marketCap: I,
            lowRisk: B,
            moderateRisk: k,
            highRisk: N
          }), await K("kGuilder", nn[g], P.getTime(), T), await ue(nn[g], P.getTime(), E);
          const b = c(g);
          await le("kCurPrice", nn[g], b), await le("kCurRatio", nn[g], b), await le("kCurSupply", nn[g], b), await le("ktt", nn[g], b), await le("reserve", nn[g], b), await le("risk", nn[g], b), await le("kGuilder", nn[g], b);
        });
      }
    })
  );
};
await kD();
