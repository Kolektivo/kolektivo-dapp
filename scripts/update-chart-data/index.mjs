const pw = 'celo',
  fw = 42220,
  hw = {
    monetaryBadger: {
      abi: 'Badger',
      address: '0x391002f0b25Fb2AdAFeDcD1EA1C97834FCD59CDD',
    },
    kolektivoBadger: {
      abi: 'Badger',
      address: '0x203EFD61908cA90bF0A5984f6754DB0e58162B88',
    },
    bacMD: {
      abi: 'BACRoles',
      address: '0x34886b875E588c412574426a9675e33b64d5Dd59',
    },
    bacFFD: {
      abi: 'BACRoles',
      address: '0x9D5C5a439E6edDb34562087D83f0A58DCC5672d7',
    },
    bacMC: {
      abi: 'BACRoles',
      address: '0xF3Fd37f7F54BFeF2cdA043B57e132006b6a44E47',
    },
    bacK: {
      abi: 'BACRoles',
      address: '0x659248bc8f8Ee7937a0e9f018dc5e8fFEe3A68Fd',
    },
    reserveDelegateScope: {
      abi: 'ScopeGuard',
      address: '0x2a016330C0e5169FA5C44A4f5C73E76B2543CFBa',
    },
    foodForestDelegateScope: {
      abi: 'ScopeGuard',
      address: '0xF22d9617d2B4d8DacDD708aF6615c5Af72b6a861',
    },
    monetaryMultisigScope: {
      abi: 'ScopeGuard',
      address: '0x06E26e99470462B0a75760B50685cf4bE084005B',
    },
    monetaryDelay: {
      abi: 'SecretDelay',
      address: '0x5bfD3A6c4a579A1F20d2652633cCAce90d9db62F',
    },
    foodForestDelay: {
      abi: 'SecretDelay',
      address: '0x28DD09637872D94b9Bac33041B3A9482E1904A4B',
    },
    kolektivoDelay: {
      abi: 'SecretDelay',
      address: '0xb846c1B4A959be7a666f3882Fd3F70019ccFA408',
    },
  },
  NO = {
    name: pw,
    chainId: fw,
    contracts: hw,
  },
  DO = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        chainId: fw,
        contracts: hw,
        default: NO,
        name: pw,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  yw = 'celo',
  mw = '42220',
  bw = {
    GeoNFT: {
      address: '0x9fC5461A1e6CF567C7E19Befa7c0351C9C6CB719',
      abi: [
        {
          inputs: [
            {
              internalType: 'string',
              name: '_name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: '_symbol',
              type: 'string',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidIdentifier',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidLatitude',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidLongitude',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidTokenId',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'approved',
              type: 'bool',
            },
          ],
          name: 'ApprovalForAll',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'TokenModified',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'getApproved',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isApprovedForAll',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'int32',
              name: 'latitude',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: 'longitude',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'mint',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'int32',
              name: 'latitude',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: 'longitude',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'modify',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ownerOf',
          outputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'safeTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'safeTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              internalType: 'bool',
              name: 'approved',
              type: 'bool',
            },
          ],
          name: 'setApprovalForAll',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'interfaceId',
              type: 'bytes4',
            },
          ],
          name: 'supportsInterface',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'tokenData',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'int32',
              name: '',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: '',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'tokenURI',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Oracle: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'reportExpirationTime_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'reportDelay_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minimumProviders_',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'invalidProvider',
              type: 'address',
            },
          ],
          name: 'Oracle__InvalidProvider',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Oracle__NewReportTooSoonAfterPastReport',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldMinimumProviders',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newMinimumProviders',
              type: 'uint256',
            },
          ],
          name: 'MinimumProvidersChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [],
          name: 'OracleMarkedAsInvalid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [],
          name: 'OracleMarkedAsValid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
          ],
          name: 'ProviderReportPushed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'purger',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderReportsPurged',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'addProvider',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getData',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'isValid',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minimumProviders',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'providerReports',
          outputs: [
            {
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'providers',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'providersSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'purgeReports',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'purgeReportsFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
          ],
          name: 'pushReport',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'removeProvider',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportDelay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportExpirationTime',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isValid_',
              type: 'bool',
            },
          ],
          name: 'setIsValid',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'minimumProviders_',
              type: 'uint256',
            },
          ],
          name: 'setMinimumProviders',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Reserve: {
      address: '0x9F2D87bEb5ead48FBf9c39Ada853C79DB6D0781f',
      abi: [
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'tokenOracle_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'vestingVault_',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'minBacking_',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20BalanceNotSufficient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20BondingLimitExceeded',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotBondable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotRedeemable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotRegistered',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20RedeemLimitExceeded',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotBondable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotRedeemable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotRegistered',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidOracle',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__MinimumBackingLimitExceeded',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldBacking',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newBacking',
              type: 'uint256',
            },
          ],
          name: 'BackingUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sBonded',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensMinted',
              type: 'uint256',
            },
          ],
          name: 'BondedERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensMinted',
              type: 'uint256',
            },
          ],
          name: 'BondedERC721',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'DebtIncurred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'DebtPaid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20Deregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum IReserve.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              indexed: !1,
              internalType: 'enum IReserve.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'ERC20Registered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sRedeemed',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensBurned',
              type: 'uint256',
            },
          ],
          name: 'RedeemedERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensBurned',
              type: 'uint256',
            },
          ],
          name: 'RedeemedERC721Id',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldDiscount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newDiscount',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingDiscount',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldtimeLockDuration',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newtimeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingTimeLock',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetERC20Oracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20RedeemLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldDiscount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newDiscount',
              type: 'uint256',
            },
          ],
          name: 'SetERC721IdBondingDiscount',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldtimeLockDuration',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newtimeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'SetERC721IdBondingTimeLock',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetERC721IdOracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldMinBacking',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newMinBacking',
              type: 'uint256',
            },
          ],
          name: 'SetMinBacking',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldTimeLockVault',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newTimeLockVault',
              type: 'address',
            },
          ],
          name: 'SetTimeLockVault',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetTokenOracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sWithdrawn',
              type: 'uint256',
            },
          ],
          name: 'WithdrewERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'WithdrewERC721Id',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC20s',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC721Ids',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'erc721',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'id',
                  type: 'uint256',
                },
              ],
              internalType: 'struct IReserve.ERC721Id[]',
              name: '',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'assetTypeOfERC20',
          outputs: [
            {
              internalType: 'enum IReserve.AssetType',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'bondERC20All',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'bondERC20AllFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC20AllFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC20AllTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20From',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20FromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20To',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'bondERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'bondERC721IdFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC721IdFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC721IdTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingDiscountPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'bondingDiscountPerERC721Id',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingTimeLockDurationPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'bondingTimeLockDurationPerERC721Id',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'deregisterERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'deregisterERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'executeTx',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'incurDebt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Bondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Redeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdBondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdRedeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minBacking',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: '',
              type: 'bytes',
            },
          ],
          name: 'onERC721Received',
          outputs: [
            {
              internalType: 'bytes4',
              name: '',
              type: 'bytes4',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'oraclePerERC20',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oraclePerERC721Id',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'payDebt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'redeemERC20All',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20From',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20FromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20To',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'redeemERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'redeemLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              internalType: 'enum IReserve.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              internalType: 'enum IReserve.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'registerERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'registerERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC20s',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC721Ids',
          outputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserveStatus',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'riskLevelOfERC20',
          outputs: [
            {
              internalType: 'enum IReserve.RiskLevel',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
          ],
          name: 'setBondingDiscountForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
          ],
          name: 'setBondingDiscountForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setBondingTimeLockForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setBondingTimeLockForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20BondingLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20RedeemLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'minBacking_',
              type: 'uint256',
            },
          ],
          name: 'setMinBacking',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'timeLockVault_',
              type: 'address',
            },
          ],
          name: 'setTimeLockVault',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'tokenOracle_',
              type: 'address',
            },
          ],
          name: 'setTokenOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Bond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Redemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC721IdBond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC721IdRedemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'timeLockVault',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'token',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tokenOracle',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateOracleForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateOracleForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'withdrawERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'withdrawERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    CuracaoReserveToken: {
      address: '0xeB22fD1Dc0F480faA0D5cce673364b31E5f1e772',
      abi: 'ERC20',
    },
    Treasury: {
      address: '0x74b06277Cd1efaA9f6595D25AdB54b4530d15BF5',
      abi: [
        {
          inputs: [],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'MaxSupplyReached',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20BondingLimitExceeded',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotBondable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotRedeemable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotRegistered',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20RedeemLimitExceeded',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotBondable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotRedeemable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotRegistered',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'Treasury__StaleERC20PriceDeliveredByOracle',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'Treasury__StaleERC721IdPriceDeliveredByOracle',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20Deregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'ERC20OracleUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldPrice',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newPrice',
              type: 'uint256',
            },
          ],
          name: 'ERC20PriceUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum Treasury.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              indexed: !1,
              internalType: 'enum Treasury.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'ERC20Registered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sWithdrawn',
              type: 'uint256',
            },
          ],
          name: 'ERC20Withdrawn',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsMinted',
              type: 'uint256',
            },
          ],
          name: 'ERC20sBonded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsBurned',
              type: 'uint256',
            },
          ],
          name: 'ERC20sRedeemed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'ERC721IdOracleUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldPrice',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newPrice',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdPriceUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'ERC721IdRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'ERC721IdWithdrawn',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsMinted',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdsBonded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsBurned',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdsRedeemed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'epoch',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newScalar',
              type: 'uint256',
            },
          ],
          name: 'Rebase',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20RedeemLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'EIP712_DOMAIN',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'EIP712_REVISION',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'PERMIT_TYPEHASH',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC20s',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC721Ids',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'erc721',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'id',
                  type: 'uint256',
                },
              ],
              internalType: 'struct Treasury.ERC721Id[]',
              name: '',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'assetTypeOfERC20',
          outputs: [
            {
              internalType: 'enum Treasury.AssetType',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'bondERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'deregisterERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'deregisterERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'executeTx',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Bondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Redeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdBondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdRedeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'lastRebase',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: '',
              type: 'bytes',
            },
          ],
          name: 'onERC721Received',
          outputs: [
            {
              internalType: 'bytes4',
              name: '',
              type: 'bytes4',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'oraclePerERC20',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oraclePerERC721Id',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'rebase',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'kttWad',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'redeemERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'redeemLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              internalType: 'enum Treasury.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              internalType: 'enum Treasury.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'registerERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'registerERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC20s',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC721Ids',
          outputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'riskLevelOfERC20',
          outputs: [
            {
              internalType: 'enum Treasury.RiskLevel',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'scaledBalanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'scaledTotalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20BondingLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20RedeemLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Bond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Redemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalValuation',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'transferAll',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'transferAllFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateERC20Oracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateERC721IdOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'withdrawERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'withdrawERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'Kolektivo Treasury Token': {
      address: '0x74b06277Cd1efaA9f6595D25AdB54b4530d15BF5',
      abi: 'ERC20',
    },
    KolektivoMultiSig: {
      address: '0x33a0F694DFEDEFa3e98205E9712f4d8FA422E70a',
    },
    Vault: {
      address: '0xD25E02047E76b688445ab154785F2642c6fe3f73',
      abi: [
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'liquidityProvider',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              indexed: !1,
              internalType: 'int256[]',
              name: 'deltas',
              type: 'int256[]',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'protocolFeeAmounts',
              type: 'uint256[]',
            },
          ],
          name: 'PoolBalanceChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'assetManager',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'int256',
              name: 'cashDelta',
              type: 'int256',
            },
            {
              indexed: !1,
              internalType: 'int256',
              name: 'managedDelta',
              type: 'int256',
            },
          ],
          name: 'PoolBalanceManaged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'poolAddress',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum IVault.PoolSpecialization',
              name: 'specialization',
              type: 'uint8',
            },
          ],
          name: 'PoolRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'tokenIn',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'tokenOut',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amountIn',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amountOut',
              type: 'uint256',
            },
          ],
          name: 'Swap',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
          ],
          name: 'TokensDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              indexed: !1,
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
          ],
          name: 'TokensRegistered',
          type: 'event',
        },
        {
          inputs: [],
          name: 'WETH',
          outputs: [
            {
              internalType: 'contract IWETH',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.SwapKind',
              name: 'kind',
              type: 'uint8',
            },
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'int256[]',
              name: 'limits',
              type: 'int256[]',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'batchSwap',
          outputs: [
            {
              internalType: 'int256[]',
              name: '',
              type: 'int256[]',
            },
          ],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
          ],
          name: 'deregisterTokens',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address payable',
              name: 'recipient',
              type: 'address',
            },
            {
              components: [
                {
                  internalType: 'contract IAsset[]',
                  name: 'assets',
                  type: 'address[]',
                },
                {
                  internalType: 'uint256[]',
                  name: 'minAmountsOut',
                  type: 'uint256[]',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.ExitPoolRequest',
              name: 'request',
              type: 'tuple',
            },
          ],
          name: 'exitPool',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
          ],
          name: 'getPool',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'enum IVault.PoolSpecialization',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getPoolTokenInfo',
          outputs: [
            {
              internalType: 'uint256',
              name: 'cash',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'managed',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'assetManager',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
          ],
          name: 'getPoolTokens',
          outputs: [
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              components: [
                {
                  internalType: 'contract IAsset[]',
                  name: 'assets',
                  type: 'address[]',
                },
                {
                  internalType: 'uint256[]',
                  name: 'maxAmountsIn',
                  type: 'uint256[]',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.JoinPoolRequest',
              name: 'request',
              type: 'tuple',
            },
          ],
          name: 'joinPool',
          outputs: [],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.PoolBalanceOpKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'token',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
              ],
              internalType: 'struct IVault.PoolBalanceOp[]',
              name: 'ops',
              type: 'tuple[]',
            },
          ],
          name: 'managePoolBalance',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.SwapKind',
              name: 'kind',
              type: 'uint8',
            },
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
          ],
          name: 'queryBatchSwap',
          outputs: [
            {
              internalType: 'int256[]',
              name: 'assetDeltas',
              type: 'int256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.PoolSpecialization',
              name: 'specialization',
              type: 'uint8',
            },
          ],
          name: 'registerPool',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
          ],
          name: 'registerTokens',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IAsset',
                  name: 'assetIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IAsset',
                  name: 'assetOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.SingleSwap',
              name: 'singleSwap',
              type: 'tuple',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'swap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'payable',
          type: 'function',
        },
      ],
    },
    'Test Token #1': {
      address: '0x4cB13ED364bd2c212B694921CdAca979DCA76054',
      abi: 'ERC20',
    },
    cUSD: {
      address: '0x765DE816845861e75A25fCA122bb6898B8B1282a',
      abi: 'ERC20',
    },
    'Test Token #2': {
      address: '0x5bFE78b0d15eF0cdcA4077336e0bEbEc15CFb142',
      abi: 'ERC20',
    },
    'Test Token #3': {
      address: '0xd312bCeA257799a39e0C85d7EC45031612e4dd50',
      abi: 'ERC20',
    },
    'GeoNFT #1': {
      address: '0x9fC5461A1e6CF567C7E19Befa7c0351C9C6CB719',
      id: 1,
      abi: 'ERC721',
    },
    'GeoNFT #2': {
      address: '0x9fC5461A1e6CF567C7E19Befa7c0351C9C6CB719',
      id: 2,
      abi: 'ERC721',
    },
    'kGuilder Pool': {
      address: '0x637A8Dc2343ef517451bE63f1D5164AD7fF53FC9',
      abi: [
        {
          inputs: [
            {
              internalType: 'contract IVault',
              name: 'vault',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: 'symbol',
              type: 'string',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'amplificationParameter',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowDuration',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodDuration',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'startValue',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'endValue',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'startTime',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'endTime',
              type: 'uint256',
            },
          ],
          name: 'AmpUpdateStarted',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'currentValue',
              type: 'uint256',
            },
          ],
          name: 'AmpUpdateStopped',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'PausedStateChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'SwapFeePercentageChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'selector',
              type: 'bytes4',
            },
          ],
          name: 'getActionId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAmplificationParameter',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'isUpdating',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'precision',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAuthorizer',
          outputs: [
            {
              internalType: 'contract IAuthorizer',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getLastInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: 'lastInvariant',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'lastInvariantAmp',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPausedState',
          outputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowEndTime',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodEndTime',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPoolId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getScalingFactors',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getSwapFeePercentage',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVault',
          outputs: [
            {
              internalType: 'contract IVault',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'addedValue',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onExitPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onJoinPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'swapRequest',
              type: 'tuple',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'indexIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'indexOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'request',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryExit',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsOut',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryJoin',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptOut',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsIn',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'poolConfig',
              type: 'bytes',
            },
          ],
          name: 'setAssetManagerPoolConfig',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'setPaused',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'setSwapFeePercentage',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'rawEndValue',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'endTime',
              type: 'uint256',
            },
          ],
          name: 'startAmplificationParameterUpdate',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stopAmplificationParameterUpdate',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'kCur Pool': {
      address: '0xfe4a8b11fd4735e96454b056cf6422aacad1c880',
      abi: [
        {
          inputs: [
            {
              internalType: 'contract IVault',
              name: 'vault',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: 'symbol',
              type: 'string',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'normalizedWeights',
              type: 'uint256[]',
            },
            {
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowDuration',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodDuration',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'PausedStateChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'SwapFeePercentageChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'selector',
              type: 'bytes4',
            },
          ],
          name: 'getActionId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAuthorizer',
          outputs: [
            {
              internalType: 'contract IAuthorizer',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getLastInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getNormalizedWeights',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPausedState',
          outputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowEndTime',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodEndTime',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPoolId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getScalingFactors',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getSwapFeePercentage',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVault',
          outputs: [
            {
              internalType: 'contract IVault',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'addedValue',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onExitPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onJoinPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'request',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryExit',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsOut',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryJoin',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptOut',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsIn',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'poolConfig',
              type: 'bytes',
            },
          ],
          name: 'setAssetManagerPoolConfig',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'setPaused',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'setSwapFeePercentage',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    TimeLockVault: {
      address: '0xFcAb95D9577bBA5c3203852DE98dD2730ce17452',
      abi: [
        {
          inputs: [],
          name: 'InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidDuration',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'SenderCantLock',
          type: 'error',
        },
        {
          inputs: [],
          name: 'UserHasNoLocks',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'Claimed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'unlockAt',
              type: 'uint256',
            },
          ],
          name: 'Locked',
          type: 'event',
        },
        {
          inputs: [],
          name: 'claim',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'claimAt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'claimToken',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
          ],
          name: 'getLocksOf',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'token',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'unlockAt',
                  type: 'uint256',
                },
              ],
              internalType: 'struct TimeLockVault.Lock[]',
              name: 'locks',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'locker',
              type: 'address',
            },
          ],
          name: 'isLocker',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'duration',
              type: 'uint256',
            },
          ],
          name: 'lock',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    SortedOracles: {
      address: '0xe2eeb028008f42Ca8d86e5CF2638F06F4651131C',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'newBreakerBox',
              type: 'address',
            },
          ],
          name: 'BreakerBoxUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'MedianUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
          ],
          name: 'OracleAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
          ],
          name: 'OracleRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'OracleReportRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'OracleReported',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'reportExpiry',
              type: 'uint256',
            },
          ],
          name: 'ReportExpirySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'reportExpiry',
              type: 'uint256',
            },
          ],
          name: 'TokenReportExpirySet',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
          ],
          name: 'addOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'breakerBox',
          outputs: [
            {
              internalType: 'contract IBreakerBox',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getOracles',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getRates',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'enum SortedLinkedListWithMedian.MedianRelation[]',
              name: '',
              type: 'uint8[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getTimestamps',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'enum SortedLinkedListWithMedian.MedianRelation[]',
              name: '',
              type: 'uint8[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getTokenReportExpirySeconds',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '_reportExpirySeconds',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'isOldestReportExpired',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isOracle',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'medianRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'medianTimestamp',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'numRates',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'numTimestamps',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oracles',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'n',
              type: 'uint256',
            },
          ],
          name: 'removeExpiredReports',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'lesserKey',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'greaterKey',
              type: 'address',
            },
          ],
          name: 'report',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportExpirySeconds',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IBreakerBox',
              name: 'newBreakerBox',
              type: 'address',
            },
          ],
          name: 'setBreakerBox',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '_reportExpirySeconds',
              type: 'uint256',
            },
          ],
          name: 'setReportExpiry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '_reportExpirySeconds',
              type: 'uint256',
            },
          ],
          name: 'setTokenReportExpiry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'tokenReportExpirySeconds',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    KolektivoGuilder: {
      address: '0x76658A30cEc19FA312781dB3e9AB7AeAF17ecA87',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bytes32',
              name: 'oldId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'bytes32',
              name: 'newId',
              type: 'bytes32',
            },
          ],
          name: 'ExchangeIdentifierUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'factor',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'lastUpdated',
              type: 'uint256',
            },
          ],
          name: 'InflationFactorUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'rate',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'updatePeriod',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'lastUpdated',
              type: 'uint256',
            },
          ],
          name: 'InflationParametersUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'string',
              name: 'comment',
              type: 'string',
            },
          ],
          name: 'TransferComment',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'accountOwner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'accountOwner',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'blsKey',
              type: 'bytes',
            },
            {
              internalType: 'bytes',
              name: 'blsPop',
              type: 'bytes',
            },
          ],
          name: 'checkProofOfPossession',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'feeRecipient',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'gatewayFeeRecipient',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'communityFund',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'refund',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'tipTxFee',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'gatewayFee',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'baseTxFee',
              type: 'uint256',
            },
          ],
          name: 'creditGasFees',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'debitGasFees',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'aNumerator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'aDenominator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bNumerator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bDenominator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'exponent',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_decimals',
              type: 'uint256',
            },
          ],
          name: 'fractionMulExp',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'getBlockNumberFromHeader',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getEpochNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'getEpochNumberOfBlock',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getEpochSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getExchangeRegistryId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getInflationParameters',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'getParentSealBitmap',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'getVerifiedSealBitmapFromHeader',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'hashHeader',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: '_name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: '_symbol',
              type: 'string',
            },
            {
              internalType: 'uint8',
              name: '_decimals',
              type: 'uint8',
            },
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'inflationRate',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'inflationFactorUpdatePeriod',
              type: 'uint256',
            },
            {
              internalType: 'string',
              name: 'exchangeIdentifier',
              type: 'string',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'minQuorumSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minQuorumSizeInCurrentSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'mint',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'numberValidatorsInCurrentSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'numberValidatorsInSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'exchangeIdentifier',
              type: 'string',
            },
          ],
          name: 'setExchangeRegistryId',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'rate',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'updatePeriod',
              type: 'uint256',
            },
          ],
          name: 'setInflationParameters',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'string',
              name: 'comment',
              type: 'string',
            },
          ],
          name: 'transferWithComment',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'units',
              type: 'uint256',
            },
          ],
          name: 'unitsToValue',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'validatorSignerAddressFromCurrentSet',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'validatorSignerAddressFromSet',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'valueToUnits',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    MentoExchange: {
      address: '0x9f66Fc3C9608f5690fE878c9f6E73AEA389ac338',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'goldBucket',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'stableBucket',
              type: 'uint256',
            },
          ],
          name: 'BucketsUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchanger',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'soldGold',
              type: 'bool',
            },
          ],
          name: 'Exchanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'minimumReports',
              type: 'uint256',
            },
          ],
          name: 'MinimumReportsSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'reserveFraction',
              type: 'uint256',
            },
          ],
          name: 'ReserveFractionSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'spread',
              type: 'uint256',
            },
          ],
          name: 'SpreadSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'stable',
              type: 'address',
            },
          ],
          name: 'StableTokenSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'updateFrequency',
              type: 'uint256',
            },
          ],
          name: 'UpdateFrequencySet',
          type: 'event',
        },
        {
          inputs: [],
          name: 'activateStable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'maxSellAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'buyGold',
              type: 'bool',
            },
          ],
          name: 'buy',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minBuyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'exchange',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getBuyAndSellBuckets',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getBuyTokenAmount',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getSellTokenAmount',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [],
          name: 'goldBucket',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'stableTokenIdentifier',
              type: 'string',
            },
            {
              internalType: 'uint256',
              name: '_spread',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_reserveFraction',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_updateFrequency',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_minimumReports',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'lastBucketUpdate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minimumReports',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserveFraction',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minBuyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'sell',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newMininumReports',
              type: 'uint256',
            },
          ],
          name: 'setMinimumReports',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newReserveFraction',
              type: 'uint256',
            },
          ],
          name: 'setReserveFraction',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newSpread',
              type: 'uint256',
            },
          ],
          name: 'setSpread',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newStableToken',
              type: 'address',
            },
          ],
          name: 'setStableToken',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newUpdateFrequency',
              type: 'uint256',
            },
          ],
          name: 'setUpdateFrequency',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'spread',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stable',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stableBucket',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stableTokenRegistryId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'updateFrequency',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    MentoReserve: {
      address: '0x41032125C55E5C362c7E1c85b3183E7d4eB99e07',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bytes32[]',
              name: 'symbols',
              type: 'bytes32[]',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'weights',
              type: 'uint256[]',
            },
          ],
          name: 'AssetAllocationSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'ratio',
              type: 'uint256',
            },
          ],
          name: 'DailySpendingRatioSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchangeSpender',
              type: 'address',
            },
          ],
          name: 'ExchangeSpenderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchangeSpender',
              type: 'address',
            },
          ],
          name: 'ExchangeSpenderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'otherReserveAddress',
              type: 'address',
            },
          ],
          name: 'OtherReserveAddressAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'otherReserveAddress',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'OtherReserveAddressRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'ReserveGoldTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'SpenderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'SpenderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxReserveRatioSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxStalenessThresholdSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'TokenAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'TokenRemoved',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'addExchangeSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'reserveAddress',
              type: 'address',
            },
          ],
          name: 'addOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'addSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'addToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'assetAllocationSymbols',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          name: 'assetAllocationWeights',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'exchangeSpenderAddresses',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'frozenReserveGoldDays',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'frozenReserveGoldStartBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'frozenReserveGoldStartDay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAssetAllocationSymbols',
          outputs: [
            {
              internalType: 'bytes32[]',
              name: '',
              type: 'bytes32[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAssetAllocationWeights',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getDailySpendingRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getExchangeSpenders',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getFrozenReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOrComputeTobinTax',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOtherReserveAddresses',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOtherReserveAddressesGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getReserveRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getTokens',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getUnfrozenBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getUnfrozenReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '_tobinTaxStalenessThreshold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_spendingRatio',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_frozenGold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_frozenDays',
              type: 'uint256',
            },
            {
              internalType: 'bytes32[]',
              name: '_assetAllocationSymbols',
              type: 'bytes32[]',
            },
            {
              internalType: 'uint256[]',
              name: '_assetAllocationWeights',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: '_tobinTax',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_tobinTaxReserveRatio',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isExchangeSpender',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isSpender',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'lastSpendingDay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'otherReserveAddresses',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeExchangeSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'reserveAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'removeSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32[]',
              name: 'symbols',
              type: 'bytes32[]',
            },
            {
              internalType: 'uint256[]',
              name: 'weights',
              type: 'uint256[]',
            },
          ],
          name: 'setAssetAllocations',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'ratio',
              type: 'uint256',
            },
          ],
          name: 'setDailySpendingRatio',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'frozenGold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'frozenDays',
              type: 'uint256',
            },
          ],
          name: 'setFrozenGold',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTax',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTaxReserveRatio',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTaxStalenessThreshold',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'spendingLimit',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTax',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTaxCache',
          outputs: [
            {
              internalType: 'uint128',
              name: 'numerator',
              type: 'uint128',
            },
            {
              internalType: 'uint128',
              name: 'timestamp',
              type: 'uint128',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTaxReserveRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTaxStalenessThreshold',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address payable',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferExchangeGold',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address payable',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferGold',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    MentoRegistry: {
      address: '0xE72ef442Edb4EF609A2d8F3731b16D29A5365b9c',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'identifierHash',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'addr',
              type: 'address',
            },
          ],
          name: 'RegistryUpdated',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'identifierHash',
              type: 'bytes32',
            },
          ],
          name: 'getAddressFor',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'identifierHash',
              type: 'bytes32',
            },
          ],
          name: 'getAddressForOrDie',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'getAddressForString',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'getAddressForStringOrDie',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32[]',
              name: 'identifierHashes',
              type: 'bytes32[]',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
          ],
          name: 'isOneOf',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          name: 'registry',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
            {
              internalType: 'address',
              name: 'addr',
              type: 'address',
            },
          ],
          name: 'setAddressFor',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Freezer: {
      address: '0xBCE9d359b89Ab36744aF01785B016fB62aE24819',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
          ],
          name: 'freeze',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isFrozen',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
          ],
          name: 'unfreeze',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
  },
  FO = {
    name: yw,
    chainId: mw,
    contracts: bw,
  },
  LO = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        chainId: mw,
        contracts: bw,
        default: FO,
        name: yw,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  gw = 'celo',
  vw = 42220,
  xw = {},
  $O = {
    name: gw,
    chainId: vw,
    contracts: xw,
  },
  UO = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        chainId: vw,
        contracts: xw,
        default: $O,
        name: gw,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  ww = 'celo',
  Tw = '42220',
  Aw = {},
  jO = {
    name: ww,
    chainId: Tw,
    contracts: Aw,
  },
  VO = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        chainId: Tw,
        contracts: Aw,
        default: jO,
        name: ww,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Ew = 'celo',
  Cw = '42220',
  Sw = {
    GeoNFT: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'string',
              name: '_name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: '_symbol',
              type: 'string',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidIdentifier',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidLatitude',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidLongitude',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidTokenId',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'approved',
              type: 'bool',
            },
          ],
          name: 'ApprovalForAll',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'TokenModified',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'getApproved',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isApprovedForAll',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'int32',
              name: 'latitude',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: 'longitude',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'mint',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'int32',
              name: 'latitude',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: 'longitude',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'modify',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ownerOf',
          outputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'safeTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'safeTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              internalType: 'bool',
              name: 'approved',
              type: 'bool',
            },
          ],
          name: 'setApprovalForAll',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'interfaceId',
              type: 'bytes4',
            },
          ],
          name: 'supportsInterface',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'tokenData',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'int32',
              name: '',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: '',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'tokenURI',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    KolektivoMultiSig: {
      address: '0xcE960DcafC201a1B4440ed5F6B63A7772a34b2Ab',
    },
    Oracle: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'reportExpirationTime_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'reportDelay_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minimumProviders_',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'invalidProvider',
              type: 'address',
            },
          ],
          name: 'Oracle__InvalidProvider',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Oracle__NewReportTooSoonAfterPastReport',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldMinimumProviders',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newMinimumProviders',
              type: 'uint256',
            },
          ],
          name: 'MinimumProvidersChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [],
          name: 'OracleMarkedAsInvalid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [],
          name: 'OracleMarkedAsValid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
          ],
          name: 'ProviderReportPushed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'purger',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderReportsPurged',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'addProvider',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getData',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'isValid',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minimumProviders',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'providerReports',
          outputs: [
            {
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'providers',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'providersSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'purgeReports',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'purgeReportsFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
          ],
          name: 'pushReport',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'removeProvider',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportDelay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportExpirationTime',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isValid_',
              type: 'bool',
            },
          ],
          name: 'setIsValid',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'minimumProviders_',
              type: 'uint256',
            },
          ],
          name: 'setMinimumProviders',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Reserve: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'tokenOracle_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'vestingVault_',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'minBacking_',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20BalanceNotSufficient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20BondingLimitExceeded',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotBondable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotRedeemable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotRegistered',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20RedeemLimitExceeded',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotBondable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotRedeemable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotRegistered',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidOracle',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__MinimumBackingLimitExceeded',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldBacking',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newBacking',
              type: 'uint256',
            },
          ],
          name: 'BackingUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sBonded',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensMinted',
              type: 'uint256',
            },
          ],
          name: 'BondedERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensMinted',
              type: 'uint256',
            },
          ],
          name: 'BondedERC721',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'DebtIncurred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'DebtPaid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20Deregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum IReserve.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              indexed: !1,
              internalType: 'enum IReserve.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'ERC20Registered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sRedeemed',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensBurned',
              type: 'uint256',
            },
          ],
          name: 'RedeemedERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensBurned',
              type: 'uint256',
            },
          ],
          name: 'RedeemedERC721Id',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldDiscount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newDiscount',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingDiscount',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldVestingDuration',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newVestingDuration',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingVesting',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetERC20Oracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20RedeemLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldDiscount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newDiscount',
              type: 'uint256',
            },
          ],
          name: 'SetERC721IdBondingDiscount',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldVestingDuration',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newVestingDuration',
              type: 'uint256',
            },
          ],
          name: 'SetERC721IdBondingVesting',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetERC721IdOracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldMinBacking',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newMinBacking',
              type: 'uint256',
            },
          ],
          name: 'SetMinBacking',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetTokenOracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldVestingVault',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newVestingVault',
              type: 'address',
            },
          ],
          name: 'SetVestingVault',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sWithdrawn',
              type: 'uint256',
            },
          ],
          name: 'WithdrewERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'WithdrewERC721Id',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC20s',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC721Ids',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'erc721',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'id',
                  type: 'uint256',
                },
              ],
              internalType: 'struct IReserve.ERC721Id[]',
              name: '',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'assetTypeOfERC20',
          outputs: [
            {
              internalType: 'enum IReserve.AssetType',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'bondERC20All',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'bondERC20AllFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC20AllFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC20AllTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20From',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20FromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20To',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'bondERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'bondERC721IdFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC721IdFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC721IdTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingDiscountPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'bondingDiscountPerERC721Id',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingVestingDurationPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'bondingVestingDurationPerERC721Id',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'deregisterERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'deregisterERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'executeTx',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'incurDebt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Bondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Redeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdBondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdRedeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minBacking',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: '',
              type: 'bytes',
            },
          ],
          name: 'onERC721Received',
          outputs: [
            {
              internalType: 'bytes4',
              name: '',
              type: 'bytes4',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'oraclePerERC20',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oraclePerERC721Id',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'payDebt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'redeemERC20All',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20From',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20FromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20To',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'redeemERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'redeemLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              internalType: 'enum IReserve.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              internalType: 'enum IReserve.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'registerERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'registerERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC20s',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC721Ids',
          outputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserveStatus',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'riskLevelOfERC20',
          outputs: [
            {
              internalType: 'enum IReserve.RiskLevel',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
          ],
          name: 'setBondingDiscountForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
          ],
          name: 'setBondingDiscountForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'vestingDuration',
              type: 'uint256',
            },
          ],
          name: 'setBondingVestingForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'vestingDuration',
              type: 'uint256',
            },
          ],
          name: 'setBondingVestingForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20BondingLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20RedeemLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'minBacking_',
              type: 'uint256',
            },
          ],
          name: 'setMinBacking',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'tokenOracle_',
              type: 'address',
            },
          ],
          name: 'setTokenOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'vestingVault_',
              type: 'address',
            },
          ],
          name: 'setVestingVault',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'vestingDuration',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Bond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Redemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'vestingDuration',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC721IdBond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC721IdRedemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'token',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tokenOracle',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateOracleForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateOracleForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'vestingVault',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'withdrawERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'withdrawERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'Kolektivo Curacao Reserve Token': {
      address: '0x0000000000000000000000000000000000000000',
      abi: 'ERC20',
    },
    Treasury: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'MaxSupplyReached',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20BondingLimitExceeded',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotBondable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotRedeemable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotRegistered',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20RedeemLimitExceeded',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotBondable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotRedeemable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotRegistered',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'Treasury__StaleERC20PriceDeliveredByOracle',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'Treasury__StaleERC721IdPriceDeliveredByOracle',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20Deregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'ERC20OracleUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldPrice',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newPrice',
              type: 'uint256',
            },
          ],
          name: 'ERC20PriceUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum Treasury.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              indexed: !1,
              internalType: 'enum Treasury.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'ERC20Registered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sWithdrawn',
              type: 'uint256',
            },
          ],
          name: 'ERC20Withdrawn',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsMinted',
              type: 'uint256',
            },
          ],
          name: 'ERC20sBonded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsBurned',
              type: 'uint256',
            },
          ],
          name: 'ERC20sRedeemed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'ERC721IdOracleUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldPrice',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newPrice',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdPriceUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'ERC721IdRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'ERC721IdWithdrawn',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsMinted',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdsBonded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsBurned',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdsRedeemed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'epoch',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newScalar',
              type: 'uint256',
            },
          ],
          name: 'Rebase',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20RedeemLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'EIP712_DOMAIN',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'EIP712_REVISION',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'PERMIT_TYPEHASH',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC20s',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC721Ids',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'erc721',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'id',
                  type: 'uint256',
                },
              ],
              internalType: 'struct Treasury.ERC721Id[]',
              name: '',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'assetTypeOfERC20',
          outputs: [
            {
              internalType: 'enum Treasury.AssetType',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'bondERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'deregisterERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'deregisterERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'executeTx',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Bondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Redeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdBondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdRedeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'lastRebase',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: '',
              type: 'bytes',
            },
          ],
          name: 'onERC721Received',
          outputs: [
            {
              internalType: 'bytes4',
              name: '',
              type: 'bytes4',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'oraclePerERC20',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oraclePerERC721Id',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'rebase',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'kttWad',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'redeemERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'redeemLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              internalType: 'enum Treasury.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              internalType: 'enum Treasury.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'registerERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'registerERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC20s',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC721Ids',
          outputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'riskLevelOfERC20',
          outputs: [
            {
              internalType: 'enum Treasury.RiskLevel',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'scaledBalanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'scaledTotalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20BondingLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20RedeemLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Bond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Redemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalValuation',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'transferAll',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'transferAllFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateERC20Oracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateERC721IdOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'withdrawERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'withdrawERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'Kolektivo Treasury Token': {
      address: '0x0000000000000000000000000000000000000000',
      abi: 'ERC20',
    },
    'Mento Exchange': {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'test',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'goldBucket',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'stableBucket',
              type: 'uint256',
            },
          ],
          name: 'BucketsUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchanger',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'soldGold',
              type: 'bool',
            },
          ],
          name: 'Exchanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'minSupplyForStableBucketCap',
              type: 'uint256',
            },
          ],
          name: 'MinSupplyForStableBucketCapSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'minimumReports',
              type: 'uint256',
            },
          ],
          name: 'MinimumReportsSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'reserveFraction',
              type: 'uint256',
            },
          ],
          name: 'ReserveFractionSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'spread',
              type: 'uint256',
            },
          ],
          name: 'SpreadSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'stableBucketMaxFraction',
              type: 'uint256',
            },
          ],
          name: 'StableBucketMaxFractionSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'stable',
              type: 'address',
            },
          ],
          name: 'StableTokenSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'updateFrequency',
              type: 'uint256',
            },
          ],
          name: 'UpdateFrequencySet',
          type: 'event',
        },
        {
          constant: !1,
          inputs: [],
          name: 'activateStable',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'maxSellAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'buyGold',
              type: 'bool',
            },
          ],
          name: 'buy',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minBuyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'exchange',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getBuyAndSellBuckets',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getBuyTokenAmount',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getSellTokenAmount',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getStableBucketCap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'pure',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'goldBucket',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'stableTokenIdentifier',
              type: 'string',
            },
            {
              internalType: 'uint256',
              name: '_spread',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_reserveFraction',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_updateFrequency',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_minimumReports',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_minSupplyForStableBucketCap',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_stableBucketMaxFraction',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'initialized',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'isOwner',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'lastBucketUpdate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'minSupplyForStableBucketCap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'minimumReports',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'reserveFraction',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minBuyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'sell',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'newMinSupplyForStableBucketCap',
              type: 'uint256',
            },
          ],
          name: 'setMinSupplyForStableBucketCap',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'newMininumReports',
              type: 'uint256',
            },
          ],
          name: 'setMinimumReports',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'newReserveFraction',
              type: 'uint256',
            },
          ],
          name: 'setReserveFraction',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'newSpread',
              type: 'uint256',
            },
          ],
          name: 'setSpread',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'newStableBucketMaxFraction',
              type: 'uint256',
            },
          ],
          name: 'setStableBucketMaxFraction',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'newStableToken',
              type: 'address',
            },
          ],
          name: 'setStableToken',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'newUpdateFrequency',
              type: 'uint256',
            },
          ],
          name: 'setUpdateFrequency',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'spread',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'stable',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'stableBucket',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'stableBucketMaxFraction',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'stableTokenRegistryId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'updateFrequency',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    'Mento Reserve': {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'test',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bytes32[]',
              name: 'symbols',
              type: 'bytes32[]',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'weights',
              type: 'uint256[]',
            },
          ],
          name: 'AssetAllocationSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'ratio',
              type: 'uint256',
            },
          ],
          name: 'DailySpendingRatioSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchangeSpender',
              type: 'address',
            },
          ],
          name: 'ExchangeSpenderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchangeSpender',
              type: 'address',
            },
          ],
          name: 'ExchangeSpenderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'otherReserveAddress',
              type: 'address',
            },
          ],
          name: 'OtherReserveAddressAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'otherReserveAddress',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'OtherReserveAddressRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'ReserveGoldTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'SpenderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'SpenderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxReserveRatioSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxStalenessThresholdSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'TokenAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'TokenRemoved',
          type: 'event',
        },
        {
          payable: !0,
          stateMutability: 'payable',
          type: 'fallback',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'addExchangeSpender',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'reserveAddress',
              type: 'address',
            },
          ],
          name: 'addOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'addSpender',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'addToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'assetAllocationSymbols',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          name: 'assetAllocationWeights',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'exchangeSpenderAddresses',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'frozenReserveGoldDays',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'frozenReserveGoldStartBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'frozenReserveGoldStartDay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getAssetAllocationSymbols',
          outputs: [
            {
              internalType: 'bytes32[]',
              name: '',
              type: 'bytes32[]',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getAssetAllocationWeights',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getDailySpendingRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getExchangeSpenders',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getFrozenReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [],
          name: 'getOrComputeTobinTax',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getOtherReserveAddresses',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getOtherReserveAddressesGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getReserveRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getTokens',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getUnfrozenBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getUnfrozenReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'pure',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '_tobinTaxStalenessThreshold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_spendingRatio',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_frozenGold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_frozenDays',
              type: 'uint256',
            },
            {
              internalType: 'bytes32[]',
              name: '_assetAllocationSymbols',
              type: 'bytes32[]',
            },
            {
              internalType: 'uint256[]',
              name: '_assetAllocationWeights',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: '_tobinTax',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_tobinTaxReserveRatio',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'initialized',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isExchangeSpender',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'isOwner',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isSpender',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'lastSpendingDay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'otherReserveAddresses',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeExchangeSpender',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'reserveAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'removeSpender',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'bytes32[]',
              name: 'symbols',
              type: 'bytes32[]',
            },
            {
              internalType: 'uint256[]',
              name: 'weights',
              type: 'uint256[]',
            },
          ],
          name: 'setAssetAllocations',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'ratio',
              type: 'uint256',
            },
          ],
          name: 'setDailySpendingRatio',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'frozenGold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'frozenDays',
              type: 'uint256',
            },
          ],
          name: 'setFrozenGold',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTax',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTaxReserveRatio',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTaxStalenessThreshold',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'spendingLimit',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'tobinTax',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'tobinTaxCache',
          outputs: [
            {
              internalType: 'uint128',
              name: 'numerator',
              type: 'uint128',
            },
            {
              internalType: 'uint128',
              name: 'timestamp',
              type: 'uint128',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'tobinTaxReserveRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'tobinTaxStalenessThreshold',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address payable',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferExchangeGold',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address payable',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferGold',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'Kolektivo Curacao Guilder Token': {
      address: '0x9E1ACEF9AA38b42f2C413f32d440f0F1Db53EDEc',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'test',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'factor',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'lastUpdated',
              type: 'uint256',
            },
          ],
          name: 'InflationFactorUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'rate',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'updatePeriod',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'lastUpdated',
              type: 'uint256',
            },
          ],
          name: 'InflationParametersUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'string',
              name: 'comment',
              type: 'string',
            },
          ],
          name: 'TransferComment',
          type: 'event',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'address',
              name: 'accountOwner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'address',
              name: 'accountOwner',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'blsKey',
              type: 'bytes',
            },
            {
              internalType: 'bytes',
              name: 'blsPop',
              type: 'bytes',
            },
          ],
          name: 'checkProofOfPossession',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'feeRecipient',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'gatewayFeeRecipient',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'communityFund',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'refund',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'tipTxFee',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'gatewayFee',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'baseTxFee',
              type: 'uint256',
            },
          ],
          name: 'creditGasFees',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'debitGasFees',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'aNumerator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'aDenominator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bNumerator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bDenominator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'exponent',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_decimals',
              type: 'uint256',
            },
          ],
          name: 'fractionMulExp',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'getBlockNumberFromHeader',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getEpochNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'getEpochNumberOfBlock',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getEpochSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getExchangeRegistryId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getInflationParameters',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'getParentSealBitmap',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'getVerifiedSealBitmapFromHeader',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'pure',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'hashHeader',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'string',
              name: '_name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: '_symbol',
              type: 'string',
            },
            {
              internalType: 'uint8',
              name: '_decimals',
              type: 'uint8',
            },
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'inflationRate',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'inflationFactorUpdatePeriod',
              type: 'uint256',
            },
            {
              internalType: 'address[]',
              name: 'initialBalanceAddresses',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'initialBalanceValues',
              type: 'uint256[]',
            },
            {
              internalType: 'string',
              name: 'exchangeIdentifier',
              type: 'string',
            },
          ],
          name: 'initialize',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'initialized',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'isOwner',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'minQuorumSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'minQuorumSizeInCurrentSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'mint',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'numberValidatorsInCurrentSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'numberValidatorsInSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'uint256',
              name: 'rate',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'updatePeriod',
              type: 'uint256',
            },
          ],
          name: 'setInflationParameters',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !1,
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'string',
              name: 'comment',
              type: 'string',
            },
          ],
          name: 'transferWithComment',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          payable: !1,
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'units',
              type: 'uint256',
            },
          ],
          name: 'unitsToValue',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'validatorSignerAddressFromCurrentSet',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'validatorSignerAddressFromSet',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
        {
          constant: !0,
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'valueToUnits',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          payable: !1,
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    'Symmetric-Vault': {
      address: '0xD25E02047E76b688445ab154785F2642c6fe3f73',
      abi: [
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'liquidityProvider',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              indexed: !1,
              internalType: 'int256[]',
              name: 'deltas',
              type: 'int256[]',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'protocolFeeAmounts',
              type: 'uint256[]',
            },
          ],
          name: 'PoolBalanceChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'assetManager',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'int256',
              name: 'cashDelta',
              type: 'int256',
            },
            {
              indexed: !1,
              internalType: 'int256',
              name: 'managedDelta',
              type: 'int256',
            },
          ],
          name: 'PoolBalanceManaged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'poolAddress',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum IVault.PoolSpecialization',
              name: 'specialization',
              type: 'uint8',
            },
          ],
          name: 'PoolRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'tokenIn',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'tokenOut',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amountIn',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amountOut',
              type: 'uint256',
            },
          ],
          name: 'Swap',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
          ],
          name: 'TokensDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              indexed: !1,
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
          ],
          name: 'TokensRegistered',
          type: 'event',
        },
        {
          inputs: [],
          name: 'WETH',
          outputs: [
            {
              internalType: 'contract IWETH',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.SwapKind',
              name: 'kind',
              type: 'uint8',
            },
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'int256[]',
              name: 'limits',
              type: 'int256[]',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'batchSwap',
          outputs: [
            {
              internalType: 'int256[]',
              name: '',
              type: 'int256[]',
            },
          ],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
          ],
          name: 'deregisterTokens',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address payable',
              name: 'recipient',
              type: 'address',
            },
            {
              components: [
                {
                  internalType: 'contract IAsset[]',
                  name: 'assets',
                  type: 'address[]',
                },
                {
                  internalType: 'uint256[]',
                  name: 'minAmountsOut',
                  type: 'uint256[]',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.ExitPoolRequest',
              name: 'request',
              type: 'tuple',
            },
          ],
          name: 'exitPool',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
          ],
          name: 'getPool',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'enum IVault.PoolSpecialization',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getPoolTokenInfo',
          outputs: [
            {
              internalType: 'uint256',
              name: 'cash',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'managed',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'assetManager',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
          ],
          name: 'getPoolTokens',
          outputs: [
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              components: [
                {
                  internalType: 'contract IAsset[]',
                  name: 'assets',
                  type: 'address[]',
                },
                {
                  internalType: 'uint256[]',
                  name: 'maxAmountsIn',
                  type: 'uint256[]',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.JoinPoolRequest',
              name: 'request',
              type: 'tuple',
            },
          ],
          name: 'joinPool',
          outputs: [],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.PoolBalanceOpKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'token',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
              ],
              internalType: 'struct IVault.PoolBalanceOp[]',
              name: 'ops',
              type: 'tuple[]',
            },
          ],
          name: 'managePoolBalance',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.SwapKind',
              name: 'kind',
              type: 'uint8',
            },
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
          ],
          name: 'queryBatchSwap',
          outputs: [
            {
              internalType: 'int256[]',
              name: 'assetDeltas',
              type: 'int256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.PoolSpecialization',
              name: 'specialization',
              type: 'uint8',
            },
          ],
          name: 'registerPool',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
          ],
          name: 'registerTokens',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IAsset',
                  name: 'assetIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IAsset',
                  name: 'assetOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.SingleSwap',
              name: 'singleSwap',
              type: 'tuple',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'swap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'payable',
          type: 'function',
        },
      ],
    },
    VestingVault: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'claim',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'vestingDuration',
              type: 'uint256',
            },
          ],
          name: 'depositFor',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'token',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'unvestedFor',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'vestedFor',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    'kGuilder Pool': {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'contract IVault',
              name: 'vault',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: 'symbol',
              type: 'string',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'amplificationParameter',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowDuration',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodDuration',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'startValue',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'endValue',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'startTime',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'endTime',
              type: 'uint256',
            },
          ],
          name: 'AmpUpdateStarted',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'currentValue',
              type: 'uint256',
            },
          ],
          name: 'AmpUpdateStopped',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'PausedStateChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'SwapFeePercentageChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'selector',
              type: 'bytes4',
            },
          ],
          name: 'getActionId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAmplificationParameter',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'isUpdating',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'precision',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAuthorizer',
          outputs: [
            {
              internalType: 'contract IAuthorizer',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getLastInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: 'lastInvariant',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'lastInvariantAmp',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPausedState',
          outputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowEndTime',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodEndTime',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPoolId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getScalingFactors',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getSwapFeePercentage',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVault',
          outputs: [
            {
              internalType: 'contract IVault',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'addedValue',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onExitPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onJoinPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'swapRequest',
              type: 'tuple',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'indexIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'indexOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'request',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryExit',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsOut',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryJoin',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptOut',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsIn',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'poolConfig',
              type: 'bytes',
            },
          ],
          name: 'setAssetManagerPoolConfig',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'setPaused',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'setSwapFeePercentage',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'rawEndValue',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'endTime',
              type: 'uint256',
            },
          ],
          name: 'startAmplificationParameterUpdate',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stopAmplificationParameterUpdate',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'kCur Pool': {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'contract IVault',
              name: 'vault',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: 'symbol',
              type: 'string',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'normalizedWeights',
              type: 'uint256[]',
            },
            {
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowDuration',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodDuration',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'PausedStateChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'SwapFeePercentageChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'selector',
              type: 'bytes4',
            },
          ],
          name: 'getActionId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAuthorizer',
          outputs: [
            {
              internalType: 'contract IAuthorizer',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getLastInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getNormalizedWeights',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPausedState',
          outputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowEndTime',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodEndTime',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPoolId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getScalingFactors',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getSwapFeePercentage',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVault',
          outputs: [
            {
              internalType: 'contract IVault',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'addedValue',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onExitPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onJoinPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'request',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryExit',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsOut',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryJoin',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptOut',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsIn',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'poolConfig',
              type: 'bytes',
            },
          ],
          name: 'setAssetManagerPoolConfig',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'setPaused',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'setSwapFeePercentage',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    cUSD: {
      address: '0x765DE816845861e75A25fCA122bb6898B8B1282a',
      abi: 'ERC20',
    },
  },
  zO = {
    name: Ew,
    chainId: Cw,
    contracts: Sw,
  },
  GO = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        chainId: Cw,
        contracts: Sw,
        default: zO,
        name: Ew,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Mw = [
    {
      inputs: [
        {
          internalType: 'string',
          name: '_baseUri',
          type: 'string',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'constructor',
    },
    {
      inputs: [],
      name: 'TransferDisabled',
      type: 'error',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'account',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'approved',
          type: 'bool',
        },
      ],
      name: 'ApprovalForAll',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousOwner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'OwnershipTransferred',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'tokenId',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'string',
          name: 'uri',
          type: 'string',
        },
      ],
      name: 'TokenUriUpdated',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256[]',
          name: 'ids',
          type: 'uint256[]',
        },
        {
          indexed: !1,
          internalType: 'uint256[]',
          name: 'values',
          type: 'uint256[]',
        },
      ],
      name: 'TransferBatch',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
      ],
      name: 'TransferSingle',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'string',
          name: 'value',
          type: 'string',
        },
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'URI',
      type: 'event',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'account',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'balanceOf',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address[]',
          name: 'accounts',
          type: 'address[]',
        },
        {
          internalType: 'uint256[]',
          name: 'ids',
          type: 'uint256[]',
        },
      ],
      name: 'balanceOfBatch',
      outputs: [
        {
          internalType: 'uint256[]',
          name: '',
          type: 'uint256[]',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'account',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'burn',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address[]',
          name: 'accounts',
          type: 'address[]',
        },
        {
          internalType: 'uint256[]',
          name: 'tokenIds',
          type: 'uint256[]',
        },
        {
          internalType: 'uint256[]',
          name: 'amounts',
          type: 'uint256[]',
        },
      ],
      name: 'burnFromMultiple',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'account',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
      ],
      name: 'isApprovedForAll',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'account',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'mint',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address[]',
          name: 'accounts',
          type: 'address[]',
        },
        {
          internalType: 'uint256[]',
          name: 'tokenIds',
          type: 'uint256[]',
        },
        {
          internalType: 'uint256[]',
          name: 'amounts',
          type: 'uint256[]',
        },
      ],
      name: 'mintToMultiple',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'owner',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'renounceOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256[]',
          name: 'ids',
          type: 'uint256[]',
        },
        {
          internalType: 'uint256[]',
          name: 'amounts',
          type: 'uint256[]',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
      ],
      name: 'safeBatchTransferFrom',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
      ],
      name: 'safeTransferFrom',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      name: 'setApprovalForAll',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'string',
          name: 'baseUri',
          type: 'string',
        },
      ],
      name: 'setBaseUri',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'tokenId',
          type: 'uint256',
        },
        {
          internalType: 'string',
          name: 'newUri',
          type: 'string',
        },
      ],
      name: 'setUri',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes4',
          name: 'interfaceId',
          type: 'bytes4',
        },
      ],
      name: 'supportsInterface',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      name: 'tokenUris',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'transferOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'tokenId',
          type: 'uint256',
        },
      ],
      name: 'uri',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
  ],
  _w = [
    {
      inputs: [
        {
          internalType: 'address',
          name: '_owner',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '_avatar',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '_target',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '_badger',
          type: 'address',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'constructor',
    },
    {
      inputs: [],
      name: 'ArraysDifferentLength',
      type: 'error',
    },
    {
      inputs: [],
      name: 'ModuleTransactionFailed',
      type: 'error',
    },
    {
      inputs: [],
      name: 'NoMembership',
      type: 'error',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'guard_',
          type: 'address',
        },
      ],
      name: 'NotIERC165Compliant',
      type: 'error',
    },
    {
      inputs: [],
      name: 'RedundantUpdateOfState',
      type: 'error',
    },
    {
      inputs: [],
      name: 'SetUpModulesAlreadyCalled',
      type: 'error',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousAvatar',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newAvatar',
          type: 'address',
        },
      ],
      name: 'AvatarSet',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'badgerAddress',
          type: 'address',
        },
      ],
      name: 'BadgerUpdated',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'guard',
          type: 'address',
        },
      ],
      name: 'ChangedGuard',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'uint8',
          name: 'version',
          type: 'uint8',
        },
      ],
      name: 'Initialized',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousOwner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'OwnershipTransferred',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'initiator',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'avatar',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'RolesModSetup',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'multisendAddress',
          type: 'address',
        },
      ],
      name: 'SetMultisendAddress',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousTarget',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newTarget',
          type: 'address',
        },
      ],
      name: 'TargetSet',
      type: 'event',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'enum ExecutionOptions',
          name: 'options',
          type: 'uint8',
        },
      ],
      name: 'allowTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'avatar',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'badger',
      outputs: [
        {
          internalType: 'contract IBadger',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
      ],
      name: 'execTransactionFromModule',
      outputs: [
        {
          internalType: 'bool',
          name: 'success',
          type: 'bool',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
      ],
      name: 'execTransactionFromModuleReturnData',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
        {
          internalType: 'bytes',
          name: '',
          type: 'bytes',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'getGuard',
      outputs: [
        {
          internalType: 'address',
          name: '_guard',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'guard',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'multisend',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'owner',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'renounceOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
      ],
      name: 'revokeTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'enum ExecutionOptions',
          name: 'options',
          type: 'uint8',
        },
      ],
      name: 'scopeAllowFunction',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'bool[]',
          name: 'isParamScoped',
          type: 'bool[]',
        },
        {
          internalType: 'enum ParameterType[]',
          name: 'paramType',
          type: 'uint8[]',
        },
        {
          internalType: 'enum Comparison[]',
          name: 'paramComp',
          type: 'uint8[]',
        },
        {
          internalType: 'bytes[]',
          name: 'compValue',
          type: 'bytes[]',
        },
        {
          internalType: 'enum ExecutionOptions',
          name: 'options',
          type: 'uint8',
        },
      ],
      name: 'scopeFunction',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'enum ExecutionOptions',
          name: 'options',
          type: 'uint8',
        },
      ],
      name: 'scopeFunctionExecutionOptions',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'uint256',
          name: 'paramIndex',
          type: 'uint256',
        },
        {
          internalType: 'enum ParameterType',
          name: 'paramType',
          type: 'uint8',
        },
        {
          internalType: 'enum Comparison',
          name: 'paramComp',
          type: 'uint8',
        },
        {
          internalType: 'bytes',
          name: 'compValue',
          type: 'bytes',
        },
      ],
      name: 'scopeParameter',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'uint256',
          name: 'paramIndex',
          type: 'uint256',
        },
        {
          internalType: 'enum ParameterType',
          name: 'paramType',
          type: 'uint8',
        },
        {
          internalType: 'bytes[]',
          name: 'compValues',
          type: 'bytes[]',
        },
      ],
      name: 'scopeParameterAsOneOf',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
      ],
      name: 'scopeRevokeFunction',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
      ],
      name: 'scopeTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_avatar',
          type: 'address',
        },
      ],
      name: 'setAvatar',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_guard',
          type: 'address',
        },
      ],
      name: 'setGuard',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_multisend',
          type: 'address',
        },
      ],
      name: 'setMultisend',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_target',
          type: 'address',
        },
      ],
      name: 'setTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes',
          name: 'initParams',
          type: 'bytes',
        },
      ],
      name: 'setUp',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'target',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'transferOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'uint8',
          name: 'paramIndex',
          type: 'uint8',
        },
      ],
      name: 'unscopeParameter',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_newBadger',
          type: 'address',
        },
      ],
      name: 'updateBadger',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  Rw = [
    {
      inputs: [
        {
          internalType: 'address',
          name: '_owner',
          type: 'address',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'constructor',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'uint8',
          name: 'version',
          type: 'uint8',
        },
      ],
      name: 'Initialized',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousOwner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'OwnershipTransferred',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'initiator',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
      ],
      name: 'ScopeGuardSetup',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
      ],
      name: 'SetDelegateCallAllowedOnTarget',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
      ],
      name: 'SetFallbackAllowedOnTarget',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
      ],
      name: 'SetFunctionAllowedOnTarget',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
      ],
      name: 'SetTargetAllowed',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'scoped',
          type: 'bool',
        },
      ],
      name: 'SetTargetScoped',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
      ],
      name: 'SetValueAllowedOnTarget',
      type: 'event',
    },
    {
      stateMutability: 'nonpayable',
      type: 'fallback',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'allowedTargets',
      outputs: [
        {
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
        {
          internalType: 'bool',
          name: 'scoped',
          type: 'bool',
        },
        {
          internalType: 'bool',
          name: 'delegateCallAllowed',
          type: 'bool',
        },
        {
          internalType: 'bool',
          name: 'fallbackAllowed',
          type: 'bool',
        },
        {
          internalType: 'bool',
          name: 'valueAllowed',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      name: 'checkAfterExecution',
      outputs: [],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
        {
          internalType: 'address payable',
          name: '',
          type: 'address',
        },
        {
          internalType: 'bytes',
          name: '',
          type: 'bytes',
        },
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'checkTransaction',
      outputs: [],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
      ],
      name: 'isAllowedFunction',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'isAllowedTarget',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'isAllowedToDelegateCall',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'isScoped',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'isValueAllowed',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'isfallbackAllowed',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'owner',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'renounceOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'bool',
          name: 'allow',
          type: 'bool',
        },
      ],
      name: 'setAllowedFunction',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'allow',
          type: 'bool',
        },
      ],
      name: 'setDelegateCallAllowedOnTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'allow',
          type: 'bool',
        },
      ],
      name: 'setFallbackAllowedOnTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'scoped',
          type: 'bool',
        },
      ],
      name: 'setScoped',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'allow',
          type: 'bool',
        },
      ],
      name: 'setTargetAllowed',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes',
          name: 'initializeParams',
          type: 'bytes',
        },
      ],
      name: 'setUp',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'allow',
          type: 'bool',
        },
      ],
      name: 'setValueAllowedOnTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes4',
          name: 'interfaceId',
          type: 'bytes4',
        },
      ],
      name: 'supportsInterface',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'pure',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'transferOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  Pw = [
    {
      inputs: [
        {
          internalType: 'address',
          name: '_owner',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '_avatar',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '_target',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: '_cooldown',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: '_expiration',
          type: 'uint256',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'constructor',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'AlreadyDisabledModule',
      type: 'error',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'AlreadyEnabledModule',
      type: 'error',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'InvalidModule',
      type: 'error',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'sender',
          type: 'address',
        },
      ],
      name: 'NotAuthorized',
      type: 'error',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'guard_',
          type: 'address',
        },
      ],
      name: 'NotIERC165Compliant',
      type: 'error',
    },
    {
      inputs: [],
      name: 'RedundantUpdateOfState',
      type: 'error',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousAvatar',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newAvatar',
          type: 'address',
        },
      ],
      name: 'AvatarSet',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'guard',
          type: 'address',
        },
      ],
      name: 'ChangedGuard',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'initiator',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'avatar',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'DelaySetup',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'DisabledModule',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'EnabledModule',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'ExecutionFromModuleFailure',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'ExecutionFromModuleSuccess',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'uint8',
          name: 'version',
          type: 'uint8',
        },
      ],
      name: 'Initialized',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousOwner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'OwnershipTransferred',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'queueIndex',
          type: 'uint256',
        },
        {
          indexed: !0,
          internalType: 'bytes32',
          name: 'txHash',
          type: 'bytes32',
        },
        {
          indexed: !1,
          internalType: 'string',
          name: 'uri',
          type: 'string',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'salt',
          type: 'uint256',
        },
      ],
      name: 'SecretTransactionAdded',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          indexed: !1,
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: '_salt',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'txIndex',
          type: 'uint256',
        },
      ],
      name: 'SecretTransactionExecuted',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousTarget',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newTarget',
          type: 'address',
        },
      ],
      name: 'TargetSet',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'queueIndex',
          type: 'uint256',
        },
        {
          indexed: !0,
          internalType: 'bytes32',
          name: 'txHash',
          type: 'bytes32',
        },
        {
          indexed: !1,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          indexed: !1,
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
      ],
      name: 'TransactionAdded',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          indexed: !1,
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'txIndex',
          type: 'uint256',
        },
      ],
      name: 'TransactionExecuted',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'startingApprovedTrxNonce',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'numberOfTrxApproved',
          type: 'uint256',
        },
      ],
      name: 'TransactionsApproved',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'startingVetoedTrxNonce',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'numberOfTrxVetoed',
          type: 'uint256',
        },
      ],
      name: 'TransactionsVetoed',
      type: 'event',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '_transactions',
          type: 'uint256',
        },
      ],
      name: 'approveNext',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'approved',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'avatar',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'prevModule',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'disableModule',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'enableModule',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes32',
          name: 'hashedTransaction',
          type: 'bytes32',
        },
        {
          internalType: 'string',
          name: 'uri',
          type: 'string',
        },
      ],
      name: 'enqueueSecretTx',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
      ],
      name: 'execTransactionFromModule',
      outputs: [
        {
          internalType: 'bool',
          name: 'success',
          type: 'bool',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
      ],
      name: 'execTransactionFromModuleReturnData',
      outputs: [
        {
          internalType: 'bool',
          name: 'success',
          type: 'bool',
        },
        {
          internalType: 'bytes',
          name: 'returnData',
          type: 'bytes',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          internalType: 'uint256',
          name: '_salt',
          type: 'uint256',
        },
      ],
      name: 'executeNextSecretTx',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
      ],
      name: 'executeNextTx',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'getGuard',
      outputs: [
        {
          internalType: 'address',
          name: '_guard',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'start',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'pageSize',
          type: 'uint256',
        },
      ],
      name: 'getModulesPaginated',
      outputs: [
        {
          internalType: 'address[]',
          name: 'array',
          type: 'address[]',
        },
        {
          internalType: 'address',
          name: 'next',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          internalType: 'uint256',
          name: '_salt',
          type: 'uint256',
        },
      ],
      name: 'getSecretTransactionHash',
      outputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
      ],
      stateMutability: 'pure',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
      ],
      name: 'getTransactionHash',
      outputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
      ],
      stateMutability: 'pure',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '_nonce',
          type: 'uint256',
        },
      ],
      name: 'getTxCreatedAt',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '_nonce',
          type: 'uint256',
        },
      ],
      name: 'getTxHash',
      outputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'guard',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_module',
          type: 'address',
        },
      ],
      name: 'isModuleEnabled',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'owner',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'queuePointer',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'renounceOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'salt',
      outputs: [
        {
          internalType: 'uint256',
          name: '_value',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_avatar',
          type: 'address',
        },
      ],
      name: 'setAvatar',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_guard',
          type: 'address',
        },
      ],
      name: 'setGuard',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_target',
          type: 'address',
        },
      ],
      name: 'setTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'cooldown',
          type: 'uint256',
        },
      ],
      name: 'setTxCooldown',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'expiration',
          type: 'uint256',
        },
      ],
      name: 'setTxExpiration',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes',
          name: 'initParams',
          type: 'bytes',
        },
      ],
      name: 'setUp',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'skipExpired',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'target',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'transferOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'txCooldown',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      name: 'txCreatedAt',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'txExpiration',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      name: 'txHash',
      outputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'txNonce',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '_newTxNonce',
          type: 'uint256',
        },
      ],
      name: 'vetoTransactionsTill',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '_newTxNonce',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: '_transactions',
          type: 'uint256',
        },
      ],
      name: 'vetoTransactionsTillAndApprove',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  HO = {
    Badger: Mw,
    BACRoles: _w,
    ScopeGuard: Rw,
    SecretDelay: Pw,
  },
  KO = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        BACRoles: _w,
        Badger: Mw,
        ScopeGuard: Rw,
        SecretDelay: Pw,
        default: HO,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  qO = {},
  WO = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        default: qO,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Iw = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'spender',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'Approval',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'Transfer',
      type: 'event',
    },
    {
      inputs: [],
      name: 'DOMAIN_SEPARATOR',
      outputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'allowance',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'spender',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'approve',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'balanceOf',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'decimals',
      outputs: [
        {
          internalType: 'uint8',
          name: '',
          type: 'uint8',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'name',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'nonces',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'spender',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: 'deadline',
          type: 'uint256',
        },
        {
          internalType: 'uint8',
          name: 'v',
          type: 'uint8',
        },
        {
          internalType: 'bytes32',
          name: 'r',
          type: 'bytes32',
        },
        {
          internalType: 'bytes32',
          name: 's',
          type: 'bytes32',
        },
      ],
      name: 'permit',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'symbol',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'totalSupply',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'transfer',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'transferFrom',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  kw = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'spender',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'Approval',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'approved',
          type: 'bool',
        },
      ],
      name: 'ApprovalForAll',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'Transfer',
      type: 'event',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'spender',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'approve',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
      ],
      name: 'balanceOf',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      name: 'getApproved',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'isApprovedForAll',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'name',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'ownerOf',
      outputs: [
        {
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'safeTransferFrom',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
      ],
      name: 'safeTransferFrom',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'approved',
          type: 'bool',
        },
      ],
      name: 'setApprovalForAll',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes4',
          name: 'interfaceId',
          type: 'bytes4',
        },
      ],
      name: 'supportsInterface',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'symbol',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'tokenURI',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'transferFrom',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  JO = {
    ERC20: Iw,
    ERC721: kw,
  },
  QO = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        ERC20: Iw,
        ERC721: kw,
        default: JO,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  );
var YO = Ow,
  uv = 128,
  XO = 127,
  ZO = ~XO,
  eB = Math.pow(2, 31);
function Ow(n, e, t) {
  (e = e || []), (t = t || 0);
  for (var r = t; n >= eB; ) (e[t++] = (n & 255) | uv), (n /= 128);
  for (; n & ZO; ) (e[t++] = (n & 255) | uv), (n >>>= 7);
  return (e[t] = n | 0), (Ow.bytes = t - r + 1), e;
}
var tB = Rh,
  nB = 128,
  lv = 127;
function Rh(n, r) {
  var t = 0,
    r = r || 0,
    i = 0,
    s = r,
    a,
    o = n.length;
  do {
    if (s >= o) throw ((Rh.bytes = 0), new RangeError('Could not decode varint'));
    (a = n[s++]), (t += i < 28 ? (a & lv) << i : (a & lv) * Math.pow(2, i)), (i += 7);
  } while (a >= nB);
  return (Rh.bytes = s - r), t;
}
var rB = Math.pow(2, 7),
  iB = Math.pow(2, 14),
  sB = Math.pow(2, 21),
  aB = Math.pow(2, 28),
  oB = Math.pow(2, 35),
  uB = Math.pow(2, 42),
  lB = Math.pow(2, 49),
  cB = Math.pow(2, 56),
  dB = Math.pow(2, 63),
  pB = function (n) {
    return n < rB ? 1 : n < iB ? 2 : n < sB ? 3 : n < aB ? 4 : n < oB ? 5 : n < uB ? 6 : n < lB ? 7 : n < cB ? 8 : n < dB ? 9 : 10;
  },
  fB = {
    encode: YO,
    decode: tB,
    encodingLength: pB,
  },
  bd = fB;
const Ph = (n, e = 0) => [bd.decode(n, e), bd.decode.bytes],
  gd = (n, e, t = 0) => (bd.encode(n, e, t), e),
  vd = (n) => bd.encodingLength(n),
  hB = (n, e) => {
    if (n === e) return !0;
    if (n.byteLength !== e.byteLength) return !1;
    for (let t = 0; t < n.byteLength; t++) if (n[t] !== e[t]) return !1;
    return !0;
  },
  k0 = (n) => {
    if (n instanceof Uint8Array && n.constructor.name === 'Uint8Array') return n;
    if (n instanceof ArrayBuffer) return new Uint8Array(n);
    if (ArrayBuffer.isView(n)) return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
    throw new Error('Unknown type, must be binary type');
  },
  yB = (n) => new TextEncoder().encode(n),
  mB = (n) => new TextDecoder().decode(n),
  bB = (n, e) => {
    const t = e.byteLength,
      r = vd(n),
      i = r + vd(t),
      s = new Uint8Array(i + t);
    return gd(n, s, 0), gd(t, s, r), s.set(e, i), new O0(n, t, e, s);
  },
  gB = (n) => {
    const e = k0(n),
      [t, r] = Ph(e),
      [i, s] = Ph(e.subarray(r)),
      a = e.subarray(r + s);
    if (a.byteLength !== i) throw new Error('Incorrect length');
    return new O0(t, i, a, e);
  },
  vB = (n, e) => {
    if (n === e) return !0;
    {
      const t =
        /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
        e;
      return n.code === t.code && n.size === t.size && t.bytes instanceof Uint8Array && hB(n.bytes, t.bytes);
    }
  };
class O0 {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(e, t, r, i) {
    (this.code = e), (this.size = t), (this.digest = r), (this.bytes = i);
  }
}
function xB(n, e) {
  if (n.length >= 255) throw new TypeError('Alphabet too long');
  for (var t = new Uint8Array(256), r = 0; r < t.length; r++) t[r] = 255;
  for (var i = 0; i < n.length; i++) {
    var s = n.charAt(i),
      a = s.charCodeAt(0);
    if (t[a] !== 255) throw new TypeError(s + ' is ambiguous');
    t[a] = i;
  }
  var o = n.length,
    u = n.charAt(0),
    l = Math.log(o) / Math.log(256),
    p = Math.log(256) / Math.log(o);
  function h(x) {
    if ((x instanceof Uint8Array || (ArrayBuffer.isView(x) ? (x = new Uint8Array(x.buffer, x.byteOffset, x.byteLength)) : Array.isArray(x) && (x = Uint8Array.from(x))), !(x instanceof Uint8Array)))
      throw new TypeError('Expected Uint8Array');
    if (x.length === 0) return '';
    for (var T = 0, w = 0, _ = 0, k = x.length; _ !== k && x[_] === 0; ) _++, T++;
    for (var D = ((k - _) * p + 1) >>> 0, N = new Uint8Array(D); _ !== k; ) {
      for (var B = x[_], j = 0, q = D - 1; (B !== 0 || j < w) && q !== -1; q--, j++) (B += (256 * N[q]) >>> 0), (N[q] = B % o >>> 0), (B = (B / o) >>> 0);
      if (B !== 0) throw new Error('Non-zero carry');
      (w = j), _++;
    }
    for (var z = D - w; z !== D && N[z] === 0; ) z++;
    for (var Y = u.repeat(T); z < D; ++z) Y += n.charAt(N[z]);
    return Y;
  }
  function b(x) {
    if (typeof x != 'string') throw new TypeError('Expected String');
    if (x.length === 0) return new Uint8Array();
    var T = 0;
    if (x[T] !== ' ') {
      for (var w = 0, _ = 0; x[T] === u; ) w++, T++;
      for (var k = ((x.length - T) * l + 1) >>> 0, D = new Uint8Array(k); x[T]; ) {
        var N = t[x.charCodeAt(T)];
        if (N === 255) return;
        for (var B = 0, j = k - 1; (N !== 0 || B < _) && j !== -1; j--, B++) (N += (o * D[j]) >>> 0), (D[j] = N % 256 >>> 0), (N = (N / 256) >>> 0);
        if (N !== 0) throw new Error('Non-zero carry');
        (_ = B), T++;
      }
      if (x[T] !== ' ') {
        for (var q = k - _; q !== k && D[q] === 0; ) q++;
        for (var z = new Uint8Array(w + (k - q)), Y = w; q !== k; ) z[Y++] = D[q++];
        return z;
      }
    }
  }
  function E(x) {
    var T = b(x);
    if (T) return T;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: h,
    decodeUnsafe: b,
    decode: E,
  };
}
var wB = xB,
  TB = wB;
class AB {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(e, t, r) {
    (this.name = e), (this.prefix = t), (this.baseEncode = r);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error('Unknown type, must be binary type');
  }
}
class EB {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, t, r) {
    if (((this.name = e), (this.prefix = t), t.codePointAt(0) === void 0)) throw new Error('Invalid prefix character');
    (this.prefixCodePoint = /** @type {number} */ t.codePointAt(0)), (this.baseDecode = r);
  }
  /**
   * @param {string} text
   */
  decode(e) {
    if (typeof e == 'string') {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error('Can only multibase decode strings');
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return Bw(this, e);
  }
}
class CB {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(e) {
    this.decoders = e;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return Bw(this, e);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(e) {
    const t =
        /** @type {Prefix} */
        e[0],
      r = this.decoders[t];
    if (r) return r.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Bw = (n, e) =>
  new CB(
    /** @type {Decoders<L|R>} */
    {
      ...(n.decoders || {
        [/** @type API.UnibaseDecoder<L> */ n.prefix]: n,
      }),
      ...(e.decoders || {
        [/** @type API.UnibaseDecoder<R> */ e.prefix]: e,
      }),
    },
  );
class SB {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, t, r, i) {
    (this.name = e), (this.prefix = t), (this.baseEncode = r), (this.baseDecode = i), (this.encoder = new AB(e, t, r)), (this.decoder = new EB(e, t, i));
  }
  /**
   * @param {Uint8Array} input
   */
  encode(e) {
    return this.encoder.encode(e);
  }
  /**
   * @param {string} input
   */
  decode(e) {
    return this.decoder.decode(e);
  }
}
const sp = ({ name: n, prefix: e, encode: t, decode: r }) => new SB(n, e, t, r),
  Rl = ({ prefix: n, name: e, alphabet: t }) => {
    const { encode: r, decode: i } = TB(t, e);
    return sp({
      prefix: n,
      name: e,
      encode: r,
      /**
       * @param {string} text
       */
      decode: (s) => k0(i(s)),
    });
  },
  MB = (n, e, t, r) => {
    const i = {};
    for (let p = 0; p < e.length; ++p) i[e[p]] = p;
    let s = n.length;
    for (; n[s - 1] === '='; ) --s;
    const a = new Uint8Array(((s * t) / 8) | 0);
    let o = 0,
      u = 0,
      l = 0;
    for (let p = 0; p < s; ++p) {
      const h = i[n[p]];
      if (h === void 0) throw new SyntaxError(`Non-${r} character`);
      (u = (u << t) | h), (o += t), o >= 8 && ((o -= 8), (a[l++] = 255 & (u >> o)));
    }
    if (o >= t || 255 & (u << (8 - o))) throw new SyntaxError('Unexpected end of data');
    return a;
  },
  _B = (n, e, t) => {
    const r = e[e.length - 1] === '=',
      i = (1 << t) - 1;
    let s = '',
      a = 0,
      o = 0;
    for (let u = 0; u < n.length; ++u) for (o = (o << 8) | n[u], a += 8; a > t; ) (a -= t), (s += e[i & (o >> a)]);
    if ((a && (s += e[i & (o << (t - a))]), r)) for (; (s.length * t) & 7; ) s += '=';
    return s;
  },
  un = ({ name: n, prefix: e, bitsPerChar: t, alphabet: r }) =>
    sp({
      prefix: e,
      name: n,
      encode(i) {
        return _B(i, r, t);
      },
      decode(i) {
        return MB(i, r, t, n);
      },
    }),
  di = Rl({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  }),
  RB = Rl({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ',
  }),
  PB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base58btc: di,
        base58flickr: RB,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  xu = un({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5,
  }),
  IB = un({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5,
  }),
  kB = un({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5,
  }),
  OB = un({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5,
  }),
  BB = un({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5,
  }),
  NB = un({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5,
  }),
  DB = un({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5,
  }),
  FB = un({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5,
  }),
  LB = un({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5,
  }),
  $B = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base32: xu,
        base32hex: BB,
        base32hexpad: DB,
        base32hexpadupper: FB,
        base32hexupper: NB,
        base32pad: kB,
        base32padupper: OB,
        base32upper: IB,
        base32z: LB,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Ih = (n, e) => {
    const { bytes: t, version: r } = n;
    switch (r) {
      case 0:
        return jB(
          t,
          kh(n),
          /** @type {API.MultibaseEncoder<"z">} */
          e || di.encoder,
        );
      default:
        return VB(
          t,
          kh(n),
          /** @type {API.MultibaseEncoder<Prefix>} */
          e || xu.encoder,
        );
    }
  },
  cv = /* @__PURE__ */ new WeakMap(),
  kh = (n) => {
    const e = cv.get(n);
    if (e == null) {
      const t = /* @__PURE__ */ new Map();
      return cv.set(n, t), t;
    }
    return e;
  };
class Yt {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(e, t, r, i) {
    (this.code = t), (this.version = e), (this.multihash = r), (this.bytes = i), (this['/'] = i);
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0:
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      case 1: {
        const { code: e, multihash: t } = this;
        if (e !== Yo) throw new Error('Cannot convert a non dag-pb CID to CIDv0');
        if (t.code !== zB) throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          Yt.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            t,
          )
        );
      }
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: t } = this.multihash,
          r = bB(e, t);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          Yt.createV1(this.code, r)
        );
      }
      case 1:
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      default:
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(e) {
    return Yt.equals(this, e);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(e, t) {
    const r =
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      t;
    return r && e.code === r.code && e.version === r.version && vB(e.multihash, r.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(e) {
    return Ih(this, e);
  }
  toJSON() {
    return { '/': Ih(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return 'CID';
  }
  // Legacy
  [Symbol.for('nodejs.util.inspect.custom')]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(e) {
    if (e == null) return null;
    const t =
      /** @type {any} */
      e;
    if (t instanceof Yt) return t;
    if ((t['/'] != null && t['/'] === t.bytes) || t.asCID === t) {
      const { version: r, code: i, multihash: s, bytes: a } = t;
      return new Yt(
        r,
        i,
        /** @type {API.MultihashDigest<Alg>} */
        s,
        a || dv(r, i, s.bytes),
      );
    } else if (t[GB] === !0) {
      const { version: r, multihash: i, code: s } = t,
        a =
          /** @type {API.MultihashDigest<Alg>} */
          gB(i);
      return Yt.create(r, s, a);
    } else return null;
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(e, t, r) {
    if (typeof t != 'number') throw new Error('String codecs are no longer supported');
    if (!(r.bytes instanceof Uint8Array)) throw new Error('Invalid digest');
    switch (e) {
      case 0: {
        if (t !== Yo) throw new Error(`Version 0 CID must use dag-pb (code: ${Yo}) block encoding`);
        return new Yt(e, t, r, r.bytes);
      }
      case 1: {
        const i = dv(e, t, r.bytes);
        return new Yt(e, t, r, i);
      }
      default:
        throw new Error('Invalid version');
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(e) {
    return Yt.create(0, Yo, e);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(e, t) {
    return Yt.create(1, e, t);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(e) {
    const [t, r] = Yt.decodeFirst(e);
    if (r.length) throw new Error('Incorrect length');
    return t;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(e) {
    const t = Yt.inspectBytes(e),
      r = t.size - t.multihashSize,
      i = k0(e.subarray(r, r + t.multihashSize));
    if (i.byteLength !== t.multihashSize) throw new Error('Incorrect length');
    const s = i.subarray(t.multihashSize - t.digestSize),
      a = new O0(t.multihashCode, t.digestSize, s, i);
    return [
      t.version === 0
        ? Yt.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            a,
          )
        : Yt.createV1(t.codec, a),
      e.subarray(t.size),
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(e) {
    let t = 0;
    const r = () => {
      const [h, b] = Ph(e.subarray(t));
      return (t += b), h;
    };
    let i =
        /** @type {V} */
        r(),
      s =
        /** @type {C} */
        Yo;
    if (/** @type {number} */ (i === 18 ? ((i = /** @type {V} */ 0), (t = 0)) : (s = /** @type {C} */ r()), i !== 0 && i !== 1)) throw new RangeError(`Invalid CID version ${i}`);
    const a = t,
      o =
        /** @type {A} */
        r(),
      u = r(),
      l = t + u,
      p = l - a;
    return { version: i, codec: s, multihashCode: o, digestSize: u, multihashSize: p, size: l };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(e, t) {
    const [r, i] = UB(e, t),
      s = Yt.decode(i);
    if (s.version === 0 && e[0] !== 'Q') throw Error('Version 0 CID string must not include multibase prefix');
    return kh(s).set(r, e), s;
  }
}
const UB = (n, e) => {
    switch (n[0]) {
      case 'Q': {
        const t = e || di;
        return [
          /** @type {Prefix} */
          di.prefix,
          t.decode(`${di.prefix}${n}`),
        ];
      }
      case di.prefix: {
        const t = e || di;
        return [
          /** @type {Prefix} */
          di.prefix,
          t.decode(n),
        ];
      }
      case xu.prefix: {
        const t = e || xu;
        return [
          /** @type {Prefix} */
          xu.prefix,
          t.decode(n),
        ];
      }
      default: {
        if (e == null) throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
        return [
          /** @type {Prefix} */
          n[0],
          e.decode(n),
        ];
      }
    }
  },
  jB = (n, e, t) => {
    const { prefix: r } = t;
    if (r !== di.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`);
    const i = e.get(r);
    if (i == null) {
      const s = t.encode(n).slice(1);
      return e.set(r, s), s;
    } else return i;
  },
  VB = (n, e, t) => {
    const { prefix: r } = t,
      i = e.get(r);
    if (i == null) {
      const s = t.encode(n);
      return e.set(r, s), s;
    } else return i;
  },
  Yo = 112,
  zB = 18,
  dv = (n, e, t) => {
    const r = vd(n),
      i = r + vd(e),
      s = new Uint8Array(i + t.byteLength);
    return gd(n, s, 0), gd(e, s, r), s.set(t, i), s;
  },
  GB = Symbol.for('@ipld/js-cid/CID'),
  HB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        CID: Yt,
        format: Ih,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  );
function Nw(n) {
  return globalThis.Buffer != null ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : n;
}
function Dw(n = 0) {
  return globalThis.Buffer?.allocUnsafe != null ? Nw(globalThis.Buffer.allocUnsafe(n)) : new Uint8Array(n);
}
function KB(n, e) {
  e == null && (e = n.reduce((i, s) => i + s.length, 0));
  const t = Dw(e);
  let r = 0;
  for (const i of n) t.set(i, r), (r += i.length);
  return Nw(t);
}
const qB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        concat: KB,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  WB = sp({
    prefix: '\0',
    name: 'identity',
    encode: (n) => mB(n),
    decode: (n) => yB(n),
  }),
  JB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        identity: WB,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  QB = un({
    prefix: '0',
    name: 'base2',
    alphabet: '01',
    bitsPerChar: 1,
  }),
  YB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base2: QB,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  XB = un({
    prefix: '7',
    name: 'base8',
    alphabet: '01234567',
    bitsPerChar: 3,
  }),
  ZB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base8: XB,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  eN = Rl({
    prefix: '9',
    name: 'base10',
    alphabet: '0123456789',
  }),
  tN = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base10: eN,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  nN = un({
    prefix: 'f',
    name: 'base16',
    alphabet: '0123456789abcdef',
    bitsPerChar: 4,
  }),
  rN = un({
    prefix: 'F',
    name: 'base16upper',
    alphabet: '0123456789ABCDEF',
    bitsPerChar: 4,
  }),
  iN = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base16: nN,
        base16upper: rN,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  sN = Rl({
    prefix: 'k',
    name: 'base36',
    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz',
  }),
  aN = Rl({
    prefix: 'K',
    name: 'base36upper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ',
  }),
  oN = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base36: sN,
        base36upper: aN,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  uN = un({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6,
  }),
  lN = un({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6,
  }),
  cN = un({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6,
  }),
  dN = un({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6,
  }),
  pN = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base64: uN,
        base64pad: lN,
        base64url: cN,
        base64urlpad: dN,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Fw = Array.from(
    '🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂',
  ),
  fN =
    /** @type {string[]} */
    Fw.reduce(
      (n, e, t) => ((n[t] = e), n),
      /** @type {string[]} */
      [],
    ),
  hN =
    /** @type {number[]} */
    Fw.reduce(
      (n, e, t) => (
        (n[
          /** @type {number} */
          e.codePointAt(0)
        ] = t),
        n
      ),
      /** @type {number[]} */
      [],
    );
function yN(n) {
  return n.reduce((e, t) => ((e += fN[t]), e), '');
}
function mN(n) {
  const e = [];
  for (const t of n) {
    const r =
      hN[
        /** @type {number} */
        t.codePointAt(0)
      ];
    if (r === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const bN = sp({
    prefix: '🚀',
    name: 'base256emoji',
    encode: yN,
    decode: mN,
  }),
  gN = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base256emoji: bN,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  );
new TextEncoder();
new TextDecoder();
const pv = { ...JB, ...YB, ...ZB, ...tN, ...iN, ...$B, ...oN, ...PB, ...pN, ...gN };
function Lw(n, e, t, r) {
  return {
    name: n,
    prefix: e,
    encoder: {
      name: n,
      prefix: e,
      encode: t,
    },
    decoder: {
      decode: r,
    },
  };
}
const fv = Lw(
    'utf8',
    'u',
    (n) => 'u' + new TextDecoder('utf8').decode(n),
    (n) => new TextEncoder().encode(n.substring(1)),
  ),
  mf = Lw(
    'ascii',
    'a',
    (n) => {
      let e = 'a';
      for (let t = 0; t < n.length; t++) e += String.fromCharCode(n[t]);
      return e;
    },
    (n) => {
      n = n.substring(1);
      const e = Dw(n.length);
      for (let t = 0; t < n.length; t++) e[t] = n.charCodeAt(t);
      return e;
    },
  ),
  vN = {
    utf8: fv,
    'utf-8': fv,
    hex: pv.base16,
    latin1: mf,
    ascii: mf,
    binary: mf,
    ...pv,
  };
function xN(n, e = 'utf8') {
  const t = vN[e];
  if (t == null) throw new Error(`Unsupported encoding "${e}"`);
  return (e === 'utf8' || e === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null
    ? globalThis.Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString('utf8')
    : t.encoder.encode(n).substring(1);
}
const wN = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      toString: xN,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
export { BO as seed };

function Nn(n) {
  return (typeof n == 'object' && n !== null) || typeof n == 'function';
}
function Oh(n) {
  return n == null;
}
let wu = /* @__PURE__ */ new WeakMap();
const fn = (n, e, t, r, i) => new TypeError(`${n}(${e.map(String).join(',')}) - Expected '${t}' to be of type ${i}, but got: ${Object.prototype.toString.call(r)} (${String(r)})`);
function gs(n) {
  switch (typeof n) {
    case 'undefined':
    case 'string':
    case 'symbol':
      return n;
    default:
      return `${n}`;
  }
}
function $w(n) {
  switch (typeof n) {
    case 'string':
    case 'symbol':
      return n;
    default:
      return `${n}`;
  }
}
function Uw(n) {
  switch (typeof n) {
    case 'undefined':
    case 'string':
    case 'symbol':
      return n;
    default:
      throw new TypeError(`Invalid metadata propertyKey: ${n}.`);
  }
}
function Zu(n, e, t) {
  let r = wu.get(n);
  if (r === void 0) {
    if (!t) return;
    (r = /* @__PURE__ */ new Map()), wu.set(n, r);
  }
  let i = r.get(e);
  if (i === void 0) {
    if (!t) return;
    (i = /* @__PURE__ */ new Map()), r.set(e, i);
  }
  return i;
}
function Bh(n, e, t) {
  const r = Zu(e, t, !1);
  return r === void 0 ? !1 : r.has(n);
}
function hv(n, e, t) {
  if (Bh(n, e, t)) return !0;
  const r = Nh(e);
  return r !== null ? hv(n, r, t) : !1;
}
function yv(n, e, t) {
  const r = Zu(e, t, !1);
  if (r !== void 0) return r.get(n);
}
function mv(n, e, t) {
  if (Bh(n, e, t)) return yv(n, e, t);
  const r = Nh(e);
  if (r !== null) return mv(n, r, t);
}
function bv(n, e, t, r) {
  Zu(t, r, !0).set(n, e);
}
function gv(n, e) {
  const t = [],
    r = Zu(n, e, !1);
  if (r === void 0) return t;
  const i = r.keys();
  let s = 0;
  for (const a of i) (t[s] = a), ++s;
  return t;
}
function vv(n, e) {
  const t = gv(n, e),
    r = Nh(n);
  if (r === null) return t;
  const i = vv(r, e),
    s = t.length;
  if (s === 0) return i;
  const a = i.length;
  if (a === 0) return t;
  const o = /* @__PURE__ */ new Set(),
    u = [];
  let l = 0,
    p;
  for (let h = 0; h < s; ++h) (p = t[h]), o.has(p) || (o.add(p), (u[l] = p), ++l);
  for (let h = 0; h < a; ++h) (p = i[h]), o.has(p) || (o.add(p), (u[l] = p), ++l);
  return u;
}
function jw(n, e, t) {
  const r = Zu(n, t, !1);
  return r === void 0 ? !1 : r.delete(e);
}
function Vw(n, e) {
  function t(r, i) {
    if (!Nn(r)) throw fn('@metadata', [n, e, r, i], 'target', r, 'Object or Function');
    bv(n, e, r, Uw(i));
  }
  return t;
}
function zw(n, e, t, r) {
  if (t !== void 0) {
    if (!Array.isArray(n)) throw fn('Metadata.decorate', [n, e, t, r], 'decorators', n, 'Array');
    if (!Nn(e)) throw fn('Metadata.decorate', [n, e, t, r], 'target', e, 'Object or Function');
    if (!Nn(r) && !Oh(r)) throw fn('Metadata.decorate', [n, e, t, r], 'attributes', r, 'Object, Function, null, or undefined');
    return r === null && (r = void 0), (t = $w(t)), Hw(n, e, t, r);
  } else {
    if (!Array.isArray(n)) throw fn('Metadata.decorate', [n, e, t, r], 'decorators', n, 'Array');
    if (typeof e != 'function') throw fn('Metadata.decorate', [n, e, t, r], 'target', e, 'Function');
    return Gw(n, e);
  }
}
function Gw(n, e) {
  for (let t = n.length - 1; t >= 0; --t) {
    const r = n[t],
      i = r(e);
    if (!Oh(i)) {
      if (typeof i != 'function') throw fn('DecorateConstructor', [n, e], 'decorated', i, 'Function, null, or undefined');
      e = i;
    }
  }
  return e;
}
function Hw(n, e, t, r) {
  for (let i = n.length - 1; i >= 0; --i) {
    const s = n[i],
      a = s(e, t, r);
    if (!Oh(a)) {
      if (!Nn(a)) throw fn('DecorateProperty', [n, e, t, r], 'decorated', a, 'Object, Function, null, or undefined');
      r = a;
    }
  }
  return r;
}
function xv(n, e, t, r) {
  if (!Nn(t)) throw fn('Metadata.define', [n, e, t, r], 'target', t, 'Object or Function');
  return bv(n, e, t, gs(r));
}
function wv(n, e, t) {
  if (!Nn(e)) throw fn('Metadata.has', [n, e, t], 'target', e, 'Object or Function');
  return hv(n, e, gs(t));
}
function Tv(n, e, t) {
  if (!Nn(e)) throw fn('Metadata.hasOwn', [n, e, t], 'target', e, 'Object or Function');
  return Bh(n, e, gs(t));
}
function Av(n, e, t) {
  if (!Nn(e)) throw fn('Metadata.get', [n, e, t], 'target', e, 'Object or Function');
  return mv(n, e, gs(t));
}
function Ev(n, e, t) {
  if (!Nn(e)) throw fn('Metadata.getOwn', [n, e, t], 'target', e, 'Object or Function');
  return yv(n, e, gs(t));
}
function Cv(n, e) {
  if (!Nn(n)) throw fn('Metadata.getKeys', [n, e], 'target', n, 'Object or Function');
  return vv(n, gs(e));
}
function Sv(n, e) {
  if (!Nn(n)) throw fn('Metadata.getOwnKeys', [n, e], 'target', n, 'Object or Function');
  return gv(n, gs(e));
}
function Mv(n, e, t) {
  if (!Nn(e)) throw fn('Metadata.delete', [n, e, t], 'target', e, 'Object or Function');
  return jw(e, n, gs(t));
}
const ti = {
    define: xv,
    has: wv,
    hasOwn: Tv,
    get: Av,
    getOwn: Ev,
    getKeys: Cv,
    getOwnKeys: Sv,
    delete: Mv,
  },
  Kw = (n, e, t, r, i) => {
    if (
      !Reflect.defineProperty(n, e, {
        writable: r,
        enumerable: !1,
        configurable: i,
        value: t,
      })
    )
      throw bf(`AUR1000:${e}`);
  },
  eu = '[[$au]]',
  qw = (n) => eu in n,
  B0 = (n, e, t) =>
    [
      [eu, wu],
      ['metadata', Vw],
      ['decorate', zw],
      ['defineMetadata', xv],
      ['hasMetadata', wv],
      ['hasOwnMetadata', Tv],
      ['getMetadata', Av],
      ['getOwnMetadata', Ev],
      ['getMetadataKeys', Cv],
      ['getOwnMetadataKeys', Sv],
      ['deleteMetadata', Mv],
    ].forEach(([r, i]) => Kw(n, r, i, e, t)),
  Ww = (n, e = !0, t = !1, r = !0, i = !0) => {
    if (qw(n)) {
      if (n[eu] === wu) return;
      if (n[eu] instanceof WeakMap) {
        wu = n[eu];
        return;
      }
      throw bf('AUR1001');
    }
    const s = 'metadata decorate defineMetadata hasMetadata hasOwnMetadata getMetadata getOwnMetadata getMetadataKeys getOwnMetadataKeys deleteMetadata'.split(' ').filter((a) => a in Reflect);
    if (s.length > 0)
      if (e) {
        const a = s.map(function (o) {
          const u = `${Reflect[o].toString().slice(0, 100)}...`;
          return `${o}:
${u}`;
        }).join(`

`);
        throw bf(`AUR1002:${a}`);
      } else t && B0(n, r, i);
    else B0(n, r, i);
  },
  bf = (n) => new Error(n),
  Nh = Object.getPrototypeOf,
  bo = String,
  Dn = ti.getOwn,
  Jw = ti.hasOwn,
  ds = ti.define,
  ta = (n) => typeof n == 'function',
  xc = (n) => typeof n == 'string',
  bi = () => /* @__PURE__ */ Object.create(null),
  Jt = (n) => new Error(n),
  Pl = {},
  Tu = (n) => {
    switch (typeof n) {
      case 'number':
        return n >= 0 && (n | 0) === n;
      case 'string': {
        const e = Pl[n];
        if (e !== void 0) return e;
        const t = n.length;
        if (t === 0) return (Pl[n] = !1);
        let r = 0,
          i = 0;
        for (; i < t; ++i) if (((r = ln(n, i)), (i === 0 && r === 48 && t > 1) || r < 48 || r > 57)) return (Pl[n] = !1);
        return (Pl[n] = !0);
      }
      default:
        return !1;
    }
  },
  _v = /* @__PURE__ */ (function () {
    const n = Object.assign(bi(), {
        0: !0,
        1: !0,
        2: !0,
        3: !0,
        4: !0,
        5: !0,
        6: !0,
        7: !0,
        8: !0,
        9: !0,
      }),
      e = (t) => (t === '' ? 0 : t !== t.toUpperCase() ? 3 : t !== t.toLowerCase() ? 2 : n[t] === !0 ? 1 : 0);
    return (t, r) => {
      const i = t.length;
      if (i === 0) return t;
      let s = !1,
        a = '',
        o,
        u = '',
        l = 0,
        p = t.charAt(0),
        h = e(p),
        b = 0;
      for (; b < i; ++b)
        (o = l), (u = p), (l = h), (p = t.charAt(b + 1)), (h = e(p)), l === 0 ? a.length > 0 && (s = !0) : (!s && a.length > 0 && l === 2 && (s = o === 3 || h === 3), (a += r(u, s)), (s = !1));
      return a;
    };
  })(),
  Wn = /* @__PURE__ */ (function () {
    const n = bi(),
      e = (t, r) => (r ? t.toUpperCase() : t.toLowerCase());
    return (t) => {
      let r = n[t];
      return r === void 0 && (r = n[t] = _v(t, e)), r;
    };
  })(),
  Qw = /* @__PURE__ */ (function () {
    const n = bi();
    return (e) => {
      let t = n[e];
      return t === void 0 && ((t = Wn(e)), t.length > 0 && (t = t[0].toUpperCase() + t.slice(1)), (n[e] = t)), t;
    };
  })(),
  Rv = /* @__PURE__ */ (function () {
    const n = bi(),
      e = (t, r) => (r ? `-${t.toLowerCase()}` : t.toLowerCase());
    return (t) => {
      let r = n[t];
      return r === void 0 && (r = n[t] = _v(t, e)), r;
    };
  })(),
  xp = (n) => {
    const e = n.length,
      t = Array(e);
    let r = 0;
    for (; r < e; ++r) t[r] = n[r];
    return t;
  },
  go = (n, e, t) => ({
    configurable: !0,
    enumerable: t.enumerable,
    get() {
      const r = t.value.bind(this);
      return (
        Reflect.defineProperty(this, e, {
          value: r,
          writable: !0,
          configurable: !0,
          enumerable: t.enumerable,
        }),
        r
      );
    },
  }),
  Ft = (...n) => {
    const e = [];
    let t = 0;
    const r = n.length;
    let i = 0,
      s,
      a = 0;
    for (; a < r; ++a)
      if (((s = n[a]), s !== void 0)) {
        i = s.length;
        let o = 0;
        for (; o < i; ++o) e[t++] = s[o];
      }
    return e;
  },
  kn = (...n) => {
    const e = n.length;
    let t,
      r = 0;
    for (; e > r; ++r) if (((t = n[r]), t !== void 0)) return t;
    throw Jt('No default value found');
  },
  Yw = /* @__PURE__ */ (function () {
    const n = Function.prototype,
      e = Object.getPrototypeOf,
      t = /* @__PURE__ */ new WeakMap();
    let r = n,
      i = 0,
      s;
    return function (a) {
      if (((s = t.get(a)), s === void 0)) for (t.set(a, (s = [(r = a)])), i = 0; (r = e(r)) !== n; ) s[++i] = r;
      return s;
    };
  })();
function Au(...n) {
  return Object.assign(bi(), ...n);
}
const N0 = /* @__PURE__ */ (function () {
    const n = /* @__PURE__ */ new WeakMap();
    let e = !1,
      t = '',
      r = 0;
    return (i) => (
      (e = n.get(i)),
      e === void 0 &&
        ((t = i.toString()),
        (r = t.length),
        (e =
          r >= 29 &&
          r <= 100 &&
          ln(t, r - 1) === 125 &&
          ln(t, r - 2) <= 32 &&
          ln(t, r - 3) === 93 &&
          ln(t, r - 4) === 101 &&
          ln(t, r - 5) === 100 &&
          ln(t, r - 6) === 111 &&
          ln(t, r - 7) === 99 &&
          ln(t, r - 8) === 32 &&
          ln(t, r - 9) === 101 &&
          ln(t, r - 10) === 118 &&
          ln(t, r - 11) === 105 &&
          ln(t, r - 12) === 116 &&
          ln(t, r - 13) === 97 &&
          ln(t, r - 14) === 110 &&
          ln(t, r - 15) === 88),
        n.set(i, e)),
      e
    );
  })(),
  Ce = (n, e) => (n instanceof Promise ? n.then(e) : e(n)),
  Kt = (...n) => {
    let e,
      t,
      r,
      i = 0,
      s = n.length;
    for (; i < s; ++i) (e = n[i]), (e = n[i]) instanceof Promise && (t === void 0 ? (t = e) : r === void 0 ? (r = [t, e]) : r.push(e));
    return r === void 0 ? t : Promise.all(r);
  },
  ln = (n, e) => n.charCodeAt(e),
  Qs = 'au:annotation',
  gi = (n, e) => (e === void 0 ? `${Qs}:${n}` : `${Qs}:${n}:${e}`),
  Dh = (n, e) => {
    const t = Dn(Qs, n);
    t === void 0 ? ds(Qs, [e], n) : t.push(e);
  },
  Xw = Object.freeze({
    name: 'au:annotation',
    appendTo: Dh,
    set(n, e, t) {
      ds(gi(e), t, n);
    },
    get: (n, e) => Dn(gi(e), n),
    getKeys(n) {
      let e = Dn(Qs, n);
      return e === void 0 && ds(Qs, (e = []), n), e;
    },
    isKey: (n) => n.startsWith(Qs),
    keyFor: gi,
  }),
  Br = 'au:resource',
  gf = (n) => Jw(Br, n),
  vf = (n) => {
    const e = Dn(Br, n);
    return e === void 0 ? Fe : e.map((t) => Dn(t, n));
  },
  Zw = Object.freeze({
    name: Br,
    appendTo(n, e) {
      const t = Dn(Br, n);
      t === void 0 ? ds(Br, [e], n) : t.push(e);
    },
    has: gf,
    getAll: vf,
    getKeys(n) {
      let e = Dn(Br, n);
      return e === void 0 && ds(Br, (e = []), n), e;
    },
    isKey: (n) => n.startsWith(Br),
    keyFor(n, e) {
      return e === void 0 ? `${Br}:${n}` : `${Br}:${n}:${e}`;
    },
  }),
  vo = {
    annotation: Xw,
    resource: Zw,
  },
  Pv = Object.prototype.hasOwnProperty;
function hr(n, e, t, r) {
  let i = Dn(gi(n), t);
  return i === void 0 ? ((i = e[n]), i === void 0 ? ((i = t[n]), i === void 0 || !Pv.call(t, n) ? r() : i) : i) : i;
}
function Yn(n, e, t) {
  let r = Dn(gi(n), e);
  return r === void 0 ? ((r = e[n]), r === void 0 || !Pv.call(e, n) ? t() : r) : r;
}
function _n(n, e, t) {
  const r = e[n];
  return r === void 0 ? t() : r;
}
const eT = new Set(
  'Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise RangeError ReferenceError RegExp Set SharedArrayBuffer String SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet'.split(
    ' ',
  ),
);
let tT = 0;
class tu {
  get depth() {
    return this.parent === null ? 0 : this.parent.depth + 1;
  }
  constructor(e, t) {
    (this.parent = e),
      (this.config = t),
      (this.id = ++tT),
      (this.t = 0),
      (this.i = /* @__PURE__ */ new Map()),
      e === null
        ? ((this.root = this), (this.u = /* @__PURE__ */ new Map()), (this.h = /* @__PURE__ */ new Map()), (this.res = bi()))
        : ((this.root = e.root), (this.u = /* @__PURE__ */ new Map()), (this.h = e.h), t.inheritParentResources ? (this.res = Object.assign(bi(), e.res, this.root.res)) : (this.res = bi())),
      this.u.set(xo, nT);
  }
  register(...e) {
    if (++this.t === 100) throw aT(e);
    let t,
      r,
      i,
      s,
      a,
      o = 0,
      u = e.length;
    for (; o < u; ++o)
      if (((t = e[o]), !!Nn(t)))
        if (Zl(t)) t.register(this);
        else if (gf(t)) {
          const l = vf(t);
          if (l.length === 1) l[0].register(this);
          else for (s = 0, a = l.length; a > s; ) l[s].register(this), ++s;
        } else if (iT(t)) fe.singleton(t, t).register(this);
        else for (r = Object.keys(t), s = 0, a = r.length; s < a; ++s) (i = t[r[s]]), Nn(i) && (Zl(i) ? i.register(this) : this.register(i));
    return --this.t, this;
  }
  registerResolver(e, t, r = !1) {
    Il(e);
    const i = this.u,
      s = i.get(e);
    if (s == null) {
      if ((i.set(e, t), sT(e))) {
        if (this.res[e] !== void 0) throw oT(e);
        this.res[e] = t;
      }
    } else s instanceof or && s.R === 4 ? s._state.push(t) : i.set(e, new or(e, 4, [s, t]));
    return r && this.i.set(e, t), t;
  }
  registerTransformer(e, t) {
    const r = this.getResolver(e);
    if (r == null) return !1;
    if (r.getFactory) {
      const i = r.getFactory(this);
      return i == null ? !1 : (i.registerTransformer(t), !0);
    }
    return !1;
  }
  getResolver(e, t = !0) {
    if ((Il(e), e.resolve !== void 0)) return e;
    let r = this,
      i,
      s;
    for (; r != null; )
      if (((i = r.u.get(e)), i == null)) {
        if (r.parent == null) return (s = F0(e) ? this : r), t ? this.$(e, s) : null;
        r = r.parent;
      } else return i;
    return null;
  }
  has(e, t = !1) {
    return this.u.has(e) ? !0 : t && this.parent != null ? this.parent.has(e, !0) : !1;
  }
  get(e) {
    if ((Il(e), e.$isResolver)) return e.resolve(this, this);
    let t = this,
      r,
      i;
    for (; t != null; )
      if (((r = t.u.get(e)), r == null)) {
        if (t.parent == null) return (i = F0(e) ? this : t), (r = this.$(e, i)), r.resolve(t, this);
        t = t.parent;
      } else return r.resolve(t, this);
    throw uT(e);
  }
  getAll(e, t = !1) {
    Il(e);
    const r = this;
    let i = r,
      s;
    if (t) {
      let a = Fe;
      for (; i != null; ) (s = i.u.get(e)), s != null && (a = a.concat(D0(s, i, r))), (i = i.parent);
      return a;
    } else
      for (; i != null; )
        if (((s = i.u.get(e)), s == null)) {
          if (((i = i.parent), i == null)) return Fe;
        } else return D0(s, i, r);
    return Fe;
  }
  invoke(e, t) {
    if (N0(e)) throw $0(e);
    return t === void 0 ? new e(...nu(e).map(wc, this)) : new e(...nu(e).map(wc, this), ...t);
  }
  getFactory(e) {
    let t = this.h.get(e);
    if (t === void 0) {
      if (N0(e)) throw $0(e);
      this.h.set(e, (t = new IT(e, nu(e))));
    }
    return t;
  }
  registerFactory(e, t) {
    this.h.set(e, t);
  }
  createChild(e) {
    return e === void 0 && this.config.inheritParentResources
      ? this.config === Vr.DEFAULT
        ? new tu(this, this.config)
        : new tu(
            this,
            Vr.from({
              ...this.config,
              inheritParentResources: !1,
            }),
          )
      : new tu(this, Vr.from(e ?? this.config));
  }
  disposeResolvers() {
    const e = this.u,
      t = this.i;
    let r, i;
    for ([i, r] of t.entries()) r.dispose(), e.delete(i);
    t.clear();
  }
  find(e, t) {
    const r = e.keyFrom(t);
    let i = this.res[r];
    if ((i === void 0 && ((i = this.root.res[r]), i === void 0)) || i === null) return null;
    if (ta(i.getFactory)) {
      const s = i.getFactory(this);
      if (s == null) return null;
      const a = Dn(e.name, s.Type);
      return a === void 0 ? null : a;
    }
    return null;
  }
  create(e, t) {
    const r = e.keyFrom(t);
    let i = this.res[r];
    return i === void 0 ? ((i = this.root.res[r]), i === void 0 ? null : i.resolve(this.root, this) ?? null) : i.resolve(this, this) ?? null;
  }
  dispose() {
    this.i.size > 0 && this.disposeResolvers(), this.u.clear();
  }
  $(e, t) {
    if (!ta(e)) throw lT(e);
    if (eT.has(e.name)) throw cT(e);
    if (Zl(e)) {
      const r = e.register(t, e);
      if (!(r instanceof Object) || r.resolve == null) {
        const i = t.u.get(e);
        if (i != null) return i;
        throw L0();
      }
      return r;
    } else if (gf(e)) {
      const r = vf(e);
      if (r.length === 1) r[0].register(t);
      else {
        const s = r.length;
        for (let a = 0; a < s; ++a) r[a].register(t);
      }
      const i = t.u.get(e);
      if (i != null) return i;
      throw L0();
    } else {
      if (e.$isInterface) throw dT(e.friendlyName);
      {
        const r = this.config.defaultResolver(e, t);
        return t.u.set(e, r), r;
      }
    }
  }
}
function Il(n) {
  if (n == null) throw Jt('AUR0014');
}
const D0 = (n, e, t) => {
    if (n instanceof or && n.R === 4) {
      const r = n._state;
      let i = r.length;
      const s = new Array(i);
      for (; i--; ) s[i] = r[i].resolve(e, t);
      return s;
    }
    return [n.resolve(e, t)];
  },
  nT = {
    $isResolver: !0,
    resolve(n, e) {
      return e;
    },
  },
  Zl = (n) => ta(n.register),
  rT = (n) => Zl(n) && typeof n.registerInRequestor == 'boolean',
  F0 = (n) => rT(n) && n.registerInRequestor,
  iT = (n) => n.prototype !== void 0,
  sT = (n) => xc(n) && n.indexOf(':') > 0,
  aT = (n) => Jt(`AUR0006:${n.map(bo)}`),
  oT = (n) => Jt(`AUR0007:${bo(n)}`),
  uT = (n) => Jt(`AUR0008:${bo(n)}`),
  lT = (n) => Jt(`AUR0009:${bo(n)}`),
  cT = (n) => Jt(`AUR0010:${n.name}`),
  L0 = () => Jt('AUR0011'),
  dT = (n) => Jt(`AUR0012:${n}`),
  $0 = (n) => Jt(`AUR0015:${n.name}`),
  Iv = (n, e) => new or(n, 0, e),
  Fh = (n, e) => new or(n, 1, e),
  pT = (n, e) => new or(n, 2, e),
  fT = (n, e) => new or(n, 3, e),
  hT = (n, e) => new or(n, 3, kv(e)),
  yT = (n, e) => new or(e, 5, n),
  mT = (n, ...e) => new kT(n, e),
  U0 = /* @__PURE__ */ new WeakMap(),
  kv = (n) => (e, t, r) => {
    let i = U0.get(e);
    if ((i === void 0 && U0.set(e, (i = /* @__PURE__ */ new WeakMap())), i.has(r))) return i.get(r);
    const s = n(e, t, r);
    return i.set(r, s), s;
  };
Ww(Reflect, !1, !1);
class bT {
  constructor(e, t) {
    (this.c = e), (this.k = t);
  }
  instance(e) {
    return this.C(0, e);
  }
  singleton(e) {
    return this.C(1, e);
  }
  transient(e) {
    return this.C(2, e);
  }
  callback(e) {
    return this.C(3, e);
  }
  cachedCallback(e) {
    return this.C(3, kv(e));
  }
  aliasTo(e) {
    return this.C(5, e);
  }
  C(e, t) {
    const { c: r, k: i } = this;
    return (this.c = this.k = void 0), r.registerResolver(i, new or(i, e, t));
  }
}
const Lo = (n) => {
    const e = n.slice(),
      t = Object.keys(n),
      r = t.length;
    let i;
    for (let s = 0; s < r; ++s) (i = t[s]), Tu(i) || (e[i] = n[i]);
    return e;
  },
  gT = {
    none(n) {
      throw vT(n);
    },
    singleton: (n) => new or(n, 1, n),
    transient: (n) => new or(n, 2, n),
  },
  vT = (n) => Jt(`AUR0002:${bo(n)}`);
class Vr {
  constructor(e, t) {
    (this.inheritParentResources = e), (this.defaultResolver = t);
  }
  static from(e) {
    return e === void 0 || e === Vr.DEFAULT ? Vr.DEFAULT : new Vr(e.inheritParentResources ?? !1, e.defaultResolver ?? gT.singleton);
  }
}
Vr.DEFAULT = Vr.from({});
const xT = (n) => new tu(null, Vr.from(n)),
  Ov = (n) => {
    const e = gi('di:paramtypes');
    return Dn(e, n);
  },
  wT = (n) => Dn('design:paramtypes', n),
  Da = (n) => {
    const e = gi('di:paramtypes');
    let t = Dn(e, n);
    return t === void 0 && (ds(e, (t = []), n), Dh(n, e)), t;
  },
  nu = (n) => {
    const e = gi('di:dependencies');
    let t = Dn(e, n);
    if (t === void 0) {
      const r = n.inject;
      if (r === void 0) {
        const i = he.getDesignParamtypes(n),
          s = Ov(n);
        if (i === void 0)
          if (s === void 0) {
            const a = Object.getPrototypeOf(n);
            ta(a) && a !== Function.prototype ? (t = Lo(nu(a))) : (t = []);
          } else t = Lo(s);
        else if (s === void 0) t = Lo(i);
        else {
          t = Lo(i);
          let a = s.length,
            o,
            u = 0;
          for (; u < a; ++u) (o = s[u]), o !== void 0 && (t[u] = o);
          const l = Object.keys(s);
          let p;
          for (u = 0, a = l.length, u = 0; u < a; ++u) (p = l[u]), Tu(p) || (t[p] = s[p]);
        }
      } else t = Lo(r);
      ds(e, t, n), Dh(n, e);
    }
    return t;
  },
  ki = (n, e) => {
    const t = ta(n) ? n : e,
      r = (xc(n) ? n : void 0) ?? '(anonymous)',
      i = function (s, a, o) {
        if (s == null || new.target !== void 0) throw TT(r);
        const u = Da(s);
        u[o] = i;
      };
    return (i.$isInterface = !0), (i.friendlyName = r), t != null && (i.register = (s, a) => t(new bT(s, a ?? i))), (i.toString = () => `InterfaceSymbol<${r}>`), i;
  },
  TT = (n) => Jt(`AUR0001:${n}`),
  he = {
    createContainer: xT,
    getDesignParamtypes: wT,
    getAnnotationParamtypes: Ov,
    getOrCreateAnnotationParamTypes: Da,
    getDependencies: nu,
    createInterface: ki,
    inject(...n) {
      return (e, t, r) => {
        if (typeof r == 'number') {
          const i = Da(e),
            s = n[0];
          s !== void 0 && (i[r] = s);
        } else if (t) {
          const i = Da(e.constructor),
            s = n[0];
          s !== void 0 && (i[t] = s);
        } else if (r) {
          const i = r.value,
            s = Da(i);
          let a,
            o = 0;
          for (; o < n.length; ++o) (a = n[o]), a !== void 0 && (s[o] = a);
        } else {
          const i = Da(e);
          let s,
            a = 0;
          for (; a < n.length; ++a) (s = n[a]), s !== void 0 && (i[a] = s);
        }
      };
    },
    transient(n) {
      return (
        (n.register = function (e) {
          return fe.transient(n, n).register(e, n);
        }),
        (n.registerInRequestor = !1),
        n
      );
    },
    singleton(n, e = CT) {
      return (
        (n.register = function (t) {
          return fe.singleton(n, n).register(t, n);
        }),
        (n.registerInRequestor = e.scoped),
        n
      );
    },
  },
  xo = /* @__PURE__ */ ki('IContainer'),
  AT = xo;
function ET(n) {
  return function (e) {
    const t = function (r, i, s) {
      Lh(t)(r, i, s);
    };
    return (
      (t.$isResolver = !0),
      (t.resolve = function (r, i) {
        return n(e, r, i);
      }),
      t
    );
  };
}
const Lh = he.inject;
function j0(n) {
  return he.transient(n);
}
function Bv(n) {
  return n == null ? j0 : j0(n);
}
const CT = {
    scoped: !1,
  },
  ST = (n) => (e, t) => {
    t = !!t;
    const r = function (i, s, a) {
      Lh(r)(i, s, a);
    };
    return (
      (r.$isResolver = !0),
      (r.resolve = function (i, s) {
        return n(e, i, s, t);
      }),
      r
    );
  },
  Nv = /* @__PURE__ */ ST((n, e, t, r) => t.getAll(n, r)),
  Dv = /* @__PURE__ */ ET((n, e, t) => {
    if (t.has(n, !0)) return t.get(n);
  }),
  xd = (n, e, t) => {
    Lh(xd)(n, e, t);
  };
xd.$isResolver = !0;
xd.resolve = () => {};
let or = class {
  constructor(e, t, r) {
    (this.k = e), (this.R = t), (this._state = r), (this.resolving = !1);
  }
  get $isResolver() {
    return !0;
  }
  register(e, t) {
    return e.registerResolver(t || this.k, this);
  }
  resolve(e, t) {
    switch (this.R) {
      case 0:
        return this._state;
      case 1: {
        if (this.resolving) throw MT(this._state.name);
        return (this.resolving = !0), (this._state = e.getFactory(this._state).construct(t)), (this.R = 0), (this.resolving = !1), this._state;
      }
      case 2: {
        const r = e.getFactory(this._state);
        if (r === null) throw _T(this.k);
        return r.construct(t);
      }
      case 3:
        return this._state(e, t, this);
      case 4:
        return this._state[0].resolve(e, t);
      case 5:
        return t.get(this._state);
      default:
        throw RT(this.R);
    }
  }
  getFactory(e) {
    switch (this.R) {
      case 1:
      case 2:
        return e.getFactory(this._state);
      case 5:
        return e.getResolver(this._state)?.getFactory?.(e) ?? null;
      default:
        return null;
    }
  }
};
const MT = (n) => Jt(`AUR0003:${n}`),
  _T = (n) => Jt(`AUR0004:${bo(n)}`),
  RT = (n) => Jt(`AUR0005:${n}`);
function wc(n) {
  return this.get(n);
}
function PT(n, e) {
  return e(n);
}
class IT {
  constructor(e, t) {
    (this.Type = e), (this.dependencies = t), (this.transformers = null);
  }
  construct(e, t) {
    let r;
    return (
      t === void 0 ? (r = new this.Type(...this.dependencies.map(wc, e))) : (r = new this.Type(...this.dependencies.map(wc, e), ...t)), this.transformers == null ? r : this.transformers.reduce(PT, r)
    );
  }
  registerTransformer(e) {
    (this.transformers ?? (this.transformers = [])).push(e);
  }
}
class kT {
  constructor(e, t) {
    (this.key = e), (this.params = t);
  }
  register(e) {
    e.has(this.key, !0) ? e.get(this.key).register(e, ...this.params) : e.register(...this.params.filter((t) => typeof t == 'object'));
  }
}
const fe = {
  instance: Iv,
  singleton: Fh,
  transient: pT,
  callback: fT,
  cachedCallback: hT,
  aliasTo: yT,
  defer: mT,
};
class nn {
  get friendlyName() {
    return this.A;
  }
  constructor(e, t) {
    (this._ = null), (this.A = e), t !== void 0 && (this._ = t);
  }
  prepare(e) {
    this._ = e;
  }
  get $isResolver() {
    return !0;
  }
  resolve() {
    if (this._ == null) throw OT(this.A);
    return this._;
  }
  dispose() {
    this._ = null;
  }
}
const OT = (n) => Jt(`AUR0013:${n}`),
  Fe = Object.freeze([]),
  BT = Object.freeze({});
function vi() {}
const el = /* @__PURE__ */ ki('IPlatform');
function Oi(n, e, t, r) {
  var i = arguments.length,
    s = i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, t)) : r,
    a;
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') s = Reflect.decorate(n, e, t, r);
  else for (var o = n.length - 1; o >= 0; o--) (a = n[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function qs(n, e) {
  return function (t, r) {
    e(t, r, n);
  };
}
var V0;
(function (n) {
  (n[(n.trace = 0)] = 'trace'),
    (n[(n.debug = 1)] = 'debug'),
    (n[(n.info = 2)] = 'info'),
    (n[(n.warn = 3)] = 'warn'),
    (n[(n.error = 4)] = 'error'),
    (n[(n.fatal = 5)] = 'fatal'),
    (n[(n.none = 6)] = 'none');
})(V0 || (V0 = {}));
var z0;
(function (n) {
  (n[(n.noColors = 0)] = 'noColors'), (n[(n.colors = 1)] = 'colors');
})(z0 || (z0 = {}));
const $h = /* @__PURE__ */ ki('ILogConfig', (n) => n.instance(new Fv(0, 3))),
  Uh = /* @__PURE__ */ ki('ISink'),
  NT = /* @__PURE__ */ ki('ILogEventFactory', (n) => n.singleton(xf)),
  ba = /* @__PURE__ */ ki('ILogger', (n) => n.singleton(Ai)),
  DT = /* @__PURE__ */ ki('ILogScope'),
  FT = Object.freeze({
    key: gi('logger-sink-handles'),
    define(n, e) {
      return ds(this.key, e.handles, n.prototype), n;
    },
    getHandles(n) {
      return ti.get(this.key, n);
    },
  }),
  ai = Au({
    red(n) {
      return `\x1B[31m${n}\x1B[39m`;
    },
    green(n) {
      return `\x1B[32m${n}\x1B[39m`;
    },
    yellow(n) {
      return `\x1B[33m${n}\x1B[39m`;
    },
    blue(n) {
      return `\x1B[34m${n}\x1B[39m`;
    },
    magenta(n) {
      return `\x1B[35m${n}\x1B[39m`;
    },
    cyan(n) {
      return `\x1B[36m${n}\x1B[39m`;
    },
    white(n) {
      return `\x1B[37m${n}\x1B[39m`;
    },
    grey(n) {
      return `\x1B[90m${n}\x1B[39m`;
    },
  });
class Fv {
  constructor(e, t) {
    (this.colorOptions = e), (this.level = t);
  }
}
const G0 = (function () {
    const n = [
      Au({
        TRC: 'TRC',
        DBG: 'DBG',
        INF: 'INF',
        WRN: 'WRN',
        ERR: 'ERR',
        FTL: 'FTL',
        QQQ: '???',
      }),
      Au({
        TRC: ai.grey('TRC'),
        DBG: ai.grey('DBG'),
        INF: ai.white('INF'),
        WRN: ai.yellow('WRN'),
        ERR: ai.red('ERR'),
        FTL: ai.red('FTL'),
        QQQ: ai.grey('???'),
      }),
    ];
    return (e, t) => (e <= 0 ? n[t].TRC : e <= 1 ? n[t].DBG : e <= 2 ? n[t].INF : e <= 3 ? n[t].WRN : e <= 4 ? n[t].ERR : e <= 5 ? n[t].FTL : n[t].QQQ);
  })(),
  LT = (n, e) => (e === 0 ? n.join('.') : n.map(ai.cyan).join('.')),
  H0 = (n, e) => (e === 0 ? new Date(n).toISOString() : ai.grey(new Date(n).toISOString()));
class $T {
  constructor(e, t, r, i, s, a) {
    (this.severity = e), (this.message = t), (this.optionalParams = r), (this.scope = i), (this.colorOptions = s), (this.timestamp = a);
  }
  toString() {
    const { severity: e, message: t, scope: r, colorOptions: i, timestamp: s } = this;
    return r.length === 0 ? `${H0(s, i)} [${G0(e, i)}] ${t}` : `${H0(s, i)} [${G0(e, i)} ${LT(r, i)}] ${t}`;
  }
}
let xf = class {
  constructor(e) {
    this.config = e;
  }
  createLogEvent(e, t, r, i) {
    return new $T(t, r, i, e.scope, this.config.colorOptions, Date.now());
  }
};
xf = Oi([qs(0, $h)], xf);
let K0 = class Lv {
  static register(e) {
    Fh(Uh, Lv).register(e);
  }
  constructor(e) {
    const t = e.console;
    this.handleEvent = function (i) {
      const s = i.optionalParams;
      if (s === void 0 || s.length === 0) {
        const a = i.toString();
        switch (i.severity) {
          case 0:
          case 1:
            return t.debug(a);
          case 2:
            return t.info(a);
          case 3:
            return t.warn(a);
          case 4:
          case 5:
            return t.error(a);
        }
      } else {
        let a = i.toString(),
          o = 0;
        for (; a.includes('%s'); ) a = a.replace('%s', String(s[o++]));
        switch (i.severity) {
          case 0:
          case 1:
            return t.debug(a, ...s.slice(o));
          case 2:
            return t.info(a, ...s.slice(o));
          case 3:
            return t.warn(a, ...s.slice(o));
          case 4:
          case 5:
            return t.error(a, ...s.slice(o));
        }
      }
    };
  }
};
K0 = Oi([qs(0, el)], K0);
let Ai = class $v {
  constructor(e, t, r, i = [], s = null) {
    (this.scope = i), (this.O = bi());
    let a, o, u, l, p, h;
    if (((this.config = e), (this.f = t), (this.sinks = r), s === null)) {
      (this.root = this), (this.parent = this), (a = this.I = []), (o = this.j = []), (u = this.L = []), (l = this.M = []), (p = this.T = []), (h = this.F = []);
      for (const b of r) {
        const E = FT.getHandles(b);
        (E?.includes(0) ?? !0) && a.push(b),
          (E?.includes(1) ?? !0) && o.push(b),
          (E?.includes(2) ?? !0) && u.push(b),
          (E?.includes(3) ?? !0) && l.push(b),
          (E?.includes(4) ?? !0) && p.push(b),
          (E?.includes(5) ?? !0) && h.push(b);
      }
    } else (this.root = s.root), (this.parent = s), (a = this.I = s.I), (o = this.j = s.j), (u = this.L = s.L), (l = this.M = s.M), (p = this.T = s.T), (h = this.F = s.F);
  }
  trace(e, ...t) {
    this.config.level <= 0 && this.U(this.I, 0, e, t);
  }
  debug(e, ...t) {
    this.config.level <= 1 && this.U(this.j, 1, e, t);
  }
  info(e, ...t) {
    this.config.level <= 2 && this.U(this.L, 2, e, t);
  }
  warn(e, ...t) {
    this.config.level <= 3 && this.U(this.M, 3, e, t);
  }
  error(e, ...t) {
    this.config.level <= 4 && this.U(this.T, 4, e, t);
  }
  fatal(e, ...t) {
    this.config.level <= 5 && this.U(this.F, 5, e, t);
  }
  scopeTo(e) {
    const t = this.O;
    let r = t[e];
    return r === void 0 && (r = t[e] = new $v(this.config, this.f, void 0, this.scope.concat(e), this)), r;
  }
  U(e, t, r, i) {
    const s = ta(r) ? r() : r,
      a = this.f.createLogEvent(this, t, s, i);
    for (let o = 0, u = e.length; o < u; ++o) e[o].handleEvent(a);
  }
};
Oi([go], Ai.prototype, 'trace', null);
Oi([go], Ai.prototype, 'debug', null);
Oi([go], Ai.prototype, 'info', null);
Oi([go], Ai.prototype, 'warn', null);
Oi([go], Ai.prototype, 'error', null);
Oi([go], Ai.prototype, 'fatal', null);
Ai = Oi([qs(0, $h), qs(1, NT), qs(2, Nv(Uh)), qs(3, Dv(DT)), qs(4, xd)], Ai);
Au({
  create({ level: n = 3, colorOptions: e = 0, sinks: t = [] } = {}) {
    return Au({
      register(r) {
        r.register(Iv($h, new Fv(e, n)));
        for (const i of t) ta(i) ? r.register(Fh(Uh, i)) : r.register(i);
        return r;
      },
    });
  },
});
class UT {
  constructor(e, t) {
    (this.type = e), (this.cb = t);
  }
  handle(e) {
    e instanceof this.type && this.cb.call(null, e);
  }
}
const wd = /* @__PURE__ */ ki('IEventAggregator', (n) => n.singleton(jT));
class jT {
  constructor() {
    (this.eventLookup = {}), (this.messageHandlers = []);
  }
  publish(e, t) {
    if (!e) throw Jt(`Invalid channel name or instance: ${e}.`);
    if (xc(e)) {
      let r = this.eventLookup[e];
      if (r !== void 0) {
        r = r.slice();
        let i = r.length;
        for (; i-- > 0; ) r[i](t, e);
      }
    } else {
      const r = this.messageHandlers.slice();
      let i = r.length;
      for (; i-- > 0; ) r[i].handle(e);
    }
  }
  subscribe(e, t) {
    if (!e) throw Jt(`Invalid channel name or type: ${e}.`);
    let r, i;
    return (
      xc(e) ? (this.eventLookup[e] === void 0 && (this.eventLookup[e] = []), (r = t), (i = this.eventLookup[e])) : ((r = new UT(e, t)), (i = this.messageHandlers)),
      i.push(r),
      {
        dispose() {
          const s = i.indexOf(r);
          s !== -1 && i.splice(s, 1);
        },
      }
    );
  }
  subscribeOnce(e, t) {
    const r = this.subscribe(e, (i, s) => {
      r.dispose(), t(i, s);
    });
    return r;
  }
}
const Td = Object,
  VT = Td.prototype.hasOwnProperty,
  ur = Reflect.defineProperty,
  ie = (n) => new Error(n),
  rr = (n) => typeof n == 'function',
  ru = (n) => n instanceof Td,
  ps = (n) => n instanceof Array,
  tl = (n) => n instanceof Set,
  as = (n) => n instanceof Map,
  jh = Td.is;
function Ei(n, e, t) {
  return (
    ur(n, e, {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: t,
    }),
    t
  );
}
function pi(n, e, t) {
  e in n || Ei(n, e, t);
}
const Uv = Object.assign,
  nl = String,
  wo = he.createInterface,
  iu = () => Td.create(null),
  Vh = ti.getOwn,
  zh = ti.define;
vo.annotation.keyFor;
vo.resource.keyFor;
vo.resource.appendTo;
var q0;
(function (n) {
  (n[(n.AccessThis = 0)] = 'AccessThis'),
    (n[(n.AccessScope = 1)] = 'AccessScope'),
    (n[(n.ArrayLiteral = 2)] = 'ArrayLiteral'),
    (n[(n.ObjectLiteral = 3)] = 'ObjectLiteral'),
    (n[(n.PrimitiveLiteral = 4)] = 'PrimitiveLiteral'),
    (n[(n.Template = 5)] = 'Template'),
    (n[(n.Unary = 6)] = 'Unary'),
    (n[(n.CallScope = 7)] = 'CallScope'),
    (n[(n.CallMember = 8)] = 'CallMember'),
    (n[(n.CallFunction = 9)] = 'CallFunction'),
    (n[(n.AccessMember = 10)] = 'AccessMember'),
    (n[(n.AccessKeyed = 11)] = 'AccessKeyed'),
    (n[(n.TaggedTemplate = 12)] = 'TaggedTemplate'),
    (n[(n.Binary = 13)] = 'Binary'),
    (n[(n.Conditional = 14)] = 'Conditional'),
    (n[(n.Assign = 15)] = 'Assign'),
    (n[(n.ArrowFunction = 16)] = 'ArrowFunction'),
    (n[(n.ValueConverter = 17)] = 'ValueConverter'),
    (n[(n.BindingBehavior = 18)] = 'BindingBehavior'),
    (n[(n.ArrayBindingPattern = 19)] = 'ArrayBindingPattern'),
    (n[(n.ObjectBindingPattern = 20)] = 'ObjectBindingPattern'),
    (n[(n.BindingIdentifier = 21)] = 'BindingIdentifier'),
    (n[(n.ForOfStatement = 22)] = 'ForOfStatement'),
    (n[(n.Interpolation = 23)] = 'Interpolation'),
    (n[(n.ArrayDestructuring = 24)] = 'ArrayDestructuring'),
    (n[(n.ObjectDestructuring = 25)] = 'ObjectDestructuring'),
    (n[(n.DestructuringAssignmentLeaf = 26)] = 'DestructuringAssignmentLeaf'),
    (n[(n.DestructuringAssignmentRestLeaf = 27)] = 'DestructuringAssignmentRestLeaf'),
    (n[(n.Custom = 28)] = 'Custom');
})(q0 || (q0 = {}));
class Gh {
  constructor(e) {
    (this.value = e), (this.$kind = 28);
  }
  evaluate(e, t, r) {
    return this.value;
  }
  assign(e, t, r) {
    return r;
  }
  bind(e, t) {}
  unbind(e, t) {}
  accept(e) {}
}
class zT {
  constructor(e, t, r) {
    (this.expression = e), (this.name = t), (this.args = r), (this.$kind = 18), (this.key = `_bb_${t}`);
  }
}
class Eu {
  constructor(e, t, r) {
    (this.expression = e), (this.name = t), (this.args = r), (this.$kind = 17);
  }
}
class GT {
  constructor(e, t) {
    (this.target = e), (this.value = t), (this.$kind = 15);
  }
}
class HT {
  constructor(e, t, r) {
    (this.condition = e), (this.yes = t), (this.no = r), (this.$kind = 14);
  }
}
class xi {
  constructor(e = 0) {
    (this.ancestor = e), (this.$kind = 0);
  }
}
xi.$this = new xi(0);
xi.$parent = new xi(1);
class ec {
  constructor(e, t = 0) {
    (this.name = e), (this.ancestor = t), (this.$kind = 1);
  }
}
class wf {
  constructor(e, t, r = !1) {
    (this.object = e), (this.name = t), (this.optional = r), (this.$kind = 10);
  }
}
class jv {
  constructor(e, t, r = !1) {
    (this.object = e), (this.key = t), (this.optional = r), (this.$kind = 11);
  }
}
class Vv {
  constructor(e, t, r = 0, i = !1) {
    (this.name = e), (this.args = t), (this.ancestor = r), (this.optional = i), (this.$kind = 7);
  }
}
class Tc {
  constructor(e, t, r, i = !1, s = !1) {
    (this.object = e), (this.name = t), (this.args = r), (this.optionalMember = i), (this.optionalCall = s), (this.$kind = 8);
  }
}
class tc {
  constructor(e, t, r = !1) {
    (this.func = e), (this.args = t), (this.optional = r), (this.$kind = 9);
  }
}
class KT {
  constructor(e, t, r) {
    (this.operation = e), (this.left = t), (this.right = r), (this.$kind = 13);
  }
}
class qT {
  constructor(e, t) {
    (this.operation = e), (this.expression = t), (this.$kind = 6);
  }
}
class sn {
  constructor(e) {
    (this.value = e), (this.$kind = 4);
  }
}
sn.$undefined = new sn(void 0);
sn.$null = new sn(null);
sn.$true = new sn(!0);
sn.$false = new sn(!1);
sn.$empty = new sn('');
class Tf {
  constructor(e) {
    (this.elements = e), (this.$kind = 2);
  }
}
Tf.$empty = new Tf(Fe);
class Af {
  constructor(e, t) {
    (this.keys = e), (this.values = t), (this.$kind = 3);
  }
}
Af.$empty = new Af(Fe, Fe);
class Ac {
  constructor(e, t = Fe) {
    (this.cooked = e), (this.expressions = t), (this.$kind = 5);
  }
}
Ac.$empty = new Ac(['']);
class zv {
  constructor(e, t, r, i = Fe) {
    (this.cooked = e), (this.func = r), (this.expressions = i), (this.$kind = 12), (e.raw = t);
  }
}
class WT {
  constructor(e) {
    (this.elements = e), (this.$kind = 19);
  }
}
class JT {
  constructor(e, t) {
    (this.keys = e), (this.values = t), (this.$kind = 20);
  }
}
class Ec {
  constructor(e) {
    (this.name = e), (this.$kind = 21);
  }
}
class QT {
  constructor(e, t, r) {
    (this.declaration = e), (this.iterable = t), (this.semiIdx = r), (this.$kind = 22);
  }
}
class Gv {
  constructor(e, t = Fe) {
    (this.parts = e), (this.expressions = t), (this.$kind = 23), (this.isMulti = t.length > 1), (this.firstExpression = t[0]);
  }
}
class YT {
  constructor(e, t, r, i) {
    (this.$kind = e), (this.list = t), (this.source = r), (this.initializer = i);
  }
}
class Hv {
  constructor(e, t, r) {
    (this.target = e), (this.source = t), (this.initializer = r), (this.$kind = 26);
  }
}
class Ef {
  constructor(e, t, r = !1) {
    (this.args = e), (this.body = t), (this.rest = r), (this.$kind = 16);
  }
}
class W0 {
  constructor(e, t) {
    e !== void 0 && (this[e] = t);
  }
}
class an {
  constructor(e, t, r, i) {
    (this.parent = e), (this.bindingContext = t), (this.overrideContext = r), (this.isBoundary = i);
  }
  static getContext(e, t, r) {
    if (e == null) throw J0();
    let i = e.overrideContext,
      s = e;
    if (r > 0) {
      for (; r > 0; ) if ((r--, (s = s.parent), s == null)) return;
      return (i = s.overrideContext), t in i ? i : s.bindingContext;
    }
    for (; s != null && !s.isBoundary && !(t in s.overrideContext) && !(t in s.bindingContext); ) s = s.parent;
    return s == null ? e.bindingContext : ((i = s.overrideContext), t in i ? i : s.bindingContext);
  }
  static create(e, t, r) {
    if (e == null) throw XT();
    return new an(null, e, t ?? new Q0(), r ?? !1);
  }
  static fromParent(e, t) {
    if (e == null) throw J0();
    return new an(e, t, new Q0(), !1);
  }
}
const J0 = () => ie('AUR0203'),
  XT = () => ie('AUR0204');
class Q0 {}
const Cf = an.getContext;
function V(n, e, t, r) {
  switch (n.$kind) {
    case 0: {
      let i = e.overrideContext,
        s = e,
        a = n.ancestor;
      for (; a-- && i; ) (s = s.parent), (i = s?.overrideContext ?? null);
      return a < 1 && s ? s.bindingContext : void 0;
    }
    case 1: {
      const i = Cf(e, n.name, n.ancestor);
      r !== null && r.observe(i, n.name);
      const s = i[n.name];
      if (s == null && n.name === '$host') throw ie('AUR0105');
      return t?.strict ? (t?.boundFn && rr(s) ? s.bind(i) : s) : s == null ? '' : t?.boundFn && rr(s) ? s.bind(i) : s;
    }
    case 2:
      return n.elements.map((i) => V(i, e, t, r));
    case 3: {
      const i = {};
      for (let s = 0; s < n.keys.length; ++s) i[n.keys[s]] = V(n.values[s], e, t, r);
      return i;
    }
    case 4:
      return n.value;
    case 5: {
      let i = n.cooked[0];
      for (let s = 0; s < n.expressions.length; ++s) (i += String(V(n.expressions[s], e, t, r))), (i += n.cooked[s + 1]);
      return i;
    }
    case 6:
      switch (n.operation) {
        case 'void':
          return void V(n.expression, e, t, r);
        case 'typeof':
          return typeof V(n.expression, e, t, r);
        case '!':
          return !V(n.expression, e, t, r);
        case '-':
          return -V(n.expression, e, t, r);
        case '+':
          return +V(n.expression, e, t, r);
        default:
          throw ie(`AUR0109:${n.operation}`);
      }
    case 7: {
      const i = n.args.map((o) => V(o, e, t, r)),
        s = Cf(e, n.name, n.ancestor),
        a = Y0(t?.strictFnCall, s, n.name);
      return a ? a.apply(s, i) : void 0;
    }
    case 8: {
      const i = V(n.object, e, t, r),
        s = n.args.map((u) => V(u, e, t, r)),
        a = Y0(t?.strictFnCall, i, n.name);
      let o;
      return a && ((o = a.apply(i, s)), ps(i) && t3.includes(n.name) && r?.observeCollection(i)), o;
    }
    case 9: {
      const i = V(n.func, e, t, r);
      if (rr(i)) return i(...n.args.map((s) => V(s, e, t, r)));
      if (!t?.strictFnCall && i == null) return;
      throw ie('AUR0107');
    }
    case 16:
      return (...s) => {
        const a = n.args,
          o = n.rest,
          u = a.length - 1,
          l = a.reduce((h, b, E) => (o && E === u ? (h[b.name] = s.slice(E)) : (h[b.name] = s[E]), h), {}),
          p = an.fromParent(e, l);
        return V(n.body, p, t, r);
      };
    case 10: {
      const i = V(n.object, e, t, r);
      let s;
      return t?.strict
        ? i == null
          ? void 0
          : (r !== null && r.observe(i, n.name), (s = i[n.name]), t?.boundFn && rr(s) ? s.bind(i) : s)
        : (r !== null && ru(i) && r.observe(i, n.name), i ? ((s = i[n.name]), t?.boundFn && rr(s) ? s.bind(i) : s) : '');
    }
    case 11: {
      const i = V(n.object, e, t, r),
        s = V(n.key, e, t, r);
      return ru(i) ? (r !== null && r.observe(i, s), i[s]) : i?.[s];
    }
    case 12: {
      const i = n.expressions.map((a) => V(a, e, t, r)),
        s = V(n.func, e, t, r);
      if (!rr(s)) throw ie('AUR0110');
      return s(n.cooked, ...i);
    }
    case 13: {
      const i = n.left,
        s = n.right;
      switch (n.operation) {
        case '&&':
          return V(i, e, t, r) && V(s, e, t, r);
        case '||':
          return V(i, e, t, r) || V(s, e, t, r);
        case '??':
          return V(i, e, t, r) ?? V(s, e, t, r);
        case '==':
          return V(i, e, t, r) == V(s, e, t, r);
        case '===':
          return V(i, e, t, r) === V(s, e, t, r);
        case '!=':
          return V(i, e, t, r) != V(s, e, t, r);
        case '!==':
          return V(i, e, t, r) !== V(s, e, t, r);
        case 'instanceof': {
          const a = V(s, e, t, r);
          return rr(a) ? V(i, e, t, r) instanceof a : !1;
        }
        case 'in': {
          const a = V(s, e, t, r);
          return ru(a) ? V(i, e, t, r) in a : !1;
        }
        case '+': {
          const a = V(i, e, t, r),
            o = V(s, e, t, r);
          if (t?.strict) return a + o;
          if (!a || !o) {
            if (X0(a) || X0(o)) return (a || 0) + (o || 0);
            if (Z0(a) || Z0(o)) return (a || '') + (o || '');
          }
          return a + o;
        }
        case '-':
          return V(i, e, t, r) - V(s, e, t, r);
        case '*':
          return V(i, e, t, r) * V(s, e, t, r);
        case '/':
          return V(i, e, t, r) / V(s, e, t, r);
        case '%':
          return V(i, e, t, r) % V(s, e, t, r);
        case '<':
          return V(i, e, t, r) < V(s, e, t, r);
        case '>':
          return V(i, e, t, r) > V(s, e, t, r);
        case '<=':
          return V(i, e, t, r) <= V(s, e, t, r);
        case '>=':
          return V(i, e, t, r) >= V(s, e, t, r);
        default:
          throw ie(`AUR0108:${n.operation}`);
      }
    }
    case 14:
      return V(n.condition, e, t, r) ? V(n.yes, e, t, r) : V(n.no, e, t, r);
    case 15:
      return dn(n.target, e, t, V(n.value, e, t, r));
    case 17: {
      const i = t?.getConverter?.(n.name);
      if (i == null) throw ie(`AUR0103:${n.name}`);
      return 'toView' in i ? i.toView(V(n.expression, e, t, r), ...n.args.map((s) => V(s, e, t, r))) : V(n.expression, e, t, r);
    }
    case 18:
      return V(n.expression, e, t, r);
    case 21:
      return n.name;
    case 22:
      return V(n.iterable, e, t, r);
    case 23:
      if (n.isMulti) {
        let i = n.parts[0],
          s = 0;
        for (; s < n.expressions.length; ++s) (i += nl(V(n.expressions[s], e, t, r))), (i += n.parts[s + 1]);
        return i;
      } else return `${n.parts[0]}${V(n.firstExpression, e, t, r)}${n.parts[1]}`;
    case 26:
      return V(n.target, e, t, r);
    case 24:
      return n.list.map((i) => V(i, e, t, r));
    case 19:
    case 20:
    case 25:
    default:
      return;
    case 28:
      return n.evaluate(e, t, r);
  }
}
function dn(n, e, t, r) {
  switch (n.$kind) {
    case 1: {
      if (n.name === '$host') throw ie('AUR0106');
      const i = Cf(e, n.name, n.ancestor);
      return (i[n.name] = r);
    }
    case 10: {
      const i = V(n.object, e, t, null);
      return (
        ru(i)
          ? n.name === 'length' && ps(i) && !isNaN(r)
            ? i.splice(r)
            : (i[n.name] = r)
          : dn(n.object, e, t, {
              [n.name]: r,
            }),
        r
      );
    }
    case 11: {
      const i = V(n.object, e, t, null),
        s = V(n.key, e, t, null);
      if (ps(i)) {
        if (s === 'length' && !isNaN(r)) return i.splice(r), r;
        if (Tu(s)) return i.splice(s, 1, r), r;
      }
      return (i[s] = r);
    }
    case 15:
      return dn(n.value, e, t, r), dn(n.target, e, t, r);
    case 17: {
      const i = t?.getConverter?.(n.name);
      if (i == null) throw Kv(n.name);
      return 'fromView' in i && (r = i.fromView(r, ...n.args.map((s) => V(s, e, t, null)))), dn(n.expression, e, t, r);
    }
    case 18:
      return dn(n.expression, e, t, r);
    case 24:
    case 25: {
      const i = n.list,
        s = i.length;
      let a, o;
      for (a = 0; a < s; a++)
        switch (((o = i[a]), o.$kind)) {
          case 26:
            dn(o, e, t, r);
            break;
          case 24:
          case 25: {
            if (typeof r != 'object' || r === null) throw ie('AUR0112');
            let u = V(o.source, an.create(r), t, null);
            u === void 0 && o.initializer && (u = V(o.initializer, e, t, null)), dn(o, e, t, u);
            break;
          }
        }
      break;
    }
    case 26: {
      if (n instanceof Hv) {
        if (r == null) return;
        if (typeof r != 'object') throw ie('AUR0112');
        let i = V(n.source, an.create(r), t, null);
        i === void 0 && n.initializer && (i = V(n.initializer, e, t, null)), dn(n.target, e, t, i);
      } else {
        if (r == null) return;
        if (typeof r != 'object') throw ie('AUR0112');
        const i = n.indexOrProperties;
        let s;
        if (Tu(i)) {
          if (!Array.isArray(r)) throw ie('AUR0112');
          s = r.slice(i);
        } else s = Object.entries(r).reduce((a, [o, u]) => (i.includes(o) || (a[o] = u), a), {});
        dn(n.target, e, t, s);
      }
      break;
    }
    case 28:
      return n.assign(e, t, r);
    default:
      return;
  }
}
function Sr(n, e, t) {
  switch (n.$kind) {
    case 18: {
      const r = n.name,
        i = n.key,
        s = t.getBehavior?.(r);
      if (s == null) throw ZT(r);
      if (t[i] === void 0) (t[i] = s), s.bind?.(e, t, ...n.args.map((a) => V(a, e, t, null)));
      else throw e3(r);
      Sr(n.expression, e, t);
      return;
    }
    case 17: {
      const r = n.name,
        i = t.getConverter?.(r);
      if (i == null) throw Kv(r);
      const s = i.signals;
      if (s != null) {
        const a = t.getSignaler?.(),
          o = s.length;
        let u = 0;
        for (; u < o; ++u) a?.addSignalListener(s[u], t);
      }
      Sr(n.expression, e, t);
      return;
    }
    case 22: {
      Sr(n.iterable, e, t);
      break;
    }
    case 28:
      n.bind?.(e, t);
  }
}
function ar(n, e, t) {
  switch (n.$kind) {
    case 18: {
      const r = n.key,
        i = t;
      i[r] !== void 0 && (i[r].unbind?.(e, t), (i[r] = void 0)), ar(n.expression, e, t);
      break;
    }
    case 17: {
      const r = t.getConverter?.(n.name);
      if (r?.signals === void 0) return;
      const i = t.getSignaler?.();
      let s = 0;
      for (; s < r.signals.length; ++s) i?.removeSignalListener(r.signals[s], t);
      ar(n.expression, e, t);
      break;
    }
    case 22: {
      ar(n.iterable, e, t);
      break;
    }
    case 28:
      n.unbind?.(e, t);
  }
}
const ZT = (n) => ie(`AUR0101:${n}`),
  e3 = (n) => ie(`AUR0102:${n}`),
  Kv = (n) => ie(`AUR0103:${n}`),
  Y0 = (n, e, t) => {
    const r = e == null ? null : e[t];
    if (rr(r)) return r;
    if (!n && r == null) return null;
    throw ie(`AUR0111:${t}`);
  },
  X0 = (n) => {
    switch (typeof n) {
      case 'number':
      case 'bigint':
        return !0;
      default:
        return !1;
    }
  },
  Z0 = (n) => {
    switch (typeof n) {
      case 'string':
        return !0;
      case 'object':
        return n instanceof Date;
      default:
        return !1;
    }
  },
  t3 = 'at map filter includes indexOf lastIndexOf findIndex find flat flatMap join reduce reduceRight slice every some sort'.split(' '),
  em = /* @__PURE__ */ he.createInterface('ICoercionConfiguration');
var tm;
(function (n) {
  (n[(n.indexed = 8)] = 'indexed'), (n[(n.keyed = 4)] = 'keyed'), (n[(n.array = 9)] = 'array'), (n[(n.map = 6)] = 'map'), (n[(n.set = 7)] = 'set');
})(tm || (tm = {}));
var nm;
(function (n) {
  (n[(n.None = 0)] = 'None'),
    (n[(n.Observer = 1)] = 'Observer'),
    (n[(n.Node = 2)] = 'Node'),
    (n[(n.Layout = 4)] = 'Layout'),
    (n[(n.Primtive = 8)] = 'Primtive'),
    (n[(n.Array = 18)] = 'Array'),
    (n[(n.Set = 34)] = 'Set'),
    (n[(n.Map = 66)] = 'Map');
})(nm || (nm = {}));
function na(n = 0) {
  const e = Array(n);
  let t = 0;
  for (; t < n; ) e[t] = t++;
  return (e.deletedIndices = []), (e.deletedItems = []), (e.isIndexMap = !0), e;
}
function n3(n) {
  const e = n.slice();
  return (e.deletedIndices = n.deletedIndices.slice()), (e.deletedItems = n.deletedItems.slice()), (e.isIndexMap = !0), e;
}
function Ln(n) {
  return n == null ? rm : rm(n);
}
function rm(n) {
  const e = n.prototype;
  ur(e, 'subs', {
    get: i3,
  }),
    pi(e, 'subscribe', s3),
    pi(e, 'unsubscribe', a3);
}
class r3 {
  constructor() {
    (this.count = 0), (this.t = []);
  }
  add(e) {
    return this.t.includes(e) ? !1 : ((this.t[this.t.length] = e), ++this.count, !0);
  }
  remove(e) {
    const t = this.t.indexOf(e);
    return t !== -1 ? (this.t.splice(t, 1), --this.count, !0) : !1;
  }
  notify(e, t) {
    const r = this.t.slice(0),
      i = r.length;
    let s = 0;
    for (; s < i; ++s) r[s].handleChange(e, t);
  }
  notifyCollection(e, t) {
    const r = this.t.slice(0),
      i = r.length;
    let s = 0;
    for (; s < i; ++s) r[s].handleCollectionChange(e, t);
  }
}
function i3() {
  return Ei(this, 'subs', new r3());
}
function s3(n) {
  return this.subs.add(n);
}
function a3(n) {
  return this.subs.remove(n);
}
class qv {
  constructor(e) {
    (this.owner = e), (this.type = 18), (this.v = (this.o = e.collection).length);
  }
  getValue() {
    return this.o.length;
  }
  setValue(e) {
    e !== this.v && (Number.isNaN(e) || (this.o.splice(e), (this.v = this.o.length)));
  }
  handleCollectionChange(e, t) {
    const r = this.v,
      i = this.o.length;
    (this.v = i) !== r && this.subs.notify(this.v, r);
  }
}
class Hh {
  constructor(e) {
    (this.owner = e), (this.v = (this.o = e.collection).size), (this.type = as(this.o) ? 66 : 34);
  }
  getValue() {
    return this.o.size;
  }
  setValue() {
    throw ie('AUR02');
  }
  handleCollectionChange(e, t) {
    const r = this.v,
      i = this.o.size;
    (this.v = i) !== r && this.subs.notify(this.v, r);
  }
}
function Wv(n) {
  const e = n.prototype;
  pi(e, 'subscribe', o3), pi(e, 'unsubscribe', u3), Ln(n);
}
function o3(n) {
  this.subs.add(n) && this.subs.count === 1 && this.owner.subscribe(this);
}
function u3(n) {
  this.subs.remove(n) && this.subs.count === 0 && this.owner.subscribe(this);
}
Wv(qv);
Wv(Hh);
const im = Symbol.for('__au_arr_obs__'),
  oi = Array[im] ?? Ei(Array, im, /* @__PURE__ */ new WeakMap());
function l3(n, e) {
  return n === e ? 0 : ((n = n === null ? 'null' : n.toString()), (e = e === null ? 'null' : e.toString()), n < e ? -1 : 1);
}
function c3(n, e) {
  return n === void 0 ? (e === void 0 ? 0 : 1) : e === void 0 ? -1 : 0;
}
function d3(n, e, t, r, i) {
  let s, a, o, u, l, p, h;
  for (p = t + 1; p < r; p++) {
    for (s = n[p], a = e[p], h = p - 1; h >= t && ((o = n[h]), (u = e[h]), (l = i(o, s)), l > 0); h--) (n[h + 1] = o), (e[h + 1] = u);
    (n[h + 1] = s), (e[h + 1] = a);
  }
}
function Cc(n, e, t, r, i) {
  let s = 0,
    a = 0,
    o,
    u,
    l,
    p,
    h,
    b,
    E,
    x,
    T,
    w,
    _,
    k,
    D,
    N,
    B,
    j,
    q,
    z,
    Y;
  for (;;) {
    if (r - t <= 10) {
      d3(n, e, t, r, i);
      return;
    }
    (s = t + ((r - t) >> 1)),
      (o = n[t]),
      (p = e[t]),
      (u = n[r - 1]),
      (h = e[r - 1]),
      (l = n[s]),
      (b = e[s]),
      (E = i(o, u)),
      E > 0 && ((w = o), (_ = p), (o = u), (p = h), (u = w), (h = _)),
      (x = i(o, l)),
      x >= 0 ? ((w = o), (_ = p), (o = l), (p = b), (l = u), (b = h), (u = w), (h = _)) : ((T = i(u, l)), T > 0 && ((w = u), (_ = h), (u = l), (h = b), (l = w), (b = _))),
      (n[t] = o),
      (e[t] = p),
      (n[r - 1] = l),
      (e[r - 1] = b),
      (k = u),
      (D = h),
      (N = t + 1),
      (B = r - 1),
      (n[s] = n[N]),
      (e[s] = e[N]),
      (n[N] = k),
      (e[N] = D);
    e: for (a = N + 1; a < B; a++)
      if (((j = n[a]), (q = e[a]), (z = i(j, k)), z < 0)) (n[a] = n[N]), (e[a] = e[N]), (n[N] = j), (e[N] = q), N++;
      else if (z > 0) {
        do {
          if ((B--, B == a)) break e;
          (Y = n[B]), (z = i(Y, k));
        } while (z > 0);
        (n[a] = n[B]), (e[a] = e[B]), (n[B] = j), (e[B] = q), z < 0 && ((j = n[a]), (q = e[a]), (n[a] = n[N]), (e[a] = e[N]), (n[N] = j), (e[N] = q), N++);
      }
    r - B < N - t ? (Cc(n, e, B, r, i), (r = N)) : (Cc(n, e, t, N, i), (t = B));
  }
}
const Ci = Array.prototype,
  p3 = Ci.push,
  wp = Ci.unshift,
  Tp = Ci.pop,
  Ap = Ci.shift,
  kl = Ci.splice,
  f3 = Ci.reverse,
  h3 = Ci.sort,
  Jv = ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'],
  Qv = {
    push: function (...n) {
      const e = oi.get(this);
      if (e === void 0) return p3.apply(this, n);
      const t = this.length,
        r = n.length;
      if (r === 0) return t;
      this.length = e.indexMap.length = t + r;
      let i = t;
      for (; i < this.length; ) (this[i] = n[i - t]), (e.indexMap[i] = -2), i++;
      return e.notify(), this.length;
    },
    unshift: function (...n) {
      const e = oi.get(this);
      if (e === void 0) return wp.apply(this, n);
      const t = n.length,
        r = new Array(t);
      let i = 0;
      for (; i < t; ) r[i++] = -2;
      wp.apply(e.indexMap, r);
      const s = wp.apply(this, n);
      return e.notify(), s;
    },
    pop: function () {
      const n = oi.get(this);
      if (n === void 0) return Tp.call(this);
      const e = n.indexMap,
        t = Tp.call(this),
        r = e.length - 1;
      return e[r] > -1 && (e.deletedIndices.push(e[r]), e.deletedItems.push(t)), Tp.call(e), n.notify(), t;
    },
    shift: function () {
      const n = oi.get(this);
      if (n === void 0) return Ap.call(this);
      const e = n.indexMap,
        t = Ap.call(this);
      return e[0] > -1 && (e.deletedIndices.push(e[0]), e.deletedItems.push(t)), Ap.call(e), n.notify(), t;
    },
    splice: function (...n) {
      const e = n[0],
        t = n[1],
        r = oi.get(this);
      if (r === void 0) return kl.apply(this, n);
      const i = this.length,
        s = e | 0,
        a = s < 0 ? Math.max(i + s, 0) : Math.min(s, i),
        o = r.indexMap,
        u = n.length,
        l = u === 0 ? 0 : u === 1 ? i - a : t;
      let p = a;
      if (l > 0) {
        const b = p + l;
        for (; p < b; ) o[p] > -1 && (o.deletedIndices.push(o[p]), o.deletedItems.push(this[p])), p++;
      }
      if (((p = 0), u > 2)) {
        const b = u - 2,
          E = new Array(b);
        for (; p < b; ) E[p++] = -2;
        kl.call(o, e, t, ...E);
      } else kl.apply(o, n);
      const h = kl.apply(this, n);
      return (l > 0 || p > 0) && r.notify(), h;
    },
    reverse: function () {
      const n = oi.get(this);
      if (n === void 0) return f3.call(this), this;
      const e = this.length,
        t = (e / 2) | 0;
      let r = 0;
      for (; r !== t; ) {
        const i = e - r - 1,
          s = this[r],
          a = n.indexMap[r],
          o = this[i],
          u = n.indexMap[i];
        (this[r] = o), (n.indexMap[r] = u), (this[i] = s), (n.indexMap[i] = a), r++;
      }
      return n.notify(), this;
    },
    sort: function (n) {
      const e = oi.get(this);
      if (e === void 0) return h3.call(this, n), this;
      let t = this.length;
      if (t < 2) return this;
      Cc(this, e.indexMap, 0, t, c3);
      let r = 0;
      for (; r < t && this[r] !== void 0; ) r++;
      (n === void 0 || !rr(n)) && (n = l3), Cc(this, e.indexMap, 0, r, n);
      let i = !1;
      for (r = 0, t = e.indexMap.length; t > r; ++r)
        if (e.indexMap[r] !== r) {
          i = !0;
          break;
        }
      return i && e.notify(), this;
    },
  };
for (const n of Jv)
  ur(Qv[n], 'observing', {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1,
  });
let sm = !1;
const am = '__au_arr_on__';
function y3() {
  if (!(Vh(am, Array) ?? !1)) {
    zh(am, !0, Array);
    for (const n of Jv) Ci[n].observing !== !0 && Ei(Ci, n, Qv[n]);
  }
}
class Yv {
  constructor(e) {
    (this.type = 18), sm || ((sm = !0), y3()), (this.indexObservers = {}), (this.collection = e), (this.indexMap = na(e.length)), (this.lenObs = void 0), oi.set(e, this);
  }
  notify() {
    this.subs;
    const e = this.indexMap,
      t = this.collection,
      r = t.length;
    (this.indexMap = na(r)), this.subs.notifyCollection(t, e);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new qv(this));
  }
  getIndexObserver(e) {
    var t;
    return (t = this.indexObservers)[e] ?? (t[e] = new Xv(this, e));
  }
}
class Xv {
  constructor(e, t) {
    (this.owner = e), (this.index = t), (this.doNotCache = !0), (this.value = this.getValue());
  }
  getValue() {
    return this.owner.collection[this.index];
  }
  setValue(e) {
    if (e === this.getValue()) return;
    const t = this.owner,
      r = this.index,
      i = t.indexMap;
    i[r] > -1 && i.deletedIndices.push(i[r]), (i[r] = -2), (t.collection[r] = e), t.notify();
  }
  handleCollectionChange(e, t) {
    const r = this.index;
    if (t[r] === r) return;
    const s = this.value,
      a = (this.value = this.getValue());
    s !== a && this.subs.notify(a, s);
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && this.owner.subscribe(this);
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && this.owner.unsubscribe(this);
  }
}
Ln(Yv);
Ln(Xv);
function su(n) {
  let e = oi.get(n);
  return e === void 0 && (e = new Yv(n)), e;
}
const m3 = (n, e) => n - e;
function b3(n) {
  let e = 0,
    t = 0,
    r = 0;
  const i = n3(n);
  i.deletedIndices.length > 1 && i.deletedIndices.sort(m3);
  const s = i.length;
  for (; r < s; ++r) {
    for (; i.deletedIndices[t] <= r - e; ) ++t, --e;
    i[r] === -2 ? ++e : (i[r] += e);
  }
  return i;
}
function g3(n, e) {
  const t = n.slice(),
    r = e.length;
  let i = 0,
    s = 0;
  for (; i < r; ) (s = e[i]), s !== -2 && (n[i] = t[s]), ++i;
}
const om = Symbol.for('__au_set_obs__'),
  au = Set[om] ?? Ei(Set, om, /* @__PURE__ */ new WeakMap()),
  Cu = Set.prototype,
  um = Cu.add,
  lm = Cu.clear,
  cm = Cu.delete,
  Zv = ['add', 'clear', 'delete'],
  ex = {
    add: function (n) {
      const e = au.get(this);
      if (e === void 0) return um.call(this, n), this;
      const t = this.size;
      return um.call(this, n), this.size === t ? this : ((e.indexMap[t] = -2), e.notify(), this);
    },
    clear: function () {
      const n = au.get(this);
      if (n === void 0) return lm.call(this);
      if (this.size > 0) {
        const t = n.indexMap;
        let r = 0;
        for (const i of this.keys()) t[r] > -1 && (t.deletedIndices.push(t[r]), t.deletedItems.push(i)), r++;
        lm.call(this), (t.length = 0), n.notify();
      }
    },
    delete: function (n) {
      const e = au.get(this);
      if (e === void 0) return cm.call(this, n);
      if (this.size === 0) return !1;
      let r = 0;
      const i = e.indexMap;
      for (const s of this.keys()) {
        if (s === n) {
          i[r] > -1 && (i.deletedIndices.push(i[r]), i.deletedItems.push(s)), i.splice(r, 1);
          const a = cm.call(this, n);
          return a === !0 && e.notify(), a;
        }
        r++;
      }
      return !1;
    },
  },
  v3 = {
    writable: !0,
    enumerable: !1,
    configurable: !0,
  };
for (const n of Zv)
  ur(ex[n], 'observing', {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1,
  });
let dm = !1;
const pm = '__au_set_on__';
function x3() {
  if (!(Vh(pm, Set) ?? !1)) {
    zh(pm, !0, Set);
    for (const n of Zv)
      Cu[n].observing !== !0 &&
        ur(Cu, n, {
          ...v3,
          value: ex[n],
        });
  }
}
class tx {
  constructor(e) {
    (this.type = 34), dm || ((dm = !0), x3()), (this.collection = e), (this.indexMap = na(e.size)), (this.lenObs = void 0), au.set(e, this);
  }
  notify() {
    this.subs;
    const e = this.indexMap,
      t = this.collection,
      r = t.size;
    (this.indexMap = na(r)), this.subs.notifyCollection(t, e);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new Hh(this));
  }
}
Ln(tx);
function Sc(n) {
  let e = au.get(n);
  return e === void 0 && (e = new tx(n)), e;
}
const fm = Symbol.for('__au_map_obs__'),
  ou = Map[fm] ?? Ei(Map, fm, /* @__PURE__ */ new WeakMap()),
  Su = Map.prototype,
  hm = Su.set,
  ym = Su.clear,
  mm = Su.delete,
  nx = ['set', 'clear', 'delete'],
  rx = {
    set: function (n, e) {
      const t = ou.get(this);
      if (t === void 0) return hm.call(this, n, e), this;
      const r = this.get(n),
        i = this.size;
      if ((hm.call(this, n, e), this.size === i)) {
        let a = 0;
        for (const o of this.entries()) {
          if (o[0] === n) return o[1] !== r && (t.indexMap.deletedIndices.push(t.indexMap[a]), t.indexMap.deletedItems.push(o), (t.indexMap[a] = -2), t.notify()), this;
          a++;
        }
        return this;
      }
      return (t.indexMap[i] = -2), t.notify(), this;
    },
    clear: function () {
      const n = ou.get(this);
      if (n === void 0) return ym.call(this);
      if (this.size > 0) {
        const t = n.indexMap;
        let r = 0;
        for (const i of this.keys()) t[r] > -1 && (t.deletedIndices.push(t[r]), t.deletedItems.push(i)), r++;
        ym.call(this), (t.length = 0), n.notify();
      }
    },
    delete: function (n) {
      const e = ou.get(this);
      if (e === void 0) return mm.call(this, n);
      if (this.size === 0) return !1;
      let r = 0;
      const i = e.indexMap;
      for (const s of this.keys()) {
        if (s === n) {
          i[r] > -1 && (i.deletedIndices.push(i[r]), i.deletedItems.push(s)), i.splice(r, 1);
          const a = mm.call(this, n);
          return a === !0 && e.notify(), a;
        }
        ++r;
      }
      return !1;
    },
  },
  w3 = {
    writable: !0,
    enumerable: !1,
    configurable: !0,
  };
for (const n of nx)
  ur(rx[n], 'observing', {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1,
  });
let bm = !1;
const gm = '__au_map_on__';
function T3() {
  if (!(Vh(gm, Map) ?? !1)) {
    zh(gm, !0, Map);
    for (const n of nx)
      Su[n].observing !== !0 &&
        ur(Su, n, {
          ...w3,
          value: rx[n],
        });
  }
}
class ix {
  constructor(e) {
    (this.type = 66), bm || ((bm = !0), T3()), (this.collection = e), (this.indexMap = na(e.size)), (this.lenObs = void 0), ou.set(e, this);
  }
  notify() {
    const e = this.subs,
      t = this.indexMap,
      r = this.collection,
      i = r.size;
    (this.indexMap = na(i)), e.notifyCollection(r, t);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new Hh(this));
  }
}
Ln(ix);
function Mc(n) {
  let e = ou.get(n);
  return e === void 0 && (e = new ix(n)), e;
}
function A3() {
  return Ei(this, 'obs', new R3(this));
}
function E3(n, e) {
  this.obs.add(this.oL.getObserver(n, e));
}
function C3(n) {
  let e;
  if (ps(n)) e = su(n);
  else if (tl(n)) e = Sc(n);
  else if (as(n)) e = Mc(n);
  else throw ie('AUR0210');
  this.obs.add(e);
}
function S3(n) {
  this.obs.add(n);
}
function M3() {
  throw ie('AUR2011:handleChange');
}
function _3() {
  throw ie('AUR2011:handleCollectionChange');
}
class R3 {
  constructor(e) {
    (this.version = 0), (this.count = 0), (this.o = /* @__PURE__ */ new Map()), (this.b = e);
  }
  add(e) {
    this.o.has(e) || (e.subscribe(this.b), ++this.count), this.o.set(e, this.version);
  }
  clear() {
    this.o.forEach(I3, this), (this.count = this.o.size);
  }
  clearAll() {
    this.o.forEach(P3, this), this.o.clear(), (this.count = 0);
  }
}
function P3(n, e) {
  e.unsubscribe(this.b);
}
function I3(n, e) {
  this.version !== n && (e.unsubscribe(this.b), this.o.delete(e));
}
function vm(n) {
  const e = n.prototype;
  return (
    pi(e, 'observe', E3),
    pi(e, 'observeCollection', C3),
    pi(e, 'subscribeTo', S3),
    ur(e, 'obs', {
      get: A3,
    }),
    pi(e, 'handleChange', M3),
    pi(e, 'handleCollectionChange', _3),
    n
  );
}
function Pr(n) {
  return n == null ? vm : vm(n);
}
const Kh = wo('IExpressionParser', (n) => n.singleton(k3));
class k3 {
  constructor() {
    (this.i = iu()), (this.u = iu()), (this.h = iu());
  }
  parse(e, t) {
    let r;
    switch (t) {
      case 32:
        return new Gh(e);
      case 1:
        return (r = this.h[e]), r === void 0 && (r = this.h[e] = this.$parse(e, t)), r;
      case 2:
        return (r = this.u[e]), r === void 0 && (r = this.u[e] = this.$parse(e, t)), r;
      default: {
        if (e.length === 0) {
          if ((t & 24) > 0) return sn.$empty;
          throw J3();
        }
        return (r = this.i[e]), r === void 0 && (r = this.i[e] = this.$parse(e, t)), r;
      }
    }
  }
  $parse(e, t) {
    return (Re = e), (Ee = 0), (qr = e.length), (Hn = 0), (ra = 0), (Z = 6291456), (Le = ''), (gt = ia(0)), (Pe = !0), (Se = !1), (Wh = -1), _t(61, t === void 0 ? 16 : t);
  }
}
function qh(n) {
  switch (n) {
    case 98:
      return 8;
    case 116:
      return 9;
    case 110:
      return 10;
    case 118:
      return 11;
    case 102:
      return 12;
    case 114:
      return 13;
    case 34:
      return 34;
    case 39:
      return 39;
    case 92:
      return 92;
    default:
      return n;
  }
}
const O3 = sn.$false,
  B3 = sn.$true,
  N3 = sn.$null,
  sx = sn.$undefined,
  uu = xi.$this,
  Ep = xi.$parent;
var xm;
(function (n) {
  (n[(n.None = 0)] = 'None'),
    (n[(n.Interpolation = 1)] = 'Interpolation'),
    (n[(n.IsIterator = 2)] = 'IsIterator'),
    (n[(n.IsChainable = 4)] = 'IsChainable'),
    (n[(n.IsFunction = 8)] = 'IsFunction'),
    (n[(n.IsProperty = 16)] = 'IsProperty'),
    (n[(n.IsCustom = 32)] = 'IsCustom');
})(xm || (xm = {}));
let Re = '',
  Ee = 0,
  qr = 0,
  Hn = 0,
  ra = 0,
  Z = 6291456,
  Le = '',
  gt,
  Pe = !0,
  Se = !1,
  Wh = -1;
const Mu = String.fromCharCode,
  ia = (n) => Re.charCodeAt(n),
  Ja = () => Re.slice(ra, Ee);
function _t(n, e) {
  if (e === 32) return new Gh(Re);
  if (Ee === 0) {
    if (e & 1) return V3();
    if ((ue(), Z & 4194304)) throw K3();
  }
  (Pe = 513 > n), (Se = !1);
  let t = !1,
    r,
    i = 0;
  if (Z & 131072) {
    const s = ic[Z & 63];
    ue(), (r = new qT(s, _t(514, e))), (Pe = !1);
  } else {
    e: switch (Z) {
      case 12294:
        (i = Hn), (Pe = !1);
        do
          switch ((ue(), ++i, Z)) {
            case 65545:
              if ((ue(), !(Z & 12288))) throw si();
              break;
            case 10:
            case 11:
              throw si();
            case 2162700:
              if (((Se = !0), ue(), !(Z & 12288))) {
                (r = i === 0 ? uu : i === 1 ? Ep : new xi(i)), (t = !0);
                break e;
              }
              break;
            default:
              if (Z & 2097152) {
                r = i === 0 ? uu : i === 1 ? Ep : new xi(i);
                break e;
              }
              throw q3();
          }
        while (Z === 12294);
      case 4096: {
        const s = Le;
        if ((e & 2 ? (r = new Ec(s)) : (r = new ec(s, i)), (Pe = !Se), ue(), vr(50))) {
          if (Z === 524296) throw px();
          const a = Se,
            o = Hn;
          ++Hn;
          const u = _t(62, 0);
          (Se = a), (Hn = o), (Pe = !1), (r = new Ef([new Ec(s)], u));
        }
        break;
      }
      case 10:
        throw iA();
      case 11:
        throw Sf();
      case 12292:
        switch (((Pe = !1), ue(), Hn)) {
          case 0:
            r = uu;
            break;
          case 1:
            r = Ep;
            break;
          default:
            r = new xi(Hn);
            break;
        }
        break;
      case 2688007:
        r = L3(e);
        break;
      case 2688016:
        r = Re.search(/\s+of\s+/) > Ee ? D3() : $3(e);
        break;
      case 524296:
        r = j3(e);
        break;
      case 2163759:
        (r = new Ac([Le])), (Pe = !1), ue();
        break;
      case 2163760:
        r = Cp(e, r, !1);
        break;
      case 16384:
      case 32768:
        (r = new sn(Le)), (Pe = !1), ue();
        break;
      case 8194:
      case 8195:
      case 8193:
      case 8192:
        (r = ic[Z & 63]), (Pe = !1), ue();
        break;
      default:
        throw Ee >= qr ? W3() : Sp();
    }
    if (e & 2) return U3(r);
    if (514 < n) return r;
    if (Z === 10 || Z === 11) throw si();
    if (r.$kind === 0)
      switch (Z) {
        case 2162700:
          if (((Se = !0), (Pe = !1), ue(), !(Z & 13312))) throw Jh();
          if (Z & 12288) (r = new ec(Le, r.ancestor)), ue();
          else if (Z === 2688007) r = new tc(r, Fr(), !0);
          else if (Z === 2688016) r = nc(r, !0);
          else throw rc();
          break;
        case 65545:
          if (((Pe = !Se), ue(), !(Z & 12288))) throw si();
          (r = new ec(Le, r.ancestor)), ue();
          break;
        case 10:
        case 11:
          throw si();
        case 2688007:
          r = new tc(r, Fr(), t);
          break;
        case 2688016:
          r = nc(r, t);
          break;
        case 2163759:
          r = wm(r);
          break;
        case 2163760:
          r = Cp(e, r, !0);
          break;
      }
    for (; (Z & 65536) > 0; )
      switch (Z) {
        case 2162700:
          r = F3(r);
          break;
        case 65545:
          if ((ue(), !(Z & 12288))) throw si();
          r = ax(r, !1);
          break;
        case 10:
        case 11:
          throw si();
        case 2688007:
          r.$kind === 1 ? (r = new Vv(r.name, Fr(), r.ancestor, !1)) : r.$kind === 10 ? (r = new Tc(r.object, r.name, Fr(), r.optional, !1)) : (r = new tc(r, Fr(), !1));
          break;
        case 2688016:
          r = nc(r, !1);
          break;
        case 2163759:
          if (Se) throw rc();
          r = wm(r);
          break;
        case 2163760:
          if (Se) throw rc();
          r = Cp(e, r, !0);
          break;
      }
  }
  if (Z === 10 || Z === 11) throw si();
  if (513 < n) return r;
  for (; (Z & 262144) > 0; ) {
    const s = Z;
    if ((s & 960) <= n) break;
    ue(), (r = new KT(ic[s & 63], r, _t(s & 960, e))), (Pe = !1);
  }
  if (63 < n) return r;
  if (vr(6291478)) {
    const s = _t(62, e);
    Mr(6291476), (r = new HT(r, s, _t(62, e))), (Pe = !1);
  }
  if (62 < n) return r;
  if (vr(4194349)) {
    if (!Pe) throw Q3();
    r = new GT(r, _t(62, e));
  }
  if (61 < n) return r;
  for (; vr(6291480); ) {
    if (Z === 6291456) throw Y3();
    const s = Le;
    ue();
    const a = new Array();
    for (; vr(6291476); ) a.push(_t(62, e));
    r = new Eu(r, s, a);
  }
  for (; vr(6291479); ) {
    if (Z === 6291456) throw X3();
    const s = Le;
    ue();
    const a = new Array();
    for (; vr(6291476); ) a.push(_t(62, e));
    r = new zT(r, s, a);
  }
  if (Z !== 6291456) {
    if ((e & 1) > 0 && Z === 7340045) return r;
    if ((e & 4) > 0 && Z === 6291477) {
      if (Ee === qr) throw Sp();
      return (Wh = Ee - 1), r;
    }
    throw Ja() === 'of' ? Z3() : Sp();
  }
  return r;
}
function D3() {
  const n = [],
    e = new YT(24, n, void 0, void 0);
  let t = '',
    r = !0,
    i = 0;
  for (; r; )
    switch ((ue(), Z)) {
      case 7340051:
        (r = !1), s();
        break;
      case 6291471:
        s();
        break;
      case 4096:
        t = Ja();
        break;
      default:
        throw nA();
    }
  return Mr(7340051), e;
  function s() {
    t !== '' ? (n.push(new Hv(new wf(uu, t), new jv(uu, new sn(i++)), void 0)), (t = '')) : i++;
  }
}
function Fr() {
  const n = Se;
  ue();
  const e = [];
  for (; Z !== 7340046 && (e.push(_t(62, 0)), !!vr(6291471)); );
  return Mr(7340046), (Pe = !1), (Se = n), e;
}
function nc(n, e) {
  const t = Se;
  return ue(), (n = new jv(n, _t(62, 0), e)), Mr(7340051), (Pe = !t), (Se = t), n;
}
function F3(n) {
  if (((Se = !0), (Pe = !1), ue(), !(Z & 13312))) throw Jh();
  if (Z & 12288) return ax(n, !0);
  if (Z === 2688007) return n.$kind === 1 ? new Vv(n.name, Fr(), n.ancestor, !0) : n.$kind === 10 ? new Tc(n.object, n.name, Fr(), n.optional, !0) : new tc(n, Fr(), !0);
  if (Z === 2688016) return nc(n, !0);
  throw rc();
}
function ax(n, e) {
  const t = Le;
  switch (Z) {
    case 2162700: {
      (Se = !0), (Pe = !1);
      const r = Ee,
        i = ra,
        s = Z,
        a = gt,
        o = Le,
        u = Pe,
        l = Se;
      if ((ue(), !(Z & 13312))) throw Jh();
      return Z === 2688007 ? new Tc(n, t, Fr(), e, !0) : ((Ee = r), (ra = i), (Z = s), (gt = a), (Le = o), (Pe = u), (Se = l), new wf(n, t, e));
    }
    case 2688007:
      return (Pe = !1), new Tc(n, t, Fr(), e, !1);
    default:
      return (Pe = !Se), ue(), new wf(n, t, e);
  }
}
function L3(n) {
  ue();
  const e = Ee,
    t = ra,
    r = Z,
    i = gt,
    s = Le,
    a = Pe,
    o = Se,
    u = [];
  let l = 1,
    p = !1;
  e: for (;;) {
    if (Z === 11) {
      if ((ue(), Z !== 4096)) throw si();
      if ((u.push(new Ec(Le)), ue(), Z === 6291471)) throw rA();
      if (Z !== 7340046 || (ue(), Z !== 50)) throw Sf();
      ue();
      const E = Se,
        x = Hn;
      ++Hn;
      const T = _t(62, 0);
      return (Se = E), (Hn = x), (Pe = !1), new Ef(u, T, !0);
    }
    switch (Z) {
      case 4096:
        u.push(new Ec(Le)), ue();
        break;
      case 7340046:
        ue();
        break e;
      case 524296:
      case 2688016:
        ue(), (l = 4);
        break;
      case 6291471:
        (l = 2), (p = !0);
        break e;
      case 2688007:
        l = 2;
        break e;
      default:
        ue(), (l = 2);
        break;
    }
    switch (Z) {
      case 6291471:
        if ((ue(), (p = !0), l === 1)) break;
        break e;
      case 7340046:
        ue();
        break e;
      case 4194349:
        l === 1 && (l = 3);
        break e;
      case 50:
        if (p) throw Ol();
        ue(), (l = 2);
        break e;
      default:
        l === 1 && (l = 2);
        break e;
    }
  }
  if (Z === 50) {
    if (l === 1) {
      if ((ue(), Z === 524296)) throw px();
      const E = Se,
        x = Hn;
      ++Hn;
      const T = _t(62, 0);
      return (Se = E), (Hn = x), (Pe = !1), new Ef(u, T);
    }
    throw Ol();
  } else if (l === 1 && u.length === 0) throw cx(50);
  if (p)
    switch (l) {
      case 2:
        throw Ol();
      case 3:
        throw Am();
      case 4:
        throw Em();
    }
  (Ee = e), (ra = t), (Z = r), (gt = i), (Le = s), (Pe = a), (Se = o);
  const h = Se,
    b = _t(62, n);
  if (((Se = h), Mr(7340046), Z === 50))
    switch (l) {
      case 2:
        throw Ol();
      case 3:
        throw Am();
      case 4:
        throw Em();
    }
  return b;
}
function $3(n) {
  const e = Se;
  ue();
  const t = new Array();
  for (; Z !== 7340051; )
    if (vr(6291471)) {
      if ((t.push(sx), Z === 7340051)) break;
    } else if ((t.push(_t(62, n & -3)), vr(6291471))) {
      if (Z === 7340051) break;
    } else break;
  return (Se = e), Mr(7340051), n & 2 ? new WT(t) : ((Pe = !1), new Tf(t));
}
function U3(n) {
  if (!(n.$kind & 23) || Z !== 4204593) throw Tm();
  ue();
  const e = n,
    t = _t(61, 4);
  return new QT(e, t, Wh);
}
function j3(n) {
  const e = Se,
    t = new Array(),
    r = new Array();
  for (ue(); Z !== 7340045; ) {
    if ((t.push(Le), Z & 49152)) ue(), Mr(6291476), r.push(_t(62, n & -3));
    else if (Z & 12288) {
      const i = gt,
        s = Z,
        a = Ee;
      ue(), vr(6291476) ? r.push(_t(62, n & -3)) : ((gt = i), (Z = s), (Ee = a), r.push(_t(515, n & -3)));
    } else throw eA();
    Z !== 7340045 && Mr(6291471);
  }
  return (Se = e), Mr(7340045), n & 2 ? new JT(t, r) : ((Pe = !1), new Af(t, r));
}
function V3() {
  const n = [],
    e = [],
    t = qr;
  let r = '';
  for (; Ee < t; ) {
    switch (gt) {
      case 36:
        if (ia(Ee + 1) === 123) {
          n.push(r), (r = ''), (Ee += 2), (gt = ia(Ee)), ue();
          const i = _t(61, 1);
          e.push(i);
          continue;
        } else r += '$';
        break;
      case 92:
        r += Mu(qh(me()));
        break;
      default:
        r += Mu(gt);
    }
    me();
  }
  return e.length ? (n.push(r), new Gv(n, e)) : null;
}
function Cp(n, e, t) {
  const r = Se,
    i = [Le];
  Mr(2163760);
  const s = [_t(62, n)];
  for (; (Z = H3()) !== 2163759; ) i.push(Le), Mr(2163760), s.push(_t(62, n));
  return i.push(Le), (Pe = !1), (Se = r), t ? (ue(), new zv(i, i, e, s)) : (ue(), new Ac(i, s));
}
function wm(n) {
  Pe = !1;
  const e = [Le];
  return ue(), new zv(e, e, n);
}
function ue() {
  for (; Ee < qr; ) if (((ra = Ee), (Z = ke[gt]()) != null)) return;
  Z = 6291456;
}
function me() {
  return (gt = ia(++Ee));
}
function z3() {
  for (; Qh[me()]; );
  const n = sA[(Le = Ja())];
  return n === void 0 ? 4096 : n;
}
function ox(n) {
  let e = gt;
  if (n === !1) {
    do e = me();
    while (e <= 57 && e >= 48);
    if (e !== 46) return (Le = parseInt(Ja(), 10)), 32768;
    if (((e = me()), Ee >= qr)) return (Le = parseInt(Ja().slice(0, -1), 10)), 32768;
  }
  if (e <= 57 && e >= 48)
    do e = me();
    while (e <= 57 && e >= 48);
  else gt = ia(--Ee);
  return (Le = parseFloat(Ja())), 32768;
}
function G3() {
  const n = gt;
  me();
  let e = 0;
  const t = new Array();
  let r = Ee;
  for (; gt !== n; )
    if (gt === 92) t.push(Re.slice(r, Ee)), me(), (e = qh(gt)), me(), t.push(Mu(e)), (r = Ee);
    else {
      if (Ee >= qr) throw tA();
      me();
    }
  const i = Re.slice(r, Ee);
  return me(), t.push(i), (Le = t.join('')), 16384;
}
function ux() {
  let n = !0,
    e = '';
  for (; me() !== 96; )
    if (gt === 36)
      if (Ee + 1 < qr && ia(Ee + 1) === 123) {
        Ee++, (n = !1);
        break;
      } else e += '$';
    else if (gt === 92) e += Mu(qh(me()));
    else {
      if (Ee >= qr) throw lx();
      e += Mu(gt);
    }
  return me(), (Le = e), n ? 2163759 : 2163760;
}
const H3 = () => {
    if (Ee >= qr) throw lx();
    return Ee--, ux();
  },
  vr = (n) => (Z === n ? (ue(), !0) : !1),
  Mr = (n) => {
    if (Z === n) ue();
    else throw cx(n);
  },
  K3 = () => ie(`AUR0151:${Re}`),
  Sf = () => ie(`AUR0152:${Re}`),
  si = () => ie(`AUR0153:${Re}`),
  q3 = () => ie(`AUR0154:${Re}`),
  W3 = () => ie(`AUR0155:${Re}`),
  Sp = () => ie(`AUR0156:${Re}`),
  J3 = () => ie('AUR0157'),
  Q3 = () => ie(`AUR0158:${Re}`),
  Y3 = () => ie(`AUR0159:${Re}`),
  X3 = () => ie(`AUR0160:${Re}`),
  Z3 = () => ie(`AUR0161:${Re}`),
  Tm = () => ie(`AUR0163:${Re}`),
  eA = () => ie(`AUR0164:${Re}`),
  tA = () => ie(`AUR0165:${Re}`),
  lx = () => ie(`AUR0166:${Re}`),
  cx = (n) => ie(`AUR0167:${Re}<${ic[n & 63]}`),
  dx = () => {
    throw ie(`AUR0168:${Re}`);
  };
dx.notMapped = !0;
const nA = () => ie(`AUR0170:${Re}`),
  Jh = () => ie(`AUR0171:${Re}`),
  rc = () => ie(`AUR0172:${Re}`),
  Ol = () => ie(`AUR0173:${Re}`),
  Am = () => ie(`AUR0174:${Re}`),
  Em = () => ie(`AUR0175:${Re}`),
  rA = () => ie(`AUR0176:${Re}`),
  px = () => ie(`AUR0178:${Re}`),
  iA = () => ie(`AUR0179:${Re}`),
  ic = [
    O3,
    B3,
    N3,
    sx,
    '$this',
    null,
    '$parent',
    '(',
    '{',
    '.',
    '..',
    '...',
    '?.',
    '}',
    ')',
    ',',
    '[',
    ']',
    ':',
    ';',
    '?',
    "'",
    '"',
    '&',
    '|',
    '??',
    '||',
    '&&',
    '==',
    '!=',
    '===',
    '!==',
    '<',
    '>',
    '<=',
    '>=',
    'in',
    'instanceof',
    '+',
    '-',
    'typeof',
    'void',
    '*',
    '%',
    '/',
    '=',
    '!',
    2163759,
    2163760,
    'of',
    '=>',
  ],
  sA = Uv(/* @__PURE__ */ Object.create(null), {
    true: 8193,
    null: 8194,
    false: 8192,
    undefined: 8195,
    $this: 12292,
    $parent: 12294,
    in: 6562212,
    instanceof: 6562213,
    typeof: 139304,
    void: 139305,
    of: 4204593,
  }),
  To = {
    AsciiIdPart: [36, 0, 48, 58, 65, 91, 95, 0, 97, 123],
    IdStart: [
      36, 0, 65, 91, 95, 0, 97, 123, 170, 0, 186, 0, 192, 215, 216, 247, 248, 697, 736, 741, 7424, 7462, 7468, 7517, 7522, 7526, 7531, 7544, 7545, 7615, 7680, 7936, 8305, 0, 8319, 0, 8336, 8349, 8490,
      8492, 8498, 0, 8526, 0, 8544, 8585, 11360, 11392, 42786, 42888, 42891, 42927, 42928, 42936, 42999, 43008, 43824, 43867, 43868, 43877, 64256, 64263, 65313, 65339, 65345, 65371,
    ],
    Digit: [48, 58],
    Skip: [0, 33, 127, 161],
  },
  Ao = (n, e, t, r) => {
    const i = t.length;
    for (let s = 0; s < i; s += 2) {
      const a = t[s];
      let o = t[s + 1];
      if (((o = o > 0 ? o : a + 1), n && n.fill(r, a, o), e)) for (let u = a; u < o; u++) e.add(u);
    }
  },
  $n = (n) => () => (me(), n),
  aA = /* @__PURE__ */ new Set();
Ao(null, aA, To.AsciiIdPart, !0);
const Qh = new Uint8Array(65535);
Ao(Qh, null, To.IdStart, 1);
Ao(Qh, null, To.Digit, 1);
const ke = new Array(65535);
ke.fill(dx, 0, 65535);
Ao(ke, null, To.Skip, () => (me(), null));
Ao(ke, null, To.IdStart, z3);
Ao(ke, null, To.Digit, () => ox(!1));
ke[34] = ke[39] = () => G3();
ke[96] = () => ux();
ke[33] = () => (me() !== 61 ? 131118 : me() !== 61 ? 6553949 : (me(), 6553951));
ke[61] = () => (me() === 62 ? (me(), 50) : gt !== 61 ? 4194349 : me() !== 61 ? 6553948 : (me(), 6553950));
ke[38] = () => (me() !== 38 ? 6291479 : (me(), 6553883));
ke[124] = () => (me() !== 124 ? 6291480 : (me(), 6553818));
ke[63] = () => {
  if (me() === 46) {
    const n = ia(Ee + 1);
    return n <= 48 || n >= 57 ? (me(), 2162700) : 6291478;
  }
  return gt !== 63 ? 6291478 : (me(), 6553753);
};
ke[46] = () => (me() <= 57 && gt >= 48 ? ox(!0) : gt === 46 ? (me() !== 46 ? 10 : (me(), 11)) : 65545);
ke[60] = () => (me() !== 61 ? 6554016 : (me(), 6554018));
ke[62] = () => (me() !== 61 ? 6554017 : (me(), 6554019));
ke[37] = $n(6554155);
ke[40] = $n(2688007);
ke[41] = $n(7340046);
ke[42] = $n(6554154);
ke[43] = $n(2490854);
ke[44] = $n(6291471);
ke[45] = $n(2490855);
ke[47] = $n(6554156);
ke[58] = $n(6291476);
ke[59] = $n(6291477);
ke[91] = $n(2688016);
ke[93] = $n(7340051);
ke[123] = $n(524296);
ke[125] = $n(7340045);
let ve = null;
const Ga = [];
let Si = !1;
function oA() {
  Si = !1;
}
function uA() {
  Si = !0;
}
function Yh() {
  return ve;
}
function Xh(n) {
  if (n == null) throw ie('AUR0206');
  if (ve == null) {
    (ve = n), (Ga[0] = ve), (Si = !0);
    return;
  }
  if (ve === n) throw ie('AUR0207');
  Ga.push(n), (ve = n), (Si = !0);
}
function Zh(n) {
  if (n == null) throw ie('AUR0208');
  if (ve !== n) throw ie('AUR0209');
  Ga.pop(), (ve = Ga.length > 0 ? Ga[Ga.length - 1] : null), (Si = ve != null);
}
const lA = Object.freeze({
    get current() {
      return ve;
    },
    get connecting() {
      return Si;
    },
    enter: Xh,
    exit: Zh,
    pause: oA,
    resume: uA,
  }),
  no = Reflect.get,
  cA = Object.prototype.toString,
  Mf = /* @__PURE__ */ new WeakMap(),
  fx = '__au_nw__',
  hx = '__au_nw';
function yx(n) {
  switch (cA.call(n)) {
    case '[object Object]':
      return n.constructor[fx] !== !0;
    case '[object Array]':
    case '[object Map]':
    case '[object Set]':
      return !0;
    default:
      return !1;
  }
}
const Eo = '__raw__';
function be(n) {
  return yx(n) ? Ad(n) : n;
}
function Ad(n) {
  return Mf.get(n) ?? dA(n);
}
function _e(n) {
  return n[Eo] ?? n;
}
function An(n) {
  return (yx(n) && n[Eo]) || n;
}
function ey(n, e) {
  return e === 'constructor' || e === '__proto__' || e === '$observers' || e === Symbol.toPrimitive || e === Symbol.toStringTag || n.constructor[`${hx}_${nl(e)}__`] === !0;
}
function dA(n) {
  const e = ps(n) ? fA : as(n) || tl(n) ? DA : pA,
    t = new Proxy(n, e);
  return Mf.set(n, t), Mf.set(t, t), t;
}
const pA = {
    get(n, e, t) {
      if (e === Eo) return n;
      const r = Yh();
      return !Si || ey(n, e) || r == null ? no(n, e, t) : (r.observe(n, e), be(no(n, e, t)));
    },
  },
  fA = {
    get(n, e, t) {
      if (e === Eo) return n;
      if (!Si || ey(n, e) || ve == null) return no(n, e, t);
      switch (e) {
        case 'length':
          return ve.observe(n, 'length'), n.length;
        case 'map':
          return hA;
        case 'includes':
          return bA;
        case 'indexOf':
          return gA;
        case 'lastIndexOf':
          return vA;
        case 'every':
          return yA;
        case 'filter':
          return mA;
        case 'find':
          return wA;
        case 'findIndex':
          return xA;
        case 'flat':
          return TA;
        case 'flatMap':
          return AA;
        case 'join':
          return EA;
        case 'push':
          return SA;
        case 'pop':
          return CA;
        case 'reduce':
          return BA;
        case 'reduceRight':
          return NA;
        case 'reverse':
          return PA;
        case 'shift':
          return MA;
        case 'unshift':
          return _A;
        case 'slice':
          return OA;
        case 'splice':
          return RA;
        case 'some':
          return IA;
        case 'sort':
          return kA;
        case 'keys':
          return mx;
        case 'values':
        case Symbol.iterator:
          return _f;
        case 'entries':
          return Rf;
      }
      return ve.observe(n, e), be(no(n, e, t));
    },
    ownKeys(n) {
      return Yh()?.observe(n, 'length'), Reflect.ownKeys(n);
    },
  };
function hA(n, e) {
  const t = _e(this),
    r = t.map((i, s) => An(n.call(e, be(i), s, this)));
  return Et(ve, t), be(r);
}
function yA(n, e) {
  const t = _e(this),
    r = t.every((i, s) => n.call(e, be(i), s, this));
  return Et(ve, t), r;
}
function mA(n, e) {
  const t = _e(this),
    r = t.filter((i, s) => An(n.call(e, be(i), s, this)));
  return Et(ve, t), be(r);
}
function bA(n) {
  const e = _e(this),
    t = e.includes(An(n));
  return Et(ve, e), t;
}
function gA(n) {
  const e = _e(this),
    t = e.indexOf(An(n));
  return Et(ve, e), t;
}
function vA(n) {
  const e = _e(this),
    t = e.lastIndexOf(An(n));
  return Et(ve, e), t;
}
function xA(n, e) {
  const t = _e(this),
    r = t.findIndex((i, s) => An(n.call(e, be(i), s, this)));
  return Et(ve, t), r;
}
function wA(n, e) {
  const t = _e(this),
    r = t.find((i, s) => n(be(i), s, this), e);
  return Et(ve, t), be(r);
}
function TA() {
  const n = _e(this);
  return Et(ve, n), be(n.flat());
}
function AA(n, e) {
  const t = _e(this);
  return Et(ve, t), Ad(t.flatMap((r, i) => be(n.call(e, be(r), i, this))));
}
function EA(n) {
  const e = _e(this);
  return Et(ve, e), e.join(n);
}
function CA() {
  return be(_e(this).pop());
}
function SA(...n) {
  return _e(this).push(...n);
}
function MA() {
  return be(_e(this).shift());
}
function _A(...n) {
  return _e(this).unshift(...n);
}
function RA(...n) {
  return be(_e(this).splice(...n));
}
function PA(...n) {
  const e = _e(this),
    t = e.reverse();
  return Et(ve, e), be(t);
}
function IA(n, e) {
  const t = _e(this),
    r = t.some((i, s) => An(n.call(e, be(i), s, this)));
  return Et(ve, t), r;
}
function kA(n) {
  const e = _e(this),
    t = e.sort(n);
  return Et(ve, e), be(t);
}
function OA(n, e) {
  const t = _e(this);
  return Et(ve, t), Ad(t.slice(n, e));
}
function BA(n, e) {
  const t = _e(this),
    r = t.reduce((i, s, a) => n(i, be(s), a, this), e);
  return Et(ve, t), be(r);
}
function NA(n, e) {
  const t = _e(this),
    r = t.reduceRight((i, s, a) => n(i, be(s), a, this), e);
  return Et(ve, t), be(r);
}
const DA = {
  get(n, e, t) {
    if (e === Eo) return n;
    const r = Yh();
    if (!Si || ey(n, e) || r == null) return no(n, e, t);
    switch (e) {
      case 'size':
        return r.observe(n, 'size'), n.size;
      case 'clear':
        return VA;
      case 'delete':
        return zA;
      case 'forEach':
        return FA;
      case 'add':
        if (tl(n)) return jA;
        break;
      case 'get':
        if (as(n)) return $A;
        break;
      case 'set':
        if (as(n)) return UA;
        break;
      case 'has':
        return LA;
      case 'keys':
        return mx;
      case 'values':
        return _f;
      case 'entries':
        return Rf;
      case Symbol.iterator:
        return as(n) ? Rf : _f;
    }
    return be(no(n, e, t));
  },
};
function FA(n, e) {
  const t = _e(this);
  return (
    Et(ve, t),
    t.forEach((r, i) => {
      n.call(e, be(r), be(i), this);
    })
  );
}
function LA(n) {
  const e = _e(this);
  return Et(ve, e), e.has(An(n));
}
function $A(n) {
  const e = _e(this);
  return Et(ve, e), be(e.get(An(n)));
}
function UA(n, e) {
  return be(_e(this).set(An(n), An(e)));
}
function jA(n) {
  return be(_e(this).add(An(n)));
}
function VA() {
  return be(_e(this).clear());
}
function zA(n) {
  return be(_e(this).delete(An(n)));
}
function mx() {
  const n = _e(this);
  Et(ve, n);
  const e = n.keys();
  return {
    next() {
      const t = e.next(),
        r = t.value,
        i = t.done;
      return i
        ? {
            value: void 0,
            done: i,
          }
        : {
            value: be(r),
            done: i,
          };
    },
    [Symbol.iterator]() {
      return this;
    },
  };
}
function _f() {
  const n = _e(this);
  Et(ve, n);
  const e = n.values();
  return {
    next() {
      const t = e.next(),
        r = t.value,
        i = t.done;
      return i
        ? {
            value: void 0,
            done: i,
          }
        : {
            value: be(r),
            done: i,
          };
    },
    [Symbol.iterator]() {
      return this;
    },
  };
}
function Rf() {
  const n = _e(this);
  Et(ve, n);
  const e = n.entries();
  return {
    next() {
      const t = e.next(),
        r = t.value,
        i = t.done;
      return i
        ? {
            value: void 0,
            done: i,
          }
        : {
            value: [be(r[0]), be(r[1])],
            done: i,
          };
    },
    [Symbol.iterator]() {
      return this;
    },
  };
}
const Et = (n, e) => n?.observeCollection(e),
  GA = Object.freeze({
    getProxy: Ad,
    getRaw: _e,
    wrap: be,
    unwrap: An,
    rawKey: Eo,
  });
class rl {
  static create(e, t, r, i, s) {
    const a = r.get,
      o = r.set,
      u = new rl(e, a, o, s, i);
    return (
      ur(e, t, {
        enumerable: r.enumerable,
        configurable: !0,
        get: Uv(() => u.getValue(), {
          getObserver: () => u,
        }),
        set: (l) => {
          u.setValue(l);
        },
      }),
      u
    );
  }
  constructor(e, t, r, i, s) {
    (this.type = 1), (this.v = void 0), (this.ov = void 0), (this.ir = !1), (this.D = !1), (this.o = e), (this.$get = t), (this.$set = r), (this.up = i), (this.oL = s);
  }
  getValue() {
    return this.subs.count === 0 ? this.$get.call(this.o, this) : (this.D && (this.compute(), (this.D = !1)), this.v);
  }
  setValue(e) {
    if (rr(this.$set)) e !== this.v && ((this.ir = !0), this.$set.call(this.o, e), (this.ir = !1), this.run());
    else throw ie('AUR0221');
  }
  handleChange() {
    (this.D = !0), this.subs.count > 0 && this.run();
  }
  handleCollectionChange() {
    (this.D = !0), this.subs.count > 0 && this.run();
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.compute(), (this.D = !1));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && ((this.D = !0), this.obs.clearAll());
  }
  run() {
    if (this.ir) return;
    const e = this.v,
      t = this.compute();
    (this.D = !1), jh(t, e) || ((this.ov = e), (Cm = this.ov), (this.ov = this.v), this.subs.notify(this.v, Cm));
  }
  compute() {
    (this.ir = !0), this.obs.version++;
    try {
      return Xh(this), (this.v = An(this.$get.call(this.up ? be(this.o) : this.o, this)));
    } finally {
      this.obs.clear(), (this.ir = !1), Zh(this);
    }
  }
}
Pr(rl);
Ln(rl);
let Cm;
const bx = wo('IDirtyChecker', (n) => n.singleton(gx)),
  HA = {
    timeoutsPerCheck: 25,
    disabled: !1,
    throw: !1,
    resetToDefault() {
      (this.timeoutsPerCheck = 6), (this.disabled = !1), (this.throw = !1);
    },
  },
  KA = {
    persistent: !0,
  };
class gx {
  constructor(e) {
    (this.p = e),
      (this.tracked = []),
      (this.A = null),
      (this.C = 0),
      (this.check = () => {
        if (++this.C < HA.timeoutsPerCheck) return;
        this.C = 0;
        const t = this.tracked,
          r = t.length;
        let i,
          s = 0;
        for (; s < r; ++s) (i = t[s]), i.isDirty() && i.flush();
      });
  }
  createProperty(e, t) {
    return new vx(this, e, t);
  }
  addProperty(e) {
    this.tracked.push(e), this.tracked.length === 1 && (this.A = this.p.taskQueue.queueTask(this.check, KA));
  }
  removeProperty(e) {
    this.tracked.splice(this.tracked.indexOf(e), 1), this.tracked.length === 0 && (this.A.cancel(), (this.A = null));
  }
}
gx.inject = [el];
class vx {
  constructor(e, t, r) {
    (this.obj = t), (this.key = r), (this.type = 0), (this.ov = void 0), (this.O = e);
  }
  getValue() {
    return this.obj[this.key];
  }
  setValue(e) {
    throw ie(`Trying to set value for property ${nl(this.key)} in dirty checker`);
  }
  isDirty() {
    return this.ov !== this.obj[this.key];
  }
  flush() {
    const e = this.ov,
      t = this.getValue();
    (this.ov = t), this.subs.notify(t, e);
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && ((this.ov = this.obj[this.key]), this.O.addProperty(this));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && this.O.removeProperty(this);
  }
}
Ln(vx);
class qA {
  get doNotCache() {
    return !0;
  }
  constructor(e, t) {
    (this.type = 0), (this.o = e), (this.k = t);
  }
  getValue() {
    return this.o[this.k];
  }
  setValue() {}
  subscribe() {}
  unsubscribe() {}
}
class xx {
  constructor() {
    this.type = 0;
  }
  getValue(e, t) {
    return e[t];
  }
  setValue(e, t, r) {
    t[r] = e;
  }
}
class ty {
  constructor(e, t) {
    (this.type = 1), (this.v = void 0), (this.iO = !1), (this.o = e), (this.k = t);
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    if (this.iO) {
      if (jh(e, this.v)) return;
      (_c = this.v), (this.v = e), this.subs.notify(e, _c);
    } else this.o[this.k] = e;
  }
  subscribe(e) {
    this.iO === !1 && this.start(), this.subs.add(e);
  }
  start() {
    return (
      this.iO === !1 &&
        ((this.iO = !0),
        (this.v = this.o[this.k]),
        ur(this.o, this.k, {
          enumerable: !0,
          configurable: !0,
          get: () => this.getValue(),
          set: (e) => {
            this.setValue(e);
          },
        })),
      this
    );
  }
  stop() {
    return (
      this.iO &&
        (ur(this.o, this.k, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: this.v,
        }),
        (this.iO = !1)),
      this
    );
  }
}
class WA {
  constructor(e, t, r, i) {
    (this.type = 1), (this.v = void 0), (this.ov = void 0), (this.o = e), (this.S = r), (this.hs = rr(r));
    const s = e[t];
    (this.cb = rr(s) ? s : void 0), (this.v = i);
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.hs && (e = this.S(e, null)), jh(e, this.v) || ((this.ov = this.v), (this.v = e), this.cb?.call(this.o, this.v, this.ov), (_c = this.ov), (this.ov = this.v), this.subs.notify(this.v, _c));
  }
}
Ln(ty);
Ln(WA);
let _c;
const Pf = new xx(),
  ga = wo('IObserverLocator', (n) => n.singleton(wx)),
  Rc = wo('INodeObserverLocator', (n) => n.cachedCallback((e) => new JA()));
class JA {
  handles() {
    return !1;
  }
  getObserver() {
    return Pf;
  }
  getAccessor() {
    return Pf;
  }
}
class wx {
  constructor(e, t) {
    (this.R = []), (this.O = e), (this.T = t);
  }
  addAdapter(e) {
    this.R.push(e);
  }
  getObserver(e, t) {
    if (e == null) throw YA(t);
    if (!ru(e)) return new qA(e, t);
    const r = Tx(e);
    let i = r[t];
    return i === void 0 && ((i = this.createObserver(e, t)), i.doNotCache || (r[t] = i)), i;
  }
  getAccessor(e, t) {
    const r = e.$observers?.[t];
    return r !== void 0 ? r : this.T.handles(e, t, this) ? this.T.getAccessor(e, t, this) : Pf;
  }
  getArrayObserver(e) {
    return su(e);
  }
  getMapObserver(e) {
    return Mc(e);
  }
  getSetObserver(e) {
    return Sc(e);
  }
  createObserver(e, t) {
    if (this.T.handles(e, t, this)) return this.T.getObserver(e, t, this);
    switch (t) {
      case 'length':
        if (ps(e)) return su(e).getLengthObserver();
        break;
      case 'size':
        if (as(e)) return Mc(e).getLengthObserver();
        if (tl(e)) return Sc(e).getLengthObserver();
        break;
      default:
        if (ps(e) && Tu(t)) return su(e).getIndexObserver(Number(t));
        break;
    }
    let r = Mm(e, t);
    if (r === void 0) {
      let i = Sm(e);
      for (; i !== null && ((r = Mm(i, t)), r === void 0); ) i = Sm(i);
    }
    if (r !== void 0 && !VT.call(r, 'value')) {
      let i = this.P(e, t, r);
      return i == null && (i = (r.get?.getObserver ?? r.set?.getObserver)?.(e, this)), i ?? (r.configurable ? rl.create(e, t, r, this, !0) : this.O.createProperty(e, t));
    }
    return new ty(e, t);
  }
  P(e, t, r) {
    if (this.R.length > 0)
      for (const i of this.R) {
        const s = i.getObserver(e, t, r, this);
        if (s != null) return s;
      }
    return null;
  }
}
wx.inject = [bx, Rc];
const QA = (n) => {
    let e;
    return ps(n) ? (e = su(n)) : as(n) ? (e = Mc(n)) : tl(n) && (e = Sc(n)), e;
  },
  Sm = Object.getPrototypeOf,
  Mm = Object.getOwnPropertyDescriptor,
  Tx = (n) => {
    let e = n.$observers;
    return (
      e === void 0 &&
        ur(n, '$observers', {
          enumerable: !1,
          value: (e = iu()),
        }),
      e
    );
  },
  YA = (n) => ie(`AUR0199:${nl(n)}`);
wo('IObservation', (n) => n.singleton(XA));
class XA {
  static get inject() {
    return [ga];
  }
  constructor(e) {
    this.oL = e;
  }
  run(e) {
    const t = new Ax(this.oL, e);
    return t.run(), t;
  }
}
class Ax {
  constructor(e, t) {
    (this.oL = e), (this.fn = t), (this.maxRunCount = 10), (this.queued = !1), (this.running = !1), (this.runCount = 0), (this.stopped = !1);
  }
  handleChange() {
    (this.queued = !0), this.run();
  }
  handleCollectionChange() {
    (this.queued = !0), this.run();
  }
  run() {
    if (this.stopped) throw ie('AUR0225');
    if (!this.running) {
      ++this.runCount, (this.running = !0), (this.queued = !1), ++this.obs.version;
      try {
        Xh(this), this.fn(this);
      } finally {
        this.obs.clear(), (this.running = !1), Zh(this);
      }
      if (this.queued) {
        if (this.runCount > this.maxRunCount) throw ((this.runCount = 0), ie('AUR0226'));
        this.run();
      } else this.runCount = 0;
    }
  }
  stop() {
    (this.stopped = !0), this.obs.clearAll();
  }
}
Pr(Ax);
function ZA(n, e) {
  if (n == null) return (r, i) => t(r, i);
  return t(n, e);
  function t(r, i) {
    !i ? Ei(r, fx, !0) : Ei(r.constructor, `${hx}_${nl(i)}__`, !0);
  }
}
const Ed = wo('ISignaler', (n) => n.singleton(e4));
class e4 {
  constructor() {
    this.signals = iu();
  }
  dispatchSignal(e) {
    const t = this.signals[e];
    if (t === void 0) return;
    let r;
    for (r of t.keys()) r.handleChange(void 0, void 0);
  }
  addSignalListener(e, t) {
    const r = this.signals,
      i = r[e];
    i === void 0 ? (r[e] = /* @__PURE__ */ new Set([t])) : i.add(t);
  }
  removeSignalListener(e, t) {
    this.signals[e]?.delete(t);
  }
}
class t4 extends Error {
  constructor(e) {
    super('Task was canceled.'), (this.task = e);
  }
}
var _m;
(function (n) {
  (n[(n.pending = 0)] = 'pending'), (n[(n.running = 1)] = 'running'), (n[(n.completed = 2)] = 'completed'), (n[(n.canceled = 3)] = 'canceled');
})(_m || (_m = {}));
var Rm;
(function (n) {
  (n[(n.render = 0)] = 'render'), (n[(n.macroTask = 1)] = 'macroTask'), (n[(n.postRender = 2)] = 'postRender');
})(Rm || (Rm = {}));
function X(n, e, t, r) {
  var i = arguments.length,
    s = i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, t)) : r,
    a;
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') s = Reflect.decorate(n, e, t, r);
  else for (var o = n.length - 1; o >= 0; o--) (a = n[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function yn(n, e) {
  return function (t, r) {
    e(t, r, n);
  };
}
const En = ti.getOwn,
  il = ti.hasOwn,
  Pt = ti.define,
  { annotation: ny, resource: Ex } = vo,
  Sn = ny.keyFor,
  va = Ex.keyFor,
  xa = Ex.appendTo,
  ry = ny.appendTo,
  n4 = ny.getKeys,
  vs = Object,
  Co = String,
  iy = vs.prototype,
  Vn = () => vs.create(null),
  re = (n) => new Error(n),
  os = iy.hasOwnProperty,
  Bi = vs.freeze,
  sy = vs.assign,
  Cx = vs.getOwnPropertyNames,
  Sx = vs.keys,
  Pm = Vn(),
  Im = (n, e, t) => {
    if (Pm[e] === !0) return !0;
    if (!vt(e)) return !1;
    const r = e.slice(0, 5);
    return (Pm[e] = r === 'aria-' || r === 'data-' || t.isStandardSvgAttribute(n, e));
  },
  tn = (n) => n instanceof Promise,
  Wr = (n) => n instanceof Array,
  qn = (n) => typeof n == 'function',
  vt = (n) => typeof n == 'string',
  r4 = vs.defineProperty,
  Pc = (n) => {
    throw n;
  },
  sl = vs.is,
  If = Reflect.defineProperty,
  Ar = (n, e, t) => (
    If(n, e, {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: t,
    }),
    t
  ),
  Mx = (n, e, t) => n.addSignalListener(e, t),
  _x = (n, e, t) => n.removeSignalListener(e, t);
function De(n, e) {
  let t;
  function r(i, s) {
    arguments.length > 1 && (t.property = s), Pt(Zi, ns.create(s, i, t), i.constructor, s), ry(i.constructor, fi.keyFrom(s));
  }
  if (arguments.length > 1) {
    (t = {}), r(n, e);
    return;
  } else if (vt(n)) return (t = {}), r;
  return (t = n === void 0 ? {} : n), r;
}
function i4(n) {
  return n.startsWith(Zi);
}
const Zi = Sn('bindable'),
  fi = Bi({
    name: Zi,
    keyFrom: (n) => `${Zi}:${n}`,
    from(n, ...e) {
      const t = {},
        r = Array.isArray;
      function i(o) {
        t[o] = ns.create(o, n);
      }
      function s(o, u) {
        t[o] = u instanceof ns ? u : ns.create(o, n, u);
      }
      function a(o) {
        r(o) ? o.forEach(i) : o instanceof ns ? (t[o.property] = o) : o !== void 0 && Sx(o).forEach((u) => s(u, o[u]));
      }
      return e.forEach(a), t;
    },
    for(n) {
      let e;
      const t = {
        add(r) {
          let i, s;
          return (
            vt(r)
              ? ((i = r),
                (s = {
                  property: i,
                }))
              : ((i = r.property), (s = r)),
            (e = ns.create(i, n, s)),
            il(Zi, n, i) || ry(n, fi.keyFrom(i)),
            Pt(Zi, e, n, i),
            t
          );
        },
        mode(r) {
          return (e.mode = r), t;
        },
        callback(r) {
          return (e.callback = r), t;
        },
        attribute(r) {
          return (e.attribute = r), t;
        },
        primary() {
          return (e.primary = !0), t;
        },
        set(r) {
          return (e.set = r), t;
        },
      };
      return t;
    },
    getAll(n) {
      const e = Zi.length + 1,
        t = [],
        r = Yw(n);
      let i = r.length,
        s = 0,
        a,
        o,
        u,
        l;
      for (; --i >= 0; ) for (u = r[i], a = n4(u).filter(i4), o = a.length, l = 0; l < o; ++l) t[s++] = En(Zi, u, a[l].slice(e));
      return t;
    },
  });
class ns {
  constructor(e, t, r, i, s, a) {
    (this.attribute = e), (this.callback = t), (this.mode = r), (this.primary = i), (this.property = s), (this.set = a);
  }
  static create(e, t, r = {}) {
    return new ns(kn(r.attribute, Rv(e)), kn(r.callback, `${e}Changed`), kn(r.mode, 2), kn(r.primary, !1), kn(r.property, e), kn(r.set, s4(e, t, r)));
  }
}
const kf = {
  key: Sn('coercer'),
  define(n, e) {
    Pt(kf.key, n[e].bind(n), n);
  },
  for(n) {
    return En(kf.key, n);
  },
};
function s4(n, e, t = {}) {
  const r = t.type ?? ti.get('design:type', e, n) ?? null;
  if (r == null) return vi;
  let i;
  switch (r) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
      i = r;
      break;
    default: {
      const s = r.coerce;
      i = typeof s == 'function' ? s.bind(r) : kf.for(r) ?? vi;
      break;
    }
  }
  return i === vi ? i : a4(i, t.nullable);
}
function a4(n, e) {
  return function (t, r) {
    return r?.enableCoercion ? ((e ?? !(r?.coerceNullish ?? !1)) && t == null ? t : n(t, r)) : t;
  };
}
class Rx {
  get type() {
    return 1;
  }
  constructor(e, t, r, i, s, a) {
    (this.set = i), (this.$controller = s), (this.i = a), (this.v = void 0), (this.ov = void 0);
    const o = e[r],
      u = e.propertyChanged,
      l = (this.u = qn(o)),
      p = (this.A = qn(u)),
      h = (this.hs = i !== vi);
    let b;
    (this.o = e),
      (this.k = t),
      (this.C = p ? u : vi),
      (this.cb = l ? o : vi),
      this.cb === void 0 && !p && !h ? (this.iO = !1) : ((this.iO = !0), (b = e[t]), (this.v = h && b !== void 0 ? i(b, this.i) : b), this.R());
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.hs && (e = this.set(e, this.i));
    const t = this.v;
    if (this.iO) {
      if (sl(e, t)) return;
      (this.v = e),
        (this.ov = t),
        (this.$controller == null || this.$controller.isBound) && (this.u && this.cb.call(this.o, e, t), this.A && this.C.call(this.o, this.k, e, t)),
        this.subs.notify(this.v, this.ov);
    } else this.o[this.k] = e;
  }
  subscribe(e) {
    this.iO && ((this.iO = !0), (this.v = this.hs ? this.set(this.o[this.k], this.i) : this.o[this.k]), this.R()), this.subs.add(e);
  }
  R() {
    Reflect.defineProperty(this.o, this.k, {
      enumerable: !0,
      configurable: !0,
      get: () => this.v,
      set: (e) => {
        this.setValue(e);
      },
    });
  }
}
Ln(Rx);
const km = function (n) {
    function e(t, r, i) {
      he.inject(e)(t, r, i);
    }
    return (
      (e.$isResolver = !0),
      (e.resolve = function (t, r) {
        return r.root === r || r.has(n, !1) ? r.get(n) : r.root.get(n);
      }),
      e
    );
  },
  Dt = he.createInterface,
  So = fe.singleton,
  al = fe.aliasTo,
  Px = fe.transient,
  xt = (n, e, t) => n.registerResolver(e, t);
function o4(...n) {
  return function (e) {
    const t = Sn('aliases'),
      r = En(t, e);
    r === void 0 ? Pt(t, n, e) : r.push(...n);
  };
}
function ol(n, e, t, r) {
  for (let i = 0, s = n.length; i < s; ++i) fe.aliasTo(t, e.keyFrom(n[i])).register(r);
}
function Un(n) {
  return function (e) {
    return Ic.define(n, e);
  };
}
class ay {
  constructor(e, t, r, i) {
    (this.Type = e), (this.name = t), (this.aliases = r), (this.key = i);
  }
  static create(e, t) {
    let r, i;
    return (
      vt(e)
        ? ((r = e),
          (i = {
            name: r,
          }))
        : ((r = e.name), (i = e)),
      new ay(t, kn(Of(t, 'name'), r), Ft(Of(t, 'aliases'), i.aliases, t.aliases), Ic.keyFrom(r))
    );
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    So(r, t).register(e), al(r, t).register(e), ol(i, Ic, r, e);
  }
}
const Us = va('binding-behavior'),
  Of = (n, e) => En(Sn(e), n),
  Ic = Bi({
    name: Us,
    keyFrom(n) {
      return `${Us}:${n}`;
    },
    isType(n) {
      return qn(n) && il(Us, n);
    },
    define(n, e) {
      const t = ay.create(n, e);
      return Pt(Us, t, t.Type), Pt(Us, t, t), xa(e, Us), t.Type;
    },
    getDefinition(n) {
      const e = En(Us, n);
      if (e === void 0) throw re(`AUR0151:${n.name}`);
      return e;
    },
    annotate(n, e, t) {
      Pt(Sn(e), t, n);
    },
    getAnnotation: Of,
  }),
  Mp = /* @__PURE__ */ new Map();
class Cd {
  bind(e, t) {
    Mp.set(t, t.mode), (t.mode = this.mode);
  }
  unbind(e, t) {
    (t.mode = Mp.get(t)), Mp.delete(t);
  }
}
class u4 extends Cd {
  get mode() {
    return 1;
  }
}
class l4 extends Cd {
  get mode() {
    return 2;
  }
}
class c4 extends Cd {
  get mode() {
    return 4;
  }
}
class d4 extends Cd {
  get mode() {
    return 6;
  }
}
Un('oneTime')(u4);
Un('toView')(l4);
Un('fromView')(c4);
Un('twoWay')(d4);
const _p = /* @__PURE__ */ new WeakMap(),
  p4 = 200;
class Ix {
  constructor(e) {
    this.p = e;
  }
  bind(e, t, r, i) {
    const s = {
        type: 'debounce',
        delay: r ?? p4,
        now: this.p.performanceNow,
        queue: this.p.taskQueue,
        signals: vt(i) ? [i] : i ?? Fe,
      },
      a = t.limit?.(s);
    a == null || _p.set(t, a);
  }
  unbind(e, t) {
    _p.get(t)?.dispose(), _p.delete(t);
  }
}
Ix.inject = [el];
Un('debounce')(Ix);
class kx {
  constructor(e) {
    (this.B = /* @__PURE__ */ new Map()), (this._ = e);
  }
  bind(e, t, ...r) {
    if (!('handleChange' in t)) throw re('AUR0817');
    if (r.length === 0) throw re('AUR0818');
    this.B.set(t, r);
    let i;
    for (i of r) Mx(this._, i, t);
  }
  unbind(e, t) {
    const r = this.B.get(t);
    this.B.delete(t);
    let i;
    for (i of r) _x(this._, i, t);
  }
}
kx.inject = [Ed];
Un('signal')(kx);
const Rp = /* @__PURE__ */ new WeakMap(),
  f4 = 200;
class Ox {
  constructor(e) {
    (this.I = e.performanceNow), (this.T = e.taskQueue);
  }
  bind(e, t, r, i) {
    const s = {
        type: 'throttle',
        delay: r ?? f4,
        now: this.I,
        queue: this.T,
        signals: vt(i) ? [i] : i ?? Fe,
      },
      a = t.limit?.(s);
    a == null || Rp.set(t, a);
  }
  unbind(e, t) {
    Rp.get(t)?.dispose(), Rp.delete(t);
  }
}
Ox.inject = [el];
Un('throttle')(Ox);
const Ni = el;
function Bx(n) {
  return function (e) {
    return ly(n, e);
  };
}
function dr(n) {
  return function (e) {
    return ly(
      vt(n)
        ? {
            isTemplateController: !0,
            name: n,
          }
        : {
            isTemplateController: !0,
            ...n,
          },
      e,
    );
  };
}
class oy {
  get type() {
    return 2;
  }
  constructor(e, t, r, i, s, a, o, u, l, p) {
    (this.Type = e),
      (this.name = t),
      (this.aliases = r),
      (this.key = i),
      (this.defaultBindingMode = s),
      (this.isTemplateController = a),
      (this.bindables = o),
      (this.noMultiBindings = u),
      (this.watches = l),
      (this.dependencies = p);
  }
  static create(e, t) {
    let r, i;
    return (
      vt(e)
        ? ((r = e),
          (i = {
            name: r,
          }))
        : ((r = e.name), (i = e)),
      new oy(
        t,
        kn(Qi(t, 'name'), r),
        Ft(Qi(t, 'aliases'), i.aliases, t.aliases),
        uy(r),
        kn(Qi(t, 'defaultBindingMode'), i.defaultBindingMode, t.defaultBindingMode, 2),
        kn(Qi(t, 'isTemplateController'), i.isTemplateController, t.isTemplateController, !1),
        fi.from(t, ...fi.getAll(t), Qi(t, 'bindables'), t.bindables, i.bindables),
        kn(Qi(t, 'noMultiBindings'), i.noMultiBindings, t.noMultiBindings, !1),
        Ft(Nf.getAnnotation(t), t.watches),
        Ft(Qi(t, 'dependencies'), i.dependencies, t.dependencies),
      )
    );
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    Px(r, t).register(e), al(r, t).register(e), ol(i, cy, r, e);
  }
}
const Ys = va('custom-attribute'),
  uy = (n) => `${Ys}:${n}`,
  Qi = (n, e) => En(Sn(e), n),
  h4 = (n) => qn(n) && il(Ys, n),
  Nx = (n, e) => Xo(n, uy(e)) ?? void 0,
  ly = (n, e) => {
    const t = oy.create(n, e);
    return Pt(Ys, t, t.Type), Pt(Ys, t, t), xa(e, Ys), t.Type;
  },
  Bf = (n) => {
    const e = En(Ys, n);
    if (e === void 0) throw re(`AUR0759:${n.name}`);
    return e;
  },
  cy = Bi({
    name: Ys,
    keyFrom: uy,
    isType: h4,
    for: Nx,
    define: ly,
    getDefinition: Bf,
    annotate(n, e, t) {
      Pt(Sn(e), t, n);
    },
    getAnnotation: Qi,
  }),
  y4 = Fe,
  Bl = Sn('watch'),
  Nf = Bi({
    name: Bl,
    add(n, e) {
      let t = En(Bl, n);
      t == null && Pt(Bl, (t = []), n), t.push(e);
    },
    getAnnotation(n) {
      return En(Bl, n) ?? y4;
    },
  });
function Dx(n) {
  return function (e) {
    return Fx(n, e);
  };
}
const Pp = /* @__PURE__ */ new WeakMap();
class Lr {
  get type() {
    return 1;
  }
  constructor(e, t, r, i, s, a, o, u, l, p, h, b, E, x, T, w, _, k, D, N) {
    (this.Type = e),
      (this.name = t),
      (this.aliases = r),
      (this.key = i),
      (this.cache = s),
      (this.capture = a),
      (this.template = o),
      (this.instructions = u),
      (this.dependencies = l),
      (this.injectable = p),
      (this.needsCompile = h),
      (this.surrogates = b),
      (this.bindables = E),
      (this.containerless = x),
      (this.isStrictBinding = T),
      (this.shadowOptions = w),
      (this.hasSlots = _),
      (this.enhance = k),
      (this.watches = D),
      (this.processContent = N);
  }
  static create(e, t = null) {
    if (t === null) {
      const i = e;
      if (vt(i)) throw re(`AUR0761:${e}`);
      const s = _n('name', i, Df);
      return (
        qn(i.Type) ? (t = i.Type) : (t = Lx(Qw(s))),
        new Lr(
          t,
          s,
          Ft(i.aliases),
          _n('key', i, () => sc(s)),
          _n('cache', i, Ip),
          _n('capture', i, bn),
          _n('template', i, Xn),
          Ft(i.instructions),
          Ft(i.dependencies),
          _n('injectable', i, Xn),
          _n('needsCompile', i, kp),
          Ft(i.surrogates),
          fi.from(t, i.bindables),
          _n('containerless', i, bn),
          _n('isStrictBinding', i, bn),
          _n('shadowOptions', i, Xn),
          _n('hasSlots', i, bn),
          _n('enhance', i, bn),
          _n('watches', i, b4),
          Yn('processContent', t, Xn),
        )
      );
    }
    if (vt(e))
      return new Lr(
        t,
        e,
        Ft(br(t, 'aliases'), t.aliases),
        sc(e),
        Yn('cache', t, Ip),
        Yn('capture', t, bn),
        Yn('template', t, Xn),
        Ft(br(t, 'instructions'), t.instructions),
        Ft(br(t, 'dependencies'), t.dependencies),
        Yn('injectable', t, Xn),
        Yn('needsCompile', t, kp),
        Ft(br(t, 'surrogates'), t.surrogates),
        fi.from(t, ...fi.getAll(t), br(t, 'bindables'), t.bindables),
        Yn('containerless', t, bn),
        Yn('isStrictBinding', t, bn),
        Yn('shadowOptions', t, Xn),
        Yn('hasSlots', t, bn),
        Yn('enhance', t, bn),
        Ft(Nf.getAnnotation(t), t.watches),
        Yn('processContent', t, Xn),
      );
    const r = _n('name', e, Df);
    return new Lr(
      t,
      r,
      Ft(br(t, 'aliases'), e.aliases, t.aliases),
      sc(r),
      hr('cache', e, t, Ip),
      hr('capture', e, t, bn),
      hr('template', e, t, Xn),
      Ft(br(t, 'instructions'), e.instructions, t.instructions),
      Ft(br(t, 'dependencies'), e.dependencies, t.dependencies),
      hr('injectable', e, t, Xn),
      hr('needsCompile', e, t, kp),
      Ft(br(t, 'surrogates'), e.surrogates, t.surrogates),
      fi.from(t, ...fi.getAll(t), br(t, 'bindables'), t.bindables, e.bindables),
      hr('containerless', e, t, bn),
      hr('isStrictBinding', e, t, bn),
      hr('shadowOptions', e, t, Xn),
      hr('hasSlots', e, t, bn),
      hr('enhance', e, t, bn),
      Ft(e.watches, Nf.getAnnotation(t), t.watches),
      hr('processContent', e, t, Xn),
    );
  }
  static getOrCreate(e) {
    if (e instanceof Lr) return e;
    if (Pp.has(e)) return Pp.get(e);
    const t = Lr.create(e);
    return Pp.set(e, t), Pt(Wt, t, t.Type), t;
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    e.has(r, !1) || (Px(r, t).register(e), al(r, t).register(e), ol(i, Qa, r, e));
  }
}
const m4 = {
    name: void 0,
    searchParents: !1,
    optional: !1,
  },
  Ip = () => 0,
  Xn = () => null,
  bn = () => !1,
  kp = () => !0,
  b4 = () => Fe,
  Wt = va('custom-element'),
  sc = (n) => `${Wt}:${n}`,
  Df = (() => {
    let n = 0;
    return () => `unnamed-${++n}`;
  })(),
  g4 = (n, e, t) => {
    Pt(Sn(e), t, n);
  },
  Fx = (n, e) => {
    const t = Lr.create(n, e);
    return Pt(Wt, t, t.Type), Pt(Wt, t, t), xa(t.Type, Wt), t.Type;
  },
  v4 = (n) => qn(n) && il(Wt, n),
  Xs = (n, e = m4) => {
    if (e.name === void 0 && e.searchParents !== !0) {
      const r = Xo(n, Wt);
      if (r === null) {
        if (e.optional === !0) return null;
        throw re('AUR0762');
      }
      return r;
    }
    if (e.name !== void 0) {
      if (e.searchParents !== !0) {
        const s = Xo(n, Wt);
        if (s === null) throw re('AUR0763');
        return s.is(e.name) ? s : void 0;
      }
      let r = n,
        i = !1;
      for (; r !== null; ) {
        const s = Xo(r, Wt);
        if (s !== null && ((i = !0), s.is(e.name))) return s;
        r = Lf(r);
      }
      if (i) return;
      throw re('AUR0764');
    }
    let t = n;
    for (; t !== null; ) {
      const r = Xo(t, Wt);
      if (r !== null) return r;
      t = Lf(t);
    }
    throw re('AUR0765');
  },
  br = (n, e) => En(Sn(e), n),
  Ff = (n) => {
    const e = En(Wt, n);
    if (e === void 0) throw re(`AUR0760:${n.name}`);
    return e;
  },
  x4 = () => {
    const n = function (e, t, r) {
      const i = he.getOrCreateAnnotationParamTypes(e);
      return (i[r] = n), e;
    };
    return (
      (n.register = function (e) {
        return {
          resolve(t, r) {
            return r.has(n, !0) ? r.get(n) : null;
          },
        };
      }),
      n
    );
  },
  Lx = (function () {
    const n = {
        value: '',
        writable: !1,
        enumerable: !1,
        configurable: !0,
      },
      e = {};
    return function (t, r = e) {
      const i = class {};
      return (n.value = t), Reflect.defineProperty(i, 'name', n), r !== e && sy(i.prototype, r), i;
    };
  })(),
  Qa = Bi({
    name: Wt,
    keyFrom: sc,
    isType: v4,
    for: Xs,
    define: Fx,
    getDefinition: Ff,
    annotate: g4,
    getAnnotation: br,
    generateName: Df,
    createInjectable: x4,
    generateType: Lx,
  });
Sn('processContent');
const w4 = 'au-start',
  T4 = 'au-end',
  Om = (n, e) => n.document.createComment(e),
  A4 = (n) => {
    const e = Om(n, T4);
    return (e.$start = Om(n, w4)), e;
  },
  E4 = (n, e) => n.document.createTextNode(e),
  C4 = (n, e, t) => n.insertBefore(e, t),
  Nl = (n, e, t) => {
    if (n === null) return;
    const r = t.length;
    let i = 0;
    for (; r > i; ) n.insertBefore(t[i], e), ++i;
  },
  S4 = (n) => {
    const e = n.previousSibling;
    let t;
    if (e?.nodeType === 8 && e.textContent === 'au-end') {
      if (((t = e), (t.$start = t.previousSibling) == null)) throw Bm();
      return n.parentNode?.removeChild(n), t;
    } else throw Bm();
  },
  dy = (n, e) => new n.ownerDocument.defaultView.MutationObserver(e),
  Bm = () => re('AURxxxx');
class M4 {}
function Xo(n, e) {
  return n.$au?.[e] ?? null;
}
function gn(n, e, t) {
  var r;
  ((r = n).$au ?? (r.$au = new M4()))[e] = t;
}
const ro = /* @__PURE__ */ Dt('INode'),
  Cn = /* @__PURE__ */ Dt('IRenderLocation'),
  Nm = /* @__PURE__ */ Dt('CssModules'),
  kc = /* @__PURE__ */ new WeakMap();
function Lf(n) {
  if (kc.has(n)) return kc.get(n);
  let e = 0,
    t = n.nextSibling;
  for (; t !== null; ) {
    if (t.nodeType === 8)
      switch (t.textContent) {
        case 'au-start':
          ++e;
          break;
        case 'au-end':
          if (e-- === 0) return t;
      }
    t = t.nextSibling;
  }
  if (n.parentNode === null && n.nodeType === 11) {
    const r = Xs(n);
    if (r === void 0) return null;
    if (r.mountTarget === 2) return Lf(r.host);
  }
  return n.parentNode;
}
function _4(n, e) {
  if (n.platform !== void 0 && !(n instanceof n.platform.Node)) {
    const t = n.childNodes;
    for (let r = 0, i = t.length; r < i; ++r) kc.set(t[r], e);
  } else kc.set(n, e);
}
function py(n) {
  if (Oc(n)) return n;
  const e = n.ownerDocument.createComment('au-end'),
    t = (e.$start = n.ownerDocument.createComment('au-start')),
    r = n.parentNode;
  return r !== null && (r.replaceChild(e, n), r.insertBefore(t, e)), e;
}
function Oc(n) {
  return n.textContent === 'au-end';
}
class Op {
  get firstChild() {
    return this.P;
  }
  get lastChild() {
    return this.L;
  }
  constructor(e, t) {
    (this.platform = e), (this.next = void 0), (this.M = !1), (this.$ = !1), (this.ref = null), (this.f = t);
    const r = t.querySelectorAll('.au');
    let i = 0,
      s = r.length,
      a,
      o = (this.t = Array(s));
    for (; s > i; ) (a = r[i]), a.nodeName === 'AU-M' ? (o[i] = S4(a)) : (o[i] = a), ++i;
    const u = t.childNodes,
      l = (this.childNodes = Array((s = u.length)));
    for (i = 0; s > i; ) (l[i] = u[i]), ++i;
    (this.P = t.firstChild), (this.L = t.lastChild);
  }
  findTargets() {
    return this.t;
  }
  insertBefore(e) {
    if (this.$ && this.ref) this.addToLinked();
    else {
      const t = e.parentNode;
      if (this.M) {
        let r = this.P,
          i;
        const s = this.L;
        for (; r != null && ((i = r.nextSibling), t.insertBefore(r, e), r !== s); ) r = i;
      } else (this.M = !0), e.parentNode.insertBefore(this.f, e);
    }
  }
  appendTo(e, t = !1) {
    if (this.M) {
      let r = this.P,
        i;
      const s = this.L;
      for (; r != null && ((i = r.nextSibling), e.appendChild(r), r !== s); ) r = i;
    } else (this.M = !0), t || e.appendChild(this.f);
  }
  remove() {
    if (this.M) {
      this.M = !1;
      const e = this.f,
        t = this.L;
      let r,
        i = this.P;
      for (; i !== null && ((r = i.nextSibling), e.appendChild(i), i !== t); ) i = r;
    }
  }
  addToLinked() {
    const e = this.ref,
      t = e.parentNode;
    if (this.M) {
      let r = this.P,
        i;
      const s = this.L;
      for (; r != null && ((i = r.nextSibling), t.insertBefore(r, e), r !== s); ) r = i;
    } else (this.M = !0), t.insertBefore(this.f, e);
  }
  unlink() {
    (this.$ = !1), (this.next = void 0), (this.ref = void 0);
  }
  link(e) {
    (this.$ = !0), Oc(e) ? (this.ref = e) : ((this.next = e), this.U());
  }
  U() {
    this.next !== void 0 ? (this.ref = this.next.firstChild) : (this.ref = void 0);
  }
}
const Dm = (n, e, t, r) => {
    n.addEventListener(e, t, r);
  },
  Fm = (n, e, t, r) => {
    n.removeEventListener(e, t, r);
  },
  fy = (n) => {
    let e;
    const t = n.prototype;
    Ar(t, 'subscribe', function (r) {
      if (this.subs.add(r) && this.subs.count === 1) {
        for (e of this.cf.events) Dm(this.q, e, this);
        (this.F = !0), this.O?.();
      }
    }),
      Ar(t, 'unsubscribe', function (r) {
        if (this.subs.remove(r) && this.subs.count === 0) {
          for (e of this.cf.events) Fm(this.q, e, this);
          (this.F = !1), this.H?.();
        }
      }),
      Ar(t, 'useConfig', function (r) {
        if (((this.cf = r), this.F)) {
          for (e of this.cf.events) Fm(this.q, e, this);
          for (e of this.cf.events) Dm(this.q, e, this);
        }
      });
  },
  Sd = (n) => {
    Ar(n.prototype, 'subscribe', vi), Ar(n.prototype, 'unsubscribe', vi);
  };
class $x {
  get doNotCache() {
    return !0;
  }
  constructor(e) {
    (this.obj = e), (this.type = 6), (this.value = ''), (this.ov = ''), (this.V = {}), (this.N = 0), (this.j = !1);
  }
  getValue() {
    return this.value;
  }
  setValue(e) {
    (this.value = e), (this.j = e !== this.ov), this.W();
  }
  W() {
    if (this.j) {
      this.j = !1;
      const e = this.value,
        t = this.V,
        r = Ux(e);
      let i = this.N;
      if (((this.ov = e), r.length > 0 && this.G(r), (this.N += 1), i === 0)) return;
      i -= 1;
      for (const s in t) !os.call(t, s) || t[s] !== i || this.obj.classList.remove(s);
    }
  }
  G(e) {
    const t = this.obj,
      r = e.length;
    let i = 0,
      s;
    for (; i < r; i++) (s = e[i]), s.length !== 0 && ((this.V[s] = this.N), t.classList.add(s));
  }
}
function Ux(n) {
  if (vt(n)) return Lm(n);
  if (typeof n != 'object') return Fe;
  if (n instanceof Array) {
    const r = n.length;
    if (r > 0) {
      const i = [];
      let s = 0;
      for (; r > s; ++s) i.push(...Ux(n[s]));
      return i;
    } else return Fe;
  }
  const e = [];
  let t;
  for (t in n) n[t] && (t.includes(' ') ? e.push(...Lm(t)) : e.push(t));
  return e;
}
function Lm(n) {
  const e = n.match(/\S+/g);
  return e === null ? Fe : e;
}
Sd($x);
const $m = /* @__PURE__ */ Dt('IShadowDOMStyles'),
  R4 = /* @__PURE__ */ Dt('IShadowDOMGlobalStyles', (n) =>
    n.instance({
      applyTo: vi,
    }),
  );
function ul(n) {
  return function (e) {
    return Bc.define(n, e);
  };
}
class hy {
  constructor(e, t, r, i) {
    (this.Type = e), (this.name = t), (this.aliases = r), (this.key = i);
  }
  static create(e, t) {
    let r, i;
    return (
      vt(e)
        ? ((r = e),
          (i = {
            name: r,
          }))
        : ((r = e.name), (i = e)),
      new hy(t, kn($f(t, 'name'), r), Ft($f(t, 'aliases'), i.aliases, t.aliases), Bc.keyFrom(r))
    );
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    fe.singleton(r, t).register(e), fe.aliasTo(r, t).register(e), ol(i, Bc, r, e);
  }
}
const js = va('value-converter'),
  $f = (n, e) => En(Sn(e), n),
  Bc = Bi({
    name: js,
    keyFrom: (n) => `${js}:${n}`,
    isType(n) {
      return qn(n) && il(js, n);
    },
    define(n, e) {
      const t = hy.create(n, e);
      return Pt(js, t, t.Type), Pt(js, t, t), xa(e, js), t.Type;
    },
    getDefinition(n) {
      const e = En(js, n);
      if (e === void 0) throw re(`AUR0152:${n.name}`);
      return e;
    },
    annotate(n, e, t) {
      Pt(Sn(e), t, n);
    },
    getAnnotation: $f,
  });
class P4 {
  constructor(e, t) {
    (this.v = void 0), (this.b = e), (this.K = t);
  }
  flush() {
    this.b.updateSource(this.v);
  }
  handleChange(e, t) {
    const r = this.b;
    e !== V(r.ast, r.s, r, null) && ((this.v = e), this.K.add(this));
  }
}
const Mo = (n) => {
    Ar(n.prototype, 'useScope', function (e) {
      this.s = e;
    });
  },
  ni =
    (n, e = !0) =>
    (t) => {
      const r = t.prototype;
      n != null &&
        If(r, 'strict', {
          enumerable: !0,
          get: function () {
            return n;
          },
        }),
        If(r, 'strictFnCall', {
          enumerable: !0,
          get: function () {
            return e;
          },
        }),
        Ar(r, 'get', function (i) {
          return this.l.get(i);
        }),
        Ar(r, 'getSignaler', function () {
          return this.l.root.get(Ed);
        }),
        Ar(r, 'getConverter', function (i) {
          const s = Bc.keyFrom(i);
          let a = Dl.get(this);
          return a == null && Dl.set(this, (a = new Um())), a[s] ?? (a[s] = this.l.get(km(s)));
        }),
        Ar(r, 'getBehavior', function (i) {
          const s = Ic.keyFrom(i);
          let a = Dl.get(this);
          return a == null && Dl.set(this, (a = new Um())), a[s] ?? (a[s] = this.l.get(km(s)));
        });
    },
  Dl = /* @__PURE__ */ new WeakMap();
class Um {}
const I4 = /* @__PURE__ */ Dt('IFlushQueue', (n) => n.singleton(k4));
class k4 {
  constructor() {
    (this.Y = !1), (this.Z = /* @__PURE__ */ new Set());
  }
  get count() {
    return this.Z.size;
  }
  add(e) {
    if ((this.Z.add(e), !this.Y)) {
      this.Y = !0;
      try {
        this.Z.forEach(O4);
      } finally {
        this.Y = !1;
      }
    }
  }
  clear() {
    this.Z.clear(), (this.Y = !1);
  }
}
function O4(n, e, t) {
  t.delete(n), n.flush();
}
const Bp = /* @__PURE__ */ new WeakSet(),
  wa = (n, e) => {
    Ar(n.prototype, 'limit', function (t) {
      if (Bp.has(this)) throw re('AURXXXX: a rate limit has already been applied.');
      Bp.add(this);
      const r = e(this, t),
        i = t.signals,
        s = i.length > 0 ? this.get(Ed) : null,
        a = this[r],
        o = (...p) => a.call(this, ...p),
        u = t.type === 'debounce' ? B4(t, o, this) : N4(t, o, this),
        l = s
          ? {
              handleChange: u.flush,
            }
          : null;
      return (
        (this[r] = u),
        s && i.forEach((p) => Mx(s, p, l)),
        {
          dispose: () => {
            s && i.forEach((p) => _x(s, p, l)), Bp.delete(this), u.dispose(), delete this[r];
          },
        }
      );
    });
  },
  B4 = (n, e, t) => {
    let r,
      i,
      s,
      a = !1;
    const o = n.queue,
      u = () => e(s),
      l = (h) => {
        (s = h),
          t.isBound
            ? ((i = r),
              (r = o.queueTask(u, {
                delay: n.delay,
                reusable: !1,
              })),
              i?.cancel())
            : u();
      },
      p = (l.dispose = () => {
        i?.cancel(), r?.cancel(), (i = r = void 0);
      });
    return (
      (l.flush = () => {
        (a = r?.status === 0), p(), a && u();
      }),
      l
    );
  },
  N4 = (n, e, t) => {
    let r,
      i,
      s = 0,
      a = 0,
      o,
      u = !1;
    const l = n.queue,
      p = () => n.now(),
      h = () => e(o),
      b = (x) => {
        (o = x),
          t.isBound
            ? ((a = p() - s),
              (i = r),
              a > n.delay
                ? ((s = p()), h())
                : (r = l.queueTask(
                    () => {
                      (s = p()), h();
                    },
                    {
                      delay: n.delay - a,
                      reusable: !1,
                    },
                  )),
              i?.cancel())
            : h();
      },
      E = (b.dispose = () => {
        i?.cancel(), r?.cancel(), (i = r = void 0);
      });
    return (
      (b.flush = () => {
        (u = r?.status === 0), E(), u && h();
      }),
      b
    );
  },
  { enter: D4, exit: F4 } = lA,
  { wrap: L4, unwrap: $4 } = GA;
class jx {
  get value() {
    return this.v;
  }
  constructor(e, t, r, i, s) {
    (this.obj = e), (this.$get = r), (this.useProxy = s), (this.isBound = !1), (this.running = !1), (this.v = void 0), (this.cb = i), (this.oL = t);
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  bind() {
    this.isBound || (this.compute(), (this.isBound = !0));
  }
  unbind() {
    this.isBound && ((this.isBound = !1), this.obs.clearAll());
  }
  run() {
    if (!this.isBound || this.running) return;
    const e = this.obj,
      t = this.v,
      r = this.compute();
    sl(r, t) || this.cb.call(e, r, t, e);
  }
  compute() {
    (this.running = !0), this.obs.version++;
    try {
      return D4(this), (this.v = $4(this.$get.call(void 0, this.useProxy ? L4(this.obj) : this.obj, this)));
    } finally {
      this.obs.clear(), (this.running = !1), F4(this);
    }
  }
}
class yy {
  get value() {
    return this.v;
  }
  constructor(e, t, r, i, s) {
    (this.scope = e), (this.l = t), (this.oL = r), (this.isBound = !1), (this.boundFn = !1), (this.obj = e.bindingContext), (this.J = i), (this.cb = s);
  }
  handleChange(e) {
    const t = this.J,
      r = this.obj,
      i = this.v;
    (t.$kind === 1 && this.obs.count === 1) || (this.obs.version++, (e = V(t, this.scope, this, this)), this.obs.clear()), sl(e, i) || ((this.v = e), this.cb.call(r, e, i, r));
  }
  bind() {
    this.isBound || (this.obs.version++, (this.v = V(this.J, this.scope, this, this)), this.obs.clear(), (this.isBound = !0));
  }
  unbind() {
    this.isBound && ((this.isBound = !1), this.obs.clearAll(), (this.v = void 0));
  }
}
Pr(jx);
Pr(yy);
ni(!0)(yy);
const Fa = /* @__PURE__ */ Dt('ILifecycleHooks');
class U4 {
  constructor(e, t) {
    (this.definition = e), (this.instance = t);
  }
}
class my {
  constructor(e, t) {
    (this.Type = e), (this.propertyNames = t);
  }
  static create(e, t) {
    const r = /* @__PURE__ */ new Set();
    let i = t.prototype;
    for (; i !== iy; ) {
      for (const s of Cx(i)) s !== 'constructor' && !s.startsWith('_') && r.add(s);
      i = Object.getPrototypeOf(i);
    }
    return new my(t, r);
  }
  register(e) {
    So(Fa, this.Type).register(e);
  }
}
const jm = /* @__PURE__ */ new WeakMap(),
  Fl = Sn('lifecycle-hooks'),
  Vm = Bi({
    name: Fl,
    define(n, e) {
      const t = my.create(n, e);
      return Pt(Fl, t, e), xa(e, Fl), t.Type;
    },
    resolve(n) {
      let e = jm.get(n);
      if (e === void 0) {
        jm.set(n, (e = new j4()));
        const t = n.root,
          r = t.id === n.id ? n.getAll(Fa) : n.has(Fa, !1) ? t.getAll(Fa).concat(n.getAll(Fa)) : t.getAll(Fa);
        let i, s, a, o, u;
        for (i of r) {
          (s = En(Fl, i.constructor)), (a = new U4(s, i));
          for (o of s.propertyNames) (u = e[o]), u === void 0 ? (e[o] = [a]) : u.push(a);
        }
      }
      return e;
    },
  });
class j4 {}
class Vx {
  constructor(e, t, r) {
    (this.type = 7), (this.v = null), (this.ov = null), (this.j = !1), (this.o = e), (this.tt = t), (this.et = r);
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    (this.v = e), (this.j = e !== this.ov), this.W();
  }
  W() {
    if (this.j)
      switch (((this.j = !1), (this.ov = this.v), this.et)) {
        case 'class': {
          this.o.classList.toggle(this.tt, !!this.v);
          break;
        }
        case 'style': {
          let e = '',
            t = this.v;
          vt(t) && t.includes('!important') && ((e = 'important'), (t = t.replace('!important', ''))), this.o.style.setProperty(this.tt, t, e);
          break;
        }
        default:
          this.v == null ? this.o.removeAttribute(this.et) : this.o.setAttribute(this.et, Co(this.v));
      }
  }
  handleMutation(e) {
    let t = !1;
    for (let r = 0, i = e.length; i > r; ++r) {
      const s = e[r];
      if (s.type === 'attributes' && s.attributeName === this.tt) {
        t = !0;
        break;
      }
    }
    if (t) {
      let r;
      switch (this.et) {
        case 'class':
          r = this.o.classList.contains(this.tt);
          break;
        case 'style':
          r = this.o.style.getPropertyValue(this.tt);
          break;
        default:
          throw re(`AUR0651:${this.et}`);
      }
      r !== this.v && ((this.ov = this.v), (this.v = r), (this.j = !1), this.it());
    }
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && ((this.v = this.ov = this.o.getAttribute(this.tt)), V4(this.o, this));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && z4(this.o, this);
  }
  it() {
    (zm = this.ov), (this.ov = this.v), this.subs.notify(this.v, zm);
  }
}
Ln(Vx);
const V4 = (n, e) => {
    n.$eMObs === void 0 && (n.$eMObs = /* @__PURE__ */ new Set()),
      n.$mObs === void 0 &&
        (n.$mObs = dy(n, G4)).observe(n, {
          attributes: !0,
        }),
      n.$eMObs.add(e);
  },
  z4 = (n, e) => {
    const t = n.$eMObs;
    return t && t.delete(e) ? (t.size === 0 && (n.$mObs.disconnect(), (n.$mObs = void 0)), !0) : !1;
  },
  G4 = (n) => {
    n[0].target.$eMObs.forEach(H4, n);
  };
function H4(n) {
  n.handleMutation(this);
}
let zm;
const K4 = {
  reusable: !1,
  preempt: !0,
};
class ll {
  constructor(e, t, r, i, s, a, o, u, l) {
    (this.targetAttribute = o),
      (this.targetProperty = u),
      (this.mode = l),
      (this.isBound = !1),
      (this.s = void 0),
      (this.st = null),
      (this.v = void 0),
      (this.boundFn = !1),
      (this.l = t),
      (this.ast = s),
      (this.nt = e),
      (this.target = a),
      (this.oL = r),
      (this.T = i);
  }
  updateTarget(e) {
    this.rt.setValue(e, this.target, this.targetProperty);
  }
  handleChange() {
    if (!this.isBound) return;
    let e;
    this.obs.version++;
    const t = V(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    this.obs.clear(),
      t !== this.v &&
        ((this.v = t),
        this.nt.state !== 1 && (this.rt.type & 4) > 0
          ? ((e = this.st),
            (this.st = this.T.queueTask(() => {
              (this.st = null), this.updateTarget(t);
            }, K4)),
            e?.cancel())
          : this.updateTarget(t));
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e),
      Sr(this.ast, e, this),
      this.rt ?? (this.rt = new Vx(this.target, this.targetProperty, this.targetAttribute)),
      this.mode & 3 && this.updateTarget((this.v = V(this.ast, e, this, (this.mode & 2) > 0 ? this : null))),
      (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), ar(this.ast, this.s, this), (this.s = void 0), (this.v = void 0), this.st?.cancel(), (this.st = null), this.obs.clearAll());
  }
}
Mo(ll);
wa(ll, () => 'updateTarget');
Pr(ll);
ni(!0)(ll);
const zx = {
  reusable: !1,
  preempt: !0,
};
class q4 {
  constructor(e, t, r, i, s, a, o, u) {
    (this.ast = s),
      (this.target = a),
      (this.targetProperty = o),
      (this.mode = u),
      (this.isBound = !1),
      (this.s = void 0),
      (this.st = null),
      (this.nt = e),
      (this.oL = r),
      (this.T = i),
      (this.rt = r.getAccessor(a, o));
    const l = s.expressions,
      p = (this.partBindings = Array(l.length)),
      h = l.length;
    let b = 0;
    for (; h > b; ++b) p[b] = new cl(l[b], a, o, t, r, this);
  }
  ot() {
    this.updateTarget();
  }
  updateTarget() {
    const e = this.partBindings,
      t = this.ast.parts,
      r = e.length;
    let i = '',
      s = 0;
    if (r === 1) i = t[0] + e[0].v + t[1];
    else for (i = t[0]; r > s; ++s) i += e[s].v + t[s + 1];
    const a = this.rt,
      o = this.nt.state !== 1 && (a.type & 4) > 0;
    let u;
    o
      ? ((u = this.st),
        (this.st = this.T.queueTask(() => {
          (this.st = null), a.setValue(i, this.target, this.targetProperty);
        }, zx)),
        u?.cancel(),
        (u = null))
      : a.setValue(i, this.target, this.targetProperty);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    this.s = e;
    const t = this.partBindings,
      r = t.length;
    let i = 0;
    for (; r > i; ++i) t[i].bind(e);
    this.updateTarget(), (this.isBound = !0);
  }
  unbind() {
    if (!this.isBound) return;
    (this.isBound = !1), (this.s = void 0);
    const e = this.partBindings,
      t = e.length;
    let r = 0;
    for (; t > r; ++r) e[r].unbind();
    this.st?.cancel(), (this.st = null);
  }
}
class cl {
  constructor(e, t, r, i, s, a) {
    (this.ast = e),
      (this.target = t),
      (this.targetProperty = r),
      (this.owner = a),
      (this.mode = 2),
      (this.task = null),
      (this.isBound = !1),
      (this.v = ''),
      (this.boundFn = !1),
      (this.l = i),
      (this.oL = s);
  }
  updateTarget() {
    this.owner.ot();
  }
  handleChange() {
    if (!this.isBound) return;
    this.obs.version++;
    const e = V(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    this.obs.clear(), e != this.v && ((this.v = e), Wr(e) && this.observeCollection(e), this.updateTarget());
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), Sr(this.ast, e, this), (this.v = V(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null)), Wr(this.v) && this.observeCollection(this.v), (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), ar(this.ast, this.s, this), (this.s = void 0), this.obs.clearAll());
  }
}
Mo(cl);
wa(cl, () => 'updateTarget');
Pr(cl);
ni(!0)(cl);
class dl {
  constructor(e, t, r, i, s, a, o, u) {
    (this.p = s),
      (this.ast = a),
      (this.target = o),
      (this.strict = u),
      (this.isBound = !1),
      (this.mode = 2),
      (this.st = null),
      (this.v = ''),
      (this.boundFn = !1),
      (this.l = t),
      (this.nt = e),
      (this.oL = r),
      (this.T = i);
  }
  updateTarget(e) {
    const t = this.target,
      r = this.p.Node,
      i = this.v;
    (this.v = e), i instanceof r && i.parentNode?.removeChild(i), e instanceof r ? ((t.textContent = ''), t.parentNode?.insertBefore(e, t)) : (t.textContent = Co(e));
  }
  handleChange() {
    if (!this.isBound) return;
    this.obs.version++;
    const e = V(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    if ((this.obs.clear(), e === this.v)) {
      this.st?.cancel(), (this.st = null);
      return;
    }
    this.nt.state !== 1 ? this.lt(e) : this.updateTarget(e);
  }
  handleCollectionChange() {
    if (!this.isBound) return;
    this.obs.version++;
    const e = (this.v = V(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null));
    this.obs.clear(), Wr(e) && this.observeCollection(e), this.nt.state !== 1 ? this.lt(e) : this.updateTarget(e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), Sr(this.ast, e, this);
    const t = (this.v = V(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null));
    Wr(t) && this.observeCollection(t), this.updateTarget(t), (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), ar(this.ast, this.s, this), (this.s = void 0), this.obs.clearAll(), this.st?.cancel(), (this.st = null));
  }
  lt(e) {
    const t = this.st;
    (this.st = this.T.queueTask(() => {
      (this.st = null), this.updateTarget(e);
    }, zx)),
      t?.cancel();
  }
}
Mo(dl);
wa(dl, () => 'updateTarget');
Pr()(dl);
ni(void 0, !1)(dl);
class pl {
  constructor(e, t, r, i, s = !1) {
    (this.ast = r), (this.targetProperty = i), (this.isBound = !1), (this.s = void 0), (this.target = null), (this.boundFn = !1), (this.l = e), (this.oL = t), (this.ht = s);
  }
  updateTarget() {
    this.target[this.targetProperty] = this.v;
  }
  handleChange() {
    this.isBound && (this.obs.version++, (this.v = V(this.ast, this.s, this, this)), this.obs.clear(), this.updateTarget());
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), (this.target = this.ht ? e.bindingContext : e.overrideContext), Sr(this.ast, e, this), (this.v = V(this.ast, this.s, this, this)), this.updateTarget(), (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), ar(this.ast, this.s, this), (this.s = void 0), this.obs.clearAll());
  }
}
Mo(pl);
wa(pl, () => 'updateTarget');
Pr(pl);
ni(!0)(pl);
class Di {
  constructor(e, t, r, i, s, a, o, u) {
    (this.ast = s),
      (this.target = a),
      (this.targetProperty = o),
      (this.mode = u),
      (this.isBound = !1),
      (this.s = void 0),
      (this.rt = void 0),
      (this.st = null),
      (this.ct = null),
      (this.boundFn = !1),
      (this.l = t),
      (this.nt = e),
      (this.T = i),
      (this.oL = r);
  }
  updateTarget(e) {
    this.rt.setValue(e, this.target, this.targetProperty);
  }
  updateSource(e) {
    dn(this.ast, this.s, this, e);
  }
  handleChange() {
    if (!this.isBound) return;
    this.obs.version++;
    const e = V(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    this.obs.clear(),
      this.nt.state !== 1 && (this.rt.type & 4) > 0
        ? ((Np = this.st),
          (this.st = this.T.queueTask(() => {
            this.updateTarget(e), (this.st = null);
          }, W4)),
          Np?.cancel(),
          (Np = null))
        : this.updateTarget(e);
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), Sr(this.ast, e, this);
    const t = this.oL,
      r = this.mode;
    let i = this.rt;
    i || (r & 4 ? (i = t.getObserver(this.target, this.targetProperty)) : (i = t.getAccessor(this.target, this.targetProperty)), (this.rt = i));
    const s = (r & 2) > 0;
    r & 3 && this.updateTarget(V(this.ast, this.s, this, s ? this : null)),
      r & 4 && (i.subscribe(this.ct ?? (this.ct = new P4(this, this.l.get(I4)))), s || this.updateSource(i.getValue(this.target, this.targetProperty))),
      (this.isBound = !0);
  }
  unbind() {
    this.isBound &&
      ((this.isBound = !1), ar(this.ast, this.s, this), (this.s = void 0), this.ct && (this.rt.unsubscribe(this.ct), (this.ct = null)), this.st?.cancel(), (this.st = null), this.obs.clearAll());
  }
  useTargetObserver(e) {
    this.rt?.unsubscribe(this), (this.rt = e).subscribe(this);
  }
  useTargetSubscriber(e) {
    if (this.ct != null) throw re('AURxxxx: binding already has a target subscriber');
    this.ct = e;
  }
}
Mo(Di);
wa(Di, (n) => (n.mode & 4 ? 'updateSource' : 'updateTarget'));
Pr(Di);
ni(!0, !1)(Di);
let Np = null;
const W4 = {
  reusable: !1,
  preempt: !0,
};
class Gx {
  constructor(e, t, r) {
    (this.ast = t), (this.target = r), (this.isBound = !1), (this.s = void 0), (this.l = e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), Sr(this.ast, e, this), dn(this.ast, this.s, this, this.target), (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), V(this.ast, this.s, this, null) === this.target && dn(this.ast, this.s, this, null), ar(this.ast, this.s, this), (this.s = void 0));
  }
}
ni(!1)(Gx);
class J4 {
  constructor(e, t = !1) {
    (this.prevent = e), (this.capture = t);
  }
}
class fl {
  constructor(e, t, r, i, s) {
    (this.ast = t), (this.target = r), (this.targetEvent = i), (this.isBound = !1), (this.self = !1), (this.boundFn = !0), (this.l = e), (this.ut = s);
  }
  callSource(e) {
    const t = this.s.overrideContext;
    t.$event = e;
    let r = V(this.ast, this.s, this, null);
    return delete t.$event, qn(r) && (r = r(e)), r !== !0 && this.ut.prevent && e.preventDefault(), r;
  }
  handleEvent(e) {
    (this.self && this.target !== e.composedPath()[0]) || this.callSource(e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), Sr(this.ast, e, this), this.target.addEventListener(this.targetEvent, this, this.ut), (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), ar(this.ast, this.s, this), (this.s = void 0), this.target.removeEventListener(this.targetEvent, this, this.ut));
  }
}
Mo(fl);
wa(fl, () => 'callSource');
ni(!0, !0)(fl);
const Jn = /* @__PURE__ */ Dt('IViewFactory');
class Md {
  constructor(e, t) {
    (this.isCaching = !1), (this.ft = null), (this.dt = -1), (this.name = t.name), (this.container = e), (this.def = t);
  }
  setCacheSize(e, t) {
    e && (e === '*' ? (e = Md.maxCacheSize) : vt(e) && (e = parseInt(e, 10)), (this.dt === -1 || !t) && (this.dt = e)), this.dt > 0 ? (this.ft = []) : (this.ft = null), (this.isCaching = this.dt > 0);
  }
  canReturnToCache(e) {
    return this.ft != null && this.ft.length < this.dt;
  }
  tryReturnToCache(e) {
    return this.canReturnToCache(e) ? (this.ft.push(e), !0) : !1;
  }
  create(e) {
    const t = this.ft;
    let r;
    return t != null && t.length > 0 ? ((r = t.pop()), r) : ((r = sr.$view(this, e)), r);
  }
}
Md.maxCacheSize = 65535;
const Hx = /* @__PURE__ */ Dt('IAuSlotsInfo');
class Kx {
  constructor(e) {
    this.projectedSlots = e;
  }
}
const Q4 = /* @__PURE__ */ Dt('IAuSlotWatcher');
var Gm;
(function (n) {
  (n.hydrateElement = 'ra'),
    (n.hydrateAttribute = 'rb'),
    (n.hydrateTemplateController = 'rc'),
    (n.hydrateLetElement = 'rd'),
    (n.setProperty = 're'),
    (n.interpolation = 'rf'),
    (n.propertyBinding = 'rg'),
    (n.letBinding = 'ri'),
    (n.refBinding = 'rj'),
    (n.iteratorBinding = 'rk'),
    (n.multiAttr = 'rl'),
    (n.textBinding = 'ha'),
    (n.listenerBinding = 'hb'),
    (n.attributeBinding = 'hc'),
    (n.stylePropertyBinding = 'hd'),
    (n.setAttribute = 'he'),
    (n.setClassAttribute = 'hf'),
    (n.setStyleAttribute = 'hg'),
    (n.spreadBinding = 'hs'),
    (n.spreadElementProp = 'hp');
})(Gm || (Gm = {}));
const _o = /* @__PURE__ */ Dt('Instruction');
class hl {
  constructor(e, t, r) {
    (this.from = e), (this.to = t), (this.mode = r), (this.type = 'rg');
  }
}
class Y4 {
  constructor(e, t, r) {
    (this.forOf = e), (this.to = t), (this.props = r), (this.type = 'rk');
  }
}
class X4 {
  constructor(e, t) {
    (this.from = e), (this.to = t), (this.type = 'rj');
  }
}
class Z4 {
  constructor(e, t, r) {
    (this.value = e), (this.to = t), (this.command = r), (this.type = 'rl');
  }
}
class qx {
  constructor(e, t, r, i) {
    (this.from = e), (this.to = t), (this.preventDefault = r), (this.capture = i), (this.type = 'hb');
  }
}
class by {
  constructor(e, t, r) {
    (this.attr = e), (this.from = t), (this.to = r), (this.type = 'hc');
  }
}
class e8 {
  constructor() {
    this.type = 'hs';
  }
}
const Wx = /* @__PURE__ */ Dt('ITemplateCompiler'),
  Jx = /* @__PURE__ */ Dt('IRenderer');
function Ut(n) {
  return function (t) {
    return (
      (t.register = function (r) {
        So(Jx, this).register(r);
      }),
      r4(t.prototype, 'target', {
        configurable: !0,
        get: function () {
          return n;
        },
      }),
      t
    );
  };
}
function Fi(n, e, t) {
  return vt(e) ? n.parse(e, t) : e;
}
function _d(n) {
  return n.viewModel != null ? n.viewModel : n;
}
function t8(n, e) {
  if (e === 'element') return n;
  switch (e) {
    case 'controller':
      return Xs(n);
    case 'view':
      throw re('AUR0750');
    case 'view-model':
      return Xs(n).viewModel;
    default: {
      const t = Nx(n, e);
      if (t !== void 0) return t.viewModel;
      const r = Xs(n, {
        name: e,
      });
      if (r === void 0) throw re(`AUR0751:${e}`);
      return r.viewModel;
    }
  }
}
let Hm = class {
  render(e, t, r) {
    const i = _d(t);
    i.$observers?.[r.to] !== void 0 ? i.$observers[r.to].setValue(r.value) : (i[r.to] = r.value);
  }
};
Hm = X([Ut('re')], Hm);
let Km = class {
  static get inject() {
    return [Ta];
  }
  constructor(e) {
    this.r = e;
  }
  render(e, t, r, i, s, a) {
    let o, u, l, p;
    const h = r.res,
      b = r.projections,
      E = e.container;
    switch (typeof h) {
      case 'string':
        if (((o = E.find(Qa, h)), o == null)) throw re(`AUR0752:${h}@${e.name}`);
        break;
      default:
        o = h;
    }
    const T = r.containerless || o.containerless ? py(t) : null,
      w = a8(i, e, t, r, T, b == null ? void 0 : new Kx(Sx(b)));
    (u = o.Type), (l = w.invoke(u)), xt(w, u, new nn(o.key, l)), (p = sr.$el(w, l, t, r, o, T)), gn(t, o.key, p);
    const _ = this.r.renderers,
      k = r.props,
      D = k.length;
    let N = 0,
      B;
    for (; D > N; ) (B = k[N]), _[B.type].render(e, p, B, i, s, a), ++N;
    e.addChild(p);
  }
};
Km = X([Ut('ra')], Km);
let qm = class {
  static get inject() {
    return [Ta];
  }
  constructor(e) {
    this.r = e;
  }
  render(e, t, r, i, s, a) {
    let o = e.container,
      u;
    switch (typeof r.res) {
      case 'string':
        if (((u = o.find(cy, r.res)), u == null)) throw re(`AUR0753:${r.res}@${e.name}`);
        break;
      default:
        u = r.res;
    }
    const l = Zx(i, u, e, t, r, void 0, void 0),
      p = sr.$attr(l.ctn, l.vm, t, u);
    gn(t, u.key, p);
    const h = this.r.renderers,
      b = r.props,
      E = b.length;
    let x = 0,
      T;
    for (; E > x; ) (T = b[x]), h[T.type].render(e, p, T, i, s, a), ++x;
    e.addChild(p);
  }
};
qm = X([Ut('rb')], qm);
let Wm = class {
  static get inject() {
    return [Ta, Ni];
  }
  constructor(e, t) {
    (this.r = e), (this.p = t);
  }
  render(e, t, r, i, s, a) {
    let o = e.container,
      u;
    switch (typeof r.res) {
      case 'string':
        if (((u = o.find(cy, r.res)), u == null)) throw re(`AUR0754:${r.res}@${e.name}`);
        break;
      default:
        u = r.res;
    }
    const l = this.r.getViewFactory(r.def, o),
      p = py(t),
      h = Zx(this.p, u, e, t, r, l, p),
      b = sr.$attr(h.ctn, h.vm, t, u);
    gn(p, u.key, b), h.vm.link?.(e, b, t, r);
    const E = this.r.renderers,
      x = r.props,
      T = x.length;
    let w = 0,
      _;
    for (; T > w; ) (_ = x[w]), E[_.type].render(e, b, _, i, s, a), ++w;
    e.addChild(b);
  }
};
Wm = X([Ut('rc')], Wm);
let Jm = class {
  render(e, t, r, i, s, a) {
    t.remove();
    const o = r.instructions,
      u = r.toBindingContext,
      l = e.container,
      p = o.length;
    let h,
      b,
      E = 0;
    for (; p > E; ) (h = o[E]), (b = Fi(s, h.from, 16)), e.addBinding(new pl(l, a, b, h.to, u)), ++E;
  }
};
Jm = X([Ut('rd')], Jm);
let Qm = class {
  render(e, t, r, i, s) {
    e.addBinding(new Gx(e.container, Fi(s, r.from, 16), t8(t, r.to)));
  }
};
Qm = X([Ut('rj')], Qm);
let Ym = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new q4(e, e.container, a, i.domWriteQueue, Fi(s, r.from, 1), _d(t), r.to, 2));
  }
};
Ym = X([Ut('rf')], Ym);
let Xm = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Di(e, e.container, a, i.domWriteQueue, Fi(s, r.from, 16), _d(t), r.to, r.mode));
  }
};
Xm = X([Ut('rg')], Xm);
let Zm = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Di(e, e.container, a, i.domWriteQueue, Fi(s, r.forOf, 2), _d(t), r.to, 2));
  }
};
Zm = X([Ut('rk')], Zm);
let eb = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new dl(e, e.container, a, i.domWriteQueue, i, Fi(s, r.from, 16), C4(t.parentNode, E4(i, ''), t), r.strict));
  }
};
eb = X([Ut('ha')], eb);
let tb = class {
  render(e, t, r, i, s) {
    e.addBinding(new fl(e.container, Fi(s, r.from, 8), t, r.to, new J4(r.preventDefault, r.capture)));
  }
};
tb = X([Ut('hb')], tb);
let nb = class {
  render(e, t, r) {
    t.setAttribute(r.to, r.value);
  }
};
nb = X([Ut('he')], nb);
let rb = class {
  render(e, t, r) {
    r8(t.classList, r.value);
  }
};
rb = X([Ut('hf')], rb);
let ib = class {
  render(e, t, r) {
    t.style.cssText += r.value;
  }
};
ib = X([Ut('hg')], ib);
let sb = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Di(e, e.container, a, i.domWriteQueue, Fi(s, r.from, 16), t.style, r.to, 2));
  }
};
sb = X([Ut('hd')], sb);
let ab = class {
  render(e, t, r, i, s, a) {
    const o = e.container,
      u = o.has(Nm, !1) ? o.get(Nm) : null;
    e.addBinding(
      new ll(
        e,
        o,
        a,
        i.domWriteQueue,
        Fi(s, r.from, 16),
        t,
        r.attr,
        u == null
          ? r.to
          : r.to
              .split(/\s/g)
              .map((l) => u[l] ?? l)
              .join(' '),
        2,
      ),
    );
  }
};
ab = X([Ut('hc')], ab);
let ob = class {
  static get inject() {
    return [Wx, Ta];
  }
  constructor(e, t) {
    (this.xt = e), (this.r = t);
  }
  render(e, t, r, i, s, a) {
    const u = e.container.get(Nc),
      l = this.r.renderers,
      p = (b) => {
        let E = b,
          x = u;
        for (; x != null && E > 0; ) (x = x.parent), --E;
        if (x == null) throw re('No scope context for spread binding.');
        return x;
      },
      h = (b) => {
        const E = p(b),
          x = i8(E),
          T = this.xt.compileSpread(E.controller.definition, E.instruction?.captures ?? Fe, E.controller.container, t);
        let w;
        for (w of T)
          switch (w.type) {
            case 'hs':
              h(b + 1);
              break;
            case 'hp':
              l[w.instructions.type].render(x, Xs(t), w.instructions, i, s, a);
              break;
            default:
              l[w.type].render(x, t, w, i, s, a);
          }
        e.addBinding(x);
      };
    h(0);
  }
};
ob = X([Ut('hs')], ob);
class n8 {
  get container() {
    return this.locator;
  }
  get definition() {
    return this.ctrl.definition;
  }
  get isStrictBinding() {
    return this.ctrl.isStrictBinding;
  }
  get state() {
    return this.ctrl.state;
  }
  constructor(e, t) {
    (this.wt = e), (this.yt = t), (this.isBound = !1), (this.ctrl = t.controller), (this.locator = this.ctrl.container);
  }
  get(e) {
    return this.locator.get(e);
  }
  bind(e) {
    if (this.isBound) return;
    this.isBound = !0;
    const t = (this.scope = this.yt.controller.scope.parent ?? void 0);
    if (t == null) throw re('Invalid spreading. Context scope is null/undefined');
    this.wt.forEach((r) => r.bind(t));
  }
  unbind() {
    this.wt.forEach((e) => e.unbind()), (this.isBound = !1);
  }
  addBinding(e) {
    this.wt.push(e);
  }
  addChild(e) {
    if (e.vmKind !== 1) throw re('Spread binding does not support spreading custom attributes/template controllers');
    this.ctrl.addChild(e);
  }
}
function r8(n, e) {
  const t = e.length;
  let r = 0;
  for (let i = 0; i < t; ++i) e.charCodeAt(i) === 32 ? (i !== r && n.add(e.slice(r, i)), (r = i + 1)) : i + 1 === t && n.add(e.slice(r));
}
const i8 = (n) => new n8([], n),
  Qx = 'IController',
  Yx = 'IInstruction',
  s8 = 'IRenderLocation',
  gy = 'ISlotsInfo';
function a8(n, e, t, r, i, s) {
  const a = e.container.createChild();
  return (
    xt(a, n.HTMLElement, xt(a, n.Element, xt(a, ro, new nn('ElementResolver', t)))),
    xt(a, Rd, new nn(Qx, e)),
    xt(a, _o, new nn(Yx, r)),
    xt(a, Cn, i == null ? t1 : new e1(i)),
    xt(a, Jn, n1),
    xt(a, Hx, s == null ? r1 : new nn(gy, s)),
    a
  );
}
class Xx {
  get $isResolver() {
    return !0;
  }
  constructor(e) {
    this.f = e;
  }
  resolve() {
    const e = this.f;
    if (e === null) throw re('AUR7055');
    if (!vt(e.name) || e.name.length === 0) throw re('AUR0756');
    return e;
  }
}
function Zx(n, e, t, r, i, s, a, o) {
  const u = t.container.createChild();
  return (
    xt(u, n.HTMLElement, xt(u, n.Element, xt(u, ro, new nn('ElementResolver', r)))),
    (t = t instanceof sr ? t : t.ctrl),
    xt(u, Rd, new nn(Qx, t)),
    xt(u, _o, new nn(Yx, i)),
    xt(u, Cn, a == null ? t1 : new nn(s8, a)),
    xt(u, Jn, s == null ? n1 : new Xx(s)),
    xt(u, Hx, o == null ? r1 : new nn(gy, o)),
    {
      vm: u.invoke(e.Type),
      ctn: u,
    }
  );
}
class e1 {
  get name() {
    return 'IRenderLocation';
  }
  get $isResolver() {
    return !0;
  }
  constructor(e) {
    this.l = e;
  }
  resolve() {
    return this.l;
  }
}
const t1 = new e1(null),
  n1 = new Xx(null),
  r1 = new nn(gy, new Kx(Fe)),
  Ta = /* @__PURE__ */ Dt('IRendering', (n) => n.singleton(i1));
class i1 {
  get renderers() {
    return this.kt ?? (this.kt = this.At.getAll(Jx, !1).reduce((e, t) => ((e[t.target] = t), e), Vn()));
  }
  constructor(e) {
    (this.Ct = /* @__PURE__ */ new WeakMap()), (this.Rt = /* @__PURE__ */ new WeakMap());
    const t = e.root;
    (this.p = (this.At = t).get(Ni)), (this.ep = t.get(Kh)), (this.oL = t.get(ga)), (this.Bt = new Op(this.p, this.p.document.createDocumentFragment()));
  }
  compile(e, t, r) {
    if (e.needsCompile !== !1) {
      const i = this.Ct,
        s = t.get(Wx);
      let a = i.get(e);
      return a == null ? i.set(e, (a = s.compile(e, t, r))) : t.register(...a.dependencies), a;
    }
    return e;
  }
  getViewFactory(e, t) {
    return new Md(t, Lr.getOrCreate(e));
  }
  createNodes(e) {
    if (e.enhance === !0) return new Op(this.p, e.template);
    let t,
      r = !1;
    const i = this.Rt,
      s = this.p,
      a = s.document;
    if (i.has(e)) t = i.get(e);
    else {
      const o = e.template;
      let u;
      o === null
        ? (t = null)
        : o instanceof s.Node
        ? o.nodeName === 'TEMPLATE'
          ? ((t = o.content), (r = !0))
          : (t = a.createDocumentFragment()).appendChild(o.cloneNode(!0))
        : ((u = a.createElement('template')), vt(o) && (u.innerHTML = o), (t = u.content), (r = !0)),
        i.set(e, t);
    }
    return t == null ? this.Bt : new Op(this.p, r ? a.importNode(t, !0) : a.adoptNode(t.cloneNode(!0)));
  }
  render(e, t, r, i) {
    const s = r.instructions,
      a = this.renderers,
      o = t.length;
    if (t.length !== s.length) throw re(`AUR0757:${o}<>${s.length}`);
    let u = 0,
      l = 0,
      p = 0,
      h,
      b,
      E;
    if (o > 0)
      for (; o > u; ) {
        for (h = s[u], E = t[u], l = 0, p = h.length; p > l; ) (b = h[l]), a[b.type].render(e, E, b, this.p, this.ep, this.oL), ++l;
        ++u;
      }
    if (i != null && ((h = r.surrogates), (p = h.length) > 0)) for (l = 0; p > l; ) (b = h[l]), a[b.type].render(e, i, b, this.p, this.ep, this.oL), ++l;
  }
}
i1.inject = [xo];
var ub;
(function (n) {
  (n[(n.none = 0)] = 'none'), (n[(n.host = 1)] = 'host'), (n[(n.shadowRoot = 2)] = 'shadowRoot'), (n[(n.location = 3)] = 'location');
})(ub || (ub = {}));
const o8 = {
    optional: !0,
  },
  qi = /* @__PURE__ */ new WeakMap();
class sr {
  get lifecycleHooks() {
    return this.St;
  }
  get isActive() {
    return (this.state & 3) > 0 && (this.state & 4) === 0;
  }
  get name() {
    if (this.parent === null)
      switch (this.vmKind) {
        case 1:
          return `[${this.definition.name}]`;
        case 0:
          return this.definition.name;
        case 2:
          return this.viewFactory.name;
      }
    switch (this.vmKind) {
      case 1:
        return `${this.parent.name}>[${this.definition.name}]`;
      case 0:
        return `${this.parent.name}>${this.definition.name}`;
      case 2:
        return this.viewFactory.name === this.parent.definition?.name ? `${this.parent.name}[view]` : `${this.parent.name}[view:${this.viewFactory.name}]`;
    }
  }
  get hooks() {
    return this._t;
  }
  get viewModel() {
    return this.It;
  }
  set viewModel(e) {
    (this.It = e), (this._t = e == null || this.vmKind === 2 ? Ha.none : new Ha(e));
  }
  constructor(e, t, r, i, s, a, o) {
    (this.container = e),
      (this.vmKind = t),
      (this.definition = r),
      (this.viewFactory = i),
      (this.host = a),
      (this.head = null),
      (this.tail = null),
      (this.next = null),
      (this.parent = null),
      (this.bindings = null),
      (this.children = null),
      (this.hasLockedScope = !1),
      (this.isStrictBinding = !1),
      (this.scope = null),
      (this.isBound = !1),
      (this.hostController = null),
      (this.mountTarget = 0),
      (this.shadowRoot = null),
      (this.nodes = null),
      (this.location = null),
      (this.St = null),
      (this.state = 0),
      (this.Tt = !1),
      (this.$initiator = null),
      (this.$resolve = void 0),
      (this.$reject = void 0),
      (this.$promise = void 0),
      (this.Et = 0),
      (this.Pt = 0),
      (this.Lt = 0),
      (this.It = s),
      (this._t = t === 2 ? Ha.none : new Ha(s)),
      (this.location = o),
      (this.r = e.root.get(Ta));
  }
  static getCached(e) {
    return qi.get(e);
  }
  static getCachedOrThrow(e) {
    const t = sr.getCached(e);
    if (t === void 0) throw re(`AUR0500:${e}`);
    return t;
  }
  static $el(e, t, r, i, s = void 0, a = null) {
    if (qi.has(t)) return qi.get(t);
    s = s ?? Ff(t.constructor);
    const o = new sr(e, 0, s, null, t, r, a),
      u = e.get(Dv(Nc));
    return s.dependencies.length > 0 && e.register(...s.dependencies), xt(e, Nc, new nn('IHydrationContext', new d8(o, i, u))), qi.set(t, o), (i == null || i.hydrate !== !1) && o.hE(i, u), o;
  }
  static $attr(e, t, r, i) {
    if (qi.has(t)) return qi.get(t);
    i = i ?? Bf(t.constructor);
    const s = new sr(e, 1, i, null, t, r, null);
    return i.dependencies.length > 0 && e.register(...i.dependencies), qi.set(t, s), s.Mt(), s;
  }
  static $view(e, t = void 0) {
    const r = new sr(e.container, 2, null, e, null, null, null);
    return (r.parent = t ?? null), r.Dt(), r;
  }
  hE(e, t) {
    const r = this.container,
      i = this.It;
    let s = this.definition;
    if (((this.scope = an.create(i, null, !0)), s.watches.length > 0 && db(this, r, s, i), lb(this, s, i), this._t.hasDefine)) {
      const a = i.define(this, t, s);
      a !== void 0 && a !== s && (s = Lr.getOrCreate(a));
    }
    (this.St = Vm.resolve(r)), s.register(r), s.injectable !== null && xt(r, s.injectable, new nn('definition.injectable', i)), (e == null || e.hydrate !== !1) && (this.hS(e), this.hC());
  }
  hS(e) {
    this.St.hydrating != null && this.St.hydrating.forEach(f8, this), this._t.hasHydrating && this.It.hydrating(this);
    const t = (this.$t = this.r.compile(this.definition, this.container, e)),
      { shadowOptions: r, isStrictBinding: i, hasSlots: s, containerless: a } = t;
    let o = this.location;
    if (
      ((this.isStrictBinding = i),
      (this.hostController = Xs(this.host, o8)) !== null &&
        ((this.host = this.container.root.get(Ni).document.createElement(this.definition.name)), a && o == null && (o = this.location = py(this.host))),
      gn(this.host, Wt, this),
      gn(this.host, this.definition.key, this),
      r !== null || s)
    ) {
      if (o != null) throw re('AUR0501');
      gn((this.shadowRoot = this.host.attachShadow(r ?? c8)), Wt, this), gn(this.shadowRoot, this.definition.key, this), (this.mountTarget = 2);
    } else o != null ? (gn(o, Wt, this), gn(o, this.definition.key, this), (this.mountTarget = 3)) : (this.mountTarget = 1);
    (this.It.$controller = this), (this.nodes = this.r.createNodes(t)), this.St.hydrated !== void 0 && this.St.hydrated.forEach(h8, this), this._t.hasHydrated && this.It.hydrated(this);
  }
  hC() {
    this.r.render(this, this.nodes.findTargets(), this.$t, this.host), this.St.created !== void 0 && this.St.created.forEach(yb, this), this._t.hasCreated && this.It.created(this);
  }
  Mt() {
    const e = this.definition,
      t = this.It;
    e.watches.length > 0 && db(this, this.container, e, t),
      lb(this, e, t),
      (t.$controller = this),
      (this.St = Vm.resolve(this.container)),
      this.St.created !== void 0 && this.St.created.forEach(yb, this),
      this._t.hasCreated && this.It.created(this);
  }
  Dt() {
    (this.$t = this.r.compile(this.viewFactory.def, this.container, null)),
      (this.isStrictBinding = this.$t.isStrictBinding),
      this.r.render(this, (this.nodes = this.r.createNodes(this.$t)).findTargets(), this.$t, void 0);
  }
  activate(e, t, r) {
    switch (this.state) {
      case 0:
      case 8:
        if (!(t === null || t.isActive)) return;
        this.state = 1;
        break;
      case 2:
        return;
      case 32:
        throw re(`AUR0502:${this.name}`);
      default:
        throw re(`AUR0503:${this.name} ${hb(this.state)}`);
    }
    switch (((this.parent = t), this.vmKind)) {
      case 0:
        this.scope.parent = r ?? null;
        break;
      case 1:
        this.scope = r ?? null;
        break;
      case 2:
        if (r == null) throw re('AUR0504');
        this.hasLockedScope || (this.scope = r);
        break;
    }
    this.isStrictBinding, (this.$initiator = e), this.Ut();
    let i;
    return (
      this.vmKind !== 2 && this.St.binding != null && (i = Kt(...this.St.binding.map(y8, this))),
      this._t.hasBinding && (i = Kt(i, this.It.binding(this.$initiator, this.parent))),
      tn(i)
        ? (this.qt(),
          i
            .then(() => {
              this.bind();
            })
            .catch((s) => {
              this.Ft(s);
            }),
          this.$promise)
        : (this.bind(), this.$promise)
    );
  }
  bind() {
    let e = 0,
      t = 0,
      r;
    if (this.bindings !== null) for (e = 0, t = this.bindings.length; t > e; ) this.bindings[e].bind(this.scope), ++e;
    if ((this.vmKind !== 2 && this.St.bound != null && (r = Kt(...this.St.bound.map(m8, this))), this._t.hasBound && (r = Kt(r, this.It.bound(this.$initiator, this.parent))), tn(r))) {
      this.qt(),
        r
          .then(() => {
            (this.isBound = !0), this.Ot();
          })
          .catch((i) => {
            this.Ft(i);
          });
      return;
    }
    (this.isBound = !0), this.Ot();
  }
  Ht(...e) {
    switch (this.mountTarget) {
      case 1:
        this.host.append(...e);
        break;
      case 2:
        this.shadowRoot.append(...e);
        break;
      case 3: {
        let t = 0;
        for (; t < e.length; ++t) this.location.parentNode.insertBefore(e[t], this.location);
        break;
      }
    }
  }
  Ot() {
    if (this.hostController !== null)
      switch (this.mountTarget) {
        case 1:
        case 2:
          this.hostController.Ht(this.host);
          break;
        case 3:
          this.hostController.Ht(this.location.$start, this.location);
          break;
      }
    switch (this.mountTarget) {
      case 1:
        this.nodes.appendTo(this.host, this.definition != null && this.definition.enhance);
        break;
      case 2: {
        const r = this.container;
        (r.has($m, !1) ? r.get($m) : r.get(R4)).applyTo(this.shadowRoot), this.nodes.appendTo(this.shadowRoot);
        break;
      }
      case 3:
        this.nodes.insertBefore(this.location);
        break;
    }
    let e = 0,
      t;
    if (
      (this.vmKind !== 2 && this.St.attaching != null && (t = Kt(...this.St.attaching.map(b8, this))),
      this._t.hasAttaching && (t = Kt(t, this.It.attaching(this.$initiator, this.parent))),
      tn(t) &&
        (this.qt(),
        this.Ut(),
        t
          .then(() => {
            this.Vt();
          })
          .catch((r) => {
            this.Ft(r);
          })),
      this.children !== null)
    )
      for (; e < this.children.length; ++e) this.children[e].activate(this.$initiator, this, this.scope);
    this.Vt();
  }
  deactivate(e, t) {
    switch (this.state & -17) {
      case 2:
        this.state = 4;
        break;
      case 0:
      case 8:
      case 32:
      case 40:
        return;
      default:
        throw re(`AUR0505:${this.name} ${hb(this.state)}`);
    }
    (this.$initiator = e), e === this && this.Nt();
    let r = 0,
      i;
    if (this.children !== null) for (r = 0; r < this.children.length; ++r) this.children[r].deactivate(e, this);
    if (
      (this.vmKind !== 2 && this.St.detaching != null && (i = Kt(...this.St.detaching.map(v8, this))),
      this._t.hasDetaching && (i = Kt(i, this.It.detaching(this.$initiator, this.parent))),
      tn(i) &&
        (this.qt(),
        e.Nt(),
        i
          .then(() => {
            e.jt();
          })
          .catch((s) => {
            e.Ft(s);
          })),
      e.head === null ? (e.head = this) : (e.tail.next = this),
      (e.tail = this),
      e === this)
    )
      return this.jt(), this.$promise;
  }
  removeNodes() {
    switch (this.vmKind) {
      case 0:
      case 2:
        this.nodes.remove(), this.nodes.unlink();
    }
    if (this.hostController !== null)
      switch (this.mountTarget) {
        case 1:
        case 2:
          this.host.remove();
          break;
        case 3:
          this.location.$start.remove(), this.location.remove();
          break;
      }
  }
  unbind() {
    let e = 0;
    if (this.bindings !== null) for (; e < this.bindings.length; ++e) this.bindings[e].unbind();
    switch (((this.parent = null), this.vmKind)) {
      case 1:
        this.scope = null;
        break;
      case 2:
        this.hasLockedScope || (this.scope = null), (this.state & 16) === 16 && !this.viewFactory.tryReturnToCache(this) && this.$initiator === this && this.dispose();
        break;
      case 0:
        this.scope.parent = null;
        break;
    }
    (this.state = 8), (this.$initiator = null), this.Wt();
  }
  qt() {
    this.$promise === void 0 &&
      ((this.$promise = new Promise((e, t) => {
        (this.$resolve = e), (this.$reject = t);
      })),
      this.$initiator !== this && this.parent.qt());
  }
  Wt() {
    this.$promise !== void 0 && ((Dp = this.$resolve), (this.$resolve = this.$reject = this.$promise = void 0), Dp(), (Dp = void 0));
  }
  Ft(e) {
    this.$promise !== void 0 && ((Fp = this.$reject), (this.$resolve = this.$reject = this.$promise = void 0), Fp(e), (Fp = void 0)), this.$initiator !== this && this.parent.Ft(e);
  }
  Ut() {
    ++this.Et, this.$initiator !== this && this.parent.Ut();
  }
  Vt() {
    if (--this.Et === 0) {
      if ((this.vmKind !== 2 && this.St.attached != null && (Vs = Kt(...this.St.attached.map(g8, this))), this._t.hasAttached && (Vs = Kt(Vs, this.It.attached(this.$initiator))), tn(Vs))) {
        this.qt(),
          Vs.then(() => {
            (this.state = 2), this.Wt(), this.$initiator !== this && this.parent.Vt();
          }).catch((e) => {
            this.Ft(e);
          }),
          (Vs = void 0);
        return;
      }
      (Vs = void 0), (this.state = 2), this.Wt();
    }
    this.$initiator !== this && this.parent.Vt();
  }
  Nt() {
    ++this.Pt;
  }
  jt() {
    if (--this.Pt === 0) {
      this.zt(), this.removeNodes();
      let e = this.$initiator.head,
        t;
      for (; e !== null; )
        e !== this && (e.debug && e.logger.trace('detach()'), e.removeNodes()),
          e.vmKind !== 2 && e.St.unbinding != null && (t = Kt(...e.St.unbinding.map(x8, this))),
          e._t.hasUnbinding && (e.debug && e.logger.trace('unbinding()'), (t = Kt(t, e.viewModel.unbinding(e.$initiator, e.parent)))),
          tn(t) &&
            (this.qt(),
            this.zt(),
            t
              .then(() => {
                this.Gt();
              })
              .catch((r) => {
                this.Ft(r);
              })),
          (t = void 0),
          (e = e.next);
      this.Gt();
    }
  }
  zt() {
    ++this.Lt;
  }
  Gt() {
    if (--this.Lt === 0) {
      let e = this.$initiator.head,
        t = null;
      for (; e !== null; ) e !== this && ((e.isBound = !1), e.unbind()), (t = e.next), (e.next = null), (e = t);
      (this.head = this.tail = null), (this.isBound = !1), this.unbind();
    }
  }
  addBinding(e) {
    this.bindings === null ? (this.bindings = [e]) : (this.bindings[this.bindings.length] = e);
  }
  addChild(e) {
    this.children === null ? (this.children = [e]) : (this.children[this.children.length] = e);
  }
  is(e) {
    switch (this.vmKind) {
      case 1:
        return Bf(this.It.constructor).name === e;
      case 0:
        return Ff(this.It.constructor).name === e;
      case 2:
        return this.viewFactory.name === e;
    }
  }
  lockScope(e) {
    (this.scope = e), (this.hasLockedScope = !0);
  }
  setHost(e) {
    return this.vmKind === 0 && (gn(e, Wt, this), gn(e, this.definition.key, this)), (this.host = e), (this.mountTarget = 1), this;
  }
  setShadowRoot(e) {
    return this.vmKind === 0 && (gn(e, Wt, this), gn(e, this.definition.key, this)), (this.shadowRoot = e), (this.mountTarget = 2), this;
  }
  setLocation(e) {
    return this.vmKind === 0 && (gn(e, Wt, this), gn(e, this.definition.key, this)), (this.location = e), (this.mountTarget = 3), this;
  }
  release() {
    this.state |= 16;
  }
  dispose() {
    (this.state & 32) !== 32 &&
      ((this.state |= 32),
      this._t.hasDispose && this.It.dispose(),
      this.children !== null && (this.children.forEach(p8), (this.children = null)),
      (this.hostController = null),
      (this.scope = null),
      (this.nodes = null),
      (this.location = null),
      (this.viewFactory = null),
      this.It !== null && (qi.delete(this.It), (this.It = null)),
      (this.It = null),
      (this.host = null),
      (this.shadowRoot = null),
      this.container.disposeResolvers());
  }
  accept(e) {
    if (e(this) === !0 || (this._t.hasAccept && this.It.accept(e) === !0)) return !0;
    if (this.children !== null) {
      const { children: t } = this;
      for (let r = 0, i = t.length; r < i; ++r) if (t[r].accept(e) === !0) return !0;
    }
  }
}
function u8(n) {
  let e = n.$observers;
  return (
    e === void 0 &&
      Reflect.defineProperty(n, '$observers', {
        enumerable: !1,
        value: (e = {}),
      }),
    e
  );
}
function lb(n, e, t) {
  const r = e.bindables,
    i = Cx(r),
    s = i.length;
  if (s > 0) {
    let a,
      o,
      u = 0;
    const l = u8(t),
      p = n.container,
      h = p.has(em, !0) ? p.get(em) : null;
    for (; u < s; ++u) (a = i[u]), l[a] === void 0 && ((o = r[a]), (l[a] = new Rx(t, a, o.callback, o.set, n, h)));
  }
}
const cb = /* @__PURE__ */ new Map(),
  l8 = (n) => {
    let e = cb.get(n);
    return e == null && ((e = new ec(n, 0)), cb.set(n, e)), e;
  };
function db(n, e, t, r) {
  const i = e.get(ga),
    s = e.get(Kh),
    a = t.watches,
    o = n.vmKind === 0 ? n.scope : an.create(r, null, !0),
    u = a.length;
  let l,
    p,
    h,
    b = 0;
  for (; u > b; ++b) {
    if ((({ expression: l, callback: p } = a[b]), (p = qn(p) ? p : Reflect.get(r, p)), !qn(p))) throw re(`AUR0506:${Co(p)}`);
    qn(l) ? n.addBinding(new jx(r, i, l, p, !0)) : ((h = vt(l) ? s.parse(l, 16) : l8(l)), n.addBinding(new yy(o, e, i, h, p)));
  }
}
class Ha {
  constructor(e) {
    (this.hasDefine = 'define' in e),
      (this.hasHydrating = 'hydrating' in e),
      (this.hasHydrated = 'hydrated' in e),
      (this.hasCreated = 'created' in e),
      (this.hasBinding = 'binding' in e),
      (this.hasBound = 'bound' in e),
      (this.hasAttaching = 'attaching' in e),
      (this.hasAttached = 'attached' in e),
      (this.hasDetaching = 'detaching' in e),
      (this.hasUnbinding = 'unbinding' in e),
      (this.hasDispose = 'dispose' in e),
      (this.hasAccept = 'accept' in e);
  }
}
Ha.none = new Ha({});
const c8 = {
  mode: 'open',
};
var pb;
(function (n) {
  (n[(n.customElement = 0)] = 'customElement'), (n[(n.customAttribute = 1)] = 'customAttribute'), (n[(n.synthetic = 2)] = 'synthetic');
})(pb || (pb = {}));
var fb;
(function (n) {
  (n[(n.none = 0)] = 'none'),
    (n[(n.activating = 1)] = 'activating'),
    (n[(n.activated = 2)] = 'activated'),
    (n[(n.deactivating = 4)] = 'deactivating'),
    (n[(n.deactivated = 8)] = 'deactivated'),
    (n[(n.released = 16)] = 'released'),
    (n[(n.disposed = 32)] = 'disposed');
})(fb || (fb = {}));
function hb(n) {
  const e = [];
  return (
    (n & 1) === 1 && e.push('activating'),
    (n & 2) === 2 && e.push('activated'),
    (n & 4) === 4 && e.push('deactivating'),
    (n & 8) === 8 && e.push('deactivated'),
    (n & 16) === 16 && e.push('released'),
    (n & 32) === 32 && e.push('disposed'),
    e.length === 0 ? 'none' : e.join('|')
  );
}
const Rd = /* @__PURE__ */ Dt('IController'),
  Nc = /* @__PURE__ */ Dt('IHydrationContext');
class d8 {
  constructor(e, t, r) {
    (this.instruction = t), (this.parent = r), (this.controller = e);
  }
}
function p8(n) {
  n.dispose();
}
function yb(n) {
  n.instance.created(this.It, this);
}
function f8(n) {
  n.instance.hydrating(this.It, this);
}
function h8(n) {
  n.instance.hydrated(this.It, this);
}
function y8(n) {
  return n.instance.binding(this.It, this.$initiator, this.parent);
}
function m8(n) {
  return n.instance.bound(this.It, this.$initiator, this.parent);
}
function b8(n) {
  return n.instance.attaching(this.It, this.$initiator, this.parent);
}
function g8(n) {
  return n.instance.attached(this.It, this.$initiator);
}
function v8(n) {
  return n.instance.detaching(this.It, this.$initiator, this.parent);
}
function x8(n) {
  return n.instance.unbinding(this.It, this.$initiator, this.parent);
}
let Dp, Fp, Vs;
class vy {
  constructor(e, t, r, i) {
    if (((this.chars = e), (this.repeat = t), (this.isSymbol = r), (this.isInverted = i), i))
      switch (e.length) {
        case 0:
          this.has = this.ne;
          break;
        case 1:
          this.has = this.re;
          break;
        default:
          this.has = this.oe;
      }
    else
      switch (e.length) {
        case 0:
          this.has = this.le;
          break;
        case 1:
          this.has = this.he;
          break;
        default:
          this.has = this.ae;
      }
  }
  equals(e) {
    return this.chars === e.chars && this.repeat === e.repeat && this.isSymbol === e.isSymbol && this.isInverted === e.isInverted;
  }
  ae(e) {
    return this.chars.includes(e);
  }
  he(e) {
    return this.chars === e;
  }
  le(e) {
    return !1;
  }
  oe(e) {
    return !this.chars.includes(e);
  }
  re(e) {
    return this.chars !== e;
  }
  ne(e) {
    return !0;
  }
}
class w8 {
  constructor() {
    (this.parts = Fe), (this.ce = ''), (this.ue = {}), (this.fe = {});
  }
  get pattern() {
    const e = this.ce;
    return e === '' ? null : e;
  }
  set pattern(e) {
    e == null ? ((this.ce = ''), (this.parts = Fe)) : ((this.ce = e), (this.parts = this.fe[e]));
  }
  append(e, t) {
    const r = this.ue;
    r[e] === void 0 ? (r[e] = t) : (r[e] += t);
  }
  next(e) {
    const t = this.ue;
    let r;
    t[e] !== void 0 && ((r = this.fe), r[e] === void 0 ? (r[e] = [t[e]]) : r[e].push(t[e]), (t[e] = void 0));
  }
}
class xy {
  get ce() {
    return this.de ? this.me[0] : null;
  }
  constructor(e, ...t) {
    (this.charSpec = e), (this.ge = []), (this.pe = null), (this.de = !1), (this.me = t);
  }
  findChild(e) {
    const t = this.ge,
      r = t.length;
    let i = null,
      s = 0;
    for (; s < r; ++s) if (((i = t[s]), e.equals(i.charSpec))) return i;
    return null;
  }
  append(e, t) {
    const r = this.me;
    r.includes(t) || r.push(t);
    let i = this.findChild(e);
    return i == null && ((i = new xy(e, t)), this.ge.push(i), e.repeat && i.ge.push(i)), i;
  }
  findMatches(e, t) {
    const r = [],
      i = this.ge,
      s = i.length;
    let a = 0,
      o = null,
      u = 0,
      l = 0;
    for (; u < s; ++u)
      if (((o = i[u]), o.charSpec.has(e)))
        if ((r.push(o), (a = o.me.length), (l = 0), o.charSpec.isSymbol)) for (; l < a; ++l) t.next(o.me[l]);
        else for (; l < a; ++l) t.append(o.me[l], e);
    return r;
  }
}
class mb {
  constructor(e) {
    this.text = e;
    const t = (this.ve = e.length),
      r = (this.be = []);
    let i = 0;
    for (; t > i; ++i) r.push(new vy(e[i], !1, !1, !1));
  }
  eachChar(e) {
    const t = this.ve,
      r = this.be;
    let i = 0;
    for (; t > i; ++i) e(r[i]);
  }
}
class T8 {
  constructor(e) {
    (this.text = 'PART'), (this.xe = new vy(e, !0, !1, !0));
  }
  eachChar(e) {
    e(this.xe);
  }
}
class A8 {
  constructor(e) {
    (this.text = e), (this.xe = new vy(e, !1, !0, !1));
  }
  eachChar(e) {
    e(this.xe);
  }
}
class E8 {
  constructor() {
    (this.statics = 0), (this.dynamics = 0), (this.symbols = 0);
  }
}
const C8 = /* @__PURE__ */ Dt('ISyntaxInterpreter', (n) => n.singleton(S8));
class S8 {
  constructor() {
    (this.we = new xy(null)), (this.ye = [this.we]);
  }
  add(e) {
    e = e.slice(0).sort((b, E) => (b.pattern > E.pattern ? 1 : -1));
    const t = e.length;
    let r,
      i,
      s,
      a,
      o,
      u,
      l,
      p = 0,
      h;
    for (; t > p; ) {
      for (r = this.we, i = e[p], s = i.pattern, a = new E8(), o = this.ke(i, a), u = o.length, l = (b) => (r = r.append(b, s)), h = 0; u > h; ++h) o[h].eachChar(l);
      (r.pe = a), (r.de = !0), ++p;
    }
  }
  interpret(e) {
    const t = new w8(),
      r = e.length;
    let i = this.ye,
      s = 0,
      a;
    for (; s < r && ((i = this.Ae(i, e.charAt(s), t)), i.length !== 0); ++s);
    return (i = i.filter(M8)), i.length > 0 && (i.sort(_8), (a = i[0]), a.charSpec.isSymbol || t.next(a.ce), (t.pattern = a.ce)), t;
  }
  Ae(e, t, r) {
    const i = [];
    let s = null;
    const a = e.length;
    let o = 0;
    for (; o < a; ++o) (s = e[o]), i.push(...s.findMatches(t, r));
    return i;
  }
  ke(e, t) {
    const r = [],
      i = e.pattern,
      s = i.length,
      a = e.symbols;
    let o = 0,
      u = 0,
      l = '';
    for (; o < s; )
      (l = i.charAt(o)),
        a.length === 0 || !a.includes(l)
          ? o === u && l === 'P' && i.slice(o, o + 4) === 'PART'
            ? ((u = o = o + 4), r.push(new T8(a)), ++t.dynamics)
            : ++o
          : o !== u
          ? (r.push(new mb(i.slice(u, o))), ++t.statics, (u = o))
          : (r.push(new A8(i.slice(u, o + 1))), ++t.symbols, (u = ++o));
    return u !== o && (r.push(new mb(i.slice(u, o))), ++t.statics), r;
  }
}
function M8(n) {
  return n.de;
}
function _8(n, e) {
  const t = n.pe,
    r = e.pe;
  return t.statics !== r.statics ? r.statics - t.statics : t.dynamics !== r.dynamics ? r.dynamics - t.dynamics : t.symbols !== r.symbols ? r.symbols - t.symbols : 0;
}
class lr {
  constructor(e, t, r, i) {
    (this.rawName = e), (this.rawValue = t), (this.target = r), (this.command = i);
  }
}
const s1 = /* @__PURE__ */ Dt('IAttributePattern'),
  R8 = /* @__PURE__ */ Dt('IAttributeParser', (n) => n.singleton(a1));
class a1 {
  constructor(e, t) {
    (this.ft = {}), (this.Ce = e);
    const r = (this.me = {}),
      i = t.reduce((s, a) => {
        const o = o1(a.constructor);
        return o.forEach((u) => (r[u.pattern] = a)), s.concat(o);
      }, Fe);
    e.add(i);
  }
  parse(e, t) {
    let r = this.ft[e];
    r == null && (r = this.ft[e] = this.Ce.interpret(e));
    const i = r.pattern;
    return i == null ? new lr(e, t, e, null) : this.me[i][i](e, t, r.parts);
  }
}
a1.inject = [C8, Nv(s1)];
function Li(...n) {
  return function (t) {
    return I8.define(n, t);
  };
}
class P8 {
  constructor(e) {
    (this.Type = e), (this.name = void 0);
  }
  register(e) {
    So(s1, this.Type).register(e);
  }
}
const Lp = va('attribute-pattern'),
  ac = 'attribute-pattern-definitions',
  o1 = (n) => vo.annotation.get(n, ac),
  I8 = Bi({
    name: Lp,
    definitionAnnotationKey: ac,
    define(n, e) {
      const t = new P8(e);
      return Pt(Lp, t, e), xa(e, Lp), vo.annotation.set(e, ac, n), ry(e, ac), e;
    },
    getPatternDefinitions: o1,
  });
let bb = class {
  'PART.PART'(e, t, r) {
    return new lr(e, t, r[0], r[1]);
  }
  'PART.PART.PART'(e, t, r) {
    return new lr(e, t, `${r[0]}.${r[1]}`, r[2]);
  }
};
bb = X(
  [
    Li(
      {
        pattern: 'PART.PART',
        symbols: '.',
      },
      {
        pattern: 'PART.PART.PART',
        symbols: '.',
      },
    ),
  ],
  bb,
);
let gb = class {
  ref(e, t, r) {
    return new lr(e, t, 'element', 'ref');
  }
  'PART.ref'(e, t, r) {
    return new lr(e, t, r[0], 'ref');
  }
};
gb = X(
  [
    Li(
      {
        pattern: 'ref',
        symbols: '',
      },
      {
        pattern: 'PART.ref',
        symbols: '.',
      },
    ),
  ],
  gb,
);
let vb = class {
  ':PART'(e, t, r) {
    return new lr(e, t, r[0], 'bind');
  }
};
vb = X(
  [
    Li({
      pattern: ':PART',
      symbols: ':',
    }),
  ],
  vb,
);
let xb = class {
  '@PART'(e, t, r) {
    return new lr(e, t, r[0], 'trigger');
  }
};
xb = X(
  [
    Li({
      pattern: '@PART',
      symbols: '@',
    }),
  ],
  xb,
);
let wb = class {
  '...$attrs'(e, t, r) {
    return new lr(e, t, '', '...$attrs');
  }
};
wb = X(
  [
    Li({
      pattern: '...$attrs',
      symbols: '',
    }),
  ],
  wb,
);
var Tb;
(function (n) {
  (n[(n.None = 0)] = 'None'), (n[(n.IgnoreAttr = 1)] = 'IgnoreAttr');
})(Tb || (Tb = {}));
function jn(n) {
  return function (e) {
    return l1.define(n, e);
  };
}
class wy {
  constructor(e, t, r, i, s) {
    (this.Type = e), (this.name = t), (this.aliases = r), (this.key = i), (this.type = s);
  }
  static create(e, t) {
    let r, i;
    return (
      vt(e)
        ? ((r = e),
          (i = {
            name: r,
          }))
        : ((r = e.name), (i = e)),
      new wy(t, kn(oc(t, 'name'), r), Ft(oc(t, 'aliases'), i.aliases, t.aliases), u1(r), kn(oc(t, 'type'), i.type, t.type, null))
    );
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    So(r, t).register(e), al(r, t).register(e), ol(i, l1, r, e);
  }
}
const Zo = va('binding-command'),
  u1 = (n) => `${Zo}:${n}`,
  oc = (n, e) => En(Sn(e), n),
  l1 = Bi({
    name: Zo,
    keyFrom: u1,
    define(n, e) {
      const t = wy.create(n, e);
      return Pt(Zo, t, t.Type), Pt(Zo, t, t), xa(e, Zo), t.Type;
    },
    getAnnotation: oc,
  });
let Ab = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    let s = e.attr.target,
      a = e.attr.rawValue;
    return e.bindable == null ? (s = r.map(e.node, s) ?? Wn(s)) : (a === '' && e.def.type === 1 && (a = Wn(s)), (s = e.bindable.property)), new hl(t.parse(a, 16), s, 1);
  }
};
Ab = X([jn('one-time')], Ab);
let Eb = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    let s = e.attr.target,
      a = e.attr.rawValue;
    return e.bindable == null ? (s = r.map(e.node, s) ?? Wn(s)) : (a === '' && e.def.type === 1 && (a = Wn(s)), (s = e.bindable.property)), new hl(t.parse(a, 16), s, 2);
  }
};
Eb = X([jn('to-view')], Eb);
let Cb = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    const i = e.attr;
    let s = i.target,
      a = i.rawValue;
    return e.bindable == null ? (s = r.map(e.node, s) ?? Wn(s)) : (a === '' && e.def.type === 1 && (a = Wn(s)), (s = e.bindable.property)), new hl(t.parse(a, 16), s, 4);
  }
};
Cb = X([jn('from-view')], Cb);
let Sb = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    const i = e.attr;
    let s = i.target,
      a = i.rawValue;
    return e.bindable == null ? (s = r.map(e.node, s) ?? Wn(s)) : (a === '' && e.def.type === 1 && (a = Wn(s)), (s = e.bindable.property)), new hl(t.parse(a, 16), s, 6);
  }
};
Sb = X([jn('two-way')], Sb);
let Mb = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    const i = e.attr,
      s = e.bindable;
    let a,
      o,
      u = i.target,
      l = i.rawValue;
    return (
      s == null
        ? ((o = r.isTwoWay(e.node, u) ? 6 : 2), (u = r.map(e.node, u) ?? Wn(u)))
        : (l === '' && e.def.type === 1 && (l = Wn(u)), (a = e.def.defaultBindingMode), (o = s.mode === 8 || s.mode == null ? (a == null || a === 8 ? 2 : a) : s.mode), (u = s.property)),
      new hl(t.parse(l, 16), u, o)
    );
  }
};
Mb = X([jn('bind')], Mb);
let _b = class {
  get type() {
    return 0;
  }
  static get inject() {
    return [R8];
  }
  constructor(e) {
    this.Re = e;
  }
  build(e, t) {
    const r = e.bindable === null ? Wn(e.attr.target) : e.bindable.property,
      i = t.parse(e.attr.rawValue, 2);
    let s = Fe;
    if (i.semiIdx > -1) {
      const a = e.attr.rawValue.slice(i.semiIdx + 1),
        o = a.indexOf(':');
      if (o > -1) {
        const u = a.slice(0, o).trim(),
          l = a.slice(o + 1).trim(),
          p = this.Re.parse(u, l);
        s = [new Z4(l, p.target, p.command)];
      }
    }
    return new Y4(i, r, s);
  }
};
_b = X([jn('for')], _b);
let Rb = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new qx(t.parse(e.attr.rawValue, 8), e.attr.target, !0, !1);
  }
};
Rb = X([jn('trigger')], Rb);
let Pb = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new qx(t.parse(e.attr.rawValue, 8), e.attr.target, !1, !0);
  }
};
Pb = X([jn('capture')], Pb);
let Ib = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new by(e.attr.target, t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
Ib = X([jn('attr')], Ib);
let kb = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new by('style', t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
kb = X([jn('style')], kb);
let Ob = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new by('class', t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
Ob = X([jn('class')], Ob);
let Bb = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new X4(t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
Bb = X([jn('ref')], Bb);
let Nb = class {
  get type() {
    return 1;
  }
  build(e) {
    return new e8();
  }
};
Nb = X([jn('...$attrs')], Nb);
const k8 = /* @__PURE__ */ Dt('ISVGAnalyzer', (n) => n.singleton(O8));
class O8 {
  isStandardSvgAttribute(e, t) {
    return !1;
  }
}
var Db;
(function (n) {
  (n[(n.oneTime = 1)] = 'oneTime'), (n[(n.toView = 2)] = 'toView'), (n[(n.fromView = 4)] = 'fromView'), (n[(n.twoWay = 6)] = 'twoWay'), (n[(n.default = 8)] = 'default');
})(Db || (Db = {}));
const Fb = Vn();
class _u {
  static forNs(e) {
    return Fb[e] ?? (Fb[e] = new _u(e));
  }
  constructor(e) {
    (this.ns = e), (this.type = 6);
  }
  getValue(e, t) {
    return e.getAttributeNS(this.ns, t);
  }
  setValue(e, t, r) {
    e == null ? t.removeAttributeNS(this.ns, r) : t.setAttributeNS(this.ns, r, e);
  }
}
Sd(_u);
class c1 {
  constructor() {
    this.type = 6;
  }
  getValue(e, t) {
    return e.getAttribute(t);
  }
  setValue(e, t, r) {
    e == null ? t.removeAttribute(r) : t.setAttribute(r, e);
  }
}
Sd(c1);
const uc = new c1(),
  B8 = {
    childList: !0,
    subtree: !0,
    characterData: !0,
  };
function Lb(n, e) {
  return n === e;
}
class Ty {
  constructor(e, t, r, i) {
    (this.type = 7), (this.v = void 0), (this.ov = void 0), (this.j = !1), (this.Ee = void 0), (this.Pe = void 0), (this.iO = !1), (this.F = !1), (this.q = e), (this.oL = i), (this.cf = r);
  }
  getValue() {
    return this.iO ? this.v : this.q.multiple ? N8(this.q.options) : this.q.value;
  }
  setValue(e) {
    (this.ov = this.v), (this.v = e), (this.j = e !== this.ov), this.Le(e instanceof Array ? e : null), this.W();
  }
  W() {
    this.j && ((this.j = !1), this.syncOptions());
  }
  handleCollectionChange() {
    this.syncOptions();
  }
  syncOptions() {
    const e = this.v,
      t = this.q,
      r = Wr(e),
      i = t.matcher ?? Lb,
      s = t.options;
    let a = s.length;
    for (; a-- > 0; ) {
      const o = s[a],
        u = os.call(o, 'model') ? o.model : o.value;
      if (r) {
        o.selected = e.findIndex((l) => !!i(u, l)) !== -1;
        continue;
      }
      o.selected = !!i(u, e);
    }
  }
  syncValue() {
    const e = this.q,
      t = e.options,
      r = t.length,
      i = this.v;
    let s = 0;
    if (e.multiple) {
      if (!(i instanceof Array)) return !0;
      let u;
      const l = e.matcher || Lb,
        p = [];
      for (; s < r; ) (u = t[s]), u.selected && p.push(os.call(u, 'model') ? u.model : u.value), ++s;
      let h;
      for (s = 0; s < i.length; ) (h = i[s]), p.findIndex((b) => !!l(h, b)) === -1 ? i.splice(s, 1) : ++s;
      for (s = 0; s < p.length; ) (h = p[s]), i.findIndex((b) => !!l(h, b)) === -1 && i.push(h), ++s;
      return !1;
    }
    let a = null,
      o;
    for (; s < r; ) {
      if (((o = t[s]), o.selected)) {
        a = os.call(o, 'model') ? o.model : o.value;
        break;
      }
      ++s;
    }
    return (this.ov = this.v), (this.v = a), !0;
  }
  O() {
    (this.Pe = dy(this.q, this.Me.bind(this))).observe(this.q, B8), this.Le(this.v instanceof Array ? this.v : null), (this.iO = !0);
  }
  H() {
    this.Pe.disconnect(), this.Ee?.unsubscribe(this), (this.Pe = this.Ee = void 0), (this.iO = !1);
  }
  Le(e) {
    if ((this.Ee?.unsubscribe(this), (this.Ee = void 0), e != null)) {
      if (!this.q.multiple) throw re('AUR0654');
      (this.Ee = this.oL.getArrayObserver(e)).subscribe(this);
    }
  }
  handleEvent() {
    this.syncValue() && this.it();
  }
  Me(e) {
    this.syncOptions(), this.syncValue() && this.it();
  }
  it() {
    ($b = this.ov), (this.ov = this.v), this.subs.notify(this.v, $b);
  }
}
fy(Ty);
Ln(Ty);
function N8(n) {
  const e = [];
  if (n.length === 0) return e;
  const t = n.length;
  let r = 0,
    i;
  for (; t > r; ) (i = n[r]), i.selected && (e[e.length] = os.call(i, 'model') ? i.model : i.value), ++r;
  return e;
}
let $b;
const D8 = '--';
class d1 {
  constructor(e) {
    (this.obj = e), (this.type = 6), (this.v = ''), (this.ov = ''), (this.styles = {}), (this.version = 0), (this.j = !1);
  }
  getValue() {
    return this.obj.style.cssText;
  }
  setValue(e) {
    (this.v = e), (this.j = e !== this.ov), this.W();
  }
  De(e) {
    const t = [],
      r = /url\([^)]+$/;
    let i = 0,
      s = '',
      a,
      o,
      u,
      l;
    for (; i < e.length; ) {
      if (((a = e.indexOf(';', i)), a === -1 && (a = e.length), (s += e.substring(i, a)), (i = a + 1), r.test(s))) {
        s += ';';
        continue;
      }
      (o = s.indexOf(':')), (u = s.substring(0, o).trim()), (l = s.substring(o + 1).trim()), t.push([u, l]), (s = '');
    }
    return t;
  }
  $e(e) {
    let t, r;
    const i = [];
    for (r in e)
      if (((t = e[r]), t != null)) {
        if (vt(t)) {
          if (r.startsWith(D8)) {
            i.push([r, t]);
            continue;
          }
          i.push([Rv(r), t]);
          continue;
        }
        i.push(...this.Ue(t));
      }
    return i;
  }
  qe(e) {
    const t = e.length;
    if (t > 0) {
      const r = [];
      let i = 0;
      for (; t > i; ++i) r.push(...this.Ue(e[i]));
      return r;
    }
    return Fe;
  }
  Ue(e) {
    return vt(e) ? this.De(e) : e instanceof Array ? this.qe(e) : e instanceof Object ? this.$e(e) : Fe;
  }
  W() {
    if (this.j) {
      this.j = !1;
      const e = this.v,
        t = this.styles,
        r = this.Ue(e);
      let i,
        s = this.version;
      this.ov = e;
      let a,
        o,
        u,
        l = 0;
      const p = r.length;
      for (; l < p; ++l) (a = r[l]), (o = a[0]), (u = a[1]), this.setProperty(o, u), (t[o] = s);
      if (((this.styles = t), (this.version += 1), s === 0)) return;
      s -= 1;
      for (i in t) !os.call(t, i) || t[i] !== s || this.obj.style.removeProperty(i);
    }
  }
  setProperty(e, t) {
    let r = '';
    t != null && qn(t.indexOf) && t.includes('!important') && ((r = 'important'), (t = t.replace('!important', ''))), this.obj.style.setProperty(e, t, r);
  }
  bind() {
    this.v = this.ov = this.obj.style.cssText;
  }
}
Sd(d1);
class Ay {
  constructor(e, t, r) {
    (this.type = 7), (this.v = ''), (this.ov = ''), (this.j = !1), (this.F = !1), (this.q = e), (this.k = t), (this.cf = r);
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    sl(e, this.v) || ((this.ov = this.v), (this.v = e), (this.j = !0), this.cf.readonly || this.W());
  }
  W() {
    this.j && ((this.j = !1), (this.q[this.k] = this.v ?? this.cf.default), this.it());
  }
  handleEvent() {
    (this.ov = this.v), (this.v = this.q[this.k]), this.ov !== this.v && ((this.j = !1), this.it());
  }
  O() {
    this.v = this.ov = this.q[this.k];
  }
  it() {
    (Ub = this.ov), (this.ov = this.v), this.subs.notify(this.v, Ub);
  }
}
fy(Ay);
Ln(Ay);
let Ub;
const zs = 'http://www.w3.org/1999/xlink',
  jb = 'http://www.w3.org/XML/1998/namespace',
  Vb = 'http://www.w3.org/2000/xmlns/',
  zb = sy(Vn(), {
    'xlink:actuate': ['actuate', zs],
    'xlink:arcrole': ['arcrole', zs],
    'xlink:href': ['href', zs],
    'xlink:role': ['role', zs],
    'xlink:show': ['show', zs],
    'xlink:title': ['title', zs],
    'xlink:type': ['type', zs],
    'xml:lang': ['lang', jb],
    'xml:space': ['space', jb],
    xmlns: ['xmlns', Vb],
    'xmlns:xlink': ['xlink', Vb],
  }),
  p1 = new xx();
p1.type = 6;
class Ru {
  constructor(e, t, r, i) {
    (this.locator = e), (this.platform = t), (this.dirtyChecker = r), (this.svgAnalyzer = i), (this.allowDirtyCheck = !0), (this.Fe = Vn()), (this.Oe = Vn()), (this.He = Vn()), (this.Ve = Vn());
    const s = ['change', 'input'],
      a = {
        events: s,
        default: '',
      };
    this.useConfig({
      INPUT: {
        value: a,
        valueAsNumber: {
          events: s,
          default: 0,
        },
        checked: {
          type: Ey,
          events: s,
        },
        files: {
          events: s,
          readonly: !0,
        },
      },
      SELECT: {
        value: {
          type: Ty,
          events: ['change'],
          default: '',
        },
      },
      TEXTAREA: {
        value: a,
      },
    });
    const o = {
        events: ['change', 'input', 'blur', 'keyup', 'paste'],
        default: '',
      },
      u = {
        events: ['scroll'],
        default: 0,
      };
    this.useConfigGlobal({
      scrollTop: u,
      scrollLeft: u,
      textContent: o,
      innerHTML: o,
    }),
      this.overrideAccessorGlobal('css', 'style', 'class'),
      this.overrideAccessor({
        INPUT: ['value', 'checked', 'model'],
        SELECT: ['value'],
        TEXTAREA: ['value'],
      });
  }
  static register(e) {
    al(Rc, Ru).register(e), So(Rc, Ru).register(e);
  }
  handles(e, t) {
    return e instanceof this.platform.Node;
  }
  useConfig(e, t, r) {
    const i = this.Fe;
    let s;
    if (vt(e)) (s = i[e] ?? (i[e] = Vn())), s[t] == null ? (s[t] = r) : Ll(e, t);
    else
      for (const a in e) {
        s = i[a] ?? (i[a] = Vn());
        const o = e[a];
        for (t in o) s[t] == null ? (s[t] = o[t]) : Ll(a, t);
      }
  }
  useConfigGlobal(e, t) {
    const r = this.Oe;
    if (typeof e == 'object') for (const i in e) r[i] == null ? (r[i] = e[i]) : Ll('*', i);
    else r[e] == null ? (r[e] = t) : Ll('*', e);
  }
  getAccessor(e, t, r) {
    if (t in this.Ve || t in (this.He[e.tagName] ?? BT)) return this.getObserver(e, t, r);
    switch (t) {
      case 'src':
      case 'href':
      case 'role':
      case 'minLength':
      case 'maxLength':
      case 'placeholder':
      case 'size':
      case 'pattern':
      case 'title':
        return uc;
      default: {
        const i = zb[t];
        return i !== void 0 ? _u.forNs(i[1]) : Im(e, t, this.svgAnalyzer) ? uc : p1;
      }
    }
  }
  overrideAccessor(e, t) {
    var r, i;
    let s;
    if (vt(e)) (s = (r = this.He)[e] ?? (r[e] = Vn())), (s[t] = !0);
    else for (const a in e) for (const o of e[a]) (s = (i = this.He)[a] ?? (i[a] = Vn())), (s[o] = !0);
  }
  overrideAccessorGlobal(...e) {
    for (const t of e) this.Ve[t] = !0;
  }
  getNodeObserverConfig(e, t) {
    return this.Fe[e.tagName]?.[t] ?? this.Oe[t];
  }
  getNodeObserver(e, t, r) {
    const i = this.Fe[e.tagName]?.[t] ?? this.Oe[t];
    let s;
    return i != null ? ((s = new (i.type ?? Ay)(e, t, i, r, this.locator)), s.doNotCache || (Tx(e)[t] = s), s) : null;
  }
  getObserver(e, t, r) {
    switch (t) {
      case 'class':
        return new $x(e);
      case 'css':
      case 'style':
        return new d1(e);
    }
    const i = this.getNodeObserver(e, t, r);
    if (i != null) return i;
    const s = zb[t];
    if (s !== void 0) return _u.forNs(s[1]);
    if (Im(e, t, this.svgAnalyzer)) return uc;
    if (t in e.constructor.prototype) {
      if (this.allowDirtyCheck) return this.dirtyChecker.createProperty(e, t);
      throw re(`AUR0652:${Co(t)}`);
    } else return new ty(e, t);
  }
}
Ru.inject = [AT, Ni, bx, k8];
function F8(n, e) {
  if (n instanceof Array) return e.getArrayObserver(n);
  if (n instanceof Map) return e.getMapObserver(n);
  if (n instanceof Set) return e.getSetObserver(n);
}
function Ll(n, e) {
  throw re(`AUR0653:${Co(e)}@${n}`);
}
function Gb(n, e) {
  return n === e;
}
class Ey {
  constructor(e, t, r, i) {
    (this.type = 7), (this.v = void 0), (this.ov = void 0), (this.Ne = void 0), (this.je = void 0), (this.F = !1), (this.q = e), (this.oL = i), (this.cf = r);
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    const t = this.v;
    e !== t && ((this.v = e), (this.ov = t), this.We(), this.ze(), this.it());
  }
  handleCollectionChange() {
    this.ze();
  }
  handleChange(e, t) {
    this.ze();
  }
  ze() {
    const e = this.v,
      t = this.q,
      r = os.call(t, 'model') ? t.model : t.value,
      i = t.type === 'radio',
      s = t.matcher !== void 0 ? t.matcher : Gb;
    if (i) t.checked = !!s(e, r);
    else if (e === !0) t.checked = !0;
    else {
      let a = !1;
      if (Wr(e)) a = e.findIndex((o) => !!s(o, r)) !== -1;
      else if (e instanceof Set) {
        for (const o of e)
          if (s(o, r)) {
            a = !0;
            break;
          }
      } else if (e instanceof Map)
        for (const o of e) {
          const u = o[0],
            l = o[1];
          if (s(u, r) && l === !0) {
            a = !0;
            break;
          }
        }
      t.checked = a;
    }
  }
  handleEvent() {
    let e = (this.ov = this.v);
    const t = this.q,
      r = os.call(t, 'model') ? t.model : t.value,
      i = t.checked,
      s = t.matcher !== void 0 ? t.matcher : Gb;
    if (t.type === 'checkbox') {
      if (Wr(e)) {
        const a = e.findIndex((o) => !!s(o, r));
        i && a === -1 ? e.push(r) : !i && a !== -1 && e.splice(a, 1);
        return;
      } else if (e instanceof Set) {
        const a = {};
        let o = a;
        for (const u of e)
          if (s(u, r) === !0) {
            o = u;
            break;
          }
        i && o === a ? e.add(r) : !i && o !== a && e.delete(o);
        return;
      } else if (e instanceof Map) {
        let a;
        for (const o of e) {
          const u = o[0];
          if (s(u, r) === !0) {
            a = u;
            break;
          }
        }
        e.set(a, i);
        return;
      }
      e = i;
    } else if (i) e = r;
    else return;
    (this.v = e), this.it();
  }
  O() {
    this.We();
  }
  H() {
    this.Ne?.unsubscribe(this), this.je?.unsubscribe(this), (this.Ne = this.je = void 0);
  }
  it() {
    (Hb = this.ov), (this.ov = this.v), this.subs.notify(this.v, Hb);
  }
  We() {
    const e = this.q;
    (this.je ?? (this.je = e.$observers?.model ?? e.$observers?.value))?.subscribe(this),
      this.Ne?.unsubscribe(this),
      (this.Ne = void 0),
      e.type === 'checkbox' && (this.Ne = F8(this.v, this.oL))?.subscribe(this);
  }
}
fy(Ey);
Ln(Ey);
let Hb;
class L8 {
  bind(e, t) {
    if (!(t instanceof Di)) throw re('AURxxxx');
    t.useTargetObserver(uc);
  }
}
Un('attr')(L8);
class $8 {
  bind(e, t) {
    if (!(t instanceof fl)) throw re('AUR0801');
    t.self = !0;
  }
  unbind(e, t) {
    t.self = !1;
  }
}
Un('self')($8);
class f1 {
  constructor(e, t) {
    if (!(t instanceof Ru))
      throw re('AURxxxx: updateTrigger binding behavior only works with the default implementation of Aurelia HTML observation. Implement your own node observation + updateTrigger');
    (this.oL = e), (this.Ge = t);
  }
  bind(e, t, ...r) {
    if (r.length === 0) throw re('AUR0802');
    if (!(t instanceof Di) || !(t.mode & 4)) throw re('AUR0803');
    const i = this.Ge.getNodeObserverConfig(t.target, t.targetProperty);
    if (i == null) throw re('AURxxxx');
    const s = this.Ge.getNodeObserver(t.target, t.targetProperty, this.oL);
    s.useConfig({
      readonly: i.readonly,
      default: i.default,
      events: r,
    }),
      t.useTargetObserver(s);
  }
}
f1.inject = [ga, Rc];
Un('updateTrigger')(f1);
class io {
  constructor(e, t) {
    (this.elseFactory = void 0),
      (this.elseView = void 0),
      (this.ifView = void 0),
      (this.view = void 0),
      (this.value = !1),
      (this.cache = !0),
      (this.pending = void 0),
      (this.Xe = !1),
      (this.Ke = 0),
      (this.Qe = e),
      (this.l = t);
  }
  attaching(e, t) {
    let r;
    const i = this.$controller,
      s = this.Ke++,
      a = () => !this.Xe && this.Ke === s + 1;
    return Ce(this.pending, () => {
      a() &&
        ((this.pending = void 0),
        this.value
          ? (r = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this.Qe.create())
          : (r = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create()),
        r != null &&
          (r.setLocation(this.l),
          (this.pending = Ce(r.activate(e, i, i.scope), () => {
            a() && (this.pending = void 0);
          }))));
    });
  }
  detaching(e, t) {
    return (
      (this.Xe = !0),
      Ce(this.pending, () => {
        (this.Xe = !1), (this.pending = void 0), this.view?.deactivate(e, this.$controller);
      })
    );
  }
  valueChanged(e, t) {
    if (!this.$controller.isActive || ((e = !!e), (t = !!t), e === t)) return;
    const r = this.view,
      i = this.$controller,
      s = this.Ke++,
      a = () => !this.Xe && this.Ke === s + 1;
    let o;
    return Ce(
      this.pending,
      () =>
        (this.pending = Ce(r?.deactivate(r, i), () => {
          if (
            a() &&
            (e
              ? (o = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this.Qe.create())
              : (o = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create()),
            o != null)
          )
            return (
              o.setLocation(this.l),
              Ce(o.activate(o, i, i.scope), () => {
                a() && (this.pending = void 0);
              })
            );
        })),
    );
  }
  dispose() {
    this.ifView?.dispose(), this.elseView?.dispose(), (this.ifView = this.elseView = this.view = void 0);
  }
  accept(e) {
    if (this.view?.accept(e) === !0) return !0;
  }
}
io.inject = [Jn, Cn];
X([De], io.prototype, 'value', void 0);
X(
  [
    De({
      set: (n) => n === '' || (!!n && n !== 'false'),
    }),
  ],
  io.prototype,
  'cache',
  void 0,
);
dr('if')(io);
class h1 {
  constructor(e) {
    this.f = e;
  }
  link(e, t, r, i) {
    const s = e.children,
      a = s[s.length - 1];
    if (a instanceof io) a.elseFactory = this.f;
    else if (a.viewModel instanceof io) a.viewModel.elseFactory = this.f;
    else throw re('AUR0810');
  }
}
h1.inject = [Jn];
dr({
  name: 'else',
})(h1);
function U8(n) {
  n.dispose();
}
const j8 = [18, 17];
class Cy {
  constructor(e, t, r, i, s) {
    (this.views = []),
      (this.key = null),
      (this.Ye = /* @__PURE__ */ new Map()),
      (this.Ze = /* @__PURE__ */ new Map()),
      (this.Je = void 0),
      (this.ti = !1),
      (this.ei = !1),
      (this.ii = null),
      (this.si = void 0),
      (this.ni = !1);
    const a = e.props[0].props[0];
    if (a !== void 0) {
      const { to: o, value: u, command: l } = a;
      if (o === 'key')
        if (l === null) this.key = u;
        else if (l === 'bind') this.key = t.parse(u, 16);
        else throw re(`AUR775:${l}`);
      else throw re(`AUR776:${o}`);
    }
    (this.l = r), (this.ri = i), (this.f = s);
  }
  binding(e, t) {
    const r = this.ri.bindings,
      i = r.length;
    let s,
      a,
      o = 0;
    for (; i > o; ++o)
      if (((s = r[o]), s.target === this && s.targetProperty === 'items')) {
        (a = this.forOf = s.ast), (this.oi = s);
        let l = a.iterable;
        for (; l != null && j8.includes(l.$kind); ) (l = l.expression), (this.ti = !0);
        this.ii = l;
        break;
      }
    this.li();
    const u = a.declaration;
    (this.ni = u.$kind === 24 || u.$kind === 25) || (this.local = V(u, this.$controller.scope, s, null));
  }
  attaching(e, t) {
    return this.hi(), this.ai(e);
  }
  detaching(e, t) {
    return this.li(), this.ui(e);
  }
  unbinding(e, t) {
    this.Ze.clear(), this.Ye.clear();
  }
  itemsChanged() {
    this.$controller.isActive && (this.li(), this.hi(), this.fi(this.items, void 0));
  }
  handleCollectionChange(e, t) {
    const r = this.$controller;
    if (r.isActive) {
      if (this.ti) {
        if (this.ei) return;
        (this.ei = !0), (this.items = V(this.forOf.iterable, r.scope, this.oi, null)), (this.ei = !1);
        return;
      }
      this.hi(), this.fi(e, t);
    }
  }
  fi(e, t) {
    const r = this.views,
      i = r.length,
      s = this.key,
      a = s !== null;
    if (a || t === void 0) {
      const o = this.local,
        u = this.si,
        l = u.length,
        p = this.forOf,
        h = p.declaration,
        b = this.oi,
        E = this.ni;
      t = na(l);
      let x = 0;
      if (i === 0) for (; x < l; ++x) t[x] = -2;
      else if (l === 0)
        if (E) for (x = 0; x < i; ++x) t.deletedIndices.push(x), t.deletedItems.push(V(h, r[x].scope, b, null));
        else for (x = 0; x < i; ++x) t.deletedIndices.push(x), t.deletedItems.push(r[x].scope.bindingContext[o]);
      else {
        const T = Array(i);
        if (E) for (x = 0; x < i; ++x) T[x] = V(h, r[x].scope, b, null);
        else for (x = 0; x < i; ++x) T[x] = r[x].scope.bindingContext[o];
        let w,
          _,
          k,
          D,
          N = 0;
        const B = i - 1,
          j = l - 1,
          q = /* @__PURE__ */ new Map(),
          z = /* @__PURE__ */ new Map(),
          Y = this.Ye,
          ae = this.Ze,
          J = this.$controller.scope;
        x = 0;
        e: {
          for (;;) {
            if (
              (a ? ((w = T[x]), (_ = u[x]), (k = Ia(Y, s, w, Gs(ae, w, p, J, b, o, E), b)), (D = Ia(Y, s, _, Gs(ae, _, p, J, b, o, E), b))) : ((w = k = Hs(T[x], x)), (_ = D = Hs(u[x], x))), k !== D)
            ) {
              Y.set(w, k), Y.set(_, D);
              break;
            }
            if ((++x, x > B || x > j)) break e;
          }
          if (B !== j) break e;
          for (N = j; ; ) {
            if (
              (a ? ((w = T[N]), (_ = u[N]), (k = Ia(Y, s, w, Gs(ae, w, p, J, b, o, E), b)), (D = Ia(Y, s, _, Gs(ae, _, p, J, b, o, E), b))) : ((w = k = Hs(T[x], x)), (_ = D = Hs(u[x], x))), k !== D)
            ) {
              Y.set(w, k), Y.set(_, D);
              break;
            }
            if ((--N, x > N)) break e;
          }
        }
        const oe = x,
          S = x;
        for (x = S; x <= j; ++x) Y.has((_ = a ? u[x] : Hs(u[x], x))) ? (D = Y.get(_)) : ((D = a ? Ia(Y, s, _, Gs(ae, _, p, J, b, o, E), b) : _), Y.set(_, D)), z.set(D, x);
        for (x = oe; x <= B; ++x)
          Y.has((w = a ? T[x] : Hs(T[x], x))) ? (k = Y.get(w)) : (k = a ? Ia(Y, s, w, r[x].scope, b) : w),
            q.set(k, x),
            z.has(k) ? (t[z.get(k)] = x) : (t.deletedIndices.push(x), t.deletedItems.push(w));
        for (x = S; x <= j; ++x) q.has(Y.get(a ? u[x] : Hs(u[x], x))) || (t[x] = -2);
        q.clear(), z.clear();
      }
    }
    if (t === void 0) {
      const o = Ce(this.ui(null), () => this.ai(null));
      tn(o) && o.catch(Pc);
    } else {
      const o = b3(t);
      if (o.deletedIndices.length > 0) {
        const u = Ce(this.di(o), () => this.mi(i, o));
        tn(u) && u.catch(Pc);
      } else this.mi(i, o);
    }
  }
  li() {
    const e = this.$controller.scope;
    let t = this.gi,
      r = this.ti,
      i;
    r && ((t = this.gi = V(this.ii, e, this.oi, null) ?? null), (r = this.ti = !sl(this.items, t)));
    const s = this.Je;
    this.$controller.isActive ? ((i = this.Je = QA(r ? t : this.items)), s !== i && (s?.unsubscribe(this), i?.subscribe(this))) : (s?.unsubscribe(this), (this.Je = void 0));
  }
  hi() {
    const { items: e } = this;
    if (Wr(e)) {
      this.si = e;
      return;
    }
    const t = [];
    Kb(e, (r, i) => {
      t[i] = r;
    }),
      (this.si = t);
  }
  ai(e) {
    let t, r, i, s;
    const { $controller: a, f: o, local: u, l, items: p, Ze: h, oi: b, forOf: E, ni: x } = this,
      T = a.scope,
      w = G8(p),
      _ = (this.views = Array(w));
    if (
      (Kb(p, (k, D) => {
        (i = _[D] = o.create().setLocation(l)), i.nodes.unlink(), (s = Gs(h, k, E, T, b, u, x)), Ul(s.overrideContext, D, w), (r = i.activate(e ?? i, a, s)), tn(r) && (t ?? (t = [])).push(r);
      }),
      t !== void 0)
    )
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  ui(e) {
    let t,
      r,
      i,
      s = 0;
    const { views: a, $controller: o } = this,
      u = a.length;
    for (; u > s; ++s) (i = a[s]), i.release(), (r = i.deactivate(e ?? i, o)), tn(r) && (t ?? (t = [])).push(r);
    if (t !== void 0) return t.length === 1 ? t[0] : Promise.all(t);
  }
  di(e) {
    let t, r, i;
    const { $controller: s, views: a } = this,
      o = e.deletedIndices,
      u = o.length;
    let l = 0;
    for (; u > l; ++l) (i = a[o[l]]), i.release(), (r = i.deactivate(i, s)), tn(r) && (t ?? (t = [])).push(r);
    l = 0;
    let p = 0;
    for (; u > l; ++l) (p = o[l] - l), a.splice(p, 1);
    if (t !== void 0) return t.length === 1 ? t[0] : Promise.all(t);
  }
  mi(e, t) {
    let r,
      i,
      s,
      a,
      o = 0;
    const { $controller: u, f: l, local: p, si: h, l: b, views: E, ni: x, oi: T, Ze: w, forOf: _ } = this,
      k = t.length;
    for (; k > o; ++o) t[o] === -2 && ((s = l.create()), E.splice(o, 0, s));
    if (E.length !== k) throw z8(E.length, k);
    const D = u.scope,
      N = t.length;
    g3(E, t);
    const B = V8(t),
      j = B.length,
      q = _.declaration;
    let z,
      Y = j - 1;
    for (o = N - 1; o >= 0; --o)
      (s = E[o]),
        (z = E[o + 1]),
        s.nodes.link(z?.nodes ?? b),
        t[o] === -2
          ? ((a = Gs(w, h[o], _, D, T, p, x)), Ul(a.overrideContext, o, N), s.setLocation(b), (i = s.activate(s, u, a)), tn(i) && (r ?? (r = [])).push(i))
          : Y < 0 || j === 1 || o !== B[Y]
          ? (x ? dn(q, s.scope, T, h[o]) : (s.scope.bindingContext[p] = h[o]), Ul(s.scope.overrideContext, o, N), s.nodes.insertBefore(s.location))
          : (x ? dn(q, s.scope, T, h[o]) : (s.scope.bindingContext[p] = h[o]), e !== N && Ul(s.scope.overrideContext, o, N), --Y);
    if (r !== void 0) return r.length === 1 ? r[0] : Promise.all(r);
  }
  dispose() {
    this.views.forEach(U8), (this.views = void 0);
  }
  accept(e) {
    const { views: t } = this;
    if (t !== void 0) {
      for (let r = 0, i = t.length; r < i; ++r) if (t[r].accept(e) === !0) return !0;
    }
  }
}
Cy.inject = [_o, Kh, Cn, Rd, Jn];
X([De], Cy.prototype, 'items', void 0);
dr('repeat')(Cy);
let Dc = 16,
  ii = new Int32Array(Dc),
  $l = new Int32Array(Dc);
function V8(n) {
  const e = n.length;
  e > Dc && ((Dc = e), (ii = new Int32Array(e)), ($l = new Int32Array(e)));
  let t = 0,
    r = 0,
    i = 0,
    s = 0,
    a = 0,
    o = 0,
    u = 0,
    l = 0;
  for (; s < e; s++)
    if (((r = n[s]), r !== -2)) {
      if (((a = ii[t]), (i = n[a]), i !== -2 && i < r)) {
        ($l[s] = a), (ii[++t] = s);
        continue;
      }
      for (o = 0, u = t; o < u; ) (l = (o + u) >> 1), (i = n[ii[l]]), i !== -2 && i < r ? (o = l + 1) : (u = l);
      (i = n[ii[o]]), (r < i || i === -2) && (o > 0 && ($l[s] = ii[o - 1]), (ii[o] = s));
    }
  s = ++t;
  const p = new Int32Array(s);
  for (r = ii[t - 1]; t-- > 0; ) (p[t] = r), (r = $l[r]);
  for (; s-- > 0; ) ii[s] = 0;
  return p;
}
const z8 = (n, e) => re(`AUR0814:${n}!=${e}`),
  Ul = (n, e, t) => {
    const r = e === 0,
      i = e === t - 1,
      s = e % 2 === 0;
    (n.$index = e), (n.$first = r), (n.$last = i), (n.$middle = !r && !i), (n.$even = s), (n.$odd = !s), (n.$length = t);
  },
  Fc = iy.toString,
  G8 = (n) => {
    switch (Fc.call(n)) {
      case '[object Array]':
        return n.length;
      case '[object Map]':
        return n.size;
      case '[object Set]':
        return n.size;
      case '[object Number]':
        return n;
      case '[object Null]':
        return 0;
      case '[object Undefined]':
        return 0;
      default:
        throw re(`Cannot count ${Fc.call(n)}`);
    }
  },
  Kb = (n, e) => {
    switch (Fc.call(n)) {
      case '[object Array]':
        return H8(n, e);
      case '[object Map]':
        return K8(n, e);
      case '[object Set]':
        return q8(n, e);
      case '[object Number]':
        return W8(n, e);
      case '[object Null]':
        return;
      case '[object Undefined]':
        return;
      default:
        throw re(`Cannot iterate over ${Fc.call(n)}`);
    }
  },
  H8 = (n, e) => {
    const t = n.length;
    let r = 0;
    for (; r < t; ++r) e(n[r], r, n);
  },
  K8 = (n, e) => {
    let t = -0,
      r;
    for (r of n.entries()) e(r, t++, n);
  },
  q8 = (n, e) => {
    let t = 0,
      r;
    for (r of n.keys()) e(r, t++, n);
  },
  W8 = (n, e) => {
    let t = 0;
    for (; t < n; ++t) e(t, t, n);
  },
  Ia = (n, e, t, r, i) => {
    let s = n.get(t);
    return s === void 0 && (typeof e == 'string' ? (s = t[e]) : (s = V(e, r, i, null)), n.set(t, s)), s;
  },
  Gs = (n, e, t, r, i, s, a) => {
    let o = n.get(e);
    return o === void 0 && (a ? dn(t.declaration, (o = an.fromParent(r, new W0())), i, e) : (o = an.fromParent(r, new W0(s, e))), n.set(e, o)), o;
  },
  Hs = (n, e) => {
    const t = typeof n;
    switch (t) {
      case 'object':
        if (n !== null) return n;
      case 'string':
      case 'number':
      case 'bigint':
      case 'undefined':
      case 'boolean':
        return `${e}${t}${n}`;
      default:
        return n;
    }
  };
class Sy {
  constructor(e, t) {
    this.view = e.create().setLocation(t);
  }
  valueChanged(e, t) {
    const r = this.$controller,
      i = this.view.bindings;
    let s,
      a = 0,
      o = 0;
    if (r.isActive && i != null) for (s = an.fromParent(r.scope, e === void 0 ? {} : e), o = i.length; o > a; ++a) i[a].bind(s);
  }
  attaching(e, t) {
    const { $controller: r, value: i } = this,
      s = an.fromParent(r.scope, i === void 0 ? {} : i);
    return this.view.activate(e, r, s);
  }
  detaching(e, t) {
    return this.view.deactivate(e, this.$controller);
  }
  dispose() {
    this.view.dispose(), (this.view = void 0);
  }
  accept(e) {
    if (this.view?.accept(e) === !0) return !0;
  }
}
Sy.inject = [Jn, Cn];
X([De], Sy.prototype, 'value', void 0);
dr('with')(Sy);
let Lc = class {
  constructor(e, t) {
    (this.f = e), (this.l = t), (this.cases = []), (this.activeCases = []), (this.promise = void 0);
  }
  link(e, t, r, i) {
    this.view = this.f.create(this.$controller).setLocation(this.l);
  }
  attaching(e, t) {
    const r = this.view,
      i = this.$controller;
    return this.queue(() => r.activate(e, i, i.scope)), this.queue(() => this.swap(e, this.value)), this.promise;
  }
  detaching(e, t) {
    return this.queue(() => this.view.deactivate(e, this.$controller)), this.promise;
  }
  dispose() {
    this.view?.dispose(), (this.view = void 0);
  }
  valueChanged(e, t) {
    this.$controller.isActive && this.queue(() => this.swap(null, this.value));
  }
  caseChanged(e) {
    this.queue(() => this.pi(e));
  }
  pi(e) {
    const t = e.isMatch(this.value),
      r = this.activeCases,
      i = r.length;
    if (!t) return i > 0 && r[0].id === e.id ? this.vi(null) : void 0;
    if (i > 0 && r[0].id < e.id) return;
    const s = [];
    let a = e.fallThrough;
    if (!a) s.push(e);
    else {
      const o = this.cases,
        u = o.indexOf(e);
      for (let l = u, p = o.length; l < p && a; l++) {
        const h = o[l];
        s.push(h), (a = h.fallThrough);
      }
    }
    return Ce(this.vi(null, s), () => ((this.activeCases = s), this.bi(null)));
  }
  swap(e, t) {
    const r = [];
    let i = !1;
    for (const a of this.cases) if (((i || a.isMatch(t)) && (r.push(a), (i = a.fallThrough)), r.length > 0 && !i)) break;
    const s = this.defaultCase;
    return (
      r.length === 0 && s !== void 0 && r.push(s),
      Ce(this.activeCases.length > 0 ? this.vi(e, r) : void 0, () => {
        if (((this.activeCases = r), r.length !== 0)) return this.bi(e);
      })
    );
  }
  bi(e) {
    const t = this.$controller;
    if (!t.isActive) return;
    const r = this.activeCases,
      i = r.length;
    if (i === 0) return;
    const s = t.scope;
    return i === 1 ? r[0].activate(e, s) : Kt(...r.map((a) => a.activate(e, s)));
  }
  vi(e, t = []) {
    const r = this.activeCases,
      i = r.length;
    if (i !== 0) {
      if (i === 1) {
        const s = r[0];
        return t.includes(s) ? void 0 : ((r.length = 0), s.deactivate(e));
      }
      return Ce(Kt(...r.reduce((s, a) => (t.includes(a) || s.push(a.deactivate(e)), s), [])), () => {
        r.length = 0;
      });
    }
  }
  queue(e) {
    const t = this.promise;
    let r;
    r = this.promise = Ce(Ce(t, e), () => {
      this.promise === r && (this.promise = void 0);
    });
  }
  accept(e) {
    if (this.$controller.accept(e) === !0 || this.activeCases.some((t) => t.accept(e))) return !0;
  }
};
X([De], Lc.prototype, 'value', void 0);
Lc = X([dr('switch'), yn(0, Jn), yn(1, Cn)], Lc);
let J8 = 0,
  so = class {
    constructor(e, t, r, i) {
      (this.f = e),
        (this.xi = t),
        (this.l = r),
        (this.id = ++J8),
        (this.fallThrough = !1),
        (this.view = void 0),
        (this.wi = i.config.level <= 1),
        (this.yi = i.scopeTo(`${this.constructor.name}-#${this.id}`));
    }
    link(e, t, r, i) {
      const a = e.parent?.viewModel;
      if (a instanceof Lc) (this.$switch = a), this.linkToSwitch(a);
      else throw re('AUR0815');
    }
    detaching(e, t) {
      return this.deactivate(e);
    }
    isMatch(e) {
      this.yi.debug('isMatch()');
      const t = this.value;
      return Wr(t) ? (this.Je === void 0 && (this.Je = this.ki(t)), t.includes(e)) : t === e;
    }
    valueChanged(e, t) {
      Wr(e) ? (this.Je?.unsubscribe(this), (this.Je = this.ki(e))) : this.Je !== void 0 && this.Je.unsubscribe(this), this.$switch.caseChanged(this);
    }
    handleCollectionChange() {
      this.$switch.caseChanged(this);
    }
    activate(e, t) {
      let r = this.view;
      if ((r === void 0 && (r = this.view = this.f.create().setLocation(this.l)), !r.isActive)) return r.activate(e ?? r, this.$controller, t);
    }
    deactivate(e) {
      const t = this.view;
      if (!(t === void 0 || !t.isActive)) return t.deactivate(e ?? t, this.$controller);
    }
    dispose() {
      this.Je?.unsubscribe(this), this.view?.dispose(), (this.view = void 0);
    }
    linkToSwitch(e) {
      e.cases.push(this);
    }
    ki(e) {
      const t = this.xi.getArrayObserver(e);
      return t.subscribe(this), t;
    }
    accept(e) {
      return this.$controller.accept(e) === !0 ? !0 : this.view?.accept(e);
    }
  };
so.inject = [Jn, ga, Cn, ba];
X([De], so.prototype, 'value', void 0);
X(
  [
    De({
      set: (n) => {
        switch (n) {
          case 'true':
            return !0;
          case 'false':
            return !1;
          default:
            return !!n;
        }
      },
      mode: 1,
    }),
  ],
  so.prototype,
  'fallThrough',
  void 0,
);
so = X([dr('case')], so);
let qb = class extends so {
  linkToSwitch(e) {
    if (e.defaultCase !== void 0) throw re('AUR0816');
    e.defaultCase = this;
  }
};
qb = X([dr('default-case')], qb);
let $c = class {
  constructor(e, t, r, i) {
    (this.f = e), (this.l = t), (this.p = r), (this.preSettledTask = null), (this.postSettledTask = null), (this.logger = i.scopeTo('promise.resolve'));
  }
  link(e, t, r, i) {
    this.view = this.f.create(this.$controller).setLocation(this.l);
  }
  attaching(e, t) {
    const r = this.view,
      i = this.$controller;
    return Ce(r.activate(e, i, (this.viewScope = an.fromParent(i.scope, {}))), () => this.swap(e));
  }
  valueChanged(e, t) {
    this.$controller.isActive && this.swap(null);
  }
  swap(e) {
    const t = this.value;
    if (!tn(t)) {
      this.logger.warn(`The value '${Co(t)}' is not a promise. No change will be done.`);
      return;
    }
    const r = this.p.domWriteQueue,
      i = this.fulfilled,
      s = this.rejected,
      a = this.pending,
      o = this.viewScope;
    let u;
    const l = {
        reusable: !1,
      },
      p = () => {
        Kt(
          (u = (this.preSettledTask = r.queueTask(() => Kt(i?.deactivate(e), s?.deactivate(e), a?.activate(e, o)), l)).result.catch((h) => {
            if (!(h instanceof t4)) throw h;
          })),
          t.then(
            (h) => {
              if (this.value !== t) return;
              const b = () => {
                this.postSettlePromise = (this.postSettledTask = r.queueTask(() => Kt(a?.deactivate(e), s?.deactivate(e), i?.activate(e, o, h)), l)).result;
              };
              this.preSettledTask.status === 1 ? u.then(b) : (this.preSettledTask.cancel(), b());
            },
            (h) => {
              if (this.value !== t) return;
              const b = () => {
                this.postSettlePromise = (this.postSettledTask = r.queueTask(() => Kt(a?.deactivate(e), i?.deactivate(e), s?.activate(e, o, h)), l)).result;
              };
              this.preSettledTask.status === 1 ? u.then(b) : (this.preSettledTask.cancel(), b());
            },
          ),
        );
      };
    this.postSettledTask?.status === 1 ? this.postSettlePromise.then(p) : (this.postSettledTask?.cancel(), p());
  }
  detaching(e, t) {
    return this.preSettledTask?.cancel(), this.postSettledTask?.cancel(), (this.preSettledTask = this.postSettledTask = null), this.view.deactivate(e, this.$controller);
  }
  dispose() {
    this.view?.dispose(), (this.view = void 0);
  }
};
X([De], $c.prototype, 'value', void 0);
$c = X([dr('promise'), yn(0, Jn), yn(1, Cn), yn(2, Ni), yn(3, ba)], $c);
let Uf = class {
  constructor(e, t) {
    (this.f = e), (this.l = t), (this.view = void 0);
  }
  link(e, t, r, i) {
    My(e).pending = this;
  }
  activate(e, t) {
    let r = this.view;
    if ((r === void 0 && (r = this.view = this.f.create().setLocation(this.l)), !r.isActive)) return r.activate(r, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive)) return t.deactivate(t, this.$controller);
  }
  detaching(e) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), (this.view = void 0);
  }
};
X(
  [
    De({
      mode: 2,
    }),
  ],
  Uf.prototype,
  'value',
  void 0,
);
Uf = X([dr('pending'), yn(0, Jn), yn(1, Cn)], Uf);
let jf = class {
  constructor(e, t) {
    (this.f = e), (this.l = t), (this.view = void 0);
  }
  link(e, t, r, i) {
    My(e).fulfilled = this;
  }
  activate(e, t, r) {
    this.value = r;
    let i = this.view;
    if ((i === void 0 && (i = this.view = this.f.create().setLocation(this.l)), !i.isActive)) return i.activate(i, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive)) return t.deactivate(t, this.$controller);
  }
  detaching(e, t) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), (this.view = void 0);
  }
};
X(
  [
    De({
      mode: 4,
    }),
  ],
  jf.prototype,
  'value',
  void 0,
);
jf = X([dr('then'), yn(0, Jn), yn(1, Cn)], jf);
let Vf = class {
  constructor(e, t) {
    (this.f = e), (this.l = t), (this.view = void 0);
  }
  link(e, t, r, i) {
    My(e).rejected = this;
  }
  activate(e, t, r) {
    this.value = r;
    let i = this.view;
    if ((i === void 0 && (i = this.view = this.f.create().setLocation(this.l)), !i.isActive)) return i.activate(i, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive)) return t.deactivate(t, this.$controller);
  }
  detaching(e, t) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), (this.view = void 0);
  }
};
X(
  [
    De({
      mode: 4,
    }),
  ],
  Vf.prototype,
  'value',
  void 0,
);
Vf = X([dr('catch'), yn(0, Jn), yn(1, Cn)], Vf);
function My(n) {
  const t = n.parent?.viewModel;
  if (t instanceof $c) return t;
  throw re('AUR0813');
}
let Wb = class {
  'promise.resolve'(e, t, r) {
    return new lr(e, t, 'promise', 'bind');
  }
};
Wb = X(
  [
    Li({
      pattern: 'promise.resolve',
      symbols: '',
    }),
  ],
  Wb,
);
let Jb = class {
  then(e, t, r) {
    return new lr(e, t, 'then', 'from-view');
  }
};
Jb = X(
  [
    Li({
      pattern: 'then',
      symbols: '',
    }),
  ],
  Jb,
);
let Qb = class {
  catch(e, t, r) {
    return new lr(e, t, 'catch', 'from-view');
  }
};
Qb = X(
  [
    Li({
      pattern: 'catch',
      symbols: '',
    }),
  ],
  Qb,
);
class _y {
  constructor(e, t) {
    (this.Ai = !1), (this.Ci = e), (this.p = t);
  }
  binding() {
    this.valueChanged();
  }
  valueChanged() {
    this.$controller.isActive ? this.Ri() : (this.Ai = !0);
  }
  attached() {
    this.Ai && ((this.Ai = !1), this.Ri()), this.Ci.addEventListener('focus', this), this.Ci.addEventListener('blur', this);
  }
  detaching() {
    const e = this.Ci;
    e.removeEventListener('focus', this), e.removeEventListener('blur', this);
  }
  handleEvent(e) {
    e.type === 'focus' ? (this.value = !0) : this.Bi || (this.value = !1);
  }
  Ri() {
    const e = this.Ci,
      t = this.Bi,
      r = this.value;
    r && !t ? e.focus() : !r && t && e.blur();
  }
  get Bi() {
    return this.Ci === this.p.document.activeElement;
  }
}
_y.inject = [ro, Ni];
X(
  [
    De({
      mode: 6,
    }),
  ],
  _y.prototype,
  'value',
  void 0,
);
Bx('focus')(_y);
class Ir {
  constructor(e, t, r) {
    (this.position = 'beforeend'), (this.strict = !1), (this.p = r), (this.Si = r.document.createElement('div')), (this.view = e.create()).setLocation((this._i = A4(r))), _4(this.view.nodes, t);
  }
  attaching(e) {
    this.callbackContext == null && (this.callbackContext = this.$controller.scope.bindingContext);
    const t = (this.Si = this.Ii());
    return this.Ti(t, this.position), this.Ei(e, t);
  }
  detaching(e) {
    return this.Pi(e, this.Si);
  }
  targetChanged() {
    const { $controller: e } = this;
    if (!e.isActive) return;
    const t = this.Ii();
    if (this.Si === t) return;
    this.Si = t;
    const r = Ce(this.Pi(null, t), () => (this.Ti(t, this.position), this.Ei(null, t)));
    tn(r) && r.catch(Pc);
  }
  positionChanged() {
    const { $controller: e, Si: t } = this;
    if (!e.isActive) return;
    const r = Ce(this.Pi(null, t), () => (this.Ti(t, this.position), this.Ei(null, t)));
    tn(r) && r.catch(Pc);
  }
  Ei(e, t) {
    const { activating: r, callbackContext: i, view: s } = this;
    return Ce(r?.call(i, t, s), () => this.Li(e, t));
  }
  Li(e, t) {
    const { $controller: r, view: i } = this;
    if (e === null) i.nodes.insertBefore(this._i);
    else return Ce(i.activate(e ?? i, r, r.scope), () => this.Mi(t));
    return this.Mi(t);
  }
  Mi(e) {
    const { activated: t, callbackContext: r, view: i } = this;
    return t?.call(r, e, i);
  }
  Pi(e, t) {
    const { deactivating: r, callbackContext: i, view: s } = this;
    return Ce(r?.call(i, t, s), () => this.Di(e, t));
  }
  Di(e, t) {
    const { $controller: r, view: i } = this;
    if (e === null) i.nodes.remove();
    else return Ce(i.deactivate(e, r), () => this.$i(t));
    return this.$i(t);
  }
  $i(e) {
    const { deactivated: t, callbackContext: r, view: i } = this;
    return t?.call(r, e, i);
  }
  Ii() {
    const e = this.p,
      t = e.document;
    let r = this.target,
      i = this.renderContext;
    if (r === '') {
      if (this.strict) throw re('AUR0811');
      return t.body;
    }
    if (vt(r)) {
      let s = t;
      vt(i) && (i = t.querySelector(i)), i instanceof e.Node && (s = i), (r = s.querySelector(r));
    }
    if (r instanceof e.Node) return r;
    if (r == null) {
      if (this.strict) throw re('AUR0812');
      return t.body;
    }
    return r;
  }
  Ti(e, t) {
    const r = this._i,
      i = r.$start,
      s = e.parentNode,
      a = [i, r];
    switch (t) {
      case 'beforeend':
        Nl(e, null, a);
        break;
      case 'afterbegin':
        Nl(e, e.firstChild, a);
        break;
      case 'beforebegin':
        Nl(s, e, a);
        break;
      case 'afterend':
        Nl(s, e.nextSibling, a);
        break;
      default:
        throw new Error('Invalid portal insertion position');
    }
  }
  dispose() {
    this.view.dispose(), (this.view = void 0), (this.callbackContext = null);
  }
  accept(e) {
    if (this.view?.accept(e) === !0) return !0;
  }
}
Ir.inject = [Jn, Cn, Ni];
X(
  [
    De({
      primary: !0,
    }),
  ],
  Ir.prototype,
  'target',
  void 0,
);
X([De()], Ir.prototype, 'position', void 0);
X(
  [
    De({
      callback: 'targetChanged',
    }),
  ],
  Ir.prototype,
  'renderContext',
  void 0,
);
X([De()], Ir.prototype, 'strict', void 0);
X([De()], Ir.prototype, 'deactivating', void 0);
X([De()], Ir.prototype, 'activating', void 0);
X([De()], Ir.prototype, 'deactivated', void 0);
X([De()], Ir.prototype, 'activated', void 0);
X([De()], Ir.prototype, 'callbackContext', void 0);
dr('portal')(Ir);
let Uc = class {
  static get inject() {
    return [Cn, _o, Nc, Ta];
  }
  constructor(e, t, r, i) {
    (this.Ui = null), (this.qi = null), (this.Fi = !1), (this.expose = null), (this.slotchange = null), (this.Oi = /* @__PURE__ */ new Set()), (this.Je = null);
    let s, a;
    const o = t.auSlot,
      u = r.instruction?.projections?.[o.name],
      l = r.controller;
    (this.name = o.name),
      u == null
        ? ((s = i.getViewFactory(o.fallback, l.container)), (this.Hi = !1))
        : ((a = r.parent.controller.container.createChild()),
          xt(a, l.definition.Type, new nn(void 0, l.viewModel)),
          (s = i.getViewFactory(u, a)),
          (this.Hi = !0),
          (this.Vi = l.container.getAll(Q4, !1)?.filter((p) => p.slotName === '*' || p.slotName === o.name) ?? Fe)),
      (this.Ni = (this.Vi ?? (this.Vi = Fe)).length > 0),
      (this.ji = r),
      (this.view = s.create().setLocation((this.l = e)));
  }
  get nodes() {
    const e = [],
      t = this.l;
    let r = t.$start.nextSibling;
    for (; r != null && r !== t; ) r.nodeType !== 8 && e.push(r), (r = r.nextSibling);
    return e;
  }
  subscribe(e) {
    this.Oi.add(e);
  }
  unsubscribe(e) {
    this.Oi.delete(e);
  }
  binding(e, t) {
    this.Ui = this.$controller.scope.parent;
    let r;
    this.Hi && ((r = this.ji.controller.scope.parent), ((this.qi = an.fromParent(r, r.bindingContext)).overrideContext.$host = this.expose ?? this.Ui.bindingContext));
  }
  attaching(e, t) {
    return Ce(this.view.activate(e, this.$controller, this.Hi ? this.qi : this.Ui), () => {
      this.Ni && (this.Vi.forEach((r) => r.watch(this)), this.We(), this.Wi(), (this.Fi = !0));
    });
  }
  detaching(e, t) {
    return (this.Fi = !1), this.zi(), this.Vi.forEach((r) => r.unwatch(this)), this.view.deactivate(e, this.$controller);
  }
  exposeChanged(e) {
    this.Hi && this.qi != null && (this.qi.overrideContext.$host = e);
  }
  dispose() {
    this.view.dispose(), (this.view = void 0);
  }
  accept(e) {
    if (this.view?.accept(e) === !0) return !0;
  }
  We() {
    if (this.Je != null) return;
    const e = this.l,
      t = e.parentElement;
    t != null &&
      (this.Je = dy(t, (r) => {
        Q8(e, r) && this.Wi();
      })).observe(t, {
        childList: !0,
      });
  }
  zi() {
    this.Je?.disconnect(), (this.Je = null);
  }
  Wi() {
    const e = this.nodes,
      t = new Set(this.Oi);
    let r;
    this.Fi && this.slotchange?.call(void 0, this.name, e);
    for (r of t) r.handleSlotChange(this, e);
  }
};
X([De], Uc.prototype, 'expose', void 0);
X([De], Uc.prototype, 'slotchange', void 0);
Uc = X(
  [
    Dx({
      name: 'au-slot',
      template: null,
      containerless: !0,
    }),
  ],
  Uc,
);
const jl = (n, e) => n.compareDocumentPosition(e),
  Q8 = (n, e) => {
    for (const { addedNodes: t, removedNodes: r, nextSibling: i } of e) {
      let s = 0,
        a = t.length,
        o;
      for (; s < a; ++s) if (((o = t[s]), jl(n.$start, o) === 4 && jl(n, o) === 2)) return !0;
      if (r.length > 0 && i != null && jl(n.$start, i) === 4 && jl(n, i) === 2) return !0;
    }
  };
var Yb;
(function (n) {
  (n[(n.Element = 1)] = 'Element'), (n[(n.Attribute = 2)] = 'Attribute');
})(Yb || (Yb = {}));
class yl {
  static get inject() {
    return [xo, Rd, ro, Cn, Ni, _o, Bv(X8)];
  }
  get pending() {
    return this.Gi;
  }
  get composition() {
    return this.Xi;
  }
  constructor(e, t, r, i, s, a, o) {
    (this.c = e), (this.parent = t), (this.host = r), (this.l = i), (this.p = s), (this.scopeBehavior = 'auto'), (this.Xi = void 0), (this.r = e.get(Ta)), (this.Ki = a), (this.Qi = o);
  }
  attaching(e, t) {
    return (this.Gi = Ce(this.queue(new Xb(this.template, this.component, this.model, void 0), e), (r) => {
      this.Qi.isCurrent(r) && (this.Gi = void 0);
    }));
  }
  detaching(e) {
    const t = this.Xi,
      r = this.Gi;
    return this.Qi.invalidate(), (this.Xi = this.Gi = void 0), Ce(r, () => t?.deactivate(e));
  }
  propertyChanged(e) {
    if (e === 'model' && this.Xi != null) {
      this.Xi.update(this.model);
      return;
    }
    this.Gi = Ce(this.Gi, () =>
      Ce(this.queue(new Xb(this.template, this.component, this.model, e), void 0), (t) => {
        this.Qi.isCurrent(t) && (this.Gi = void 0);
      }),
    );
  }
  queue(e, t) {
    const r = this.Qi,
      i = this.Xi;
    return Ce(r.create(e), (s) =>
      r.isCurrent(s)
        ? Ce(this.compose(s), (a) =>
            r.isCurrent(s)
              ? Ce(a.activate(t), () =>
                  r.isCurrent(s) ? ((this.Xi = a), Ce(i?.deactivate(t), () => s)) : Ce(a.controller.deactivate(a.controller, this.$controller), () => (a.controller.dispose(), s)),
                )
              : (a.controller.dispose(), s),
          )
        : s,
    );
  }
  compose(e) {
    let t, r, i;
    const { Yi: s, Zi: a, Ji: o } = e.change,
      { c: u, host: l, $controller: p, l: h } = this,
      b = this.getDef(a),
      E = u.createChild(),
      x = h == null ? l.parentNode : h.parentNode;
    if (b !== null) {
      if (b.containerless) throw re('AUR0806');
      h == null
        ? ((r = l), (i = () => {}))
        : ((r = x.insertBefore(this.p.document.createElement(b.name), h)),
          (i = () => {
            r.remove();
          })),
        (t = this.ts(E, a, r));
    } else (r = h ?? l), (t = this.ts(E, a, r));
    const T = () => {
      if (b !== null) {
        const w = sr.$el(
          E,
          t,
          r,
          {
            projections: this.Ki.projections,
          },
          b,
        );
        return new eg(
          w,
          (_) => w.activate(_ ?? w, p, p.scope.parent),
          (_) => Ce(w.deactivate(_ ?? w, p), i),
          (_) => t.activate?.(_),
          e,
        );
      } else {
        const w = Lr.create({
            name: Qa.generateName(),
            template: s,
          }),
          _ = this.r.getViewFactory(w, E),
          k = sr.$view(_, p),
          D = this.scopeBehavior === 'auto' ? an.fromParent(this.parent.scope, t) : an.create(t);
        return (
          Oc(r) ? k.setLocation(r) : k.setHost(r),
          new eg(
            k,
            (N) => k.activate(N ?? k, p, D),
            (N) => k.deactivate(N ?? k, p),
            (N) => t.activate?.(N),
            e,
          )
        );
      }
    };
    return 'activate' in t ? Ce(t.activate(o), () => T()) : T();
  }
  ts(e, t, r) {
    if (t == null) return new Y8();
    if (typeof t == 'object') return t;
    const i = this.p,
      s = Oc(r);
    xt(e, i.Element, xt(e, ro, new nn('ElementResolver', s ? null : r))), xt(e, Cn, new nn('IRenderLocation', s ? r : null));
    const a = e.invoke(t);
    return xt(e, t, new nn('au-compose.component', a)), a;
  }
  getDef(e) {
    const t = qn(e) ? e : e?.constructor;
    return Qa.isType(t) ? Qa.getDefinition(t) : null;
  }
}
X([De], yl.prototype, 'template', void 0);
X([De], yl.prototype, 'component', void 0);
X([De], yl.prototype, 'model', void 0);
X(
  [
    De({
      set: (n) => {
        if (n === 'scoped' || n === 'auto') return n;
        throw re('AUR0805');
      },
    }),
  ],
  yl.prototype,
  'scopeBehavior',
  void 0,
);
Dx('au-compose')(yl);
class Y8 {}
class X8 {
  constructor() {
    this.id = 0;
  }
  isCurrent(e) {
    return e.id === this.id;
  }
  create(e) {
    return Ce(e.load(), (t) => new Z8(++this.id, t));
  }
  invalidate() {
    this.id++;
  }
}
class Xb {
  constructor(e, t, r, i) {
    (this.Yi = e), (this.Zi = t), (this.Ji = r), (this.es = i);
  }
  load() {
    return tn(this.Yi) || tn(this.Zi) ? Promise.all([this.Yi, this.Zi]).then(([e, t]) => new Zb(e, t, this.Ji, this.es)) : new Zb(this.Yi, this.Zi, this.Ji, this.es);
  }
}
class Zb {
  constructor(e, t, r, i) {
    (this.Yi = e), (this.Zi = t), (this.Ji = r), (this.es = i);
  }
}
class Z8 {
  constructor(e, t) {
    (this.id = e), (this.change = t);
  }
}
class eg {
  constructor(e, t, r, i, s) {
    (this.controller = e), (this.start = t), (this.stop = r), (this.update = i), (this.context = s), (this.state = 0);
  }
  activate(e) {
    if (this.state !== 0) throw re(`AUR0807:${this.controller.name}`);
    return (this.state = 1), this.start(e);
  }
  deactivate(e) {
    switch (this.state) {
      case 1:
        return (this.state = -1), this.stop(e);
      case -1:
        throw re('AUR0808');
      default:
        this.state = -1;
    }
  }
}
const eE = /* @__PURE__ */ Dt('ISanitizer', (n) =>
  n.singleton(
    class {
      sanitize() {
        throw re('"sanitize" method not implemented');
      }
    },
  ),
);
let zf = class {
  constructor(e) {
    this.ss = e;
  }
  toView(e) {
    return e == null ? null : this.ss.sanitize(e);
  }
};
zf = X([yn(0, eE)], zf);
ul('sanitize')(zf);
sy(Vn(), {
  id: !0,
  name: !0,
  'au-slot': !0,
  'as-element': !0,
});
va('compiler-hooks');
let Pu = class {
  constructor(e, t, r) {
    (this.el = e),
      (this.p = t),
      (this.Ts = !1),
      (this.st = null),
      (this.$val = ''),
      (this.$prio = ''),
      (this.update = () => {
        (this.st = null),
          !!this.value !== this.Es &&
            (this.Es === this.Ps
              ? ((this.Es = !this.Ps),
                (this.$val = this.el.style.getPropertyValue('display')),
                (this.$prio = this.el.style.getPropertyPriority('display')),
                this.el.style.setProperty('display', 'none', 'important'))
              : ((this.Es = this.Ps), this.el.style.setProperty('display', this.$val, this.$prio), this.el.getAttribute('style') === '' && this.el.removeAttribute('style')));
      }),
      (this.Es = this.Ps = r.alias !== 'hide');
  }
  binding() {
    (this.Ts = !0), this.update();
  }
  detaching() {
    (this.Ts = !1), this.st?.cancel(), (this.st = null);
  }
  valueChanged() {
    this.Ts && this.st === null && (this.st = this.p.domWriteQueue.queueTask(this.update));
  }
};
X([De], Pu.prototype, 'value', void 0);
Pu = X([yn(0, ro), yn(1, Ni), yn(2, _o)], Pu);
o4('hide')(Pu);
Bx('show')(Pu);
function _r(n) {
  return (
    (_r =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e && typeof Symbol == 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
          }),
    _r(n)
  );
}
function tE(n, e) {
  if (_r(n) !== 'object' || n === null) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || 'default');
    if (_r(r) !== 'object') return r;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (e === 'string' ? String : Number)(n);
}
function y1(n) {
  var e = tE(n, 'string');
  return _r(e) === 'symbol' ? e : String(e);
}
function nE(n, e, t) {
  return (
    (e = y1(e)),
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function On(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      r = Object.keys(t);
    typeof Object.getOwnPropertySymbols == 'function' &&
      r.push.apply(
        r,
        Object.getOwnPropertySymbols(t).filter(function (i) {
          return Object.getOwnPropertyDescriptor(t, i).enumerable;
        }),
      ),
      r.forEach(function (i) {
        nE(n, i, t[i]);
      });
  }
  return n;
}
function $i(n, e) {
  if (!(n instanceof e)) throw new TypeError('Cannot call a class as a function');
}
function tg(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    (r.enumerable = r.enumerable || !1), (r.configurable = !0), 'value' in r && (r.writable = !0), Object.defineProperty(n, y1(r.key), r);
  }
}
function Ui(n, e, t) {
  return (
    e && tg(n.prototype, e),
    t && tg(n, t),
    Object.defineProperty(n, 'prototype', {
      writable: !1,
    }),
    n
  );
}
function sa(n) {
  if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function Iu(n, e) {
  if (e && (_r(e) === 'object' || typeof e == 'function')) return e;
  if (e !== void 0) throw new TypeError('Derived constructors may only return object or undefined');
  return sa(n);
}
function ao(n) {
  return (
    (ao = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        }),
    ao(n)
  );
}
function Gf(n, e) {
  return (
    (Gf = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (r, i) {
          return (r.__proto__ = i), r;
        }),
    Gf(n, e)
  );
}
function Pd(n, e) {
  if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function');
  (n.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: n,
      writable: !0,
      configurable: !0,
    },
  })),
    Object.defineProperty(n, 'prototype', {
      writable: !1,
    }),
    e && Gf(n, e);
}
function Hf(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++) r[t] = n[t];
  return r;
}
function rE(n) {
  if (Array.isArray(n)) return Hf(n);
}
function iE(n) {
  if ((typeof Symbol < 'u' && n[Symbol.iterator] != null) || n['@@iterator'] != null) return Array.from(n);
}
function m1(n, e) {
  if (n) {
    if (typeof n == 'string') return Hf(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if ((t === 'Object' && n.constructor && (t = n.constructor.name), t === 'Map' || t === 'Set')) return Array.from(n);
    if (t === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return Hf(n, e);
  }
}
function sE() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function aE(n) {
  return rE(n) || iE(n) || m1(n) || sE();
}
function oE(n) {
  if (Array.isArray(n)) return n;
}
function uE(n, e) {
  var t = n == null ? null : (typeof Symbol < 'u' && n[Symbol.iterator]) || n['@@iterator'];
  if (t != null) {
    var r,
      i,
      s,
      a,
      o = [],
      u = !0,
      l = !1;
    try {
      if (((s = (t = t.call(n)).next), e === 0)) {
        if (Object(t) !== t) return;
        u = !1;
      } else for (; !(u = (r = s.call(t)).done) && (o.push(r.value), o.length !== e); u = !0);
    } catch (p) {
      (l = !0), (i = p);
    } finally {
      try {
        if (!u && t.return != null && ((a = t.return()), Object(a) !== a)) return;
      } finally {
        if (l) throw i;
      }
    }
    return o;
  }
}
function lE() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ng(n, e) {
  return oE(n) || uE(n, e) || m1(n, e) || lE();
}
var cE = {
    type: 'logger',
    log: function (e) {
      this.output('log', e);
    },
    warn: function (e) {
      this.output('warn', e);
    },
    error: function (e) {
      this.output('error', e);
    },
    output: function (e, t) {
      var r;
      console && console[e] && (r = console)[e].apply(r, aE(t));
    },
  },
  dE = /* @__PURE__ */ (function () {
    function n(e) {
      var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      $i(this, n), this.init(e, t);
    }
    return (
      Ui(n, [
        {
          key: 'init',
          value: function (t) {
            var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            (this.prefix = r.prefix || 'i18next:'), (this.logger = t || cE), (this.options = r), (this.debug = r.debug);
          },
        },
        {
          key: 'setDebug',
          value: function (t) {
            this.debug = t;
          },
        },
        {
          key: 'log',
          value: function () {
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
            return this.forward(r, 'log', '', !0);
          },
        },
        {
          key: 'warn',
          value: function () {
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
            return this.forward(r, 'warn', '', !0);
          },
        },
        {
          key: 'error',
          value: function () {
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
            return this.forward(r, 'error', '');
          },
        },
        {
          key: 'deprecate',
          value: function () {
            for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++) r[i] = arguments[i];
            return this.forward(r, 'warn', 'WARNING DEPRECATED: ', !0);
          },
        },
        {
          key: 'forward',
          value: function (t, r, i, s) {
            return s && !this.debug ? null : (typeof t[0] == 'string' && (t[0] = ''.concat(i).concat(this.prefix, ' ').concat(t[0])), this.logger[r](t));
          },
        },
        {
          key: 'create',
          value: function (t) {
            return new n(
              this.logger,
              On(
                {},
                {
                  prefix: ''.concat(this.prefix, ':').concat(t, ':'),
                },
                this.options,
              ),
            );
          },
        },
      ]),
      n
    );
  })(),
  yi = new dE(),
  fs = /* @__PURE__ */ (function () {
    function n() {
      $i(this, n), (this.observers = {});
    }
    return (
      Ui(n, [
        {
          key: 'on',
          value: function (t, r) {
            var i = this;
            return (
              t.split(' ').forEach(function (s) {
                (i.observers[s] = i.observers[s] || []), i.observers[s].push(r);
              }),
              this
            );
          },
        },
        {
          key: 'off',
          value: function (t, r) {
            if (this.observers[t]) {
              if (!r) {
                delete this.observers[t];
                return;
              }
              this.observers[t] = this.observers[t].filter(function (i) {
                return i !== r;
              });
            }
          },
        },
        {
          key: 'emit',
          value: function (t) {
            for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++) i[s - 1] = arguments[s];
            if (this.observers[t]) {
              var a = [].concat(this.observers[t]);
              a.forEach(function (u) {
                u.apply(void 0, i);
              });
            }
            if (this.observers['*']) {
              var o = [].concat(this.observers['*']);
              o.forEach(function (u) {
                u.apply(u, [t].concat(i));
              });
            }
          },
        },
      ]),
      n
    );
  })();
function $o() {
  var n,
    e,
    t = new Promise(function (r, i) {
      (n = r), (e = i);
    });
  return (t.resolve = n), (t.reject = e), t;
}
function $p(n) {
  return n == null ? '' : '' + n;
}
function pE(n, e, t) {
  n.forEach(function (r) {
    e[r] && (t[r] = e[r]);
  });
}
function Ry(n, e, t) {
  function r(o) {
    return o && o.indexOf('###') > -1 ? o.replace(/###/g, '.') : o;
  }
  function i() {
    return !n || typeof n == 'string';
  }
  for (var s = typeof e != 'string' ? [].concat(e) : e.split('.'); s.length > 1; ) {
    if (i()) return {};
    var a = r(s.shift());
    !n[a] && t && (n[a] = new t()), (n = n[a]);
  }
  return i()
    ? {}
    : {
        obj: n,
        k: r(s.shift()),
      };
}
function rg(n, e, t) {
  var r = Ry(n, e, Object),
    i = r.obj,
    s = r.k;
  i[s] = t;
}
function fE(n, e, t, r) {
  var i = Ry(n, e, Object),
    s = i.obj,
    a = i.k;
  (s[a] = s[a] || []), r && (s[a] = s[a].concat(t)), r || s[a].push(t);
}
function jc(n, e) {
  var t = Ry(n, e),
    r = t.obj,
    i = t.k;
  if (r) return r[i];
}
function ig(n, e, t) {
  var r = jc(n, t);
  return r !== void 0 ? r : jc(e, t);
}
function b1(n, e, t) {
  for (var r in e) r in n ? (typeof n[r] == 'string' || n[r] instanceof String || typeof e[r] == 'string' || e[r] instanceof String ? t && (n[r] = e[r]) : b1(n[r], e[r], t)) : (n[r] = e[r]);
  return n;
}
function ka(n) {
  return n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
var hE = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;',
};
function yE(n) {
  return typeof n == 'string'
    ? n.replace(/[&<>"'\/]/g, function (e) {
        return hE[e];
      })
    : n;
}
var mE = /* @__PURE__ */ (function (n) {
    Pd(e, n);
    function e(t) {
      var r,
        i =
          arguments.length > 1 && arguments[1] !== void 0
            ? arguments[1]
            : {
                ns: ['translation'],
                defaultNS: 'translation',
              };
      return $i(this, e), (r = Iu(this, ao(e).call(this))), fs.call(sa(r)), (r.data = t || {}), (r.options = i), r.options.keySeparator === void 0 && (r.options.keySeparator = '.'), r;
    }
    return (
      Ui(e, [
        {
          key: 'addNamespaces',
          value: function (r) {
            this.options.ns.indexOf(r) < 0 && this.options.ns.push(r);
          },
        },
        {
          key: 'removeNamespaces',
          value: function (r) {
            var i = this.options.ns.indexOf(r);
            i > -1 && this.options.ns.splice(i, 1);
          },
        },
        {
          key: 'getResource',
          value: function (r, i, s) {
            var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
              o = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator,
              u = [r, i];
            return s && typeof s != 'string' && (u = u.concat(s)), s && typeof s == 'string' && (u = u.concat(o ? s.split(o) : s)), r.indexOf('.') > -1 && (u = r.split('.')), jc(this.data, u);
          },
        },
        {
          key: 'addResource',
          value: function (r, i, s, a) {
            var o =
                arguments.length > 4 && arguments[4] !== void 0
                  ? arguments[4]
                  : {
                      silent: !1,
                    },
              u = this.options.keySeparator;
            u === void 0 && (u = '.');
            var l = [r, i];
            s && (l = l.concat(u ? s.split(u) : s)),
              r.indexOf('.') > -1 && ((l = r.split('.')), (a = i), (i = l[1])),
              this.addNamespaces(i),
              rg(this.data, l, a),
              o.silent || this.emit('added', r, i, s, a);
          },
        },
        {
          key: 'addResources',
          value: function (r, i, s) {
            var a =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : {
                    silent: !1,
                  };
            for (var o in s)
              (typeof s[o] == 'string' || Object.prototype.toString.apply(s[o]) === '[object Array]') &&
                this.addResource(r, i, o, s[o], {
                  silent: !0,
                });
            a.silent || this.emit('added', r, i, s);
          },
        },
        {
          key: 'addResourceBundle',
          value: function (r, i, s, a, o) {
            var u =
                arguments.length > 5 && arguments[5] !== void 0
                  ? arguments[5]
                  : {
                      silent: !1,
                    },
              l = [r, i];
            r.indexOf('.') > -1 && ((l = r.split('.')), (a = s), (s = i), (i = l[1])), this.addNamespaces(i);
            var p = jc(this.data, l) || {};
            a ? b1(p, s, o) : (p = On({}, p, s)), rg(this.data, l, p), u.silent || this.emit('added', r, i, s);
          },
        },
        {
          key: 'removeResourceBundle',
          value: function (r, i) {
            this.hasResourceBundle(r, i) && delete this.data[r][i], this.removeNamespaces(i), this.emit('removed', r, i);
          },
        },
        {
          key: 'hasResourceBundle',
          value: function (r, i) {
            return this.getResource(r, i) !== void 0;
          },
        },
        {
          key: 'getResourceBundle',
          value: function (r, i) {
            return i || (i = this.options.defaultNS), this.options.compatibilityAPI === 'v1' ? On({}, {}, this.getResource(r, i)) : this.getResource(r, i);
          },
        },
        {
          key: 'getDataByLanguage',
          value: function (r) {
            return this.data[r];
          },
        },
        {
          key: 'toJSON',
          value: function () {
            return this.data;
          },
        },
      ]),
      e
    );
  })(fs),
  g1 = {
    processors: {},
    addPostProcessor: function (e) {
      this.processors[e.name] = e;
    },
    handle: function (e, t, r, i, s) {
      var a = this;
      return (
        e.forEach(function (o) {
          a.processors[o] && (t = a.processors[o].process(t, r, i, s));
        }),
        t
      );
    },
  },
  sg = /* @__PURE__ */ (function (n) {
    Pd(e, n);
    function e(t) {
      var r,
        i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return (
        $i(this, e),
        (r = Iu(this, ao(e).call(this))),
        fs.call(sa(r)),
        pE(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], t, sa(r)),
        (r.options = i),
        r.options.keySeparator === void 0 && (r.options.keySeparator = '.'),
        (r.logger = yi.create('translator')),
        r
      );
    }
    return (
      Ui(e, [
        {
          key: 'changeLanguage',
          value: function (r) {
            r && (this.language = r);
          },
        },
        {
          key: 'exists',
          value: function (r) {
            var i =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {
                      interpolation: {},
                    },
              s = this.resolve(r, i);
            return s && s.res !== void 0;
          },
        },
        {
          key: 'extractFromKey',
          value: function (r, i) {
            var s = i.nsSeparator || this.options.nsSeparator;
            s === void 0 && (s = ':');
            var a = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator,
              o = i.ns || this.options.defaultNS;
            if (s && r.indexOf(s) > -1) {
              var u = r.split(s);
              (s !== a || (s === a && this.options.ns.indexOf(u[0]) > -1)) && (o = u.shift()), (r = u.join(a));
            }
            return (
              typeof o == 'string' && (o = [o]),
              {
                key: r,
                namespaces: o,
              }
            );
          },
        },
        {
          key: 'translate',
          value: function (r, i) {
            var s = this;
            if ((_r(i) !== 'object' && this.options.overloadTranslationOptionHandler && (i = this.options.overloadTranslationOptionHandler(arguments)), i || (i = {}), r == null)) return '';
            Array.isArray(r) || (r = [String(r)]);
            var a = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator,
              o = this.extractFromKey(r[r.length - 1], i),
              u = o.key,
              l = o.namespaces,
              p = l[l.length - 1],
              h = i.lng || this.language,
              b = i.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
            if (h && h.toLowerCase() === 'cimode') {
              if (b) {
                var E = i.nsSeparator || this.options.nsSeparator;
                return p + E + u;
              }
              return u;
            }
            var x = this.resolve(r, i),
              T = x && x.res,
              w = (x && x.usedKey) || u,
              _ = (x && x.exactUsedKey) || u,
              k = Object.prototype.toString.apply(T),
              D = ['[object Number]', '[object Function]', '[object RegExp]'],
              N = i.joinArrays !== void 0 ? i.joinArrays : this.options.joinArrays,
              B = !this.i18nFormat || this.i18nFormat.handleAsObject,
              j = typeof T != 'string' && typeof T != 'boolean' && typeof T != 'number';
            if (B && T && j && D.indexOf(k) < 0 && !(typeof N == 'string' && k === '[object Array]')) {
              if (!i.returnObjects && !this.options.returnObjects)
                return (
                  this.logger.warn('accessing an object - but returnObjects options is not enabled!'),
                  this.options.returnedObjectHandler ? this.options.returnedObjectHandler(w, T, i) : "key '".concat(u, ' (').concat(this.language, ")' returned an object instead of string.")
                );
              if (a) {
                var q = k === '[object Array]',
                  z = q ? [] : {},
                  Y = q ? _ : w;
                for (var ae in T)
                  if (Object.prototype.hasOwnProperty.call(T, ae)) {
                    var J = ''.concat(Y).concat(a).concat(ae);
                    (z[ae] = this.translate(
                      J,
                      On({}, i, {
                        joinArrays: !1,
                        ns: l,
                      }),
                    )),
                      z[ae] === J && (z[ae] = T[ae]);
                  }
                T = z;
              }
            } else if (B && typeof N == 'string' && k === '[object Array]') (T = T.join(N)), T && (T = this.extendTranslation(T, r, i));
            else {
              var oe = !1,
                S = !1;
              if (!this.isValidLookup(T) && i.defaultValue !== void 0) {
                if (((oe = !0), i.count !== void 0)) {
                  var c = this.pluralResolver.getSuffix(h, i.count);
                  T = i['defaultValue'.concat(c)];
                }
                T || (T = i.defaultValue);
              }
              this.isValidLookup(T) || ((S = !0), (T = u));
              var y = i.defaultValue && i.defaultValue !== T && this.options.updateMissing;
              if (S || oe || y) {
                this.logger.log(y ? 'updateKey' : 'missingKey', h, p, u, y ? i.defaultValue : T);
                var v = [],
                  C = this.languageUtils.getFallbackCodes(this.options.fallbackLng, i.lng || this.language);
                if (this.options.saveMissingTo === 'fallback' && C && C[0]) for (var A = 0; A < C.length; A++) v.push(C[A]);
                else this.options.saveMissingTo === 'all' ? (v = this.languageUtils.toResolveHierarchy(i.lng || this.language)) : v.push(i.lng || this.language);
                var M = function (d, g) {
                  s.options.missingKeyHandler
                    ? s.options.missingKeyHandler(d, p, g, y ? i.defaultValue : T, y, i)
                    : s.backendConnector && s.backendConnector.saveMissing && s.backendConnector.saveMissing(d, p, g, y ? i.defaultValue : T, y, i),
                    s.emit('missingKey', d, p, g, T);
                };
                if (this.options.saveMissing) {
                  var P = i.count !== void 0 && typeof i.count != 'string';
                  this.options.saveMissingPlurals && P
                    ? v.forEach(function (m) {
                        var d = s.pluralResolver.getPluralFormsOfKey(m, u);
                        d.forEach(function (g) {
                          return M([m], g);
                        });
                      })
                    : M(v, u);
                }
              }
              (T = this.extendTranslation(T, r, i, x)),
                S && T === u && this.options.appendNamespaceToMissingKey && (T = ''.concat(p, ':').concat(u)),
                S && this.options.parseMissingKeyHandler && (T = this.options.parseMissingKeyHandler(T));
            }
            return T;
          },
        },
        {
          key: 'extendTranslation',
          value: function (r, i, s, a) {
            var o = this;
            if (this.i18nFormat && this.i18nFormat.parse)
              r = this.i18nFormat.parse(r, s, a.usedLng, a.usedNS, a.usedKey, {
                resolved: a,
              });
            else if (!s.skipInterpolation) {
              s.interpolation &&
                this.interpolator.init(
                  On({}, s, {
                    interpolation: On({}, this.options.interpolation, s.interpolation),
                  }),
                );
              var u = s.replace && typeof s.replace != 'string' ? s.replace : s;
              this.options.interpolation.defaultVariables && (u = On({}, this.options.interpolation.defaultVariables, u)),
                (r = this.interpolator.interpolate(r, u, s.lng || this.language, s)),
                s.nest !== !1 &&
                  (r = this.interpolator.nest(
                    r,
                    function () {
                      return o.translate.apply(o, arguments);
                    },
                    s,
                  )),
                s.interpolation && this.interpolator.reset();
            }
            var l = s.postProcess || this.options.postProcess,
              p = typeof l == 'string' ? [l] : l;
            return (
              r != null &&
                p &&
                p.length &&
                s.applyPostProcessor !== !1 &&
                (r = g1.handle(
                  p,
                  r,
                  i,
                  this.options && this.options.postProcessPassResolved
                    ? On(
                        {
                          i18nResolved: a,
                        },
                        s,
                      )
                    : s,
                  this,
                )),
              r
            );
          },
        },
        {
          key: 'resolve',
          value: function (r) {
            var i = this,
              s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
              a,
              o,
              u,
              l,
              p;
            return (
              typeof r == 'string' && (r = [r]),
              r.forEach(function (h) {
                if (!i.isValidLookup(a)) {
                  var b = i.extractFromKey(h, s),
                    E = b.key;
                  o = E;
                  var x = b.namespaces;
                  i.options.fallbackNS && (x = x.concat(i.options.fallbackNS));
                  var T = s.count !== void 0 && typeof s.count != 'string',
                    w = s.context !== void 0 && typeof s.context == 'string' && s.context !== '',
                    _ = s.lngs ? s.lngs : i.languageUtils.toResolveHierarchy(s.lng || i.language, s.fallbackLng);
                  x.forEach(function (k) {
                    i.isValidLookup(a) ||
                      ((p = k),
                      i.utils &&
                        i.utils.hasLoadedNamespace &&
                        !i.utils.hasLoadedNamespace(p) &&
                        i.logger.warn(
                          'key "'.concat(o, '" for namespace "').concat(p, `" won't get resolved as namespace was not yet loaded`),
                          'This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!',
                        ),
                      _.forEach(function (D) {
                        if (!i.isValidLookup(a)) {
                          l = D;
                          var N = E,
                            B = [N];
                          if (i.i18nFormat && i.i18nFormat.addLookupKeys) i.i18nFormat.addLookupKeys(B, E, D, k, s);
                          else {
                            var j;
                            T && (j = i.pluralResolver.getSuffix(D, s.count)),
                              T && w && B.push(N + j),
                              w && B.push((N += ''.concat(i.options.contextSeparator).concat(s.context))),
                              T && B.push((N += j));
                          }
                          for (var q; (q = B.pop()); ) i.isValidLookup(a) || ((u = q), (a = i.getResource(D, k, q, s)));
                        }
                      }));
                  });
                }
              }),
              {
                res: a,
                usedKey: o,
                exactUsedKey: u,
                usedLng: l,
                usedNS: p,
              }
            );
          },
        },
        {
          key: 'isValidLookup',
          value: function (r) {
            return r !== void 0 && !(!this.options.returnNull && r === null) && !(!this.options.returnEmptyString && r === '');
          },
        },
        {
          key: 'getResource',
          value: function (r, i, s) {
            var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(r, i, s, a) : this.resourceStore.getResource(r, i, s, a);
          },
        },
      ]),
      e
    );
  })(fs);
function Up(n) {
  return n.charAt(0).toUpperCase() + n.slice(1);
}
var bE = /* @__PURE__ */ (function () {
    function n(e) {
      $i(this, n), (this.options = e), (this.whitelist = this.options.whitelist || !1), (this.logger = yi.create('languageUtils'));
    }
    return (
      Ui(n, [
        {
          key: 'getScriptPartFromCode',
          value: function (t) {
            if (!t || t.indexOf('-') < 0) return null;
            var r = t.split('-');
            return r.length === 2 ? null : (r.pop(), this.formatLanguageCode(r.join('-')));
          },
        },
        {
          key: 'getLanguagePartFromCode',
          value: function (t) {
            if (!t || t.indexOf('-') < 0) return t;
            var r = t.split('-');
            return this.formatLanguageCode(r[0]);
          },
        },
        {
          key: 'formatLanguageCode',
          value: function (t) {
            if (typeof t == 'string' && t.indexOf('-') > -1) {
              var r = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'],
                i = t.split('-');
              return (
                this.options.lowerCaseLng
                  ? (i = i.map(function (s) {
                      return s.toLowerCase();
                    }))
                  : i.length === 2
                  ? ((i[0] = i[0].toLowerCase()), (i[1] = i[1].toUpperCase()), r.indexOf(i[1].toLowerCase()) > -1 && (i[1] = Up(i[1].toLowerCase())))
                  : i.length === 3 &&
                    ((i[0] = i[0].toLowerCase()),
                    i[1].length === 2 && (i[1] = i[1].toUpperCase()),
                    i[0] !== 'sgn' && i[2].length === 2 && (i[2] = i[2].toUpperCase()),
                    r.indexOf(i[1].toLowerCase()) > -1 && (i[1] = Up(i[1].toLowerCase())),
                    r.indexOf(i[2].toLowerCase()) > -1 && (i[2] = Up(i[2].toLowerCase()))),
                i.join('-')
              );
            }
            return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
          },
        },
        {
          key: 'isWhitelisted',
          value: function (t) {
            return (
              (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist) && (t = this.getLanguagePartFromCode(t)),
              !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(t) > -1
            );
          },
        },
        {
          key: 'getFallbackCodes',
          value: function (t, r) {
            if (!t) return [];
            if ((typeof t == 'string' && (t = [t]), Object.prototype.toString.apply(t) === '[object Array]')) return t;
            if (!r) return t.default || [];
            var i = t[r];
            return i || (i = t[this.getScriptPartFromCode(r)]), i || (i = t[this.formatLanguageCode(r)]), i || (i = t.default), i || [];
          },
        },
        {
          key: 'toResolveHierarchy',
          value: function (t, r) {
            var i = this,
              s = this.getFallbackCodes(r || this.options.fallbackLng || [], t),
              a = [],
              o = function (l) {
                l && (i.isWhitelisted(l) ? a.push(l) : i.logger.warn('rejecting non-whitelisted language code: '.concat(l)));
              };
            return (
              typeof t == 'string' && t.indexOf('-') > -1
                ? (this.options.load !== 'languageOnly' && o(this.formatLanguageCode(t)),
                  this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly' && o(this.getScriptPartFromCode(t)),
                  this.options.load !== 'currentOnly' && o(this.getLanguagePartFromCode(t)))
                : typeof t == 'string' && o(this.formatLanguageCode(t)),
              s.forEach(function (u) {
                a.indexOf(u) < 0 && o(i.formatLanguageCode(u));
              }),
              a
            );
          },
        },
      ]),
      n
    );
  })(),
  gE = [
    {
      lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'ti', 'tr', 'uz', 'wa'],
      nr: [1, 2],
      fc: 1,
    },
    {
      lngs: [
        'af',
        'an',
        'ast',
        'az',
        'bg',
        'bn',
        'ca',
        'da',
        'de',
        'dev',
        'el',
        'en',
        'eo',
        'es',
        'et',
        'eu',
        'fi',
        'fo',
        'fur',
        'fy',
        'gl',
        'gu',
        'ha',
        'hi',
        'hu',
        'hy',
        'ia',
        'it',
        'kn',
        'ku',
        'lb',
        'mai',
        'ml',
        'mn',
        'mr',
        'nah',
        'nap',
        'nb',
        'ne',
        'nl',
        'nn',
        'no',
        'nso',
        'pa',
        'pap',
        'pms',
        'ps',
        'pt-PT',
        'rm',
        'sco',
        'se',
        'si',
        'so',
        'son',
        'sq',
        'sv',
        'sw',
        'ta',
        'te',
        'tk',
        'ur',
        'yo',
      ],
      nr: [1, 2],
      fc: 2,
    },
    {
      lngs: ['ay', 'bo', 'cgg', 'fa', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
      nr: [1],
      fc: 3,
    },
    {
      lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
      nr: [1, 2, 5],
      fc: 4,
    },
    {
      lngs: ['ar'],
      nr: [0, 1, 2, 3, 11, 100],
      fc: 5,
    },
    {
      lngs: ['cs', 'sk'],
      nr: [1, 2, 5],
      fc: 6,
    },
    {
      lngs: ['csb', 'pl'],
      nr: [1, 2, 5],
      fc: 7,
    },
    {
      lngs: ['cy'],
      nr: [1, 2, 3, 8],
      fc: 8,
    },
    {
      lngs: ['fr'],
      nr: [1, 2],
      fc: 9,
    },
    {
      lngs: ['ga'],
      nr: [1, 2, 3, 7, 11],
      fc: 10,
    },
    {
      lngs: ['gd'],
      nr: [1, 2, 3, 20],
      fc: 11,
    },
    {
      lngs: ['is'],
      nr: [1, 2],
      fc: 12,
    },
    {
      lngs: ['jv'],
      nr: [0, 1],
      fc: 13,
    },
    {
      lngs: ['kw'],
      nr: [1, 2, 3, 4],
      fc: 14,
    },
    {
      lngs: ['lt'],
      nr: [1, 2, 10],
      fc: 15,
    },
    {
      lngs: ['lv'],
      nr: [1, 2, 0],
      fc: 16,
    },
    {
      lngs: ['mk'],
      nr: [1, 2],
      fc: 17,
    },
    {
      lngs: ['mnk'],
      nr: [0, 1, 2],
      fc: 18,
    },
    {
      lngs: ['mt'],
      nr: [1, 2, 11, 20],
      fc: 19,
    },
    {
      lngs: ['or'],
      nr: [2, 1],
      fc: 2,
    },
    {
      lngs: ['ro'],
      nr: [1, 2, 20],
      fc: 20,
    },
    {
      lngs: ['sl'],
      nr: [5, 1, 2, 3],
      fc: 21,
    },
    {
      lngs: ['he'],
      nr: [1, 2, 20, 21],
      fc: 22,
    },
  ],
  vE = {
    1: function (e) {
      return +(e > 1);
    },
    2: function (e) {
      return +(e != 1);
    },
    3: function (e) {
      return 0;
    },
    4: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
    },
    5: function (e) {
      return e === 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5;
    },
    6: function (e) {
      return e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2;
    },
    7: function (e) {
      return e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
    },
    8: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3;
    },
    9: function (e) {
      return +(e >= 2);
    },
    10: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4;
    },
    11: function (e) {
      return e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3;
    },
    12: function (e) {
      return +(e % 10 != 1 || e % 100 == 11);
    },
    13: function (e) {
      return +(e !== 0);
    },
    14: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3;
    },
    15: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
    },
    16: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2;
    },
    17: function (e) {
      return e == 1 || e % 10 == 1 ? 0 : 1;
    },
    18: function (e) {
      return e == 0 ? 0 : e == 1 ? 1 : 2;
    },
    19: function (e) {
      return e == 1 ? 0 : e === 0 || (e % 100 > 1 && e % 100 < 11) ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3;
    },
    20: function (e) {
      return e == 1 ? 0 : e === 0 || (e % 100 > 0 && e % 100 < 20) ? 1 : 2;
    },
    21: function (e) {
      return e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0;
    },
    22: function (e) {
      return e === 1 ? 0 : e === 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3;
    },
  };
function xE() {
  var n = {};
  return (
    gE.forEach(function (e) {
      e.lngs.forEach(function (t) {
        n[t] = {
          numbers: e.nr,
          plurals: vE[e.fc],
        };
      });
    }),
    n
  );
}
var wE = /* @__PURE__ */ (function () {
    function n(e) {
      var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      $i(this, n), (this.languageUtils = e), (this.options = t), (this.logger = yi.create('pluralResolver')), (this.rules = xE());
    }
    return (
      Ui(n, [
        {
          key: 'addRule',
          value: function (t, r) {
            this.rules[t] = r;
          },
        },
        {
          key: 'getRule',
          value: function (t) {
            return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)];
          },
        },
        {
          key: 'needsPlural',
          value: function (t) {
            var r = this.getRule(t);
            return r && r.numbers.length > 1;
          },
        },
        {
          key: 'getPluralFormsOfKey',
          value: function (t, r) {
            var i = this,
              s = [],
              a = this.getRule(t);
            return (
              a &&
                a.numbers.forEach(function (o) {
                  var u = i.getSuffix(t, o);
                  s.push(''.concat(r).concat(u));
                }),
              s
            );
          },
        },
        {
          key: 'getSuffix',
          value: function (t, r) {
            var i = this,
              s = this.getRule(t);
            if (s) {
              var a = s.noAbs ? s.plurals(r) : s.plurals(Math.abs(r)),
                o = s.numbers[a];
              this.options.simplifyPluralSuffix && s.numbers.length === 2 && s.numbers[0] === 1 && (o === 2 ? (o = 'plural') : o === 1 && (o = ''));
              var u = function () {
                return i.options.prepend && o.toString() ? i.options.prepend + o.toString() : o.toString();
              };
              return this.options.compatibilityJSON === 'v1'
                ? o === 1
                  ? ''
                  : typeof o == 'number'
                  ? '_plural_'.concat(o.toString())
                  : u()
                : /* v2 */
                this.options.compatibilityJSON === 'v2' /* v3 - gettext index */ || (this.options.simplifyPluralSuffix && s.numbers.length === 2 && s.numbers[0] === 1)
                ? u()
                : this.options.prepend && a.toString()
                ? this.options.prepend + a.toString()
                : a.toString();
            }
            return this.logger.warn('no plural rule found for: '.concat(t)), '';
          },
        },
      ]),
      n
    );
  })(),
  TE = /* @__PURE__ */ (function () {
    function n() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      $i(this, n),
        (this.logger = yi.create('interpolator')),
        (this.options = e),
        (this.format =
          (e.interpolation && e.interpolation.format) ||
          function (t) {
            return t;
          }),
        this.init(e);
    }
    return (
      Ui(n, [
        {
          key: 'init',
          value: function () {
            var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            t.interpolation ||
              (t.interpolation = {
                escapeValue: !0,
              });
            var r = t.interpolation;
            (this.escape = r.escape !== void 0 ? r.escape : yE),
              (this.escapeValue = r.escapeValue !== void 0 ? r.escapeValue : !0),
              (this.useRawValueToEscape = r.useRawValueToEscape !== void 0 ? r.useRawValueToEscape : !1),
              (this.prefix = r.prefix ? ka(r.prefix) : r.prefixEscaped || '{{'),
              (this.suffix = r.suffix ? ka(r.suffix) : r.suffixEscaped || '}}'),
              (this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ','),
              (this.unescapePrefix = r.unescapeSuffix ? '' : r.unescapePrefix || '-'),
              (this.unescapeSuffix = this.unescapePrefix ? '' : r.unescapeSuffix || ''),
              (this.nestingPrefix = r.nestingPrefix ? ka(r.nestingPrefix) : r.nestingPrefixEscaped || ka('$t(')),
              (this.nestingSuffix = r.nestingSuffix ? ka(r.nestingSuffix) : r.nestingSuffixEscaped || ka(')')),
              (this.maxReplaces = r.maxReplaces ? r.maxReplaces : 1e3),
              this.resetRegExp();
          },
        },
        {
          key: 'reset',
          value: function () {
            this.options && this.init(this.options);
          },
        },
        {
          key: 'resetRegExp',
          value: function () {
            var t = ''.concat(this.prefix, '(.+?)').concat(this.suffix);
            this.regexp = new RegExp(t, 'g');
            var r = ''.concat(this.prefix).concat(this.unescapePrefix, '(.+?)').concat(this.unescapeSuffix).concat(this.suffix);
            this.regexpUnescape = new RegExp(r, 'g');
            var i = ''.concat(this.nestingPrefix, '(.+?)').concat(this.nestingSuffix);
            this.nestingRegexp = new RegExp(i, 'g');
          },
        },
        {
          key: 'interpolate',
          value: function (t, r, i, s) {
            var a = this,
              o,
              u,
              l,
              p = (this.options && this.options.interpolation && this.options.interpolation.defaultVariables) || {};
            function h(w) {
              return w.replace(/\$/g, '$$$$');
            }
            var b = function (_) {
              if (_.indexOf(a.formatSeparator) < 0) return ig(r, p, _);
              var k = _.split(a.formatSeparator),
                D = k.shift().trim(),
                N = k.join(a.formatSeparator).trim();
              return a.format(ig(r, p, D), N, i);
            };
            this.resetRegExp();
            var E = (s && s.missingInterpolationHandler) || this.options.missingInterpolationHandler;
            for (l = 0; (o = this.regexpUnescape.exec(t)); ) {
              if (((u = b(o[1].trim())), u === void 0))
                if (typeof E == 'function') {
                  var x = E(t, o, s);
                  u = typeof x == 'string' ? x : '';
                } else this.logger.warn('missed to pass in variable '.concat(o[1], ' for interpolating ').concat(t)), (u = '');
              else typeof u != 'string' && !this.useRawValueToEscape && (u = $p(u));
              if (((t = t.replace(o[0], h(u))), (this.regexpUnescape.lastIndex = 0), l++, l >= this.maxReplaces)) break;
            }
            for (l = 0; (o = this.regexp.exec(t)); ) {
              if (((u = b(o[1].trim())), u === void 0))
                if (typeof E == 'function') {
                  var T = E(t, o, s);
                  u = typeof T == 'string' ? T : '';
                } else this.logger.warn('missed to pass in variable '.concat(o[1], ' for interpolating ').concat(t)), (u = '');
              else typeof u != 'string' && !this.useRawValueToEscape && (u = $p(u));
              if (((u = this.escapeValue ? h(this.escape(u)) : h(u)), (t = t.replace(o[0], u)), (this.regexp.lastIndex = 0), l++, l >= this.maxReplaces)) break;
            }
            return t;
          },
        },
        {
          key: 'nest',
          value: function (t, r) {
            var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
              s,
              a,
              o = On({}, i);
            (o.applyPostProcessor = !1), delete o.defaultValue;
            function u(l, p) {
              if (l.indexOf(',') < 0) return l;
              var h = l.split(',');
              l = h.shift();
              var b = h.join(',');
              (b = this.interpolate(b, o)), (b = b.replace(/'/g, '"'));
              try {
                (o = JSON.parse(b)), p && (o = On({}, p, o));
              } catch (E) {
                this.logger.error('failed parsing options string in nesting for key '.concat(l), E);
              }
              return delete o.defaultValue, l;
            }
            for (; (s = this.nestingRegexp.exec(t)); ) {
              if (((a = r(u.call(this, s[1].trim(), o), o)), a && s[0] === t && typeof a != 'string')) return a;
              typeof a != 'string' && (a = $p(a)),
                a || (this.logger.warn('missed to resolve '.concat(s[1], ' for nesting ').concat(t)), (a = '')),
                (t = t.replace(s[0], a)),
                (this.regexp.lastIndex = 0);
            }
            return t;
          },
        },
      ]),
      n
    );
  })();
function AE(n, e) {
  for (var t = n.indexOf(e); t !== -1; ) n.splice(t, 1), (t = n.indexOf(e));
}
var EE = /* @__PURE__ */ (function (n) {
  Pd(e, n);
  function e(t, r, i) {
    var s,
      a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return (
      $i(this, e),
      (s = Iu(this, ao(e).call(this))),
      fs.call(sa(s)),
      (s.backend = t),
      (s.store = r),
      (s.services = i),
      (s.languageUtils = i.languageUtils),
      (s.options = a),
      (s.logger = yi.create('backendConnector')),
      (s.state = {}),
      (s.queue = []),
      s.backend && s.backend.init && s.backend.init(i, a.backend, a),
      s
    );
  }
  return (
    Ui(e, [
      {
        key: 'queueLoad',
        value: function (r, i, s, a) {
          var o = this,
            u = [],
            l = [],
            p = [],
            h = [];
          return (
            r.forEach(function (b) {
              var E = !0;
              i.forEach(function (x) {
                var T = ''.concat(b, '|').concat(x);
                !s.reload && o.store.hasResourceBundle(b, x)
                  ? (o.state[T] = 2)
                  : o.state[T] < 0 ||
                    (o.state[T] === 1 ? l.indexOf(T) < 0 && l.push(T) : ((o.state[T] = 1), (E = !1), l.indexOf(T) < 0 && l.push(T), u.indexOf(T) < 0 && u.push(T), h.indexOf(x) < 0 && h.push(x)));
              }),
                E || p.push(b);
            }),
            (u.length || l.length) &&
              this.queue.push({
                pending: l,
                loaded: {},
                errors: [],
                callback: a,
              }),
            {
              toLoad: u,
              pending: l,
              toLoadLanguages: p,
              toLoadNamespaces: h,
            }
          );
        },
      },
      {
        key: 'loaded',
        value: function (r, i, s) {
          var a = r.split('|'),
            o = ng(a, 2),
            u = o[0],
            l = o[1];
          i && this.emit('failedLoading', u, l, i), s && this.store.addResourceBundle(u, l, s), (this.state[r] = i ? -1 : 2);
          var p = {};
          this.queue.forEach(function (h) {
            fE(h.loaded, [u], l),
              AE(h.pending, r),
              i && h.errors.push(i),
              h.pending.length === 0 &&
                !h.done &&
                (Object.keys(h.loaded).forEach(function (b) {
                  p[b] || (p[b] = []),
                    h.loaded[b].length &&
                      h.loaded[b].forEach(function (E) {
                        p[b].indexOf(E) < 0 && p[b].push(E);
                      });
                }),
                (h.done = !0),
                h.errors.length ? h.callback(h.errors) : h.callback());
          }),
            this.emit('loaded', p),
            (this.queue = this.queue.filter(function (h) {
              return !h.done;
            }));
        },
      },
      {
        key: 'read',
        value: function (r, i, s) {
          var a = this,
            o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
            u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 250,
            l = arguments.length > 5 ? arguments[5] : void 0;
          return r.length
            ? this.backend[s](r, i, function (p, h) {
                if (p && h && o < 5) {
                  setTimeout(function () {
                    a.read.call(a, r, i, s, o + 1, u * 2, l);
                  }, u);
                  return;
                }
                l(p, h);
              })
            : l(null, {});
        },
        /* eslint consistent-return: 0 */
      },
      {
        key: 'prepareLoading',
        value: function (r, i) {
          var s = this,
            a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
            o = arguments.length > 3 ? arguments[3] : void 0;
          if (!this.backend) return this.logger.warn('No backend was added via i18next.use. Will not load resources.'), o && o();
          typeof r == 'string' && (r = this.languageUtils.toResolveHierarchy(r)), typeof i == 'string' && (i = [i]);
          var u = this.queueLoad(r, i, a, o);
          if (!u.toLoad.length) return u.pending.length || o(), null;
          u.toLoad.forEach(function (l) {
            s.loadOne(l);
          });
        },
      },
      {
        key: 'load',
        value: function (r, i, s) {
          this.prepareLoading(r, i, {}, s);
        },
      },
      {
        key: 'reload',
        value: function (r, i, s) {
          this.prepareLoading(
            r,
            i,
            {
              reload: !0,
            },
            s,
          );
        },
      },
      {
        key: 'loadOne',
        value: function (r) {
          var i = this,
            s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '',
            a = r.split('|'),
            o = ng(a, 2),
            u = o[0],
            l = o[1];
          this.read(u, l, 'read', null, null, function (p, h) {
            p && i.logger.warn(''.concat(s, 'loading namespace ').concat(l, ' for language ').concat(u, ' failed'), p),
              !p && h && i.logger.log(''.concat(s, 'loaded namespace ').concat(l, ' for language ').concat(u), h),
              i.loaded(r, p, h);
          });
        },
      },
      {
        key: 'saveMissing',
        value: function (r, i, s, a, o) {
          var u = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
          if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(i)) {
            this.logger.warn(
              'did not save key "'.concat(s, '" for namespace "').concat(i, '" as the namespace was not yet loaded'),
              'This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!',
            );
            return;
          }
          this.backend &&
            this.backend.create &&
            this.backend.create(
              r,
              i,
              s,
              a,
              null,
              On({}, u, {
                isUpdate: o,
              }),
            ),
            !(!r || !r[0]) && this.store.addResource(r[0], i, s, a);
        },
      },
    ]),
    e
  );
})(fs);
function CE() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ['translation'],
    defaultNS: ['translation'],
    fallbackLng: ['dev'],
    fallbackNS: !1,
    // string or array of namespaces
    whitelist: !1,
    // array with whitelisted languages
    nonExplicitWhitelist: !1,
    load: 'all',
    // | currentOnly | languageOnly
    preload: !1,
    // array with preload languages
    simplifyPluralSuffix: !0,
    keySeparator: '.',
    nsSeparator: ':',
    pluralSeparator: '_',
    contextSeparator: '_',
    partialBundledLanguages: !1,
    // allow bundling certain languages that are not remotely fetched
    saveMissing: !1,
    // enable to send missing values
    updateMissing: !1,
    // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
    saveMissingTo: 'fallback',
    // 'current' || 'all'
    saveMissingPlurals: !0,
    // will save all forms not only singular key
    missingKeyHandler: !1,
    // function(lng, ns, key, fallbackValue) -> override if prefer on handling
    missingInterpolationHandler: !1,
    // function(str, match)
    postProcess: !1,
    // string or array of postProcessor names
    postProcessPassResolved: !1,
    // pass resolved object into 'options.i18nResolved' for postprocessor
    returnNull: !0,
    // allows null value as valid translation
    returnEmptyString: !0,
    // allows empty string value as valid translation
    returnObjects: !1,
    joinArrays: !1,
    // or string to join array
    returnedObjectHandler: !1,
    // function(key, value, options) triggered if key returns object but returnObjects is set to false
    parseMissingKeyHandler: !1,
    // function(key) parsed a key that was not found in t() before returning
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function (e) {
      var t = {};
      if (
        (_r(e[1]) === 'object' && (t = e[1]), typeof e[1] == 'string' && (t.defaultValue = e[1]), typeof e[2] == 'string' && (t.tDescription = e[2]), _r(e[2]) === 'object' || _r(e[3]) === 'object')
      ) {
        var r = e[3] || e[2];
        Object.keys(r).forEach(function (i) {
          t[i] = r[i];
        });
      }
      return t;
    },
    interpolation: {
      escapeValue: !0,
      format: function (e, t, r) {
        return e;
      },
      prefix: '{{',
      suffix: '}}',
      formatSeparator: ',',
      // prefixEscaped: '{{',
      // suffixEscaped: '}}',
      // unescapeSuffix: '',
      unescapePrefix: '-',
      nestingPrefix: '$t(',
      nestingSuffix: ')',
      // nestingPrefixEscaped: '$t(',
      // nestingSuffixEscaped: ')',
      // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
      maxReplaces: 1e3,
      // max replaces to prevent endless loop
    },
  };
}
function ag(n) {
  return (
    typeof n.ns == 'string' && (n.ns = [n.ns]),
    typeof n.fallbackLng == 'string' && (n.fallbackLng = [n.fallbackLng]),
    typeof n.fallbackNS == 'string' && (n.fallbackNS = [n.fallbackNS]),
    n.whitelist && n.whitelist.indexOf('cimode') < 0 && (n.whitelist = n.whitelist.concat(['cimode'])),
    n
  );
}
function Vl() {}
var SE = /* @__PURE__ */ (function (n) {
  Pd(e, n);
  function e() {
    var t,
      r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      i = arguments.length > 1 ? arguments[1] : void 0;
    if (
      ($i(this, e),
      (t = Iu(this, ao(e).call(this))),
      fs.call(sa(t)),
      (t.options = ag(r)),
      (t.services = {}),
      (t.logger = yi),
      (t.modules = {
        external: [],
      }),
      i && !t.isInitialized && !r.isClone)
    ) {
      if (!t.options.initImmediate) return t.init(r, i), Iu(t, sa(t));
      setTimeout(function () {
        t.init(r, i);
      }, 0);
    }
    return t;
  }
  return (
    Ui(e, [
      {
        key: 'init',
        value: function () {
          var r = this,
            i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            s = arguments.length > 1 ? arguments[1] : void 0;
          typeof i == 'function' && ((s = i), (i = {})), (this.options = On({}, CE(), this.options, ag(i))), (this.format = this.options.interpolation.format), s || (s = Vl);
          function a(b) {
            return b ? (typeof b == 'function' ? new b() : b) : null;
          }
          if (!this.options.isClone) {
            this.modules.logger ? yi.init(a(this.modules.logger), this.options) : yi.init(null, this.options);
            var o = new bE(this.options);
            this.store = new mE(this.options.resources, this.options);
            var u = this.services;
            (u.logger = yi),
              (u.resourceStore = this.store),
              (u.languageUtils = o),
              (u.pluralResolver = new wE(o, {
                prepend: this.options.pluralSeparator,
                compatibilityJSON: this.options.compatibilityJSON,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix,
              })),
              (u.interpolator = new TE(this.options)),
              (u.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this),
              }),
              (u.backendConnector = new EE(a(this.modules.backend), u.resourceStore, u, this.options)),
              u.backendConnector.on('*', function (b) {
                for (var E = arguments.length, x = new Array(E > 1 ? E - 1 : 0), T = 1; T < E; T++) x[T - 1] = arguments[T];
                r.emit.apply(r, [b].concat(x));
              }),
              this.modules.languageDetector && ((u.languageDetector = a(this.modules.languageDetector)), u.languageDetector.init(u, this.options.detection, this.options)),
              this.modules.i18nFormat && ((u.i18nFormat = a(this.modules.i18nFormat)), u.i18nFormat.init && u.i18nFormat.init(this)),
              (this.translator = new sg(this.services, this.options)),
              this.translator.on('*', function (b) {
                for (var E = arguments.length, x = new Array(E > 1 ? E - 1 : 0), T = 1; T < E; T++) x[T - 1] = arguments[T];
                r.emit.apply(r, [b].concat(x));
              }),
              this.modules.external.forEach(function (b) {
                b.init && b.init(r);
              });
          }
          var l = ['getResource', 'addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
          l.forEach(function (b) {
            r[b] = function () {
              var E;
              return (E = r.store)[b].apply(E, arguments);
            };
          });
          var p = $o(),
            h = function () {
              r.changeLanguage(r.options.lng, function (E, x) {
                (r.isInitialized = !0), r.logger.log('initialized', r.options), r.emit('initialized', r.options), p.resolve(x), s(E, x);
              });
            };
          return this.options.resources || !this.options.initImmediate ? h() : setTimeout(h, 0), p;
        },
        /* eslint consistent-return: 0 */
      },
      {
        key: 'loadResources',
        value: function () {
          var r = this,
            i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Vl;
          if (!this.options.resources || this.options.partialBundledLanguages) {
            if (this.language && this.language.toLowerCase() === 'cimode') return i();
            var s = [],
              a = function (l) {
                if (l) {
                  var p = r.services.languageUtils.toResolveHierarchy(l);
                  p.forEach(function (h) {
                    s.indexOf(h) < 0 && s.push(h);
                  });
                }
              };
            if (this.language) a(this.language);
            else {
              var o = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
              o.forEach(function (u) {
                return a(u);
              });
            }
            this.options.preload &&
              this.options.preload.forEach(function (u) {
                return a(u);
              }),
              this.services.backendConnector.load(s, this.options.ns, i);
          } else i(null);
        },
      },
      {
        key: 'reloadResources',
        value: function (r, i, s) {
          var a = $o();
          return (
            r || (r = this.languages),
            i || (i = this.options.ns),
            s || (s = Vl),
            this.services.backendConnector.reload(r, i, function (o) {
              a.resolve(), s(o);
            }),
            a
          );
        },
      },
      {
        key: 'use',
        value: function (r) {
          return (
            r.type === 'backend' && (this.modules.backend = r),
            (r.type === 'logger' || (r.log && r.warn && r.error)) && (this.modules.logger = r),
            r.type === 'languageDetector' && (this.modules.languageDetector = r),
            r.type === 'i18nFormat' && (this.modules.i18nFormat = r),
            r.type === 'postProcessor' && g1.addPostProcessor(r),
            r.type === '3rdParty' && this.modules.external.push(r),
            this
          );
        },
      },
      {
        key: 'changeLanguage',
        value: function (r, i) {
          var s = this,
            a = $o();
          this.emit('languageChanging', r);
          var o = function (p, h) {
              s.translator.changeLanguage(h),
                h && (s.emit('languageChanged', h), s.logger.log('languageChanged', h)),
                a.resolve(function () {
                  return s.t.apply(s, arguments);
                }),
                i &&
                  i(p, function () {
                    return s.t.apply(s, arguments);
                  });
            },
            u = function (p) {
              p &&
                ((s.language = p),
                (s.languages = s.services.languageUtils.toResolveHierarchy(p)),
                s.translator.language || s.translator.changeLanguage(p),
                s.services.languageDetector && s.services.languageDetector.cacheUserLanguage(p)),
                s.loadResources(function (h) {
                  o(h, p);
                });
            };
          return (
            !r && this.services.languageDetector && !this.services.languageDetector.async
              ? u(this.services.languageDetector.detect())
              : !r && this.services.languageDetector && this.services.languageDetector.async
              ? this.services.languageDetector.detect(u)
              : u(r),
            a
          );
        },
      },
      {
        key: 'getFixedT',
        value: function (r, i) {
          var s = this,
            a = function o(u, l) {
              var p;
              if (_r(l) !== 'object') {
                for (var h = arguments.length, b = new Array(h > 2 ? h - 2 : 0), E = 2; E < h; E++) b[E - 2] = arguments[E];
                p = s.options.overloadTranslationOptionHandler([u, l].concat(b));
              } else p = On({}, l);
              return (p.lng = p.lng || o.lng), (p.lngs = p.lngs || o.lngs), (p.ns = p.ns || o.ns), s.t(u, p);
            };
          return typeof r == 'string' ? (a.lng = r) : (a.lngs = r), (a.ns = i), a;
        },
      },
      {
        key: 't',
        value: function () {
          var r;
          return this.translator && (r = this.translator).translate.apply(r, arguments);
        },
      },
      {
        key: 'exists',
        value: function () {
          var r;
          return this.translator && (r = this.translator).exists.apply(r, arguments);
        },
      },
      {
        key: 'setDefaultNamespace',
        value: function (r) {
          this.options.defaultNS = r;
        },
      },
      {
        key: 'hasLoadedNamespace',
        value: function (r) {
          var i = this;
          if (!this.isInitialized) return this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages), !1;
          if (!this.languages || !this.languages.length) return this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages), !1;
          var s = this.languages[0],
            a = this.options ? this.options.fallbackLng : !1,
            o = this.languages[this.languages.length - 1];
          if (s.toLowerCase() === 'cimode') return !0;
          var u = function (p, h) {
            var b = i.services.backendConnector.state[''.concat(p, '|').concat(h)];
            return b === -1 || b === 2;
          };
          return !!(this.hasResourceBundle(s, r) || !this.services.backendConnector.backend || (u(s, r) && (!a || u(o, r))));
        },
      },
      {
        key: 'loadNamespaces',
        value: function (r, i) {
          var s = this,
            a = $o();
          return this.options.ns
            ? (typeof r == 'string' && (r = [r]),
              r.forEach(function (o) {
                s.options.ns.indexOf(o) < 0 && s.options.ns.push(o);
              }),
              this.loadResources(function (o) {
                a.resolve(), i && i(o);
              }),
              a)
            : (i && i(), Promise.resolve());
        },
      },
      {
        key: 'loadLanguages',
        value: function (r, i) {
          var s = $o();
          typeof r == 'string' && (r = [r]);
          var a = this.options.preload || [],
            o = r.filter(function (u) {
              return a.indexOf(u) < 0;
            });
          return o.length
            ? ((this.options.preload = a.concat(o)),
              this.loadResources(function (u) {
                s.resolve(), i && i(u);
              }),
              s)
            : (i && i(), Promise.resolve());
        },
      },
      {
        key: 'dir',
        value: function (r) {
          if ((r || (r = this.languages && this.languages.length > 0 ? this.languages[0] : this.language), !r)) return 'rtl';
          var i = [
            'ar',
            'shu',
            'sqr',
            'ssh',
            'xaa',
            'yhd',
            'yud',
            'aao',
            'abh',
            'abv',
            'acm',
            'acq',
            'acw',
            'acx',
            'acy',
            'adf',
            'ads',
            'aeb',
            'aec',
            'afb',
            'ajp',
            'apc',
            'apd',
            'arb',
            'arq',
            'ars',
            'ary',
            'arz',
            'auz',
            'avl',
            'ayh',
            'ayl',
            'ayn',
            'ayp',
            'bbz',
            'pga',
            'he',
            'iw',
            'ps',
            'pbt',
            'pbu',
            'pst',
            'prp',
            'prd',
            'ur',
            'ydd',
            'yds',
            'yih',
            'ji',
            'yi',
            'hbo',
            'men',
            'xmn',
            'fa',
            'jpr',
            'peo',
            'pes',
            'prs',
            'dv',
            'sam',
          ];
          return i.indexOf(this.services.languageUtils.getLanguagePartFromCode(r)) >= 0 ? 'rtl' : 'ltr';
        },
        /* eslint class-methods-use-this: 0 */
      },
      {
        key: 'createInstance',
        value: function () {
          var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            i = arguments.length > 1 ? arguments[1] : void 0;
          return new e(r, i);
        },
      },
      {
        key: 'cloneInstance',
        value: function () {
          var r = this,
            i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Vl,
            a = On({}, this.options, i, {
              isClone: !0,
            }),
            o = new e(a),
            u = ['store', 'services', 'language'];
          return (
            u.forEach(function (l) {
              o[l] = r[l];
            }),
            (o.translator = new sg(o.services, o.options)),
            o.translator.on('*', function (l) {
              for (var p = arguments.length, h = new Array(p > 1 ? p - 1 : 0), b = 1; b < p; b++) h[b - 1] = arguments[b];
              o.emit.apply(o, [l].concat(h));
            }),
            o.init(a, s),
            (o.translator.options = o.options),
            o
          );
        },
      },
    ]),
    e
  );
})(fs);
new SE();
function Mn(n, e, t, r) {
  var i = arguments.length,
    s = i < 3 ? e : r === null ? (r = Object.getOwnPropertyDescriptor(e, t)) : r,
    a;
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') s = Reflect.decorate(n, e, t, r);
  else for (var o = n.length - 1; o >= 0; o--) (a = n[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function rs(n, e) {
  return function (t, r) {
    e(t, r, n);
  };
}
var og;
(function (n) {
  (n.I18N_EA_CHANNEL = 'i18n:locale:changed'), (n.I18N_SIGNAL = 'aurelia-translation-signal'), (n.RT_SIGNAL = 'aurelia-relativetime-signal');
})(og || (og = {}));
var ug;
(function (n) {
  (n.translationValueConverterName = 't'), (n.dateFormatValueConverterName = 'df'), (n.numberFormatValueConverterName = 'nf'), (n.relativeTimeValueConverterName = 'rt');
})(ug || (ug = {}));
function Py(n, e) {
  const t = e.ast.expression;
  if (!(t instanceof Eu)) {
    const r = new Eu(t, n, e.ast.args);
    e.ast.expression = r;
  }
}
let lg = class {
  bind(e, t) {
    Py('df', t);
  }
};
lg = Mn([Un('df')], lg);
const ME = /* @__PURE__ */ he.createInterface('I18nInitOptions'),
  _E = /* @__PURE__ */ he.createInterface('I18nextWrapper');
var cg;
(function (n) {
  (n[(n.Second = 1e3)] = 'Second'),
    (n[(n.Minute = 6e4)] = 'Minute'),
    (n[(n.Hour = 36e5)] = 'Hour'),
    (n[(n.Day = 864e5)] = 'Day'),
    (n[(n.Week = 6048e5)] = 'Week'),
    (n[(n.Month = 2592e6)] = 'Month'),
    (n[(n.Year = 31536e6)] = 'Year');
})(cg || (cg = {}));
class RE {
  constructor(e) {
    this.value = void 0;
    const t = /\[([a-z\-, ]*)\]/gi;
    this.attributes = [];
    const r = t.exec(e);
    r && ((e = e.replace(r[0], '')), (this.attributes = r[1].split(','))), (this.key = e);
  }
}
const Aa = /* @__PURE__ */ he.createInterface('I18N');
let Kf = class {
  constructor(e, t, r, i) {
    (this.ea = r), (this.i = /* @__PURE__ */ new Set()), (this.i18next = e.i18next), (this.initPromise = this.h(t)), (this.u = i);
  }
  evaluate(e, t) {
    const r = e.split(';'),
      i = [];
    for (const s of r) {
      const a = new RE(s),
        o = a.key,
        u = this.tr(o, t);
      this.options.skipTranslationOnMissingKey && u === o ? console.warn(`Couldn't find translation for key: ${o}`) : ((a.value = u), i.push(a));
    }
    return i;
  }
  tr(e, t) {
    return this.i18next.t(e, t);
  }
  getLocale() {
    return this.i18next.language;
  }
  async setLocale(e) {
    const r = {
      oldLocale: this.getLocale(),
      newLocale: e,
    };
    await this.i18next.changeLanguage(e), this.ea.publish('i18n:locale:changed', r), this.i.forEach((i) => i.handleLocaleChange(r)), this.u.dispatchSignal('aurelia-translation-signal');
  }
  createNumberFormat(e, t) {
    return Intl.NumberFormat(t || this.getLocale(), e);
  }
  nf(e, t, r) {
    return this.createNumberFormat(t, r).format(e);
  }
  createDateTimeFormat(e, t) {
    return Intl.DateTimeFormat(t || this.getLocale(), e);
  }
  df(e, t, r) {
    return this.createDateTimeFormat(t, r).format(e);
  }
  uf(e, t) {
    const r = this.nf(3333.3333333333335, void 0, t);
    let i = r[1];
    const s = r[5];
    i === '.' && (i = '\\.');
    const a = e
      .replace(new RegExp(i, 'g'), '')
      .replace(/[^\d.,-]/g, '')
      .replace(s, '.');
    return Number(a);
  }
  createRelativeTimeFormat(e, t) {
    return new Intl.RelativeTimeFormat(t || this.getLocale(), e);
  }
  rt(e, t, r) {
    let i = e.getTime() - this.now();
    const s = this.options.rtEpsilon * (i > 0 ? 1 : 0),
      a = this.createRelativeTimeFormat(t, r);
    let o = i / 31536e6;
    return Math.abs(o + s) >= 1
      ? a.format(Math.round(o), 'year')
      : ((o = i / 2592e6),
        Math.abs(o + s) >= 1
          ? a.format(Math.round(o), 'month')
          : ((o = i / 6048e5),
            Math.abs(o + s) >= 1
              ? a.format(Math.round(o), 'week')
              : ((o = i / 864e5),
                Math.abs(o + s) >= 1
                  ? a.format(Math.round(o), 'day')
                  : ((o = i / 36e5),
                    Math.abs(o + s) >= 1
                      ? a.format(Math.round(o), 'hour')
                      : ((o = i / 6e4), Math.abs(o + s) >= 1 ? a.format(Math.round(o), 'minute') : ((i = Math.abs(i) < 1e3 ? 1e3 : i), (o = i / 1e3), a.format(Math.round(o), 'second')))))));
  }
  subscribeLocaleChange(e) {
    this.i.add(e);
  }
  now() {
    return /* @__PURE__ */ new Date().getTime();
  }
  async h(e) {
    const t = {
      lng: 'en',
      fallbackLng: ['en'],
      debug: !1,
      plugins: [],
      rtEpsilon: 0.01,
      skipTranslationOnMissingKey: !1,
    };
    this.options = {
      ...t,
      ...e,
    };
    for (const r of this.options.plugins) this.i18next.use(r);
    await this.i18next.init(this.options);
  }
};
Mn([ZA], Kf.prototype, 'i18next', void 0);
Kf = Mn([rs(0, _E), rs(1, ME), rs(2, wd), rs(3, Ed)], Kf);
let dg = class {
  constructor(e) {
    (this.i18n = e), (this.signals = ['aurelia-translation-signal']);
  }
  toView(e, t, r) {
    if ((!e && e !== 0) || (typeof e == 'string' && e.trim() === '')) return e;
    if (typeof e == 'string') {
      const i = Number(e),
        s = new Date(Number.isInteger(i) ? i : e);
      if (isNaN(s.getTime())) return e;
      e = s;
    }
    return this.i18n.df(e, t, r);
  }
};
dg = Mn([ul('df'), rs(0, Aa)], dg);
let pg = class {
  bind(e, t) {
    Py('nf', t);
  }
};
pg = Mn([Un('nf')], pg);
let fg = class {
  constructor(e) {
    (this.i18n = e), (this.signals = ['aurelia-translation-signal']);
  }
  toView(e, t, r) {
    return typeof e != 'number' ? e : this.i18n.nf(e, t, r);
  }
};
fg = Mn([ul('nf'), rs(0, Aa)], fg);
let hg = class {
  bind(e, t) {
    Py('rt', t);
  }
};
hg = Mn([Un('rt')], hg);
let yg = class {
  constructor(e) {
    (this.i18n = e), (this.signals = ['aurelia-translation-signal', 'aurelia-relativetime-signal']);
  }
  toView(e, t, r) {
    return e instanceof Date ? this.i18n.rt(e, t, r) : e;
  }
};
yg = Mn([ul('rt'), rs(0, Aa)], yg);
let mg = class {
  bind(e, t) {
    const r = t.ast.expression;
    if (!(r instanceof Eu)) {
      const i = new Eu(r, 't', t.ast.args);
      t.ast.expression = i;
    }
  }
};
mg = Mn([Un('t')], mg);
const PE = ['textContent', 'innerHTML', 'prepend', 'append'],
  IE = /* @__PURE__ */ new Map([
    ['text', 'textContent'],
    ['html', 'innerHTML'],
  ]),
  kE = {
    optional: !0,
  },
  OE = {
    reusable: !1,
    preempt: !0,
  };
class Mi {
  constructor(e, t, r, i, s) {
    (this.isBound = !1),
      (this._ = PE),
      (this.T = null),
      (this.parameter = null),
      (this.boundFn = !1),
      (this.l = t),
      (this.B = e),
      (this.target = s),
      (this.i18n = t.get(Aa)),
      (this.p = i),
      (this.C = /* @__PURE__ */ new Set()),
      (this.oL = r),
      this.i18n.subscribeLocaleChange(this),
      (this.I = i.domWriteQueue);
  }
  static create({ parser: e, observerLocator: t, context: r, controller: i, target: s, instruction: a, platform: o, isParameterContext: u }) {
    const l = this.P({
        observerLocator: t,
        context: r,
        controller: i,
        target: s,
        platform: o,
      }),
      p = typeof a.from == 'string' ? e.parse(a.from, 16) : a.from;
    if (u) l.useParameter(p);
    else {
      const h = p instanceof Gh ? e.parse(p.value, 1) : void 0;
      l.ast = h || p;
    }
  }
  static P({ observerLocator: e, context: t, controller: r, target: i, platform: s }) {
    let a = r.bindings && r.bindings.find((o) => o instanceof Mi && o.target === i);
    return a || ((a = new Mi(r, t, e, s, i)), r.addBinding(a)), a;
  }
  bind(e) {
    if (!this.isBound) {
      if (!this.ast) throw new Error('key expression is missing');
      (this.s = e), (this.M = this.ast instanceof Gv), (this.A = V(this.ast, e, this, this)), this.L(), this.parameter?.bind(e), this.updateTranslations(), (this.isBound = !0);
    }
  }
  unbind() {
    this.isBound && (ar(this.ast, this.s, this), this.parameter?.unbind(), this.C.clear(), this.T !== null && (this.T.cancel(), (this.T = null)), (this.s = void 0), this.obs.clearAll());
  }
  handleChange(e, t) {
    this.obs.version++, (this.A = this.M ? V(this.ast, this.s, this, this) : e), this.obs.clear(), this.L(), this.updateTranslations();
  }
  handleLocaleChange() {
    this.updateTranslations();
  }
  useParameter(e) {
    if (this.parameter != null) throw new Error('This translation parameter has already been specified.');
    this.parameter = new Iy(this, e, () => this.updateTranslations());
  }
  updateTranslations() {
    const e = this.i18n.evaluate(this.A, this.parameter?.value),
      t = /* @__PURE__ */ Object.create(null),
      r = [],
      i = this.T;
    this.C.clear();
    for (const a of e) {
      const o = a.value,
        u = this.R(a.attributes);
      for (const l of u)
        if (this.V(l)) t[l] = o;
        else {
          const p = Qa.for(this.target, kE),
            h = p?.viewModel ? this.oL.getAccessor(p.viewModel, l) : this.oL.getAccessor(this.target, l);
          this.B.state !== 1 && (h.type & 4) > 0 ? r.push(new BE(h, o, this.target, l)) : h.setValue(o, this.target, l), this.C.add(h);
        }
    }
    let s = !1;
    Object.keys(t).length > 0 && ((s = this.B.state !== 1), s || this.F(t)),
      (r.length > 0 || s) &&
        (this.T = this.I.queueTask(() => {
          this.T = null;
          for (const a of r) a.run();
          s && this.F(t);
        }, OE)),
      i?.cancel();
  }
  R(e) {
    e.length === 0 && (e = this.target.tagName === 'IMG' ? ['src'] : ['textContent']);
    for (const [t, r] of IE) {
      const i = e.findIndex((s) => s === t);
      i > -1 && e.splice(i, 1, r);
    }
    return e;
  }
  V(e) {
    return this._.includes(e);
  }
  F(e) {
    const t = xp(this.target.childNodes),
      r = [],
      i = 'au-i18n';
    for (const a of t) Reflect.get(a, i) || r.push(a);
    const s = this.N(e, i, r);
    this.target.innerHTML = '';
    for (const a of xp(s.content.childNodes)) this.target.appendChild(a);
  }
  N(e, t, r) {
    const i = this.p.document.createElement('template');
    if ((this.O(i, e.prepend, t), !this.O(i, e.innerHTML ?? e.textContent, t))) for (const s of r) i.content.append(s);
    return this.O(i, e.append, t), i;
  }
  O(e, t, r) {
    if (t != null) {
      const i = this.p.document.createElement('div');
      i.innerHTML = t;
      for (const s of xp(i.childNodes)) Reflect.set(s, r, !0), e.content.append(s);
      return !0;
    }
    return !1;
  }
  L() {
    const e = this.A ?? (this.A = ''),
      t = typeof e;
    if (t !== 'string') throw new Error(`Expected the i18n key to be a string, but got ${e} of type ${t}`);
  }
}
Pr(Mi);
ni(!0)(Mi);
wa(Mi, () => 'updateTranslations');
class BE {
  constructor(e, t, r, i) {
    (this.accessor = e), (this.v = t), (this.el = r), (this.attr = i);
  }
  run() {
    this.accessor.setValue(this.v, this.el, this.attr);
  }
}
class Iy {
  constructor(e, t, r) {
    (this.owner = e), (this.ast = t), (this.updater = r), (this.isBound = !1), (this.boundFn = !1), (this.oL = e.oL), (this.l = e.l);
  }
  handleChange(e, t) {
    this.isBound && (this.obs.version++, (this.value = V(this.ast, this.s, this, this)), this.obs.clear(), this.updater());
  }
  bind(e) {
    this.isBound || ((this.s = e), Sr(this.ast, e, this), (this.value = V(this.ast, e, this, this)), (this.isBound = !0));
  }
  unbind() {
    this.isBound && (ar(this.ast, this.s, this), (this.s = void 0), this.obs.clearAll());
  }
}
Pr(Iy);
ni(!0)(Iy);
const v1 = 'tpt',
  ku = 't-params.bind';
let bg = class {
  [ku](e, t, r) {
    return new lr(e, t, '', ku);
  }
};
bg = Mn(
  [
    Li({
      pattern: ku,
      symbols: '',
    }),
  ],
  bg,
);
class NE {
  constructor(e, t) {
    (this.from = e), (this.to = t), (this.type = v1), (this.mode = 2);
  }
}
let gg = class {
  constructor() {
    this.type = 0;
  }
  get name() {
    return ku;
  }
  build(e, t, r) {
    const i = e.attr;
    let s = i.target;
    return e.bindable == null ? (s = r.map(e.node, s) ?? Wn(s)) : (s = e.bindable.property), new NE(t.parse(i.rawValue, 16), s);
  }
};
gg = Mn([jn(ku)], gg);
let vg = class {
  render(e, t, r, i, s, a) {
    Mi.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: r,
      isParameterContext: !0,
      platform: i,
    });
  }
};
vg = Mn([Ut(v1)], vg);
const DE = 'tt';
let xg = class {
  render(e, t, r, i, s, a) {
    Mi.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: r,
      platform: i,
    });
  }
};
xg = Mn([Ut(DE)], xg);
const FE = 'tbt';
let wg = class {
  render(e, t, r, i, s, a) {
    Mi.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: r,
      platform: i,
    });
  }
};
wg = Mn([Ut(FE)], wg);
let Tg = class {
  constructor(e) {
    (this.i18n = e), (this.signals = ['aurelia-translation-signal']);
  }
  toView(e, t) {
    return this.i18n.tr(e, t);
  }
};
Tg = Mn([ul('t'), rs(0, Aa)], Tg);
Array.prototype.sum = function () {
  return this.reduce((n, e) => n + e, 0);
};
const Ea = he.createInterface(),
  LE = {
    authDomain: 'kolektivo-36b63.firebaseapp.com',
    projectId: 'kolektivo-36b63',
    storageBucket: 'kolektivo-36b63.appspot.com',
    messagingSenderId: '324595180464',
    appId: '1:324595180464:web:69e6b83cdba3bf2d30ac75',
    measurementId: 'G-7BSHV1Y6VS',
  },
  ml = he.createInterface('CacheService');
class Id {
  cache = /* @__PURE__ */ new Map();
  setItem(e, t) {
    this.cache.set(e, t);
  }
  getItem(e) {
    return this.cache.get(e);
  }
  static register(e) {
    fe.singleton(ml, Id).register(e);
  }
}
const jp = (n, e) => {
  const t = n[e];
  return t
    ? typeof t == 'function'
      ? t()
      : Promise.resolve(t)
    : new Promise((r, i) => {
        (typeof queueMicrotask == 'function' ? queueMicrotask : setTimeout)(i.bind(null, new Error('Unknown variable dynamic import: ' + e)));
      });
};
function x1(n) {
  return function (e, t, r) {
    const i = `${e.constructor.name}_${t}`,
      s = r.value;
    return (
      (r.value = function (...a) {
        const { storage: o } = n.call(this),
          u = `${i}_${JSON.stringify(a)}`;
        let l = o.getItem(u);
        return l || ((l = s?.apply(this, a)), o.setItem(u, l), l);
      }),
      r
    );
  };
}
const kd = he.createInterface(),
  $E = 'https://primedao.mypinata.cloud//',
  Ag = Number({}.KOL_CHAIN_ID ?? 42220),
  Eg = {}.KOL_CHAIN_URL ?? 'https://forno.celo.org',
  Cg = {}.KOL_CHAIN ?? 'Celo',
  UE = {}.KOL_SCAN_LINK ?? 'https://explorer.celo.org/{type}/{address}',
  jE = !!({}.KOL_TESTING ?? !0),
  La = 'testData';
var es = typeof globalThis < 'u' ? globalThis : typeof window < 'u' ? window : typeof global < 'u' ? global : typeof self < 'u' ? self : {};
function It(n) {
  if (n.__esModule) return n;
  var e = n.default;
  if (typeof e == 'function') {
    var t = function r() {
      if (this instanceof r) {
        var i = [null];
        i.push.apply(i, arguments);
        var s = Function.bind.apply(e, i);
        return new s();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, '__esModule', { value: !0 }),
    Object.keys(n).forEach(function (r) {
      var i = Object.getOwnPropertyDescriptor(n, r);
      Object.defineProperty(
        t,
        r,
        i.get
          ? i
          : {
              enumerable: !0,
              get: function () {
                return n[r];
              },
            },
      );
    }),
    t
  );
}
var qf = {},
  VE = {
    get exports() {
      return qf;
    },
    set exports(n) {
      qf = n;
    },
  };
const zE = {},
  GE = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        default: zE,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  HE = /* @__PURE__ */ It(GE);
(function (n) {
  (function (e, t) {
    function r(S, c) {
      if (!S) throw new Error(c || 'Assertion failed');
    }
    function i(S, c) {
      S.super_ = c;
      var y = function () {};
      (y.prototype = c.prototype), (S.prototype = new y()), (S.prototype.constructor = S);
    }
    function s(S, c, y) {
      if (s.isBN(S)) return S;
      (this.negative = 0), (this.words = null), (this.length = 0), (this.red = null), S !== null && ((c === 'le' || c === 'be') && ((y = c), (c = 10)), this._init(S || 0, c || 10, y || 'be'));
    }
    typeof e == 'object' ? (e.exports = s) : (t.BN = s), (s.BN = s), (s.wordSize = 26);
    var a;
    try {
      typeof window < 'u' && typeof window.Buffer < 'u' ? (a = window.Buffer) : (a = HE.Buffer);
    } catch {}
    (s.isBN = function (c) {
      return c instanceof s ? !0 : c !== null && typeof c == 'object' && c.constructor.wordSize === s.wordSize && Array.isArray(c.words);
    }),
      (s.max = function (c, y) {
        return c.cmp(y) > 0 ? c : y;
      }),
      (s.min = function (c, y) {
        return c.cmp(y) < 0 ? c : y;
      }),
      (s.prototype._init = function (c, y, v) {
        if (typeof c == 'number') return this._initNumber(c, y, v);
        if (typeof c == 'object') return this._initArray(c, y, v);
        y === 'hex' && (y = 16), r(y === (y | 0) && y >= 2 && y <= 36), (c = c.toString().replace(/\s+/g, ''));
        var C = 0;
        c[0] === '-' && (C++, (this.negative = 1)), C < c.length && (y === 16 ? this._parseHex(c, C, v) : (this._parseBase(c, y, C), v === 'le' && this._initArray(this.toArray(), y, v)));
      }),
      (s.prototype._initNumber = function (c, y, v) {
        c < 0 && ((this.negative = 1), (c = -c)),
          c < 67108864
            ? ((this.words = [c & 67108863]), (this.length = 1))
            : c < 4503599627370496
            ? ((this.words = [c & 67108863, (c / 67108864) & 67108863]), (this.length = 2))
            : (r(c < 9007199254740992), (this.words = [c & 67108863, (c / 67108864) & 67108863, 1]), (this.length = 3)),
          v === 'le' && this._initArray(this.toArray(), y, v);
      }),
      (s.prototype._initArray = function (c, y, v) {
        if ((r(typeof c.length == 'number'), c.length <= 0)) return (this.words = [0]), (this.length = 1), this;
        (this.length = Math.ceil(c.length / 3)), (this.words = new Array(this.length));
        for (var C = 0; C < this.length; C++) this.words[C] = 0;
        var A,
          M,
          P = 0;
        if (v === 'be')
          for (C = c.length - 1, A = 0; C >= 0; C -= 3)
            (M = c[C] | (c[C - 1] << 8) | (c[C - 2] << 16)), (this.words[A] |= (M << P) & 67108863), (this.words[A + 1] = (M >>> (26 - P)) & 67108863), (P += 24), P >= 26 && ((P -= 26), A++);
        else if (v === 'le')
          for (C = 0, A = 0; C < c.length; C += 3)
            (M = c[C] | (c[C + 1] << 8) | (c[C + 2] << 16)), (this.words[A] |= (M << P) & 67108863), (this.words[A + 1] = (M >>> (26 - P)) & 67108863), (P += 24), P >= 26 && ((P -= 26), A++);
        return this._strip();
      });
    function o(S, c) {
      var y = S.charCodeAt(c);
      if (y >= 48 && y <= 57) return y - 48;
      if (y >= 65 && y <= 70) return y - 55;
      if (y >= 97 && y <= 102) return y - 87;
      r(!1, 'Invalid character in ' + S);
    }
    function u(S, c, y) {
      var v = o(S, y);
      return y - 1 >= c && (v |= o(S, y - 1) << 4), v;
    }
    s.prototype._parseHex = function (c, y, v) {
      (this.length = Math.ceil((c.length - y) / 6)), (this.words = new Array(this.length));
      for (var C = 0; C < this.length; C++) this.words[C] = 0;
      var A = 0,
        M = 0,
        P;
      if (v === 'be') for (C = c.length - 1; C >= y; C -= 2) (P = u(c, y, C) << A), (this.words[M] |= P & 67108863), A >= 18 ? ((A -= 18), (M += 1), (this.words[M] |= P >>> 26)) : (A += 8);
      else {
        var m = c.length - y;
        for (C = m % 2 === 0 ? y + 1 : y; C < c.length; C += 2) (P = u(c, y, C) << A), (this.words[M] |= P & 67108863), A >= 18 ? ((A -= 18), (M += 1), (this.words[M] |= P >>> 26)) : (A += 8);
      }
      this._strip();
    };
    function l(S, c, y, v) {
      for (var C = 0, A = 0, M = Math.min(S.length, y), P = c; P < M; P++) {
        var m = S.charCodeAt(P) - 48;
        (C *= v), m >= 49 ? (A = m - 49 + 10) : m >= 17 ? (A = m - 17 + 10) : (A = m), r(m >= 0 && A < v, 'Invalid character'), (C += A);
      }
      return C;
    }
    (s.prototype._parseBase = function (c, y, v) {
      (this.words = [0]), (this.length = 1);
      for (var C = 0, A = 1; A <= 67108863; A *= y) C++;
      C--, (A = (A / y) | 0);
      for (var M = c.length - v, P = M % C, m = Math.min(M, M - P) + v, d = 0, g = v; g < m; g += C)
        (d = l(c, g, g + C, y)), this.imuln(A), this.words[0] + d < 67108864 ? (this.words[0] += d) : this._iaddn(d);
      if (P !== 0) {
        var I = 1;
        for (d = l(c, g, c.length, y), g = 0; g < P; g++) I *= y;
        this.imuln(I), this.words[0] + d < 67108864 ? (this.words[0] += d) : this._iaddn(d);
      }
      this._strip();
    }),
      (s.prototype.copy = function (c) {
        c.words = new Array(this.length);
        for (var y = 0; y < this.length; y++) c.words[y] = this.words[y];
        (c.length = this.length), (c.negative = this.negative), (c.red = this.red);
      });
    function p(S, c) {
      (S.words = c.words), (S.length = c.length), (S.negative = c.negative), (S.red = c.red);
    }
    if (
      ((s.prototype._move = function (c) {
        p(c, this);
      }),
      (s.prototype.clone = function () {
        var c = new s(null);
        return this.copy(c), c;
      }),
      (s.prototype._expand = function (c) {
        for (; this.length < c; ) this.words[this.length++] = 0;
        return this;
      }),
      (s.prototype._strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
        return this._normSign();
      }),
      (s.prototype._normSign = function () {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }),
      typeof Symbol < 'u' && typeof Symbol.for == 'function')
    )
      try {
        s.prototype[Symbol.for('nodejs.util.inspect.custom')] = h;
      } catch {
        s.prototype.inspect = h;
      }
    else s.prototype.inspect = h;
    function h() {
      return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    }
    var b = [
        '',
        '0',
        '00',
        '000',
        '0000',
        '00000',
        '000000',
        '0000000',
        '00000000',
        '000000000',
        '0000000000',
        '00000000000',
        '000000000000',
        '0000000000000',
        '00000000000000',
        '000000000000000',
        '0000000000000000',
        '00000000000000000',
        '000000000000000000',
        '0000000000000000000',
        '00000000000000000000',
        '000000000000000000000',
        '0000000000000000000000',
        '00000000000000000000000',
        '000000000000000000000000',
        '0000000000000000000000000',
      ],
      E = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
      x = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6,
        4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
      ];
    (s.prototype.toString = function (c, y) {
      (c = c || 10), (y = y | 0 || 1);
      var v;
      if (c === 16 || c === 'hex') {
        v = '';
        for (var C = 0, A = 0, M = 0; M < this.length; M++) {
          var P = this.words[M],
            m = (((P << C) | A) & 16777215).toString(16);
          (A = (P >>> (24 - C)) & 16777215), (C += 2), C >= 26 && ((C -= 26), M--), A !== 0 || M !== this.length - 1 ? (v = b[6 - m.length] + m + v) : (v = m + v);
        }
        for (A !== 0 && (v = A.toString(16) + v); v.length % y !== 0; ) v = '0' + v;
        return this.negative !== 0 && (v = '-' + v), v;
      }
      if (c === (c | 0) && c >= 2 && c <= 36) {
        var d = E[c],
          g = x[c];
        v = '';
        var I = this.clone();
        for (I.negative = 0; !I.isZero(); ) {
          var f = I.modrn(g).toString(c);
          (I = I.idivn(g)), I.isZero() ? (v = f + v) : (v = b[d - f.length] + f + v);
        }
        for (this.isZero() && (v = '0' + v); v.length % y !== 0; ) v = '0' + v;
        return this.negative !== 0 && (v = '-' + v), v;
      }
      r(!1, 'Base should be between 2 and 36');
    }),
      (s.prototype.toNumber = function () {
        var c = this.words[0];
        return (
          this.length === 2
            ? (c += this.words[1] * 67108864)
            : this.length === 3 && this.words[2] === 1
            ? (c += 4503599627370496 + this.words[1] * 67108864)
            : this.length > 2 && r(!1, 'Number can only safely store up to 53 bits'),
          this.negative !== 0 ? -c : c
        );
      }),
      (s.prototype.toJSON = function () {
        return this.toString(16, 2);
      }),
      a &&
        (s.prototype.toBuffer = function (c, y) {
          return this.toArrayLike(a, c, y);
        }),
      (s.prototype.toArray = function (c, y) {
        return this.toArrayLike(Array, c, y);
      });
    var T = function (c, y) {
      return c.allocUnsafe ? c.allocUnsafe(y) : new c(y);
    };
    (s.prototype.toArrayLike = function (c, y, v) {
      this._strip();
      var C = this.byteLength(),
        A = v || Math.max(1, C);
      r(C <= A, 'byte array longer than desired length'), r(A > 0, 'Requested array length <= 0');
      var M = T(c, A),
        P = y === 'le' ? 'LE' : 'BE';
      return this['_toArrayLike' + P](M, C), M;
    }),
      (s.prototype._toArrayLikeLE = function (c, y) {
        for (var v = 0, C = 0, A = 0, M = 0; A < this.length; A++) {
          var P = (this.words[A] << M) | C;
          (c[v++] = P & 255),
            v < c.length && (c[v++] = (P >> 8) & 255),
            v < c.length && (c[v++] = (P >> 16) & 255),
            M === 6 ? (v < c.length && (c[v++] = (P >> 24) & 255), (C = 0), (M = 0)) : ((C = P >>> 24), (M += 2));
        }
        if (v < c.length) for (c[v++] = C; v < c.length; ) c[v++] = 0;
      }),
      (s.prototype._toArrayLikeBE = function (c, y) {
        for (var v = c.length - 1, C = 0, A = 0, M = 0; A < this.length; A++) {
          var P = (this.words[A] << M) | C;
          (c[v--] = P & 255),
            v >= 0 && (c[v--] = (P >> 8) & 255),
            v >= 0 && (c[v--] = (P >> 16) & 255),
            M === 6 ? (v >= 0 && (c[v--] = (P >> 24) & 255), (C = 0), (M = 0)) : ((C = P >>> 24), (M += 2));
        }
        if (v >= 0) for (c[v--] = C; v >= 0; ) c[v--] = 0;
      }),
      Math.clz32
        ? (s.prototype._countBits = function (c) {
            return 32 - Math.clz32(c);
          })
        : (s.prototype._countBits = function (c) {
            var y = c,
              v = 0;
            return y >= 4096 && ((v += 13), (y >>>= 13)), y >= 64 && ((v += 7), (y >>>= 7)), y >= 8 && ((v += 4), (y >>>= 4)), y >= 2 && ((v += 2), (y >>>= 2)), v + y;
          }),
      (s.prototype._zeroBits = function (c) {
        if (c === 0) return 26;
        var y = c,
          v = 0;
        return y & 8191 || ((v += 13), (y >>>= 13)), y & 127 || ((v += 7), (y >>>= 7)), y & 15 || ((v += 4), (y >>>= 4)), y & 3 || ((v += 2), (y >>>= 2)), y & 1 || v++, v;
      }),
      (s.prototype.bitLength = function () {
        var c = this.words[this.length - 1],
          y = this._countBits(c);
        return (this.length - 1) * 26 + y;
      });
    function w(S) {
      for (var c = new Array(S.bitLength()), y = 0; y < c.length; y++) {
        var v = (y / 26) | 0,
          C = y % 26;
        c[y] = (S.words[v] >>> C) & 1;
      }
      return c;
    }
    (s.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var c = 0, y = 0; y < this.length; y++) {
        var v = this._zeroBits(this.words[y]);
        if (((c += v), v !== 26)) break;
      }
      return c;
    }),
      (s.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
      }),
      (s.prototype.toTwos = function (c) {
        return this.negative !== 0 ? this.abs().inotn(c).iaddn(1) : this.clone();
      }),
      (s.prototype.fromTwos = function (c) {
        return this.testn(c - 1) ? this.notn(c).iaddn(1).ineg() : this.clone();
      }),
      (s.prototype.isNeg = function () {
        return this.negative !== 0;
      }),
      (s.prototype.neg = function () {
        return this.clone().ineg();
      }),
      (s.prototype.ineg = function () {
        return this.isZero() || (this.negative ^= 1), this;
      }),
      (s.prototype.iuor = function (c) {
        for (; this.length < c.length; ) this.words[this.length++] = 0;
        for (var y = 0; y < c.length; y++) this.words[y] = this.words[y] | c.words[y];
        return this._strip();
      }),
      (s.prototype.ior = function (c) {
        return r((this.negative | c.negative) === 0), this.iuor(c);
      }),
      (s.prototype.or = function (c) {
        return this.length > c.length ? this.clone().ior(c) : c.clone().ior(this);
      }),
      (s.prototype.uor = function (c) {
        return this.length > c.length ? this.clone().iuor(c) : c.clone().iuor(this);
      }),
      (s.prototype.iuand = function (c) {
        var y;
        this.length > c.length ? (y = c) : (y = this);
        for (var v = 0; v < y.length; v++) this.words[v] = this.words[v] & c.words[v];
        return (this.length = y.length), this._strip();
      }),
      (s.prototype.iand = function (c) {
        return r((this.negative | c.negative) === 0), this.iuand(c);
      }),
      (s.prototype.and = function (c) {
        return this.length > c.length ? this.clone().iand(c) : c.clone().iand(this);
      }),
      (s.prototype.uand = function (c) {
        return this.length > c.length ? this.clone().iuand(c) : c.clone().iuand(this);
      }),
      (s.prototype.iuxor = function (c) {
        var y, v;
        this.length > c.length ? ((y = this), (v = c)) : ((y = c), (v = this));
        for (var C = 0; C < v.length; C++) this.words[C] = y.words[C] ^ v.words[C];
        if (this !== y) for (; C < y.length; C++) this.words[C] = y.words[C];
        return (this.length = y.length), this._strip();
      }),
      (s.prototype.ixor = function (c) {
        return r((this.negative | c.negative) === 0), this.iuxor(c);
      }),
      (s.prototype.xor = function (c) {
        return this.length > c.length ? this.clone().ixor(c) : c.clone().ixor(this);
      }),
      (s.prototype.uxor = function (c) {
        return this.length > c.length ? this.clone().iuxor(c) : c.clone().iuxor(this);
      }),
      (s.prototype.inotn = function (c) {
        r(typeof c == 'number' && c >= 0);
        var y = Math.ceil(c / 26) | 0,
          v = c % 26;
        this._expand(y), v > 0 && y--;
        for (var C = 0; C < y; C++) this.words[C] = ~this.words[C] & 67108863;
        return v > 0 && (this.words[C] = ~this.words[C] & (67108863 >> (26 - v))), this._strip();
      }),
      (s.prototype.notn = function (c) {
        return this.clone().inotn(c);
      }),
      (s.prototype.setn = function (c, y) {
        r(typeof c == 'number' && c >= 0);
        var v = (c / 26) | 0,
          C = c % 26;
        return this._expand(v + 1), y ? (this.words[v] = this.words[v] | (1 << C)) : (this.words[v] = this.words[v] & ~(1 << C)), this._strip();
      }),
      (s.prototype.iadd = function (c) {
        var y;
        if (this.negative !== 0 && c.negative === 0) return (this.negative = 0), (y = this.isub(c)), (this.negative ^= 1), this._normSign();
        if (this.negative === 0 && c.negative !== 0) return (c.negative = 0), (y = this.isub(c)), (c.negative = 1), y._normSign();
        var v, C;
        this.length > c.length ? ((v = this), (C = c)) : ((v = c), (C = this));
        for (var A = 0, M = 0; M < C.length; M++) (y = (v.words[M] | 0) + (C.words[M] | 0) + A), (this.words[M] = y & 67108863), (A = y >>> 26);
        for (; A !== 0 && M < v.length; M++) (y = (v.words[M] | 0) + A), (this.words[M] = y & 67108863), (A = y >>> 26);
        if (((this.length = v.length), A !== 0)) (this.words[this.length] = A), this.length++;
        else if (v !== this) for (; M < v.length; M++) this.words[M] = v.words[M];
        return this;
      }),
      (s.prototype.add = function (c) {
        var y;
        return c.negative !== 0 && this.negative === 0
          ? ((c.negative = 0), (y = this.sub(c)), (c.negative ^= 1), y)
          : c.negative === 0 && this.negative !== 0
          ? ((this.negative = 0), (y = c.sub(this)), (this.negative = 1), y)
          : this.length > c.length
          ? this.clone().iadd(c)
          : c.clone().iadd(this);
      }),
      (s.prototype.isub = function (c) {
        if (c.negative !== 0) {
          c.negative = 0;
          var y = this.iadd(c);
          return (c.negative = 1), y._normSign();
        } else if (this.negative !== 0) return (this.negative = 0), this.iadd(c), (this.negative = 1), this._normSign();
        var v = this.cmp(c);
        if (v === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this;
        var C, A;
        v > 0 ? ((C = this), (A = c)) : ((C = c), (A = this));
        for (var M = 0, P = 0; P < A.length; P++) (y = (C.words[P] | 0) - (A.words[P] | 0) + M), (M = y >> 26), (this.words[P] = y & 67108863);
        for (; M !== 0 && P < C.length; P++) (y = (C.words[P] | 0) + M), (M = y >> 26), (this.words[P] = y & 67108863);
        if (M === 0 && P < C.length && C !== this) for (; P < C.length; P++) this.words[P] = C.words[P];
        return (this.length = Math.max(this.length, P)), C !== this && (this.negative = 1), this._strip();
      }),
      (s.prototype.sub = function (c) {
        return this.clone().isub(c);
      });
    function _(S, c, y) {
      y.negative = c.negative ^ S.negative;
      var v = (S.length + c.length) | 0;
      (y.length = v), (v = (v - 1) | 0);
      var C = S.words[0] | 0,
        A = c.words[0] | 0,
        M = C * A,
        P = M & 67108863,
        m = (M / 67108864) | 0;
      y.words[0] = P;
      for (var d = 1; d < v; d++) {
        for (var g = m >>> 26, I = m & 67108863, f = Math.min(d, c.length - 1), R = Math.max(0, d - S.length + 1); R <= f; R++) {
          var L = (d - R) | 0;
          (C = S.words[L] | 0), (A = c.words[R] | 0), (M = C * A + I), (g += (M / 67108864) | 0), (I = M & 67108863);
        }
        (y.words[d] = I | 0), (m = g | 0);
      }
      return m !== 0 ? (y.words[d] = m | 0) : y.length--, y._strip();
    }
    var k = function (c, y, v) {
      var C = c.words,
        A = y.words,
        M = v.words,
        P = 0,
        m,
        d,
        g,
        I = C[0] | 0,
        f = I & 8191,
        R = I >>> 13,
        L = C[1] | 0,
        F = L & 8191,
        $ = L >>> 13,
        ee = C[2] | 0,
        W = ee & 8191,
        Q = ee >>> 13,
        wt = C[3] | 0,
        te = wt & 8191,
        de = wt >>> 13,
        Es = C[4] | 0,
        Ue = Es & 8191,
        je = Es >>> 13,
        Cs = C[5] | 0,
        Ve = Cs & 8191,
        ze = Cs >>> 13,
        Ss = C[6] | 0,
        Ge = Ss & 8191,
        He = Ss >>> 13,
        Ms = C[7] | 0,
        Ke = Ms & 8191,
        qe = Ms >>> 13,
        _s = C[8] | 0,
        We = _s & 8191,
        Je = _s >>> 13,
        Rs = C[9] | 0,
        Qe = Rs & 8191,
        Ye = Rs >>> 13,
        Ps = A[0] | 0,
        Xe = Ps & 8191,
        Ze = Ps >>> 13,
        Is = A[1] | 0,
        et = Is & 8191,
        tt = Is >>> 13,
        ks = A[2] | 0,
        nt = ks & 8191,
        rt = ks >>> 13,
        Os = A[3] | 0,
        it = Os & 8191,
        st = Os >>> 13,
        Bs = A[4] | 0,
        at = Bs & 8191,
        ot = Bs >>> 13,
        Ns = A[5] | 0,
        ut = Ns & 8191,
        lt = Ns >>> 13,
        Ds = A[6] | 0,
        ct = Ds & 8191,
        dt = Ds >>> 13,
        Fs = A[7] | 0,
        pt = Fs & 8191,
        ft = Fs >>> 13,
        Ls = A[8] | 0,
        ht = Ls & 8191,
        yt = Ls >>> 13,
        $s = A[9] | 0,
        mt = $s & 8191,
        bt = $s >>> 13;
      (v.negative = c.negative ^ y.negative), (v.length = 19), (m = Math.imul(f, Xe)), (d = Math.imul(f, Ze)), (d = (d + Math.imul(R, Xe)) | 0), (g = Math.imul(R, Ze));
      var Vi = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (Vi >>> 26)) | 0),
        (Vi &= 67108863),
        (m = Math.imul(F, Xe)),
        (d = Math.imul(F, Ze)),
        (d = (d + Math.imul($, Xe)) | 0),
        (g = Math.imul($, Ze)),
        (m = (m + Math.imul(f, et)) | 0),
        (d = (d + Math.imul(f, tt)) | 0),
        (d = (d + Math.imul(R, et)) | 0),
        (g = (g + Math.imul(R, tt)) | 0);
      var zi = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (zi >>> 26)) | 0),
        (zi &= 67108863),
        (m = Math.imul(W, Xe)),
        (d = Math.imul(W, Ze)),
        (d = (d + Math.imul(Q, Xe)) | 0),
        (g = Math.imul(Q, Ze)),
        (m = (m + Math.imul(F, et)) | 0),
        (d = (d + Math.imul(F, tt)) | 0),
        (d = (d + Math.imul($, et)) | 0),
        (g = (g + Math.imul($, tt)) | 0),
        (m = (m + Math.imul(f, nt)) | 0),
        (d = (d + Math.imul(f, rt)) | 0),
        (d = (d + Math.imul(R, nt)) | 0),
        (g = (g + Math.imul(R, rt)) | 0);
      var Gi = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (Gi >>> 26)) | 0),
        (Gi &= 67108863),
        (m = Math.imul(te, Xe)),
        (d = Math.imul(te, Ze)),
        (d = (d + Math.imul(de, Xe)) | 0),
        (g = Math.imul(de, Ze)),
        (m = (m + Math.imul(W, et)) | 0),
        (d = (d + Math.imul(W, tt)) | 0),
        (d = (d + Math.imul(Q, et)) | 0),
        (g = (g + Math.imul(Q, tt)) | 0),
        (m = (m + Math.imul(F, nt)) | 0),
        (d = (d + Math.imul(F, rt)) | 0),
        (d = (d + Math.imul($, nt)) | 0),
        (g = (g + Math.imul($, rt)) | 0),
        (m = (m + Math.imul(f, it)) | 0),
        (d = (d + Math.imul(f, st)) | 0),
        (d = (d + Math.imul(R, it)) | 0),
        (g = (g + Math.imul(R, st)) | 0);
      var Hi = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (Hi >>> 26)) | 0),
        (Hi &= 67108863),
        (m = Math.imul(Ue, Xe)),
        (d = Math.imul(Ue, Ze)),
        (d = (d + Math.imul(je, Xe)) | 0),
        (g = Math.imul(je, Ze)),
        (m = (m + Math.imul(te, et)) | 0),
        (d = (d + Math.imul(te, tt)) | 0),
        (d = (d + Math.imul(de, et)) | 0),
        (g = (g + Math.imul(de, tt)) | 0),
        (m = (m + Math.imul(W, nt)) | 0),
        (d = (d + Math.imul(W, rt)) | 0),
        (d = (d + Math.imul(Q, nt)) | 0),
        (g = (g + Math.imul(Q, rt)) | 0),
        (m = (m + Math.imul(F, it)) | 0),
        (d = (d + Math.imul(F, st)) | 0),
        (d = (d + Math.imul($, it)) | 0),
        (g = (g + Math.imul($, st)) | 0),
        (m = (m + Math.imul(f, at)) | 0),
        (d = (d + Math.imul(f, ot)) | 0),
        (d = (d + Math.imul(R, at)) | 0),
        (g = (g + Math.imul(R, ot)) | 0);
      var Ki = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (Ki >>> 26)) | 0),
        (Ki &= 67108863),
        (m = Math.imul(Ve, Xe)),
        (d = Math.imul(Ve, Ze)),
        (d = (d + Math.imul(ze, Xe)) | 0),
        (g = Math.imul(ze, Ze)),
        (m = (m + Math.imul(Ue, et)) | 0),
        (d = (d + Math.imul(Ue, tt)) | 0),
        (d = (d + Math.imul(je, et)) | 0),
        (g = (g + Math.imul(je, tt)) | 0),
        (m = (m + Math.imul(te, nt)) | 0),
        (d = (d + Math.imul(te, rt)) | 0),
        (d = (d + Math.imul(de, nt)) | 0),
        (g = (g + Math.imul(de, rt)) | 0),
        (m = (m + Math.imul(W, it)) | 0),
        (d = (d + Math.imul(W, st)) | 0),
        (d = (d + Math.imul(Q, it)) | 0),
        (g = (g + Math.imul(Q, st)) | 0),
        (m = (m + Math.imul(F, at)) | 0),
        (d = (d + Math.imul(F, ot)) | 0),
        (d = (d + Math.imul($, at)) | 0),
        (g = (g + Math.imul($, ot)) | 0),
        (m = (m + Math.imul(f, ut)) | 0),
        (d = (d + Math.imul(f, lt)) | 0),
        (d = (d + Math.imul(R, ut)) | 0),
        (g = (g + Math.imul(R, lt)) | 0);
      var ap = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (ap >>> 26)) | 0),
        (ap &= 67108863),
        (m = Math.imul(Ge, Xe)),
        (d = Math.imul(Ge, Ze)),
        (d = (d + Math.imul(He, Xe)) | 0),
        (g = Math.imul(He, Ze)),
        (m = (m + Math.imul(Ve, et)) | 0),
        (d = (d + Math.imul(Ve, tt)) | 0),
        (d = (d + Math.imul(ze, et)) | 0),
        (g = (g + Math.imul(ze, tt)) | 0),
        (m = (m + Math.imul(Ue, nt)) | 0),
        (d = (d + Math.imul(Ue, rt)) | 0),
        (d = (d + Math.imul(je, nt)) | 0),
        (g = (g + Math.imul(je, rt)) | 0),
        (m = (m + Math.imul(te, it)) | 0),
        (d = (d + Math.imul(te, st)) | 0),
        (d = (d + Math.imul(de, it)) | 0),
        (g = (g + Math.imul(de, st)) | 0),
        (m = (m + Math.imul(W, at)) | 0),
        (d = (d + Math.imul(W, ot)) | 0),
        (d = (d + Math.imul(Q, at)) | 0),
        (g = (g + Math.imul(Q, ot)) | 0),
        (m = (m + Math.imul(F, ut)) | 0),
        (d = (d + Math.imul(F, lt)) | 0),
        (d = (d + Math.imul($, ut)) | 0),
        (g = (g + Math.imul($, lt)) | 0),
        (m = (m + Math.imul(f, ct)) | 0),
        (d = (d + Math.imul(f, dt)) | 0),
        (d = (d + Math.imul(R, ct)) | 0),
        (g = (g + Math.imul(R, dt)) | 0);
      var op = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (op >>> 26)) | 0),
        (op &= 67108863),
        (m = Math.imul(Ke, Xe)),
        (d = Math.imul(Ke, Ze)),
        (d = (d + Math.imul(qe, Xe)) | 0),
        (g = Math.imul(qe, Ze)),
        (m = (m + Math.imul(Ge, et)) | 0),
        (d = (d + Math.imul(Ge, tt)) | 0),
        (d = (d + Math.imul(He, et)) | 0),
        (g = (g + Math.imul(He, tt)) | 0),
        (m = (m + Math.imul(Ve, nt)) | 0),
        (d = (d + Math.imul(Ve, rt)) | 0),
        (d = (d + Math.imul(ze, nt)) | 0),
        (g = (g + Math.imul(ze, rt)) | 0),
        (m = (m + Math.imul(Ue, it)) | 0),
        (d = (d + Math.imul(Ue, st)) | 0),
        (d = (d + Math.imul(je, it)) | 0),
        (g = (g + Math.imul(je, st)) | 0),
        (m = (m + Math.imul(te, at)) | 0),
        (d = (d + Math.imul(te, ot)) | 0),
        (d = (d + Math.imul(de, at)) | 0),
        (g = (g + Math.imul(de, ot)) | 0),
        (m = (m + Math.imul(W, ut)) | 0),
        (d = (d + Math.imul(W, lt)) | 0),
        (d = (d + Math.imul(Q, ut)) | 0),
        (g = (g + Math.imul(Q, lt)) | 0),
        (m = (m + Math.imul(F, ct)) | 0),
        (d = (d + Math.imul(F, dt)) | 0),
        (d = (d + Math.imul($, ct)) | 0),
        (g = (g + Math.imul($, dt)) | 0),
        (m = (m + Math.imul(f, pt)) | 0),
        (d = (d + Math.imul(f, ft)) | 0),
        (d = (d + Math.imul(R, pt)) | 0),
        (g = (g + Math.imul(R, ft)) | 0);
      var up = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (up >>> 26)) | 0),
        (up &= 67108863),
        (m = Math.imul(We, Xe)),
        (d = Math.imul(We, Ze)),
        (d = (d + Math.imul(Je, Xe)) | 0),
        (g = Math.imul(Je, Ze)),
        (m = (m + Math.imul(Ke, et)) | 0),
        (d = (d + Math.imul(Ke, tt)) | 0),
        (d = (d + Math.imul(qe, et)) | 0),
        (g = (g + Math.imul(qe, tt)) | 0),
        (m = (m + Math.imul(Ge, nt)) | 0),
        (d = (d + Math.imul(Ge, rt)) | 0),
        (d = (d + Math.imul(He, nt)) | 0),
        (g = (g + Math.imul(He, rt)) | 0),
        (m = (m + Math.imul(Ve, it)) | 0),
        (d = (d + Math.imul(Ve, st)) | 0),
        (d = (d + Math.imul(ze, it)) | 0),
        (g = (g + Math.imul(ze, st)) | 0),
        (m = (m + Math.imul(Ue, at)) | 0),
        (d = (d + Math.imul(Ue, ot)) | 0),
        (d = (d + Math.imul(je, at)) | 0),
        (g = (g + Math.imul(je, ot)) | 0),
        (m = (m + Math.imul(te, ut)) | 0),
        (d = (d + Math.imul(te, lt)) | 0),
        (d = (d + Math.imul(de, ut)) | 0),
        (g = (g + Math.imul(de, lt)) | 0),
        (m = (m + Math.imul(W, ct)) | 0),
        (d = (d + Math.imul(W, dt)) | 0),
        (d = (d + Math.imul(Q, ct)) | 0),
        (g = (g + Math.imul(Q, dt)) | 0),
        (m = (m + Math.imul(F, pt)) | 0),
        (d = (d + Math.imul(F, ft)) | 0),
        (d = (d + Math.imul($, pt)) | 0),
        (g = (g + Math.imul($, ft)) | 0),
        (m = (m + Math.imul(f, ht)) | 0),
        (d = (d + Math.imul(f, yt)) | 0),
        (d = (d + Math.imul(R, ht)) | 0),
        (g = (g + Math.imul(R, yt)) | 0);
      var lp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (lp >>> 26)) | 0),
        (lp &= 67108863),
        (m = Math.imul(Qe, Xe)),
        (d = Math.imul(Qe, Ze)),
        (d = (d + Math.imul(Ye, Xe)) | 0),
        (g = Math.imul(Ye, Ze)),
        (m = (m + Math.imul(We, et)) | 0),
        (d = (d + Math.imul(We, tt)) | 0),
        (d = (d + Math.imul(Je, et)) | 0),
        (g = (g + Math.imul(Je, tt)) | 0),
        (m = (m + Math.imul(Ke, nt)) | 0),
        (d = (d + Math.imul(Ke, rt)) | 0),
        (d = (d + Math.imul(qe, nt)) | 0),
        (g = (g + Math.imul(qe, rt)) | 0),
        (m = (m + Math.imul(Ge, it)) | 0),
        (d = (d + Math.imul(Ge, st)) | 0),
        (d = (d + Math.imul(He, it)) | 0),
        (g = (g + Math.imul(He, st)) | 0),
        (m = (m + Math.imul(Ve, at)) | 0),
        (d = (d + Math.imul(Ve, ot)) | 0),
        (d = (d + Math.imul(ze, at)) | 0),
        (g = (g + Math.imul(ze, ot)) | 0),
        (m = (m + Math.imul(Ue, ut)) | 0),
        (d = (d + Math.imul(Ue, lt)) | 0),
        (d = (d + Math.imul(je, ut)) | 0),
        (g = (g + Math.imul(je, lt)) | 0),
        (m = (m + Math.imul(te, ct)) | 0),
        (d = (d + Math.imul(te, dt)) | 0),
        (d = (d + Math.imul(de, ct)) | 0),
        (g = (g + Math.imul(de, dt)) | 0),
        (m = (m + Math.imul(W, pt)) | 0),
        (d = (d + Math.imul(W, ft)) | 0),
        (d = (d + Math.imul(Q, pt)) | 0),
        (g = (g + Math.imul(Q, ft)) | 0),
        (m = (m + Math.imul(F, ht)) | 0),
        (d = (d + Math.imul(F, yt)) | 0),
        (d = (d + Math.imul($, ht)) | 0),
        (g = (g + Math.imul($, yt)) | 0),
        (m = (m + Math.imul(f, mt)) | 0),
        (d = (d + Math.imul(f, bt)) | 0),
        (d = (d + Math.imul(R, mt)) | 0),
        (g = (g + Math.imul(R, bt)) | 0);
      var cp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (cp >>> 26)) | 0),
        (cp &= 67108863),
        (m = Math.imul(Qe, et)),
        (d = Math.imul(Qe, tt)),
        (d = (d + Math.imul(Ye, et)) | 0),
        (g = Math.imul(Ye, tt)),
        (m = (m + Math.imul(We, nt)) | 0),
        (d = (d + Math.imul(We, rt)) | 0),
        (d = (d + Math.imul(Je, nt)) | 0),
        (g = (g + Math.imul(Je, rt)) | 0),
        (m = (m + Math.imul(Ke, it)) | 0),
        (d = (d + Math.imul(Ke, st)) | 0),
        (d = (d + Math.imul(qe, it)) | 0),
        (g = (g + Math.imul(qe, st)) | 0),
        (m = (m + Math.imul(Ge, at)) | 0),
        (d = (d + Math.imul(Ge, ot)) | 0),
        (d = (d + Math.imul(He, at)) | 0),
        (g = (g + Math.imul(He, ot)) | 0),
        (m = (m + Math.imul(Ve, ut)) | 0),
        (d = (d + Math.imul(Ve, lt)) | 0),
        (d = (d + Math.imul(ze, ut)) | 0),
        (g = (g + Math.imul(ze, lt)) | 0),
        (m = (m + Math.imul(Ue, ct)) | 0),
        (d = (d + Math.imul(Ue, dt)) | 0),
        (d = (d + Math.imul(je, ct)) | 0),
        (g = (g + Math.imul(je, dt)) | 0),
        (m = (m + Math.imul(te, pt)) | 0),
        (d = (d + Math.imul(te, ft)) | 0),
        (d = (d + Math.imul(de, pt)) | 0),
        (g = (g + Math.imul(de, ft)) | 0),
        (m = (m + Math.imul(W, ht)) | 0),
        (d = (d + Math.imul(W, yt)) | 0),
        (d = (d + Math.imul(Q, ht)) | 0),
        (g = (g + Math.imul(Q, yt)) | 0),
        (m = (m + Math.imul(F, mt)) | 0),
        (d = (d + Math.imul(F, bt)) | 0),
        (d = (d + Math.imul($, mt)) | 0),
        (g = (g + Math.imul($, bt)) | 0);
      var dp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (dp >>> 26)) | 0),
        (dp &= 67108863),
        (m = Math.imul(Qe, nt)),
        (d = Math.imul(Qe, rt)),
        (d = (d + Math.imul(Ye, nt)) | 0),
        (g = Math.imul(Ye, rt)),
        (m = (m + Math.imul(We, it)) | 0),
        (d = (d + Math.imul(We, st)) | 0),
        (d = (d + Math.imul(Je, it)) | 0),
        (g = (g + Math.imul(Je, st)) | 0),
        (m = (m + Math.imul(Ke, at)) | 0),
        (d = (d + Math.imul(Ke, ot)) | 0),
        (d = (d + Math.imul(qe, at)) | 0),
        (g = (g + Math.imul(qe, ot)) | 0),
        (m = (m + Math.imul(Ge, ut)) | 0),
        (d = (d + Math.imul(Ge, lt)) | 0),
        (d = (d + Math.imul(He, ut)) | 0),
        (g = (g + Math.imul(He, lt)) | 0),
        (m = (m + Math.imul(Ve, ct)) | 0),
        (d = (d + Math.imul(Ve, dt)) | 0),
        (d = (d + Math.imul(ze, ct)) | 0),
        (g = (g + Math.imul(ze, dt)) | 0),
        (m = (m + Math.imul(Ue, pt)) | 0),
        (d = (d + Math.imul(Ue, ft)) | 0),
        (d = (d + Math.imul(je, pt)) | 0),
        (g = (g + Math.imul(je, ft)) | 0),
        (m = (m + Math.imul(te, ht)) | 0),
        (d = (d + Math.imul(te, yt)) | 0),
        (d = (d + Math.imul(de, ht)) | 0),
        (g = (g + Math.imul(de, yt)) | 0),
        (m = (m + Math.imul(W, mt)) | 0),
        (d = (d + Math.imul(W, bt)) | 0),
        (d = (d + Math.imul(Q, mt)) | 0),
        (g = (g + Math.imul(Q, bt)) | 0);
      var pp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (pp >>> 26)) | 0),
        (pp &= 67108863),
        (m = Math.imul(Qe, it)),
        (d = Math.imul(Qe, st)),
        (d = (d + Math.imul(Ye, it)) | 0),
        (g = Math.imul(Ye, st)),
        (m = (m + Math.imul(We, at)) | 0),
        (d = (d + Math.imul(We, ot)) | 0),
        (d = (d + Math.imul(Je, at)) | 0),
        (g = (g + Math.imul(Je, ot)) | 0),
        (m = (m + Math.imul(Ke, ut)) | 0),
        (d = (d + Math.imul(Ke, lt)) | 0),
        (d = (d + Math.imul(qe, ut)) | 0),
        (g = (g + Math.imul(qe, lt)) | 0),
        (m = (m + Math.imul(Ge, ct)) | 0),
        (d = (d + Math.imul(Ge, dt)) | 0),
        (d = (d + Math.imul(He, ct)) | 0),
        (g = (g + Math.imul(He, dt)) | 0),
        (m = (m + Math.imul(Ve, pt)) | 0),
        (d = (d + Math.imul(Ve, ft)) | 0),
        (d = (d + Math.imul(ze, pt)) | 0),
        (g = (g + Math.imul(ze, ft)) | 0),
        (m = (m + Math.imul(Ue, ht)) | 0),
        (d = (d + Math.imul(Ue, yt)) | 0),
        (d = (d + Math.imul(je, ht)) | 0),
        (g = (g + Math.imul(je, yt)) | 0),
        (m = (m + Math.imul(te, mt)) | 0),
        (d = (d + Math.imul(te, bt)) | 0),
        (d = (d + Math.imul(de, mt)) | 0),
        (g = (g + Math.imul(de, bt)) | 0);
      var fp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (fp >>> 26)) | 0),
        (fp &= 67108863),
        (m = Math.imul(Qe, at)),
        (d = Math.imul(Qe, ot)),
        (d = (d + Math.imul(Ye, at)) | 0),
        (g = Math.imul(Ye, ot)),
        (m = (m + Math.imul(We, ut)) | 0),
        (d = (d + Math.imul(We, lt)) | 0),
        (d = (d + Math.imul(Je, ut)) | 0),
        (g = (g + Math.imul(Je, lt)) | 0),
        (m = (m + Math.imul(Ke, ct)) | 0),
        (d = (d + Math.imul(Ke, dt)) | 0),
        (d = (d + Math.imul(qe, ct)) | 0),
        (g = (g + Math.imul(qe, dt)) | 0),
        (m = (m + Math.imul(Ge, pt)) | 0),
        (d = (d + Math.imul(Ge, ft)) | 0),
        (d = (d + Math.imul(He, pt)) | 0),
        (g = (g + Math.imul(He, ft)) | 0),
        (m = (m + Math.imul(Ve, ht)) | 0),
        (d = (d + Math.imul(Ve, yt)) | 0),
        (d = (d + Math.imul(ze, ht)) | 0),
        (g = (g + Math.imul(ze, yt)) | 0),
        (m = (m + Math.imul(Ue, mt)) | 0),
        (d = (d + Math.imul(Ue, bt)) | 0),
        (d = (d + Math.imul(je, mt)) | 0),
        (g = (g + Math.imul(je, bt)) | 0);
      var hp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (hp >>> 26)) | 0),
        (hp &= 67108863),
        (m = Math.imul(Qe, ut)),
        (d = Math.imul(Qe, lt)),
        (d = (d + Math.imul(Ye, ut)) | 0),
        (g = Math.imul(Ye, lt)),
        (m = (m + Math.imul(We, ct)) | 0),
        (d = (d + Math.imul(We, dt)) | 0),
        (d = (d + Math.imul(Je, ct)) | 0),
        (g = (g + Math.imul(Je, dt)) | 0),
        (m = (m + Math.imul(Ke, pt)) | 0),
        (d = (d + Math.imul(Ke, ft)) | 0),
        (d = (d + Math.imul(qe, pt)) | 0),
        (g = (g + Math.imul(qe, ft)) | 0),
        (m = (m + Math.imul(Ge, ht)) | 0),
        (d = (d + Math.imul(Ge, yt)) | 0),
        (d = (d + Math.imul(He, ht)) | 0),
        (g = (g + Math.imul(He, yt)) | 0),
        (m = (m + Math.imul(Ve, mt)) | 0),
        (d = (d + Math.imul(Ve, bt)) | 0),
        (d = (d + Math.imul(ze, mt)) | 0),
        (g = (g + Math.imul(ze, bt)) | 0);
      var yp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (yp >>> 26)) | 0),
        (yp &= 67108863),
        (m = Math.imul(Qe, ct)),
        (d = Math.imul(Qe, dt)),
        (d = (d + Math.imul(Ye, ct)) | 0),
        (g = Math.imul(Ye, dt)),
        (m = (m + Math.imul(We, pt)) | 0),
        (d = (d + Math.imul(We, ft)) | 0),
        (d = (d + Math.imul(Je, pt)) | 0),
        (g = (g + Math.imul(Je, ft)) | 0),
        (m = (m + Math.imul(Ke, ht)) | 0),
        (d = (d + Math.imul(Ke, yt)) | 0),
        (d = (d + Math.imul(qe, ht)) | 0),
        (g = (g + Math.imul(qe, yt)) | 0),
        (m = (m + Math.imul(Ge, mt)) | 0),
        (d = (d + Math.imul(Ge, bt)) | 0),
        (d = (d + Math.imul(He, mt)) | 0),
        (g = (g + Math.imul(He, bt)) | 0);
      var mp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (mp >>> 26)) | 0),
        (mp &= 67108863),
        (m = Math.imul(Qe, pt)),
        (d = Math.imul(Qe, ft)),
        (d = (d + Math.imul(Ye, pt)) | 0),
        (g = Math.imul(Ye, ft)),
        (m = (m + Math.imul(We, ht)) | 0),
        (d = (d + Math.imul(We, yt)) | 0),
        (d = (d + Math.imul(Je, ht)) | 0),
        (g = (g + Math.imul(Je, yt)) | 0),
        (m = (m + Math.imul(Ke, mt)) | 0),
        (d = (d + Math.imul(Ke, bt)) | 0),
        (d = (d + Math.imul(qe, mt)) | 0),
        (g = (g + Math.imul(qe, bt)) | 0);
      var bp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (bp >>> 26)) | 0),
        (bp &= 67108863),
        (m = Math.imul(Qe, ht)),
        (d = Math.imul(Qe, yt)),
        (d = (d + Math.imul(Ye, ht)) | 0),
        (g = Math.imul(Ye, yt)),
        (m = (m + Math.imul(We, mt)) | 0),
        (d = (d + Math.imul(We, bt)) | 0),
        (d = (d + Math.imul(Je, mt)) | 0),
        (g = (g + Math.imul(Je, bt)) | 0);
      var gp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      (P = (((g + (d >>> 13)) | 0) + (gp >>> 26)) | 0), (gp &= 67108863), (m = Math.imul(Qe, mt)), (d = Math.imul(Qe, bt)), (d = (d + Math.imul(Ye, mt)) | 0), (g = Math.imul(Ye, bt));
      var vp = (((P + m) | 0) + ((d & 8191) << 13)) | 0;
      return (
        (P = (((g + (d >>> 13)) | 0) + (vp >>> 26)) | 0),
        (vp &= 67108863),
        (M[0] = Vi),
        (M[1] = zi),
        (M[2] = Gi),
        (M[3] = Hi),
        (M[4] = Ki),
        (M[5] = ap),
        (M[6] = op),
        (M[7] = up),
        (M[8] = lp),
        (M[9] = cp),
        (M[10] = dp),
        (M[11] = pp),
        (M[12] = fp),
        (M[13] = hp),
        (M[14] = yp),
        (M[15] = mp),
        (M[16] = bp),
        (M[17] = gp),
        (M[18] = vp),
        P !== 0 && ((M[19] = P), v.length++),
        v
      );
    };
    Math.imul || (k = _);
    function D(S, c, y) {
      (y.negative = c.negative ^ S.negative), (y.length = S.length + c.length);
      for (var v = 0, C = 0, A = 0; A < y.length - 1; A++) {
        var M = C;
        C = 0;
        for (var P = v & 67108863, m = Math.min(A, c.length - 1), d = Math.max(0, A - S.length + 1); d <= m; d++) {
          var g = A - d,
            I = S.words[g] | 0,
            f = c.words[d] | 0,
            R = I * f,
            L = R & 67108863;
          (M = (M + ((R / 67108864) | 0)) | 0), (L = (L + P) | 0), (P = L & 67108863), (M = (M + (L >>> 26)) | 0), (C += M >>> 26), (M &= 67108863);
        }
        (y.words[A] = P), (v = M), (M = C);
      }
      return v !== 0 ? (y.words[A] = v) : y.length--, y._strip();
    }
    function N(S, c, y) {
      return D(S, c, y);
    }
    (s.prototype.mulTo = function (c, y) {
      var v,
        C = this.length + c.length;
      return this.length === 10 && c.length === 10 ? (v = k(this, c, y)) : C < 63 ? (v = _(this, c, y)) : C < 1024 ? (v = D(this, c, y)) : (v = N(this, c, y)), v;
    }),
      (s.prototype.mul = function (c) {
        var y = new s(null);
        return (y.words = new Array(this.length + c.length)), this.mulTo(c, y);
      }),
      (s.prototype.mulf = function (c) {
        var y = new s(null);
        return (y.words = new Array(this.length + c.length)), N(this, c, y);
      }),
      (s.prototype.imul = function (c) {
        return this.clone().mulTo(c, this);
      }),
      (s.prototype.imuln = function (c) {
        var y = c < 0;
        y && (c = -c), r(typeof c == 'number'), r(c < 67108864);
        for (var v = 0, C = 0; C < this.length; C++) {
          var A = (this.words[C] | 0) * c,
            M = (A & 67108863) + (v & 67108863);
          (v >>= 26), (v += (A / 67108864) | 0), (v += M >>> 26), (this.words[C] = M & 67108863);
        }
        return v !== 0 && ((this.words[C] = v), this.length++), y ? this.ineg() : this;
      }),
      (s.prototype.muln = function (c) {
        return this.clone().imuln(c);
      }),
      (s.prototype.sqr = function () {
        return this.mul(this);
      }),
      (s.prototype.isqr = function () {
        return this.imul(this.clone());
      }),
      (s.prototype.pow = function (c) {
        var y = w(c);
        if (y.length === 0) return new s(1);
        for (var v = this, C = 0; C < y.length && y[C] === 0; C++, v = v.sqr());
        if (++C < y.length) for (var A = v.sqr(); C < y.length; C++, A = A.sqr()) y[C] !== 0 && (v = v.mul(A));
        return v;
      }),
      (s.prototype.iushln = function (c) {
        r(typeof c == 'number' && c >= 0);
        var y = c % 26,
          v = (c - y) / 26,
          C = (67108863 >>> (26 - y)) << (26 - y),
          A;
        if (y !== 0) {
          var M = 0;
          for (A = 0; A < this.length; A++) {
            var P = this.words[A] & C,
              m = ((this.words[A] | 0) - P) << y;
            (this.words[A] = m | M), (M = P >>> (26 - y));
          }
          M && ((this.words[A] = M), this.length++);
        }
        if (v !== 0) {
          for (A = this.length - 1; A >= 0; A--) this.words[A + v] = this.words[A];
          for (A = 0; A < v; A++) this.words[A] = 0;
          this.length += v;
        }
        return this._strip();
      }),
      (s.prototype.ishln = function (c) {
        return r(this.negative === 0), this.iushln(c);
      }),
      (s.prototype.iushrn = function (c, y, v) {
        r(typeof c == 'number' && c >= 0);
        var C;
        y ? (C = (y - (y % 26)) / 26) : (C = 0);
        var A = c % 26,
          M = Math.min((c - A) / 26, this.length),
          P = 67108863 ^ ((67108863 >>> A) << A),
          m = v;
        if (((C -= M), (C = Math.max(0, C)), m)) {
          for (var d = 0; d < M; d++) m.words[d] = this.words[d];
          m.length = M;
        }
        if (M !== 0)
          if (this.length > M) for (this.length -= M, d = 0; d < this.length; d++) this.words[d] = this.words[d + M];
          else (this.words[0] = 0), (this.length = 1);
        var g = 0;
        for (d = this.length - 1; d >= 0 && (g !== 0 || d >= C); d--) {
          var I = this.words[d] | 0;
          (this.words[d] = (g << (26 - A)) | (I >>> A)), (g = I & P);
        }
        return m && g !== 0 && (m.words[m.length++] = g), this.length === 0 && ((this.words[0] = 0), (this.length = 1)), this._strip();
      }),
      (s.prototype.ishrn = function (c, y, v) {
        return r(this.negative === 0), this.iushrn(c, y, v);
      }),
      (s.prototype.shln = function (c) {
        return this.clone().ishln(c);
      }),
      (s.prototype.ushln = function (c) {
        return this.clone().iushln(c);
      }),
      (s.prototype.shrn = function (c) {
        return this.clone().ishrn(c);
      }),
      (s.prototype.ushrn = function (c) {
        return this.clone().iushrn(c);
      }),
      (s.prototype.testn = function (c) {
        r(typeof c == 'number' && c >= 0);
        var y = c % 26,
          v = (c - y) / 26,
          C = 1 << y;
        if (this.length <= v) return !1;
        var A = this.words[v];
        return !!(A & C);
      }),
      (s.prototype.imaskn = function (c) {
        r(typeof c == 'number' && c >= 0);
        var y = c % 26,
          v = (c - y) / 26;
        if ((r(this.negative === 0, 'imaskn works only with positive numbers'), this.length <= v)) return this;
        if ((y !== 0 && v++, (this.length = Math.min(v, this.length)), y !== 0)) {
          var C = 67108863 ^ ((67108863 >>> y) << y);
          this.words[this.length - 1] &= C;
        }
        return this._strip();
      }),
      (s.prototype.maskn = function (c) {
        return this.clone().imaskn(c);
      }),
      (s.prototype.iaddn = function (c) {
        return (
          r(typeof c == 'number'),
          r(c < 67108864),
          c < 0
            ? this.isubn(-c)
            : this.negative !== 0
            ? this.length === 1 && (this.words[0] | 0) <= c
              ? ((this.words[0] = c - (this.words[0] | 0)), (this.negative = 0), this)
              : ((this.negative = 0), this.isubn(c), (this.negative = 1), this)
            : this._iaddn(c)
        );
      }),
      (s.prototype._iaddn = function (c) {
        this.words[0] += c;
        for (var y = 0; y < this.length && this.words[y] >= 67108864; y++) (this.words[y] -= 67108864), y === this.length - 1 ? (this.words[y + 1] = 1) : this.words[y + 1]++;
        return (this.length = Math.max(this.length, y + 1)), this;
      }),
      (s.prototype.isubn = function (c) {
        if ((r(typeof c == 'number'), r(c < 67108864), c < 0)) return this.iaddn(-c);
        if (this.negative !== 0) return (this.negative = 0), this.iaddn(c), (this.negative = 1), this;
        if (((this.words[0] -= c), this.length === 1 && this.words[0] < 0)) (this.words[0] = -this.words[0]), (this.negative = 1);
        else for (var y = 0; y < this.length && this.words[y] < 0; y++) (this.words[y] += 67108864), (this.words[y + 1] -= 1);
        return this._strip();
      }),
      (s.prototype.addn = function (c) {
        return this.clone().iaddn(c);
      }),
      (s.prototype.subn = function (c) {
        return this.clone().isubn(c);
      }),
      (s.prototype.iabs = function () {
        return (this.negative = 0), this;
      }),
      (s.prototype.abs = function () {
        return this.clone().iabs();
      }),
      (s.prototype._ishlnsubmul = function (c, y, v) {
        var C = c.length + v,
          A;
        this._expand(C);
        var M,
          P = 0;
        for (A = 0; A < c.length; A++) {
          M = (this.words[A + v] | 0) + P;
          var m = (c.words[A] | 0) * y;
          (M -= m & 67108863), (P = (M >> 26) - ((m / 67108864) | 0)), (this.words[A + v] = M & 67108863);
        }
        for (; A < this.length - v; A++) (M = (this.words[A + v] | 0) + P), (P = M >> 26), (this.words[A + v] = M & 67108863);
        if (P === 0) return this._strip();
        for (r(P === -1), P = 0, A = 0; A < this.length; A++) (M = -(this.words[A] | 0) + P), (P = M >> 26), (this.words[A] = M & 67108863);
        return (this.negative = 1), this._strip();
      }),
      (s.prototype._wordDiv = function (c, y) {
        var v = this.length - c.length,
          C = this.clone(),
          A = c,
          M = A.words[A.length - 1] | 0,
          P = this._countBits(M);
        (v = 26 - P), v !== 0 && ((A = A.ushln(v)), C.iushln(v), (M = A.words[A.length - 1] | 0));
        var m = C.length - A.length,
          d;
        if (y !== 'mod') {
          (d = new s(null)), (d.length = m + 1), (d.words = new Array(d.length));
          for (var g = 0; g < d.length; g++) d.words[g] = 0;
        }
        var I = C.clone()._ishlnsubmul(A, 1, m);
        I.negative === 0 && ((C = I), d && (d.words[m] = 1));
        for (var f = m - 1; f >= 0; f--) {
          var R = (C.words[A.length + f] | 0) * 67108864 + (C.words[A.length + f - 1] | 0);
          for (R = Math.min((R / M) | 0, 67108863), C._ishlnsubmul(A, R, f); C.negative !== 0; ) R--, (C.negative = 0), C._ishlnsubmul(A, 1, f), C.isZero() || (C.negative ^= 1);
          d && (d.words[f] = R);
        }
        return (
          d && d._strip(),
          C._strip(),
          y !== 'div' && v !== 0 && C.iushrn(v),
          {
            div: d || null,
            mod: C,
          }
        );
      }),
      (s.prototype.divmod = function (c, y, v) {
        if ((r(!c.isZero()), this.isZero()))
          return {
            div: new s(0),
            mod: new s(0),
          };
        var C, A, M;
        return this.negative !== 0 && c.negative === 0
          ? ((M = this.neg().divmod(c, y)),
            y !== 'mod' && (C = M.div.neg()),
            y !== 'div' && ((A = M.mod.neg()), v && A.negative !== 0 && A.iadd(c)),
            {
              div: C,
              mod: A,
            })
          : this.negative === 0 && c.negative !== 0
          ? ((M = this.divmod(c.neg(), y)),
            y !== 'mod' && (C = M.div.neg()),
            {
              div: C,
              mod: M.mod,
            })
          : this.negative & c.negative
          ? ((M = this.neg().divmod(c.neg(), y)),
            y !== 'div' && ((A = M.mod.neg()), v && A.negative !== 0 && A.isub(c)),
            {
              div: M.div,
              mod: A,
            })
          : c.length > this.length || this.cmp(c) < 0
          ? {
              div: new s(0),
              mod: this,
            }
          : c.length === 1
          ? y === 'div'
            ? {
                div: this.divn(c.words[0]),
                mod: null,
              }
            : y === 'mod'
            ? {
                div: null,
                mod: new s(this.modrn(c.words[0])),
              }
            : {
                div: this.divn(c.words[0]),
                mod: new s(this.modrn(c.words[0])),
              }
          : this._wordDiv(c, y);
      }),
      (s.prototype.div = function (c) {
        return this.divmod(c, 'div', !1).div;
      }),
      (s.prototype.mod = function (c) {
        return this.divmod(c, 'mod', !1).mod;
      }),
      (s.prototype.umod = function (c) {
        return this.divmod(c, 'mod', !0).mod;
      }),
      (s.prototype.divRound = function (c) {
        var y = this.divmod(c);
        if (y.mod.isZero()) return y.div;
        var v = y.div.negative !== 0 ? y.mod.isub(c) : y.mod,
          C = c.ushrn(1),
          A = c.andln(1),
          M = v.cmp(C);
        return M < 0 || (A === 1 && M === 0) ? y.div : y.div.negative !== 0 ? y.div.isubn(1) : y.div.iaddn(1);
      }),
      (s.prototype.modrn = function (c) {
        var y = c < 0;
        y && (c = -c), r(c <= 67108863);
        for (var v = (1 << 26) % c, C = 0, A = this.length - 1; A >= 0; A--) C = (v * C + (this.words[A] | 0)) % c;
        return y ? -C : C;
      }),
      (s.prototype.modn = function (c) {
        return this.modrn(c);
      }),
      (s.prototype.idivn = function (c) {
        var y = c < 0;
        y && (c = -c), r(c <= 67108863);
        for (var v = 0, C = this.length - 1; C >= 0; C--) {
          var A = (this.words[C] | 0) + v * 67108864;
          (this.words[C] = (A / c) | 0), (v = A % c);
        }
        return this._strip(), y ? this.ineg() : this;
      }),
      (s.prototype.divn = function (c) {
        return this.clone().idivn(c);
      }),
      (s.prototype.egcd = function (c) {
        r(c.negative === 0), r(!c.isZero());
        var y = this,
          v = c.clone();
        y.negative !== 0 ? (y = y.umod(c)) : (y = y.clone());
        for (var C = new s(1), A = new s(0), M = new s(0), P = new s(1), m = 0; y.isEven() && v.isEven(); ) y.iushrn(1), v.iushrn(1), ++m;
        for (var d = v.clone(), g = y.clone(); !y.isZero(); ) {
          for (var I = 0, f = 1; !(y.words[0] & f) && I < 26; ++I, f <<= 1);
          if (I > 0) for (y.iushrn(I); I-- > 0; ) (C.isOdd() || A.isOdd()) && (C.iadd(d), A.isub(g)), C.iushrn(1), A.iushrn(1);
          for (var R = 0, L = 1; !(v.words[0] & L) && R < 26; ++R, L <<= 1);
          if (R > 0) for (v.iushrn(R); R-- > 0; ) (M.isOdd() || P.isOdd()) && (M.iadd(d), P.isub(g)), M.iushrn(1), P.iushrn(1);
          y.cmp(v) >= 0 ? (y.isub(v), C.isub(M), A.isub(P)) : (v.isub(y), M.isub(C), P.isub(A));
        }
        return {
          a: M,
          b: P,
          gcd: v.iushln(m),
        };
      }),
      (s.prototype._invmp = function (c) {
        r(c.negative === 0), r(!c.isZero());
        var y = this,
          v = c.clone();
        y.negative !== 0 ? (y = y.umod(c)) : (y = y.clone());
        for (var C = new s(1), A = new s(0), M = v.clone(); y.cmpn(1) > 0 && v.cmpn(1) > 0; ) {
          for (var P = 0, m = 1; !(y.words[0] & m) && P < 26; ++P, m <<= 1);
          if (P > 0) for (y.iushrn(P); P-- > 0; ) C.isOdd() && C.iadd(M), C.iushrn(1);
          for (var d = 0, g = 1; !(v.words[0] & g) && d < 26; ++d, g <<= 1);
          if (d > 0) for (v.iushrn(d); d-- > 0; ) A.isOdd() && A.iadd(M), A.iushrn(1);
          y.cmp(v) >= 0 ? (y.isub(v), C.isub(A)) : (v.isub(y), A.isub(C));
        }
        var I;
        return y.cmpn(1) === 0 ? (I = C) : (I = A), I.cmpn(0) < 0 && I.iadd(c), I;
      }),
      (s.prototype.gcd = function (c) {
        if (this.isZero()) return c.abs();
        if (c.isZero()) return this.abs();
        var y = this.clone(),
          v = c.clone();
        (y.negative = 0), (v.negative = 0);
        for (var C = 0; y.isEven() && v.isEven(); C++) y.iushrn(1), v.iushrn(1);
        do {
          for (; y.isEven(); ) y.iushrn(1);
          for (; v.isEven(); ) v.iushrn(1);
          var A = y.cmp(v);
          if (A < 0) {
            var M = y;
            (y = v), (v = M);
          } else if (A === 0 || v.cmpn(1) === 0) break;
          y.isub(v);
        } while (!0);
        return v.iushln(C);
      }),
      (s.prototype.invm = function (c) {
        return this.egcd(c).a.umod(c);
      }),
      (s.prototype.isEven = function () {
        return (this.words[0] & 1) === 0;
      }),
      (s.prototype.isOdd = function () {
        return (this.words[0] & 1) === 1;
      }),
      (s.prototype.andln = function (c) {
        return this.words[0] & c;
      }),
      (s.prototype.bincn = function (c) {
        r(typeof c == 'number');
        var y = c % 26,
          v = (c - y) / 26,
          C = 1 << y;
        if (this.length <= v) return this._expand(v + 1), (this.words[v] |= C), this;
        for (var A = C, M = v; A !== 0 && M < this.length; M++) {
          var P = this.words[M] | 0;
          (P += A), (A = P >>> 26), (P &= 67108863), (this.words[M] = P);
        }
        return A !== 0 && ((this.words[M] = A), this.length++), this;
      }),
      (s.prototype.isZero = function () {
        return this.length === 1 && this.words[0] === 0;
      }),
      (s.prototype.cmpn = function (c) {
        var y = c < 0;
        if (this.negative !== 0 && !y) return -1;
        if (this.negative === 0 && y) return 1;
        this._strip();
        var v;
        if (this.length > 1) v = 1;
        else {
          y && (c = -c), r(c <= 67108863, 'Number is too big');
          var C = this.words[0] | 0;
          v = C === c ? 0 : C < c ? -1 : 1;
        }
        return this.negative !== 0 ? -v | 0 : v;
      }),
      (s.prototype.cmp = function (c) {
        if (this.negative !== 0 && c.negative === 0) return -1;
        if (this.negative === 0 && c.negative !== 0) return 1;
        var y = this.ucmp(c);
        return this.negative !== 0 ? -y | 0 : y;
      }),
      (s.prototype.ucmp = function (c) {
        if (this.length > c.length) return 1;
        if (this.length < c.length) return -1;
        for (var y = 0, v = this.length - 1; v >= 0; v--) {
          var C = this.words[v] | 0,
            A = c.words[v] | 0;
          if (C !== A) {
            C < A ? (y = -1) : C > A && (y = 1);
            break;
          }
        }
        return y;
      }),
      (s.prototype.gtn = function (c) {
        return this.cmpn(c) === 1;
      }),
      (s.prototype.gt = function (c) {
        return this.cmp(c) === 1;
      }),
      (s.prototype.gten = function (c) {
        return this.cmpn(c) >= 0;
      }),
      (s.prototype.gte = function (c) {
        return this.cmp(c) >= 0;
      }),
      (s.prototype.ltn = function (c) {
        return this.cmpn(c) === -1;
      }),
      (s.prototype.lt = function (c) {
        return this.cmp(c) === -1;
      }),
      (s.prototype.lten = function (c) {
        return this.cmpn(c) <= 0;
      }),
      (s.prototype.lte = function (c) {
        return this.cmp(c) <= 0;
      }),
      (s.prototype.eqn = function (c) {
        return this.cmpn(c) === 0;
      }),
      (s.prototype.eq = function (c) {
        return this.cmp(c) === 0;
      }),
      (s.red = function (c) {
        return new J(c);
      }),
      (s.prototype.toRed = function (c) {
        return r(!this.red, 'Already a number in reduction context'), r(this.negative === 0, 'red works only with positives'), c.convertTo(this)._forceRed(c);
      }),
      (s.prototype.fromRed = function () {
        return r(this.red, 'fromRed works only with numbers in reduction context'), this.red.convertFrom(this);
      }),
      (s.prototype._forceRed = function (c) {
        return (this.red = c), this;
      }),
      (s.prototype.forceRed = function (c) {
        return r(!this.red, 'Already a number in reduction context'), this._forceRed(c);
      }),
      (s.prototype.redAdd = function (c) {
        return r(this.red, 'redAdd works only with red numbers'), this.red.add(this, c);
      }),
      (s.prototype.redIAdd = function (c) {
        return r(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, c);
      }),
      (s.prototype.redSub = function (c) {
        return r(this.red, 'redSub works only with red numbers'), this.red.sub(this, c);
      }),
      (s.prototype.redISub = function (c) {
        return r(this.red, 'redISub works only with red numbers'), this.red.isub(this, c);
      }),
      (s.prototype.redShl = function (c) {
        return r(this.red, 'redShl works only with red numbers'), this.red.shl(this, c);
      }),
      (s.prototype.redMul = function (c) {
        return r(this.red, 'redMul works only with red numbers'), this.red._verify2(this, c), this.red.mul(this, c);
      }),
      (s.prototype.redIMul = function (c) {
        return r(this.red, 'redMul works only with red numbers'), this.red._verify2(this, c), this.red.imul(this, c);
      }),
      (s.prototype.redSqr = function () {
        return r(this.red, 'redSqr works only with red numbers'), this.red._verify1(this), this.red.sqr(this);
      }),
      (s.prototype.redISqr = function () {
        return r(this.red, 'redISqr works only with red numbers'), this.red._verify1(this), this.red.isqr(this);
      }),
      (s.prototype.redSqrt = function () {
        return r(this.red, 'redSqrt works only with red numbers'), this.red._verify1(this), this.red.sqrt(this);
      }),
      (s.prototype.redInvm = function () {
        return r(this.red, 'redInvm works only with red numbers'), this.red._verify1(this), this.red.invm(this);
      }),
      (s.prototype.redNeg = function () {
        return r(this.red, 'redNeg works only with red numbers'), this.red._verify1(this), this.red.neg(this);
      }),
      (s.prototype.redPow = function (c) {
        return r(this.red && !c.red, 'redPow(normalNum)'), this.red._verify1(this), this.red.pow(this, c);
      });
    var B = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null,
    };
    function j(S, c) {
      (this.name = S), (this.p = new s(c, 16)), (this.n = this.p.bitLength()), (this.k = new s(1).iushln(this.n).isub(this.p)), (this.tmp = this._tmp());
    }
    (j.prototype._tmp = function () {
      var c = new s(null);
      return (c.words = new Array(Math.ceil(this.n / 13))), c;
    }),
      (j.prototype.ireduce = function (c) {
        var y = c,
          v;
        do this.split(y, this.tmp), (y = this.imulK(y)), (y = y.iadd(this.tmp)), (v = y.bitLength());
        while (v > this.n);
        var C = v < this.n ? -1 : y.ucmp(this.p);
        return C === 0 ? ((y.words[0] = 0), (y.length = 1)) : C > 0 ? y.isub(this.p) : y.strip !== void 0 ? y.strip() : y._strip(), y;
      }),
      (j.prototype.split = function (c, y) {
        c.iushrn(this.n, 0, y);
      }),
      (j.prototype.imulK = function (c) {
        return c.imul(this.k);
      });
    function q() {
      j.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    i(q, j),
      (q.prototype.split = function (c, y) {
        for (var v = 4194303, C = Math.min(c.length, 9), A = 0; A < C; A++) y.words[A] = c.words[A];
        if (((y.length = C), c.length <= 9)) {
          (c.words[0] = 0), (c.length = 1);
          return;
        }
        var M = c.words[9];
        for (y.words[y.length++] = M & v, A = 10; A < c.length; A++) {
          var P = c.words[A] | 0;
          (c.words[A - 10] = ((P & v) << 4) | (M >>> 22)), (M = P);
        }
        (M >>>= 22), (c.words[A - 10] = M), M === 0 && c.length > 10 ? (c.length -= 10) : (c.length -= 9);
      }),
      (q.prototype.imulK = function (c) {
        (c.words[c.length] = 0), (c.words[c.length + 1] = 0), (c.length += 2);
        for (var y = 0, v = 0; v < c.length; v++) {
          var C = c.words[v] | 0;
          (y += C * 977), (c.words[v] = y & 67108863), (y = C * 64 + ((y / 67108864) | 0));
        }
        return c.words[c.length - 1] === 0 && (c.length--, c.words[c.length - 1] === 0 && c.length--), c;
      });
    function z() {
      j.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    i(z, j);
    function Y() {
      j.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    i(Y, j);
    function ae() {
      j.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    i(ae, j),
      (ae.prototype.imulK = function (c) {
        for (var y = 0, v = 0; v < c.length; v++) {
          var C = (c.words[v] | 0) * 19 + y,
            A = C & 67108863;
          (C >>>= 26), (c.words[v] = A), (y = C);
        }
        return y !== 0 && (c.words[c.length++] = y), c;
      }),
      (s._prime = function (c) {
        if (B[c]) return B[c];
        var y;
        if (c === 'k256') y = new q();
        else if (c === 'p224') y = new z();
        else if (c === 'p192') y = new Y();
        else if (c === 'p25519') y = new ae();
        else throw new Error('Unknown prime ' + c);
        return (B[c] = y), y;
      });
    function J(S) {
      if (typeof S == 'string') {
        var c = s._prime(S);
        (this.m = c.p), (this.prime = c);
      } else r(S.gtn(1), 'modulus must be greater than 1'), (this.m = S), (this.prime = null);
    }
    (J.prototype._verify1 = function (c) {
      r(c.negative === 0, 'red works only with positives'), r(c.red, 'red works only with red numbers');
    }),
      (J.prototype._verify2 = function (c, y) {
        r((c.negative | y.negative) === 0, 'red works only with positives'), r(c.red && c.red === y.red, 'red works only with red numbers');
      }),
      (J.prototype.imod = function (c) {
        return this.prime ? this.prime.ireduce(c)._forceRed(this) : (p(c, c.umod(this.m)._forceRed(this)), c);
      }),
      (J.prototype.neg = function (c) {
        return c.isZero() ? c.clone() : this.m.sub(c)._forceRed(this);
      }),
      (J.prototype.add = function (c, y) {
        this._verify2(c, y);
        var v = c.add(y);
        return v.cmp(this.m) >= 0 && v.isub(this.m), v._forceRed(this);
      }),
      (J.prototype.iadd = function (c, y) {
        this._verify2(c, y);
        var v = c.iadd(y);
        return v.cmp(this.m) >= 0 && v.isub(this.m), v;
      }),
      (J.prototype.sub = function (c, y) {
        this._verify2(c, y);
        var v = c.sub(y);
        return v.cmpn(0) < 0 && v.iadd(this.m), v._forceRed(this);
      }),
      (J.prototype.isub = function (c, y) {
        this._verify2(c, y);
        var v = c.isub(y);
        return v.cmpn(0) < 0 && v.iadd(this.m), v;
      }),
      (J.prototype.shl = function (c, y) {
        return this._verify1(c), this.imod(c.ushln(y));
      }),
      (J.prototype.imul = function (c, y) {
        return this._verify2(c, y), this.imod(c.imul(y));
      }),
      (J.prototype.mul = function (c, y) {
        return this._verify2(c, y), this.imod(c.mul(y));
      }),
      (J.prototype.isqr = function (c) {
        return this.imul(c, c.clone());
      }),
      (J.prototype.sqr = function (c) {
        return this.mul(c, c);
      }),
      (J.prototype.sqrt = function (c) {
        if (c.isZero()) return c.clone();
        var y = this.m.andln(3);
        if ((r(y % 2 === 1), y === 3)) {
          var v = this.m.add(new s(1)).iushrn(2);
          return this.pow(c, v);
        }
        for (var C = this.m.subn(1), A = 0; !C.isZero() && C.andln(1) === 0; ) A++, C.iushrn(1);
        r(!C.isZero());
        var M = new s(1).toRed(this),
          P = M.redNeg(),
          m = this.m.subn(1).iushrn(1),
          d = this.m.bitLength();
        for (d = new s(2 * d * d).toRed(this); this.pow(d, m).cmp(P) !== 0; ) d.redIAdd(P);
        for (var g = this.pow(d, C), I = this.pow(c, C.addn(1).iushrn(1)), f = this.pow(c, C), R = A; f.cmp(M) !== 0; ) {
          for (var L = f, F = 0; L.cmp(M) !== 0; F++) L = L.redSqr();
          r(F < R);
          var $ = this.pow(g, new s(1).iushln(R - F - 1));
          (I = I.redMul($)), (g = $.redSqr()), (f = f.redMul(g)), (R = F);
        }
        return I;
      }),
      (J.prototype.invm = function (c) {
        var y = c._invmp(this.m);
        return y.negative !== 0 ? ((y.negative = 0), this.imod(y).redNeg()) : this.imod(y);
      }),
      (J.prototype.pow = function (c, y) {
        if (y.isZero()) return new s(1).toRed(this);
        if (y.cmpn(1) === 0) return c.clone();
        var v = 4,
          C = new Array(1 << v);
        (C[0] = new s(1).toRed(this)), (C[1] = c);
        for (var A = 2; A < C.length; A++) C[A] = this.mul(C[A - 1], c);
        var M = C[0],
          P = 0,
          m = 0,
          d = y.bitLength() % 26;
        for (d === 0 && (d = 26), A = y.length - 1; A >= 0; A--) {
          for (var g = y.words[A], I = d - 1; I >= 0; I--) {
            var f = (g >> I) & 1;
            if ((M !== C[0] && (M = this.sqr(M)), f === 0 && P === 0)) {
              m = 0;
              continue;
            }
            (P <<= 1), (P |= f), m++, !(m !== v && (A !== 0 || I !== 0)) && ((M = this.mul(M, C[P])), (m = 0), (P = 0));
          }
          d = 26;
        }
        return M;
      }),
      (J.prototype.convertTo = function (c) {
        var y = c.umod(this.m);
        return y === c ? y.clone() : y;
      }),
      (J.prototype.convertFrom = function (c) {
        var y = c.clone();
        return (y.red = null), y;
      }),
      (s.mont = function (c) {
        return new oe(c);
      });
    function oe(S) {
      J.call(this, S),
        (this.shift = this.m.bitLength()),
        this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
        (this.r = new s(1).iushln(this.shift)),
        (this.r2 = this.imod(this.r.sqr())),
        (this.rinv = this.r._invmp(this.m)),
        (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
        (this.minv = this.minv.umod(this.r)),
        (this.minv = this.r.sub(this.minv));
    }
    i(oe, J),
      (oe.prototype.convertTo = function (c) {
        return this.imod(c.ushln(this.shift));
      }),
      (oe.prototype.convertFrom = function (c) {
        var y = this.imod(c.mul(this.rinv));
        return (y.red = null), y;
      }),
      (oe.prototype.imul = function (c, y) {
        if (c.isZero() || y.isZero()) return (c.words[0] = 0), (c.length = 1), c;
        var v = c.imul(y),
          C = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          A = v.isub(C).iushrn(this.shift),
          M = A;
        return A.cmp(this.m) >= 0 ? (M = A.isub(this.m)) : A.cmpn(0) < 0 && (M = A.iadd(this.m)), M._forceRed(this);
      }),
      (oe.prototype.mul = function (c, y) {
        if (c.isZero() || y.isZero()) return new s(0)._forceRed(this);
        var v = c.mul(y),
          C = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          A = v.isub(C).iushrn(this.shift),
          M = A;
        return A.cmp(this.m) >= 0 ? (M = A.isub(this.m)) : A.cmpn(0) < 0 && (M = A.iadd(this.m)), M._forceRed(this);
      }),
      (oe.prototype.invm = function (c) {
        var y = this.imod(c._invmp(this.m).mul(this.r2));
        return y._forceRed(this);
      });
  })(n, es);
})(VE);
const pe = qf,
  KE = 'logger/5.7.0';
let Sg = !1,
  Mg = !1;
const lc = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let _g = lc.default,
  Vp = null;
function qE() {
  try {
    const n = [];
    if (
      (['NFD', 'NFC', 'NFKD', 'NFKC'].forEach((e) => {
        try {
          if ('test'.normalize(e) !== 'test') throw new Error('bad normalize');
        } catch {
          n.push(e);
        }
      }),
      n.length)
    )
      throw new Error('missing ' + n.join(', '));
    if (String.fromCharCode(233).normalize('NFD') !== String.fromCharCode(101, 769)) throw new Error('broken implementation');
  } catch (n) {
    return n.message;
  }
  return null;
}
const Rg = qE();
var Vc;
(function (n) {
  (n.DEBUG = 'DEBUG'), (n.INFO = 'INFO'), (n.WARNING = 'WARNING'), (n.ERROR = 'ERROR'), (n.OFF = 'OFF');
})(Vc || (Vc = {}));
var nr;
(function (n) {
  (n.UNKNOWN_ERROR = 'UNKNOWN_ERROR'),
    (n.NOT_IMPLEMENTED = 'NOT_IMPLEMENTED'),
    (n.UNSUPPORTED_OPERATION = 'UNSUPPORTED_OPERATION'),
    (n.NETWORK_ERROR = 'NETWORK_ERROR'),
    (n.SERVER_ERROR = 'SERVER_ERROR'),
    (n.TIMEOUT = 'TIMEOUT'),
    (n.BUFFER_OVERRUN = 'BUFFER_OVERRUN'),
    (n.NUMERIC_FAULT = 'NUMERIC_FAULT'),
    (n.MISSING_NEW = 'MISSING_NEW'),
    (n.INVALID_ARGUMENT = 'INVALID_ARGUMENT'),
    (n.MISSING_ARGUMENT = 'MISSING_ARGUMENT'),
    (n.UNEXPECTED_ARGUMENT = 'UNEXPECTED_ARGUMENT'),
    (n.CALL_EXCEPTION = 'CALL_EXCEPTION'),
    (n.INSUFFICIENT_FUNDS = 'INSUFFICIENT_FUNDS'),
    (n.NONCE_EXPIRED = 'NONCE_EXPIRED'),
    (n.REPLACEMENT_UNDERPRICED = 'REPLACEMENT_UNDERPRICED'),
    (n.UNPREDICTABLE_GAS_LIMIT = 'UNPREDICTABLE_GAS_LIMIT'),
    (n.TRANSACTION_REPLACED = 'TRANSACTION_REPLACED'),
    (n.ACTION_REJECTED = 'ACTION_REJECTED');
})(nr || (nr = {}));
const Pg = '0123456789abcdef';
let O = class jt {
  constructor(e) {
    Object.defineProperty(this, 'version', {
      enumerable: !0,
      value: e,
      writable: !1,
    });
  }
  _log(e, t) {
    const r = e.toLowerCase();
    lc[r] == null && this.throwArgumentError('invalid log level name', 'logLevel', e), !(_g > lc[r]) && console.log.apply(console, t);
  }
  debug(...e) {
    this._log(jt.levels.DEBUG, e);
  }
  info(...e) {
    this._log(jt.levels.INFO, e);
  }
  warn(...e) {
    this._log(jt.levels.WARNING, e);
  }
  makeError(e, t, r) {
    if (Mg) return this.makeError('censored error', t, {});
    t || (t = jt.errors.UNKNOWN_ERROR), r || (r = {});
    const i = [];
    Object.keys(r).forEach((u) => {
      const l = r[u];
      try {
        if (l instanceof Uint8Array) {
          let p = '';
          for (let h = 0; h < l.length; h++) (p += Pg[l[h] >> 4]), (p += Pg[l[h] & 15]);
          i.push(u + '=Uint8Array(0x' + p + ')');
        } else i.push(u + '=' + JSON.stringify(l));
      } catch {
        i.push(u + '=' + JSON.stringify(r[u].toString()));
      }
    }),
      i.push(`code=${t}`),
      i.push(`version=${this.version}`);
    const s = e;
    let a = '';
    switch (t) {
      case nr.NUMERIC_FAULT: {
        a = 'NUMERIC_FAULT';
        const u = e;
        switch (u) {
          case 'overflow':
          case 'underflow':
          case 'division-by-zero':
            a += '-' + u;
            break;
          case 'negative-power':
          case 'negative-width':
            a += '-unsupported';
            break;
          case 'unbound-bitwise-result':
            a += '-unbound-result';
            break;
        }
        break;
      }
      case nr.CALL_EXCEPTION:
      case nr.INSUFFICIENT_FUNDS:
      case nr.MISSING_NEW:
      case nr.NONCE_EXPIRED:
      case nr.REPLACEMENT_UNDERPRICED:
      case nr.TRANSACTION_REPLACED:
      case nr.UNPREDICTABLE_GAS_LIMIT:
        a = t;
        break;
    }
    a && (e += ' [ See: https://links.ethers.org/v5-errors-' + a + ' ]'), i.length && (e += ' (' + i.join(', ') + ')');
    const o = new Error(e);
    return (
      (o.reason = s),
      (o.code = t),
      Object.keys(r).forEach(function (u) {
        o[u] = r[u];
      }),
      o
    );
  }
  throwError(e, t, r) {
    throw this.makeError(e, t, r);
  }
  throwArgumentError(e, t, r) {
    return this.throwError(e, jt.errors.INVALID_ARGUMENT, {
      argument: t,
      value: r,
    });
  }
  assert(e, t, r, i) {
    e || this.throwError(t, r, i);
  }
  assertArgument(e, t, r, i) {
    e || this.throwArgumentError(t, r, i);
  }
  checkNormalize(e) {
    Rg &&
      this.throwError('platform missing String.prototype.normalize', jt.errors.UNSUPPORTED_OPERATION, {
        operation: 'String.prototype.normalize',
        form: Rg,
      });
  }
  checkSafeUint53(e, t) {
    typeof e == 'number' &&
      (t == null && (t = 'value not safe'),
      (e < 0 || e >= 9007199254740991) &&
        this.throwError(t, jt.errors.NUMERIC_FAULT, {
          operation: 'checkSafeInteger',
          fault: 'out-of-safe-range',
          value: e,
        }),
      e % 1 &&
        this.throwError(t, jt.errors.NUMERIC_FAULT, {
          operation: 'checkSafeInteger',
          fault: 'non-integer',
          value: e,
        }));
  }
  checkArgumentCount(e, t, r) {
    r ? (r = ': ' + r) : (r = ''),
      e < t &&
        this.throwError('missing argument' + r, jt.errors.MISSING_ARGUMENT, {
          count: e,
          expectedCount: t,
        }),
      e > t &&
        this.throwError('too many arguments' + r, jt.errors.UNEXPECTED_ARGUMENT, {
          count: e,
          expectedCount: t,
        });
  }
  checkNew(e, t) {
    (e === Object || e == null) && this.throwError('missing new', jt.errors.MISSING_NEW, { name: t.name });
  }
  checkAbstract(e, t) {
    e === t
      ? this.throwError('cannot instantiate abstract class ' + JSON.stringify(t.name) + ' directly; use a sub-class', jt.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: 'new' })
      : (e === Object || e == null) && this.throwError('missing new', jt.errors.MISSING_NEW, { name: t.name });
  }
  static globalLogger() {
    return Vp || (Vp = new jt(KE)), Vp;
  }
  static setCensorship(e, t) {
    if (
      (!e &&
        t &&
        this.globalLogger().throwError('cannot permanently disable censorship', jt.errors.UNSUPPORTED_OPERATION, {
          operation: 'setCensorship',
        }),
      Sg)
    ) {
      if (!e) return;
      this.globalLogger().throwError('error censorship permanent', jt.errors.UNSUPPORTED_OPERATION, {
        operation: 'setCensorship',
      });
    }
    (Mg = !!e), (Sg = !!t);
  }
  static setLogLevel(e) {
    const t = lc[e.toLowerCase()];
    if (t == null) {
      jt.globalLogger().warn('invalid log level - ' + e);
      return;
    }
    _g = t;
  }
  static from(e) {
    return new jt(e);
  }
};
O.errors = nr;
O.levels = Vc;
const WE = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        get ErrorCode() {
          return nr;
        },
        get LogLevel() {
          return Vc;
        },
        Logger: O,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  JE = 'bytes/5.7.0',
  St = new O(JE);
function w1(n) {
  return !!n.toHexString;
}
function Ya(n) {
  return (
    n.slice ||
      (n.slice = function () {
        const e = Array.prototype.slice.call(arguments);
        return Ya(new Uint8Array(Array.prototype.slice.apply(n, e)));
      }),
    n
  );
}
function bl(n) {
  return (Ae(n) && !(n.length % 2)) || Ca(n);
}
function Ig(n) {
  return typeof n == 'number' && n == n && n % 1 === 0;
}
function Ca(n) {
  if (n == null) return !1;
  if (n.constructor === Uint8Array) return !0;
  if (typeof n == 'string' || !Ig(n.length) || n.length < 0) return !1;
  for (let e = 0; e < n.length; e++) {
    const t = n[e];
    if (!Ig(t) || t < 0 || t >= 256) return !1;
  }
  return !0;
}
function H(n, e) {
  if ((e || (e = {}), typeof n == 'number')) {
    St.checkSafeUint53(n, 'invalid arrayify value');
    const t = [];
    for (; n; ) t.unshift(n & 255), (n = parseInt(String(n / 256)));
    return t.length === 0 && t.push(0), Ya(new Uint8Array(t));
  }
  if ((e.allowMissingPrefix && typeof n == 'string' && n.substring(0, 2) !== '0x' && (n = '0x' + n), w1(n) && (n = n.toHexString()), Ae(n))) {
    let t = n.substring(2);
    t.length % 2 && (e.hexPad === 'left' ? (t = '0' + t) : e.hexPad === 'right' ? (t += '0') : St.throwArgumentError('hex data is odd-length', 'value', n));
    const r = [];
    for (let i = 0; i < t.length; i += 2) r.push(parseInt(t.substring(i, i + 2), 16));
    return Ya(new Uint8Array(r));
  }
  return Ca(n) ? Ya(new Uint8Array(n)) : St.throwArgumentError('invalid arrayify value', 'value', n);
}
function $e(n) {
  const e = n.map((i) => H(i)),
    t = e.reduce((i, s) => i + s.length, 0),
    r = new Uint8Array(t);
  return e.reduce((i, s) => (r.set(s, i), i + s.length), 0), Ya(r);
}
function zr(n) {
  let e = H(n);
  if (e.length === 0) return e;
  let t = 0;
  for (; t < e.length && e[t] === 0; ) t++;
  return t && (e = e.slice(t)), e;
}
function lu(n, e) {
  (n = H(n)), n.length > e && St.throwArgumentError('value out of range', 'value', arguments[0]);
  const t = new Uint8Array(e);
  return t.set(n, e - n.length), Ya(t);
}
function Ae(n, e) {
  return !(typeof n != 'string' || !n.match(/^0x[0-9A-Fa-f]*$/) || (e && n.length !== 2 + 2 * e));
}
const zp = '0123456789abcdef';
function K(n, e) {
  if ((e || (e = {}), typeof n == 'number')) {
    St.checkSafeUint53(n, 'invalid hexlify value');
    let t = '';
    for (; n; ) (t = zp[n & 15] + t), (n = Math.floor(n / 16));
    return t.length ? (t.length % 2 && (t = '0' + t), '0x' + t) : '0x00';
  }
  if (typeof n == 'bigint') return (n = n.toString(16)), n.length % 2 ? '0x0' + n : '0x' + n;
  if ((e.allowMissingPrefix && typeof n == 'string' && n.substring(0, 2) !== '0x' && (n = '0x' + n), w1(n))) return n.toHexString();
  if (Ae(n))
    return n.length % 2 && (e.hexPad === 'left' ? (n = '0x0' + n.substring(2)) : e.hexPad === 'right' ? (n += '0') : St.throwArgumentError('hex data is odd-length', 'value', n)), n.toLowerCase();
  if (Ca(n)) {
    let t = '0x';
    for (let r = 0; r < n.length; r++) {
      let i = n[r];
      t += zp[(i & 240) >> 4] + zp[i & 15];
    }
    return t;
  }
  return St.throwArgumentError('invalid hexlify value', 'value', n);
}
function Jr(n) {
  if (typeof n != 'string') n = K(n);
  else if (!Ae(n) || n.length % 2) return null;
  return (n.length - 2) / 2;
}
function Bt(n, e, t) {
  return (
    typeof n != 'string' ? (n = K(n)) : (!Ae(n) || n.length % 2) && St.throwArgumentError('invalid hexData', 'value', n),
    (e = 2 + 2 * e),
    t != null ? '0x' + n.substring(e, 2 + 2 * t) : '0x' + n.substring(e)
  );
}
function xn(n) {
  let e = '0x';
  return (
    n.forEach((t) => {
      e += K(t).substring(2);
    }),
    e
  );
}
function Od(n) {
  const e = T1(K(n, { hexPad: 'left' }));
  return e === '0x' ? '0x0' : e;
}
function T1(n) {
  typeof n != 'string' && (n = K(n)), Ae(n) || St.throwArgumentError('invalid hex string', 'value', n), (n = n.substring(2));
  let e = 0;
  for (; e < n.length && n[e] === '0'; ) e++;
  return '0x' + n.substring(e);
}
function Be(n, e) {
  for (
    typeof n != 'string' ? (n = K(n)) : Ae(n) || St.throwArgumentError('invalid hex string', 'value', n), n.length > 2 * e + 2 && St.throwArgumentError('value out of range', 'value', arguments[1]);
    n.length < 2 * e + 2;

  )
    n = '0x0' + n.substring(2);
  return n;
}
function Sa(n) {
  const e = {
    r: '0x',
    s: '0x',
    _vs: '0x',
    recoveryParam: 0,
    v: 0,
    yParityAndS: '0x',
    compact: '0x',
  };
  if (bl(n)) {
    let t = H(n);
    t.length === 64
      ? ((e.v = 27 + (t[32] >> 7)), (t[32] &= 127), (e.r = K(t.slice(0, 32))), (e.s = K(t.slice(32, 64))))
      : t.length === 65
      ? ((e.r = K(t.slice(0, 32))), (e.s = K(t.slice(32, 64))), (e.v = t[64]))
      : St.throwArgumentError('invalid signature string', 'signature', n),
      e.v < 27 && (e.v === 0 || e.v === 1 ? (e.v += 27) : St.throwArgumentError('signature invalid v byte', 'signature', n)),
      (e.recoveryParam = 1 - (e.v % 2)),
      e.recoveryParam && (t[32] |= 128),
      (e._vs = K(t.slice(32, 64)));
  } else {
    if (((e.r = n.r), (e.s = n.s), (e.v = n.v), (e.recoveryParam = n.recoveryParam), (e._vs = n._vs), e._vs != null)) {
      const i = lu(H(e._vs), 32);
      e._vs = K(i);
      const s = i[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? (e.recoveryParam = s) : e.recoveryParam !== s && St.throwArgumentError('signature recoveryParam mismatch _vs', 'signature', n), (i[0] &= 127);
      const a = K(i);
      e.s == null ? (e.s = a) : e.s !== a && St.throwArgumentError('signature v mismatch _vs', 'signature', n);
    }
    if (e.recoveryParam == null)
      e.v == null ? St.throwArgumentError('signature missing v and recoveryParam', 'signature', n) : e.v === 0 || e.v === 1 ? (e.recoveryParam = e.v) : (e.recoveryParam = 1 - (e.v % 2));
    else if (e.v == null) e.v = 27 + e.recoveryParam;
    else {
      const i = e.v === 0 || e.v === 1 ? e.v : 1 - (e.v % 2);
      e.recoveryParam !== i && St.throwArgumentError('signature recoveryParam mismatch v', 'signature', n);
    }
    e.r == null || !Ae(e.r) ? St.throwArgumentError('signature missing or invalid r', 'signature', n) : (e.r = Be(e.r, 32)),
      e.s == null || !Ae(e.s) ? St.throwArgumentError('signature missing or invalid s', 'signature', n) : (e.s = Be(e.s, 32));
    const t = H(e.s);
    t[0] >= 128 && St.throwArgumentError('signature s out of range', 'signature', n), e.recoveryParam && (t[0] |= 128);
    const r = K(t);
    e._vs && (Ae(e._vs) || St.throwArgumentError('signature invalid _vs', 'signature', n), (e._vs = Be(e._vs, 32))),
      e._vs == null ? (e._vs = r) : e._vs !== r && St.throwArgumentError('signature _vs mismatch v and s', 'signature', n);
  }
  return (e.yParityAndS = e._vs), (e.compact = e.r + e.yParityAndS.substring(2)), e;
}
function Wf(n) {
  return (n = Sa(n)), K($e([n.r, n.s, n.recoveryParam ? '0x1c' : '0x1b']));
}
const QE = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        arrayify: H,
        concat: $e,
        hexConcat: xn,
        hexDataLength: Jr,
        hexDataSlice: Bt,
        hexStripZeros: T1,
        hexValue: Od,
        hexZeroPad: Be,
        hexlify: K,
        isBytes: Ca,
        isBytesLike: bl,
        isHexString: Ae,
        joinSignature: Wf,
        splitSignature: Sa,
        stripZeros: zr,
        zeroPad: lu,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  A1 = 'bignumber/5.7.0';
var Ou = pe.BN;
const ui = new O(A1),
  Gp = {},
  kg = 9007199254740991;
function YE(n) {
  return n != null && (G.isBigNumber(n) || (typeof n == 'number' && n % 1 === 0) || (typeof n == 'string' && !!n.match(/^-?[0-9]+$/)) || Ae(n) || typeof n == 'bigint' || Ca(n));
}
let Og = !1;
class G {
  constructor(e, t) {
    e !== Gp &&
      ui.throwError('cannot call constructor directly; use BigNumber.from', O.errors.UNSUPPORTED_OPERATION, {
        operation: 'new (BigNumber)',
      }),
      (this._hex = t),
      (this._isBigNumber = !0),
      Object.freeze(this);
  }
  fromTwos(e) {
    return Rn(ge(this).fromTwos(e));
  }
  toTwos(e) {
    return Rn(ge(this).toTwos(e));
  }
  abs() {
    return this._hex[0] === '-' ? G.from(this._hex.substring(1)) : this;
  }
  add(e) {
    return Rn(ge(this).add(ge(e)));
  }
  sub(e) {
    return Rn(ge(this).sub(ge(e)));
  }
  div(e) {
    return G.from(e).isZero() && Zn('division-by-zero', 'div'), Rn(ge(this).div(ge(e)));
  }
  mul(e) {
    return Rn(ge(this).mul(ge(e)));
  }
  mod(e) {
    const t = ge(e);
    return t.isNeg() && Zn('division-by-zero', 'mod'), Rn(ge(this).umod(t));
  }
  pow(e) {
    const t = ge(e);
    return t.isNeg() && Zn('negative-power', 'pow'), Rn(ge(this).pow(t));
  }
  and(e) {
    const t = ge(e);
    return (this.isNegative() || t.isNeg()) && Zn('unbound-bitwise-result', 'and'), Rn(ge(this).and(t));
  }
  or(e) {
    const t = ge(e);
    return (this.isNegative() || t.isNeg()) && Zn('unbound-bitwise-result', 'or'), Rn(ge(this).or(t));
  }
  xor(e) {
    const t = ge(e);
    return (this.isNegative() || t.isNeg()) && Zn('unbound-bitwise-result', 'xor'), Rn(ge(this).xor(t));
  }
  mask(e) {
    return (this.isNegative() || e < 0) && Zn('negative-width', 'mask'), Rn(ge(this).maskn(e));
  }
  shl(e) {
    return (this.isNegative() || e < 0) && Zn('negative-width', 'shl'), Rn(ge(this).shln(e));
  }
  shr(e) {
    return (this.isNegative() || e < 0) && Zn('negative-width', 'shr'), Rn(ge(this).shrn(e));
  }
  eq(e) {
    return ge(this).eq(ge(e));
  }
  lt(e) {
    return ge(this).lt(ge(e));
  }
  lte(e) {
    return ge(this).lte(ge(e));
  }
  gt(e) {
    return ge(this).gt(ge(e));
  }
  gte(e) {
    return ge(this).gte(ge(e));
  }
  isNegative() {
    return this._hex[0] === '-';
  }
  isZero() {
    return ge(this).isZero();
  }
  toNumber() {
    try {
      return ge(this).toNumber();
    } catch {
      Zn('overflow', 'toNumber', this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {}
    return ui.throwError('this platform does not support BigInt', O.errors.UNSUPPORTED_OPERATION, {
      value: this.toString(),
    });
  }
  toString() {
    return (
      arguments.length > 0 &&
        (arguments[0] === 10
          ? Og || ((Og = !0), ui.warn('BigNumber.toString does not accept any parameters; base-10 is assumed'))
          : arguments[0] === 16
          ? ui.throwError('BigNumber.toString does not accept any parameters; use bigNumber.toHexString()', O.errors.UNEXPECTED_ARGUMENT, {})
          : ui.throwError('BigNumber.toString does not accept parameters', O.errors.UNEXPECTED_ARGUMENT, {})),
      ge(this).toString(10)
    );
  }
  toHexString() {
    return this._hex;
  }
  toJSON(e) {
    return { type: 'BigNumber', hex: this.toHexString() };
  }
  static from(e) {
    if (e instanceof G) return e;
    if (typeof e == 'string') return e.match(/^-?0x[0-9a-f]+$/i) ? new G(Gp, Bu(e)) : e.match(/^-?[0-9]+$/) ? new G(Gp, Bu(new Ou(e))) : ui.throwArgumentError('invalid BigNumber string', 'value', e);
    if (typeof e == 'number') return e % 1 && Zn('underflow', 'BigNumber.from', e), (e >= kg || e <= -kg) && Zn('overflow', 'BigNumber.from', e), G.from(String(e));
    const t = e;
    if (typeof t == 'bigint') return G.from(t.toString());
    if (Ca(t)) return G.from(K(t));
    if (t)
      if (t.toHexString) {
        const r = t.toHexString();
        if (typeof r == 'string') return G.from(r);
      } else {
        let r = t._hex;
        if ((r == null && t.type === 'BigNumber' && (r = t.hex), typeof r == 'string' && (Ae(r) || (r[0] === '-' && Ae(r.substring(1)))))) return G.from(r);
      }
    return ui.throwArgumentError('invalid BigNumber value', 'value', e);
  }
  static isBigNumber(e) {
    return !!(e && e._isBigNumber);
  }
}
function Bu(n) {
  if (typeof n != 'string') return Bu(n.toString(16));
  if (n[0] === '-') return (n = n.substring(1)), n[0] === '-' && ui.throwArgumentError('invalid hex', 'value', n), (n = Bu(n)), n === '0x00' ? n : '-' + n;
  if ((n.substring(0, 2) !== '0x' && (n = '0x' + n), n === '0x')) return '0x00';
  for (n.length % 2 && (n = '0x0' + n.substring(2)); n.length > 4 && n.substring(0, 4) === '0x00'; ) n = '0x' + n.substring(4);
  return n;
}
function Rn(n) {
  return G.from(Bu(n));
}
function ge(n) {
  const e = G.from(n).toHexString();
  return e[0] === '-' ? new Ou('-' + e.substring(3), 16) : new Ou(e.substring(2), 16);
}
function Zn(n, e, t) {
  const r = { fault: n, operation: e };
  return t != null && (r.value = t), ui.throwError(n, O.errors.NUMERIC_FAULT, r);
}
function XE(n) {
  return new Ou(n, 36).toString(16);
}
function ZE(n) {
  return new Ou(n, 16).toString(36);
}
const wn = new O(A1),
  cu = {},
  E1 = G.from(0),
  C1 = G.from(-1);
function S1(n, e, t, r) {
  const i = { fault: e, operation: t };
  return r !== void 0 && (i.value = r), wn.throwError(n, O.errors.NUMERIC_FAULT, i);
}
let du = '0';
for (; du.length < 256; ) du += du;
function ky(n) {
  if (typeof n != 'number')
    try {
      n = G.from(n).toNumber();
    } catch {}
  return typeof n == 'number' && n >= 0 && n <= 256 && !(n % 1) ? '1' + du.substring(0, n) : wn.throwArgumentError('invalid decimal size', 'decimals', n);
}
function cc(n, e) {
  e == null && (e = 0);
  const t = ky(e);
  n = G.from(n);
  const r = n.lt(E1);
  r && (n = n.mul(C1));
  let i = n.mod(t).toString();
  for (; i.length < t.length - 1; ) i = '0' + i;
  i = i.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const s = n.div(t).toString();
  return t.length === 1 ? (n = s) : (n = s + '.' + i), r && (n = '-' + n), n;
}
function Or(n, e) {
  e == null && (e = 0);
  const t = ky(e);
  (typeof n != 'string' || !n.match(/^-?[0-9.]+$/)) && wn.throwArgumentError('invalid decimal value', 'value', n);
  const r = n.substring(0, 1) === '-';
  r && (n = n.substring(1)), n === '.' && wn.throwArgumentError('missing value', 'value', n);
  const i = n.split('.');
  i.length > 2 && wn.throwArgumentError('too many decimal points', 'value', n);
  let s = i[0],
    a = i[1];
  for (s || (s = '0'), a || (a = '0'); a[a.length - 1] === '0'; ) a = a.substring(0, a.length - 1);
  for (a.length > t.length - 1 && S1('fractional component exceeds decimals', 'underflow', 'parseFixed'), a === '' && (a = '0'); a.length < t.length - 1; ) a += '0';
  const o = G.from(s),
    u = G.from(a);
  let l = o.mul(t).add(u);
  return r && (l = l.mul(C1)), l;
}
class Xa {
  constructor(e, t, r, i) {
    e !== cu &&
      wn.throwError('cannot use FixedFormat constructor; use FixedFormat.from', O.errors.UNSUPPORTED_OPERATION, {
        operation: 'new FixedFormat',
      }),
      (this.signed = t),
      (this.width = r),
      (this.decimals = i),
      (this.name = (t ? '' : 'u') + 'fixed' + String(r) + 'x' + String(i)),
      (this._multiplier = ky(i)),
      Object.freeze(this);
  }
  static from(e) {
    if (e instanceof Xa) return e;
    typeof e == 'number' && (e = `fixed128x${e}`);
    let t = !0,
      r = 128,
      i = 18;
    if (typeof e == 'string') {
      if (e !== 'fixed')
        if (e === 'ufixed') t = !1;
        else {
          const s = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          s || wn.throwArgumentError('invalid fixed format', 'format', e), (t = s[1] !== 'u'), (r = parseInt(s[2])), (i = parseInt(s[3]));
        }
    } else if (e) {
      const s = (a, o, u) => (e[a] == null ? u : (typeof e[a] !== o && wn.throwArgumentError('invalid fixed format (' + a + ' not ' + o + ')', 'format.' + a, e[a]), e[a]));
      (t = s('signed', 'boolean', t)), (r = s('width', 'number', r)), (i = s('decimals', 'number', i));
    }
    return (
      r % 8 && wn.throwArgumentError('invalid fixed format width (not byte aligned)', 'format.width', r),
      i > 80 && wn.throwArgumentError('invalid fixed format (decimals too large)', 'format.decimals', i),
      new Xa(cu, t, r, i)
    );
  }
}
class Xt {
  constructor(e, t, r, i) {
    e !== cu &&
      wn.throwError('cannot use FixedNumber constructor; use FixedNumber.from', O.errors.UNSUPPORTED_OPERATION, {
        operation: 'new FixedFormat',
      }),
      (this.format = i),
      (this._hex = t),
      (this._value = r),
      (this._isFixedNumber = !0),
      Object.freeze(this);
  }
  _checkFormat(e) {
    this.format.name !== e.format.name && wn.throwArgumentError('incompatible format; use fixedNumber.toFormat', 'other', e);
  }
  addUnsafe(e) {
    this._checkFormat(e);
    const t = Or(this._value, this.format.decimals),
      r = Or(e._value, e.format.decimals);
    return Xt.fromValue(t.add(r), this.format.decimals, this.format);
  }
  subUnsafe(e) {
    this._checkFormat(e);
    const t = Or(this._value, this.format.decimals),
      r = Or(e._value, e.format.decimals);
    return Xt.fromValue(t.sub(r), this.format.decimals, this.format);
  }
  mulUnsafe(e) {
    this._checkFormat(e);
    const t = Or(this._value, this.format.decimals),
      r = Or(e._value, e.format.decimals);
    return Xt.fromValue(t.mul(r).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(e) {
    this._checkFormat(e);
    const t = Or(this._value, this.format.decimals),
      r = Or(e._value, e.format.decimals);
    return Xt.fromValue(t.mul(this.format._multiplier).div(r), this.format.decimals, this.format);
  }
  floor() {
    const e = this.toString().split('.');
    e.length === 1 && e.push('0');
    let t = Xt.from(e[0], this.format);
    const r = !e[1].match(/^(0*)$/);
    return this.isNegative() && r && (t = t.subUnsafe(Bg.toFormat(t.format))), t;
  }
  ceiling() {
    const e = this.toString().split('.');
    e.length === 1 && e.push('0');
    let t = Xt.from(e[0], this.format);
    const r = !e[1].match(/^(0*)$/);
    return !this.isNegative() && r && (t = t.addUnsafe(Bg.toFormat(t.format))), t;
  }
  // @TODO: Support other rounding algorithms
  round(e) {
    e == null && (e = 0);
    const t = this.toString().split('.');
    if ((t.length === 1 && t.push('0'), (e < 0 || e > 80 || e % 1) && wn.throwArgumentError('invalid decimal count', 'decimals', e), t[1].length <= e)) return this;
    const r = Xt.from('1' + du.substring(0, e), this.format),
      i = e7.toFormat(this.format);
    return this.mulUnsafe(r).addUnsafe(i).floor().divUnsafe(r);
  }
  isZero() {
    return this._value === '0.0' || this._value === '0';
  }
  isNegative() {
    return this._value[0] === '-';
  }
  toString() {
    return this._value;
  }
  toHexString(e) {
    if (e == null) return this._hex;
    e % 8 && wn.throwArgumentError('invalid byte width', 'width', e);
    const t = G.from(this._hex).fromTwos(this.format.width).toTwos(e).toHexString();
    return Be(t, e / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(e) {
    return Xt.fromString(this._value, e);
  }
  static fromValue(e, t, r) {
    return r == null && t != null && !YE(t) && ((r = t), (t = null)), t == null && (t = 0), r == null && (r = 'fixed'), Xt.fromString(cc(e, t), Xa.from(r));
  }
  static fromString(e, t) {
    t == null && (t = 'fixed');
    const r = Xa.from(t),
      i = Or(e, r.decimals);
    !r.signed && i.lt(E1) && S1('unsigned value cannot be negative', 'overflow', 'value', e);
    let s = null;
    r.signed ? (s = i.toTwos(r.width).toHexString()) : ((s = i.toHexString()), (s = Be(s, r.width / 8)));
    const a = cc(i, r.decimals);
    return new Xt(cu, s, a, r);
  }
  static fromBytes(e, t) {
    t == null && (t = 'fixed');
    const r = Xa.from(t);
    if (H(e).length > r.width / 8) throw new Error('overflow');
    let i = G.from(e);
    r.signed && (i = i.fromTwos(r.width));
    const s = i.toTwos((r.signed ? 0 : 1) + r.width).toHexString(),
      a = cc(i, r.decimals);
    return new Xt(cu, s, a, r);
  }
  static from(e, t) {
    if (typeof e == 'string') return Xt.fromString(e, t);
    if (Ca(e)) return Xt.fromBytes(e, t);
    try {
      return Xt.fromValue(e, 0, t);
    } catch (r) {
      if (r.code !== O.errors.INVALID_ARGUMENT) throw r;
    }
    return wn.throwArgumentError('invalid FixedNumber value', 'value', e);
  }
  static isFixedNumber(e) {
    return !!(e && e._isFixedNumber);
  }
}
const Bg = Xt.from(1),
  e7 = Xt.from('0.5'),
  t7 = 'properties/5.7.0';
var n7 =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const zc = new O(t7);
function U(n, e, t) {
  Object.defineProperty(n, e, {
    enumerable: !0,
    value: t,
    writable: !1,
  });
}
function Er(n, e) {
  for (let t = 0; t < 32; t++) {
    if (n[e]) return n[e];
    if (!n.prototype || typeof n.prototype != 'object') break;
    n = Object.getPrototypeOf(n.prototype).constructor;
  }
  return null;
}
function Mt(n) {
  return n7(this, void 0, void 0, function* () {
    const e = Object.keys(n).map((r) => {
      const i = n[r];
      return Promise.resolve(i).then((s) => ({ key: r, value: s }));
    });
    return (yield Promise.all(e)).reduce((r, i) => ((r[i.key] = i.value), r), {});
  });
}
function Oy(n, e) {
  (!n || typeof n != 'object') && zc.throwArgumentError('invalid object', 'object', n),
    Object.keys(n).forEach((t) => {
      e[t] || zc.throwArgumentError('invalid object key - ' + t, 'transaction:' + t, n);
    });
}
function $t(n) {
  const e = {};
  for (const t in n) e[t] = n[t];
  return e;
}
const r7 = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function M1(n) {
  if (n == null || r7[typeof n]) return !0;
  if (Array.isArray(n) || typeof n == 'object') {
    if (!Object.isFrozen(n)) return !1;
    const e = Object.keys(n);
    for (let t = 0; t < e.length; t++) {
      let r = null;
      try {
        r = n[e[t]];
      } catch {
        continue;
      }
      if (!M1(r)) return !1;
    }
    return !0;
  }
  return zc.throwArgumentError(`Cannot deepCopy ${typeof n}`, 'object', n);
}
function i7(n) {
  if (M1(n)) return n;
  if (Array.isArray(n)) return Object.freeze(n.map((e) => hs(e)));
  if (typeof n == 'object') {
    const e = {};
    for (const t in n) {
      const r = n[t];
      r !== void 0 && U(e, t, hs(r));
    }
    return e;
  }
  return zc.throwArgumentError(`Cannot deepCopy ${typeof n}`, 'object', n);
}
function hs(n) {
  return i7(n);
}
class xs {
  constructor(e) {
    for (const t in e) this[t] = hs(e[t]);
  }
}
const s7 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        Description: xs,
        checkProperties: Oy,
        deepCopy: hs,
        defineReadOnly: U,
        getStatic: Er,
        resolveProperties: Mt,
        shallowCopy: $t,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  gl = 'abi/5.7.0',
  we = new O(gl),
  aa = {};
let Ng = { calldata: !0, memory: !0, storage: !0 },
  a7 = { calldata: !0, memory: !0 };
function zl(n, e) {
  if (n === 'bytes' || n === 'string') {
    if (Ng[e]) return !0;
  } else if (n === 'address') {
    if (e === 'payable') return !0;
  } else if ((n.indexOf('[') >= 0 || n === 'tuple') && a7[e]) return !0;
  return (Ng[e] || e === 'payable') && we.throwArgumentError('invalid modifier', 'name', e), !1;
}
function o7(n, e) {
  let t = n;
  function r(o) {
    we.throwArgumentError(`unexpected character at position ${o}`, 'param', n);
  }
  n = n.replace(/\s/g, ' ');
  function i(o) {
    let u = { type: '', name: '', parent: o, state: { allowType: !0 } };
    return e && (u.indexed = !1), u;
  }
  let s = { type: '', name: '', state: { allowType: !0 } },
    a = s;
  for (let o = 0; o < n.length; o++) {
    let u = n[o];
    switch (u) {
      case '(':
        a.state.allowType && a.type === '' ? (a.type = 'tuple') : a.state.allowParams || r(o), (a.state.allowType = !1), (a.type = $a(a.type)), (a.components = [i(a)]), (a = a.components[0]);
        break;
      case ')':
        delete a.state, a.name === 'indexed' && (e || r(o), (a.indexed = !0), (a.name = '')), zl(a.type, a.name) && (a.name = ''), (a.type = $a(a.type));
        let l = a;
        (a = a.parent), a || r(o), delete l.parent, (a.state.allowParams = !1), (a.state.allowName = !0), (a.state.allowArray = !0);
        break;
      case ',':
        delete a.state, a.name === 'indexed' && (e || r(o), (a.indexed = !0), (a.name = '')), zl(a.type, a.name) && (a.name = ''), (a.type = $a(a.type));
        let p = i(a.parent);
        a.parent.components.push(p), delete a.parent, (a = p);
        break;
      case ' ':
        a.state.allowType && a.type !== '' && ((a.type = $a(a.type)), delete a.state.allowType, (a.state.allowName = !0), (a.state.allowParams = !0)),
          a.state.allowName &&
            a.name !== '' &&
            (a.name === 'indexed' ? (e || r(o), a.indexed && r(o), (a.indexed = !0), (a.name = '')) : zl(a.type, a.name) ? (a.name = '') : (a.state.allowName = !1));
        break;
      case '[':
        a.state.allowArray || r(o), (a.type += u), (a.state.allowArray = !1), (a.state.allowName = !1), (a.state.readArray = !0);
        break;
      case ']':
        a.state.readArray || r(o), (a.type += u), (a.state.readArray = !1), (a.state.allowArray = !0), (a.state.allowName = !0);
        break;
      default:
        a.state.allowType
          ? ((a.type += u), (a.state.allowParams = !0), (a.state.allowArray = !0))
          : a.state.allowName
          ? ((a.name += u), delete a.state.allowArray)
          : a.state.readArray
          ? (a.type += u)
          : r(o);
    }
  }
  return (
    a.parent && we.throwArgumentError('unexpected eof', 'param', n),
    delete s.state,
    a.name === 'indexed' ? (e || r(t.length - 7), a.indexed && r(t.length - 7), (a.indexed = !0), (a.name = '')) : zl(a.type, a.name) && (a.name = ''),
    (s.type = $a(s.type)),
    s
  );
}
function dc(n, e) {
  for (let t in e) U(n, t, e[t]);
}
const Me = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: 'sighash',
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: 'minimal',
    // Human-Readable with nice spacing, including all names
    full: 'full',
    // JSON-format a la Solidity
    json: 'json',
  }),
  u7 = new RegExp(/^(.*)\[([0-9]*)\]$/);
class zt {
  constructor(e, t) {
    e !== aa &&
      we.throwError('use fromString', O.errors.UNSUPPORTED_OPERATION, {
        operation: 'new ParamType()',
      }),
      dc(this, t);
    let r = this.type.match(u7);
    r
      ? dc(this, {
          arrayLength: parseInt(r[2] || '-1'),
          arrayChildren: zt.fromObject({
            type: r[1],
            components: this.components,
          }),
          baseType: 'array',
        })
      : dc(this, {
          arrayLength: null,
          arrayChildren: null,
          baseType: this.components != null ? 'tuple' : this.type,
        }),
      (this._isParamType = !0),
      Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(e) {
    if ((e || (e = Me.sighash), Me[e] || we.throwArgumentError('invalid format type', 'format', e), e === Me.json)) {
      let r = {
        type: this.baseType === 'tuple' ? 'tuple' : this.type,
        name: this.name || void 0,
      };
      return typeof this.indexed == 'boolean' && (r.indexed = this.indexed), this.components && (r.components = this.components.map((i) => JSON.parse(i.format(e)))), JSON.stringify(r);
    }
    let t = '';
    return (
      this.baseType === 'array'
        ? ((t += this.arrayChildren.format(e)), (t += '[' + (this.arrayLength < 0 ? '' : String(this.arrayLength)) + ']'))
        : this.baseType === 'tuple'
        ? (e !== Me.sighash && (t += this.type), (t += '(' + this.components.map((r) => r.format(e)).join(e === Me.full ? ', ' : ',') + ')'))
        : (t += this.type),
      e !== Me.sighash && (this.indexed === !0 && (t += ' indexed'), e === Me.full && this.name && (t += ' ' + this.name)),
      t
    );
  }
  static from(e, t) {
    return typeof e == 'string' ? zt.fromString(e, t) : zt.fromObject(e);
  }
  static fromObject(e) {
    return zt.isParamType(e)
      ? e
      : new zt(aa, {
          name: e.name || null,
          type: $a(e.type),
          indexed: e.indexed == null ? null : !!e.indexed,
          components: e.components ? e.components.map(zt.fromObject) : null,
        });
  }
  static fromString(e, t) {
    function r(i) {
      return zt.fromObject({
        name: i.name,
        type: i.type,
        indexed: i.indexed,
        components: i.components,
      });
    }
    return r(o7(e, !!t));
  }
  static isParamType(e) {
    return !!(e != null && e._isParamType);
  }
}
function Nu(n, e) {
  return c7(n).map((t) => zt.fromString(t, e));
}
class Ur {
  constructor(e, t) {
    e !== aa &&
      we.throwError('use a static from method', O.errors.UNSUPPORTED_OPERATION, {
        operation: 'new Fragment()',
      }),
      dc(this, t),
      (this._isFragment = !0),
      Object.freeze(this);
  }
  static from(e) {
    return Ur.isFragment(e) ? e : typeof e == 'string' ? Ur.fromString(e) : Ur.fromObject(e);
  }
  static fromObject(e) {
    if (Ur.isFragment(e)) return e;
    switch (e.type) {
      case 'function':
        return wr.fromObject(e);
      case 'event':
        return $r.fromObject(e);
      case 'constructor':
        return xr.fromObject(e);
      case 'error':
        return hi.fromObject(e);
      case 'fallback':
      case 'receive':
        return null;
    }
    return we.throwArgumentError('invalid fragment object', 'value', e);
  }
  static fromString(e) {
    return (
      (e = e.replace(/\s/g, ' ')),
      (e = e.replace(/\(/g, ' (').replace(/\)/g, ') ').replace(/\s+/g, ' ')),
      (e = e.trim()),
      e.split(' ')[0] === 'event'
        ? $r.fromString(e.substring(5).trim())
        : e.split(' ')[0] === 'function'
        ? wr.fromString(e.substring(8).trim())
        : e.split('(')[0].trim() === 'constructor'
        ? xr.fromString(e.trim())
        : e.split(' ')[0] === 'error'
        ? hi.fromString(e.substring(5).trim())
        : we.throwArgumentError('unsupported fragment', 'value', e)
    );
  }
  static isFragment(e) {
    return !!(e && e._isFragment);
  }
}
class $r extends Ur {
  format(e) {
    if ((e || (e = Me.sighash), Me[e] || we.throwArgumentError('invalid format type', 'format', e), e === Me.json))
      return JSON.stringify({
        type: 'event',
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
      });
    let t = '';
    return (
      e !== Me.sighash && (t += 'event '),
      (t += this.name + '(' + this.inputs.map((r) => r.format(e)).join(e === Me.full ? ', ' : ',') + ') '),
      e !== Me.sighash && this.anonymous && (t += 'anonymous '),
      t.trim()
    );
  }
  static from(e) {
    return typeof e == 'string' ? $r.fromString(e) : $r.fromObject(e);
  }
  static fromObject(e) {
    if ($r.isEventFragment(e)) return e;
    e.type !== 'event' && we.throwArgumentError('invalid event object', 'value', e);
    const t = {
      name: Du(e.name),
      anonymous: e.anonymous,
      inputs: e.inputs ? e.inputs.map(zt.fromObject) : [],
      type: 'event',
    };
    return new $r(aa, t);
  }
  static fromString(e) {
    let t = e.match(Fu);
    t || we.throwArgumentError('invalid event string', 'value', e);
    let r = !1;
    return (
      t[3].split(' ').forEach((i) => {
        switch (i.trim()) {
          case 'anonymous':
            r = !0;
            break;
          case '':
            break;
          default:
            we.warn('unknown modifier: ' + i);
        }
      }),
      $r.fromObject({
        name: t[1].trim(),
        anonymous: r,
        inputs: Nu(t[2], !0),
        type: 'event',
      })
    );
  }
  static isEventFragment(e) {
    return e && e._isFragment && e.type === 'event';
  }
}
function _1(n, e) {
  e.gas = null;
  let t = n.split('@');
  return t.length !== 1
    ? (t.length > 2 && we.throwArgumentError('invalid human-readable ABI signature', 'value', n),
      t[1].match(/^[0-9]+$/) || we.throwArgumentError('invalid human-readable ABI signature gas', 'value', n),
      (e.gas = G.from(t[1])),
      t[0])
    : n;
}
function R1(n, e) {
  (e.constant = !1),
    (e.payable = !1),
    (e.stateMutability = 'nonpayable'),
    n.split(' ').forEach((t) => {
      switch (t.trim()) {
        case 'constant':
          e.constant = !0;
          break;
        case 'payable':
          (e.payable = !0), (e.stateMutability = 'payable');
          break;
        case 'nonpayable':
          (e.payable = !1), (e.stateMutability = 'nonpayable');
          break;
        case 'pure':
          (e.constant = !0), (e.stateMutability = 'pure');
          break;
        case 'view':
          (e.constant = !0), (e.stateMutability = 'view');
          break;
        case 'external':
        case 'public':
        case '':
          break;
        default:
          console.log('unknown modifier: ' + t);
      }
    });
}
function P1(n) {
  let e = {
    constant: !1,
    payable: !0,
    stateMutability: 'payable',
  };
  return (
    n.stateMutability != null
      ? ((e.stateMutability = n.stateMutability),
        (e.constant = e.stateMutability === 'view' || e.stateMutability === 'pure'),
        n.constant != null && !!n.constant !== e.constant && we.throwArgumentError('cannot have constant function with mutability ' + e.stateMutability, 'value', n),
        (e.payable = e.stateMutability === 'payable'),
        n.payable != null && !!n.payable !== e.payable && we.throwArgumentError('cannot have payable function with mutability ' + e.stateMutability, 'value', n))
      : n.payable != null
      ? ((e.payable = !!n.payable),
        n.constant == null && !e.payable && n.type !== 'constructor' && we.throwArgumentError('unable to determine stateMutability', 'value', n),
        (e.constant = !!n.constant),
        e.constant ? (e.stateMutability = 'view') : (e.stateMutability = e.payable ? 'payable' : 'nonpayable'),
        e.payable && e.constant && we.throwArgumentError('cannot have constant payable function', 'value', n))
      : n.constant != null
      ? ((e.constant = !!n.constant), (e.payable = !e.constant), (e.stateMutability = e.constant ? 'view' : 'payable'))
      : n.type !== 'constructor' && we.throwArgumentError('unable to determine stateMutability', 'value', n),
    e
  );
}
class xr extends Ur {
  format(e) {
    if ((e || (e = Me.sighash), Me[e] || we.throwArgumentError('invalid format type', 'format', e), e === Me.json))
      return JSON.stringify({
        type: 'constructor',
        stateMutability: this.stateMutability !== 'nonpayable' ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
      });
    e === Me.sighash &&
      we.throwError('cannot format a constructor for sighash', O.errors.UNSUPPORTED_OPERATION, {
        operation: 'format(sighash)',
      });
    let t = 'constructor(' + this.inputs.map((r) => r.format(e)).join(e === Me.full ? ', ' : ',') + ') ';
    return this.stateMutability && this.stateMutability !== 'nonpayable' && (t += this.stateMutability + ' '), t.trim();
  }
  static from(e) {
    return typeof e == 'string' ? xr.fromString(e) : xr.fromObject(e);
  }
  static fromObject(e) {
    if (xr.isConstructorFragment(e)) return e;
    e.type !== 'constructor' && we.throwArgumentError('invalid constructor object', 'value', e);
    let t = P1(e);
    t.constant && we.throwArgumentError('constructor cannot be constant', 'value', e);
    const r = {
      name: null,
      type: e.type,
      inputs: e.inputs ? e.inputs.map(zt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? G.from(e.gas) : null,
    };
    return new xr(aa, r);
  }
  static fromString(e) {
    let t = { type: 'constructor' };
    e = _1(e, t);
    let r = e.match(Fu);
    return (!r || r[1].trim() !== 'constructor') && we.throwArgumentError('invalid constructor string', 'value', e), (t.inputs = Nu(r[2].trim(), !1)), R1(r[3].trim(), t), xr.fromObject(t);
  }
  static isConstructorFragment(e) {
    return e && e._isFragment && e.type === 'constructor';
  }
}
class wr extends xr {
  format(e) {
    if ((e || (e = Me.sighash), Me[e] || we.throwArgumentError('invalid format type', 'format', e), e === Me.json))
      return JSON.stringify({
        type: 'function',
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== 'nonpayable' ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        outputs: this.outputs.map((r) => JSON.parse(r.format(e))),
      });
    let t = '';
    return (
      e !== Me.sighash && (t += 'function '),
      (t += this.name + '(' + this.inputs.map((r) => r.format(e)).join(e === Me.full ? ', ' : ',') + ') '),
      e !== Me.sighash &&
        (this.stateMutability ? this.stateMutability !== 'nonpayable' && (t += this.stateMutability + ' ') : this.constant && (t += 'view '),
        this.outputs && this.outputs.length && (t += 'returns (' + this.outputs.map((r) => r.format(e)).join(', ') + ') '),
        this.gas != null && (t += '@' + this.gas.toString() + ' ')),
      t.trim()
    );
  }
  static from(e) {
    return typeof e == 'string' ? wr.fromString(e) : wr.fromObject(e);
  }
  static fromObject(e) {
    if (wr.isFunctionFragment(e)) return e;
    e.type !== 'function' && we.throwArgumentError('invalid function object', 'value', e);
    let t = P1(e);
    const r = {
      type: e.type,
      name: Du(e.name),
      constant: t.constant,
      inputs: e.inputs ? e.inputs.map(zt.fromObject) : [],
      outputs: e.outputs ? e.outputs.map(zt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? G.from(e.gas) : null,
    };
    return new wr(aa, r);
  }
  static fromString(e) {
    let t = { type: 'function' };
    e = _1(e, t);
    let r = e.split(' returns ');
    r.length > 2 && we.throwArgumentError('invalid function string', 'value', e);
    let i = r[0].match(Fu);
    if ((i || we.throwArgumentError('invalid function signature', 'value', e), (t.name = i[1].trim()), t.name && Du(t.name), (t.inputs = Nu(i[2], !1)), R1(i[3].trim(), t), r.length > 1)) {
      let s = r[1].match(Fu);
      (s[1].trim() != '' || s[3].trim() != '') && we.throwArgumentError('unexpected tokens', 'value', e), (t.outputs = Nu(s[2], !1));
    } else t.outputs = [];
    return wr.fromObject(t);
  }
  static isFunctionFragment(e) {
    return e && e._isFragment && e.type === 'function';
  }
}
function Dg(n) {
  const e = n.format();
  return (e === 'Error(string)' || e === 'Panic(uint256)') && we.throwArgumentError(`cannot specify user defined ${e} error`, 'fragment', n), n;
}
class hi extends Ur {
  format(e) {
    if ((e || (e = Me.sighash), Me[e] || we.throwArgumentError('invalid format type', 'format', e), e === Me.json))
      return JSON.stringify({
        type: 'error',
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
      });
    let t = '';
    return e !== Me.sighash && (t += 'error '), (t += this.name + '(' + this.inputs.map((r) => r.format(e)).join(e === Me.full ? ', ' : ',') + ') '), t.trim();
  }
  static from(e) {
    return typeof e == 'string' ? hi.fromString(e) : hi.fromObject(e);
  }
  static fromObject(e) {
    if (hi.isErrorFragment(e)) return e;
    e.type !== 'error' && we.throwArgumentError('invalid error object', 'value', e);
    const t = {
      type: e.type,
      name: Du(e.name),
      inputs: e.inputs ? e.inputs.map(zt.fromObject) : [],
    };
    return Dg(new hi(aa, t));
  }
  static fromString(e) {
    let t = { type: 'error' },
      r = e.match(Fu);
    return r || we.throwArgumentError('invalid error signature', 'value', e), (t.name = r[1].trim()), t.name && Du(t.name), (t.inputs = Nu(r[2], !1)), Dg(hi.fromObject(t));
  }
  static isErrorFragment(e) {
    return e && e._isFragment && e.type === 'error';
  }
}
function $a(n) {
  return n.match(/^uint($|[^1-9])/) ? (n = 'uint256' + n.substring(4)) : n.match(/^int($|[^1-9])/) && (n = 'int256' + n.substring(3)), n;
}
const l7 = new RegExp('^[a-zA-Z$_][a-zA-Z0-9$_]*$');
function Du(n) {
  return (!n || !n.match(l7)) && we.throwArgumentError(`invalid identifier "${n}"`, 'value', n), n;
}
const Fu = new RegExp('^([^)(]*)\\((.*)\\)([^)(]*)$');
function c7(n) {
  n = n.trim();
  let e = [],
    t = '',
    r = 0;
  for (let i = 0; i < n.length; i++) {
    let s = n[i];
    s === ',' && r === 0 ? (e.push(t), (t = '')) : ((t += s), s === '(' ? r++ : s === ')' && (r--, r === -1 && we.throwArgumentError('unbalanced parenthesis', 'value', n)));
  }
  return t && e.push(t), e;
}
const By = new O(gl);
function I1(n) {
  const e = [],
    t = function (r, i) {
      if (Array.isArray(i))
        for (let s in i) {
          const a = r.slice();
          a.push(s);
          try {
            t(a, i[s]);
          } catch (o) {
            e.push({ path: a, error: o });
          }
        }
    };
  return t([], n), e;
}
class ji {
  constructor(e, t, r, i) {
    (this.name = e), (this.type = t), (this.localName = r), (this.dynamic = i);
  }
  _throwError(e, t) {
    By.throwArgumentError(e, this.localName, t);
  }
}
class Jf {
  constructor(e) {
    U(this, 'wordSize', e || 32), (this._data = []), (this._dataLength = 0), (this._padding = new Uint8Array(e));
  }
  get data() {
    return xn(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(e) {
    return this._data.push(e), (this._dataLength += e.length), e.length;
  }
  appendWriter(e) {
    return this._writeData($e(e._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(e) {
    let t = H(e);
    const r = t.length % this.wordSize;
    return r && (t = $e([t, this._padding.slice(r)])), this._writeData(t);
  }
  _getValue(e) {
    let t = H(G.from(e));
    return (
      t.length > this.wordSize &&
        By.throwError('value out-of-bounds', O.errors.BUFFER_OVERRUN, {
          length: this.wordSize,
          offset: t.length,
        }),
      t.length % this.wordSize && (t = $e([this._padding.slice(t.length % this.wordSize), t])),
      t
    );
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(e) {
    return this._writeData(this._getValue(e));
  }
  writeUpdatableValue() {
    const e = this._data.length;
    return (
      this._data.push(this._padding),
      (this._dataLength += this.wordSize),
      (t) => {
        this._data[e] = this._getValue(t);
      }
    );
  }
}
class Gc {
  constructor(e, t, r, i) {
    U(this, '_data', H(e)), U(this, 'wordSize', t || 32), U(this, '_coerceFunc', r), U(this, 'allowLoose', i), (this._offset = 0);
  }
  get data() {
    return K(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(e, t) {
    let r = e.match('^u?int([0-9]+)$');
    return r && parseInt(r[1]) <= 48 && (t = t.toNumber()), t;
  }
  coerce(e, t) {
    return this._coerceFunc ? this._coerceFunc(e, t) : Gc.coerce(e, t);
  }
  _peekBytes(e, t, r) {
    let i = Math.ceil(t / this.wordSize) * this.wordSize;
    return (
      this._offset + i > this._data.length &&
        (this.allowLoose && r && this._offset + t <= this._data.length
          ? (i = t)
          : By.throwError('data out-of-bounds', O.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + i,
            })),
      this._data.slice(this._offset, this._offset + i)
    );
  }
  subReader(e) {
    return new Gc(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(e, t) {
    let r = this._peekBytes(0, e, !!t);
    return (this._offset += r.length), r.slice(0, e);
  }
  readValue() {
    return G.from(this.readBytes(this.wordSize));
  }
}
const oa = typeof global < 'u' ? global : typeof self < 'u' ? self : typeof window < 'u' ? window : {};
function k1() {
  throw new Error('setTimeout has not been defined');
}
function O1() {
  throw new Error('clearTimeout has not been defined');
}
var Yi = k1,
  Xi = O1;
typeof oa.setTimeout == 'function' && (Yi = setTimeout);
typeof oa.clearTimeout == 'function' && (Xi = clearTimeout);
function B1(n) {
  if (Yi === setTimeout) return setTimeout(n, 0);
  if ((Yi === k1 || !Yi) && setTimeout) return (Yi = setTimeout), setTimeout(n, 0);
  try {
    return Yi(n, 0);
  } catch {
    try {
      return Yi.call(null, n, 0);
    } catch {
      return Yi.call(this, n, 0);
    }
  }
}
function d7(n) {
  if (Xi === clearTimeout) return clearTimeout(n);
  if ((Xi === O1 || !Xi) && clearTimeout) return (Xi = clearTimeout), clearTimeout(n);
  try {
    return Xi(n);
  } catch {
    try {
      return Xi.call(null, n);
    } catch {
      return Xi.call(this, n);
    }
  }
}
var mi = [],
  Za = !1,
  Js,
  pc = -1;
function p7() {
  !Za || !Js || ((Za = !1), Js.length ? (mi = Js.concat(mi)) : (pc = -1), mi.length && N1());
}
function N1() {
  if (!Za) {
    var n = B1(p7);
    Za = !0;
    for (var e = mi.length; e; ) {
      for (Js = mi, mi = []; ++pc < e; ) Js && Js[pc].run();
      (pc = -1), (e = mi.length);
    }
    (Js = null), (Za = !1), d7(n);
  }
}
function f7(n) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  mi.push(new D1(n, e)), mi.length === 1 && !Za && B1(N1);
}
function D1(n, e) {
  (this.fun = n), (this.array = e);
}
D1.prototype.run = function () {
  this.fun.apply(null, this.array);
};
var h7 = 'browser',
  y7 = 'browser',
  m7 = !0,
  b7 = {},
  g7 = [],
  v7 = '',
  x7 = {},
  w7 = {},
  T7 = {};
function Ma() {}
var A7 = Ma,
  E7 = Ma,
  C7 = Ma,
  S7 = Ma,
  M7 = Ma,
  _7 = Ma,
  R7 = Ma;
function P7(n) {
  throw new Error('process.binding is not supported');
}
function I7() {
  return '/';
}
function k7(n) {
  throw new Error('process.chdir is not supported');
}
function O7() {
  return 0;
}
var Ua = oa.performance || {},
  B7 =
    Ua.now ||
    Ua.mozNow ||
    Ua.msNow ||
    Ua.oNow ||
    Ua.webkitNow ||
    function () {
      return /* @__PURE__ */ new Date().getTime();
    };
function N7(n) {
  var e = B7.call(Ua) * 1e-3,
    t = Math.floor(e),
    r = Math.floor((e % 1) * 1e9);
  return n && ((t = t - n[0]), (r = r - n[1]), r < 0 && (t--, (r += 1e9))), [t, r];
}
var D7 = /* @__PURE__ */ new Date();
function F7() {
  var n = /* @__PURE__ */ new Date(),
    e = n - D7;
  return e / 1e3;
}
var fc = {
    nextTick: f7,
    title: h7,
    browser: m7,
    env: b7,
    argv: g7,
    version: v7,
    versions: x7,
    on: A7,
    addListener: E7,
    once: C7,
    off: S7,
    removeListener: M7,
    removeAllListeners: _7,
    emit: R7,
    binding: P7,
    cwd: I7,
    chdir: k7,
    umask: O7,
    hrtime: N7,
    platform: y7,
    release: w7,
    config: T7,
    uptime: F7,
  },
  Qf = {},
  L7 = {
    get exports() {
      return Qf;
    },
    set exports(n) {
      Qf = n;
    },
  };
(function (n) {
  (function () {
    var e = 'input is invalid type',
      t = 'finalize already called',
      r = typeof window == 'object',
      i = r ? window : {};
    i.JS_SHA3_NO_WINDOW && (r = !1);
    var s = !r && typeof self == 'object',
      a = !i.JS_SHA3_NO_NODE_JS && typeof fc == 'object' && fc.versions && fc.versions.node;
    a ? (i = es) : s && (i = self);
    var o = !i.JS_SHA3_NO_COMMON_JS && !0 && n.exports,
      u = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < 'u',
      l = '0123456789abcdef'.split(''),
      p = [31, 7936, 2031616, 520093696],
      h = [4, 1024, 262144, 67108864],
      b = [1, 256, 65536, 16777216],
      E = [6, 1536, 393216, 100663296],
      x = [0, 8, 16, 24],
      T = [
        1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139,
        2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424,
        2147483648,
      ],
      w = [224, 256, 384, 512],
      _ = [128, 256],
      k = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'],
      D = {
        128: 168,
        256: 136,
      };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) &&
      (Array.isArray = function (f) {
        return Object.prototype.toString.call(f) === '[object Array]';
      }),
      u &&
        (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) &&
        (ArrayBuffer.isView = function (f) {
          return typeof f == 'object' && f.buffer && f.buffer.constructor === ArrayBuffer;
        });
    for (
      var N = function (f, R, L) {
          return function (F) {
            return new d(f, R, f).update(F)[L]();
          };
        },
        B = function (f, R, L) {
          return function (F, $) {
            return new d(f, R, $).update(F)[L]();
          };
        },
        j = function (f, R, L) {
          return function (F, $, ee, W) {
            return c['cshake' + f].update(F, $, ee, W)[L]();
          };
        },
        q = function (f, R, L) {
          return function (F, $, ee, W) {
            return c['kmac' + f].update(F, $, ee, W)[L]();
          };
        },
        z = function (f, R, L, F) {
          for (var $ = 0; $ < k.length; ++$) {
            var ee = k[$];
            f[ee] = R(L, F, ee);
          }
          return f;
        },
        Y = function (f, R) {
          var L = N(f, R, 'hex');
          return (
            (L.create = function () {
              return new d(f, R, f);
            }),
            (L.update = function (F) {
              return L.create().update(F);
            }),
            z(L, N, f, R)
          );
        },
        ae = function (f, R) {
          var L = B(f, R, 'hex');
          return (
            (L.create = function (F) {
              return new d(f, R, F);
            }),
            (L.update = function (F, $) {
              return L.create($).update(F);
            }),
            z(L, B, f, R)
          );
        },
        J = function (f, R) {
          var L = D[f],
            F = j(f, R, 'hex');
          return (
            (F.create = function ($, ee, W) {
              return !ee && !W ? c['shake' + f].create($) : new d(f, R, $).bytepad([ee, W], L);
            }),
            (F.update = function ($, ee, W, Q) {
              return F.create(ee, W, Q).update($);
            }),
            z(F, j, f, R)
          );
        },
        oe = function (f, R) {
          var L = D[f],
            F = q(f, R, 'hex');
          return (
            (F.create = function ($, ee, W) {
              return new g(f, R, ee).bytepad(['KMAC', W], L).bytepad([$], L);
            }),
            (F.update = function ($, ee, W, Q) {
              return F.create($, W, Q).update(ee);
            }),
            z(F, q, f, R)
          );
        },
        S = [
          { name: 'keccak', padding: b, bits: w, createMethod: Y },
          { name: 'sha3', padding: E, bits: w, createMethod: Y },
          { name: 'shake', padding: p, bits: _, createMethod: ae },
          { name: 'cshake', padding: h, bits: _, createMethod: J },
          { name: 'kmac', padding: h, bits: _, createMethod: oe },
        ],
        c = {},
        y = [],
        v = 0;
      v < S.length;
      ++v
    )
      for (var C = S[v], A = C.bits, M = 0; M < A.length; ++M) {
        var P = C.name + '_' + A[M];
        if ((y.push(P), (c[P] = C.createMethod(A[M], C.padding)), C.name !== 'sha3')) {
          var m = C.name + A[M];
          y.push(m), (c[m] = c[P]);
        }
      }
    function d(f, R, L) {
      (this.blocks = []),
        (this.s = []),
        (this.padding = R),
        (this.outputBits = L),
        (this.reset = !0),
        (this.finalized = !1),
        (this.block = 0),
        (this.start = 0),
        (this.blockCount = (1600 - (f << 1)) >> 5),
        (this.byteCount = this.blockCount << 2),
        (this.outputBlocks = L >> 5),
        (this.extraBytes = (L & 31) >> 3);
      for (var F = 0; F < 50; ++F) this.s[F] = 0;
    }
    (d.prototype.update = function (f) {
      if (this.finalized) throw new Error(t);
      var R,
        L = typeof f;
      if (L !== 'string') {
        if (L === 'object') {
          if (f === null) throw new Error(e);
          if (u && f.constructor === ArrayBuffer) f = new Uint8Array(f);
          else if (!Array.isArray(f) && (!u || !ArrayBuffer.isView(f))) throw new Error(e);
        } else throw new Error(e);
        R = !0;
      }
      for (var F = this.blocks, $ = this.byteCount, ee = f.length, W = this.blockCount, Q = 0, wt = this.s, te, de; Q < ee; ) {
        if (this.reset) for (this.reset = !1, F[0] = this.block, te = 1; te < W + 1; ++te) F[te] = 0;
        if (R) for (te = this.start; Q < ee && te < $; ++Q) F[te >> 2] |= f[Q] << x[te++ & 3];
        else
          for (te = this.start; Q < ee && te < $; ++Q)
            (de = f.charCodeAt(Q)),
              de < 128
                ? (F[te >> 2] |= de << x[te++ & 3])
                : de < 2048
                ? ((F[te >> 2] |= (192 | (de >> 6)) << x[te++ & 3]), (F[te >> 2] |= (128 | (de & 63)) << x[te++ & 3]))
                : de < 55296 || de >= 57344
                ? ((F[te >> 2] |= (224 | (de >> 12)) << x[te++ & 3]), (F[te >> 2] |= (128 | ((de >> 6) & 63)) << x[te++ & 3]), (F[te >> 2] |= (128 | (de & 63)) << x[te++ & 3]))
                : ((de = 65536 + (((de & 1023) << 10) | (f.charCodeAt(++Q) & 1023))),
                  (F[te >> 2] |= (240 | (de >> 18)) << x[te++ & 3]),
                  (F[te >> 2] |= (128 | ((de >> 12) & 63)) << x[te++ & 3]),
                  (F[te >> 2] |= (128 | ((de >> 6) & 63)) << x[te++ & 3]),
                  (F[te >> 2] |= (128 | (de & 63)) << x[te++ & 3]));
        if (((this.lastByteIndex = te), te >= $)) {
          for (this.start = te - $, this.block = F[W], te = 0; te < W; ++te) wt[te] ^= F[te];
          I(wt), (this.reset = !0);
        } else this.start = te;
      }
      return this;
    }),
      (d.prototype.encode = function (f, R) {
        var L = f & 255,
          F = 1,
          $ = [L];
        for (f = f >> 8, L = f & 255; L > 0; ) $.unshift(L), (f = f >> 8), (L = f & 255), ++F;
        return R ? $.push(F) : $.unshift(F), this.update($), $.length;
      }),
      (d.prototype.encodeString = function (f) {
        var R,
          L = typeof f;
        if (L !== 'string') {
          if (L === 'object') {
            if (f === null) throw new Error(e);
            if (u && f.constructor === ArrayBuffer) f = new Uint8Array(f);
            else if (!Array.isArray(f) && (!u || !ArrayBuffer.isView(f))) throw new Error(e);
          } else throw new Error(e);
          R = !0;
        }
        var F = 0,
          $ = f.length;
        if (R) F = $;
        else
          for (var ee = 0; ee < f.length; ++ee) {
            var W = f.charCodeAt(ee);
            W < 128 ? (F += 1) : W < 2048 ? (F += 2) : W < 55296 || W >= 57344 ? (F += 3) : ((W = 65536 + (((W & 1023) << 10) | (f.charCodeAt(++ee) & 1023))), (F += 4));
          }
        return (F += this.encode(F * 8)), this.update(f), F;
      }),
      (d.prototype.bytepad = function (f, R) {
        for (var L = this.encode(R), F = 0; F < f.length; ++F) L += this.encodeString(f[F]);
        var $ = R - (L % R),
          ee = [];
        return (ee.length = $), this.update(ee), this;
      }),
      (d.prototype.finalize = function () {
        if (!this.finalized) {
          this.finalized = !0;
          var f = this.blocks,
            R = this.lastByteIndex,
            L = this.blockCount,
            F = this.s;
          if (((f[R >> 2] |= this.padding[R & 3]), this.lastByteIndex === this.byteCount)) for (f[0] = f[L], R = 1; R < L + 1; ++R) f[R] = 0;
          for (f[L - 1] |= 2147483648, R = 0; R < L; ++R) F[R] ^= f[R];
          I(F);
        }
      }),
      (d.prototype.toString = d.prototype.hex =
        function () {
          this.finalize();
          for (var f = this.blockCount, R = this.s, L = this.outputBlocks, F = this.extraBytes, $ = 0, ee = 0, W = '', Q; ee < L; ) {
            for ($ = 0; $ < f && ee < L; ++$, ++ee)
              (Q = R[$]), (W += l[(Q >> 4) & 15] + l[Q & 15] + l[(Q >> 12) & 15] + l[(Q >> 8) & 15] + l[(Q >> 20) & 15] + l[(Q >> 16) & 15] + l[(Q >> 28) & 15] + l[(Q >> 24) & 15]);
            ee % f === 0 && (I(R), ($ = 0));
          }
          return F && ((Q = R[$]), (W += l[(Q >> 4) & 15] + l[Q & 15]), F > 1 && (W += l[(Q >> 12) & 15] + l[(Q >> 8) & 15]), F > 2 && (W += l[(Q >> 20) & 15] + l[(Q >> 16) & 15])), W;
        }),
      (d.prototype.arrayBuffer = function () {
        this.finalize();
        var f = this.blockCount,
          R = this.s,
          L = this.outputBlocks,
          F = this.extraBytes,
          $ = 0,
          ee = 0,
          W = this.outputBits >> 3,
          Q;
        F ? (Q = new ArrayBuffer((L + 1) << 2)) : (Q = new ArrayBuffer(W));
        for (var wt = new Uint32Array(Q); ee < L; ) {
          for ($ = 0; $ < f && ee < L; ++$, ++ee) wt[ee] = R[$];
          ee % f === 0 && I(R);
        }
        return F && ((wt[$] = R[$]), (Q = Q.slice(0, W))), Q;
      }),
      (d.prototype.buffer = d.prototype.arrayBuffer),
      (d.prototype.digest = d.prototype.array =
        function () {
          this.finalize();
          for (var f = this.blockCount, R = this.s, L = this.outputBlocks, F = this.extraBytes, $ = 0, ee = 0, W = [], Q, wt; ee < L; ) {
            for ($ = 0; $ < f && ee < L; ++$, ++ee) (Q = ee << 2), (wt = R[$]), (W[Q] = wt & 255), (W[Q + 1] = (wt >> 8) & 255), (W[Q + 2] = (wt >> 16) & 255), (W[Q + 3] = (wt >> 24) & 255);
            ee % f === 0 && I(R);
          }
          return F && ((Q = ee << 2), (wt = R[$]), (W[Q] = wt & 255), F > 1 && (W[Q + 1] = (wt >> 8) & 255), F > 2 && (W[Q + 2] = (wt >> 16) & 255)), W;
        });
    function g(f, R, L) {
      d.call(this, f, R, L);
    }
    (g.prototype = new d()),
      (g.prototype.finalize = function () {
        return this.encode(this.outputBits, !0), d.prototype.finalize.call(this);
      });
    var I = function (f) {
      var R,
        L,
        F,
        $,
        ee,
        W,
        Q,
        wt,
        te,
        de,
        Es,
        Ue,
        je,
        Cs,
        Ve,
        ze,
        Ss,
        Ge,
        He,
        Ms,
        Ke,
        qe,
        _s,
        We,
        Je,
        Rs,
        Qe,
        Ye,
        Ps,
        Xe,
        Ze,
        Is,
        et,
        tt,
        ks,
        nt,
        rt,
        Os,
        it,
        st,
        Bs,
        at,
        ot,
        Ns,
        ut,
        lt,
        Ds,
        ct,
        dt,
        Fs,
        pt,
        ft,
        Ls,
        ht,
        yt,
        $s,
        mt,
        bt,
        Vi,
        zi,
        Gi,
        Hi,
        Ki;
      for (F = 0; F < 48; F += 2)
        ($ = f[0] ^ f[10] ^ f[20] ^ f[30] ^ f[40]),
          (ee = f[1] ^ f[11] ^ f[21] ^ f[31] ^ f[41]),
          (W = f[2] ^ f[12] ^ f[22] ^ f[32] ^ f[42]),
          (Q = f[3] ^ f[13] ^ f[23] ^ f[33] ^ f[43]),
          (wt = f[4] ^ f[14] ^ f[24] ^ f[34] ^ f[44]),
          (te = f[5] ^ f[15] ^ f[25] ^ f[35] ^ f[45]),
          (de = f[6] ^ f[16] ^ f[26] ^ f[36] ^ f[46]),
          (Es = f[7] ^ f[17] ^ f[27] ^ f[37] ^ f[47]),
          (Ue = f[8] ^ f[18] ^ f[28] ^ f[38] ^ f[48]),
          (je = f[9] ^ f[19] ^ f[29] ^ f[39] ^ f[49]),
          (R = Ue ^ ((W << 1) | (Q >>> 31))),
          (L = je ^ ((Q << 1) | (W >>> 31))),
          (f[0] ^= R),
          (f[1] ^= L),
          (f[10] ^= R),
          (f[11] ^= L),
          (f[20] ^= R),
          (f[21] ^= L),
          (f[30] ^= R),
          (f[31] ^= L),
          (f[40] ^= R),
          (f[41] ^= L),
          (R = $ ^ ((wt << 1) | (te >>> 31))),
          (L = ee ^ ((te << 1) | (wt >>> 31))),
          (f[2] ^= R),
          (f[3] ^= L),
          (f[12] ^= R),
          (f[13] ^= L),
          (f[22] ^= R),
          (f[23] ^= L),
          (f[32] ^= R),
          (f[33] ^= L),
          (f[42] ^= R),
          (f[43] ^= L),
          (R = W ^ ((de << 1) | (Es >>> 31))),
          (L = Q ^ ((Es << 1) | (de >>> 31))),
          (f[4] ^= R),
          (f[5] ^= L),
          (f[14] ^= R),
          (f[15] ^= L),
          (f[24] ^= R),
          (f[25] ^= L),
          (f[34] ^= R),
          (f[35] ^= L),
          (f[44] ^= R),
          (f[45] ^= L),
          (R = wt ^ ((Ue << 1) | (je >>> 31))),
          (L = te ^ ((je << 1) | (Ue >>> 31))),
          (f[6] ^= R),
          (f[7] ^= L),
          (f[16] ^= R),
          (f[17] ^= L),
          (f[26] ^= R),
          (f[27] ^= L),
          (f[36] ^= R),
          (f[37] ^= L),
          (f[46] ^= R),
          (f[47] ^= L),
          (R = de ^ (($ << 1) | (ee >>> 31))),
          (L = Es ^ ((ee << 1) | ($ >>> 31))),
          (f[8] ^= R),
          (f[9] ^= L),
          (f[18] ^= R),
          (f[19] ^= L),
          (f[28] ^= R),
          (f[29] ^= L),
          (f[38] ^= R),
          (f[39] ^= L),
          (f[48] ^= R),
          (f[49] ^= L),
          (Cs = f[0]),
          (Ve = f[1]),
          (lt = (f[11] << 4) | (f[10] >>> 28)),
          (Ds = (f[10] << 4) | (f[11] >>> 28)),
          (Ye = (f[20] << 3) | (f[21] >>> 29)),
          (Ps = (f[21] << 3) | (f[20] >>> 29)),
          (zi = (f[31] << 9) | (f[30] >>> 23)),
          (Gi = (f[30] << 9) | (f[31] >>> 23)),
          (at = (f[40] << 18) | (f[41] >>> 14)),
          (ot = (f[41] << 18) | (f[40] >>> 14)),
          (tt = (f[2] << 1) | (f[3] >>> 31)),
          (ks = (f[3] << 1) | (f[2] >>> 31)),
          (ze = (f[13] << 12) | (f[12] >>> 20)),
          (Ss = (f[12] << 12) | (f[13] >>> 20)),
          (ct = (f[22] << 10) | (f[23] >>> 22)),
          (dt = (f[23] << 10) | (f[22] >>> 22)),
          (Xe = (f[33] << 13) | (f[32] >>> 19)),
          (Ze = (f[32] << 13) | (f[33] >>> 19)),
          (Hi = (f[42] << 2) | (f[43] >>> 30)),
          (Ki = (f[43] << 2) | (f[42] >>> 30)),
          (ht = (f[5] << 30) | (f[4] >>> 2)),
          (yt = (f[4] << 30) | (f[5] >>> 2)),
          (nt = (f[14] << 6) | (f[15] >>> 26)),
          (rt = (f[15] << 6) | (f[14] >>> 26)),
          (Ge = (f[25] << 11) | (f[24] >>> 21)),
          (He = (f[24] << 11) | (f[25] >>> 21)),
          (Fs = (f[34] << 15) | (f[35] >>> 17)),
          (pt = (f[35] << 15) | (f[34] >>> 17)),
          (Is = (f[45] << 29) | (f[44] >>> 3)),
          (et = (f[44] << 29) | (f[45] >>> 3)),
          (We = (f[6] << 28) | (f[7] >>> 4)),
          (Je = (f[7] << 28) | (f[6] >>> 4)),
          ($s = (f[17] << 23) | (f[16] >>> 9)),
          (mt = (f[16] << 23) | (f[17] >>> 9)),
          (Os = (f[26] << 25) | (f[27] >>> 7)),
          (it = (f[27] << 25) | (f[26] >>> 7)),
          (Ms = (f[36] << 21) | (f[37] >>> 11)),
          (Ke = (f[37] << 21) | (f[36] >>> 11)),
          (ft = (f[47] << 24) | (f[46] >>> 8)),
          (Ls = (f[46] << 24) | (f[47] >>> 8)),
          (Ns = (f[8] << 27) | (f[9] >>> 5)),
          (ut = (f[9] << 27) | (f[8] >>> 5)),
          (Rs = (f[18] << 20) | (f[19] >>> 12)),
          (Qe = (f[19] << 20) | (f[18] >>> 12)),
          (bt = (f[29] << 7) | (f[28] >>> 25)),
          (Vi = (f[28] << 7) | (f[29] >>> 25)),
          (st = (f[38] << 8) | (f[39] >>> 24)),
          (Bs = (f[39] << 8) | (f[38] >>> 24)),
          (qe = (f[48] << 14) | (f[49] >>> 18)),
          (_s = (f[49] << 14) | (f[48] >>> 18)),
          (f[0] = Cs ^ (~ze & Ge)),
          (f[1] = Ve ^ (~Ss & He)),
          (f[10] = We ^ (~Rs & Ye)),
          (f[11] = Je ^ (~Qe & Ps)),
          (f[20] = tt ^ (~nt & Os)),
          (f[21] = ks ^ (~rt & it)),
          (f[30] = Ns ^ (~lt & ct)),
          (f[31] = ut ^ (~Ds & dt)),
          (f[40] = ht ^ (~$s & bt)),
          (f[41] = yt ^ (~mt & Vi)),
          (f[2] = ze ^ (~Ge & Ms)),
          (f[3] = Ss ^ (~He & Ke)),
          (f[12] = Rs ^ (~Ye & Xe)),
          (f[13] = Qe ^ (~Ps & Ze)),
          (f[22] = nt ^ (~Os & st)),
          (f[23] = rt ^ (~it & Bs)),
          (f[32] = lt ^ (~ct & Fs)),
          (f[33] = Ds ^ (~dt & pt)),
          (f[42] = $s ^ (~bt & zi)),
          (f[43] = mt ^ (~Vi & Gi)),
          (f[4] = Ge ^ (~Ms & qe)),
          (f[5] = He ^ (~Ke & _s)),
          (f[14] = Ye ^ (~Xe & Is)),
          (f[15] = Ps ^ (~Ze & et)),
          (f[24] = Os ^ (~st & at)),
          (f[25] = it ^ (~Bs & ot)),
          (f[34] = ct ^ (~Fs & ft)),
          (f[35] = dt ^ (~pt & Ls)),
          (f[44] = bt ^ (~zi & Hi)),
          (f[45] = Vi ^ (~Gi & Ki)),
          (f[6] = Ms ^ (~qe & Cs)),
          (f[7] = Ke ^ (~_s & Ve)),
          (f[16] = Xe ^ (~Is & We)),
          (f[17] = Ze ^ (~et & Je)),
          (f[26] = st ^ (~at & tt)),
          (f[27] = Bs ^ (~ot & ks)),
          (f[36] = Fs ^ (~ft & Ns)),
          (f[37] = pt ^ (~Ls & ut)),
          (f[46] = zi ^ (~Hi & ht)),
          (f[47] = Gi ^ (~Ki & yt)),
          (f[8] = qe ^ (~Cs & ze)),
          (f[9] = _s ^ (~Ve & Ss)),
          (f[18] = Is ^ (~We & Rs)),
          (f[19] = et ^ (~Je & Qe)),
          (f[28] = at ^ (~tt & nt)),
          (f[29] = ot ^ (~ks & rt)),
          (f[38] = ft ^ (~Ns & lt)),
          (f[39] = Ls ^ (~ut & Ds)),
          (f[48] = Hi ^ (~ht & $s)),
          (f[49] = Ki ^ (~yt & mt)),
          (f[0] ^= T[F]),
          (f[1] ^= T[F + 1]);
    };
    if (o) n.exports = c;
    else for (v = 0; v < y.length; ++v) i[y[v]] = c[y[v]];
  })();
})(L7);
const $7 = Qf;
function Ie(n) {
  return '0x' + $7.keccak_256(H(n));
}
const U7 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        keccak256: Ie,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  j7 = 'rlp/5.7.0',
  Nr = new O(j7);
function Fg(n) {
  const e = [];
  for (; n; ) e.unshift(n & 255), (n >>= 8);
  return e;
}
function Lg(n, e, t) {
  let r = 0;
  for (let i = 0; i < t; i++) r = r * 256 + n[e + i];
  return r;
}
function F1(n) {
  if (Array.isArray(n)) {
    let r = [];
    if (
      (n.forEach(function (s) {
        r = r.concat(F1(s));
      }),
      r.length <= 55)
    )
      return r.unshift(192 + r.length), r;
    const i = Fg(r.length);
    return i.unshift(247 + i.length), i.concat(r);
  }
  bl(n) || Nr.throwArgumentError('RLP object must be BytesLike', 'object', n);
  const e = Array.prototype.slice.call(H(n));
  if (e.length === 1 && e[0] <= 127) return e;
  if (e.length <= 55) return e.unshift(128 + e.length), e;
  const t = Fg(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
function ys(n) {
  return K(F1(n));
}
function $g(n, e, t, r) {
  const i = [];
  for (; t < e + 1 + r; ) {
    const s = L1(n, t);
    i.push(s.result), (t += s.consumed), t > e + 1 + r && Nr.throwError('child data too short', O.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + r, result: i };
}
function L1(n, e) {
  if ((n.length === 0 && Nr.throwError('data too short', O.errors.BUFFER_OVERRUN, {}), n[e] >= 248)) {
    const t = n[e] - 247;
    e + 1 + t > n.length && Nr.throwError('data short segment too short', O.errors.BUFFER_OVERRUN, {});
    const r = Lg(n, e + 1, t);
    return e + 1 + t + r > n.length && Nr.throwError('data long segment too short', O.errors.BUFFER_OVERRUN, {}), $g(n, e, e + 1 + t, t + r);
  } else if (n[e] >= 192) {
    const t = n[e] - 192;
    return e + 1 + t > n.length && Nr.throwError('data array too short', O.errors.BUFFER_OVERRUN, {}), $g(n, e, e + 1, t);
  } else if (n[e] >= 184) {
    const t = n[e] - 183;
    e + 1 + t > n.length && Nr.throwError('data array too short', O.errors.BUFFER_OVERRUN, {});
    const r = Lg(n, e + 1, t);
    e + 1 + t + r > n.length && Nr.throwError('data array too short', O.errors.BUFFER_OVERRUN, {});
    const i = K(n.slice(e + 1 + t, e + 1 + t + r));
    return { consumed: 1 + t + r, result: i };
  } else if (n[e] >= 128) {
    const t = n[e] - 128;
    e + 1 + t > n.length && Nr.throwError('data too short', O.errors.BUFFER_OVERRUN, {});
    const r = K(n.slice(e + 1, e + 1 + t));
    return { consumed: 1 + t, result: r };
  }
  return { consumed: 1, result: K(n[e]) };
}
function vl(n) {
  const e = H(n),
    t = L1(e, 0);
  return t.consumed !== e.length && Nr.throwArgumentError('invalid rlp data', 'data', n), t.result;
}
const V7 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        decode: vl,
        encode: ys,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  z7 = 'address/5.7.0',
  is = new O(z7);
function Ug(n) {
  Ae(n, 20) || is.throwArgumentError('invalid address', 'address', n), (n = n.toLowerCase());
  const e = n.substring(2).split(''),
    t = new Uint8Array(40);
  for (let i = 0; i < 40; i++) t[i] = e[i].charCodeAt(0);
  const r = H(Ie(t));
  for (let i = 0; i < 40; i += 2) r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return '0x' + e.join('');
}
const G7 = 9007199254740991;
function H7(n) {
  return Math.log10 ? Math.log10(n) : Math.log(n) / Math.LN10;
}
const Ny = {};
for (let n = 0; n < 10; n++) Ny[String(n)] = String(n);
for (let n = 0; n < 26; n++) Ny[String.fromCharCode(65 + n)] = String(10 + n);
const jg = Math.floor(H7(G7));
function $1(n) {
  (n = n.toUpperCase()), (n = n.substring(4) + n.substring(0, 2) + '00');
  let e = n
    .split('')
    .map((r) => Ny[r])
    .join('');
  for (; e.length >= jg; ) {
    let r = e.substring(0, jg);
    e = (parseInt(r, 10) % 97) + e.substring(r.length);
  }
  let t = String(98 - (parseInt(e, 10) % 97));
  for (; t.length < 2; ) t = '0' + t;
  return t;
}
function Oe(n) {
  let e = null;
  if ((typeof n != 'string' && is.throwArgumentError('invalid address', 'address', n), n.match(/^(0x)?[0-9a-fA-F]{40}$/)))
    n.substring(0, 2) !== '0x' && (n = '0x' + n), (e = Ug(n)), n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== n && is.throwArgumentError('bad address checksum', 'address', n);
  else if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (n.substring(2, 4) !== $1(n) && is.throwArgumentError('bad icap checksum', 'address', n), e = XE(n.substring(4)); e.length < 40; ) e = '0' + e;
    e = Ug('0x' + e);
  } else is.throwArgumentError('invalid address', 'address', n);
  return e;
}
function K7(n) {
  try {
    return Oe(n), !0;
  } catch {}
  return !1;
}
function q7(n) {
  let e = ZE(Oe(n).substring(2)).toUpperCase();
  for (; e.length < 30; ) e = '0' + e;
  return 'XE' + $1('XE00' + e) + e;
}
function Dy(n) {
  let e = null;
  try {
    e = Oe(n.from);
  } catch {
    is.throwArgumentError('missing from address', 'transaction', n);
  }
  const t = zr(H(G.from(n.nonce).toHexString()));
  return Oe(Bt(Ie(ys([e, t])), 12));
}
function W7(n, e, t) {
  return (
    Jr(e) !== 32 && is.throwArgumentError('salt must be 32 bytes', 'salt', e),
    Jr(t) !== 32 && is.throwArgumentError('initCodeHash must be 32 bytes', 'initCodeHash', t),
    Oe(Bt(Ie($e(['0xff', Oe(n), e, t])), 12))
  );
}
const J7 = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      getAddress: Oe,
      getContractAddress: Dy,
      getCreate2Address: W7,
      getIcapAddress: q7,
      isAddress: K7,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
class Q7 extends ji {
  constructor(e) {
    super('address', 'address', e, !1);
  }
  defaultValue() {
    return '0x0000000000000000000000000000000000000000';
  }
  encode(e, t) {
    try {
      t = Oe(t);
    } catch (r) {
      this._throwError(r.message, t);
    }
    return e.writeValue(t);
  }
  decode(e) {
    return Oe(Be(e.readValue().toHexString(), 20));
  }
}
class Y7 extends ji {
  constructor(e) {
    super(e.name, e.type, void 0, e.dynamic), (this.coder = e);
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, t) {
    return this.coder.encode(e, t);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
const Ka = new O(gl);
function U1(n, e, t) {
  let r = null;
  if (Array.isArray(t)) r = t;
  else if (t && typeof t == 'object') {
    let u = {};
    r = e.map((l) => {
      const p = l.localName;
      return (
        p ||
          Ka.throwError('cannot encode object for signature with missing names', O.errors.INVALID_ARGUMENT, {
            argument: 'values',
            coder: l,
            value: t,
          }),
        u[p] &&
          Ka.throwError('cannot encode object for signature with duplicate names', O.errors.INVALID_ARGUMENT, {
            argument: 'values',
            coder: l,
            value: t,
          }),
        (u[p] = !0),
        t[p]
      );
    });
  } else Ka.throwArgumentError('invalid tuple value', 'tuple', t);
  e.length !== r.length && Ka.throwArgumentError('types/value length mismatch', 'tuple', t);
  let i = new Jf(n.wordSize),
    s = new Jf(n.wordSize),
    a = [];
  e.forEach((u, l) => {
    let p = r[l];
    if (u.dynamic) {
      let h = s.length;
      u.encode(s, p);
      let b = i.writeUpdatableValue();
      a.push((E) => {
        b(E + h);
      });
    } else u.encode(i, p);
  }),
    a.forEach((u) => {
      u(i.length);
    });
  let o = n.appendWriter(i);
  return (o += n.appendWriter(s)), o;
}
function j1(n, e) {
  let t = [],
    r = n.subReader(0);
  e.forEach((s) => {
    let a = null;
    if (s.dynamic) {
      let o = n.readValue(),
        u = r.subReader(o.toNumber());
      try {
        a = s.decode(u);
      } catch (l) {
        if (l.code === O.errors.BUFFER_OVERRUN) throw l;
        (a = l), (a.baseType = s.name), (a.name = s.localName), (a.type = s.type);
      }
    } else
      try {
        a = s.decode(n);
      } catch (o) {
        if (o.code === O.errors.BUFFER_OVERRUN) throw o;
        (a = o), (a.baseType = s.name), (a.name = s.localName), (a.type = s.type);
      }
    a != null && t.push(a);
  });
  const i = e.reduce((s, a) => {
    const o = a.localName;
    return o && (s[o] || (s[o] = 0), s[o]++), s;
  }, {});
  e.forEach((s, a) => {
    let o = s.localName;
    if (!o || i[o] !== 1 || (o === 'length' && (o = '_length'), t[o] != null)) return;
    const u = t[a];
    u instanceof Error
      ? Object.defineProperty(t, o, {
          enumerable: !0,
          get: () => {
            throw u;
          },
        })
      : (t[o] = u);
  });
  for (let s = 0; s < t.length; s++) {
    const a = t[s];
    a instanceof Error &&
      Object.defineProperty(t, s, {
        enumerable: !0,
        get: () => {
          throw a;
        },
      });
  }
  return Object.freeze(t);
}
class X7 extends ji {
  constructor(e, t, r) {
    const i = e.type + '[' + (t >= 0 ? t : '') + ']',
      s = t === -1 || e.dynamic;
    super('array', i, r, s), (this.coder = e), (this.length = t);
  }
  defaultValue() {
    const e = this.coder.defaultValue(),
      t = [];
    for (let r = 0; r < this.length; r++) t.push(e);
    return t;
  }
  encode(e, t) {
    Array.isArray(t) || this._throwError('expected array value', t);
    let r = this.length;
    r === -1 && ((r = t.length), e.writeValue(t.length)), Ka.checkArgumentCount(t.length, r, 'coder array' + (this.localName ? ' ' + this.localName : ''));
    let i = [];
    for (let s = 0; s < t.length; s++) i.push(this.coder);
    return U1(e, i, t);
  }
  decode(e) {
    let t = this.length;
    t === -1 &&
      ((t = e.readValue().toNumber()),
      t * 32 > e._data.length &&
        Ka.throwError('insufficient data length', O.errors.BUFFER_OVERRUN, {
          length: e._data.length,
          count: t,
        }));
    let r = [];
    for (let i = 0; i < t; i++) r.push(new Y7(this.coder));
    return e.coerce(this.name, j1(e, r));
  }
}
class Z7 extends ji {
  constructor(e) {
    super('bool', 'bool', e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    return e.writeValue(t ? 1 : 0);
  }
  decode(e) {
    return e.coerce(this.type, !e.readValue().isZero());
  }
}
class V1 extends ji {
  constructor(e, t) {
    super(e, e, t, !0);
  }
  defaultValue() {
    return '0x';
  }
  encode(e, t) {
    t = H(t);
    let r = e.writeValue(t.length);
    return (r += e.writeBytes(t)), r;
  }
  decode(e) {
    return e.readBytes(e.readValue().toNumber(), !0);
  }
}
class eC extends V1 {
  constructor(e) {
    super('bytes', e);
  }
  decode(e) {
    return e.coerce(this.name, K(super.decode(e)));
  }
}
class tC extends ji {
  constructor(e, t) {
    let r = 'bytes' + String(e);
    super(r, r, t, !1), (this.size = e);
  }
  defaultValue() {
    return '0x0000000000000000000000000000000000000000000000000000000000000000'.substring(0, 2 + this.size * 2);
  }
  encode(e, t) {
    let r = H(t);
    return r.length !== this.size && this._throwError('incorrect data length', t), e.writeBytes(r);
  }
  decode(e) {
    return e.coerce(this.name, K(e.readBytes(this.size)));
  }
}
class nC extends ji {
  constructor(e) {
    super('null', '', e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, t) {
    return t != null && this._throwError('not null', t), e.writeBytes([]);
  }
  decode(e) {
    return e.readBytes(0), e.coerce(this.name, null);
  }
}
const rC = '0x0000000000000000000000000000000000000000',
  iC = /* @__PURE__ */ G.from(-1),
  Fy = /* @__PURE__ */ G.from(0),
  sC = /* @__PURE__ */ G.from(1),
  aC = /* @__PURE__ */ G.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'),
  z1 = '0x0000000000000000000000000000000000000000000000000000000000000000';
class oC extends ji {
  constructor(e, t, r) {
    const i = (t ? 'int' : 'uint') + e * 8;
    super(i, i, r, !1), (this.size = e), (this.signed = t);
  }
  defaultValue() {
    return 0;
  }
  encode(e, t) {
    let r = G.from(t),
      i = aC.mask(e.wordSize * 8);
    if (this.signed) {
      let s = i.mask(this.size * 8 - 1);
      (r.gt(s) || r.lt(s.add(sC).mul(iC))) && this._throwError('value out-of-bounds', t);
    } else (r.lt(Fy) || r.gt(i.mask(this.size * 8))) && this._throwError('value out-of-bounds', t);
    return (r = r.toTwos(this.size * 8).mask(this.size * 8)), this.signed && (r = r.fromTwos(this.size * 8).toTwos(8 * e.wordSize)), e.writeValue(r);
  }
  decode(e) {
    let t = e.readValue().mask(this.size * 8);
    return this.signed && (t = t.fromTwos(this.size * 8)), e.coerce(this.name, t);
  }
}
const uC = 'strings/5.7.0',
  G1 = new O(uC);
var Qr;
(function (n) {
  (n.current = ''), (n.NFC = 'NFC'), (n.NFD = 'NFD'), (n.NFKC = 'NFKC'), (n.NFKD = 'NFKD');
})(Qr || (Qr = {}));
var In;
(function (n) {
  (n.UNEXPECTED_CONTINUE = 'unexpected continuation byte'),
    (n.BAD_PREFIX = 'bad codepoint prefix'),
    (n.OVERRUN = 'string overrun'),
    (n.MISSING_CONTINUE = 'missing continuation byte'),
    (n.OUT_OF_RANGE = 'out of UTF-8 range'),
    (n.UTF16_SURROGATE = 'UTF-16 surrogate'),
    (n.OVERLONG = 'overlong representation');
})(In || (In = {}));
function lC(n, e, t, r, i) {
  return G1.throwArgumentError(`invalid codepoint at offset ${e}; ${n}`, 'bytes', t);
}
function H1(n, e, t, r, i) {
  if (n === In.BAD_PREFIX || n === In.UNEXPECTED_CONTINUE) {
    let s = 0;
    for (let a = e + 1; a < t.length && t[a] >> 6 === 2; a++) s++;
    return s;
  }
  return n === In.OVERRUN ? t.length - e - 1 : 0;
}
function cC(n, e, t, r, i) {
  return n === In.OVERLONG ? (r.push(i), 0) : (r.push(65533), H1(n, e, t));
}
const K1 = Object.freeze({
  error: lC,
  ignore: H1,
  replace: cC,
});
function Ly(n, e) {
  e == null && (e = K1.error), (n = H(n));
  const t = [];
  let r = 0;
  for (; r < n.length; ) {
    const i = n[r++];
    if (!(i >> 7)) {
      t.push(i);
      continue;
    }
    let s = null,
      a = null;
    if ((i & 224) === 192) (s = 1), (a = 127);
    else if ((i & 240) === 224) (s = 2), (a = 2047);
    else if ((i & 248) === 240) (s = 3), (a = 65535);
    else {
      (i & 192) === 128 ? (r += e(In.UNEXPECTED_CONTINUE, r - 1, n, t)) : (r += e(In.BAD_PREFIX, r - 1, n, t));
      continue;
    }
    if (r - 1 + s >= n.length) {
      r += e(In.OVERRUN, r - 1, n, t);
      continue;
    }
    let o = i & ((1 << (8 - s - 1)) - 1);
    for (let u = 0; u < s; u++) {
      let l = n[r];
      if ((l & 192) != 128) {
        (r += e(In.MISSING_CONTINUE, r, n, t)), (o = null);
        break;
      }
      (o = (o << 6) | (l & 63)), r++;
    }
    if (o !== null) {
      if (o > 1114111) {
        r += e(In.OUT_OF_RANGE, r - 1 - s, n, t, o);
        continue;
      }
      if (o >= 55296 && o <= 57343) {
        r += e(In.UTF16_SURROGATE, r - 1 - s, n, t, o);
        continue;
      }
      if (o <= a) {
        r += e(In.OVERLONG, r - 1 - s, n, t, o);
        continue;
      }
      t.push(o);
    }
  }
  return t;
}
function Nt(n, e = Qr.current) {
  e != Qr.current && (G1.checkNormalize(), (n = n.normalize(e)));
  let t = [];
  for (let r = 0; r < n.length; r++) {
    const i = n.charCodeAt(r);
    if (i < 128) t.push(i);
    else if (i < 2048) t.push((i >> 6) | 192), t.push((i & 63) | 128);
    else if ((i & 64512) == 55296) {
      r++;
      const s = n.charCodeAt(r);
      if (r >= n.length || (s & 64512) !== 56320) throw new Error('invalid utf-8 string');
      const a = 65536 + ((i & 1023) << 10) + (s & 1023);
      t.push((a >> 18) | 240), t.push(((a >> 12) & 63) | 128), t.push(((a >> 6) & 63) | 128), t.push((a & 63) | 128);
    } else t.push((i >> 12) | 224), t.push(((i >> 6) & 63) | 128), t.push((i & 63) | 128);
  }
  return H(t);
}
function Hp(n) {
  const e = '0000' + n.toString(16);
  return '\\u' + e.substring(e.length - 4);
}
function dC(n, e) {
  return (
    '"' +
    Ly(n, e)
      .map((t) => {
        if (t < 256) {
          switch (t) {
            case 8:
              return '\\b';
            case 9:
              return '\\t';
            case 10:
              return '\\n';
            case 13:
              return '\\r';
            case 34:
              return '\\"';
            case 92:
              return '\\\\';
          }
          if (t >= 32 && t < 127) return String.fromCharCode(t);
        }
        return t <= 65535 ? Hp(t) : ((t -= 65536), Hp(((t >> 10) & 1023) + 55296) + Hp((t & 1023) + 56320));
      })
      .join('') +
    '"'
  );
}
function Yf(n) {
  return n.map((e) => (e <= 65535 ? String.fromCharCode(e) : ((e -= 65536), String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320)))).join('');
}
function ws(n, e) {
  return Yf(Ly(n, e));
}
function Hc(n, e = Qr.current) {
  return Ly(Nt(n, e));
}
function pC(n) {
  const e = Nt(n);
  if (e.length > 31) throw new Error('bytes32 string must be less than 32 bytes');
  return K($e([e, z1]).slice(0, 32));
}
function fC(n) {
  const e = H(n);
  if (e.length !== 32) throw new Error('invalid bytes32 - not 32 bytes long');
  if (e[31] !== 0) throw new Error('invalid bytes32 string - no null terminator');
  let t = 31;
  for (; e[t - 1] === 0; ) t--;
  return ws(e.slice(0, t));
}
function hC(n) {
  if (n.length % 4 !== 0) throw new Error('bad data');
  let e = [];
  for (let t = 0; t < n.length; t += 4) e.push(parseInt(n.substring(t, t + 4), 16));
  return e;
}
function $y(n, e) {
  e ||
    (e = function (i) {
      return [parseInt(i, 16)];
    });
  let t = 0,
    r = {};
  return (
    n.split(',').forEach((i) => {
      let s = i.split(':');
      (t += parseInt(s[0], 16)), (r[t] = e(s[1]));
    }),
    r
  );
}
function q1(n) {
  let e = 0;
  return n.split(',').map((t) => {
    let r = t.split('-');
    r.length === 1 ? (r[1] = '0') : r[1] === '' && (r[1] = '1');
    let i = e + parseInt(r[0], 16);
    return (e = parseInt(r[1], 16)), { l: i, h: e };
  });
}
function Uy(n, e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    let i = e[r];
    if (((t += i.l), n >= t && n <= t + i.h && (n - t) % (i.d || 1) === 0)) {
      if (i.e && i.e.indexOf(n - t) !== -1) continue;
      return i;
    }
  }
  return null;
}
const yC = q1(
    '221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d',
  ),
  mC = 'ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff'.split(',').map((n) => parseInt(n, 16)),
  bC = [
    { h: 25, s: 32, l: 65 },
    { h: 30, s: 32, e: [23], l: 127 },
    { h: 54, s: 1, e: [48], l: 64, d: 2 },
    { h: 14, s: 1, l: 57, d: 2 },
    { h: 44, s: 1, l: 17, d: 2 },
    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
    { h: 16, s: 1, l: 68, d: 2 },
    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
    { h: 26, s: 32, e: [17], l: 435 },
    { h: 22, s: 1, l: 71, d: 2 },
    { h: 15, s: 80, l: 40 },
    { h: 31, s: 32, l: 16 },
    { h: 32, s: 1, l: 80, d: 2 },
    { h: 52, s: 1, l: 42, d: 2 },
    { h: 12, s: 1, l: 55, d: 2 },
    { h: 40, s: 1, e: [38], l: 15, d: 2 },
    { h: 14, s: 1, l: 48, d: 2 },
    { h: 37, s: 48, l: 49 },
    { h: 148, s: 1, l: 6351, d: 2 },
    { h: 88, s: 1, l: 160, d: 2 },
    { h: 15, s: 16, l: 704 },
    { h: 25, s: 26, l: 854 },
    { h: 25, s: 32, l: 55915 },
    { h: 37, s: 40, l: 1247 },
    { h: 25, s: -119711, l: 53248 },
    { h: 25, s: -119763, l: 52 },
    { h: 25, s: -119815, l: 52 },
    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
    { h: 25, s: -119919, l: 52 },
    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
    { h: 25, s: -120075, l: 52 },
    { h: 25, s: -120127, l: 52 },
    { h: 25, s: -120179, l: 52 },
    { h: 25, s: -120231, l: 52 },
    { h: 25, s: -120283, l: 52 },
    { h: 25, s: -120335, l: 52 },
    { h: 24, s: -119543, e: [17], l: 56 },
    { h: 24, s: -119601, e: [17], l: 58 },
    { h: 24, s: -119659, e: [17], l: 58 },
    { h: 24, s: -119717, e: [17], l: 58 },
    { h: 24, s: -119775, e: [17], l: 58 },
  ],
  gC = $y(
    'b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3',
  ),
  vC = $y(
    '179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7',
  ),
  xC = $y(
    'df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D',
    hC,
  ),
  wC = q1('80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001');
function TC(n) {
  return n.reduce(
    (e, t) => (
      t.forEach((r) => {
        e.push(r);
      }),
      e
    ),
    [],
  );
}
function AC(n) {
  return !!Uy(n, yC);
}
function EC(n) {
  let e = Uy(n, bC);
  if (e) return [n + e.s];
  let t = gC[n];
  if (t) return t;
  let r = vC[n];
  if (r) return [n + r[0]];
  let i = xC[n];
  return i || null;
}
function CC(n) {
  return !!Uy(n, wC);
}
function SC(n) {
  if (n.match(/^[a-z0-9-]*$/i) && n.length <= 59) return n.toLowerCase();
  let e = Hc(n);
  (e = TC(
    e.map((r) => {
      if (mC.indexOf(r) >= 0) return [];
      if (r >= 65024 && r <= 65039) return [];
      let i = EC(r);
      return i || [r];
    }),
  )),
    (e = Hc(Yf(e), Qr.NFKC)),
    e.forEach((r) => {
      if (CC(r)) throw new Error('STRINGPREP_CONTAINS_PROHIBITED');
    }),
    e.forEach((r) => {
      if (AC(r)) throw new Error('STRINGPREP_CONTAINS_UNASSIGNED');
    });
  let t = Yf(e);
  if (t.substring(0, 1) === '-' || t.substring(2, 4) === '--' || t.substring(t.length - 1) === '-') throw new Error('invalid hyphen');
  return t;
}
const MC = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      get UnicodeNormalizationForm() {
        return Qr;
      },
      Utf8ErrorFuncs: K1,
      get Utf8ErrorReason() {
        return In;
      },
      _toEscapedUtf8String: dC,
      formatBytes32String: pC,
      nameprep: SC,
      parseBytes32String: fC,
      toUtf8Bytes: Nt,
      toUtf8CodePoints: Hc,
      toUtf8String: ws,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
class _C extends V1 {
  constructor(e) {
    super('string', e);
  }
  defaultValue() {
    return '';
  }
  encode(e, t) {
    return super.encode(e, Nt(t));
  }
  decode(e) {
    return ws(super.decode(e));
  }
}
class Gl extends ji {
  constructor(e, t) {
    let r = !1;
    const i = [];
    e.forEach((a) => {
      a.dynamic && (r = !0), i.push(a.type);
    });
    const s = 'tuple(' + i.join(',') + ')';
    super('tuple', s, t, r), (this.coders = e);
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((r) => {
      e.push(r.defaultValue());
    });
    const t = this.coders.reduce((r, i) => {
      const s = i.localName;
      return s && (r[s] || (r[s] = 0), r[s]++), r;
    }, {});
    return (
      this.coders.forEach((r, i) => {
        let s = r.localName;
        !s || t[s] !== 1 || (s === 'length' && (s = '_length'), e[s] == null && (e[s] = e[i]));
      }),
      Object.freeze(e)
    );
  }
  encode(e, t) {
    return U1(e, this.coders, t);
  }
  decode(e) {
    return e.coerce(this.name, j1(e, this.coders));
  }
}
const Hl = new O(gl),
  RC = new RegExp(/^bytes([0-9]*)$/),
  PC = new RegExp(/^(u?int)([0-9]*)$/);
class W1 {
  constructor(e) {
    U(this, 'coerceFunc', e || null);
  }
  _getCoder(e) {
    switch (e.baseType) {
      case 'address':
        return new Q7(e.name);
      case 'bool':
        return new Z7(e.name);
      case 'string':
        return new _C(e.name);
      case 'bytes':
        return new eC(e.name);
      case 'array':
        return new X7(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
      case 'tuple':
        return new Gl(
          (e.components || []).map((r) => this._getCoder(r)),
          e.name,
        );
      case '':
        return new nC(e.name);
    }
    let t = e.type.match(PC);
    if (t) {
      let r = parseInt(t[2] || '256');
      return (r === 0 || r > 256 || r % 8 !== 0) && Hl.throwArgumentError('invalid ' + t[1] + ' bit length', 'param', e), new oC(r / 8, t[1] === 'int', e.name);
    }
    if (((t = e.type.match(RC)), t)) {
      let r = parseInt(t[1]);
      return (r === 0 || r > 32) && Hl.throwArgumentError('invalid bytes length', 'param', e), new tC(r, e.name);
    }
    return Hl.throwArgumentError('invalid type', 'type', e.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(e, t) {
    return new Gc(e, this._getWordSize(), this.coerceFunc, t);
  }
  _getWriter() {
    return new Jf(this._getWordSize());
  }
  getDefaultValue(e) {
    const t = e.map((i) => this._getCoder(zt.from(i)));
    return new Gl(t, '_').defaultValue();
  }
  encode(e, t) {
    e.length !== t.length &&
      Hl.throwError('types/values length mismatch', O.errors.INVALID_ARGUMENT, {
        count: { types: e.length, values: t.length },
        value: { types: e, values: t },
      });
    const r = e.map((a) => this._getCoder(zt.from(a))),
      i = new Gl(r, '_'),
      s = this._getWriter();
    return i.encode(s, t), s.data;
  }
  decode(e, t, r) {
    const i = e.map((a) => this._getCoder(zt.from(a)));
    return new Gl(i, '_').decode(this._getReader(H(t), r));
  }
}
const J1 = new W1();
function ss(n) {
  return Ie(Nt(n));
}
const Q1 = 'hash/5.7.0';
function jy(n) {
  n = atob(n);
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n.charCodeAt(t));
  return H(e);
}
function Vy(n) {
  n = H(n);
  let e = '';
  for (let t = 0; t < n.length; t++) e += String.fromCharCode(n[t]);
  return btoa(e);
}
const IC = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      decode: jy,
      encode: Vy,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
function Y1(n, e) {
  e == null && (e = 1);
  const t = [],
    r = t.forEach,
    i = function (s, a) {
      r.call(s, function (o) {
        a > 0 && Array.isArray(o) ? i(o, a - 1) : t.push(o);
      });
    };
  return i(n, e), t;
}
function kC(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = n[t];
    e[r[0]] = r[1];
  }
  return e;
}
function OC(n) {
  let e = 0;
  function t() {
    return (n[e++] << 8) | n[e++];
  }
  let r = t(),
    i = 1,
    s = [0, 1];
  for (let B = 1; B < r; B++) s.push((i += t()));
  let a = t(),
    o = e;
  e += a;
  let u = 0,
    l = 0;
  function p() {
    return u == 0 && ((l = (l << 8) | n[e++]), (u = 8)), (l >> --u) & 1;
  }
  const h = 31,
    b = Math.pow(2, h),
    E = b >>> 1,
    x = E >> 1,
    T = b - 1;
  let w = 0;
  for (let B = 0; B < h; B++) w = (w << 1) | p();
  let _ = [],
    k = 0,
    D = b;
  for (;;) {
    let B = Math.floor(((w - k + 1) * i - 1) / D),
      j = 0,
      q = r;
    for (; q - j > 1; ) {
      let ae = (j + q) >>> 1;
      B < s[ae] ? (q = ae) : (j = ae);
    }
    if (j == 0) break;
    _.push(j);
    let z = k + Math.floor((D * s[j]) / i),
      Y = k + Math.floor((D * s[j + 1]) / i) - 1;
    for (; !((z ^ Y) & E); ) (w = ((w << 1) & T) | p()), (z = (z << 1) & T), (Y = ((Y << 1) & T) | 1);
    for (; z & ~Y & x; ) (w = (w & E) | ((w << 1) & (T >>> 1)) | p()), (z = (z << 1) ^ E), (Y = ((Y ^ E) << 1) | E | 1);
    (k = z), (D = 1 + Y - z);
  }
  let N = r - 4;
  return _.map((B) => {
    switch (B - N) {
      case 3:
        return N + 65792 + ((n[o++] << 16) | (n[o++] << 8) | n[o++]);
      case 2:
        return N + 256 + ((n[o++] << 8) | n[o++]);
      case 1:
        return N + n[o++];
      default:
        return B - 1;
    }
  });
}
function BC(n) {
  let e = 0;
  return () => n[e++];
}
function NC(n) {
  return BC(OC(n));
}
function DC(n) {
  return n & 1 ? ~n >> 1 : n >> 1;
}
function FC(n, e) {
  let t = Array(n);
  for (let r = 0; r < n; r++) t[r] = 1 + e();
  return t;
}
function Vg(n, e) {
  let t = Array(n);
  for (let r = 0, i = -1; r < n; r++) t[r] = i += 1 + e();
  return t;
}
function LC(n, e) {
  let t = Array(n);
  for (let r = 0, i = 0; r < n; r++) t[r] = i += DC(e());
  return t;
}
function Kc(n, e) {
  let t = Vg(n(), n),
    r = n(),
    i = Vg(r, n),
    s = FC(r, n);
  for (let a = 0; a < r; a++) for (let o = 0; o < s[a]; o++) t.push(i[a] + o);
  return e ? t.map((a) => e[a]) : t;
}
function $C(n) {
  let e = [];
  for (;;) {
    let t = n();
    if (t == 0) break;
    e.push(jC(t, n));
  }
  for (;;) {
    let t = n() - 1;
    if (t < 0) break;
    e.push(VC(t, n));
  }
  return kC(Y1(e));
}
function UC(n) {
  let e = [];
  for (;;) {
    let t = n();
    if (t == 0) break;
    e.push(t);
  }
  return e;
}
function X1(n, e, t) {
  let r = Array(n)
    .fill(void 0)
    .map(() => []);
  for (let i = 0; i < e; i++) LC(n, t).forEach((s, a) => r[a].push(s));
  return r;
}
function jC(n, e) {
  let t = 1 + e(),
    r = e(),
    i = UC(e),
    s = X1(i.length, 1 + n, e);
  return Y1(
    s.map((a, o) => {
      const u = a[0],
        l = a.slice(1);
      return Array(i[o])
        .fill(void 0)
        .map((p, h) => {
          let b = h * r;
          return [u + h * t, l.map((E) => E + b)];
        });
    }),
  );
}
function VC(n, e) {
  let t = 1 + e();
  return X1(t, 1 + n, e).map((i) => [i[0], i.slice(1)]);
}
function zC(n) {
  let e = Kc(n).sort((r, i) => r - i);
  return t();
  function t() {
    let r = [];
    for (;;) {
      let l = Kc(n, e);
      if (l.length == 0) break;
      r.push({ set: new Set(l), node: t() });
    }
    r.sort((l, p) => p.set.size - l.set.size);
    let i = n(),
      s = i % 3;
    i = (i / 3) | 0;
    let a = !!(i & 1);
    i >>= 1;
    let o = i == 1,
      u = i == 2;
    return { branches: r, valid: s, fe0f: a, save: o, check: u };
  }
}
function GC() {
  return NC(
    jy(
      'AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA==',
    ),
  );
}
const Bd = GC(),
  HC = new Set(Kc(Bd)),
  KC = new Set(Kc(Bd)),
  qC = $C(Bd),
  WC = zC(Bd),
  zg = 45,
  Gg = 95;
function Z1(n) {
  return Hc(n);
}
function JC(n) {
  return n.filter((e) => e != 65039);
}
function e6(n) {
  for (let e of n.split('.')) {
    let t = Z1(e);
    try {
      for (let r = t.lastIndexOf(Gg) - 1; r >= 0; r--) if (t[r] !== Gg) throw new Error('underscore only allowed at start');
      if (t.length >= 4 && t.every((r) => r < 128) && t[2] === zg && t[3] === zg) throw new Error('invalid label extension');
    } catch (r) {
      throw new Error(`Invalid label "${e}": ${r.message}`);
    }
  }
  return n;
}
function QC(n) {
  return e6(YC(n, JC));
}
function YC(n, e) {
  let t = Z1(n).reverse(),
    r = [];
  for (; t.length; ) {
    let i = ZC(t);
    if (i) {
      r.push(...e(i));
      continue;
    }
    let s = t.pop();
    if (HC.has(s)) {
      r.push(s);
      continue;
    }
    if (KC.has(s)) continue;
    let a = qC[s];
    if (a) {
      r.push(...a);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`);
  }
  return e6(XC(String.fromCodePoint(...r)));
}
function XC(n) {
  return n.normalize('NFC');
}
function ZC(n, e) {
  var t;
  let r = WC,
    i,
    s,
    a = [],
    o = n.length;
  for (e && (e.length = 0); o; ) {
    let u = n[--o];
    if (((r = (t = r.branches.find((l) => l.set.has(u))) === null || t === void 0 ? void 0 : t.node), !r)) break;
    if (r.save) s = u;
    else if (r.check && u === s) break;
    a.push(u), r.fe0f && (a.push(65039), o > 0 && n[o - 1] == 65039 && o--), r.valid && ((i = a.slice()), r.valid == 2 && i.splice(1, 1), e && e.push(...n.slice(o).reverse()), (n.length = o));
  }
  return i;
}
const eS = new O(Q1),
  t6 = new Uint8Array(32);
t6.fill(0);
function Hg(n) {
  if (n.length === 0) throw new Error('invalid ENS name; empty component');
  return n;
}
function Nd(n) {
  const e = Nt(QC(n)),
    t = [];
  if (n.length === 0) return t;
  let r = 0;
  for (let i = 0; i < e.length; i++) e[i] === 46 && (t.push(Hg(e.slice(r, i))), (r = i + 1));
  if (r >= e.length) throw new Error('invalid ENS name; empty component');
  return t.push(Hg(e.slice(r))), t;
}
function tS(n) {
  return Nd(n)
    .map((e) => ws(e))
    .join('.');
}
function nS(n) {
  try {
    return Nd(n).length !== 0;
  } catch {}
  return !1;
}
function pu(n) {
  typeof n != 'string' && eS.throwArgumentError('invalid ENS name; not a string', 'name', n);
  let e = t6;
  const t = Nd(n);
  for (; t.length; ) e = Ie($e([e, Ie(t.pop())]));
  return K(e);
}
function n6(n) {
  return (
    K(
      $e(
        Nd(n).map((e) => {
          if (e.length > 63) throw new Error('invalid DNS encoded entry; length exceeds 63 bytes');
          const t = new Uint8Array(e.length + 1);
          return t.set(e, 1), (t[0] = t.length - 1), t;
        }),
      ),
    ) + '00'
  );
}
const r6 = `Ethereum Signed Message:
`;
function zy(n) {
  return typeof n == 'string' && (n = Nt(n)), Ie($e([Nt(r6), Nt(String(n.length)), n]));
}
var rS =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const At = new O(Q1),
  i6 = new Uint8Array(32);
i6.fill(0);
const iS = G.from(-1),
  s6 = G.from(0),
  a6 = G.from(1),
  sS = G.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
function aS(n) {
  const e = H(n),
    t = e.length % 32;
  return t ? xn([e, i6.slice(t)]) : K(e);
}
const oS = Be(a6.toHexString(), 32),
  uS = Be(s6.toHexString(), 32),
  Kg = {
    name: 'string',
    version: 'string',
    chainId: 'uint256',
    verifyingContract: 'address',
    salt: 'bytes32',
  },
  Kp = ['name', 'version', 'chainId', 'verifyingContract', 'salt'];
function qg(n) {
  return function (e) {
    return typeof e != 'string' && At.throwArgumentError(`invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, e), e;
  };
}
const lS = {
  name: qg('name'),
  version: qg('version'),
  chainId: function (n) {
    try {
      return G.from(n).toString();
    } catch {}
    return At.throwArgumentError('invalid domain value for "chainId"', 'domain.chainId', n);
  },
  verifyingContract: function (n) {
    try {
      return Oe(n).toLowerCase();
    } catch {}
    return At.throwArgumentError('invalid domain value "verifyingContract"', 'domain.verifyingContract', n);
  },
  salt: function (n) {
    try {
      const e = H(n);
      if (e.length !== 32) throw new Error('bad length');
      return K(e);
    } catch {}
    return At.throwArgumentError('invalid domain value "salt"', 'domain.salt', n);
  },
};
function qp(n) {
  {
    const e = n.match(/^(u?)int(\d*)$/);
    if (e) {
      const t = e[1] === '',
        r = parseInt(e[2] || '256');
      (r % 8 !== 0 || r > 256 || (e[2] && e[2] !== String(r))) && At.throwArgumentError('invalid numeric width', 'type', n);
      const i = sS.mask(t ? r - 1 : r),
        s = t ? i.add(a6).mul(iS) : s6;
      return function (a) {
        const o = G.from(a);
        return (o.lt(s) || o.gt(i)) && At.throwArgumentError(`value out-of-bounds for ${n}`, 'value', a), Be(o.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const e = n.match(/^bytes(\d+)$/);
    if (e) {
      const t = parseInt(e[1]);
      return (
        (t === 0 || t > 32 || e[1] !== String(t)) && At.throwArgumentError('invalid bytes width', 'type', n),
        function (r) {
          return H(r).length !== t && At.throwArgumentError(`invalid length for ${n}`, 'value', r), aS(r);
        }
      );
    }
  }
  switch (n) {
    case 'address':
      return function (e) {
        return Be(Oe(e), 32);
      };
    case 'bool':
      return function (e) {
        return e ? oS : uS;
      };
    case 'bytes':
      return function (e) {
        return Ie(e);
      };
    case 'string':
      return function (e) {
        return ss(e);
      };
  }
  return null;
}
function Wg(n, e) {
  return `${n}(${e.map(({ name: t, type: r }) => r + ' ' + t).join(',')})`;
}
class Zt {
  constructor(e) {
    U(this, 'types', Object.freeze(hs(e))), U(this, '_encoderCache', {}), U(this, '_types', {});
    const t = {},
      r = {},
      i = {};
    Object.keys(e).forEach((o) => {
      (t[o] = {}), (r[o] = []), (i[o] = {});
    });
    for (const o in e) {
      const u = {};
      e[o].forEach((l) => {
        u[l.name] && At.throwArgumentError(`duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(o)}`, 'types', e), (u[l.name] = !0);
        const p = l.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        p === o && At.throwArgumentError(`circular type reference to ${JSON.stringify(p)}`, 'types', e),
          !qp(p) && (r[p] || At.throwArgumentError(`unknown type ${JSON.stringify(p)}`, 'types', e), r[p].push(o), (t[o][p] = !0));
      });
    }
    const s = Object.keys(r).filter((o) => r[o].length === 0);
    s.length === 0
      ? At.throwArgumentError('missing primary type', 'types', e)
      : s.length > 1 && At.throwArgumentError(`ambiguous primary types or unused types: ${s.map((o) => JSON.stringify(o)).join(', ')}`, 'types', e),
      U(this, 'primaryType', s[0]);
    function a(o, u) {
      u[o] && At.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`, 'types', e),
        (u[o] = !0),
        Object.keys(t[o]).forEach((l) => {
          r[l] &&
            (a(l, u),
            Object.keys(u).forEach((p) => {
              i[p][l] = !0;
            }));
        }),
        delete u[o];
    }
    a(this.primaryType, {});
    for (const o in i) {
      const u = Object.keys(i[o]);
      u.sort(), (this._types[o] = Wg(o, e[o]) + u.map((l) => Wg(l, e[l])).join(''));
    }
  }
  getEncoder(e) {
    let t = this._encoderCache[e];
    return t || (t = this._encoderCache[e] = this._getEncoder(e)), t;
  }
  _getEncoder(e) {
    {
      const i = qp(e);
      if (i) return i;
    }
    const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (t) {
      const i = t[1],
        s = this.getEncoder(i),
        a = parseInt(t[3]);
      return (o) => {
        a >= 0 && o.length !== a && At.throwArgumentError('array length mismatch; expected length ${ arrayLength }', 'value', o);
        let u = o.map(s);
        return this._types[i] && (u = u.map(Ie)), Ie(xn(u));
      };
    }
    const r = this.types[e];
    if (r) {
      const i = ss(this._types[e]);
      return (s) => {
        const a = r.map(({ name: o, type: u }) => {
          const l = this.getEncoder(u)(s[o]);
          return this._types[u] ? Ie(l) : l;
        });
        return a.unshift(i), xn(a);
      };
    }
    return At.throwArgumentError(`unknown type: ${e}`, 'type', e);
  }
  encodeType(e) {
    const t = this._types[e];
    return t || At.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, 'name', e), t;
  }
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  hashStruct(e, t) {
    return Ie(this.encodeData(e, t));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, t, r) {
    if (qp(e)) return r(e, t);
    const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (i) {
      const a = i[1],
        o = parseInt(i[3]);
      return o >= 0 && t.length !== o && At.throwArgumentError('array length mismatch; expected length ${ arrayLength }', 'value', t), t.map((u) => this._visit(a, u, r));
    }
    const s = this.types[e];
    return s ? s.reduce((a, { name: o, type: u }) => ((a[o] = this._visit(u, t[o], r)), a), {}) : At.throwArgumentError(`unknown type: ${e}`, 'type', e);
  }
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  static from(e) {
    return new Zt(e);
  }
  static getPrimaryType(e) {
    return Zt.from(e).primaryType;
  }
  static hashStruct(e, t, r) {
    return Zt.from(t).hashStruct(e, r);
  }
  static hashDomain(e) {
    const t = [];
    for (const r in e) {
      const i = Kg[r];
      i || At.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(r)}`, 'domain', e), t.push({ name: r, type: i });
    }
    return t.sort((r, i) => Kp.indexOf(r.name) - Kp.indexOf(i.name)), Zt.hashStruct('EIP712Domain', { EIP712Domain: t }, e);
  }
  static encode(e, t, r) {
    return xn(['0x1901', Zt.hashDomain(e), Zt.from(t).hash(r)]);
  }
  static hash(e, t, r) {
    return Ie(Zt.encode(e, t, r));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(e, t, r, i) {
    return rS(this, void 0, void 0, function* () {
      e = $t(e);
      const s = {};
      e.verifyingContract && !Ae(e.verifyingContract, 20) && (s[e.verifyingContract] = '0x');
      const a = Zt.from(t);
      a.visit(r, (o, u) => (o === 'address' && !Ae(u, 20) && (s[u] = '0x'), u));
      for (const o in s) s[o] = yield i(o);
      return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), (r = a.visit(r, (o, u) => (o === 'address' && s[u] ? s[u] : u))), { domain: e, value: r };
    });
  }
  static getPayload(e, t, r) {
    Zt.hashDomain(e);
    const i = {},
      s = [];
    Kp.forEach((u) => {
      const l = e[u];
      l != null && ((i[u] = lS[u](l)), s.push({ name: u, type: Kg[u] }));
    });
    const a = Zt.from(t),
      o = $t(t);
    return (
      o.EIP712Domain ? At.throwArgumentError('types must not contain EIP712Domain type', 'types.EIP712Domain', t) : (o.EIP712Domain = s),
      a.encode(r),
      {
        types: o,
        domain: i,
        primaryType: a.primaryType,
        message: a.visit(r, (u, l) => {
          if (u.match(/^bytes(\d*)/)) return K(H(l));
          if (u.match(/^u?int/)) return G.from(l).toString();
          switch (u) {
            case 'address':
              return l.toLowerCase();
            case 'bool':
              return !!l;
            case 'string':
              return typeof l != 'string' && At.throwArgumentError('invalid string', 'value', l), l;
          }
          return At.throwArgumentError('unsupported type', 'type', u);
        }),
      }
    );
  }
}
const cS = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        _TypedDataEncoder: Zt,
        dnsEncode: n6,
        ensNormalize: tS,
        hashMessage: zy,
        id: ss,
        isValidName: nS,
        messagePrefix: r6,
        namehash: pu,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Tt = new O(gl);
class o6 extends xs {}
class u6 extends xs {}
class dS extends xs {}
class qc extends xs {
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const pS = {
  '0x08c379a0': { signature: 'Error(string)', name: 'Error', inputs: ['string'], reason: !0 },
  '0x4e487b71': { signature: 'Panic(uint256)', name: 'Panic', inputs: ['uint256'] },
};
function Jg(n, e) {
  const t = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
  return (t.error = e), t;
}
class Xf {
  constructor(e) {
    let t = [];
    typeof e == 'string' ? (t = JSON.parse(e)) : (t = e),
      U(
        this,
        'fragments',
        t.map((r) => Ur.from(r)).filter((r) => r != null),
      ),
      U(this, '_abiCoder', Er(new.target, 'getAbiCoder')()),
      U(this, 'functions', {}),
      U(this, 'errors', {}),
      U(this, 'events', {}),
      U(this, 'structs', {}),
      this.fragments.forEach((r) => {
        let i = null;
        switch (r.type) {
          case 'constructor':
            if (this.deploy) {
              Tt.warn('duplicate definition - constructor');
              return;
            }
            U(this, 'deploy', r);
            return;
          case 'function':
            i = this.functions;
            break;
          case 'event':
            i = this.events;
            break;
          case 'error':
            i = this.errors;
            break;
          default:
            return;
        }
        let s = r.format();
        if (i[s]) {
          Tt.warn('duplicate definition - ' + s);
          return;
        }
        i[s] = r;
      }),
      this.deploy ||
        U(
          this,
          'deploy',
          xr.from({
            payable: !1,
            type: 'constructor',
          }),
        ),
      U(this, '_isInterface', !0);
  }
  format(e) {
    e || (e = Me.full), e === Me.sighash && Tt.throwArgumentError('interface does not support formatting sighash', 'format', e);
    const t = this.fragments.map((r) => r.format(e));
    return e === Me.json ? JSON.stringify(t.map((r) => JSON.parse(r))) : t;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return J1;
  }
  static getAddress(e) {
    return Oe(e);
  }
  static getSighash(e) {
    return Bt(ss(e.format()), 0, 4);
  }
  static getEventTopic(e) {
    return ss(e.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(e) {
    if (Ae(e)) {
      for (const r in this.functions) if (e === this.getSighash(r)) return this.functions[r];
      Tt.throwArgumentError('no matching function', 'sighash', e);
    }
    if (e.indexOf('(') === -1) {
      const r = e.trim(),
        i = Object.keys(this.functions).filter(
          (s) =>
            s.split(
              '(',
              /* fix:) */
            )[0] === r,
        );
      return i.length === 0 ? Tt.throwArgumentError('no matching function', 'name', r) : i.length > 1 && Tt.throwArgumentError('multiple matching functions', 'name', r), this.functions[i[0]];
    }
    const t = this.functions[wr.fromString(e).format()];
    return t || Tt.throwArgumentError('no matching function', 'signature', e), t;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(e) {
    if (Ae(e)) {
      const r = e.toLowerCase();
      for (const i in this.events) if (r === this.getEventTopic(i)) return this.events[i];
      Tt.throwArgumentError('no matching event', 'topichash', r);
    }
    if (e.indexOf('(') === -1) {
      const r = e.trim(),
        i = Object.keys(this.events).filter(
          (s) =>
            s.split(
              '(',
              /* fix:) */
            )[0] === r,
        );
      return i.length === 0 ? Tt.throwArgumentError('no matching event', 'name', r) : i.length > 1 && Tt.throwArgumentError('multiple matching events', 'name', r), this.events[i[0]];
    }
    const t = this.events[$r.fromString(e).format()];
    return t || Tt.throwArgumentError('no matching event', 'signature', e), t;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(e) {
    if (Ae(e)) {
      const r = Er(this.constructor, 'getSighash');
      for (const i in this.errors) {
        const s = this.errors[i];
        if (e === r(s)) return this.errors[i];
      }
      Tt.throwArgumentError('no matching error', 'sighash', e);
    }
    if (e.indexOf('(') === -1) {
      const r = e.trim(),
        i = Object.keys(this.errors).filter(
          (s) =>
            s.split(
              '(',
              /* fix:) */
            )[0] === r,
        );
      return i.length === 0 ? Tt.throwArgumentError('no matching error', 'name', r) : i.length > 1 && Tt.throwArgumentError('multiple matching errors', 'name', r), this.errors[i[0]];
    }
    const t = this.errors[wr.fromString(e).format()];
    return t || Tt.throwArgumentError('no matching error', 'signature', e), t;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(e) {
    if (typeof e == 'string')
      try {
        e = this.getFunction(e);
      } catch (t) {
        try {
          e = this.getError(e);
        } catch {
          throw t;
        }
      }
    return Er(this.constructor, 'getSighash')(e);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(e) {
    return typeof e == 'string' && (e = this.getEvent(e)), Er(this.constructor, 'getEventTopic')(e);
  }
  _decodeParams(e, t) {
    return this._abiCoder.decode(e, t);
  }
  _encodeParams(e, t) {
    return this._abiCoder.encode(e, t);
  }
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  decodeErrorResult(e, t) {
    typeof e == 'string' && (e = this.getError(e));
    const r = H(t);
    return K(r.slice(0, 4)) !== this.getSighash(e) && Tt.throwArgumentError(`data signature does not match error ${e.name}.`, 'data', K(r)), this._decodeParams(e.inputs, r.slice(4));
  }
  encodeErrorResult(e, t) {
    return typeof e == 'string' && (e = this.getError(e)), K($e([this.getSighash(e), this._encodeParams(e.inputs, t || [])]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(e, t) {
    typeof e == 'string' && (e = this.getFunction(e));
    const r = H(t);
    return K(r.slice(0, 4)) !== this.getSighash(e) && Tt.throwArgumentError(`data signature does not match function ${e.name}.`, 'data', K(r)), this._decodeParams(e.inputs, r.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(e, t) {
    return typeof e == 'string' && (e = this.getFunction(e)), K($e([this.getSighash(e), this._encodeParams(e.inputs, t || [])]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(e, t) {
    typeof e == 'string' && (e = this.getFunction(e));
    let r = H(t),
      i = null,
      s = '',
      a = null,
      o = null,
      u = null;
    switch (r.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(e.outputs, r);
        } catch {}
        break;
      case 4: {
        const l = K(r.slice(0, 4)),
          p = pS[l];
        if (p)
          (a = this._abiCoder.decode(p.inputs, r.slice(4))),
            (o = p.name),
            (u = p.signature),
            p.reason && (i = a[0]),
            o === 'Error'
              ? (s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(a[0])}`)
              : o === 'Panic' && (s = `; VM Exception while processing transaction: reverted with panic code ${a[0]}`);
        else
          try {
            const h = this.getError(l);
            (a = this._abiCoder.decode(h.inputs, r.slice(4))), (o = h.name), (u = h.format());
          } catch {}
        break;
      }
    }
    return Tt.throwError('call revert exception' + s, O.errors.CALL_EXCEPTION, {
      method: e.format(),
      data: K(t),
      errorArgs: a,
      errorName: o,
      errorSignature: u,
      reason: i,
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(e, t) {
    return typeof e == 'string' && (e = this.getFunction(e)), K(this._abiCoder.encode(e.outputs, t || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, t) {
    typeof e == 'string' && (e = this.getEvent(e)),
      t.length > e.inputs.length &&
        Tt.throwError('too many arguments for ' + e.format(), O.errors.UNEXPECTED_ARGUMENT, {
          argument: 'values',
          value: t,
        });
    let r = [];
    e.anonymous || r.push(this.getEventTopic(e));
    const i = (s, a) =>
      s.type === 'string'
        ? ss(a)
        : s.type === 'bytes'
        ? Ie(K(a))
        : (s.type === 'bool' && typeof a == 'boolean' && (a = a ? '0x01' : '0x00'),
          s.type.match(/^u?int/) && (a = G.from(a).toHexString()),
          s.type === 'address' && this._abiCoder.encode(['address'], [a]),
          Be(K(a), 32));
    for (
      t.forEach((s, a) => {
        let o = e.inputs[a];
        if (!o.indexed) {
          s != null && Tt.throwArgumentError('cannot filter non-indexed parameters; must be null', 'contract.' + o.name, s);
          return;
        }
        s == null
          ? r.push(null)
          : o.baseType === 'array' || o.baseType === 'tuple'
          ? Tt.throwArgumentError('filtering with tuples or arrays not supported', 'contract.' + o.name, s)
          : Array.isArray(s)
          ? r.push(s.map((u) => i(o, u)))
          : r.push(i(o, s));
      });
      r.length && r[r.length - 1] === null;

    )
      r.pop();
    return r;
  }
  encodeEventLog(e, t) {
    typeof e == 'string' && (e = this.getEvent(e));
    const r = [],
      i = [],
      s = [];
    return (
      e.anonymous || r.push(this.getEventTopic(e)),
      t.length !== e.inputs.length && Tt.throwArgumentError('event arguments/values mismatch', 'values', t),
      e.inputs.forEach((a, o) => {
        const u = t[o];
        if (a.indexed)
          if (a.type === 'string') r.push(ss(u));
          else if (a.type === 'bytes') r.push(Ie(u));
          else {
            if (a.baseType === 'tuple' || a.baseType === 'array') throw new Error('not implemented');
            r.push(this._abiCoder.encode([a.type], [u]));
          }
        else i.push(a), s.push(u);
      }),
      {
        data: this._abiCoder.encode(i, s),
        topics: r,
      }
    );
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, t, r) {
    if ((typeof e == 'string' && (e = this.getEvent(e)), r != null && !e.anonymous)) {
      let b = this.getEventTopic(e);
      (!Ae(r[0], 32) || r[0].toLowerCase() !== b) && Tt.throwError('fragment/topic mismatch', O.errors.INVALID_ARGUMENT, { argument: 'topics[0]', expected: b, value: r[0] }), (r = r.slice(1));
    }
    let i = [],
      s = [],
      a = [];
    e.inputs.forEach((b, E) => {
      b.indexed
        ? b.type === 'string' || b.type === 'bytes' || b.baseType === 'tuple' || b.baseType === 'array'
          ? (i.push(zt.fromObject({ type: 'bytes32', name: b.name })), a.push(!0))
          : (i.push(b), a.push(!1))
        : (s.push(b), a.push(!1));
    });
    let o = r != null ? this._abiCoder.decode(i, $e(r)) : null,
      u = this._abiCoder.decode(s, t, !0),
      l = [],
      p = 0,
      h = 0;
    e.inputs.forEach((b, E) => {
      if (b.indexed)
        if (o == null) l[E] = new qc({ _isIndexed: !0, hash: null });
        else if (a[E]) l[E] = new qc({ _isIndexed: !0, hash: o[h++] });
        else
          try {
            l[E] = o[h++];
          } catch (x) {
            l[E] = x;
          }
      else
        try {
          l[E] = u[p++];
        } catch (x) {
          l[E] = x;
        }
      if (b.name && l[b.name] == null) {
        const x = l[E];
        x instanceof Error
          ? Object.defineProperty(l, b.name, {
              enumerable: !0,
              get: () => {
                throw Jg(`property ${JSON.stringify(b.name)}`, x);
              },
            })
          : (l[b.name] = x);
      }
    });
    for (let b = 0; b < l.length; b++) {
      const E = l[b];
      E instanceof Error &&
        Object.defineProperty(l, b, {
          enumerable: !0,
          get: () => {
            throw Jg(`index ${b}`, E);
          },
        });
    }
    return Object.freeze(l);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(e) {
    let t = this.getFunction(e.data.substring(0, 10).toLowerCase());
    return t
      ? new u6({
          args: this._abiCoder.decode(t.inputs, '0x' + e.data.substring(10)),
          functionFragment: t,
          name: t.name,
          signature: t.format(),
          sighash: this.getSighash(t),
          value: G.from(e.value || '0'),
        })
      : null;
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(e) {
    let t = this.getEvent(e.topics[0]);
    return !t || t.anonymous
      ? null
      : new o6({
          eventFragment: t,
          name: t.name,
          signature: t.format(),
          topic: this.getEventTopic(t),
          args: this.decodeEventLog(t, e.data, e.topics),
        });
  }
  parseError(e) {
    const t = K(e);
    let r = this.getError(t.substring(0, 10).toLowerCase());
    return r
      ? new dS({
          args: this._abiCoder.decode(r.inputs, '0x' + t.substring(10)),
          errorFragment: r,
          name: r.name,
          signature: r.format(),
          sighash: this.getSighash(r),
        })
      : null;
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(e) {
    return !!(e && e._isInterface);
  }
}
const fS = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        AbiCoder: W1,
        ConstructorFragment: xr,
        ErrorFragment: hi,
        EventFragment: $r,
        FormatTypes: Me,
        Fragment: Ur,
        FunctionFragment: wr,
        Indexed: qc,
        Interface: Xf,
        LogDescription: o6,
        ParamType: zt,
        TransactionDescription: u6,
        checkResultErrors: I1,
        defaultAbiCoder: J1,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  hS = 'abstract-provider/5.7.0';
var yS =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const mS = new O(hS);
class bS extends xs {
  static isForkEvent(e) {
    return !!(e && e._isForkEvent);
  }
}
let Gy = class l6 {
  constructor() {
    mS.checkAbstract(new.target, l6), U(this, '_isProvider', !0);
  }
  getFeeData() {
    return yS(this, void 0, void 0, function* () {
      const { block: e, gasPrice: t } = yield Mt({
        block: this.getBlock('latest'),
        gasPrice: this.getGasPrice().catch((a) => null),
      });
      let r = null,
        i = null,
        s = null;
      return (
        e && e.baseFeePerGas && ((r = e.baseFeePerGas), (s = G.from('1500000000')), (i = e.baseFeePerGas.mul(2).add(s))),
        { lastBaseFeePerGas: r, maxFeePerGas: i, maxPriorityFeePerGas: s, gasPrice: t }
      );
    });
  }
  // Alias for "on"
  addListener(e, t) {
    return this.on(e, t);
  }
  // Alias for "off"
  removeListener(e, t) {
    return this.off(e, t);
  }
  static isProvider(e) {
    return !!(e && e._isProvider);
  }
};
const gS = 'abstract-signer/5.7.0';
var yr =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const tr = new O(gS),
  vS = ['accessList', 'ccipReadEnabled', 'chainId', 'customData', 'data', 'from', 'gasLimit', 'gasPrice', 'maxFeePerGas', 'maxPriorityFeePerGas', 'nonce', 'to', 'type', 'value'],
  xS = [O.errors.INSUFFICIENT_FUNDS, O.errors.NONCE_EXPIRED, O.errors.REPLACEMENT_UNDERPRICED];
class _a {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    tr.checkAbstract(new.target, _a), U(this, '_isSigner', !0);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(e) {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider('getBalance'), yield this.provider.getBalance(this.getAddress(), e);
    });
  }
  getTransactionCount(e) {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider('getTransactionCount'), yield this.provider.getTransactionCount(this.getAddress(), e);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(e) {
    return yr(this, void 0, void 0, function* () {
      this._checkProvider('estimateGas');
      const t = yield Mt(this.checkTransaction(e));
      return yield this.provider.estimateGas(t);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(e, t) {
    return yr(this, void 0, void 0, function* () {
      this._checkProvider('call');
      const r = yield Mt(this.checkTransaction(e));
      return yield this.provider.call(r, t);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(e) {
    return yr(this, void 0, void 0, function* () {
      this._checkProvider('sendTransaction');
      const t = yield this.populateTransaction(e),
        r = yield this.signTransaction(t);
      return yield this.provider.sendTransaction(r);
    });
  }
  getChainId() {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider('getChainId'), (yield this.provider.getNetwork()).chainId;
    });
  }
  getGasPrice() {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider('getGasPrice'), yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider('getFeeData'), yield this.provider.getFeeData();
    });
  }
  resolveName(e) {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider('resolveName'), yield this.provider.resolveName(e);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(e) {
    for (const r in e) vS.indexOf(r) === -1 && tr.throwArgumentError('invalid transaction key: ' + r, 'transaction', e);
    const t = $t(e);
    return (
      t.from == null
        ? (t.from = this.getAddress())
        : (t.from = Promise.all([Promise.resolve(t.from), this.getAddress()]).then(
            (r) => (r[0].toLowerCase() !== r[1].toLowerCase() && tr.throwArgumentError('from address mismatch', 'transaction', e), r[0]),
          )),
      t
    );
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(e) {
    return yr(this, void 0, void 0, function* () {
      const t = yield Mt(this.checkTransaction(e));
      t.to != null &&
        ((t.to = Promise.resolve(t.to).then((i) =>
          yr(this, void 0, void 0, function* () {
            if (i == null) return null;
            const s = yield this.resolveName(i);
            return s == null && tr.throwArgumentError('provided ENS name resolves to null', 'tx.to', i), s;
          }),
        )),
        t.to.catch((i) => {}));
      const r = t.maxFeePerGas != null || t.maxPriorityFeePerGas != null;
      if (
        (t.gasPrice != null && (t.type === 2 || r)
          ? tr.throwArgumentError('eip-1559 transaction do not support gasPrice', 'transaction', e)
          : (t.type === 0 || t.type === 1) && r && tr.throwArgumentError('pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas', 'transaction', e),
        (t.type === 2 || t.type == null) && t.maxFeePerGas != null && t.maxPriorityFeePerGas != null)
      )
        t.type = 2;
      else if (t.type === 0 || t.type === 1) t.gasPrice == null && (t.gasPrice = this.getGasPrice());
      else {
        const i = yield this.getFeeData();
        if (t.type == null)
          if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
            if (((t.type = 2), t.gasPrice != null)) {
              const s = t.gasPrice;
              delete t.gasPrice, (t.maxFeePerGas = s), (t.maxPriorityFeePerGas = s);
            } else t.maxFeePerGas == null && (t.maxFeePerGas = i.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
          else
            i.gasPrice != null
              ? (r &&
                  tr.throwError('network does not support EIP-1559', O.errors.UNSUPPORTED_OPERATION, {
                    operation: 'populateTransaction',
                  }),
                t.gasPrice == null && (t.gasPrice = i.gasPrice),
                (t.type = 0))
              : tr.throwError('failed to get consistent fee data', O.errors.UNSUPPORTED_OPERATION, {
                  operation: 'signer.getFeeData',
                });
        else t.type === 2 && (t.maxFeePerGas == null && (t.maxFeePerGas = i.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
      }
      return (
        t.nonce == null && (t.nonce = this.getTransactionCount('pending')),
        t.gasLimit == null &&
          (t.gasLimit = this.estimateGas(t).catch((i) => {
            if (xS.indexOf(i.code) >= 0) throw i;
            return tr.throwError('cannot estimate gas; transaction may fail or may require manual gas limit', O.errors.UNPREDICTABLE_GAS_LIMIT, {
              error: i,
              tx: t,
            });
          })),
        t.chainId == null
          ? (t.chainId = this.getChainId())
          : (t.chainId = Promise.all([Promise.resolve(t.chainId), this.getChainId()]).then(
              (i) => (i[1] !== 0 && i[0] !== i[1] && tr.throwArgumentError('chainId address mismatch', 'transaction', e), i[0]),
            )),
        yield Mt(t)
      );
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(e) {
    this.provider ||
      tr.throwError('missing provider', O.errors.UNSUPPORTED_OPERATION, {
        operation: e || '_checkProvider',
      });
  }
  static isSigner(e) {
    return !!(e && e._isSigner);
  }
}
class Hy extends _a {
  constructor(e, t) {
    super(), U(this, 'address', e), U(this, 'provider', t || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(e, t) {
    return Promise.resolve().then(() => {
      tr.throwError(e, O.errors.UNSUPPORTED_OPERATION, { operation: t });
    });
  }
  signMessage(e) {
    return this._fail('VoidSigner cannot sign messages', 'signMessage');
  }
  signTransaction(e) {
    return this._fail('VoidSigner cannot sign transactions', 'signTransaction');
  }
  _signTypedData(e, t, r) {
    return this._fail('VoidSigner cannot sign typed data', 'signTypedData');
  }
  connect(e) {
    return new Hy(this.address, e);
  }
}
var vn = {},
  xe = {},
  xl = c6;
function c6(n, e) {
  if (!n) throw new Error(e || 'Assertion failed');
}
c6.equal = function (e, t, r) {
  if (e != t) throw new Error(r || 'Assertion failed: ' + e + ' != ' + t);
};
var Zf = {},
  Qg = {
    get exports() {
      return Zf;
    },
    set exports(n) {
      Zf = n;
    },
  };
typeof Object.create == 'function'
  ? (Qg.exports = function (e, t) {
      t &&
        ((e.super_ = t),
        (e.prototype = Object.create(t.prototype, {
          constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })));
    })
  : (Qg.exports = function (e, t) {
      if (t) {
        e.super_ = t;
        var r = function () {};
        (r.prototype = t.prototype), (e.prototype = new r()), (e.prototype.constructor = e);
      }
    });
var wS = xl,
  TS = Zf;
xe.inherits = TS;
function AS(n, e) {
  return (n.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= n.length ? !1 : (n.charCodeAt(e + 1) & 64512) === 56320;
}
function ES(n, e) {
  if (Array.isArray(n)) return n.slice();
  if (!n) return [];
  var t = [];
  if (typeof n == 'string')
    if (e) {
      if (e === 'hex') for (n = n.replace(/[^a-z0-9]+/gi, ''), n.length % 2 !== 0 && (n = '0' + n), i = 0; i < n.length; i += 2) t.push(parseInt(n[i] + n[i + 1], 16));
    } else
      for (var r = 0, i = 0; i < n.length; i++) {
        var s = n.charCodeAt(i);
        s < 128
          ? (t[r++] = s)
          : s < 2048
          ? ((t[r++] = (s >> 6) | 192), (t[r++] = (s & 63) | 128))
          : AS(n, i)
          ? ((s = 65536 + ((s & 1023) << 10) + (n.charCodeAt(++i) & 1023)), (t[r++] = (s >> 18) | 240), (t[r++] = ((s >> 12) & 63) | 128), (t[r++] = ((s >> 6) & 63) | 128), (t[r++] = (s & 63) | 128))
          : ((t[r++] = (s >> 12) | 224), (t[r++] = ((s >> 6) & 63) | 128), (t[r++] = (s & 63) | 128));
      }
  else for (i = 0; i < n.length; i++) t[i] = n[i] | 0;
  return t;
}
xe.toArray = ES;
function CS(n) {
  for (var e = '', t = 0; t < n.length; t++) e += p6(n[t].toString(16));
  return e;
}
xe.toHex = CS;
function d6(n) {
  var e = (n >>> 24) | ((n >>> 8) & 65280) | ((n << 8) & 16711680) | ((n & 255) << 24);
  return e >>> 0;
}
xe.htonl = d6;
function SS(n, e) {
  for (var t = '', r = 0; r < n.length; r++) {
    var i = n[r];
    e === 'little' && (i = d6(i)), (t += f6(i.toString(16)));
  }
  return t;
}
xe.toHex32 = SS;
function p6(n) {
  return n.length === 1 ? '0' + n : n;
}
xe.zero2 = p6;
function f6(n) {
  return n.length === 7
    ? '0' + n
    : n.length === 6
    ? '00' + n
    : n.length === 5
    ? '000' + n
    : n.length === 4
    ? '0000' + n
    : n.length === 3
    ? '00000' + n
    : n.length === 2
    ? '000000' + n
    : n.length === 1
    ? '0000000' + n
    : n;
}
xe.zero8 = f6;
function MS(n, e, t, r) {
  var i = t - e;
  wS(i % 4 === 0);
  for (var s = new Array(i / 4), a = 0, o = e; a < s.length; a++, o += 4) {
    var u;
    r === 'big' ? (u = (n[o] << 24) | (n[o + 1] << 16) | (n[o + 2] << 8) | n[o + 3]) : (u = (n[o + 3] << 24) | (n[o + 2] << 16) | (n[o + 1] << 8) | n[o]), (s[a] = u >>> 0);
  }
  return s;
}
xe.join32 = MS;
function _S(n, e) {
  for (var t = new Array(n.length * 4), r = 0, i = 0; r < n.length; r++, i += 4) {
    var s = n[r];
    e === 'big'
      ? ((t[i] = s >>> 24), (t[i + 1] = (s >>> 16) & 255), (t[i + 2] = (s >>> 8) & 255), (t[i + 3] = s & 255))
      : ((t[i + 3] = s >>> 24), (t[i + 2] = (s >>> 16) & 255), (t[i + 1] = (s >>> 8) & 255), (t[i] = s & 255));
  }
  return t;
}
xe.split32 = _S;
function RS(n, e) {
  return (n >>> e) | (n << (32 - e));
}
xe.rotr32 = RS;
function PS(n, e) {
  return (n << e) | (n >>> (32 - e));
}
xe.rotl32 = PS;
function IS(n, e) {
  return (n + e) >>> 0;
}
xe.sum32 = IS;
function kS(n, e, t) {
  return (n + e + t) >>> 0;
}
xe.sum32_3 = kS;
function OS(n, e, t, r) {
  return (n + e + t + r) >>> 0;
}
xe.sum32_4 = OS;
function BS(n, e, t, r, i) {
  return (n + e + t + r + i) >>> 0;
}
xe.sum32_5 = BS;
function NS(n, e, t, r) {
  var i = n[e],
    s = n[e + 1],
    a = (r + s) >>> 0,
    o = (a < r ? 1 : 0) + t + i;
  (n[e] = o >>> 0), (n[e + 1] = a);
}
xe.sum64 = NS;
function DS(n, e, t, r) {
  var i = (e + r) >>> 0,
    s = (i < e ? 1 : 0) + n + t;
  return s >>> 0;
}
xe.sum64_hi = DS;
function FS(n, e, t, r) {
  var i = e + r;
  return i >>> 0;
}
xe.sum64_lo = FS;
function LS(n, e, t, r, i, s, a, o) {
  var u = 0,
    l = e;
  (l = (l + r) >>> 0), (u += l < e ? 1 : 0), (l = (l + s) >>> 0), (u += l < s ? 1 : 0), (l = (l + o) >>> 0), (u += l < o ? 1 : 0);
  var p = n + t + i + a + u;
  return p >>> 0;
}
xe.sum64_4_hi = LS;
function $S(n, e, t, r, i, s, a, o) {
  var u = e + r + s + o;
  return u >>> 0;
}
xe.sum64_4_lo = $S;
function US(n, e, t, r, i, s, a, o, u, l) {
  var p = 0,
    h = e;
  (h = (h + r) >>> 0), (p += h < e ? 1 : 0), (h = (h + s) >>> 0), (p += h < s ? 1 : 0), (h = (h + o) >>> 0), (p += h < o ? 1 : 0), (h = (h + l) >>> 0), (p += h < l ? 1 : 0);
  var b = n + t + i + a + u + p;
  return b >>> 0;
}
xe.sum64_5_hi = US;
function jS(n, e, t, r, i, s, a, o, u, l) {
  var p = e + r + s + o + l;
  return p >>> 0;
}
xe.sum64_5_lo = jS;
function VS(n, e, t) {
  var r = (e << (32 - t)) | (n >>> t);
  return r >>> 0;
}
xe.rotr64_hi = VS;
function zS(n, e, t) {
  var r = (n << (32 - t)) | (e >>> t);
  return r >>> 0;
}
xe.rotr64_lo = zS;
function GS(n, e, t) {
  return n >>> t;
}
xe.shr64_hi = GS;
function HS(n, e, t) {
  var r = (n << (32 - t)) | (e >>> t);
  return r >>> 0;
}
xe.shr64_lo = HS;
var Ro = {},
  Yg = xe,
  KS = xl;
function Dd() {
  (this.pending = null),
    (this.pendingTotal = 0),
    (this.blockSize = this.constructor.blockSize),
    (this.outSize = this.constructor.outSize),
    (this.hmacStrength = this.constructor.hmacStrength),
    (this.padLength = this.constructor.padLength / 8),
    (this.endian = 'big'),
    (this._delta8 = this.blockSize / 8),
    (this._delta32 = this.blockSize / 32);
}
Ro.BlockHash = Dd;
Dd.prototype.update = function (e, t) {
  if (((e = Yg.toArray(e, t)), this.pending ? (this.pending = this.pending.concat(e)) : (this.pending = e), (this.pendingTotal += e.length), this.pending.length >= this._delta8)) {
    e = this.pending;
    var r = e.length % this._delta8;
    (this.pending = e.slice(e.length - r, e.length)), this.pending.length === 0 && (this.pending = null), (e = Yg.join32(e, 0, e.length - r, this.endian));
    for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32);
  }
  return this;
};
Dd.prototype.digest = function (e) {
  return this.update(this._pad()), KS(this.pending === null), this._digest(e);
};
Dd.prototype._pad = function () {
  var e = this.pendingTotal,
    t = this._delta8,
    r = t - ((e + this.padLength) % t),
    i = new Array(r + this.padLength);
  i[0] = 128;
  for (var s = 1; s < r; s++) i[s] = 0;
  if (((e <<= 3), this.endian === 'big')) {
    for (var a = 8; a < this.padLength; a++) i[s++] = 0;
    (i[s++] = 0), (i[s++] = 0), (i[s++] = 0), (i[s++] = 0), (i[s++] = (e >>> 24) & 255), (i[s++] = (e >>> 16) & 255), (i[s++] = (e >>> 8) & 255), (i[s++] = e & 255);
  } else
    for (i[s++] = e & 255, i[s++] = (e >>> 8) & 255, i[s++] = (e >>> 16) & 255, i[s++] = (e >>> 24) & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, a = 8; a < this.padLength; a++) i[s++] = 0;
  return i;
};
var Po = {},
  ri = {},
  qS = xe,
  Gr = qS.rotr32;
function WS(n, e, t, r) {
  if (n === 0) return h6(e, t, r);
  if (n === 1 || n === 3) return m6(e, t, r);
  if (n === 2) return y6(e, t, r);
}
ri.ft_1 = WS;
function h6(n, e, t) {
  return (n & e) ^ (~n & t);
}
ri.ch32 = h6;
function y6(n, e, t) {
  return (n & e) ^ (n & t) ^ (e & t);
}
ri.maj32 = y6;
function m6(n, e, t) {
  return n ^ e ^ t;
}
ri.p32 = m6;
function JS(n) {
  return Gr(n, 2) ^ Gr(n, 13) ^ Gr(n, 22);
}
ri.s0_256 = JS;
function QS(n) {
  return Gr(n, 6) ^ Gr(n, 11) ^ Gr(n, 25);
}
ri.s1_256 = QS;
function YS(n) {
  return Gr(n, 7) ^ Gr(n, 18) ^ (n >>> 3);
}
ri.g0_256 = YS;
function XS(n) {
  return Gr(n, 17) ^ Gr(n, 19) ^ (n >>> 10);
}
ri.g1_256 = XS;
var oo = xe,
  ZS = Ro,
  eM = ri,
  Wp = oo.rotl32,
  Uo = oo.sum32,
  tM = oo.sum32_5,
  nM = eM.ft_1,
  b6 = ZS.BlockHash,
  rM = [1518500249, 1859775393, 2400959708, 3395469782];
function Yr() {
  if (!(this instanceof Yr)) return new Yr();
  b6.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.W = new Array(80));
}
oo.inherits(Yr, b6);
var iM = Yr;
Yr.blockSize = 512;
Yr.outSize = 160;
Yr.hmacStrength = 80;
Yr.padLength = 64;
Yr.prototype._update = function (e, t) {
  for (var r = this.W, i = 0; i < 16; i++) r[i] = e[t + i];
  for (; i < r.length; i++) r[i] = Wp(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
  var s = this.h[0],
    a = this.h[1],
    o = this.h[2],
    u = this.h[3],
    l = this.h[4];
  for (i = 0; i < r.length; i++) {
    var p = ~~(i / 20),
      h = tM(Wp(s, 5), nM(p, a, o, u), l, r[i], rM[p]);
    (l = u), (u = o), (o = Wp(a, 30)), (a = s), (s = h);
  }
  (this.h[0] = Uo(this.h[0], s)), (this.h[1] = Uo(this.h[1], a)), (this.h[2] = Uo(this.h[2], o)), (this.h[3] = Uo(this.h[3], u)), (this.h[4] = Uo(this.h[4], l));
};
Yr.prototype._digest = function (e) {
  return e === 'hex' ? oo.toHex32(this.h, 'big') : oo.split32(this.h, 'big');
};
var uo = xe,
  sM = Ro,
  Io = ri,
  aM = xl,
  mr = uo.sum32,
  oM = uo.sum32_4,
  uM = uo.sum32_5,
  lM = Io.ch32,
  cM = Io.maj32,
  dM = Io.s0_256,
  pM = Io.s1_256,
  fM = Io.g0_256,
  hM = Io.g1_256,
  g6 = sM.BlockHash,
  yM = [
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ];
function Xr() {
  if (!(this instanceof Xr)) return new Xr();
  g6.call(this), (this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), (this.k = yM), (this.W = new Array(64));
}
uo.inherits(Xr, g6);
var v6 = Xr;
Xr.blockSize = 512;
Xr.outSize = 256;
Xr.hmacStrength = 192;
Xr.padLength = 64;
Xr.prototype._update = function (e, t) {
  for (var r = this.W, i = 0; i < 16; i++) r[i] = e[t + i];
  for (; i < r.length; i++) r[i] = oM(hM(r[i - 2]), r[i - 7], fM(r[i - 15]), r[i - 16]);
  var s = this.h[0],
    a = this.h[1],
    o = this.h[2],
    u = this.h[3],
    l = this.h[4],
    p = this.h[5],
    h = this.h[6],
    b = this.h[7];
  for (aM(this.k.length === r.length), i = 0; i < r.length; i++) {
    var E = uM(b, pM(l), lM(l, p, h), this.k[i], r[i]),
      x = mr(dM(s), cM(s, a, o));
    (b = h), (h = p), (p = l), (l = mr(u, E)), (u = o), (o = a), (a = s), (s = mr(E, x));
  }
  (this.h[0] = mr(this.h[0], s)),
    (this.h[1] = mr(this.h[1], a)),
    (this.h[2] = mr(this.h[2], o)),
    (this.h[3] = mr(this.h[3], u)),
    (this.h[4] = mr(this.h[4], l)),
    (this.h[5] = mr(this.h[5], p)),
    (this.h[6] = mr(this.h[6], h)),
    (this.h[7] = mr(this.h[7], b));
};
Xr.prototype._digest = function (e) {
  return e === 'hex' ? uo.toHex32(this.h, 'big') : uo.split32(this.h, 'big');
};
var eh = xe,
  x6 = v6;
function _i() {
  if (!(this instanceof _i)) return new _i();
  x6.call(this), (this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
}
eh.inherits(_i, x6);
var mM = _i;
_i.blockSize = 512;
_i.outSize = 224;
_i.hmacStrength = 192;
_i.padLength = 64;
_i.prototype._digest = function (e) {
  return e === 'hex' ? eh.toHex32(this.h.slice(0, 7), 'big') : eh.split32(this.h.slice(0, 7), 'big');
};
var Fn = xe,
  bM = Ro,
  gM = xl,
  Hr = Fn.rotr64_hi,
  Kr = Fn.rotr64_lo,
  w6 = Fn.shr64_hi,
  T6 = Fn.shr64_lo,
  Wi = Fn.sum64,
  Jp = Fn.sum64_hi,
  Qp = Fn.sum64_lo,
  vM = Fn.sum64_4_hi,
  xM = Fn.sum64_4_lo,
  wM = Fn.sum64_5_hi,
  TM = Fn.sum64_5_lo,
  A6 = bM.BlockHash,
  AM = [
    1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560,
    3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868,
    3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
    2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936,
    666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627,
    2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
    430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899,
    1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427,
    3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733,
    587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591,
  ];
function Rr() {
  if (!(this instanceof Rr)) return new Rr();
  A6.call(this),
    (this.h = [
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209,
    ]),
    (this.k = AM),
    (this.W = new Array(160));
}
Fn.inherits(Rr, A6);
var E6 = Rr;
Rr.blockSize = 1024;
Rr.outSize = 512;
Rr.hmacStrength = 192;
Rr.padLength = 128;
Rr.prototype._prepareBlock = function (e, t) {
  for (var r = this.W, i = 0; i < 32; i++) r[i] = e[t + i];
  for (; i < r.length; i += 2) {
    var s = BM(r[i - 4], r[i - 3]),
      a = NM(r[i - 4], r[i - 3]),
      o = r[i - 14],
      u = r[i - 13],
      l = kM(r[i - 30], r[i - 29]),
      p = OM(r[i - 30], r[i - 29]),
      h = r[i - 32],
      b = r[i - 31];
    (r[i] = vM(s, a, o, u, l, p, h, b)), (r[i + 1] = xM(s, a, o, u, l, p, h, b));
  }
};
Rr.prototype._update = function (e, t) {
  this._prepareBlock(e, t);
  var r = this.W,
    i = this.h[0],
    s = this.h[1],
    a = this.h[2],
    o = this.h[3],
    u = this.h[4],
    l = this.h[5],
    p = this.h[6],
    h = this.h[7],
    b = this.h[8],
    E = this.h[9],
    x = this.h[10],
    T = this.h[11],
    w = this.h[12],
    _ = this.h[13],
    k = this.h[14],
    D = this.h[15];
  gM(this.k.length === r.length);
  for (var N = 0; N < r.length; N += 2) {
    var B = k,
      j = D,
      q = PM(b, E),
      z = IM(b, E),
      Y = EM(b, E, x, T, w),
      ae = CM(b, E, x, T, w, _),
      J = this.k[N],
      oe = this.k[N + 1],
      S = r[N],
      c = r[N + 1],
      y = wM(B, j, q, z, Y, ae, J, oe, S, c),
      v = TM(B, j, q, z, Y, ae, J, oe, S, c);
    (B = _M(i, s)), (j = RM(i, s)), (q = SM(i, s, a, o, u)), (z = MM(i, s, a, o, u, l));
    var C = Jp(B, j, q, z),
      A = Qp(B, j, q, z);
    (k = w), (D = _), (w = x), (_ = T), (x = b), (T = E), (b = Jp(p, h, y, v)), (E = Qp(h, h, y, v)), (p = u), (h = l), (u = a), (l = o), (a = i), (o = s), (i = Jp(y, v, C, A)), (s = Qp(y, v, C, A));
  }
  Wi(this.h, 0, i, s), Wi(this.h, 2, a, o), Wi(this.h, 4, u, l), Wi(this.h, 6, p, h), Wi(this.h, 8, b, E), Wi(this.h, 10, x, T), Wi(this.h, 12, w, _), Wi(this.h, 14, k, D);
};
Rr.prototype._digest = function (e) {
  return e === 'hex' ? Fn.toHex32(this.h, 'big') : Fn.split32(this.h, 'big');
};
function EM(n, e, t, r, i) {
  var s = (n & t) ^ (~n & i);
  return s < 0 && (s += 4294967296), s;
}
function CM(n, e, t, r, i, s) {
  var a = (e & r) ^ (~e & s);
  return a < 0 && (a += 4294967296), a;
}
function SM(n, e, t, r, i) {
  var s = (n & t) ^ (n & i) ^ (t & i);
  return s < 0 && (s += 4294967296), s;
}
function MM(n, e, t, r, i, s) {
  var a = (e & r) ^ (e & s) ^ (r & s);
  return a < 0 && (a += 4294967296), a;
}
function _M(n, e) {
  var t = Hr(n, e, 28),
    r = Hr(e, n, 2),
    i = Hr(e, n, 7),
    s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function RM(n, e) {
  var t = Kr(n, e, 28),
    r = Kr(e, n, 2),
    i = Kr(e, n, 7),
    s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function PM(n, e) {
  var t = Hr(n, e, 14),
    r = Hr(n, e, 18),
    i = Hr(e, n, 9),
    s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function IM(n, e) {
  var t = Kr(n, e, 14),
    r = Kr(n, e, 18),
    i = Kr(e, n, 9),
    s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function kM(n, e) {
  var t = Hr(n, e, 1),
    r = Hr(n, e, 8),
    i = w6(n, e, 7),
    s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function OM(n, e) {
  var t = Kr(n, e, 1),
    r = Kr(n, e, 8),
    i = T6(n, e, 7),
    s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function BM(n, e) {
  var t = Hr(n, e, 19),
    r = Hr(e, n, 29),
    i = w6(n, e, 6),
    s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function NM(n, e) {
  var t = Kr(n, e, 19),
    r = Kr(e, n, 29),
    i = T6(n, e, 6),
    s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
var th = xe,
  C6 = E6;
function Ri() {
  if (!(this instanceof Ri)) return new Ri();
  C6.call(this),
    (this.h = [
      3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428,
    ]);
}
th.inherits(Ri, C6);
var DM = Ri;
Ri.blockSize = 1024;
Ri.outSize = 384;
Ri.hmacStrength = 192;
Ri.padLength = 128;
Ri.prototype._digest = function (e) {
  return e === 'hex' ? th.toHex32(this.h.slice(0, 12), 'big') : th.split32(this.h.slice(0, 12), 'big');
};
Po.sha1 = iM;
Po.sha224 = mM;
Po.sha256 = v6;
Po.sha384 = DM;
Po.sha512 = E6;
var S6 = {},
  ua = xe,
  FM = Ro,
  Kl = ua.rotl32,
  Xg = ua.sum32,
  jo = ua.sum32_3,
  Zg = ua.sum32_4,
  M6 = FM.BlockHash;
function Zr() {
  if (!(this instanceof Zr)) return new Zr();
  M6.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.endian = 'little');
}
ua.inherits(Zr, M6);
S6.ripemd160 = Zr;
Zr.blockSize = 512;
Zr.outSize = 160;
Zr.hmacStrength = 192;
Zr.padLength = 64;
Zr.prototype._update = function (e, t) {
  for (var r = this.h[0], i = this.h[1], s = this.h[2], a = this.h[3], o = this.h[4], u = r, l = i, p = s, h = a, b = o, E = 0; E < 80; E++) {
    var x = Xg(Kl(Zg(r, e2(E, i, s, a), e[UM[E] + t], LM(E)), VM[E]), o);
    (r = o), (o = a), (a = Kl(s, 10)), (s = i), (i = x), (x = Xg(Kl(Zg(u, e2(79 - E, l, p, h), e[jM[E] + t], $M(E)), zM[E]), b)), (u = b), (b = h), (h = Kl(p, 10)), (p = l), (l = x);
  }
  (x = jo(this.h[1], s, h)), (this.h[1] = jo(this.h[2], a, b)), (this.h[2] = jo(this.h[3], o, u)), (this.h[3] = jo(this.h[4], r, l)), (this.h[4] = jo(this.h[0], i, p)), (this.h[0] = x);
};
Zr.prototype._digest = function (e) {
  return e === 'hex' ? ua.toHex32(this.h, 'little') : ua.split32(this.h, 'little');
};
function e2(n, e, t, r) {
  return n <= 15 ? e ^ t ^ r : n <= 31 ? (e & t) | (~e & r) : n <= 47 ? (e | ~t) ^ r : n <= 63 ? (e & r) | (t & ~r) : e ^ (t | ~r);
}
function LM(n) {
  return n <= 15 ? 0 : n <= 31 ? 1518500249 : n <= 47 ? 1859775393 : n <= 63 ? 2400959708 : 2840853838;
}
function $M(n) {
  return n <= 15 ? 1352829926 : n <= 31 ? 1548603684 : n <= 47 ? 1836072691 : n <= 63 ? 2053994217 : 0;
}
var UM = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3,
    7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
  ],
  jM = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12,
    2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
  ],
  VM = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9,
    8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
  ],
  zM = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14,
    6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,
  ],
  GM = xe,
  HM = xl;
function lo(n, e, t) {
  if (!(this instanceof lo)) return new lo(n, e, t);
  (this.Hash = n), (this.blockSize = n.blockSize / 8), (this.outSize = n.outSize / 8), (this.inner = null), (this.outer = null), this._init(GM.toArray(e, t));
}
var KM = lo;
lo.prototype._init = function (e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), HM(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++) e.push(0);
  for (t = 0; t < e.length; t++) e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++) e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
lo.prototype.update = function (e, t) {
  return this.inner.update(e, t), this;
};
lo.prototype.digest = function (e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function (n) {
  var e = n;
  (e.utils = xe),
    (e.common = Ro),
    (e.sha = Po),
    (e.ripemd = S6),
    (e.hmac = KM),
    (e.sha1 = e.sha.sha1),
    (e.sha256 = e.sha.sha256),
    (e.sha224 = e.sha.sha224),
    (e.sha384 = e.sha.sha384),
    (e.sha512 = e.sha.sha512),
    (e.ripemd160 = e.ripemd.ripemd160);
})(vn);
function ko(n, e, t) {
  return (
    (t = {
      path: e,
      exports: {},
      require: function (r, i) {
        return qM(r, i ?? t.path);
      },
    }),
    n(t, t.exports),
    t.exports
  );
}
function qM() {
  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}
var Ky = _6;
function _6(n, e) {
  if (!n) throw new Error(e || 'Assertion failed');
}
_6.equal = function (e, t, r) {
  if (e != t) throw new Error(r || 'Assertion failed: ' + e + ' != ' + t);
};
var Cr = ko(function (n, e) {
    var t = e;
    function r(a, o) {
      if (Array.isArray(a)) return a.slice();
      if (!a) return [];
      var u = [];
      if (typeof a != 'string') {
        for (var l = 0; l < a.length; l++) u[l] = a[l] | 0;
        return u;
      }
      if (o === 'hex') {
        (a = a.replace(/[^a-z0-9]+/gi, '')), a.length % 2 !== 0 && (a = '0' + a);
        for (var l = 0; l < a.length; l += 2) u.push(parseInt(a[l] + a[l + 1], 16));
      } else
        for (var l = 0; l < a.length; l++) {
          var p = a.charCodeAt(l),
            h = p >> 8,
            b = p & 255;
          h ? u.push(h, b) : u.push(b);
        }
      return u;
    }
    t.toArray = r;
    function i(a) {
      return a.length === 1 ? '0' + a : a;
    }
    t.zero2 = i;
    function s(a) {
      for (var o = '', u = 0; u < a.length; u++) o += i(a[u].toString(16));
      return o;
    }
    (t.toHex = s),
      (t.encode = function (o, u) {
        return u === 'hex' ? s(o) : o;
      });
  }),
  Qn = ko(function (n, e) {
    var t = e;
    (t.assert = Ky), (t.toArray = Cr.toArray), (t.zero2 = Cr.zero2), (t.toHex = Cr.toHex), (t.encode = Cr.encode);
    function r(u, l, p) {
      var h = new Array(Math.max(u.bitLength(), p) + 1);
      h.fill(0);
      for (var b = 1 << (l + 1), E = u.clone(), x = 0; x < h.length; x++) {
        var T,
          w = E.andln(b - 1);
        E.isOdd() ? (w > (b >> 1) - 1 ? (T = (b >> 1) - w) : (T = w), E.isubn(T)) : (T = 0), (h[x] = T), E.iushrn(1);
      }
      return h;
    }
    t.getNAF = r;
    function i(u, l) {
      var p = [[], []];
      (u = u.clone()), (l = l.clone());
      for (var h = 0, b = 0, E; u.cmpn(-h) > 0 || l.cmpn(-b) > 0; ) {
        var x = (u.andln(3) + h) & 3,
          T = (l.andln(3) + b) & 3;
        x === 3 && (x = -1), T === 3 && (T = -1);
        var w;
        x & 1 ? ((E = (u.andln(7) + h) & 7), (E === 3 || E === 5) && T === 2 ? (w = -x) : (w = x)) : (w = 0), p[0].push(w);
        var _;
        T & 1 ? ((E = (l.andln(7) + b) & 7), (E === 3 || E === 5) && x === 2 ? (_ = -T) : (_ = T)) : (_ = 0),
          p[1].push(_),
          2 * h === w + 1 && (h = 1 - h),
          2 * b === _ + 1 && (b = 1 - b),
          u.iushrn(1),
          l.iushrn(1);
      }
      return p;
    }
    t.getJSF = i;
    function s(u, l, p) {
      var h = '_' + l;
      u.prototype[l] = function () {
        return this[h] !== void 0 ? this[h] : (this[h] = p.call(this));
      };
    }
    t.cachedProperty = s;
    function a(u) {
      return typeof u == 'string' ? t.toArray(u, 'hex') : u;
    }
    t.parseBytes = a;
    function o(u) {
      return new pe(u, 'hex', 'le');
    }
    t.intFromLE = o;
  }),
  Wc = Qn.getNAF,
  WM = Qn.getJSF,
  Jc = Qn.assert;
function Ts(n, e) {
  (this.type = n),
    (this.p = new pe(e.p, 16)),
    (this.red = e.prime ? pe.red(e.prime) : pe.mont(this.p)),
    (this.zero = new pe(0).toRed(this.red)),
    (this.one = new pe(1).toRed(this.red)),
    (this.two = new pe(2).toRed(this.red)),
    (this.n = e.n && new pe(e.n, 16)),
    (this.g = e.g && this.pointFromJSON(e.g, e.gRed)),
    (this._wnafT1 = new Array(4)),
    (this._wnafT2 = new Array(4)),
    (this._wnafT3 = new Array(4)),
    (this._wnafT4 = new Array(4)),
    (this._bitLength = this.n ? this.n.bitLength() : 0);
  var t = this.n && this.p.div(this.n);
  !t || t.cmpn(100) > 0 ? (this.redN = null) : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)));
}
var Ra = Ts;
Ts.prototype.point = function () {
  throw new Error('Not implemented');
};
Ts.prototype.validate = function () {
  throw new Error('Not implemented');
};
Ts.prototype._fixedNafMul = function (e, t) {
  Jc(e.precomputed);
  var r = e._getDoubles(),
    i = Wc(t, 1, this._bitLength),
    s = (1 << (r.step + 1)) - (r.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var a = [],
    o,
    u;
  for (o = 0; o < i.length; o += r.step) {
    u = 0;
    for (var l = o + r.step - 1; l >= o; l--) u = (u << 1) + i[l];
    a.push(u);
  }
  for (var p = this.jpoint(null, null, null), h = this.jpoint(null, null, null), b = s; b > 0; b--) {
    for (o = 0; o < a.length; o++) (u = a[o]), u === b ? (h = h.mixedAdd(r.points[o])) : u === -b && (h = h.mixedAdd(r.points[o].neg()));
    p = p.add(h);
  }
  return p.toP();
};
Ts.prototype._wnafMul = function (e, t) {
  var r = 4,
    i = e._getNAFPoints(r);
  r = i.wnd;
  for (var s = i.points, a = Wc(t, r, this._bitLength), o = this.jpoint(null, null, null), u = a.length - 1; u >= 0; u--) {
    for (var l = 0; u >= 0 && a[u] === 0; u--) l++;
    if ((u >= 0 && l++, (o = o.dblp(l)), u < 0)) break;
    var p = a[u];
    Jc(p !== 0),
      e.type === 'affine' ? (p > 0 ? (o = o.mixedAdd(s[(p - 1) >> 1])) : (o = o.mixedAdd(s[(-p - 1) >> 1].neg()))) : p > 0 ? (o = o.add(s[(p - 1) >> 1])) : (o = o.add(s[(-p - 1) >> 1].neg()));
  }
  return e.type === 'affine' ? o.toP() : o;
};
Ts.prototype._wnafMulAdd = function (e, t, r, i, s) {
  var a = this._wnafT1,
    o = this._wnafT2,
    u = this._wnafT3,
    l = 0,
    p,
    h,
    b;
  for (p = 0; p < i; p++) {
    b = t[p];
    var E = b._getNAFPoints(e);
    (a[p] = E.wnd), (o[p] = E.points);
  }
  for (p = i - 1; p >= 1; p -= 2) {
    var x = p - 1,
      T = p;
    if (a[x] !== 1 || a[T] !== 1) {
      (u[x] = Wc(r[x], a[x], this._bitLength)), (u[T] = Wc(r[T], a[T], this._bitLength)), (l = Math.max(u[x].length, l)), (l = Math.max(u[T].length, l));
      continue;
    }
    var w = [
      t[x],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      t[T],
      /* 7 */
    ];
    t[x].y.cmp(t[T].y) === 0
      ? ((w[1] = t[x].add(t[T])), (w[2] = t[x].toJ().mixedAdd(t[T].neg())))
      : t[x].y.cmp(t[T].y.redNeg()) === 0
      ? ((w[1] = t[x].toJ().mixedAdd(t[T])), (w[2] = t[x].add(t[T].neg())))
      : ((w[1] = t[x].toJ().mixedAdd(t[T])), (w[2] = t[x].toJ().mixedAdd(t[T].neg())));
    var _ = [
        -3 /* -1 -1 */, -1 /* -1 0 */, -5 /* -1 1 */, -7 /* 0 -1 */, 0 /* 0 0 */, 7 /* 0 1 */, 5 /* 1 -1 */, 1 /* 1 0 */, 3,
        /* 1 1 */
      ],
      k = WM(r[x], r[T]);
    for (l = Math.max(k[0].length, l), u[x] = new Array(l), u[T] = new Array(l), h = 0; h < l; h++) {
      var D = k[0][h] | 0,
        N = k[1][h] | 0;
      (u[x][h] = _[(D + 1) * 3 + (N + 1)]), (u[T][h] = 0), (o[x] = w);
    }
  }
  var B = this.jpoint(null, null, null),
    j = this._wnafT4;
  for (p = l; p >= 0; p--) {
    for (var q = 0; p >= 0; ) {
      var z = !0;
      for (h = 0; h < i; h++) (j[h] = u[h][p] | 0), j[h] !== 0 && (z = !1);
      if (!z) break;
      q++, p--;
    }
    if ((p >= 0 && q++, (B = B.dblp(q)), p < 0)) break;
    for (h = 0; h < i; h++) {
      var Y = j[h];
      Y !== 0 && (Y > 0 ? (b = o[h][(Y - 1) >> 1]) : Y < 0 && (b = o[h][(-Y - 1) >> 1].neg()), b.type === 'affine' ? (B = B.mixedAdd(b)) : (B = B.add(b)));
    }
  }
  for (p = 0; p < i; p++) o[p] = null;
  return s ? B : B.toP();
};
function pr(n, e) {
  (this.curve = n), (this.type = e), (this.precomputed = null);
}
Ts.BasePoint = pr;
pr.prototype.eq = function () {
  throw new Error('Not implemented');
};
pr.prototype.validate = function () {
  return this.curve.validate(this);
};
Ts.prototype.decodePoint = function (e, t) {
  e = Qn.toArray(e, t);
  var r = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
    e[0] === 6 ? Jc(e[e.length - 1] % 2 === 0) : e[0] === 7 && Jc(e[e.length - 1] % 2 === 1);
    var i = this.point(e.slice(1, 1 + r), e.slice(1 + r, 1 + 2 * r));
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r) return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
  throw new Error('Unknown point format');
};
pr.prototype.encodeCompressed = function (e) {
  return this.encode(e, !0);
};
pr.prototype._encode = function (e) {
  var t = this.curve.p.byteLength(),
    r = this.getX().toArray('be', t);
  return e ? [this.getY().isEven() ? 2 : 3].concat(r) : [4].concat(r, this.getY().toArray('be', t));
};
pr.prototype.encode = function (e, t) {
  return Qn.encode(this._encode(t), e);
};
pr.prototype.precompute = function (e) {
  if (this.precomputed) return this;
  var t = {
    doubles: null,
    naf: null,
    beta: null,
  };
  return (t.naf = this._getNAFPoints(8)), (t.doubles = this._getDoubles(4, e)), (t.beta = this._getBeta()), (this.precomputed = t), this;
};
pr.prototype._hasDoubles = function (e) {
  if (!this.precomputed) return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
pr.prototype._getDoubles = function (e, t) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  for (var r = [this], i = this, s = 0; s < t; s += e) {
    for (var a = 0; a < e; a++) i = i.dbl();
    r.push(i);
  }
  return {
    step: e,
    points: r,
  };
};
pr.prototype._getNAFPoints = function (e) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  for (var t = [this], r = (1 << e) - 1, i = r === 1 ? null : this.dbl(), s = 1; s < r; s++) t[s] = t[s - 1].add(i);
  return {
    wnd: e,
    points: t,
  };
};
pr.prototype._getBeta = function () {
  return null;
};
pr.prototype.dblp = function (e) {
  for (var t = this, r = 0; r < e; r++) t = t.dbl();
  return t;
};
var qy = ko(function (n) {
    typeof Object.create == 'function'
      ? (n.exports = function (t, r) {
          r &&
            ((t.super_ = r),
            (t.prototype = Object.create(r.prototype, {
              constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })));
        })
      : (n.exports = function (t, r) {
          if (r) {
            t.super_ = r;
            var i = function () {};
            (i.prototype = r.prototype), (t.prototype = new i()), (t.prototype.constructor = t);
          }
        });
  }),
  JM = Qn.assert;
function fr(n) {
  Ra.call(this, 'short', n),
    (this.a = new pe(n.a, 16).toRed(this.red)),
    (this.b = new pe(n.b, 16).toRed(this.red)),
    (this.tinv = this.two.redInvm()),
    (this.zeroA = this.a.fromRed().cmpn(0) === 0),
    (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
    (this.endo = this._getEndomorphism(n)),
    (this._endoWnafT1 = new Array(4)),
    (this._endoWnafT2 = new Array(4));
}
qy(fr, Ra);
var QM = fr;
fr.prototype._getEndomorphism = function (e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, r;
    if (e.beta) t = new pe(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      (t = i[0].cmp(i[1]) < 0 ? i[0] : i[1]), (t = t.toRed(this.red));
    }
    if (e.lambda) r = new pe(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(t)) === 0 ? (r = s[0]) : ((r = s[1]), JM(this.g.mul(r).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var a;
    return (
      e.basis
        ? (a = e.basis.map(function (o) {
            return {
              a: new pe(o.a, 16),
              b: new pe(o.b, 16),
            };
          }))
        : (a = this._getEndoBasis(r)),
      {
        beta: t,
        lambda: r,
        basis: a,
      }
    );
  }
};
fr.prototype._getEndoRoots = function (e) {
  var t = e === this.p ? this.red : pe.mont(e),
    r = new pe(2).toRed(t).redInvm(),
    i = r.redNeg(),
    s = new pe(3).toRed(t).redNeg().redSqrt().redMul(r),
    a = i.redAdd(s).fromRed(),
    o = i.redSub(s).fromRed();
  return [a, o];
};
fr.prototype._getEndoBasis = function (e) {
  for (
    var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r = e, i = this.n.clone(), s = new pe(1), a = new pe(0), o = new pe(0), u = new pe(1), l, p, h, b, E, x, T, w = 0, _, k;
    r.cmpn(0) !== 0;

  ) {
    var D = i.div(r);
    (_ = i.sub(D.mul(r))), (k = o.sub(D.mul(s)));
    var N = u.sub(D.mul(a));
    if (!h && _.cmp(t) < 0) (l = T.neg()), (p = s), (h = _.neg()), (b = k);
    else if (h && ++w === 2) break;
    (T = _), (i = r), (r = _), (o = s), (s = k), (u = a), (a = N);
  }
  (E = _.neg()), (x = k);
  var B = h.sqr().add(b.sqr()),
    j = E.sqr().add(x.sqr());
  return (
    j.cmp(B) >= 0 && ((E = l), (x = p)),
    h.negative && ((h = h.neg()), (b = b.neg())),
    E.negative && ((E = E.neg()), (x = x.neg())),
    [
      { a: h, b },
      { a: E, b: x },
    ]
  );
};
fr.prototype._endoSplit = function (e) {
  var t = this.endo.basis,
    r = t[0],
    i = t[1],
    s = i.b.mul(e).divRound(this.n),
    a = r.b.neg().mul(e).divRound(this.n),
    o = s.mul(r.a),
    u = a.mul(i.a),
    l = s.mul(r.b),
    p = a.mul(i.b),
    h = e.sub(o).sub(u),
    b = l.add(p).neg();
  return { k1: h, k2: b };
};
fr.prototype.pointFromX = function (e, t) {
  (e = new pe(e, 16)), e.red || (e = e.toRed(this.red));
  var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
    i = r.redSqrt();
  if (i.redSqr().redSub(r).cmp(this.zero) !== 0) throw new Error('invalid point');
  var s = i.fromRed().isOdd();
  return ((t && !s) || (!t && s)) && (i = i.redNeg()), this.point(e, i);
};
fr.prototype.validate = function (e) {
  if (e.inf) return !0;
  var t = e.x,
    r = e.y,
    i = this.a.redMul(t),
    s = t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);
  return r.redSqr().redISub(s).cmpn(0) === 0;
};
fr.prototype._endoWnafMulAdd = function (e, t, r) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, a = 0; a < e.length; a++) {
    var o = this._endoSplit(t[a]),
      u = e[a],
      l = u._getBeta();
    o.k1.negative && (o.k1.ineg(), (u = u.neg(!0))), o.k2.negative && (o.k2.ineg(), (l = l.neg(!0))), (i[a * 2] = u), (i[a * 2 + 1] = l), (s[a * 2] = o.k1), (s[a * 2 + 1] = o.k2);
  }
  for (var p = this._wnafMulAdd(1, i, s, a * 2, r), h = 0; h < a * 2; h++) (i[h] = null), (s[h] = null);
  return p;
};
function Qt(n, e, t, r) {
  Ra.BasePoint.call(this, n, 'affine'),
    e === null && t === null
      ? ((this.x = null), (this.y = null), (this.inf = !0))
      : ((this.x = new pe(e, 16)),
        (this.y = new pe(t, 16)),
        r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        (this.inf = !1));
}
qy(Qt, Ra.BasePoint);
fr.prototype.point = function (e, t, r) {
  return new Qt(this, e, t, r);
};
fr.prototype.pointFromJSON = function (e, t) {
  return Qt.fromJSON(this, e, t);
};
Qt.prototype._getBeta = function () {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta) return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var r = this.curve,
        i = function (s) {
          return r.point(s.x.redMul(r.endo.beta), s.y);
        };
      (e.beta = t),
        (t.precomputed = {
          beta: null,
          naf: e.naf && {
            wnd: e.naf.wnd,
            points: e.naf.points.map(i),
          },
          doubles: e.doubles && {
            step: e.doubles.step,
            points: e.doubles.points.map(i),
          },
        });
    }
    return t;
  }
};
Qt.prototype.toJSON = function () {
  return this.precomputed
    ? [
        this.x,
        this.y,
        this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1),
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1),
          },
        },
      ]
    : [this.x, this.y];
};
Qt.fromJSON = function (e, t, r) {
  typeof t == 'string' && (t = JSON.parse(t));
  var i = e.point(t[0], t[1], r);
  if (!t[2]) return i;
  function s(o) {
    return e.point(o[0], o[1], r);
  }
  var a = t[2];
  return (
    (i.precomputed = {
      beta: null,
      doubles: a.doubles && {
        step: a.doubles.step,
        points: [i].concat(a.doubles.points.map(s)),
      },
      naf: a.naf && {
        wnd: a.naf.wnd,
        points: [i].concat(a.naf.points.map(s)),
      },
    }),
    i
  );
};
Qt.prototype.inspect = function () {
  return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};
Qt.prototype.isInfinity = function () {
  return this.inf;
};
Qt.prototype.add = function (e) {
  if (this.inf) return e;
  if (e.inf) return this;
  if (this.eq(e)) return this.dbl();
  if (this.neg().eq(e)) return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var r = t.redSqr().redISub(this.x).redISub(e.x),
    i = t.redMul(this.x.redSub(r)).redISub(this.y);
  return this.curve.point(r, i);
};
Qt.prototype.dbl = function () {
  if (this.inf) return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0) return this.curve.point(null, null);
  var t = this.curve.a,
    r = this.x.redSqr(),
    i = e.redInvm(),
    s = r.redAdd(r).redIAdd(r).redIAdd(t).redMul(i),
    a = s.redSqr().redISub(this.x.redAdd(this.x)),
    o = s.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, o);
};
Qt.prototype.getX = function () {
  return this.x.fromRed();
};
Qt.prototype.getY = function () {
  return this.y.fromRed();
};
Qt.prototype.mul = function (e) {
  return (
    (e = new pe(e, 16)), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
  );
};
Qt.prototype.mulAdd = function (e, t, r) {
  var i = [this, t],
    s = [e, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
Qt.prototype.jmulAdd = function (e, t, r) {
  var i = [this, t],
    s = [e, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
Qt.prototype.eq = function (e) {
  return this === e || (this.inf === e.inf && (this.inf || (this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)));
};
Qt.prototype.neg = function (e) {
  if (this.inf) return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var r = this.precomputed,
      i = function (s) {
        return s.neg();
      };
    t.precomputed = {
      naf: r.naf && {
        wnd: r.naf.wnd,
        points: r.naf.points.map(i),
      },
      doubles: r.doubles && {
        step: r.doubles.step,
        points: r.doubles.points.map(i),
      },
    };
  }
  return t;
};
Qt.prototype.toJ = function () {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function on(n, e, t, r) {
  Ra.BasePoint.call(this, n, 'jacobian'),
    e === null && t === null && r === null
      ? ((this.x = this.curve.one), (this.y = this.curve.one), (this.z = new pe(0)))
      : ((this.x = new pe(e, 16)), (this.y = new pe(t, 16)), (this.z = new pe(r, 16))),
    this.x.red || (this.x = this.x.toRed(this.curve.red)),
    this.y.red || (this.y = this.y.toRed(this.curve.red)),
    this.z.red || (this.z = this.z.toRed(this.curve.red)),
    (this.zOne = this.z === this.curve.one);
}
qy(on, Ra.BasePoint);
fr.prototype.jpoint = function (e, t, r) {
  return new on(this, e, t, r);
};
on.prototype.toP = function () {
  if (this.isInfinity()) return this.curve.point(null, null);
  var e = this.z.redInvm(),
    t = e.redSqr(),
    r = this.x.redMul(t),
    i = this.y.redMul(t).redMul(e);
  return this.curve.point(r, i);
};
on.prototype.neg = function () {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
on.prototype.add = function (e) {
  if (this.isInfinity()) return e;
  if (e.isInfinity()) return this;
  var t = e.z.redSqr(),
    r = this.z.redSqr(),
    i = this.x.redMul(t),
    s = e.x.redMul(r),
    a = this.y.redMul(t.redMul(e.z)),
    o = e.y.redMul(r.redMul(this.z)),
    u = i.redSub(s),
    l = a.redSub(o);
  if (u.cmpn(0) === 0) return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var p = u.redSqr(),
    h = p.redMul(u),
    b = i.redMul(p),
    E = l.redSqr().redIAdd(h).redISub(b).redISub(b),
    x = l.redMul(b.redISub(E)).redISub(a.redMul(h)),
    T = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(E, x, T);
};
on.prototype.mixedAdd = function (e) {
  if (this.isInfinity()) return e.toJ();
  if (e.isInfinity()) return this;
  var t = this.z.redSqr(),
    r = this.x,
    i = e.x.redMul(t),
    s = this.y,
    a = e.y.redMul(t).redMul(this.z),
    o = r.redSub(i),
    u = s.redSub(a);
  if (o.cmpn(0) === 0) return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = o.redSqr(),
    p = l.redMul(o),
    h = r.redMul(l),
    b = u.redSqr().redIAdd(p).redISub(h).redISub(h),
    E = u.redMul(h.redISub(b)).redISub(s.redMul(p)),
    x = this.z.redMul(o);
  return this.curve.jpoint(b, E, x);
};
on.prototype.dblp = function (e) {
  if (e === 0) return this;
  if (this.isInfinity()) return this;
  if (!e) return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (t = 0; t < e; t++) r = r.dbl();
    return r;
  }
  var i = this.curve.a,
    s = this.curve.tinv,
    a = this.x,
    o = this.y,
    u = this.z,
    l = u.redSqr().redSqr(),
    p = o.redAdd(o);
  for (t = 0; t < e; t++) {
    var h = a.redSqr(),
      b = p.redSqr(),
      E = b.redSqr(),
      x = h.redAdd(h).redIAdd(h).redIAdd(i.redMul(l)),
      T = a.redMul(b),
      w = x.redSqr().redISub(T.redAdd(T)),
      _ = T.redISub(w),
      k = x.redMul(_);
    k = k.redIAdd(k).redISub(E);
    var D = p.redMul(u);
    t + 1 < e && (l = l.redMul(E)), (a = w), (u = D), (p = k);
  }
  return this.curve.jpoint(a, p.redMul(s), u);
};
on.prototype.dbl = function () {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
on.prototype._zeroDbl = function () {
  var e, t, r;
  if (this.zOne) {
    var i = this.x.redSqr(),
      s = this.y.redSqr(),
      a = s.redSqr(),
      o = this.x.redAdd(s).redSqr().redISub(i).redISub(a);
    o = o.redIAdd(o);
    var u = i.redAdd(i).redIAdd(i),
      l = u.redSqr().redISub(o).redISub(o),
      p = a.redIAdd(a);
    (p = p.redIAdd(p)), (p = p.redIAdd(p)), (e = l), (t = u.redMul(o.redISub(l)).redISub(p)), (r = this.y.redAdd(this.y));
  } else {
    var h = this.x.redSqr(),
      b = this.y.redSqr(),
      E = b.redSqr(),
      x = this.x.redAdd(b).redSqr().redISub(h).redISub(E);
    x = x.redIAdd(x);
    var T = h.redAdd(h).redIAdd(h),
      w = T.redSqr(),
      _ = E.redIAdd(E);
    (_ = _.redIAdd(_)), (_ = _.redIAdd(_)), (e = w.redISub(x).redISub(x)), (t = T.redMul(x.redISub(e)).redISub(_)), (r = this.y.redMul(this.z)), (r = r.redIAdd(r));
  }
  return this.curve.jpoint(e, t, r);
};
on.prototype._threeDbl = function () {
  var e, t, r;
  if (this.zOne) {
    var i = this.x.redSqr(),
      s = this.y.redSqr(),
      a = s.redSqr(),
      o = this.x.redAdd(s).redSqr().redISub(i).redISub(a);
    o = o.redIAdd(o);
    var u = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a),
      l = u.redSqr().redISub(o).redISub(o);
    e = l;
    var p = a.redIAdd(a);
    (p = p.redIAdd(p)), (p = p.redIAdd(p)), (t = u.redMul(o.redISub(l)).redISub(p)), (r = this.y.redAdd(this.y));
  } else {
    var h = this.z.redSqr(),
      b = this.y.redSqr(),
      E = this.x.redMul(b),
      x = this.x.redSub(h).redMul(this.x.redAdd(h));
    x = x.redAdd(x).redIAdd(x);
    var T = E.redIAdd(E);
    T = T.redIAdd(T);
    var w = T.redAdd(T);
    (e = x.redSqr().redISub(w)), (r = this.y.redAdd(this.z).redSqr().redISub(b).redISub(h));
    var _ = b.redSqr();
    (_ = _.redIAdd(_)), (_ = _.redIAdd(_)), (_ = _.redIAdd(_)), (t = x.redMul(T.redISub(e)).redISub(_));
  }
  return this.curve.jpoint(e, t, r);
};
on.prototype._dbl = function () {
  var e = this.curve.a,
    t = this.x,
    r = this.y,
    i = this.z,
    s = i.redSqr().redSqr(),
    a = t.redSqr(),
    o = r.redSqr(),
    u = a.redAdd(a).redIAdd(a).redIAdd(e.redMul(s)),
    l = t.redAdd(t);
  l = l.redIAdd(l);
  var p = l.redMul(o),
    h = u.redSqr().redISub(p.redAdd(p)),
    b = p.redISub(h),
    E = o.redSqr();
  (E = E.redIAdd(E)), (E = E.redIAdd(E)), (E = E.redIAdd(E));
  var x = u.redMul(b).redISub(E),
    T = r.redAdd(r).redMul(i);
  return this.curve.jpoint(h, x, T);
};
on.prototype.trpl = function () {
  if (!this.curve.zeroA) return this.dbl().add(this);
  var e = this.x.redSqr(),
    t = this.y.redSqr(),
    r = this.z.redSqr(),
    i = t.redSqr(),
    s = e.redAdd(e).redIAdd(e),
    a = s.redSqr(),
    o = this.x.redAdd(t).redSqr().redISub(e).redISub(i);
  (o = o.redIAdd(o)), (o = o.redAdd(o).redIAdd(o)), (o = o.redISub(a));
  var u = o.redSqr(),
    l = i.redIAdd(i);
  (l = l.redIAdd(l)), (l = l.redIAdd(l)), (l = l.redIAdd(l));
  var p = s.redIAdd(o).redSqr().redISub(a).redISub(u).redISub(l),
    h = t.redMul(p);
  (h = h.redIAdd(h)), (h = h.redIAdd(h));
  var b = this.x.redMul(u).redISub(h);
  (b = b.redIAdd(b)), (b = b.redIAdd(b));
  var E = this.y.redMul(p.redMul(l.redISub(p)).redISub(o.redMul(u)));
  (E = E.redIAdd(E)), (E = E.redIAdd(E)), (E = E.redIAdd(E));
  var x = this.z.redAdd(o).redSqr().redISub(r).redISub(u);
  return this.curve.jpoint(b, E, x);
};
on.prototype.mul = function (e, t) {
  return (e = new pe(e, t)), this.curve._wnafMul(this, e);
};
on.prototype.eq = function (e) {
  if (e.type === 'affine') return this.eq(e.toJ());
  if (this === e) return !0;
  var t = this.z.redSqr(),
    r = e.z.redSqr();
  if (this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0) !== 0) return !1;
  var i = t.redMul(this.z),
    s = r.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
on.prototype.eqXToP = function (e) {
  var t = this.z.redSqr(),
    r = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(r) === 0) return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(t); ; ) {
    if ((i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)) return !1;
    if ((r.redIAdd(s), this.x.cmp(r) === 0)) return !0;
  }
};
on.prototype.inspect = function () {
  return this.isInfinity() ? '<EC JPoint Infinity>' : '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
};
on.prototype.isInfinity = function () {
  return this.z.cmpn(0) === 0;
};
var hc = ko(function (n, e) {
    var t = e;
    (t.base = Ra), (t.short = QM), (t.mont = /*RicMoo:ethers:require(./mont)*/ null), (t.edwards = /*RicMoo:ethers:require(./edwards)*/ null);
  }),
  yc = ko(function (n, e) {
    var t = e,
      r = Qn.assert;
    function i(o) {
      o.type === 'short' ? (this.curve = new hc.short(o)) : o.type === 'edwards' ? (this.curve = new hc.edwards(o)) : (this.curve = new hc.mont(o)),
        (this.g = this.curve.g),
        (this.n = this.curve.n),
        (this.hash = o.hash),
        r(this.g.validate(), 'Invalid curve'),
        r(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
    }
    t.PresetCurve = i;
    function s(o, u) {
      Object.defineProperty(t, o, {
        configurable: !0,
        enumerable: !0,
        get: function () {
          var l = new i(u);
          return (
            Object.defineProperty(t, o, {
              configurable: !0,
              enumerable: !0,
              value: l,
            }),
            l
          );
        },
      });
    }
    s('p192', {
      type: 'short',
      prime: 'p192',
      p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
      a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
      b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
      n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
      hash: vn.sha256,
      gRed: !1,
      g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'],
    }),
      s('p224', {
        type: 'short',
        prime: 'p224',
        p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
        a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
        b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
        n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
        hash: vn.sha256,
        gRed: !1,
        g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'],
      }),
      s('p256', {
        type: 'short',
        prime: null,
        p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
        a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
        b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
        n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
        hash: vn.sha256,
        gRed: !1,
        g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'],
      }),
      s('p384', {
        type: 'short',
        prime: null,
        p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff',
        a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc',
        b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
        n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
        hash: vn.sha384,
        gRed: !1,
        g: [
          'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7',
          '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
        ],
      }),
      s('p521', {
        type: 'short',
        prime: null,
        p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff',
        a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc',
        b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
        n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
        hash: vn.sha512,
        gRed: !1,
        g: [
          '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
          '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650',
        ],
      }),
      s('curve25519', {
        type: 'mont',
        prime: 'p25519',
        p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
        a: '76d06',
        b: '1',
        n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
        hash: vn.sha256,
        gRed: !1,
        g: ['9'],
      }),
      s('ed25519', {
        type: 'edwards',
        prime: 'p25519',
        p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
        a: '-1',
        c: '1',
        // -121665 * (121666^(-1)) (mod P)
        d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
        n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
        hash: vn.sha256,
        gRed: !1,
        g: [
          '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
          // 4/5
          '6666666666666666666666666666666666666666666666666666666666666658',
        ],
      });
    var a;
    try {
      a = /*RicMoo:ethers:require(./precomputed/secp256k1)*/ null.crash();
    } catch {
      a = void 0;
    }
    s('secp256k1', {
      type: 'short',
      prime: 'k256',
      p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
      a: '0',
      b: '7',
      n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
      h: '1',
      hash: vn.sha256,
      // Precomputed endomorphism
      beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
      lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
      basis: [
        {
          a: '3086d221a7d46bcde86c90e49284eb15',
          b: '-e4437ed6010e88286f547fa90abfe4c3',
        },
        {
          a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
          b: '3086d221a7d46bcde86c90e49284eb15',
        },
      ],
      gRed: !1,
      g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', a],
    });
  });
function ms(n) {
  if (!(this instanceof ms)) return new ms(n);
  (this.hash = n.hash),
    (this.predResist = !!n.predResist),
    (this.outLen = this.hash.outSize),
    (this.minEntropy = n.minEntropy || this.hash.hmacStrength),
    (this._reseed = null),
    (this.reseedInterval = null),
    (this.K = null),
    (this.V = null);
  var e = Cr.toArray(n.entropy, n.entropyEnc || 'hex'),
    t = Cr.toArray(n.nonce, n.nonceEnc || 'hex'),
    r = Cr.toArray(n.pers, n.persEnc || 'hex');
  Ky(e.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'), this._init(e, t, r);
}
var R6 = ms;
ms.prototype._init = function (e, t, r) {
  var i = e.concat(t).concat(r);
  (this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8));
  for (var s = 0; s < this.V.length; s++) (this.K[s] = 0), (this.V[s] = 1);
  this._update(i), (this._reseed = 1), (this.reseedInterval = 281474976710656);
};
ms.prototype._hmac = function () {
  return new vn.hmac(this.hash, this.K);
};
ms.prototype._update = function (e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)),
    (this.K = t.digest()),
    (this.V = this._hmac().update(this.V).digest()),
    e && ((this.K = this._hmac().update(this.V).update([1]).update(e).digest()), (this.V = this._hmac().update(this.V).digest()));
};
ms.prototype.reseed = function (e, t, r, i) {
  typeof t != 'string' && ((i = r), (r = t), (t = null)),
    (e = Cr.toArray(e, t)),
    (r = Cr.toArray(r, i)),
    Ky(e.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'),
    this._update(e.concat(r || [])),
    (this._reseed = 1);
};
ms.prototype.generate = function (e, t, r, i) {
  if (this._reseed > this.reseedInterval) throw new Error('Reseed is required');
  typeof t != 'string' && ((i = r), (r = t), (t = null)), r && ((r = Cr.toArray(r, i || 'hex')), this._update(r));
  for (var s = []; s.length < e; ) (this.V = this._hmac().update(this.V).digest()), (s = s.concat(this.V));
  var a = s.slice(0, e);
  return this._update(r), this._reseed++, Cr.encode(a, t);
};
var nh = Qn.assert;
function mn(n, e) {
  (this.ec = n), (this.priv = null), (this.pub = null), e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var Wy = mn;
mn.fromPublic = function (e, t, r) {
  return t instanceof mn
    ? t
    : new mn(e, {
        pub: t,
        pubEnc: r,
      });
};
mn.fromPrivate = function (e, t, r) {
  return t instanceof mn
    ? t
    : new mn(e, {
        priv: t,
        privEnc: r,
      });
};
mn.prototype.validate = function () {
  var e = this.getPublic();
  return e.isInfinity()
    ? { result: !1, reason: 'Invalid public key' }
    : e.validate()
    ? e.mul(this.ec.curve.n).isInfinity()
      ? { result: !0, reason: null }
      : { result: !1, reason: 'Public key * N != O' }
    : { result: !1, reason: 'Public key is not a point' };
};
mn.prototype.getPublic = function (e, t) {
  return typeof e == 'string' && ((t = e), (e = null)), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;
};
mn.prototype.getPrivate = function (e) {
  return e === 'hex' ? this.priv.toString(16, 2) : this.priv;
};
mn.prototype._importPrivate = function (e, t) {
  (this.priv = new pe(e, t || 16)), (this.priv = this.priv.umod(this.ec.curve.n));
};
mn.prototype._importPublic = function (e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === 'mont' ? nh(e.x, 'Need x coordinate') : (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') && nh(e.x && e.y, 'Need both x and y coordinate'),
      (this.pub = this.ec.curve.point(e.x, e.y));
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
mn.prototype.derive = function (e) {
  return e.validate() || nh(e.validate(), 'public point not validated'), e.mul(this.priv).getX();
};
mn.prototype.sign = function (e, t, r) {
  return this.ec.sign(e, this, t, r);
};
mn.prototype.verify = function (e, t) {
  return this.ec.verify(e, t, this);
};
mn.prototype.inspect = function () {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};
var YM = Qn.assert;
function Fd(n, e) {
  if (n instanceof Fd) return n;
  this._importDER(n, e) ||
    (YM(n.r && n.s, 'Signature without r or s'),
    (this.r = new pe(n.r, 16)),
    (this.s = new pe(n.s, 16)),
    n.recoveryParam === void 0 ? (this.recoveryParam = null) : (this.recoveryParam = n.recoveryParam));
}
var Ld = Fd;
function XM() {
  this.place = 0;
}
function Yp(n, e) {
  var t = n[e.place++];
  if (!(t & 128)) return t;
  var r = t & 15;
  if (r === 0 || r > 4) return !1;
  for (var i = 0, s = 0, a = e.place; s < r; s++, a++) (i <<= 8), (i |= n[a]), (i >>>= 0);
  return i <= 127 ? !1 : ((e.place = a), i);
}
function t2(n) {
  for (var e = 0, t = n.length - 1; !n[e] && !(n[e + 1] & 128) && e < t; ) e++;
  return e === 0 ? n : n.slice(e);
}
Fd.prototype._importDER = function (e, t) {
  e = Qn.toArray(e, t);
  var r = new XM();
  if (e[r.place++] !== 48) return !1;
  var i = Yp(e, r);
  if (i === !1 || i + r.place !== e.length || e[r.place++] !== 2) return !1;
  var s = Yp(e, r);
  if (s === !1) return !1;
  var a = e.slice(r.place, s + r.place);
  if (((r.place += s), e[r.place++] !== 2)) return !1;
  var o = Yp(e, r);
  if (o === !1 || e.length !== o + r.place) return !1;
  var u = e.slice(r.place, o + r.place);
  if (a[0] === 0)
    if (a[1] & 128) a = a.slice(1);
    else return !1;
  if (u[0] === 0)
    if (u[1] & 128) u = u.slice(1);
    else return !1;
  return (this.r = new pe(a)), (this.s = new pe(u)), (this.recoveryParam = null), !0;
};
function Xp(n, e) {
  if (e < 128) {
    n.push(e);
    return;
  }
  var t = 1 + ((Math.log(e) / Math.LN2) >>> 3);
  for (n.push(t | 128); --t; ) n.push((e >>> (t << 3)) & 255);
  n.push(e);
}
Fd.prototype.toDER = function (e) {
  var t = this.r.toArray(),
    r = this.s.toArray();
  for (t[0] & 128 && (t = [0].concat(t)), r[0] & 128 && (r = [0].concat(r)), t = t2(t), r = t2(r); !r[0] && !(r[1] & 128); ) r = r.slice(1);
  var i = [2];
  Xp(i, t.length), (i = i.concat(t)), i.push(2), Xp(i, r.length);
  var s = i.concat(r),
    a = [48];
  return Xp(a, s.length), (a = a.concat(s)), Qn.encode(a, e);
};
var ZM =
    /*RicMoo:ethers:require(brorand)*/
    function () {
      throw new Error('unsupported');
    },
  P6 = Qn.assert;
function cr(n) {
  if (!(this instanceof cr)) return new cr(n);
  typeof n == 'string' && (P6(Object.prototype.hasOwnProperty.call(yc, n), 'Unknown curve ' + n), (n = yc[n])),
    n instanceof yc.PresetCurve && (n = { curve: n }),
    (this.curve = n.curve.curve),
    (this.n = this.curve.n),
    (this.nh = this.n.ushrn(1)),
    (this.g = this.curve.g),
    (this.g = n.curve.g),
    this.g.precompute(n.curve.n.bitLength() + 1),
    (this.hash = n.hash || n.curve.hash);
}
var e_ = cr;
cr.prototype.keyPair = function (e) {
  return new Wy(this, e);
};
cr.prototype.keyFromPrivate = function (e, t) {
  return Wy.fromPrivate(this, e, t);
};
cr.prototype.keyFromPublic = function (e, t) {
  return Wy.fromPublic(this, e, t);
};
cr.prototype.genKeyPair = function (e) {
  e || (e = {});
  for (
    var t = new R6({
        hash: this.hash,
        pers: e.pers,
        persEnc: e.persEnc || 'utf8',
        entropy: e.entropy || ZM(this.hash.hmacStrength),
        entropyEnc: (e.entropy && e.entropyEnc) || 'utf8',
        nonce: this.n.toArray(),
      }),
      r = this.n.byteLength(),
      i = this.n.sub(new pe(2));
    ;

  ) {
    var s = new pe(t.generate(r));
    if (!(s.cmp(i) > 0)) return s.iaddn(1), this.keyFromPrivate(s);
  }
};
cr.prototype._truncateToN = function (e, t) {
  var r = e.byteLength() * 8 - this.n.bitLength();
  return r > 0 && (e = e.ushrn(r)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
cr.prototype.sign = function (e, t, r, i) {
  typeof r == 'object' && ((i = r), (r = null)), i || (i = {}), (t = this.keyFromPrivate(t, r)), (e = this._truncateToN(new pe(e, 16)));
  for (
    var s = this.n.byteLength(),
      a = t.getPrivate().toArray('be', s),
      o = e.toArray('be', s),
      u = new R6({
        hash: this.hash,
        entropy: a,
        nonce: o,
        pers: i.pers,
        persEnc: i.persEnc || 'utf8',
      }),
      l = this.n.sub(new pe(1)),
      p = 0;
    ;
    p++
  ) {
    var h = i.k ? i.k(p) : new pe(u.generate(this.n.byteLength()));
    if (((h = this._truncateToN(h, !0)), !(h.cmpn(1) <= 0 || h.cmp(l) >= 0))) {
      var b = this.g.mul(h);
      if (!b.isInfinity()) {
        var E = b.getX(),
          x = E.umod(this.n);
        if (x.cmpn(0) !== 0) {
          var T = h.invm(this.n).mul(x.mul(t.getPrivate()).iadd(e));
          if (((T = T.umod(this.n)), T.cmpn(0) !== 0)) {
            var w = (b.getY().isOdd() ? 1 : 0) | (E.cmp(x) !== 0 ? 2 : 0);
            return i.canonical && T.cmp(this.nh) > 0 && ((T = this.n.sub(T)), (w ^= 1)), new Ld({ r: x, s: T, recoveryParam: w });
          }
        }
      }
    }
  }
};
cr.prototype.verify = function (e, t, r, i) {
  (e = this._truncateToN(new pe(e, 16))), (r = this.keyFromPublic(r, i)), (t = new Ld(t, 'hex'));
  var s = t.r,
    a = t.s;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0) return !1;
  var o = a.invm(this.n),
    u = o.mul(e).umod(this.n),
    l = o.mul(s).umod(this.n),
    p;
  return this.curve._maxwellTrick
    ? ((p = this.g.jmulAdd(u, r.getPublic(), l)), p.isInfinity() ? !1 : p.eqXToP(s))
    : ((p = this.g.mulAdd(u, r.getPublic(), l)), p.isInfinity() ? !1 : p.getX().umod(this.n).cmp(s) === 0);
};
cr.prototype.recoverPubKey = function (n, e, t, r) {
  P6((3 & t) === t, 'The recovery param is more than two bits'), (e = new Ld(e, r));
  var i = this.n,
    s = new pe(n),
    a = e.r,
    o = e.s,
    u = t & 1,
    l = t >> 1;
  if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l) throw new Error('Unable to find sencond key candinate');
  l ? (a = this.curve.pointFromX(a.add(this.curve.n), u)) : (a = this.curve.pointFromX(a, u));
  var p = e.r.invm(i),
    h = i.sub(s).mul(p).umod(i),
    b = o.mul(p).umod(i);
  return this.g.mulAdd(h, a, b);
};
cr.prototype.getKeyRecoveryParam = function (n, e, t, r) {
  if (((e = new Ld(e, r)), e.recoveryParam !== null)) return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(n, e, i);
    } catch {
      continue;
    }
    if (s.eq(t)) return i;
  }
  throw new Error('Unable to find valid recovery factor');
};
var t_ = ko(function (n, e) {
    var t = e;
    (t.version = '6.5.4'),
      (t.utils = Qn),
      (t.rand =
        /*RicMoo:ethers:require(brorand)*/
        function () {
          throw new Error('unsupported');
        }),
      (t.curve = hc),
      (t.curves = yc),
      (t.ec = e_),
      (t.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/ null);
  }),
  n_ = t_.ec;
const r_ = 'signing-key/5.7.0',
  rh = new O(r_);
let Zp = null;
function Dr() {
  return Zp || (Zp = new n_('secp256k1')), Zp;
}
class Zs {
  constructor(e) {
    U(this, 'curve', 'secp256k1'), U(this, 'privateKey', K(e)), Jr(this.privateKey) !== 32 && rh.throwArgumentError('invalid private key', 'privateKey', '[[ REDACTED ]]');
    const t = Dr().keyFromPrivate(H(this.privateKey));
    U(this, 'publicKey', '0x' + t.getPublic(!1, 'hex')), U(this, 'compressedPublicKey', '0x' + t.getPublic(!0, 'hex')), U(this, '_isSigningKey', !0);
  }
  _addPoint(e) {
    const t = Dr().keyFromPublic(H(this.publicKey)),
      r = Dr().keyFromPublic(H(e));
    return '0x' + t.pub.add(r.pub).encodeCompressed('hex');
  }
  signDigest(e) {
    const t = Dr().keyFromPrivate(H(this.privateKey)),
      r = H(e);
    r.length !== 32 && rh.throwArgumentError('bad digest length', 'digest', e);
    const i = t.sign(r, { canonical: !0 });
    return Sa({
      recoveryParam: i.recoveryParam,
      r: Be('0x' + i.r.toString(16), 32),
      s: Be('0x' + i.s.toString(16), 32),
    });
  }
  computeSharedSecret(e) {
    const t = Dr().keyFromPrivate(H(this.privateKey)),
      r = Dr().keyFromPublic(H(Jy(e)));
    return Be('0x' + t.derive(r.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function I6(n, e) {
  const t = Sa(e),
    r = { r: H(t.r), s: H(t.s) };
  return '0x' + Dr().recoverPubKey(H(n), r, t.recoveryParam).encode('hex', !1);
}
function Jy(n, e) {
  const t = H(n);
  if (t.length === 32) {
    const r = new Zs(t);
    return e ? '0x' + Dr().keyFromPrivate(t).getPublic(!0, 'hex') : r.publicKey;
  } else {
    if (t.length === 33) return e ? K(t) : '0x' + Dr().keyFromPublic(t).getPublic(!1, 'hex');
    if (t.length === 65) return e ? '0x' + Dr().keyFromPublic(t).getPublic(!0, 'hex') : K(t);
  }
  return rh.throwArgumentError('invalid public or private key', 'key', '[REDACTED]');
}
const i_ = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        SigningKey: Zs,
        computePublicKey: Jy,
        recoverPublicKey: I6,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  s_ = 'transactions/5.7.0',
  hn = new O(s_);
var ih;
(function (n) {
  (n[(n.legacy = 0)] = 'legacy'), (n[(n.eip2930 = 1)] = 'eip2930'), (n[(n.eip1559 = 2)] = 'eip1559');
})(ih || (ih = {}));
function Qy(n) {
  return n === '0x' ? null : Oe(n);
}
function pn(n) {
  return n === '0x' ? Fy : G.from(n);
}
const a_ = [
    { name: 'nonce', maxLength: 32, numeric: !0 },
    { name: 'gasPrice', maxLength: 32, numeric: !0 },
    { name: 'gasLimit', maxLength: 32, numeric: !0 },
    { name: 'to', length: 20 },
    { name: 'value', maxLength: 32, numeric: !0 },
    { name: 'data' },
  ],
  o_ = {
    chainId: !0,
    data: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    type: !0,
    value: !0,
  };
function us(n) {
  const e = Jy(n);
  return Oe(Bt(Ie(Bt(e, 1)), 12));
}
function Oo(n, e) {
  return us(I6(H(n), e));
}
function zn(n, e) {
  const t = zr(G.from(n).toHexString());
  return t.length > 32 && hn.throwArgumentError('invalid length for ' + e, 'transaction:' + e, n), t;
}
function ef(n, e) {
  return {
    address: Oe(n),
    storageKeys: (e || []).map((t, r) => (Jr(t) !== 32 && hn.throwArgumentError('invalid access list storageKey', `accessList[${n}:${r}]`, t), t.toLowerCase())),
  };
}
function Pa(n) {
  if (Array.isArray(n))
    return n.map((t, r) =>
      Array.isArray(t) ? (t.length > 2 && hn.throwArgumentError('access list expected to be [ address, storageKeys[] ]', `value[${r}]`, t), ef(t[0], t[1])) : ef(t.address, t.storageKeys),
    );
  const e = Object.keys(n).map((t) => {
    const r = n[t].reduce((i, s) => ((i[s] = !0), i), {});
    return ef(t, Object.keys(r).sort());
  });
  return e.sort((t, r) => t.address.localeCompare(r.address)), e;
}
function k6(n) {
  return Pa(n).map((e) => [e.address, e.storageKeys]);
}
function O6(n, e) {
  if (n.gasPrice != null) {
    const r = G.from(n.gasPrice),
      i = G.from(n.maxFeePerGas || 0);
    r.eq(i) ||
      hn.throwArgumentError('mismatch EIP-1559 gasPrice != maxFeePerGas', 'tx', {
        gasPrice: r,
        maxFeePerGas: i,
      });
  }
  const t = [
    zn(n.chainId || 0, 'chainId'),
    zn(n.nonce || 0, 'nonce'),
    zn(n.maxPriorityFeePerGas || 0, 'maxPriorityFeePerGas'),
    zn(n.maxFeePerGas || 0, 'maxFeePerGas'),
    zn(n.gasLimit || 0, 'gasLimit'),
    n.to != null ? Oe(n.to) : '0x',
    zn(n.value || 0, 'value'),
    n.data || '0x',
    k6(n.accessList || []),
  ];
  if (e) {
    const r = Sa(e);
    t.push(zn(r.recoveryParam, 'recoveryParam')), t.push(zr(r.r)), t.push(zr(r.s));
  }
  return xn(['0x02', ys(t)]);
}
function B6(n, e) {
  const t = [
    zn(n.chainId || 0, 'chainId'),
    zn(n.nonce || 0, 'nonce'),
    zn(n.gasPrice || 0, 'gasPrice'),
    zn(n.gasLimit || 0, 'gasLimit'),
    n.to != null ? Oe(n.to) : '0x',
    zn(n.value || 0, 'value'),
    n.data || '0x',
    k6(n.accessList || []),
  ];
  if (e) {
    const r = Sa(e);
    t.push(zn(r.recoveryParam, 'recoveryParam')), t.push(zr(r.r)), t.push(zr(r.s));
  }
  return xn(['0x01', ys(t)]);
}
function u_(n, e) {
  Oy(n, o_);
  const t = [];
  a_.forEach(function (a) {
    let o = n[a.name] || [];
    const u = {};
    a.numeric && (u.hexPad = 'left'),
      (o = H(K(o, u))),
      a.length && o.length !== a.length && o.length > 0 && hn.throwArgumentError('invalid length for ' + a.name, 'transaction:' + a.name, o),
      a.maxLength && ((o = zr(o)), o.length > a.maxLength && hn.throwArgumentError('invalid length for ' + a.name, 'transaction:' + a.name, o)),
      t.push(K(o));
  });
  let r = 0;
  if (
    (n.chainId != null
      ? ((r = n.chainId), typeof r != 'number' && hn.throwArgumentError('invalid transaction.chainId', 'transaction', n))
      : e && !bl(e) && e.v > 28 && (r = Math.floor((e.v - 35) / 2)),
    r !== 0 && (t.push(K(r)), t.push('0x'), t.push('0x')),
    !e)
  )
    return ys(t);
  const i = Sa(e);
  let s = 27 + i.recoveryParam;
  return (
    r !== 0
      ? (t.pop(), t.pop(), t.pop(), (s += r * 2 + 8), i.v > 28 && i.v !== s && hn.throwArgumentError('transaction.chainId/signature.v mismatch', 'signature', e))
      : i.v !== s && hn.throwArgumentError('transaction.chainId/signature.v mismatch', 'signature', e),
    t.push(K(s)),
    t.push(zr(H(i.r))),
    t.push(zr(H(i.s))),
    ys(t)
  );
}
function sh(n, e) {
  if (n.type == null || n.type === 0) return n.accessList != null && hn.throwArgumentError('untyped transactions do not support accessList; include type: 1', 'transaction', n), u_(n, e);
  switch (n.type) {
    case 1:
      return B6(n, e);
    case 2:
      return O6(n, e);
  }
  return hn.throwError(`unsupported transaction type: ${n.type}`, O.errors.UNSUPPORTED_OPERATION, {
    operation: 'serializeTransaction',
    transactionType: n.type,
  });
}
function N6(n, e, t) {
  try {
    const r = pn(e[0]).toNumber();
    if (r !== 0 && r !== 1) throw new Error('bad recid');
    n.v = r;
  } catch {
    hn.throwArgumentError('invalid v for transaction type: 1', 'v', e[0]);
  }
  (n.r = Be(e[1], 32)), (n.s = Be(e[2], 32));
  try {
    const r = Ie(t(n));
    n.from = Oo(r, { r: n.r, s: n.s, recoveryParam: n.v });
  } catch {}
}
function l_(n) {
  const e = vl(n.slice(1));
  e.length !== 9 && e.length !== 12 && hn.throwArgumentError('invalid component count for transaction type: 2', 'payload', K(n));
  const t = pn(e[2]),
    r = pn(e[3]),
    i = {
      type: 2,
      chainId: pn(e[0]).toNumber(),
      nonce: pn(e[1]).toNumber(),
      maxPriorityFeePerGas: t,
      maxFeePerGas: r,
      gasPrice: null,
      gasLimit: pn(e[4]),
      to: Qy(e[5]),
      value: pn(e[6]),
      data: e[7],
      accessList: Pa(e[8]),
    };
  return e.length === 9 || ((i.hash = Ie(n)), N6(i, e.slice(9), O6)), i;
}
function c_(n) {
  const e = vl(n.slice(1));
  e.length !== 8 && e.length !== 11 && hn.throwArgumentError('invalid component count for transaction type: 1', 'payload', K(n));
  const t = {
    type: 1,
    chainId: pn(e[0]).toNumber(),
    nonce: pn(e[1]).toNumber(),
    gasPrice: pn(e[2]),
    gasLimit: pn(e[3]),
    to: Qy(e[4]),
    value: pn(e[5]),
    data: e[6],
    accessList: Pa(e[7]),
  };
  return e.length === 8 || ((t.hash = Ie(n)), N6(t, e.slice(8), B6)), t;
}
function d_(n) {
  const e = vl(n);
  e.length !== 9 && e.length !== 6 && hn.throwArgumentError('invalid raw transaction', 'rawTransaction', n);
  const t = {
    nonce: pn(e[0]).toNumber(),
    gasPrice: pn(e[1]),
    gasLimit: pn(e[2]),
    to: Qy(e[3]),
    value: pn(e[4]),
    data: e[5],
    chainId: 0,
  };
  if (e.length === 6) return t;
  try {
    t.v = G.from(e[6]).toNumber();
  } catch {
    return t;
  }
  if (((t.r = Be(e[7], 32)), (t.s = Be(e[8], 32)), G.from(t.r).isZero() && G.from(t.s).isZero())) (t.chainId = t.v), (t.v = 0);
  else {
    (t.chainId = Math.floor((t.v - 35) / 2)), t.chainId < 0 && (t.chainId = 0);
    let r = t.v - 27;
    const i = e.slice(0, 6);
    t.chainId !== 0 && (i.push(K(t.chainId)), i.push('0x'), i.push('0x'), (r -= t.chainId * 2 + 8));
    const s = Ie(ys(i));
    try {
      t.from = Oo(s, { r: K(t.r), s: K(t.s), recoveryParam: r });
    } catch {}
    t.hash = Ie(n);
  }
  return (t.type = null), t;
}
function D6(n) {
  const e = H(n);
  if (e[0] > 127) return d_(e);
  switch (e[0]) {
    case 1:
      return c_(e);
    case 2:
      return l_(e);
  }
  return hn.throwError(`unsupported transaction type: ${e[0]}`, O.errors.UNSUPPORTED_OPERATION, {
    operation: 'parseTransaction',
    transactionType: e[0],
  });
}
const p_ = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        get TransactionTypes() {
          return ih;
        },
        accessListify: Pa,
        computeAddress: us,
        parse: D6,
        recoverAddress: Oo,
        serialize: sh,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  f_ = 'contracts/5.7.0';
var la =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const kt = new O(f_);
function Qc(n, e) {
  return la(this, void 0, void 0, function* () {
    const t = yield e;
    typeof t != 'string' && kt.throwArgumentError('invalid address or ENS name', 'name', t);
    try {
      return Oe(t);
    } catch {}
    n ||
      kt.throwError('a provider or signer is needed to resolve ENS names', O.errors.UNSUPPORTED_OPERATION, {
        operation: 'resolveName',
      });
    const r = yield n.resolveName(t);
    return r == null && kt.throwArgumentError('resolver or addr is not configured for ENS name', 'name', t), r;
  });
}
function mc(n, e, t) {
  return la(this, void 0, void 0, function* () {
    return Array.isArray(t)
      ? yield Promise.all(t.map((r, i) => mc(n, Array.isArray(e) ? e[i] : e[r.name], r)))
      : t.type === 'address'
      ? yield Qc(n, e)
      : t.type === 'tuple'
      ? yield mc(n, e, t.components)
      : t.baseType === 'array'
      ? Array.isArray(e)
        ? yield Promise.all(e.map((r) => mc(n, r, t.arrayChildren)))
        : Promise.reject(
            kt.makeError('invalid value for array', O.errors.INVALID_ARGUMENT, {
              argument: 'value',
              value: e,
            }),
          )
      : e;
  });
}
function $d(n, e, t) {
  return la(this, void 0, void 0, function* () {
    let r = {};
    t.length === e.inputs.length + 1 && typeof t[t.length - 1] == 'object' && (r = $t(t.pop())),
      kt.checkArgumentCount(t.length, e.inputs.length, 'passed to contract'),
      n.signer
        ? r.from
          ? (r.from = Mt({
              override: Qc(n.signer, r.from),
              signer: n.signer.getAddress(),
            }).then((l) =>
              la(this, void 0, void 0, function* () {
                return (
                  Oe(l.signer) !== l.override &&
                    kt.throwError('Contract with a Signer cannot override from', O.errors.UNSUPPORTED_OPERATION, {
                      operation: 'overrides.from',
                    }),
                  l.override
                );
              }),
            ))
          : (r.from = n.signer.getAddress())
        : r.from && (r.from = Qc(n.provider, r.from));
    const i = yield Mt({
        args: mc(n.signer || n.provider, t, e.inputs),
        address: n.resolvedAddress,
        overrides: Mt(r) || {},
      }),
      s = n.interface.encodeFunctionData(e, i.args),
      a = {
        data: s,
        to: i.address,
      },
      o = i.overrides;
    if (
      (o.nonce != null && (a.nonce = G.from(o.nonce).toNumber()),
      o.gasLimit != null && (a.gasLimit = G.from(o.gasLimit)),
      o.gasPrice != null && (a.gasPrice = G.from(o.gasPrice)),
      o.maxFeePerGas != null && (a.maxFeePerGas = G.from(o.maxFeePerGas)),
      o.maxPriorityFeePerGas != null && (a.maxPriorityFeePerGas = G.from(o.maxPriorityFeePerGas)),
      o.from != null && (a.from = o.from),
      o.type != null && (a.type = o.type),
      o.accessList != null && (a.accessList = Pa(o.accessList)),
      a.gasLimit == null && e.gas != null)
    ) {
      let l = 21e3;
      const p = H(s);
      for (let h = 0; h < p.length; h++) (l += 4), p[h] && (l += 64);
      a.gasLimit = G.from(e.gas).add(l);
    }
    if (o.value) {
      const l = G.from(o.value);
      !l.isZero() &&
        !e.payable &&
        kt.throwError('non-payable method cannot override value', O.errors.UNSUPPORTED_OPERATION, {
          operation: 'overrides.value',
          value: r.value,
        }),
        (a.value = l);
    }
    o.customData && (a.customData = $t(o.customData)),
      o.ccipReadEnabled && (a.ccipReadEnabled = !!o.ccipReadEnabled),
      delete r.nonce,
      delete r.gasLimit,
      delete r.gasPrice,
      delete r.from,
      delete r.value,
      delete r.type,
      delete r.accessList,
      delete r.maxFeePerGas,
      delete r.maxPriorityFeePerGas,
      delete r.customData,
      delete r.ccipReadEnabled;
    const u = Object.keys(r).filter((l) => r[l] != null);
    return (
      u.length &&
        kt.throwError(`cannot override ${u.map((l) => JSON.stringify(l)).join(',')}`, O.errors.UNSUPPORTED_OPERATION, {
          operation: 'overrides',
          overrides: u,
        }),
      a
    );
  });
}
function h_(n, e) {
  return function (...t) {
    return $d(n, e, t);
  };
}
function y_(n, e) {
  const t = n.signer || n.provider;
  return function (...r) {
    return la(this, void 0, void 0, function* () {
      t ||
        kt.throwError('estimate require a provider or signer', O.errors.UNSUPPORTED_OPERATION, {
          operation: 'estimateGas',
        });
      const i = yield $d(n, e, r);
      return yield t.estimateGas(i);
    });
  };
}
function m_(n, e) {
  const t = e.wait.bind(e);
  e.wait = (r) =>
    t(r).then(
      (i) => (
        (i.events = i.logs.map((s) => {
          let a = hs(s),
            o = null;
          try {
            o = n.interface.parseLog(s);
          } catch {}
          return (
            o && ((a.args = o.args), (a.decode = (u, l) => n.interface.decodeEventLog(o.eventFragment, u, l)), (a.event = o.name), (a.eventSignature = o.signature)),
            (a.removeListener = () => n.provider),
            (a.getBlock = () => n.provider.getBlock(i.blockHash)),
            (a.getTransaction = () => n.provider.getTransaction(i.transactionHash)),
            (a.getTransactionReceipt = () => Promise.resolve(i)),
            a
          );
        })),
        i
      ),
    );
}
function F6(n, e, t) {
  const r = n.signer || n.provider;
  return function (...i) {
    return la(this, void 0, void 0, function* () {
      let s;
      if (i.length === e.inputs.length + 1 && typeof i[i.length - 1] == 'object') {
        const u = $t(i.pop());
        u.blockTag != null && (s = yield u.blockTag), delete u.blockTag, i.push(u);
      }
      n.deployTransaction != null && (yield n._deployed(s));
      const a = yield $d(n, e, i),
        o = yield r.call(a, s);
      try {
        let u = n.interface.decodeFunctionResult(e, o);
        return t && e.outputs.length === 1 && (u = u[0]), u;
      } catch (u) {
        throw (u.code === O.errors.CALL_EXCEPTION && ((u.address = n.address), (u.args = i), (u.transaction = a)), u);
      }
    });
  };
}
function b_(n, e) {
  return function (...t) {
    return la(this, void 0, void 0, function* () {
      n.signer ||
        kt.throwError('sending a transaction requires a signer', O.errors.UNSUPPORTED_OPERATION, {
          operation: 'sendTransaction',
        }),
        n.deployTransaction != null && (yield n._deployed());
      const r = yield $d(n, e, t),
        i = yield n.signer.sendTransaction(r);
      return m_(n, i), i;
    });
  };
}
function n2(n, e, t) {
  return e.constant ? F6(n, e, t) : b_(n, e);
}
function L6(n) {
  return n.address && (n.topics == null || n.topics.length === 0) ? '*' : (n.address || '*') + '@' + (n.topics ? n.topics.map((e) => (Array.isArray(e) ? e.join('|') : e)).join(':') : '');
}
class Lu {
  constructor(e, t) {
    U(this, 'tag', e), U(this, 'filter', t), (this._listeners = []);
  }
  addListener(e, t) {
    this._listeners.push({ listener: e, once: t });
  }
  removeListener(e) {
    let t = !1;
    this._listeners = this._listeners.filter((r) => (t || r.listener !== e ? !0 : ((t = !0), !1)));
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((e) => e.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(e) {
    const t = this.listenerCount();
    return (
      (this._listeners = this._listeners.filter((r) => {
        const i = e.slice();
        return (
          setTimeout(() => {
            r.listener.apply(this, i);
          }, 0),
          !r.once
        );
      })),
      t
    );
  }
  prepareEvent(e) {}
  // Returns the array that will be applied to an emit
  getEmit(e) {
    return [e];
  }
}
class g_ extends Lu {
  constructor() {
    super('error', null);
  }
}
class r2 extends Lu {
  constructor(e, t, r, i) {
    const s = {
      address: e,
    };
    let a = t.getEventTopic(r);
    i ? (a !== i[0] && kt.throwArgumentError('topic mismatch', 'topics', i), (s.topics = i.slice())) : (s.topics = [a]),
      super(L6(s), s),
      U(this, 'address', e),
      U(this, 'interface', t),
      U(this, 'fragment', r);
  }
  prepareEvent(e) {
    super.prepareEvent(e), (e.event = this.fragment.name), (e.eventSignature = this.fragment.format()), (e.decode = (t, r) => this.interface.decodeEventLog(this.fragment, t, r));
    try {
      e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics);
    } catch (t) {
      (e.args = null), (e.decodeError = t);
    }
  }
  getEmit(e) {
    const t = I1(e.args);
    if (t.length) throw t[0].error;
    const r = (e.args || []).slice();
    return r.push(e), r;
  }
}
class i2 extends Lu {
  constructor(e, t) {
    super('*', { address: e }), U(this, 'address', e), U(this, 'interface', t);
  }
  prepareEvent(e) {
    super.prepareEvent(e);
    try {
      const t = this.interface.parseLog(e);
      (e.event = t.name), (e.eventSignature = t.signature), (e.decode = (r, i) => this.interface.decodeEventLog(t.eventFragment, r, i)), (e.args = t.args);
    } catch {}
  }
}
class v_ {
  constructor(e, t, r) {
    U(this, 'interface', Er(new.target, 'getInterface')(t)),
      r == null
        ? (U(this, 'provider', null), U(this, 'signer', null))
        : _a.isSigner(r)
        ? (U(this, 'provider', r.provider || null), U(this, 'signer', r))
        : Gy.isProvider(r)
        ? (U(this, 'provider', r), U(this, 'signer', null))
        : kt.throwArgumentError('invalid signer or provider', 'signerOrProvider', r),
      U(this, 'callStatic', {}),
      U(this, 'estimateGas', {}),
      U(this, 'functions', {}),
      U(this, 'populateTransaction', {}),
      U(this, 'filters', {});
    {
      const a = {};
      Object.keys(this.interface.events).forEach((o) => {
        const u = this.interface.events[o];
        U(this.filters, o, (...l) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(u, l),
        })),
          a[u.name] || (a[u.name] = []),
          a[u.name].push(o);
      }),
        Object.keys(a).forEach((o) => {
          const u = a[o];
          u.length === 1 ? U(this.filters, o, this.filters[u[0]]) : kt.warn(`Duplicate definition of ${o} (${u.join(', ')})`);
        });
    }
    if (
      (U(this, '_runningEvents', {}),
      U(this, '_wrappedEmits', {}),
      e == null && kt.throwArgumentError('invalid contract address or ENS name', 'addressOrName', e),
      U(this, 'address', e),
      this.provider)
    )
      U(this, 'resolvedAddress', Qc(this.provider, e));
    else
      try {
        U(this, 'resolvedAddress', Promise.resolve(Oe(e)));
      } catch {
        kt.throwError('provider is required to use ENS name as contract address', O.errors.UNSUPPORTED_OPERATION, {
          operation: 'new Contract',
        });
      }
    this.resolvedAddress.catch((a) => {});
    const i = {},
      s = {};
    Object.keys(this.interface.functions).forEach((a) => {
      const o = this.interface.functions[a];
      if (s[a]) {
        kt.warn(`Duplicate ABI entry for ${JSON.stringify(a)}`);
        return;
      }
      s[a] = !0;
      {
        const u = o.name;
        i[`%${u}`] || (i[`%${u}`] = []), i[`%${u}`].push(a);
      }
      this[a] == null && U(this, a, n2(this, o, !0)),
        this.functions[a] == null && U(this.functions, a, n2(this, o, !1)),
        this.callStatic[a] == null && U(this.callStatic, a, F6(this, o, !0)),
        this.populateTransaction[a] == null && U(this.populateTransaction, a, h_(this, o)),
        this.estimateGas[a] == null && U(this.estimateGas, a, y_(this, o));
    }),
      Object.keys(i).forEach((a) => {
        const o = i[a];
        if (o.length > 1) return;
        a = a.substring(1);
        const u = o[0];
        try {
          this[a] == null && U(this, a, this[u]);
        } catch {}
        this.functions[a] == null && U(this.functions, a, this.functions[u]),
          this.callStatic[a] == null && U(this.callStatic, a, this.callStatic[u]),
          this.populateTransaction[a] == null && U(this.populateTransaction, a, this.populateTransaction[u]),
          this.estimateGas[a] == null && U(this.estimateGas, a, this.estimateGas[u]);
      });
  }
  static getContractAddress(e) {
    return Dy(e);
  }
  static getInterface(e) {
    return Xf.isInterface(e) ? e : new Xf(e);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(e) {
    return (
      this._deployedPromise ||
        (this.deployTransaction
          ? (this._deployedPromise = this.deployTransaction.wait().then(() => this))
          : (this._deployedPromise = this.provider.getCode(this.address, e).then(
              (t) => (
                t === '0x' &&
                  kt.throwError('contract not deployed', O.errors.UNSUPPORTED_OPERATION, {
                    contractAddress: this.address,
                    operation: 'getDeployed',
                  }),
                this
              ),
            ))),
      this._deployedPromise
    );
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(e) {
    this.signer || kt.throwError('sending a transactions require a signer', O.errors.UNSUPPORTED_OPERATION, { operation: 'sendTransaction(fallback)' });
    const t = $t(e || {});
    return (
      ['from', 'to'].forEach(function (r) {
        t[r] != null && kt.throwError('cannot override ' + r, O.errors.UNSUPPORTED_OPERATION, { operation: r });
      }),
      (t.to = this.resolvedAddress),
      this.deployed().then(() => this.signer.sendTransaction(t))
    );
  }
  // Reconnect to a different signer or provider
  connect(e) {
    typeof e == 'string' && (e = new Hy(e, this.provider));
    const t = new this.constructor(this.address, this.interface, e);
    return this.deployTransaction && U(t, 'deployTransaction', this.deployTransaction), t;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(e) {
    return new this.constructor(e, this.interface, this.signer || this.provider);
  }
  static isIndexed(e) {
    return qc.isIndexed(e);
  }
  _normalizeRunningEvent(e) {
    return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e;
  }
  _getRunningEvent(e) {
    if (typeof e == 'string') {
      if (e === 'error') return this._normalizeRunningEvent(new g_());
      if (e === 'event') return this._normalizeRunningEvent(new Lu('event', null));
      if (e === '*') return this._normalizeRunningEvent(new i2(this.address, this.interface));
      const t = this.interface.getEvent(e);
      return this._normalizeRunningEvent(new r2(this.address, this.interface, t));
    }
    if (e.topics && e.topics.length > 0) {
      try {
        const r = e.topics[0];
        if (typeof r != 'string') throw new Error('invalid topic');
        const i = this.interface.getEvent(r);
        return this._normalizeRunningEvent(new r2(this.address, this.interface, i, e.topics));
      } catch {}
      const t = {
        address: this.address,
        topics: e.topics,
      };
      return this._normalizeRunningEvent(new Lu(L6(t), t));
    }
    return this._normalizeRunningEvent(new i2(this.address, this.interface));
  }
  _checkRunningEvents(e) {
    if (e.listenerCount() === 0) {
      delete this._runningEvents[e.tag];
      const t = this._wrappedEmits[e.tag];
      t && e.filter && (this.provider.off(e.filter, t), delete this._wrappedEmits[e.tag]);
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(e, t, r) {
    const i = hs(t);
    return (
      (i.removeListener = () => {
        r && (e.removeListener(r), this._checkRunningEvents(e));
      }),
      (i.getBlock = () => this.provider.getBlock(t.blockHash)),
      (i.getTransaction = () => this.provider.getTransaction(t.transactionHash)),
      (i.getTransactionReceipt = () => this.provider.getTransactionReceipt(t.transactionHash)),
      e.prepareEvent(i),
      i
    );
  }
  _addEventListener(e, t, r) {
    if (
      (this.provider || kt.throwError('events require a provider or a signer with a provider', O.errors.UNSUPPORTED_OPERATION, { operation: 'once' }),
      e.addListener(t, r),
      (this._runningEvents[e.tag] = e),
      !this._wrappedEmits[e.tag])
    ) {
      const i = (s) => {
        let a = this._wrapEvent(e, s, t);
        if (a.decodeError == null)
          try {
            const o = e.getEmit(a);
            this.emit(e.filter, ...o);
          } catch (o) {
            a.decodeError = o.error;
          }
        e.filter != null && this.emit('event', a), a.decodeError != null && this.emit('error', a.decodeError, a);
      };
      (this._wrappedEmits[e.tag] = i), e.filter != null && this.provider.on(e.filter, i);
    }
  }
  queryFilter(e, t, r) {
    const i = this._getRunningEvent(e),
      s = $t(i.filter);
    return (
      typeof t == 'string' && Ae(t, 32)
        ? (r != null && kt.throwArgumentError('cannot specify toBlock with blockhash', 'toBlock', r), (s.blockHash = t))
        : ((s.fromBlock = t ?? 0), (s.toBlock = r ?? 'latest')),
      this.provider.getLogs(s).then((a) => a.map((o) => this._wrapEvent(i, o, null)))
    );
  }
  on(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !1), this;
  }
  once(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !0), this;
  }
  emit(e, ...t) {
    if (!this.provider) return !1;
    const r = this._getRunningEvent(e),
      i = r.run(t) > 0;
    return this._checkRunningEvents(r), i;
  }
  listenerCount(e) {
    return this.provider ? (e == null ? Object.keys(this._runningEvents).reduce((t, r) => t + this._runningEvents[r].listenerCount(), 0) : this._getRunningEvent(e).listenerCount()) : 0;
  }
  listeners(e) {
    if (!this.provider) return [];
    if (e == null) {
      const t = [];
      for (let r in this._runningEvents)
        this._runningEvents[r].listeners().forEach((i) => {
          t.push(i);
        });
      return t;
    }
    return this._getRunningEvent(e).listeners();
  }
  removeAllListeners(e) {
    if (!this.provider) return this;
    if (e == null) {
      for (const r in this._runningEvents) {
        const i = this._runningEvents[r];
        i.removeAllListeners(), this._checkRunningEvents(i);
      }
      return this;
    }
    const t = this._getRunningEvent(e);
    return t.removeAllListeners(), this._checkRunningEvents(t), this;
  }
  off(e, t) {
    if (!this.provider) return this;
    const r = this._getRunningEvent(e);
    return r.removeListener(t), this._checkRunningEvents(r), this;
  }
  removeListener(e, t) {
    return this.off(e, t);
  }
}
class $6 extends v_ {}
var x_ = Object.defineProperty,
  w_ = Object.getOwnPropertyDescriptor,
  U6 = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? w_(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && x_(e, t, i), i;
  },
  s2 = (n, e) => (t, r) => e(t, r, n);
const Bo = he.createInterface();
let co = class {
  constructor(n, e) {
    (this.cacheService = n), (this.readOnlyProvider = e);
  }
  static register(n) {
    fe.singleton(Bo, co).register(n);
  }
  /**
   * get a Promise of a PopulatedTransaction that can be used to sign
   * and manually send transactions.
   * Uses the `populateTransaction` method supplied by ethers.js.
   *
   * @param contract
   * @param subFunctionName the name of the contract function
   * @param params
   * @returns
   */
  callPopulateTransaction(n, e, ...t) {
    return n.populateTransaction[e].call(t);
  }
  async getContract(n, e, t, r) {
    const a = (
      jE
        ? await jp(
            /* @__PURE__ */ Object.assign({
              '../../contracts/governance/celo-test.json': () => Promise.resolve().then(() => DO),
              '../../contracts/monetary/celo-test.json': () => Promise.resolve().then(() => LO),
            }),
            `../../contracts/${n}/celo-test.json`,
          )
        : await jp(
            /* @__PURE__ */ Object.assign({
              '../../contracts/governance/celo.json': () => Promise.resolve().then(() => UO),
              '../../contracts/map/celo.json': () => Promise.resolve().then(() => VO),
              '../../contracts/monetary/celo.json': () => Promise.resolve().then(() => GO),
            }),
            `../../contracts/${n}/celo.json`,
          )
    ).contracts[e];
    let o = a.abi;
    if ((o || (o = 'ERC20'), typeof o == 'string')) {
      const u = o;
      o = await this.getSharedAbi(n, u);
    }
    if (((t = t ?? a.address), !t)) throw new Error(`ContractService: requested contract has no address: ${e}`);
    return new $6(t, o, r ?? this.readOnlyProvider);
  }
  async getSharedAbi(n, e) {
    return (
      await jp(
        /* @__PURE__ */ Object.assign({
          '../../contracts/governance/sharedAbis.json': () => Promise.resolve().then(() => KO),
          '../../contracts/map/sharedAbis.json': () => Promise.resolve().then(() => WO),
          '../../contracts/monetary/sharedAbis.json': () => Promise.resolve().then(() => QO),
        }),
        `../../contracts/${n}/sharedAbis.json`,
      )
    )[e];
  }
};
U6(
  [
    x1(function () {
      return { storage: this.cacheService };
    }),
  ],
  co.prototype,
  'getContract',
  1,
);
co = U6([s2(0, ml), s2(1, kd)], co);
const j6 = he.createInterface(),
  T_ = 'https://raw.githubusercontent.com/Kolektivo/tokenlists/main/tokenlist.json',
  A_ =
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    globalThis.fetch !== void 0
      ? await fetch(T_, {
          method: 'GET',
          headers: { accept: 'application/json' },
        })
          .then(async (n) => await n.json())
          .then((n) => n.tokens)
      : [];
var E_ = Object.defineProperty,
  C_ = Object.getOwnPropertyDescriptor,
  S_ = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? C_(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && E_(e, t, i), i;
  },
  M_ = (n, e) => (t, r) => e(t, r, n);
const V6 = he.createInterface(),
  Yy = he.createInterface();
let $u = class {
  constructor(n) {
    this.container = n;
  }
  static register(n) {
    n.register(fe.singleton(Yy, $u));
  }
  fireStore;
  async connect() {
    const { getFirestore: n } = await Promise.resolve().then(() => ov);
    return (this.fireStore ??= n(await this.container.get(V6))), this.fireStore;
  }
  async getDocs(n, e, t, r) {
    const { getDocs: i, query: s, collection: a, where: o, orderBy: u } = await Promise.resolve().then(() => ov);
    return (await i(s(a(await this.connect(), n), o(r.fieldPath, r.opStr, r.value), u(e, t)))).docs.map((p) => p.data());
  }
};
$u = S_([M_(0, xo)], $u);
var __ = Object.defineProperty,
  R_ = Object.getOwnPropertyDescriptor,
  P_ = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? R_(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && __(e, t, i), i;
  },
  I_ = (n, e) => (t, r) => e(t, r, n);
const wl = he.createInterface('NumberService');
let Uu = class {
  constructor(n) {
    this.i18n = n;
  }
  static register(n) {
    n.register(fe.singleton(wl, Uu));
  }
  /**
   * Returns a string from a number or BigNumber.
   * @param value
   * @param format
   */
  toString(n, e) {
    if (n === null || typeof n > 'u' || typeof n == 'string') return n;
    if ((G.isBigNumber(n) && (n = n.toNumber()), Number.isNaN(n))) return 'NaN';
    const t = e?.useGrouping ?? !0,
      r = e?.isPercentage ?? !1,
      i = e?.isCurrency ?? !1;
    let s = this.fromString(e?.fractionDigits);
    isNaN(s) && (s = 2);
    const a = i ? { style: 'currency', currency: 'USD' } : r ? { style: 'percent' } : { style: 'decimal' };
    return this.i18n.nf(
      n,
      Object.assign(a, {
        useGrouping: t,
        minimumFractionDigits: s,
        maximumFractionDigits: s,
      }),
    );
  }
  /**
   * returns number from string.
   * @param value the value
   */
  fromString(n) {
    return n === null || typeof n > 'u' ? NaN : typeof n == 'number' ? n : this.i18n.uf(n);
  }
};
Uu = P_([I_(0, Aa)], Uu);
var k_ = Object.defineProperty,
  O_ = Object.getOwnPropertyDescriptor,
  z6 = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? O_(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && k_(e, t, i), i;
  },
  tf = (n, e) => (t, r) => e(t, r, n);
const Xy = he.createInterface();
let po = class {
  constructor(n, e, t) {
    (this.cacheService = n), (this.contractService = e), (this.readonlyProvider = t);
  }
  static register(n) {
    fe.singleton(Xy, po).register(n);
  }
  async getTokenContract(n, e, t) {
    const r = e ? await this.contractService.getSharedAbi('monetary', 'ERC721') : await this.contractService.getSharedAbi('monetary', 'ERC20');
    return new $6(n, r, t ?? this.readonlyProvider);
  }
};
z6(
  [
    x1(function () {
      return { storage: this.cacheService };
    }),
  ],
  po.prototype,
  'getTokenContract',
  1,
);
po = z6([tf(0, ml), tf(1, Bo), tf(2, kd)], po);
var fu = /* @__PURE__ */ ((n) => ((n[(n.Low = 0)] = 'Low'), (n[(n.Medium = 1)] = 'Medium'), (n[(n.High = 2)] = 'High'), n))(fu || {});
const B_ = he.createInterface();
var N_ = Object.defineProperty,
  D_ = Object.getOwnPropertyDescriptor,
  F_ = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? D_(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && N_(e, t, i), i;
  },
  L_ = (n, e) => (t, r) => e(t, r, n);
const Zy = he.createInterface();
let Yc = class {
  constructor(n) {
    this.client = n;
  }
  static register(n) {
    n.register(fe.singleton(Zy, Yc));
  }
  async all(n) {
    const e = [];
    for await (const t of n) e.push(t);
    return e;
  }
  save(n, e = !0) {
    return typeof n == 'string'
      ? this.client
          .add(
            { content: n },
            {
              pin: e,
            },
          )
          .then((t) => t.cid)
      : this.client.dag.put(n, {
          pin: e,
        });
  }
  async get(n, e = !1, t) {
    const r = (await Promise.resolve().then(() => HB)).CID.asCID(n);
    if (r) {
      if (!e) {
        const i = this.client.cat(n),
          s = (await Promise.resolve().then(() => qB)).concat(await this.all(i));
        return (await Promise.resolve().then(() => wN)).toString(s);
      }
      return JSON.stringify((await this.client.dag.get(r, { path: t })).value);
    }
  }
};
Yc = F_([L_(0, B_)], Yc);
const $_ = '@kolektivo/dapp',
  U_ = 'A collection of institutional technologies that open up new opportunities for local communities to govern and finance their own regenerative economies.',
  j_ = '1.0.0',
  V_ = {
    type: 'git',
    url: 'https://github.com/Kolektivo/dapp',
  },
  z_ = 'CL Cybernetix GmbH',
  G_ = './',
  H_ = 'MIT',
  K_ = {
    node: '>=16.0.0',
  },
  q_ = {
    http: !1,
  },
  W_ = {
    'lint:js': 'eslint src --ext .js,.ts',
    'lint:fix': 'eslint src  --fix',
    'lint:scss:fix': 'stylelint "src/**/*.scss" --fix',
    'lint:scss': 'stylelint "src/**/*.scss"',
    'lint:html': 'htmlhint -c .htmlhintrc src design-system ',
    lint: 'npm run lint:js && npm run lint:html',
    clean: 'npx -y rimraf node_modules package-lock.json && npm i',
    dev: 'vite',
    start: 'vite',
    typecheck: 'tsc',
    build: 'tsc && vite build',
    'build:chart-data-script': 'vite build --config vite.config-lib.ts',
    'build:dev:chart-data-script': 'vite build --config vite.config-lib.ts --mode development',
    'build:dev': 'vite build --mode development',
    'preview-build': 'vite preview --open',
    postinstall: 'node build/postinstall/index.mjs',
    test: 'exit 0',
    'test:ui': 'vitest --ui',
    coverage: 'vitest run --coverage',
    e2e: 'playwright test',
    'e2e:watch': 'playwright test --watch',
    'e2e:ci': 'URL=$npm_config_url playwright test',
    'vercel:deploy': 'vercel --token $npm_config_token',
    'vercel:deploy:production': 'vercel --prod --token $npm_config_token',
    'vercel:alias': 'vercel alias set $npm_config_deployment $npm_config_branch --token $npm_config_token --scope $npm_config_scope',
  },
  J_ = {
    aurelia: 'dev',
    '@aurelia/i18n': 'dev',
    '@aurelia/router-lite': 'dev',
    '@aurelia/validation-html': 'dev',
    '@celo-tools/celo-ethers-wrapper': '^0.4.0',
    '@dethcrypto/eth-sdk': '^0.3.3',
    '@dethcrypto/eth-sdk-client': '^0.1.6',
    '@lottiefiles/lottie-player': '^1.7.1',
    '@material-design-icons/svg': '^0.14.3',
    '@metamask/detect-provider': '^2.0.0',
    '@metamask/providers': '^10.2.1',
    '@walletconnect/web3-provider': '^1.8.0',
    'browserify-zlib': '^0.2.0',
    buffer: '^6.0.3',
    'chart.js': '^4.2.1',
    cids: '^1.1.9',
    ethers: '^5',
    events: '^3.3.0',
    firebase: '^9.17.2',
    'i18next-chained-backend': '^4.2.0',
    'i18next-http-backend': '^2.2.0',
    'i18next-intervalplural-postprocessor': '^3.0.0',
    'i18next-localstorage-backend': '^4.1.0',
    'ipfs-core': '^0.18.0',
    'ipfs-http-client': '^60.0.0',
    'lit-js-sdk': '^1.2.17',
    process: '^0.11.10',
    'stream-browserify': '^3.0.0',
    uint8arrays: '^4.0.3',
    util: '^0.12.5',
    web3modal: '^1.9.12',
  },
  Q_ = {
    'stylelint-config-standard-scss': '^7.0.1',
    '@aurelia/plugin-conventions': 'dev',
    '@aurelia/testing': 'dev',
    '@esbuild-plugins/node-globals-polyfill': '^0.2.3',
    '@playwright/test': '^1.31.2',
    '@rollup/plugin-inject': '^5.0.3',
    '@typechain/ethers-v5': '^10.2.0',
    '@types/node': '^18.15.3',
    '@typescript-eslint/eslint-plugin': '^5.55.0',
    '@typescript-eslint/parser': '^5.55.0',
    '@vitest/ui': '^0.29.3',
    'cross-env': '^7.0.3',
    eslint: '^8.36.0',
    'eslint-config-prettier': '^8.7.0',
    'eslint-import-resolver-typescript': '^3.5.3',
    'eslint-plugin-cypress': '^2.12.1',
    'eslint-plugin-import': '^2.27.5',
    'eslint-plugin-prettier': '^4.2.1',
    'eslint-plugin-simple-import-sort': '^10.0.0',
    'eslint-plugin-unused-imports': '^2.0.0',
    'fs-extra': '^11.1.0',
    glob: '^9.3.0',
    'happy-dom': '^8.9.0',
    'html-loader': '^4.2.0',
    htmlhint: '^1.1.4',
    'http-browserify': '1.7.0',
    'https-browserify': '^1.0.0',
    postcss: '^8.4.21',
    'postcss-loader': '^7.1.0',
    'rollup-plugin-html': '^0.2.1',
    'rollup-plugin-polyfill-node': '^0.12.0',
    'rollup-plugin-swc': '^0.2.1',
    'rollup-plugin-visualizer': '^5.9.0',
    'rollup-pluginutils': '^2.8.2',
    sass: '^1.59.3',
    stylelint: '^15.2.0',
    'stylelint-config-standard': '^30.0.1',
    'stylelint-prettier': '^3.0.0',
    tslib: '^2.5.0',
    typescript: '~4.9.5',
    vercel: 'latest',
    vite: '^4.2.0',
    vitest: '^0.29.3',
    'vitest-mock-extended': '^1.1.0',
  },
  Y_ = {
    terser: 'npm:@swc/core',
  },
  X_ = {
    name: $_,
    description: U_,
    version: j_,
    repository: V_,
    author: z_,
    homepage: G_,
    license: H_,
    engines: K_,
    browser: q_,
    scripts: W_,
    dependencies: J_,
    devDependencies: Q_,
    resolutions: Y_,
  },
  e0 = he.createInterface('BrowserStorageService');
class t0 {
  addVersion(e, t) {
    return {
      data: e,
      _version: t,
    };
  }
  getKey(e) {
    return `${X_.name}.${e}`;
  }
  set(e, t, r, i) {
    const s = typeof i == 'string' ? this.addVersion(r, i) : r;
    e.setItem(this.getKey(t), JSON.stringify(s));
  }
  get(e, t, r, i) {
    const s = e.getItem(this.getKey(t));
    if (typeof s == 'string')
      try {
        const a = JSON.parse(s);
        if (typeof i == 'string') {
          const o = a;
          return o._version === i ? o.data : r;
        } else return a;
      } catch {
        return r;
      }
    return r;
  }
  remove(e, t) {
    e.removeItem(this.getKey(t));
  }
  lsSet(e, t, r) {
    this.set(localStorage, e, t, r);
  }
  lsGet(e, t, r) {
    return this.get(localStorage, e, t, r);
  }
  lsRemove(e) {
    this.remove(localStorage, e);
  }
  ssSet(e, t, r) {
    this.set(sessionStorage, e, t, r);
  }
  ssGet(e, t, r) {
    return this.get(sessionStorage, e, t, r);
  }
  ssRemove(e) {
    this.remove(sessionStorage, e);
  }
  static register(e) {
    fe.singleton(e0, t0).register(e);
  }
}
var ah = /* @__PURE__ */ ((n) => (
  (n[(n.MONETARY_CONTROLLER = 1)] = 'MONETARY_CONTROLLER'),
  (n[(n.RESERVE_DELEGATE = 2)] = 'RESERVE_DELEGATE'),
  (n[(n.RESERVE_VETO_DELEGATE = 3)] = 'RESERVE_VETO_DELEGATE'),
  (n[(n.TOPOLOGY_DELEGATE = 4)] = 'TOPOLOGY_DELEGATE'),
  (n[(n.ECOLOGY_DELEGATE = 5)] = 'ECOLOGY_DELEGATE'),
  (n[(n.ECOLOGY_DELEGATE_PROPOSER = 6)] = 'ECOLOGY_DELEGATE_PROPOSER'),
  (n[(n.RESERVE_ARBITRAGEUR = 7)] = 'RESERVE_ARBITRAGEUR'),
  (n[(n.LOCAL_MULTI_SIG_MEMBER = 8)] = 'LOCAL_MULTI_SIG_MEMBER'),
  (n[(n.TREASURY_DELEGATE = 101)] = 'TREASURY_DELEGATE'),
  (n[(n.TREASURY_VETO_DELEGATE = 102)] = 'TREASURY_VETO_DELEGATE'),
  (n[(n.TREASURY_ARBITRAGEUR = 103)] = 'TREASURY_ARBITRAGEUR'),
  (n[(n.KOLEKTIVO_MULTI_SIG_MEMBER = 104)] = 'KOLEKTIVO_MULTI_SIG_MEMBER'),
  n
))(ah || {});
const Z_ = he.createInterface();
var e9 = Object.defineProperty,
  t9 = Object.getOwnPropertyDescriptor,
  n9 = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? t9(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && e9(e, t, i), i;
  },
  nf = (n, e) => (t, r) => e(t, r, n);
const G6 = he.createInterface('EncryptionService');
let Xc = class {
  constructor(n, e, t) {
    (this.logger = n), (this.container = e), (this.config = t), this.logger.scopeTo('EncryptionService');
  }
  client;
  static register(n) {
    fe.singleton(G6, Xc).register(n);
  }
  authSig;
  encryptedSymmetricKey;
  get chain() {
    return this.config.chain.toLowerCase();
  }
  getAccessControlConditions(n) {
    return [
      {
        contractAddress: n,
        standardContractType: 'ERC1155',
        chain: this.chain,
        method: 'balanceOfBatch',
        parameters: [':userAddress,:userAddress', `${ah.RESERVE_DELEGATE},${ah.ECOLOGY_DELEGATE_PROPOSER}`],
        returnValueTest: {
          comparator: '>',
          value: '0',
        },
      },
    ];
  }
  async connect() {
    if (this.client) return;
    const n = await this.container.get(Z_);
    return (this.client = n), await this.client.connect();
  }
  async encrypt(n, e, t, r) {
    if ((await this.connect(), !this.client)) return;
    const i = {
      web3: e,
      account: t.toLowerCase(),
      chainId: this.config.chainId,
      expiration: new Date(Date.now() + 3e5),
      // 5 minutes
    };
    this.authSig = await this.client.getAuthSig(i);
    const { encryptedString: s, symmetricKey: a } = await this.client.encryptString(n);
    return (
      (this.encryptedSymmetricKey = this.client.uint8arrayToString(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        await this.client.saveEncryptionKey({
          accessControlConditions: this.getAccessControlConditions(r),
          symmetricKey: a,
          authSig: this.authSig,
          chain: this.chain,
        }),
        'base16',
      )),
      { encryptedString: s, symmetricKey: a }
    );
  }
  async decryptAs(n, e) {
    if ((await this.connect(), !this.client)) throw new Error('No encryption client connected');
    const t = await this.client.getEncryptionKey({
        accessControlConditions: this.getAccessControlConditions(e),
        toDecrypt: this.encryptedSymmetricKey,
        chain: this.chain,
        authSig: this.authSig,
      }),
      r = await this.client.decryptString(n, t);
    try {
      return JSON.parse(r);
    } catch {
      this.logger.info('Failed to parse data from LIT');
    }
    return r;
  }
};
Xc = n9([nf(0, ba), nf(1, xo), nf(2, Ea)], Xc);
var Tr = /* @__PURE__ */ ((n) => ((n[(n['1h'] = 0)] = '1h'), (n[(n['1d'] = 1)] = '1d'), (n[(n['1w'] = 2)] = '1w'), (n[(n['1m'] = 3)] = '1m'), (n[(n['1y'] = 4)] = '1y'), n))(Tr || {}),
  n0 = {};
const r9 = /* @__PURE__ */ It(fS),
  i9 = /* @__PURE__ */ It(J7),
  s9 = /* @__PURE__ */ It(IC);
class r0 {
  constructor(e) {
    U(this, 'alphabet', e), U(this, 'base', e.length), U(this, '_alphabetMap', {}), U(this, '_leader', e.charAt(0));
    for (let t = 0; t < e.length; t++) this._alphabetMap[e.charAt(t)] = t;
  }
  encode(e) {
    let t = H(e);
    if (t.length === 0) return '';
    let r = [0];
    for (let s = 0; s < t.length; ++s) {
      let a = t[s];
      for (let o = 0; o < r.length; ++o) (a += r[o] << 8), (r[o] = a % this.base), (a = (a / this.base) | 0);
      for (; a > 0; ) r.push(a % this.base), (a = (a / this.base) | 0);
    }
    let i = '';
    for (let s = 0; t[s] === 0 && s < t.length - 1; ++s) i += this._leader;
    for (let s = r.length - 1; s >= 0; --s) i += this.alphabet[r[s]];
    return i;
  }
  decode(e) {
    if (typeof e != 'string') throw new TypeError('Expected String');
    let t = [];
    if (e.length === 0) return new Uint8Array(t);
    t.push(0);
    for (let r = 0; r < e.length; r++) {
      let i = this._alphabetMap[e[r]];
      if (i === void 0) throw new Error('Non-base' + this.base + ' character');
      let s = i;
      for (let a = 0; a < t.length; ++a) (s += t[a] * this.base), (t[a] = s & 255), (s >>= 8);
      for (; s > 0; ) t.push(s & 255), (s >>= 8);
    }
    for (let r = 0; e[r] === this._leader && r < e.length - 1; ++r) t.push(0);
    return H(new Uint8Array(t.reverse()));
  }
}
const a9 = new r0('abcdefghijklmnopqrstuvwxyz234567'),
  fo = new r0('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'),
  o9 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        Base32: a9,
        Base58: fo,
        BaseX: r0,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  u9 = /* @__PURE__ */ It(o9),
  l9 = /* @__PURE__ */ It(QE),
  c9 = /* @__PURE__ */ It(cS);
var ho;
(function (n) {
  (n.sha256 = 'sha256'), (n.sha512 = 'sha512');
})(ho || (ho = {}));
const d9 = 'sha2/5.7.0',
  p9 = new O(d9);
function H6(n) {
  return '0x' + vn.ripemd160().update(H(n)).digest('hex');
}
function Pi(n) {
  return '0x' + vn.sha256().update(H(n)).digest('hex');
}
function f9(n) {
  return '0x' + vn.sha512().update(H(n)).digest('hex');
}
function ju(n, e, t) {
  return (
    ho[n] ||
      p9.throwError('unsupported algorithm ' + n, O.errors.UNSUPPORTED_OPERATION, {
        operation: 'hmac',
        algorithm: n,
      }),
    '0x' + vn.hmac(vn[n], H(e)).update(H(t)).digest('hex')
  );
}
const h9 = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      get SupportedAlgorithm() {
        return ho;
      },
      computeHmac: ju,
      ripemd160: H6,
      sha256: Pi,
      sha512: f9,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
function i0(n, e, t, r, i) {
  (n = H(n)), (e = H(e));
  let s,
    a = 1;
  const o = new Uint8Array(r),
    u = new Uint8Array(e.length + 4);
  u.set(e);
  let l, p;
  for (let h = 1; h <= a; h++) {
    (u[e.length] = (h >> 24) & 255), (u[e.length + 1] = (h >> 16) & 255), (u[e.length + 2] = (h >> 8) & 255), (u[e.length + 3] = h & 255);
    let b = H(ju(i, n, u));
    s || ((s = b.length), (p = new Uint8Array(s)), (a = Math.ceil(r / s)), (l = r - (a - 1) * s)), p.set(b);
    for (let T = 1; T < t; T++) {
      b = H(ju(i, n, b));
      for (let w = 0; w < s; w++) p[w] ^= b[w];
    }
    const E = (h - 1) * s,
      x = h === a ? l : s;
    o.set(H(p).slice(0, x), E);
  }
  return K(o);
}
const y9 = 'wordlists/5.7.0',
  m9 = new O(y9);
class Tl {
  constructor(e) {
    m9.checkAbstract(new.target, Tl), U(this, 'locale', e);
  }
  // Subclasses may override this
  split(e) {
    return e.toLowerCase().split(/ +/g);
  }
  // Subclasses may override this
  join(e) {
    return e.join(' ');
  }
  static check(e) {
    const t = [];
    for (let r = 0; r < 2048; r++) {
      const i = e.getWord(r);
      if (r !== e.getWordIndex(i)) return '0x';
      t.push(i);
    }
    return ss(
      t.join(`
`) +
        `
`,
    );
  }
  static register(e, t) {
    t || (t = e.locale);
  }
}
const b9 =
  'AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo';
let hu = null;
function a2(n) {
  if (
    hu == null &&
    ((hu = b9
      .replace(/([A-Z])/g, ' $1')
      .toLowerCase()
      .substring(1)
      .split(' ')),
    Tl.check(n) !== '0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60')
  )
    throw ((hu = null), new Error('BIP39 Wordlist for en (English) FAILED'));
}
class g9 extends Tl {
  constructor() {
    super('en');
  }
  getWord(e) {
    return a2(this), hu[e];
  }
  getWordIndex(e) {
    return a2(this), hu.indexOf(e);
  }
}
const K6 = new g9();
Tl.register(K6);
const o2 = {
    en: K6,
  },
  v9 = 'hdnode/5.7.0',
  Vu = new O(v9),
  x9 = G.from('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
  w9 = Nt('Bitcoin seed'),
  ja = 2147483648;
function q6(n) {
  return ((1 << n) - 1) << (8 - n);
}
function T9(n) {
  return (1 << n) - 1;
}
function ql(n) {
  return Be(K(n), 32);
}
function u2(n) {
  return fo.encode($e([n, Bt(Pi(Pi(n)), 0, 4)]));
}
function s0(n) {
  if (n == null) return o2.en;
  if (typeof n == 'string') {
    const e = o2[n];
    return e == null && Vu.throwArgumentError('unknown locale', 'wordlist', n), e;
  }
  return n;
}
const Oa = {},
  yo = "m/44'/60'/0'/0/0";
class Gn {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(e, t, r, i, s, a, o, u) {
    if (e !== Oa) throw new Error('HDNode constructor cannot be called directly');
    if (t) {
      const l = new Zs(t);
      U(this, 'privateKey', l.privateKey), U(this, 'publicKey', l.compressedPublicKey);
    } else U(this, 'privateKey', null), U(this, 'publicKey', K(r));
    U(this, 'parentFingerprint', i),
      U(this, 'fingerprint', Bt(H6(Pi(this.publicKey)), 0, 4)),
      U(this, 'address', us(this.publicKey)),
      U(this, 'chainCode', s),
      U(this, 'index', a),
      U(this, 'depth', o),
      u == null ? (U(this, 'mnemonic', null), U(this, 'path', null)) : typeof u == 'string' ? (U(this, 'mnemonic', null), U(this, 'path', u)) : (U(this, 'mnemonic', u), U(this, 'path', u.path));
  }
  get extendedKey() {
    if (this.depth >= 256) throw new Error('Depth too large!');
    return u2(
      $e([
        this.privateKey != null ? '0x0488ADE4' : '0x0488B21E',
        K(this.depth),
        this.parentFingerprint,
        Be(K(this.index), 4),
        this.chainCode,
        this.privateKey != null ? $e(['0x00', this.privateKey]) : this.publicKey,
      ]),
    );
  }
  neuter() {
    return new Gn(Oa, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(e) {
    if (e > 4294967295) throw new Error('invalid index - ' + String(e));
    let t = this.path;
    t && (t += '/' + (e & ~ja));
    const r = new Uint8Array(37);
    if (e & ja) {
      if (!this.privateKey) throw new Error('cannot derive child of neutered node');
      r.set(H(this.privateKey), 1), t && (t += "'");
    } else r.set(H(this.publicKey));
    for (let h = 24; h >= 0; h -= 8) r[33 + (h >> 3)] = (e >> (24 - h)) & 255;
    const i = H(ju(ho.sha512, this.chainCode, r)),
      s = i.slice(0, 32),
      a = i.slice(32);
    let o = null,
      u = null;
    this.privateKey ? (o = ql(G.from(s).add(this.privateKey).mod(x9))) : (u = new Zs(K(s))._addPoint(this.publicKey));
    let l = t;
    const p = this.mnemonic;
    return (
      p &&
        (l = Object.freeze({
          phrase: p.phrase,
          path: t,
          locale: p.locale || 'en',
        })),
      new Gn(Oa, o, u, this.fingerprint, ql(a), e, this.depth + 1, l)
    );
  }
  derivePath(e) {
    const t = e.split('/');
    if (t.length === 0 || (t[0] === 'm' && this.depth !== 0)) throw new Error('invalid path - ' + e);
    t[0] === 'm' && t.shift();
    let r = this;
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      if (s.match(/^[0-9]+'$/)) {
        const a = parseInt(s.substring(0, s.length - 1));
        if (a >= ja) throw new Error('invalid path index - ' + s);
        r = r._derive(ja + a);
      } else if (s.match(/^[0-9]+$/)) {
        const a = parseInt(s);
        if (a >= ja) throw new Error('invalid path index - ' + s);
        r = r._derive(a);
      } else throw new Error('invalid path component - ' + s);
    }
    return r;
  }
  static _fromSeed(e, t) {
    const r = H(e);
    if (r.length < 16 || r.length > 64) throw new Error('invalid seed');
    const i = H(ju(ho.sha512, w9, r));
    return new Gn(Oa, ql(i.slice(0, 32)), null, '0x00000000', ql(i.slice(32)), 0, 0, t);
  }
  static fromMnemonic(e, t, r) {
    return (
      (r = s0(r)),
      (e = jd(Ud(e, r), r)),
      Gn._fromSeed(W6(e, t), {
        phrase: e,
        path: 'm',
        locale: r.locale,
      })
    );
  }
  static fromSeed(e) {
    return Gn._fromSeed(e, null);
  }
  static fromExtendedKey(e) {
    const t = fo.decode(e);
    (t.length !== 82 || u2(t.slice(0, 78)) !== e) && Vu.throwArgumentError('invalid extended key', 'extendedKey', '[REDACTED]');
    const r = t[4],
      i = K(t.slice(5, 9)),
      s = parseInt(K(t.slice(9, 13)).substring(2), 16),
      a = K(t.slice(13, 45)),
      o = t.slice(45, 78);
    switch (K(t.slice(0, 4))) {
      case '0x0488b21e':
      case '0x043587cf':
        return new Gn(Oa, null, K(o), i, a, s, r, null);
      case '0x0488ade4':
      case '0x04358394 ':
        if (o[0] !== 0) break;
        return new Gn(Oa, K(o.slice(1)), null, i, a, s, r, null);
    }
    return Vu.throwArgumentError('invalid extended key', 'extendedKey', '[REDACTED]');
  }
}
function W6(n, e) {
  e || (e = '');
  const t = Nt('mnemonic' + e, Qr.NFKD);
  return i0(Nt(n, Qr.NFKD), t, 2048, 64, 'sha512');
}
function Ud(n, e) {
  (e = s0(e)), Vu.checkNormalize();
  const t = e.split(n);
  if (t.length % 3 !== 0) throw new Error('invalid mnemonic');
  const r = H(new Uint8Array(Math.ceil((11 * t.length) / 8)));
  let i = 0;
  for (let l = 0; l < t.length; l++) {
    let p = e.getWordIndex(t[l].normalize('NFKD'));
    if (p === -1) throw new Error('invalid mnemonic');
    for (let h = 0; h < 11; h++) p & (1 << (10 - h)) && (r[i >> 3] |= 1 << (7 - (i % 8))), i++;
  }
  const s = (32 * t.length) / 3,
    a = t.length / 3,
    o = q6(a);
  if ((H(Pi(r.slice(0, s / 8)))[0] & o) !== (r[r.length - 1] & o)) throw new Error('invalid checksum');
  return K(r.slice(0, s / 8));
}
function jd(n, e) {
  if (((e = s0(e)), (n = H(n)), n.length % 4 !== 0 || n.length < 16 || n.length > 32)) throw new Error('invalid entropy');
  const t = [0];
  let r = 11;
  for (let a = 0; a < n.length; a++)
    r > 8 ? ((t[t.length - 1] <<= 8), (t[t.length - 1] |= n[a]), (r -= 8)) : ((t[t.length - 1] <<= r), (t[t.length - 1] |= n[a] >> (8 - r)), t.push(n[a] & T9(8 - r)), (r += 3));
  const i = n.length / 4,
    s = H(Pi(n))[0] & q6(i);
  return (t[t.length - 1] <<= i), (t[t.length - 1] |= s >> (8 - i)), e.join(t.map((a) => e.getWord(a)));
}
function A9(n, e) {
  try {
    return Ud(n, e), !0;
  } catch {}
  return !1;
}
function E9(n) {
  return (typeof n != 'number' || n < 0 || n >= ja || n % 1) && Vu.throwArgumentError('invalid account index', 'index', n), `m/44'/60'/${n}'/0/0`;
}
const C9 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        HDNode: Gn,
        defaultPath: yo,
        entropyToMnemonic: jd,
        getAccountPath: E9,
        isValidMnemonic: A9,
        mnemonicToEntropy: Ud,
        mnemonicToSeed: W6,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  S9 = /* @__PURE__ */ It(C9);
var oh = {},
  M9 = {
    get exports() {
      return oh;
    },
    set exports(n) {
      oh = n;
    },
  };
(function (n, e) {
  (function (t) {
    function r(m) {
      return parseInt(m) === m;
    }
    function i(m) {
      if (!r(m.length)) return !1;
      for (var d = 0; d < m.length; d++) if (!r(m[d]) || m[d] < 0 || m[d] > 255) return !1;
      return !0;
    }
    function s(m, d) {
      if (m.buffer && ArrayBuffer.isView(m) && m.name === 'Uint8Array') return d && (m.slice ? (m = m.slice()) : (m = Array.prototype.slice.call(m))), m;
      if (Array.isArray(m)) {
        if (!i(m)) throw new Error('Array contains invalid value: ' + m);
        return new Uint8Array(m);
      }
      if (r(m.length) && i(m)) return new Uint8Array(m);
      throw new Error('unsupported array-like object');
    }
    function a(m) {
      return new Uint8Array(m);
    }
    function o(m, d, g, I, f) {
      (I != null || f != null) && (m.slice ? (m = m.slice(I, f)) : (m = Array.prototype.slice.call(m, I, f))), d.set(m, g);
    }
    var u = (function () {
        function m(g) {
          var I = [],
            f = 0;
          for (g = encodeURI(g); f < g.length; ) {
            var R = g.charCodeAt(f++);
            R === 37 ? (I.push(parseInt(g.substr(f, 2), 16)), (f += 2)) : I.push(R);
          }
          return s(I);
        }
        function d(g) {
          for (var I = [], f = 0; f < g.length; ) {
            var R = g[f];
            R < 128
              ? (I.push(String.fromCharCode(R)), f++)
              : R > 191 && R < 224
              ? (I.push(String.fromCharCode(((R & 31) << 6) | (g[f + 1] & 63))), (f += 2))
              : (I.push(String.fromCharCode(((R & 15) << 12) | ((g[f + 1] & 63) << 6) | (g[f + 2] & 63))), (f += 3));
          }
          return I.join('');
        }
        return {
          toBytes: m,
          fromBytes: d,
        };
      })(),
      l = (function () {
        function m(I) {
          for (var f = [], R = 0; R < I.length; R += 2) f.push(parseInt(I.substr(R, 2), 16));
          return f;
        }
        var d = '0123456789abcdef';
        function g(I) {
          for (var f = [], R = 0; R < I.length; R++) {
            var L = I[R];
            f.push(d[(L & 240) >> 4] + d[L & 15]);
          }
          return f.join('');
        }
        return {
          toBytes: m,
          fromBytes: g,
        };
      })(),
      p = { 16: 10, 24: 12, 32: 14 },
      h = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145],
      b = [
        99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204,
        52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0,
        237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16,
        255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92,
        194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138,
        112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65,
        153, 45, 15, 176, 84, 187, 22,
      ],
      E = [
        82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76,
        149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72,
        80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19,
        138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197,
        137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96,
        81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20,
        99, 85, 33, 12, 125,
      ],
      x = [
        3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586,
        2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635,
        1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767,
        134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367,
        302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799,
        2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746,
        3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483,
        2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685,
        2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909,
        3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934,
        3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243,
        3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816,
        1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669,
        3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745,
        3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378,
        59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986,
      ],
      T = [
        2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086,
        1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080,
        3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517,
        201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837,
        454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724,
        4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800,
        717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137,
        4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245,
        337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144,
        2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696,
        1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335,
        1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306,
        2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952,
        1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233,
        334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476,
        4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766,
      ],
      w = [
        1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566,
        3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120,
        3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077,
        67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517,
        152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444,
        1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360,
        4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297,
        2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245,
        202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744,
        2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296,
        844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455,
        3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946,
        2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832,
        1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393,
        4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796,
        2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126,
      ],
      _ = [
        1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396,
        3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835,
        3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962,
        67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922,
        151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939,
        1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995,
        4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282,
        2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745,
        202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344,
        2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771,
        842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725,
        3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511,
        2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312,
        1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753,
        4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891,
        2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436,
      ],
      k = [
        1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495,
        3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676,
        1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228,
        1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356,
        2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961,
        1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483,
        2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497,
        2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501,
        2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733,
        3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455,
        3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150,
        1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889,
        1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685,
        1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476,
        933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769,
        3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890,
      ],
      D = [
        1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155,
        1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456,
        1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523,
        1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666,
        730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976,
        4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598,
        1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327,
        261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081,
        1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268,
        4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110,
        3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200,
        2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859,
        3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630,
        1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921,
        2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179,
        1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935,
      ],
      N = [
        2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290,
        1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201,
        2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368,
        1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086,
        472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366,
        2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968,
        172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202,
        3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201,
        122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898,
        1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145,
        3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285,
        2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639,
        919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085,
        2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631,
        209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519,
        3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600,
      ],
      B = [
        4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325,
        2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166,
        3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913,
        1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221,
        3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261,
        562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953,
        2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692,
        1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591,
        1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413,
        3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655,
        953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495,
        3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714,
        1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550,
        4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426,
        2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274,
        1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480,
      ],
      j = [
        0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992,
        4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923,
        3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995,
        899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766,
        2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366,
        1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685,
        2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453,
        2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591,
        1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871,
        2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476,
        2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780,
        1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369,
        3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497,
        33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370,
        967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226,
        3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795,
      ],
      q = [
        0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152,
        3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243,
        1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355,
        3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181,
        4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461,
        1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630,
        2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158,
        915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826,
        4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386,
        1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921,
        2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705,
        930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319,
        182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327,
        3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060,
        1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636,
        3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855,
      ],
      z = [
        0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752,
        3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443,
        3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195,
        1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806,
        1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286,
        2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085,
        3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613,
        188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356,
        3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556,
        122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631,
        1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695,
        3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634,
        3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202,
        1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544,
        376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200,
        3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150,
      ],
      Y = [
        0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872,
        2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683,
        850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315,
        2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061,
        2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981,
        4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550,
        1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718,
        3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121,
        3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481,
        1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426,
        3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690,
        1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844,
        2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692,
        57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495,
        2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431,
        953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925,
      ];
    function ae(m) {
      for (var d = [], g = 0; g < m.length; g += 4) d.push((m[g] << 24) | (m[g + 1] << 16) | (m[g + 2] << 8) | m[g + 3]);
      return d;
    }
    var J = function (m) {
      if (!(this instanceof J)) throw Error('AES must be instanitated with `new`');
      Object.defineProperty(this, 'key', {
        value: s(m, !0),
      }),
        this._prepare();
    };
    (J.prototype._prepare = function () {
      var m = p[this.key.length];
      if (m == null) throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
      (this._Ke = []), (this._Kd = []);
      for (var d = 0; d <= m; d++) this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (var g = (m + 1) * 4, I = this.key.length / 4, f = ae(this.key), R, d = 0; d < I; d++) (R = d >> 2), (this._Ke[R][d % 4] = f[d]), (this._Kd[m - R][d % 4] = f[d]);
      for (var L = 0, F = I, $; F < g; ) {
        if ((($ = f[I - 1]), (f[0] ^= (b[($ >> 16) & 255] << 24) ^ (b[($ >> 8) & 255] << 16) ^ (b[$ & 255] << 8) ^ b[($ >> 24) & 255] ^ (h[L] << 24)), (L += 1), I != 8))
          for (var d = 1; d < I; d++) f[d] ^= f[d - 1];
        else {
          for (var d = 1; d < I / 2; d++) f[d] ^= f[d - 1];
          ($ = f[I / 2 - 1]), (f[I / 2] ^= b[$ & 255] ^ (b[($ >> 8) & 255] << 8) ^ (b[($ >> 16) & 255] << 16) ^ (b[($ >> 24) & 255] << 24));
          for (var d = I / 2 + 1; d < I; d++) f[d] ^= f[d - 1];
        }
        for (var d = 0, ee, W; d < I && F < g; ) (ee = F >> 2), (W = F % 4), (this._Ke[ee][W] = f[d]), (this._Kd[m - ee][W] = f[d++]), F++;
      }
      for (var ee = 1; ee < m; ee++) for (var W = 0; W < 4; W++) ($ = this._Kd[ee][W]), (this._Kd[ee][W] = j[($ >> 24) & 255] ^ q[($ >> 16) & 255] ^ z[($ >> 8) & 255] ^ Y[$ & 255]);
    }),
      (J.prototype.encrypt = function (m) {
        if (m.length != 16) throw new Error('invalid plaintext size (must be 16 bytes)');
        for (var d = this._Ke.length - 1, g = [0, 0, 0, 0], I = ae(m), f = 0; f < 4; f++) I[f] ^= this._Ke[0][f];
        for (var R = 1; R < d; R++) {
          for (var f = 0; f < 4; f++) g[f] = x[(I[f] >> 24) & 255] ^ T[(I[(f + 1) % 4] >> 16) & 255] ^ w[(I[(f + 2) % 4] >> 8) & 255] ^ _[I[(f + 3) % 4] & 255] ^ this._Ke[R][f];
          I = g.slice();
        }
        for (var L = a(16), F, f = 0; f < 4; f++)
          (F = this._Ke[d][f]),
            (L[4 * f] = (b[(I[f] >> 24) & 255] ^ (F >> 24)) & 255),
            (L[4 * f + 1] = (b[(I[(f + 1) % 4] >> 16) & 255] ^ (F >> 16)) & 255),
            (L[4 * f + 2] = (b[(I[(f + 2) % 4] >> 8) & 255] ^ (F >> 8)) & 255),
            (L[4 * f + 3] = (b[I[(f + 3) % 4] & 255] ^ F) & 255);
        return L;
      }),
      (J.prototype.decrypt = function (m) {
        if (m.length != 16) throw new Error('invalid ciphertext size (must be 16 bytes)');
        for (var d = this._Kd.length - 1, g = [0, 0, 0, 0], I = ae(m), f = 0; f < 4; f++) I[f] ^= this._Kd[0][f];
        for (var R = 1; R < d; R++) {
          for (var f = 0; f < 4; f++) g[f] = k[(I[f] >> 24) & 255] ^ D[(I[(f + 3) % 4] >> 16) & 255] ^ N[(I[(f + 2) % 4] >> 8) & 255] ^ B[I[(f + 1) % 4] & 255] ^ this._Kd[R][f];
          I = g.slice();
        }
        for (var L = a(16), F, f = 0; f < 4; f++)
          (F = this._Kd[d][f]),
            (L[4 * f] = (E[(I[f] >> 24) & 255] ^ (F >> 24)) & 255),
            (L[4 * f + 1] = (E[(I[(f + 3) % 4] >> 16) & 255] ^ (F >> 16)) & 255),
            (L[4 * f + 2] = (E[(I[(f + 2) % 4] >> 8) & 255] ^ (F >> 8)) & 255),
            (L[4 * f + 3] = (E[I[(f + 1) % 4] & 255] ^ F) & 255);
        return L;
      });
    var oe = function (m) {
      if (!(this instanceof oe)) throw Error('AES must be instanitated with `new`');
      (this.description = 'Electronic Code Block'), (this.name = 'ecb'), (this._aes = new J(m));
    };
    (oe.prototype.encrypt = function (m) {
      if (((m = s(m)), m.length % 16 !== 0)) throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
      for (var d = a(m.length), g = a(16), I = 0; I < m.length; I += 16) o(m, g, 0, I, I + 16), (g = this._aes.encrypt(g)), o(g, d, I);
      return d;
    }),
      (oe.prototype.decrypt = function (m) {
        if (((m = s(m)), m.length % 16 !== 0)) throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        for (var d = a(m.length), g = a(16), I = 0; I < m.length; I += 16) o(m, g, 0, I, I + 16), (g = this._aes.decrypt(g)), o(g, d, I);
        return d;
      });
    var S = function (m, d) {
      if (!(this instanceof S)) throw Error('AES must be instanitated with `new`');
      if (((this.description = 'Cipher Block Chaining'), (this.name = 'cbc'), !d)) d = a(16);
      else if (d.length != 16) throw new Error('invalid initialation vector size (must be 16 bytes)');
      (this._lastCipherblock = s(d, !0)), (this._aes = new J(m));
    };
    (S.prototype.encrypt = function (m) {
      if (((m = s(m)), m.length % 16 !== 0)) throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
      for (var d = a(m.length), g = a(16), I = 0; I < m.length; I += 16) {
        o(m, g, 0, I, I + 16);
        for (var f = 0; f < 16; f++) g[f] ^= this._lastCipherblock[f];
        (this._lastCipherblock = this._aes.encrypt(g)), o(this._lastCipherblock, d, I);
      }
      return d;
    }),
      (S.prototype.decrypt = function (m) {
        if (((m = s(m)), m.length % 16 !== 0)) throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        for (var d = a(m.length), g = a(16), I = 0; I < m.length; I += 16) {
          o(m, g, 0, I, I + 16), (g = this._aes.decrypt(g));
          for (var f = 0; f < 16; f++) d[I + f] = g[f] ^ this._lastCipherblock[f];
          o(m, this._lastCipherblock, 0, I, I + 16);
        }
        return d;
      });
    var c = function (m, d, g) {
      if (!(this instanceof c)) throw Error('AES must be instanitated with `new`');
      if (((this.description = 'Cipher Feedback'), (this.name = 'cfb'), !d)) d = a(16);
      else if (d.length != 16) throw new Error('invalid initialation vector size (must be 16 size)');
      g || (g = 1), (this.segmentSize = g), (this._shiftRegister = s(d, !0)), (this._aes = new J(m));
    };
    (c.prototype.encrypt = function (m) {
      if (m.length % this.segmentSize != 0) throw new Error('invalid plaintext size (must be segmentSize bytes)');
      for (var d = s(m, !0), g, I = 0; I < d.length; I += this.segmentSize) {
        g = this._aes.encrypt(this._shiftRegister);
        for (var f = 0; f < this.segmentSize; f++) d[I + f] ^= g[f];
        o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(d, this._shiftRegister, 16 - this.segmentSize, I, I + this.segmentSize);
      }
      return d;
    }),
      (c.prototype.decrypt = function (m) {
        if (m.length % this.segmentSize != 0) throw new Error('invalid ciphertext size (must be segmentSize bytes)');
        for (var d = s(m, !0), g, I = 0; I < d.length; I += this.segmentSize) {
          g = this._aes.encrypt(this._shiftRegister);
          for (var f = 0; f < this.segmentSize; f++) d[I + f] ^= g[f];
          o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(m, this._shiftRegister, 16 - this.segmentSize, I, I + this.segmentSize);
        }
        return d;
      });
    var y = function (m, d) {
      if (!(this instanceof y)) throw Error('AES must be instanitated with `new`');
      if (((this.description = 'Output Feedback'), (this.name = 'ofb'), !d)) d = a(16);
      else if (d.length != 16) throw new Error('invalid initialation vector size (must be 16 bytes)');
      (this._lastPrecipher = s(d, !0)), (this._lastPrecipherIndex = 16), (this._aes = new J(m));
    };
    (y.prototype.encrypt = function (m) {
      for (var d = s(m, !0), g = 0; g < d.length; g++)
        this._lastPrecipherIndex === 16 && ((this._lastPrecipher = this._aes.encrypt(this._lastPrecipher)), (this._lastPrecipherIndex = 0)), (d[g] ^= this._lastPrecipher[this._lastPrecipherIndex++]);
      return d;
    }),
      (y.prototype.decrypt = y.prototype.encrypt);
    var v = function (m) {
      if (!(this instanceof v)) throw Error('Counter must be instanitated with `new`');
      m !== 0 && !m && (m = 1), typeof m == 'number' ? ((this._counter = a(16)), this.setValue(m)) : this.setBytes(m);
    };
    (v.prototype.setValue = function (m) {
      if (typeof m != 'number' || parseInt(m) != m) throw new Error('invalid counter value (must be an integer)');
      for (var d = 15; d >= 0; --d) (this._counter[d] = m % 256), (m = m >> 8);
    }),
      (v.prototype.setBytes = function (m) {
        if (((m = s(m, !0)), m.length != 16)) throw new Error('invalid counter bytes size (must be 16 bytes)');
        this._counter = m;
      }),
      (v.prototype.increment = function () {
        for (var m = 15; m >= 0; m--)
          if (this._counter[m] === 255) this._counter[m] = 0;
          else {
            this._counter[m]++;
            break;
          }
      });
    var C = function (m, d) {
      if (!(this instanceof C)) throw Error('AES must be instanitated with `new`');
      (this.description = 'Counter'),
        (this.name = 'ctr'),
        d instanceof v || (d = new v(d)),
        (this._counter = d),
        (this._remainingCounter = null),
        (this._remainingCounterIndex = 16),
        (this._aes = new J(m));
    };
    (C.prototype.encrypt = function (m) {
      for (var d = s(m, !0), g = 0; g < d.length; g++)
        this._remainingCounterIndex === 16 && ((this._remainingCounter = this._aes.encrypt(this._counter._counter)), (this._remainingCounterIndex = 0), this._counter.increment()),
          (d[g] ^= this._remainingCounter[this._remainingCounterIndex++]);
      return d;
    }),
      (C.prototype.decrypt = C.prototype.encrypt);
    function A(m) {
      m = s(m, !0);
      var d = 16 - (m.length % 16),
        g = a(m.length + d);
      o(m, g);
      for (var I = m.length; I < g.length; I++) g[I] = d;
      return g;
    }
    function M(m) {
      if (((m = s(m, !0)), m.length < 16)) throw new Error('PKCS#7 invalid length');
      var d = m[m.length - 1];
      if (d > 16) throw new Error('PKCS#7 padding byte out of range');
      for (var g = m.length - d, I = 0; I < d; I++) if (m[g + I] !== d) throw new Error('PKCS#7 invalid padding byte');
      var f = a(g);
      return o(m, f, 0, 0, g), f;
    }
    var P = {
      AES: J,
      Counter: v,
      ModeOfOperation: {
        ecb: oe,
        cbc: S,
        cfb: c,
        ofb: y,
        ctr: C,
      },
      utils: {
        hex: l,
        utf8: u,
      },
      padding: {
        pkcs7: {
          pad: A,
          strip: M,
        },
      },
      _arrayTest: {
        coerceArray: s,
        createArray: a,
        copyArray: o,
      },
    };
    n.exports = P;
  })();
})(M9);
const jr = oh,
  J6 = 'json-wallets/5.7.0';
function ea(n) {
  return typeof n == 'string' && n.substring(0, 2) !== '0x' && (n = '0x' + n), H(n);
}
function Vo(n, e) {
  for (n = String(n); n.length < e; ) n = '0' + n;
  return n;
}
function a0(n) {
  return typeof n == 'string' ? Nt(n, Qr.NFKC) : H(n);
}
function Ot(n, e) {
  let t = n;
  const r = e.toLowerCase().split('/');
  for (let i = 0; i < r.length; i++) {
    let s = null;
    for (const a in t)
      if (a.toLowerCase() === r[i]) {
        s = t[a];
        break;
      }
    if (s === null) return null;
    t = s;
  }
  return t;
}
function _9(n) {
  const e = H(n);
  (e[6] = (e[6] & 15) | 64), (e[8] = (e[8] & 63) | 128);
  const t = K(e);
  return [t.substring(2, 10), t.substring(10, 14), t.substring(14, 18), t.substring(18, 22), t.substring(22, 34)].join('-');
}
const R9 = new O(J6);
class P9 extends xs {
  isCrowdsaleAccount(e) {
    return !!(e && e._isCrowdsaleAccount);
  }
}
function o0(n, e) {
  const t = JSON.parse(n);
  e = a0(e);
  const r = Oe(Ot(t, 'ethaddr')),
    i = ea(Ot(t, 'encseed'));
  (!i || i.length % 16 !== 0) && R9.throwArgumentError('invalid encseed', 'json', n);
  const s = H(i0(e, e, 2e3, 32, 'sha256')).slice(0, 16),
    a = i.slice(0, 16),
    o = i.slice(16),
    u = new jr.ModeOfOperation.cbc(s, a),
    l = jr.padding.pkcs7.strip(H(u.decrypt(o)));
  let p = '';
  for (let E = 0; E < l.length; E++) p += String.fromCharCode(l[E]);
  const h = Nt(p),
    b = Ie(h);
  return new P9({
    _isCrowdsaleAccount: !0,
    address: r,
    privateKey: b,
  });
}
function Vd(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return e.encseed && e.ethaddr;
}
function zd(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return !(!e.version || parseInt(e.version) !== e.version || parseInt(e.version) !== 3);
}
function I9(n) {
  if (Vd(n))
    try {
      return Oe(JSON.parse(n).ethaddr);
    } catch {
      return null;
    }
  if (zd(n))
    try {
      return Oe(JSON.parse(n).address);
    } catch {
      return null;
    }
  return null;
}
var uh = {},
  k9 = {
    get exports() {
      return uh;
    },
    set exports(n) {
      uh = n;
    },
  };
(function (n, e) {
  (function (t) {
    function i(T) {
      const w = new Uint32Array([
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
        3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
        666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
      ]);
      let _ = 1779033703,
        k = 3144134277,
        D = 1013904242,
        N = 2773480762,
        B = 1359893119,
        j = 2600822924,
        q = 528734635,
        z = 1541459225;
      const Y = new Uint32Array(64);
      function ae(C) {
        let A = 0,
          M = C.length;
        for (; M >= 64; ) {
          let P = _,
            m = k,
            d = D,
            g = N,
            I = B,
            f = j,
            R = q,
            L = z,
            F,
            $,
            ee,
            W,
            Q;
          for ($ = 0; $ < 16; $++) (ee = A + $ * 4), (Y[$] = ((C[ee] & 255) << 24) | ((C[ee + 1] & 255) << 16) | ((C[ee + 2] & 255) << 8) | (C[ee + 3] & 255));
          for ($ = 16; $ < 64; $++)
            (F = Y[$ - 2]),
              (W = ((F >>> 17) | (F << (32 - 17))) ^ ((F >>> 19) | (F << (32 - 19))) ^ (F >>> 10)),
              (F = Y[$ - 15]),
              (Q = ((F >>> 7) | (F << (32 - 7))) ^ ((F >>> 18) | (F << (32 - 18))) ^ (F >>> 3)),
              (Y[$] = (((W + Y[$ - 7]) | 0) + ((Q + Y[$ - 16]) | 0)) | 0);
          for ($ = 0; $ < 64; $++)
            (W = ((((((I >>> 6) | (I << (32 - 6))) ^ ((I >>> 11) | (I << (32 - 11))) ^ ((I >>> 25) | (I << (32 - 25)))) + ((I & f) ^ (~I & R))) | 0) + ((L + ((w[$] + Y[$]) | 0)) | 0)) | 0),
              (Q = ((((P >>> 2) | (P << (32 - 2))) ^ ((P >>> 13) | (P << (32 - 13))) ^ ((P >>> 22) | (P << (32 - 22)))) + ((P & m) ^ (P & d) ^ (m & d))) | 0),
              (L = R),
              (R = f),
              (f = I),
              (I = (g + W) | 0),
              (g = d),
              (d = m),
              (m = P),
              (P = (W + Q) | 0);
          (_ = (_ + P) | 0), (k = (k + m) | 0), (D = (D + d) | 0), (N = (N + g) | 0), (B = (B + I) | 0), (j = (j + f) | 0), (q = (q + R) | 0), (z = (z + L) | 0), (A += 64), (M -= 64);
        }
      }
      ae(T);
      let J,
        oe = T.length % 64,
        S = (T.length / 536870912) | 0,
        c = T.length << 3,
        y = oe < 56 ? 56 : 120,
        v = T.slice(T.length - oe, T.length);
      for (v.push(128), J = oe + 1; J < y; J++) v.push(0);
      return (
        v.push((S >>> 24) & 255),
        v.push((S >>> 16) & 255),
        v.push((S >>> 8) & 255),
        v.push((S >>> 0) & 255),
        v.push((c >>> 24) & 255),
        v.push((c >>> 16) & 255),
        v.push((c >>> 8) & 255),
        v.push((c >>> 0) & 255),
        ae(v),
        [
          (_ >>> 24) & 255,
          (_ >>> 16) & 255,
          (_ >>> 8) & 255,
          (_ >>> 0) & 255,
          (k >>> 24) & 255,
          (k >>> 16) & 255,
          (k >>> 8) & 255,
          (k >>> 0) & 255,
          (D >>> 24) & 255,
          (D >>> 16) & 255,
          (D >>> 8) & 255,
          (D >>> 0) & 255,
          (N >>> 24) & 255,
          (N >>> 16) & 255,
          (N >>> 8) & 255,
          (N >>> 0) & 255,
          (B >>> 24) & 255,
          (B >>> 16) & 255,
          (B >>> 8) & 255,
          (B >>> 0) & 255,
          (j >>> 24) & 255,
          (j >>> 16) & 255,
          (j >>> 8) & 255,
          (j >>> 0) & 255,
          (q >>> 24) & 255,
          (q >>> 16) & 255,
          (q >>> 8) & 255,
          (q >>> 0) & 255,
          (z >>> 24) & 255,
          (z >>> 16) & 255,
          (z >>> 8) & 255,
          (z >>> 0) & 255,
        ]
      );
    }
    function s(T, w, _) {
      T = T.length <= 64 ? T : i(T);
      const k = 64 + w.length + 4,
        D = new Array(k),
        N = new Array(64);
      let B,
        j = [];
      for (B = 0; B < 64; B++) D[B] = 54;
      for (B = 0; B < T.length; B++) D[B] ^= T[B];
      for (B = 0; B < w.length; B++) D[64 + B] = w[B];
      for (B = k - 4; B < k; B++) D[B] = 0;
      for (B = 0; B < 64; B++) N[B] = 92;
      for (B = 0; B < T.length; B++) N[B] ^= T[B];
      function q() {
        for (let z = k - 1; z >= k - 4; z--) {
          if ((D[z]++, D[z] <= 255)) return;
          D[z] = 0;
        }
      }
      for (; _ >= 32; ) q(), (j = j.concat(i(N.concat(i(D))))), (_ -= 32);
      return _ > 0 && (q(), (j = j.concat(i(N.concat(i(D))).slice(0, _)))), j;
    }
    function a(T, w, _, k, D) {
      let N;
      for (p(T, (2 * _ - 1) * 16, D, 0, 16), N = 0; N < 2 * _; N++) l(T, N * 16, D, 16), u(D, k), p(D, 0, T, w + N * 16, 16);
      for (N = 0; N < _; N++) p(T, w + N * 2 * 16, T, N * 16, 16);
      for (N = 0; N < _; N++) p(T, w + (N * 2 + 1) * 16, T, (N + _) * 16, 16);
    }
    function o(T, w) {
      return (T << w) | (T >>> (32 - w));
    }
    function u(T, w) {
      p(T, 0, w, 0, 16);
      for (let _ = 8; _ > 0; _ -= 2)
        (w[4] ^= o(w[0] + w[12], 7)),
          (w[8] ^= o(w[4] + w[0], 9)),
          (w[12] ^= o(w[8] + w[4], 13)),
          (w[0] ^= o(w[12] + w[8], 18)),
          (w[9] ^= o(w[5] + w[1], 7)),
          (w[13] ^= o(w[9] + w[5], 9)),
          (w[1] ^= o(w[13] + w[9], 13)),
          (w[5] ^= o(w[1] + w[13], 18)),
          (w[14] ^= o(w[10] + w[6], 7)),
          (w[2] ^= o(w[14] + w[10], 9)),
          (w[6] ^= o(w[2] + w[14], 13)),
          (w[10] ^= o(w[6] + w[2], 18)),
          (w[3] ^= o(w[15] + w[11], 7)),
          (w[7] ^= o(w[3] + w[15], 9)),
          (w[11] ^= o(w[7] + w[3], 13)),
          (w[15] ^= o(w[11] + w[7], 18)),
          (w[1] ^= o(w[0] + w[3], 7)),
          (w[2] ^= o(w[1] + w[0], 9)),
          (w[3] ^= o(w[2] + w[1], 13)),
          (w[0] ^= o(w[3] + w[2], 18)),
          (w[6] ^= o(w[5] + w[4], 7)),
          (w[7] ^= o(w[6] + w[5], 9)),
          (w[4] ^= o(w[7] + w[6], 13)),
          (w[5] ^= o(w[4] + w[7], 18)),
          (w[11] ^= o(w[10] + w[9], 7)),
          (w[8] ^= o(w[11] + w[10], 9)),
          (w[9] ^= o(w[8] + w[11], 13)),
          (w[10] ^= o(w[9] + w[8], 18)),
          (w[12] ^= o(w[15] + w[14], 7)),
          (w[13] ^= o(w[12] + w[15], 9)),
          (w[14] ^= o(w[13] + w[12], 13)),
          (w[15] ^= o(w[14] + w[13], 18));
      for (let _ = 0; _ < 16; ++_) T[_] += w[_];
    }
    function l(T, w, _, k) {
      for (let D = 0; D < k; D++) _[D] ^= T[w + D];
    }
    function p(T, w, _, k, D) {
      for (; D--; ) _[k++] = T[w++];
    }
    function h(T) {
      if (!T || typeof T.length != 'number') return !1;
      for (let w = 0; w < T.length; w++) {
        const _ = T[w];
        if (typeof _ != 'number' || _ % 1 || _ < 0 || _ >= 256) return !1;
      }
      return !0;
    }
    function b(T, w) {
      if (typeof T != 'number' || T % 1) throw new Error('invalid ' + w);
      return T;
    }
    function E(T, w, _, k, D, N, B) {
      if (((_ = b(_, 'N')), (k = b(k, 'r')), (D = b(D, 'p')), (N = b(N, 'dkLen')), _ === 0 || _ & (_ - 1))) throw new Error('N must be power of 2');
      if (_ > 2147483647 / 128 / k) throw new Error('N too large');
      if (k > 2147483647 / 128 / D) throw new Error('r too large');
      if (!h(T)) throw new Error('password must be an array or buffer');
      if (((T = Array.prototype.slice.call(T)), !h(w))) throw new Error('salt must be an array or buffer');
      w = Array.prototype.slice.call(w);
      let j = s(T, w, D * 128 * k);
      const q = new Uint32Array(D * 32 * k);
      for (let I = 0; I < q.length; I++) {
        const f = I * 4;
        q[I] = ((j[f + 3] & 255) << 24) | ((j[f + 2] & 255) << 16) | ((j[f + 1] & 255) << 8) | ((j[f + 0] & 255) << 0);
      }
      const z = new Uint32Array(64 * k),
        Y = new Uint32Array(32 * k * _),
        ae = 32 * k,
        J = new Uint32Array(16),
        oe = new Uint32Array(16),
        S = D * _ * 2;
      let c = 0,
        y = null,
        v = !1,
        C = 0,
        A = 0,
        M,
        P;
      const m = B ? parseInt(1e3 / k) : 4294967295,
        d = typeof setImmediate < 'u' ? setImmediate : setTimeout,
        g = function () {
          if (v) return B(new Error('cancelled'), c / S);
          let I;
          switch (C) {
            case 0:
              (P = A * 32 * k), p(q, P, z, 0, ae), (C = 1), (M = 0);
            case 1:
              (I = _ - M), I > m && (I = m);
              for (let R = 0; R < I; R++) p(z, 0, Y, (M + R) * ae, ae), a(z, ae, k, J, oe);
              if (((M += I), (c += I), B)) {
                const R = parseInt((1e3 * c) / S);
                if (R !== y) {
                  if (((v = B(null, c / S)), v)) break;
                  y = R;
                }
              }
              if (M < _) break;
              (M = 0), (C = 2);
            case 2:
              (I = _ - M), I > m && (I = m);
              for (let R = 0; R < I; R++) {
                const L = (2 * k - 1) * 16,
                  F = z[L] & (_ - 1);
                l(Y, F * ae, z, ae), a(z, ae, k, J, oe);
              }
              if (((M += I), (c += I), B)) {
                const R = parseInt((1e3 * c) / S);
                if (R !== y) {
                  if (((v = B(null, c / S)), v)) break;
                  y = R;
                }
              }
              if (M < _) break;
              if ((p(z, 0, q, P, ae), A++, A < D)) {
                C = 0;
                break;
              }
              j = [];
              for (let R = 0; R < q.length; R++) j.push((q[R] >> 0) & 255), j.push((q[R] >> 8) & 255), j.push((q[R] >> 16) & 255), j.push((q[R] >> 24) & 255);
              const f = s(T, j, N);
              return B && B(null, 1, f), f;
          }
          B && d(g);
        };
      if (!B)
        for (;;) {
          const I = g();
          if (I != null) return I;
        }
      g();
    }
    const x = {
      scrypt: function (T, w, _, k, D, N, B) {
        return new Promise(function (j, q) {
          let z = 0;
          B && B(0),
            E(T, w, _, k, D, N, function (Y, ae, J) {
              if (Y) q(Y);
              else if (J) B && z !== 1 && B(1), j(new Uint8Array(J));
              else if (B && ae !== z) return (z = ae), B(ae);
            });
        });
      },
      syncScrypt: function (T, w, _, k, D, N) {
        return new Uint8Array(E(T, w, _, k, D, N));
      },
    };
    n.exports = x;
  })();
})(k9);
const u0 = uh,
  O9 = 'random/5.7.0',
  lh = new O(O9);
function B9() {
  if (typeof self < 'u') return self;
  if (typeof window < 'u') return window;
  if (typeof oa < 'u') return oa;
  throw new Error('unable to locate global object');
}
const l2 = B9();
let bc = l2.crypto || l2.msCrypto;
(!bc || !bc.getRandomValues) &&
  (lh.warn('WARNING: Missing strong random number source'),
  (bc = {
    getRandomValues: function (n) {
      return lh.throwError('no secure random source avaialble', O.errors.UNSUPPORTED_OPERATION, {
        operation: 'crypto.getRandomValues',
      });
    },
  }));
function qa(n) {
  (n <= 0 || n > 1024 || n % 1 || n != n) && lh.throwArgumentError('invalid length', 'length', n);
  const e = new Uint8Array(n);
  return bc.getRandomValues(e), H(e);
}
function N9(n) {
  n = n.slice();
  for (let e = n.length - 1; e > 0; e--) {
    const t = Math.floor(Math.random() * (e + 1)),
      r = n[e];
    (n[e] = n[t]), (n[t] = r);
  }
  return n;
}
const D9 = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      randomBytes: qa,
      shuffled: N9,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
var F9 =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const ch = new O(J6);
function c2(n) {
  return n != null && n.mnemonic && n.mnemonic.phrase;
}
class L9 extends xs {
  isKeystoreAccount(e) {
    return !!(e && e._isKeystoreAccount);
  }
}
function $9(n, e, t) {
  if (Ot(n, 'crypto/cipher') === 'aes-128-ctr') {
    const i = ea(Ot(n, 'crypto/cipherparams/iv')),
      s = new jr.Counter(i),
      a = new jr.ModeOfOperation.ctr(e, s);
    return H(a.decrypt(t));
  }
  return null;
}
function Q6(n, e) {
  const t = ea(Ot(n, 'crypto/ciphertext'));
  if (K(Ie($e([e.slice(16, 32), t]))).substring(2) !== Ot(n, 'crypto/mac').toLowerCase()) throw new Error('invalid password');
  const i = $9(n, e.slice(0, 16), t);
  i ||
    ch.throwError('unsupported cipher', O.errors.UNSUPPORTED_OPERATION, {
      operation: 'decrypt',
    });
  const s = e.slice(32, 64),
    a = us(i);
  if (n.address) {
    let u = n.address.toLowerCase();
    if ((u.substring(0, 2) !== '0x' && (u = '0x' + u), Oe(u) !== a)) throw new Error('address mismatch');
  }
  const o = {
    _isKeystoreAccount: !0,
    address: a,
    privateKey: K(i),
  };
  if (Ot(n, 'x-ethers/version') === '0.1') {
    const u = ea(Ot(n, 'x-ethers/mnemonicCiphertext')),
      l = ea(Ot(n, 'x-ethers/mnemonicCounter')),
      p = new jr.Counter(l),
      h = new jr.ModeOfOperation.ctr(s, p),
      b = Ot(n, 'x-ethers/path') || yo,
      E = Ot(n, 'x-ethers/locale') || 'en',
      x = H(h.decrypt(u));
    try {
      const T = jd(x, E),
        w = Gn.fromMnemonic(T, null, E).derivePath(b);
      if (w.privateKey != o.privateKey) throw new Error('mnemonic mismatch');
      o.mnemonic = w.mnemonic;
    } catch (T) {
      if (T.code !== O.errors.INVALID_ARGUMENT || T.argument !== 'wordlist') throw T;
    }
  }
  return new L9(o);
}
function Y6(n, e, t, r, i) {
  return H(i0(n, e, t, r, i));
}
function U9(n, e, t, r, i) {
  return Promise.resolve(Y6(n, e, t, r, i));
}
function X6(n, e, t, r, i) {
  const s = a0(e),
    a = Ot(n, 'crypto/kdf');
  if (a && typeof a == 'string') {
    const o = function (u, l) {
      return ch.throwArgumentError('invalid key-derivation function parameters', u, l);
    };
    if (a.toLowerCase() === 'scrypt') {
      const u = ea(Ot(n, 'crypto/kdfparams/salt')),
        l = parseInt(Ot(n, 'crypto/kdfparams/n')),
        p = parseInt(Ot(n, 'crypto/kdfparams/r')),
        h = parseInt(Ot(n, 'crypto/kdfparams/p'));
      (!l || !p || !h) && o('kdf', a), l & (l - 1) && o('N', l);
      const b = parseInt(Ot(n, 'crypto/kdfparams/dklen'));
      return b !== 32 && o('dklen', b), r(s, u, l, p, h, 64, i);
    } else if (a.toLowerCase() === 'pbkdf2') {
      const u = ea(Ot(n, 'crypto/kdfparams/salt'));
      let l = null;
      const p = Ot(n, 'crypto/kdfparams/prf');
      p === 'hmac-sha256' ? (l = 'sha256') : p === 'hmac-sha512' ? (l = 'sha512') : o('prf', p);
      const h = parseInt(Ot(n, 'crypto/kdfparams/c')),
        b = parseInt(Ot(n, 'crypto/kdfparams/dklen'));
      return b !== 32 && o('dklen', b), t(s, u, h, b, l);
    }
  }
  return ch.throwArgumentError('unsupported key-derivation function', 'kdf', a);
}
function Z6(n, e) {
  const t = JSON.parse(n),
    r = X6(t, e, Y6, u0.syncScrypt);
  return Q6(t, r);
}
function e5(n, e, t) {
  return F9(this, void 0, void 0, function* () {
    const r = JSON.parse(n),
      i = yield X6(r, e, U9, u0.scrypt, t);
    return Q6(r, i);
  });
}
function t5(n, e, t, r) {
  try {
    if (Oe(n.address) !== us(n.privateKey)) throw new Error('address/privateKey mismatch');
    if (c2(n)) {
      const w = n.mnemonic;
      if (Gn.fromMnemonic(w.phrase, null, w.locale).derivePath(w.path || yo).privateKey != n.privateKey) throw new Error('mnemonic mismatch');
    }
  } catch (w) {
    return Promise.reject(w);
  }
  typeof t == 'function' && !r && ((r = t), (t = {})), t || (t = {});
  const i = H(n.privateKey),
    s = a0(e);
  let a = null,
    o = null,
    u = null;
  if (c2(n)) {
    const w = n.mnemonic;
    (a = H(Ud(w.phrase, w.locale || 'en'))), (o = w.path || yo), (u = w.locale || 'en');
  }
  let l = t.client;
  l || (l = 'ethers.js');
  let p = null;
  t.salt ? (p = H(t.salt)) : (p = qa(32));
  let h = null;
  if (t.iv) {
    if (((h = H(t.iv)), h.length !== 16)) throw new Error('invalid iv');
  } else h = qa(16);
  let b = null;
  if (t.uuid) {
    if (((b = H(t.uuid)), b.length !== 16)) throw new Error('invalid uuid');
  } else b = qa(16);
  let E = 1 << 17,
    x = 8,
    T = 1;
  return (
    t.scrypt && (t.scrypt.N && (E = t.scrypt.N), t.scrypt.r && (x = t.scrypt.r), t.scrypt.p && (T = t.scrypt.p)),
    u0.scrypt(s, p, E, x, T, 64, r).then((w) => {
      w = H(w);
      const _ = w.slice(0, 16),
        k = w.slice(16, 32),
        D = w.slice(32, 64),
        N = new jr.Counter(h),
        B = new jr.ModeOfOperation.ctr(_, N),
        j = H(B.encrypt(i)),
        q = Ie($e([k, j])),
        z = {
          address: n.address.substring(2).toLowerCase(),
          id: _9(b),
          version: 3,
          crypto: {
            cipher: 'aes-128-ctr',
            cipherparams: {
              iv: K(h).substring(2),
            },
            ciphertext: K(j).substring(2),
            kdf: 'scrypt',
            kdfparams: {
              salt: K(p).substring(2),
              n: E,
              dklen: 32,
              p: T,
              r: x,
            },
            mac: q.substring(2),
          },
        };
      if (a) {
        const Y = qa(16),
          ae = new jr.Counter(Y),
          J = new jr.ModeOfOperation.ctr(D, ae),
          oe = H(J.encrypt(a)),
          S = /* @__PURE__ */ new Date(),
          c =
            S.getUTCFullYear() +
            '-' +
            Vo(S.getUTCMonth() + 1, 2) +
            '-' +
            Vo(S.getUTCDate(), 2) +
            'T' +
            Vo(S.getUTCHours(), 2) +
            '-' +
            Vo(S.getUTCMinutes(), 2) +
            '-' +
            Vo(S.getUTCSeconds(), 2) +
            '.0Z';
        z['x-ethers'] = {
          client: l,
          gethFilename: 'UTC--' + c + '--' + z.address,
          mnemonicCounter: K(Y).substring(2),
          mnemonicCiphertext: K(oe).substring(2),
          path: o,
          locale: u,
          version: '0.1',
        };
      }
      return JSON.stringify(z);
    })
  );
}
function n5(n, e, t) {
  if (Vd(n)) {
    t && t(0);
    const r = o0(n, e);
    return t && t(1), Promise.resolve(r);
  }
  return zd(n) ? e5(n, e, t) : Promise.reject(new Error('invalid JSON wallet'));
}
function r5(n, e) {
  if (Vd(n)) return o0(n, e);
  if (zd(n)) return Z6(n, e);
  throw new Error('invalid JSON wallet');
}
const j9 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        decryptCrowdsale: o0,
        decryptJsonWallet: n5,
        decryptJsonWalletSync: r5,
        decryptKeystore: e5,
        decryptKeystoreSync: Z6,
        encryptKeystore: t5,
        getJsonWalletAddress: I9,
        isCrowdsaleWallet: Vd,
        isKeystoreWallet: zd,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  V9 = /* @__PURE__ */ It(j9),
  z9 = /* @__PURE__ */ It(U7),
  G9 = /* @__PURE__ */ It(WE),
  d2 = /* @__PURE__ */ It(h9),
  H9 = 'solidity/5.7.0',
  K9 = new RegExp('^bytes([0-9]+)$'),
  q9 = new RegExp('^(u?int)([0-9]*)$'),
  W9 = new RegExp('^(.*)\\[([0-9]*)\\]$'),
  J9 = '0000000000000000000000000000000000000000000000000000000000000000',
  Va = new O(H9);
function i5(n, e, t) {
  switch (n) {
    case 'address':
      return t ? lu(e, 32) : H(e);
    case 'string':
      return Nt(e);
    case 'bytes':
      return H(e);
    case 'bool':
      return (e = e ? '0x01' : '0x00'), t ? lu(e, 32) : H(e);
  }
  let r = n.match(q9);
  if (r) {
    let i = parseInt(r[2] || '256');
    return ((r[2] && String(i) !== r[2]) || i % 8 !== 0 || i === 0 || i > 256) && Va.throwArgumentError('invalid number type', 'type', n), t && (i = 256), (e = G.from(e).toTwos(i)), lu(e, i / 8);
  }
  if (((r = n.match(K9)), r)) {
    const i = parseInt(r[1]);
    return (
      (String(i) !== r[1] || i === 0 || i > 32) && Va.throwArgumentError('invalid bytes type', 'type', n),
      H(e).byteLength !== i && Va.throwArgumentError(`invalid value for ${n}`, 'value', e),
      t ? H((e + J9).substring(0, 66)) : e
    );
  }
  if (((r = n.match(W9)), r && Array.isArray(e))) {
    const i = r[1];
    parseInt(r[2] || String(e.length)) != e.length && Va.throwArgumentError(`invalid array length for ${n}`, 'value', e);
    const a = [];
    return (
      e.forEach(function (o) {
        a.push(i5(i, o, !0));
      }),
      $e(a)
    );
  }
  return Va.throwArgumentError('invalid type', 'type', n);
}
function l0(n, e) {
  n.length != e.length && Va.throwArgumentError('wrong number of values; expected ${ types.length }', 'values', e);
  const t = [];
  return (
    n.forEach(function (r, i) {
      t.push(i5(r, e[i]));
    }),
    K($e(t))
  );
}
function Q9(n, e) {
  return Ie(l0(n, e));
}
function Y9(n, e) {
  return Pi(l0(n, e));
}
const X9 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        keccak256: Q9,
        pack: l0,
        sha256: Y9,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Z9 = /* @__PURE__ */ It(X9),
  eR = /* @__PURE__ */ It(D9),
  tR = /* @__PURE__ */ It(s7),
  nR = /* @__PURE__ */ It(V7),
  rR = /* @__PURE__ */ It(i_),
  p2 = /* @__PURE__ */ It(MC),
  iR = /* @__PURE__ */ It(p_),
  sR = 'units/5.7.0',
  s5 = new O(sR),
  a5 = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'];
function aR(n) {
  const e = String(n).split('.');
  (e.length > 2 || !e[0].match(/^-?[0-9]*$/) || (e[1] && !e[1].match(/^[0-9]*$/)) || n === '.' || n === '-.') && s5.throwArgumentError('invalid value', 'value', n);
  let t = e[0],
    r = '';
  for (t.substring(0, 1) === '-' && ((r = '-'), (t = t.substring(1))); t.substring(0, 1) === '0'; ) t = t.substring(1);
  t === '' && (t = '0');
  let i = '';
  for (e.length === 2 && (i = '.' + (e[1] || '0')); i.length > 2 && i[i.length - 1] === '0'; ) i = i.substring(0, i.length - 1);
  const s = [];
  for (; t.length; )
    if (t.length <= 3) {
      s.unshift(t);
      break;
    } else {
      const a = t.length - 3;
      s.unshift(t.substring(a)), (t = t.substring(0, a));
    }
  return r + s.join(',') + i;
}
function o5(n, e) {
  if (typeof e == 'string') {
    const t = a5.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return cc(n, e ?? 18);
}
function u5(n, e) {
  if ((typeof n != 'string' && s5.throwArgumentError('value must be a string', 'value', n), typeof e == 'string')) {
    const t = a5.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return Or(n, e ?? 18);
}
function oR(n) {
  return o5(n, 18);
}
function uR(n) {
  return u5(n, 18);
}
const lR = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        commify: aR,
        formatEther: oR,
        formatUnits: o5,
        parseEther: uR,
        parseUnits: u5,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  cR = /* @__PURE__ */ It(lR),
  dR = 'wallet/5.7.0';
var f2 =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const Ba = new O(dR);
function pR(n) {
  return n != null && Ae(n.privateKey, 32) && n.address != null;
}
function fR(n) {
  const e = n.mnemonic;
  return e && e.phrase;
}
class Ws extends _a {
  constructor(e, t) {
    if ((super(), pR(e))) {
      const r = new Zs(e.privateKey);
      if (
        (U(this, '_signingKey', () => r),
        U(this, 'address', us(this.publicKey)),
        this.address !== Oe(e.address) && Ba.throwArgumentError('privateKey/address mismatch', 'privateKey', '[REDACTED]'),
        fR(e))
      ) {
        const i = e.mnemonic;
        U(this, '_mnemonic', () => ({
          phrase: i.phrase,
          path: i.path || yo,
          locale: i.locale || 'en',
        }));
        const s = this.mnemonic,
          a = Gn.fromMnemonic(s.phrase, null, s.locale).derivePath(s.path);
        us(a.privateKey) !== this.address && Ba.throwArgumentError('mnemonic/address mismatch', 'privateKey', '[REDACTED]');
      } else U(this, '_mnemonic', () => null);
    } else {
      if (Zs.isSigningKey(e)) e.curve !== 'secp256k1' && Ba.throwArgumentError('unsupported curve; must be secp256k1', 'privateKey', '[REDACTED]'), U(this, '_signingKey', () => e);
      else {
        typeof e == 'string' && e.match(/^[0-9a-f]*$/i) && e.length === 64 && (e = '0x' + e);
        const r = new Zs(e);
        U(this, '_signingKey', () => r);
      }
      U(this, '_mnemonic', () => null), U(this, 'address', us(this.publicKey));
    }
    t && !Gy.isProvider(t) && Ba.throwArgumentError('invalid provider', 'provider', t), U(this, 'provider', t || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(e) {
    return new Ws(this, e);
  }
  signTransaction(e) {
    return Mt(e).then((t) => {
      t.from != null && (Oe(t.from) !== this.address && Ba.throwArgumentError('transaction from address mismatch', 'transaction.from', e.from), delete t.from);
      const r = this._signingKey().signDigest(Ie(sh(t)));
      return sh(t, r);
    });
  }
  signMessage(e) {
    return f2(this, void 0, void 0, function* () {
      return Wf(this._signingKey().signDigest(zy(e)));
    });
  }
  _signTypedData(e, t, r) {
    return f2(this, void 0, void 0, function* () {
      const i = yield Zt.resolveNames(
        e,
        t,
        r,
        (s) => (
          this.provider == null &&
            Ba.throwError('cannot resolve ENS names without a provider', O.errors.UNSUPPORTED_OPERATION, {
              operation: 'resolveName',
              value: s,
            }),
          this.provider.resolveName(s)
        ),
      );
      return Wf(this._signingKey().signDigest(Zt.hash(i.domain, t, i.value)));
    });
  }
  encrypt(e, t, r) {
    if ((typeof t == 'function' && !r && ((r = t), (t = {})), r && typeof r != 'function')) throw new Error('invalid callback');
    return t || (t = {}), t5(this, e, t, r);
  }
  /**
   *  Static methods to create Wallet instances.
   */
  static createRandom(e) {
    let t = qa(16);
    e || (e = {}), e.extraEntropy && (t = H(Bt(Ie($e([t, e.extraEntropy])), 0, 16)));
    const r = jd(t, e.locale);
    return Ws.fromMnemonic(r, e.path, e.locale);
  }
  static fromEncryptedJson(e, t, r) {
    return n5(e, t, r).then((i) => new Ws(i));
  }
  static fromEncryptedJsonSync(e, t) {
    return new Ws(r5(e, t));
  }
  static fromMnemonic(e, t, r) {
    return t || (t = yo), new Ws(Gn.fromMnemonic(e, null, r).derivePath(t));
  }
}
function hR(n, e) {
  return Oo(zy(n), e);
}
function yR(n, e, t, r) {
  return Oo(Zt.hash(n, e, t), r);
}
const mR = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        Wallet: Ws,
        verifyMessage: hR,
        verifyTypedData: yR,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  bR = /* @__PURE__ */ It(mR),
  gR = 'web/5.7.1';
var vR =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
function xR(n, e) {
  return vR(this, void 0, void 0, function* () {
    e == null && (e = {});
    const t = {
      method: e.method || 'GET',
      headers: e.headers || {},
      body: e.body || void 0,
    };
    if ((e.skipFetchSetup !== !0 && ((t.mode = 'cors'), (t.cache = 'no-cache'), (t.credentials = 'same-origin'), (t.redirect = 'follow'), (t.referrer = 'client')), e.fetchOptions != null)) {
      const a = e.fetchOptions;
      a.mode && (t.mode = a.mode), a.cache && (t.cache = a.cache), a.credentials && (t.credentials = a.credentials), a.redirect && (t.redirect = a.redirect), a.referrer && (t.referrer = a.referrer);
    }
    const r = yield fetch(n, t),
      i = yield r.arrayBuffer(),
      s = {};
    return (
      r.headers.forEach
        ? r.headers.forEach((a, o) => {
            s[o.toLowerCase()] = a;
          })
        : r.headers.keys().forEach((a) => {
            s[a.toLowerCase()] = r.headers.get(a);
          }),
      {
        headers: s,
        statusCode: r.status,
        statusMessage: r.statusText,
        body: H(new Uint8Array(i)),
      }
    );
  });
}
var wR =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const gr = new O(gR);
function h2(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function Ji(n, e) {
  if (n == null) return null;
  if (typeof n == 'string') return n;
  if (bl(n)) {
    if (e && (e.split('/')[0] === 'text' || e.split(';')[0].trim() === 'application/json'))
      try {
        return ws(n);
      } catch {}
    return K(n);
  }
  return n;
}
function TR(n) {
  return Nt(n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))));
}
function l5(n, e, t) {
  const r = typeof n == 'object' && n.throttleLimit != null ? n.throttleLimit : 12;
  gr.assertArgument(r > 0 && r % 1 === 0, 'invalid connection throttle limit', 'connection.throttleLimit', r);
  const i = typeof n == 'object' ? n.throttleCallback : null,
    s = typeof n == 'object' && typeof n.throttleSlotInterval == 'number' ? n.throttleSlotInterval : 100;
  gr.assertArgument(s > 0 && s % 1 === 0, 'invalid connection throttle slot interval', 'connection.throttleSlotInterval', s);
  const a = typeof n == 'object' ? !!n.errorPassThrough : !1,
    o = {};
  let u = null;
  const l = {
    method: 'GET',
  };
  let p = !1,
    h = 2 * 60 * 1e3;
  if (typeof n == 'string') u = n;
  else if (typeof n == 'object') {
    if (((n == null || n.url == null) && gr.throwArgumentError('missing URL', 'connection.url', n), (u = n.url), typeof n.timeout == 'number' && n.timeout > 0 && (h = n.timeout), n.headers))
      for (const _ in n.headers) (o[_.toLowerCase()] = { key: _, value: String(n.headers[_]) }), ['if-none-match', 'if-modified-since'].indexOf(_.toLowerCase()) >= 0 && (p = !0);
    if (((l.allowGzip = !!n.allowGzip), n.user != null && n.password != null)) {
      u.substring(0, 6) !== 'https:' &&
        n.allowInsecureAuthentication !== !0 &&
        gr.throwError('basic authentication requires a secure https url', O.errors.INVALID_ARGUMENT, { argument: 'url', url: u, user: n.user, password: '[REDACTED]' });
      const _ = n.user + ':' + n.password;
      o.authorization = {
        key: 'Authorization',
        value: 'Basic ' + Vy(Nt(_)),
      };
    }
    n.skipFetchSetup != null && (l.skipFetchSetup = !!n.skipFetchSetup), n.fetchOptions != null && (l.fetchOptions = $t(n.fetchOptions));
  }
  const b = new RegExp('^data:([^;:]*)?(;base64)?,(.*)$', 'i'),
    E = u ? u.match(b) : null;
  if (E)
    try {
      const _ = {
        statusCode: 200,
        statusMessage: 'OK',
        headers: { 'content-type': E[1] || 'text/plain' },
        body: E[2] ? jy(E[3]) : TR(E[3]),
      };
      let k = _.body;
      return t && (k = t(_.body, _)), Promise.resolve(k);
    } catch (_) {
      gr.throwError('processing response error', O.errors.SERVER_ERROR, {
        body: Ji(E[1], E[2]),
        error: _,
        requestBody: null,
        requestMethod: 'GET',
        url: u,
      });
    }
  e &&
    ((l.method = 'POST'),
    (l.body = e),
    o['content-type'] == null && (o['content-type'] = { key: 'Content-Type', value: 'application/octet-stream' }),
    o['content-length'] == null && (o['content-length'] = { key: 'Content-Length', value: String(e.length) }));
  const x = {};
  Object.keys(o).forEach((_) => {
    const k = o[_];
    x[k.key] = k.value;
  }),
    (l.headers = x);
  const T = (function () {
      let _ = null;
      return {
        promise: new Promise(function (N, B) {
          h &&
            (_ = setTimeout(() => {
              _ != null &&
                ((_ = null),
                B(
                  gr.makeError('timeout', O.errors.TIMEOUT, {
                    requestBody: Ji(l.body, x['content-type']),
                    requestMethod: l.method,
                    timeout: h,
                    url: u,
                  }),
                ));
            }, h));
        }),
        cancel: function () {
          _ != null && (clearTimeout(_), (_ = null));
        },
      };
    })(),
    w = (function () {
      return wR(this, void 0, void 0, function* () {
        for (let _ = 0; _ < r; _++) {
          let k = null;
          try {
            if (((k = yield xR(u, l)), _ < r)) {
              if (k.statusCode === 301 || k.statusCode === 302) {
                const N = k.headers.location || '';
                if (l.method === 'GET' && N.match(/^https:/)) {
                  u = k.headers.location;
                  continue;
                }
              } else if (k.statusCode === 429) {
                let N = !0;
                if ((i && (N = yield i(_, u)), N)) {
                  let B = 0;
                  const j = k.headers['retry-after'];
                  typeof j == 'string' && j.match(/^[1-9][0-9]*$/) ? (B = parseInt(j) * 1e3) : (B = s * parseInt(String(Math.random() * Math.pow(2, _)))), yield h2(B);
                  continue;
                }
              }
            }
          } catch (N) {
            (k = N.response),
              k == null &&
                (T.cancel(),
                gr.throwError('missing response', O.errors.SERVER_ERROR, {
                  requestBody: Ji(l.body, x['content-type']),
                  requestMethod: l.method,
                  serverError: N,
                  url: u,
                }));
          }
          let D = k.body;
          if (
            (p && k.statusCode === 304
              ? (D = null)
              : !a &&
                (k.statusCode < 200 || k.statusCode >= 300) &&
                (T.cancel(),
                gr.throwError('bad response', O.errors.SERVER_ERROR, {
                  status: k.statusCode,
                  headers: k.headers,
                  body: Ji(D, k.headers ? k.headers['content-type'] : null),
                  requestBody: Ji(l.body, x['content-type']),
                  requestMethod: l.method,
                  url: u,
                })),
            t)
          )
            try {
              const N = yield t(D, k);
              return T.cancel(), N;
            } catch (N) {
              if (N.throttleRetry && _ < r) {
                let B = !0;
                if ((i && (B = yield i(_, u)), B)) {
                  const j = s * parseInt(String(Math.random() * Math.pow(2, _)));
                  yield h2(j);
                  continue;
                }
              }
              T.cancel(),
                gr.throwError('processing response error', O.errors.SERVER_ERROR, {
                  body: Ji(D, k.headers ? k.headers['content-type'] : null),
                  error: N,
                  requestBody: Ji(l.body, x['content-type']),
                  requestMethod: l.method,
                  url: u,
                });
            }
          return T.cancel(), D;
        }
        return gr.throwError('failed response', O.errors.SERVER_ERROR, {
          requestBody: Ji(l.body, x['content-type']),
          requestMethod: l.method,
          url: u,
        });
      });
    })();
  return Promise.race([T.promise, w]);
}
function Gd(n, e, t) {
  let r = (s, a) => {
      let o = null;
      if (s != null)
        try {
          o = JSON.parse(ws(s));
        } catch (u) {
          gr.throwError('invalid JSON', O.errors.SERVER_ERROR, {
            body: s,
            error: u,
          });
        }
      return t && (o = t(o, a)), o;
    },
    i = null;
  if (e != null) {
    i = Nt(e);
    const s = typeof n == 'string' ? { url: n } : $t(n);
    s.headers
      ? Object.keys(s.headers).filter((o) => o.toLowerCase() === 'content-type').length !== 0 || ((s.headers = $t(s.headers)), (s.headers['content-type'] = 'application/json'))
      : (s.headers = { 'content-type': 'application/json' }),
      (n = s);
  }
  return l5(n, i, r);
}
function Wa(n, e) {
  return (
    e || (e = {}),
    (e = $t(e)),
    e.floor == null && (e.floor = 0),
    e.ceiling == null && (e.ceiling = 1e4),
    e.interval == null && (e.interval = 250),
    new Promise(function (t, r) {
      let i = null,
        s = !1;
      const a = () => (s ? !1 : ((s = !0), i && clearTimeout(i), !0));
      e.timeout &&
        (i = setTimeout(() => {
          a() && r(new Error('timeout'));
        }, e.timeout));
      const o = e.retryLimit;
      let u = 0;
      function l() {
        return n().then(
          function (p) {
            if (p !== void 0) a() && t(p);
            else if (e.oncePoll) e.oncePoll.once('poll', l);
            else if (e.onceBlock) e.onceBlock.once('block', l);
            else if (!s) {
              if ((u++, u > o)) {
                a() && r(new Error('retry limit reached'));
                return;
              }
              let h = e.interval * parseInt(String(Math.random() * Math.pow(2, u)));
              h < e.floor && (h = e.floor), h > e.ceiling && (h = e.ceiling), setTimeout(l, h);
            }
            return null;
          },
          function (p) {
            a() && r(p);
          },
        );
      }
      l();
    })
  );
}
const AR = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        _fetchData: l5,
        fetchJson: Gd,
        poll: Wa,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  ER = /* @__PURE__ */ It(AR);
(function (n) {
  var e =
      (es && es.__createBinding) ||
      (Object.create
        ? function (J, oe, S, c) {
            c === void 0 && (c = S),
              Object.defineProperty(J, c, {
                enumerable: !0,
                get: function () {
                  return oe[S];
                },
              });
          }
        : function (J, oe, S, c) {
            c === void 0 && (c = S), (J[c] = oe[S]);
          }),
    t =
      (es && es.__setModuleDefault) ||
      (Object.create
        ? function (J, oe) {
            Object.defineProperty(J, 'default', { enumerable: !0, value: oe });
          }
        : function (J, oe) {
            J.default = oe;
          }),
    r =
      (es && es.__importStar) ||
      function (J) {
        if (J && J.__esModule) return J;
        var oe = {};
        if (J != null) for (var S in J) S !== 'default' && Object.prototype.hasOwnProperty.call(J, S) && e(oe, J, S);
        return t(oe, J), oe;
      };
  Object.defineProperty(n, '__esModule', { value: !0 }),
    (n.formatBytes32String =
      n.Utf8ErrorFuncs =
      n.toUtf8String =
      n.toUtf8CodePoints =
      n.toUtf8Bytes =
      n._toEscapedUtf8String =
      n.nameprep =
      n.hexDataSlice =
      n.hexDataLength =
      n.hexZeroPad =
      n.hexValue =
      n.hexStripZeros =
      n.hexConcat =
      n.isHexString =
      n.hexlify =
      n.base64 =
      n.base58 =
      n.TransactionDescription =
      n.LogDescription =
      n.Interface =
      n.SigningKey =
      n.HDNode =
      n.defaultPath =
      n.isBytesLike =
      n.isBytes =
      n.zeroPad =
      n.stripZeros =
      n.concat =
      n.arrayify =
      n.shallowCopy =
      n.resolveProperties =
      n.getStatic =
      n.defineReadOnly =
      n.deepCopy =
      n.checkProperties =
      n.poll =
      n.fetchJson =
      n._fetchData =
      n.RLP =
      n.Logger =
      n.checkResultErrors =
      n.FormatTypes =
      n.ParamType =
      n.FunctionFragment =
      n.EventFragment =
      n.ErrorFragment =
      n.ConstructorFragment =
      n.Fragment =
      n.defaultAbiCoder =
      n.AbiCoder =
        void 0),
    (n.Indexed =
      n.Utf8ErrorReason =
      n.UnicodeNormalizationForm =
      n.SupportedAlgorithm =
      n.mnemonicToSeed =
      n.isValidMnemonic =
      n.entropyToMnemonic =
      n.mnemonicToEntropy =
      n.getAccountPath =
      n.verifyTypedData =
      n.verifyMessage =
      n.recoverPublicKey =
      n.computePublicKey =
      n.recoverAddress =
      n.computeAddress =
      n.getJsonWalletAddress =
      n.TransactionTypes =
      n.serializeTransaction =
      n.parseTransaction =
      n.accessListify =
      n.joinSignature =
      n.splitSignature =
      n.soliditySha256 =
      n.solidityKeccak256 =
      n.solidityPack =
      n.shuffled =
      n.randomBytes =
      n.sha512 =
      n.sha256 =
      n.ripemd160 =
      n.keccak256 =
      n.computeHmac =
      n.commify =
      n.parseUnits =
      n.formatUnits =
      n.parseEther =
      n.formatEther =
      n.isAddress =
      n.getCreate2Address =
      n.getContractAddress =
      n.getIcapAddress =
      n.getAddress =
      n._TypedDataEncoder =
      n.id =
      n.isValidName =
      n.namehash =
      n.hashMessage =
      n.dnsEncode =
      n.parseBytes32String =
        void 0);
  var i = r9;
  Object.defineProperty(n, 'AbiCoder', {
    enumerable: !0,
    get: function () {
      return i.AbiCoder;
    },
  }),
    Object.defineProperty(n, 'checkResultErrors', {
      enumerable: !0,
      get: function () {
        return i.checkResultErrors;
      },
    }),
    Object.defineProperty(n, 'ConstructorFragment', {
      enumerable: !0,
      get: function () {
        return i.ConstructorFragment;
      },
    }),
    Object.defineProperty(n, 'defaultAbiCoder', {
      enumerable: !0,
      get: function () {
        return i.defaultAbiCoder;
      },
    }),
    Object.defineProperty(n, 'ErrorFragment', {
      enumerable: !0,
      get: function () {
        return i.ErrorFragment;
      },
    }),
    Object.defineProperty(n, 'EventFragment', {
      enumerable: !0,
      get: function () {
        return i.EventFragment;
      },
    }),
    Object.defineProperty(n, 'FormatTypes', {
      enumerable: !0,
      get: function () {
        return i.FormatTypes;
      },
    }),
    Object.defineProperty(n, 'Fragment', {
      enumerable: !0,
      get: function () {
        return i.Fragment;
      },
    }),
    Object.defineProperty(n, 'FunctionFragment', {
      enumerable: !0,
      get: function () {
        return i.FunctionFragment;
      },
    }),
    Object.defineProperty(n, 'Indexed', {
      enumerable: !0,
      get: function () {
        return i.Indexed;
      },
    }),
    Object.defineProperty(n, 'Interface', {
      enumerable: !0,
      get: function () {
        return i.Interface;
      },
    }),
    Object.defineProperty(n, 'LogDescription', {
      enumerable: !0,
      get: function () {
        return i.LogDescription;
      },
    }),
    Object.defineProperty(n, 'ParamType', {
      enumerable: !0,
      get: function () {
        return i.ParamType;
      },
    }),
    Object.defineProperty(n, 'TransactionDescription', {
      enumerable: !0,
      get: function () {
        return i.TransactionDescription;
      },
    });
  var s = i9;
  Object.defineProperty(n, 'getAddress', {
    enumerable: !0,
    get: function () {
      return s.getAddress;
    },
  }),
    Object.defineProperty(n, 'getCreate2Address', {
      enumerable: !0,
      get: function () {
        return s.getCreate2Address;
      },
    }),
    Object.defineProperty(n, 'getContractAddress', {
      enumerable: !0,
      get: function () {
        return s.getContractAddress;
      },
    }),
    Object.defineProperty(n, 'getIcapAddress', {
      enumerable: !0,
      get: function () {
        return s.getIcapAddress;
      },
    }),
    Object.defineProperty(n, 'isAddress', {
      enumerable: !0,
      get: function () {
        return s.isAddress;
      },
    });
  var a = r(s9);
  n.base64 = a;
  var o = u9;
  Object.defineProperty(n, 'base58', {
    enumerable: !0,
    get: function () {
      return o.Base58;
    },
  });
  var u = l9;
  Object.defineProperty(n, 'arrayify', {
    enumerable: !0,
    get: function () {
      return u.arrayify;
    },
  }),
    Object.defineProperty(n, 'concat', {
      enumerable: !0,
      get: function () {
        return u.concat;
      },
    }),
    Object.defineProperty(n, 'hexConcat', {
      enumerable: !0,
      get: function () {
        return u.hexConcat;
      },
    }),
    Object.defineProperty(n, 'hexDataSlice', {
      enumerable: !0,
      get: function () {
        return u.hexDataSlice;
      },
    }),
    Object.defineProperty(n, 'hexDataLength', {
      enumerable: !0,
      get: function () {
        return u.hexDataLength;
      },
    }),
    Object.defineProperty(n, 'hexlify', {
      enumerable: !0,
      get: function () {
        return u.hexlify;
      },
    }),
    Object.defineProperty(n, 'hexStripZeros', {
      enumerable: !0,
      get: function () {
        return u.hexStripZeros;
      },
    }),
    Object.defineProperty(n, 'hexValue', {
      enumerable: !0,
      get: function () {
        return u.hexValue;
      },
    }),
    Object.defineProperty(n, 'hexZeroPad', {
      enumerable: !0,
      get: function () {
        return u.hexZeroPad;
      },
    }),
    Object.defineProperty(n, 'isBytes', {
      enumerable: !0,
      get: function () {
        return u.isBytes;
      },
    }),
    Object.defineProperty(n, 'isBytesLike', {
      enumerable: !0,
      get: function () {
        return u.isBytesLike;
      },
    }),
    Object.defineProperty(n, 'isHexString', {
      enumerable: !0,
      get: function () {
        return u.isHexString;
      },
    }),
    Object.defineProperty(n, 'joinSignature', {
      enumerable: !0,
      get: function () {
        return u.joinSignature;
      },
    }),
    Object.defineProperty(n, 'zeroPad', {
      enumerable: !0,
      get: function () {
        return u.zeroPad;
      },
    }),
    Object.defineProperty(n, 'splitSignature', {
      enumerable: !0,
      get: function () {
        return u.splitSignature;
      },
    }),
    Object.defineProperty(n, 'stripZeros', {
      enumerable: !0,
      get: function () {
        return u.stripZeros;
      },
    });
  var l = c9;
  Object.defineProperty(n, '_TypedDataEncoder', {
    enumerable: !0,
    get: function () {
      return l._TypedDataEncoder;
    },
  }),
    Object.defineProperty(n, 'dnsEncode', {
      enumerable: !0,
      get: function () {
        return l.dnsEncode;
      },
    }),
    Object.defineProperty(n, 'hashMessage', {
      enumerable: !0,
      get: function () {
        return l.hashMessage;
      },
    }),
    Object.defineProperty(n, 'id', {
      enumerable: !0,
      get: function () {
        return l.id;
      },
    }),
    Object.defineProperty(n, 'isValidName', {
      enumerable: !0,
      get: function () {
        return l.isValidName;
      },
    }),
    Object.defineProperty(n, 'namehash', {
      enumerable: !0,
      get: function () {
        return l.namehash;
      },
    });
  var p = S9;
  Object.defineProperty(n, 'defaultPath', {
    enumerable: !0,
    get: function () {
      return p.defaultPath;
    },
  }),
    Object.defineProperty(n, 'entropyToMnemonic', {
      enumerable: !0,
      get: function () {
        return p.entropyToMnemonic;
      },
    }),
    Object.defineProperty(n, 'getAccountPath', {
      enumerable: !0,
      get: function () {
        return p.getAccountPath;
      },
    }),
    Object.defineProperty(n, 'HDNode', {
      enumerable: !0,
      get: function () {
        return p.HDNode;
      },
    }),
    Object.defineProperty(n, 'isValidMnemonic', {
      enumerable: !0,
      get: function () {
        return p.isValidMnemonic;
      },
    }),
    Object.defineProperty(n, 'mnemonicToEntropy', {
      enumerable: !0,
      get: function () {
        return p.mnemonicToEntropy;
      },
    }),
    Object.defineProperty(n, 'mnemonicToSeed', {
      enumerable: !0,
      get: function () {
        return p.mnemonicToSeed;
      },
    });
  var h = V9;
  Object.defineProperty(n, 'getJsonWalletAddress', {
    enumerable: !0,
    get: function () {
      return h.getJsonWalletAddress;
    },
  });
  var b = z9;
  Object.defineProperty(n, 'keccak256', {
    enumerable: !0,
    get: function () {
      return b.keccak256;
    },
  });
  var E = G9;
  Object.defineProperty(n, 'Logger', {
    enumerable: !0,
    get: function () {
      return E.Logger;
    },
  });
  var x = d2;
  Object.defineProperty(n, 'computeHmac', {
    enumerable: !0,
    get: function () {
      return x.computeHmac;
    },
  }),
    Object.defineProperty(n, 'ripemd160', {
      enumerable: !0,
      get: function () {
        return x.ripemd160;
      },
    }),
    Object.defineProperty(n, 'sha256', {
      enumerable: !0,
      get: function () {
        return x.sha256;
      },
    }),
    Object.defineProperty(n, 'sha512', {
      enumerable: !0,
      get: function () {
        return x.sha512;
      },
    });
  var T = Z9;
  Object.defineProperty(n, 'solidityKeccak256', {
    enumerable: !0,
    get: function () {
      return T.keccak256;
    },
  }),
    Object.defineProperty(n, 'solidityPack', {
      enumerable: !0,
      get: function () {
        return T.pack;
      },
    }),
    Object.defineProperty(n, 'soliditySha256', {
      enumerable: !0,
      get: function () {
        return T.sha256;
      },
    });
  var w = eR;
  Object.defineProperty(n, 'randomBytes', {
    enumerable: !0,
    get: function () {
      return w.randomBytes;
    },
  }),
    Object.defineProperty(n, 'shuffled', {
      enumerable: !0,
      get: function () {
        return w.shuffled;
      },
    });
  var _ = tR;
  Object.defineProperty(n, 'checkProperties', {
    enumerable: !0,
    get: function () {
      return _.checkProperties;
    },
  }),
    Object.defineProperty(n, 'deepCopy', {
      enumerable: !0,
      get: function () {
        return _.deepCopy;
      },
    }),
    Object.defineProperty(n, 'defineReadOnly', {
      enumerable: !0,
      get: function () {
        return _.defineReadOnly;
      },
    }),
    Object.defineProperty(n, 'getStatic', {
      enumerable: !0,
      get: function () {
        return _.getStatic;
      },
    }),
    Object.defineProperty(n, 'resolveProperties', {
      enumerable: !0,
      get: function () {
        return _.resolveProperties;
      },
    }),
    Object.defineProperty(n, 'shallowCopy', {
      enumerable: !0,
      get: function () {
        return _.shallowCopy;
      },
    });
  var k = r(nR);
  n.RLP = k;
  var D = rR;
  Object.defineProperty(n, 'computePublicKey', {
    enumerable: !0,
    get: function () {
      return D.computePublicKey;
    },
  }),
    Object.defineProperty(n, 'recoverPublicKey', {
      enumerable: !0,
      get: function () {
        return D.recoverPublicKey;
      },
    }),
    Object.defineProperty(n, 'SigningKey', {
      enumerable: !0,
      get: function () {
        return D.SigningKey;
      },
    });
  var N = p2;
  Object.defineProperty(n, 'formatBytes32String', {
    enumerable: !0,
    get: function () {
      return N.formatBytes32String;
    },
  }),
    Object.defineProperty(n, 'nameprep', {
      enumerable: !0,
      get: function () {
        return N.nameprep;
      },
    }),
    Object.defineProperty(n, 'parseBytes32String', {
      enumerable: !0,
      get: function () {
        return N.parseBytes32String;
      },
    }),
    Object.defineProperty(n, '_toEscapedUtf8String', {
      enumerable: !0,
      get: function () {
        return N._toEscapedUtf8String;
      },
    }),
    Object.defineProperty(n, 'toUtf8Bytes', {
      enumerable: !0,
      get: function () {
        return N.toUtf8Bytes;
      },
    }),
    Object.defineProperty(n, 'toUtf8CodePoints', {
      enumerable: !0,
      get: function () {
        return N.toUtf8CodePoints;
      },
    }),
    Object.defineProperty(n, 'toUtf8String', {
      enumerable: !0,
      get: function () {
        return N.toUtf8String;
      },
    }),
    Object.defineProperty(n, 'Utf8ErrorFuncs', {
      enumerable: !0,
      get: function () {
        return N.Utf8ErrorFuncs;
      },
    });
  var B = iR;
  Object.defineProperty(n, 'accessListify', {
    enumerable: !0,
    get: function () {
      return B.accessListify;
    },
  }),
    Object.defineProperty(n, 'computeAddress', {
      enumerable: !0,
      get: function () {
        return B.computeAddress;
      },
    }),
    Object.defineProperty(n, 'parseTransaction', {
      enumerable: !0,
      get: function () {
        return B.parse;
      },
    }),
    Object.defineProperty(n, 'recoverAddress', {
      enumerable: !0,
      get: function () {
        return B.recoverAddress;
      },
    }),
    Object.defineProperty(n, 'serializeTransaction', {
      enumerable: !0,
      get: function () {
        return B.serialize;
      },
    }),
    Object.defineProperty(n, 'TransactionTypes', {
      enumerable: !0,
      get: function () {
        return B.TransactionTypes;
      },
    });
  var j = cR;
  Object.defineProperty(n, 'commify', {
    enumerable: !0,
    get: function () {
      return j.commify;
    },
  }),
    Object.defineProperty(n, 'formatEther', {
      enumerable: !0,
      get: function () {
        return j.formatEther;
      },
    }),
    Object.defineProperty(n, 'parseEther', {
      enumerable: !0,
      get: function () {
        return j.parseEther;
      },
    }),
    Object.defineProperty(n, 'formatUnits', {
      enumerable: !0,
      get: function () {
        return j.formatUnits;
      },
    }),
    Object.defineProperty(n, 'parseUnits', {
      enumerable: !0,
      get: function () {
        return j.parseUnits;
      },
    });
  var q = bR;
  Object.defineProperty(n, 'verifyMessage', {
    enumerable: !0,
    get: function () {
      return q.verifyMessage;
    },
  }),
    Object.defineProperty(n, 'verifyTypedData', {
      enumerable: !0,
      get: function () {
        return q.verifyTypedData;
      },
    });
  var z = ER;
  Object.defineProperty(n, '_fetchData', {
    enumerable: !0,
    get: function () {
      return z._fetchData;
    },
  }),
    Object.defineProperty(n, 'fetchJson', {
      enumerable: !0,
      get: function () {
        return z.fetchJson;
      },
    }),
    Object.defineProperty(n, 'poll', {
      enumerable: !0,
      get: function () {
        return z.poll;
      },
    });
  var Y = d2;
  Object.defineProperty(n, 'SupportedAlgorithm', {
    enumerable: !0,
    get: function () {
      return Y.SupportedAlgorithm;
    },
  });
  var ae = p2;
  Object.defineProperty(n, 'UnicodeNormalizationForm', {
    enumerable: !0,
    get: function () {
      return ae.UnicodeNormalizationForm;
    },
  }),
    Object.defineProperty(n, 'Utf8ErrorReason', {
      enumerable: !0,
      get: function () {
        return ae.Utf8ErrorReason;
      },
    });
})(n0);
function CR(n, e) {
  if (typeof n != 'number' || Number.isInteger(n) || isNaN(n)) return n;
  const t = n.toString().split('.');
  return +`${t[0]}.${t[1].slice(0, e)}`;
}
function c5(n) {
  switch (n) {
    case Tr['1d']:
      return 'hour';
    case Tr['1h']:
      return 'minute';
    case Tr['1m']:
    case Tr['1w']:
    case Tr['1y']:
      return 'day';
  }
}
function d5(n) {
  const e = /* @__PURE__ */ new Date();
  switch (n) {
    case Tr['1h']:
      e.setMinutes(e.getMinutes() - 60);
      break;
    case Tr['1d']:
      e.setHours(e.getHours() - 24);
      break;
    case Tr['1w']:
      e.setDate(e.getDate() - 7);
      break;
    case Tr['1m']:
      e.setMonth(e.getMonth() - 1);
      break;
    case Tr['1y']:
      e.setFullYear(e.getFullYear() - 1);
      break;
  }
  return e.getTime();
}
const SR = (n, e) => {
    for (const t in e) {
      const r = new RegExp('{' + t + '}', 'gm');
      n = n.replace(r, e[t]);
    }
    return n;
  },
  y2 = (n, e) => {
    const t = typeof n;
    return (t === 'string' || t === 'number') && (n = CR(Number(n), Number(e))), n0.parseUnits(n.toString(), e);
  },
  Ct = (n, e) => n0.formatUnits(n.toString(), e),
  c0 = he.createInterface();
function MR({ mustBeMetaMask: n = !1, silent: e = !1, timeout: t = 3e3 } = {}) {
  i();
  let r = !1;
  return new Promise((s) => {
    window.ethereum
      ? a()
      : (window.addEventListener('ethereum#initialized', a, { once: !0 }),
        setTimeout(() => {
          a();
        }, t));
    function a() {
      if (r) return;
      (r = !0), window.removeEventListener('ethereum#initialized', a);
      const { ethereum: o } = window;
      o && (!n || o.isMetaMask) ? s(o) : (!e && console.error('@metamask/detect-provider:', n && o ? 'Non-MetaMask window.ethereum detected.' : 'Unable to detect window.ethereum.'), s(null));
    }
  });
  function i() {
    if (typeof n != 'boolean') throw new Error("@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.");
    if (typeof e != 'boolean') throw new Error("@metamask/detect-provider: Expected option 'silent' to be a boolean.");
    if (typeof t != 'number') throw new Error("@metamask/detect-provider: Expected option 'timeout' to be a number.");
  }
}
var _R = MR;
const RR = 'networks/5.7.1',
  m2 = new O(RR);
function PR(n) {
  return n && typeof n.renetwork == 'function';
}
function ci(n) {
  const e = function (t, r) {
    r == null && (r = {});
    const i = [];
    if (t.InfuraProvider && r.infura !== '-')
      try {
        i.push(new t.InfuraProvider(n, r.infura));
      } catch {}
    if (t.EtherscanProvider && r.etherscan !== '-')
      try {
        i.push(new t.EtherscanProvider(n, r.etherscan));
      } catch {}
    if (t.AlchemyProvider && r.alchemy !== '-')
      try {
        i.push(new t.AlchemyProvider(n, r.alchemy));
      } catch {}
    if (t.PocketProvider && r.pocket !== '-') {
      const s = ['goerli', 'ropsten', 'rinkeby', 'sepolia'];
      try {
        const a = new t.PocketProvider(n, r.pocket);
        a.network && s.indexOf(a.network.name) === -1 && i.push(a);
      } catch {}
    }
    if (t.CloudflareProvider && r.cloudflare !== '-')
      try {
        i.push(new t.CloudflareProvider(n));
      } catch {}
    if (t.AnkrProvider && r.ankr !== '-')
      try {
        const s = ['ropsten'],
          a = new t.AnkrProvider(n, r.ankr);
        a.network && s.indexOf(a.network.name) === -1 && i.push(a);
      } catch {}
    if (i.length === 0) return null;
    if (t.FallbackProvider) {
      let s = 1;
      return r.quorum != null ? (s = r.quorum) : n === 'homestead' && (s = 2), new t.FallbackProvider(i, s);
    }
    return i[0];
  };
  return (
    (e.renetwork = function (t) {
      return ci(t);
    }),
    e
  );
}
function Zc(n, e) {
  const t = function (r, i) {
    return r.JsonRpcProvider ? new r.JsonRpcProvider(n, e) : null;
  };
  return (
    (t.renetwork = function (r) {
      return Zc(n, r);
    }),
    t
  );
}
const b2 = {
    chainId: 1,
    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
    name: 'homestead',
    _defaultProvider: ci('homestead'),
  },
  g2 = {
    chainId: 3,
    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
    name: 'ropsten',
    _defaultProvider: ci('ropsten'),
  },
  v2 = {
    chainId: 63,
    name: 'classicMordor',
    _defaultProvider: Zc('https://www.ethercluster.com/mordor', 'classicMordor'),
  },
  Wl = {
    unspecified: { chainId: 0, name: 'unspecified' },
    homestead: b2,
    mainnet: b2,
    morden: { chainId: 2, name: 'morden' },
    ropsten: g2,
    testnet: g2,
    rinkeby: {
      chainId: 4,
      ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
      name: 'rinkeby',
      _defaultProvider: ci('rinkeby'),
    },
    kovan: {
      chainId: 42,
      name: 'kovan',
      _defaultProvider: ci('kovan'),
    },
    goerli: {
      chainId: 5,
      ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
      name: 'goerli',
      _defaultProvider: ci('goerli'),
    },
    kintsugi: { chainId: 1337702, name: 'kintsugi' },
    sepolia: {
      chainId: 11155111,
      name: 'sepolia',
      _defaultProvider: ci('sepolia'),
    },
    // ETC (See: #351)
    classic: {
      chainId: 61,
      name: 'classic',
      _defaultProvider: Zc('https://www.ethercluster.com/etc', 'classic'),
    },
    classicMorden: { chainId: 62, name: 'classicMorden' },
    classicMordor: v2,
    classicTestnet: v2,
    classicKotti: {
      chainId: 6,
      name: 'classicKotti',
      _defaultProvider: Zc('https://www.ethercluster.com/kotti', 'classicKotti'),
    },
    xdai: { chainId: 100, name: 'xdai' },
    matic: {
      chainId: 137,
      name: 'matic',
      _defaultProvider: ci('matic'),
    },
    maticmum: { chainId: 80001, name: 'maticmum' },
    optimism: {
      chainId: 10,
      name: 'optimism',
      _defaultProvider: ci('optimism'),
    },
    'optimism-kovan': { chainId: 69, name: 'optimism-kovan' },
    'optimism-goerli': { chainId: 420, name: 'optimism-goerli' },
    arbitrum: { chainId: 42161, name: 'arbitrum' },
    'arbitrum-rinkeby': { chainId: 421611, name: 'arbitrum-rinkeby' },
    'arbitrum-goerli': { chainId: 421613, name: 'arbitrum-goerli' },
    bnb: { chainId: 56, name: 'bnb' },
    bnbt: { chainId: 97, name: 'bnbt' },
  };
function IR(n) {
  if (n == null) return null;
  if (typeof n == 'number') {
    for (const r in Wl) {
      const i = Wl[r];
      if (i.chainId === n)
        return {
          name: i.name,
          chainId: i.chainId,
          ensAddress: i.ensAddress || null,
          _defaultProvider: i._defaultProvider || null,
        };
    }
    return {
      chainId: n,
      name: 'unknown',
    };
  }
  if (typeof n == 'string') {
    const r = Wl[n];
    return r == null
      ? null
      : {
          name: r.name,
          chainId: r.chainId,
          ensAddress: r.ensAddress,
          _defaultProvider: r._defaultProvider || null,
        };
  }
  const e = Wl[n.name];
  if (!e) return typeof n.chainId != 'number' && m2.throwArgumentError('invalid network chainId', 'network', n), n;
  n.chainId !== 0 && n.chainId !== e.chainId && m2.throwArgumentError('network chainId mismatch', 'network', n);
  let t = n._defaultProvider || null;
  return (
    t == null && e._defaultProvider && (PR(e._defaultProvider) ? (t = e._defaultProvider.renetwork(n)) : (t = e._defaultProvider)),
    {
      name: n.name,
      chainId: e.chainId,
      ensAddress: n.ensAddress || e.ensAddress || null,
      _defaultProvider: t,
    }
  );
}
var ed = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l',
  dh = {};
for (var Jl = 0; Jl < ed.length; Jl++) {
  var rf = ed.charAt(Jl);
  if (dh[rf] !== void 0) throw new TypeError(rf + ' is ambiguous');
  dh[rf] = Jl;
}
function eo(n) {
  var e = n >> 25;
  return ((n & 33554431) << 5) ^ (-((e >> 0) & 1) & 996825010) ^ (-((e >> 1) & 1) & 642813549) ^ (-((e >> 2) & 1) & 513874426) ^ (-((e >> 3) & 1) & 1027748829) ^ (-((e >> 4) & 1) & 705979059);
}
function p5(n) {
  for (var e = 1, t = 0; t < n.length; ++t) {
    var r = n.charCodeAt(t);
    if (r < 33 || r > 126) return 'Invalid prefix (' + n + ')';
    e = eo(e) ^ (r >> 5);
  }
  for (e = eo(e), t = 0; t < n.length; ++t) {
    var i = n.charCodeAt(t);
    e = eo(e) ^ (i & 31);
  }
  return e;
}
function kR(n, e, t) {
  if (((t = t || 90), n.length + 7 + e.length > t)) throw new TypeError('Exceeds length limit');
  n = n.toLowerCase();
  var r = p5(n);
  if (typeof r == 'string') throw new Error(r);
  for (var i = n + '1', s = 0; s < e.length; ++s) {
    var a = e[s];
    if (a >> 5) throw new Error('Non 5-bit word');
    (r = eo(r) ^ a), (i += ed.charAt(a));
  }
  for (s = 0; s < 6; ++s) r = eo(r);
  for (r ^= 1, s = 0; s < 6; ++s) {
    var o = (r >> ((5 - s) * 5)) & 31;
    i += ed.charAt(o);
  }
  return i;
}
function f5(n, e) {
  if (((e = e || 90), n.length < 8)) return n + ' too short';
  if (n.length > e) return 'Exceeds length limit';
  var t = n.toLowerCase(),
    r = n.toUpperCase();
  if (n !== t && n !== r) return 'Mixed-case string ' + n;
  n = t;
  var i = n.lastIndexOf('1');
  if (i === -1) return 'No separator character for ' + n;
  if (i === 0) return 'Missing prefix for ' + n;
  var s = n.slice(0, i),
    a = n.slice(i + 1);
  if (a.length < 6) return 'Data too short';
  var o = p5(s);
  if (typeof o == 'string') return o;
  for (var u = [], l = 0; l < a.length; ++l) {
    var p = a.charAt(l),
      h = dh[p];
    if (h === void 0) return 'Unknown character ' + p;
    (o = eo(o) ^ h), !(l + 6 >= a.length) && u.push(h);
  }
  return o !== 1 ? 'Invalid checksum for ' + n : { prefix: s, words: u };
}
function OR() {
  var n = f5.apply(null, arguments);
  if (typeof n == 'object') return n;
}
function BR(n) {
  var e = f5.apply(null, arguments);
  if (typeof e == 'object') return e;
  throw new Error(e);
}
function Hd(n, e, t, r) {
  for (var i = 0, s = 0, a = (1 << t) - 1, o = [], u = 0; u < n.length; ++u) for (i = (i << e) | n[u], s += e; s >= t; ) (s -= t), o.push((i >> s) & a);
  if (r) s > 0 && o.push((i << (t - s)) & a);
  else {
    if (s >= e) return 'Excess padding';
    if ((i << (t - s)) & a) return 'Non-zero padding';
  }
  return o;
}
function NR(n) {
  var e = Hd(n, 8, 5, !0);
  if (Array.isArray(e)) return e;
}
function DR(n) {
  var e = Hd(n, 8, 5, !0);
  if (Array.isArray(e)) return e;
  throw new Error(e);
}
function FR(n) {
  var e = Hd(n, 5, 8, !1);
  if (Array.isArray(e)) return e;
}
function LR(n) {
  var e = Hd(n, 5, 8, !1);
  if (Array.isArray(e)) return e;
  throw new Error(e);
}
var x2 = {
  decodeUnsafe: OR,
  decode: BR,
  encode: kR,
  toWordsUnsafe: NR,
  toWords: DR,
  fromWordsUnsafe: FR,
  fromWords: LR,
};
const d0 = 'providers/5.7.2',
  zo = new O(d0);
class ne {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const e = {},
      t = this.address.bind(this),
      r = this.bigNumber.bind(this),
      i = this.blockTag.bind(this),
      s = this.data.bind(this),
      a = this.hash.bind(this),
      o = this.hex.bind(this),
      u = this.number.bind(this),
      l = this.type.bind(this),
      p = (h) => this.data(h, !0);
    return (
      (e.transaction = {
        hash: a,
        type: l,
        accessList: ne.allowNull(this.accessList.bind(this), null),
        blockHash: ne.allowNull(a, null),
        blockNumber: ne.allowNull(u, null),
        transactionIndex: ne.allowNull(u, null),
        confirmations: ne.allowNull(u, null),
        from: t,
        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
        // must be set
        gasPrice: ne.allowNull(r),
        maxPriorityFeePerGas: ne.allowNull(r),
        maxFeePerGas: ne.allowNull(r),
        gasLimit: r,
        to: ne.allowNull(t, null),
        value: r,
        nonce: u,
        data: s,
        r: ne.allowNull(this.uint256),
        s: ne.allowNull(this.uint256),
        v: ne.allowNull(u),
        creates: ne.allowNull(t, null),
        raw: ne.allowNull(s),
      }),
      (e.transactionRequest = {
        from: ne.allowNull(t),
        nonce: ne.allowNull(u),
        gasLimit: ne.allowNull(r),
        gasPrice: ne.allowNull(r),
        maxPriorityFeePerGas: ne.allowNull(r),
        maxFeePerGas: ne.allowNull(r),
        to: ne.allowNull(t),
        value: ne.allowNull(r),
        data: ne.allowNull(p),
        type: ne.allowNull(u),
        accessList: ne.allowNull(this.accessList.bind(this), null),
      }),
      (e.receiptLog = {
        transactionIndex: u,
        blockNumber: u,
        transactionHash: a,
        address: t,
        topics: ne.arrayOf(a),
        data: s,
        logIndex: u,
        blockHash: a,
      }),
      (e.receipt = {
        to: ne.allowNull(this.address, null),
        from: ne.allowNull(this.address, null),
        contractAddress: ne.allowNull(t, null),
        transactionIndex: u,
        // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
        root: ne.allowNull(o),
        gasUsed: r,
        logsBloom: ne.allowNull(s),
        blockHash: a,
        transactionHash: a,
        logs: ne.arrayOf(this.receiptLog.bind(this)),
        blockNumber: u,
        confirmations: ne.allowNull(u, null),
        cumulativeGasUsed: r,
        effectiveGasPrice: ne.allowNull(r),
        status: ne.allowNull(u),
        type: l,
      }),
      (e.block = {
        hash: ne.allowNull(a),
        parentHash: a,
        number: u,
        timestamp: u,
        nonce: ne.allowNull(o),
        difficulty: this.difficulty.bind(this),
        gasLimit: r,
        gasUsed: r,
        miner: ne.allowNull(t),
        extraData: s,
        transactions: ne.allowNull(ne.arrayOf(a)),
        baseFeePerGas: ne.allowNull(r),
      }),
      (e.blockWithTransactions = $t(e.block)),
      (e.blockWithTransactions.transactions = ne.allowNull(ne.arrayOf(this.transactionResponse.bind(this)))),
      (e.filter = {
        fromBlock: ne.allowNull(i, void 0),
        toBlock: ne.allowNull(i, void 0),
        blockHash: ne.allowNull(a, void 0),
        address: ne.allowNull(t, void 0),
        topics: ne.allowNull(this.topics.bind(this), void 0),
      }),
      (e.filterLog = {
        blockNumber: ne.allowNull(u),
        blockHash: ne.allowNull(a),
        transactionIndex: u,
        removed: ne.allowNull(this.boolean.bind(this)),
        address: t,
        data: ne.allowFalsish(s, '0x'),
        topics: ne.arrayOf(a),
        transactionHash: a,
        logIndex: u,
      }),
      e
    );
  }
  accessList(e) {
    return Pa(e || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(e) {
    return e === '0x' ? 0 : G.from(e).toNumber();
  }
  type(e) {
    return e === '0x' || e == null ? 0 : G.from(e).toNumber();
  }
  // Strict! Used on input.
  bigNumber(e) {
    return G.from(e);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(e) {
    if (typeof e == 'boolean') return e;
    if (typeof e == 'string') {
      if (((e = e.toLowerCase()), e === 'true')) return !0;
      if (e === 'false') return !1;
    }
    throw new Error('invalid boolean - ' + e);
  }
  hex(e, t) {
    return typeof e == 'string' && (!t && e.substring(0, 2) !== '0x' && (e = '0x' + e), Ae(e)) ? e.toLowerCase() : zo.throwArgumentError('invalid hash', 'value', e);
  }
  data(e, t) {
    const r = this.hex(e, t);
    if (r.length % 2 !== 0) throw new Error('invalid data; odd-length - ' + e);
    return r;
  }
  // Requires an address
  // Strict! Used on input.
  address(e) {
    return Oe(e);
  }
  callAddress(e) {
    if (!Ae(e, 32)) return null;
    const t = Oe(Bt(e, 12));
    return t === rC ? null : t;
  }
  contractAddress(e) {
    return Dy(e);
  }
  // Strict! Used on input.
  blockTag(e) {
    if (e == null) return 'latest';
    if (e === 'earliest') return '0x0';
    switch (e) {
      case 'earliest':
        return '0x0';
      case 'latest':
      case 'pending':
      case 'safe':
      case 'finalized':
        return e;
    }
    if (typeof e == 'number' || Ae(e)) return Od(e);
    throw new Error('invalid blockTag');
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(e, t) {
    const r = this.hex(e, t);
    return Jr(r) !== 32 ? zo.throwArgumentError('invalid hash', 'value', e) : r;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(e) {
    if (e == null) return null;
    const t = G.from(e);
    try {
      return t.toNumber();
    } catch {}
    return null;
  }
  uint256(e) {
    if (!Ae(e)) throw new Error('invalid uint256');
    return Be(e, 32);
  }
  _block(e, t) {
    e.author != null && e.miner == null && (e.miner = e.author);
    const r = e._difficulty != null ? e._difficulty : e.difficulty,
      i = ne.check(t, e);
    return (i._difficulty = r == null ? null : G.from(r)), i;
  }
  block(e) {
    return this._block(e, this.formats.block);
  }
  blockWithTransactions(e) {
    return this._block(e, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(e) {
    return ne.check(this.formats.transactionRequest, e);
  }
  transactionResponse(e) {
    e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas),
      e.to && G.from(e.to).isZero() && (e.to = '0x0000000000000000000000000000000000000000'),
      e.input != null && e.data == null && (e.data = e.input),
      e.to == null && e.creates == null && (e.creates = this.contractAddress(e)),
      (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = []);
    const t = ne.check(this.formats.transaction, e);
    if (e.chainId != null) {
      let r = e.chainId;
      Ae(r) && (r = G.from(r).toNumber()), (t.chainId = r);
    } else {
      let r = e.networkId;
      r == null && t.v == null && (r = e.chainId),
        Ae(r) && (r = G.from(r).toNumber()),
        typeof r != 'number' && t.v != null && ((r = (t.v - 35) / 2), r < 0 && (r = 0), (r = parseInt(r))),
        typeof r != 'number' && (r = 0),
        (t.chainId = r);
    }
    return t.blockHash && t.blockHash.replace(/0/g, '') === 'x' && (t.blockHash = null), t;
  }
  transaction(e) {
    return D6(e);
  }
  receiptLog(e) {
    return ne.check(this.formats.receiptLog, e);
  }
  receipt(e) {
    const t = ne.check(this.formats.receipt, e);
    if (t.root != null)
      if (t.root.length <= 4) {
        const r = G.from(t.root).toNumber();
        r === 0 || r === 1
          ? (t.status != null && t.status !== r && zo.throwArgumentError('alt-root-status/status mismatch', 'value', { root: t.root, status: t.status }), (t.status = r), delete t.root)
          : zo.throwArgumentError('invalid alt-root-status', 'value.root', t.root);
      } else t.root.length !== 66 && zo.throwArgumentError('invalid root hash', 'value.root', t.root);
    return t.status != null && (t.byzantium = !0), t;
  }
  topics(e) {
    return Array.isArray(e) ? e.map((t) => this.topics(t)) : e != null ? this.hash(e, !0) : null;
  }
  filter(e) {
    return ne.check(this.formats.filter, e);
  }
  filterLog(e) {
    return ne.check(this.formats.filterLog, e);
  }
  static check(e, t) {
    const r = {};
    for (const i in e)
      try {
        const s = e[i](t[i]);
        s !== void 0 && (r[i] = s);
      } catch (s) {
        throw ((s.checkKey = i), (s.checkValue = t[i]), s);
      }
    return r;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(e, t) {
    return function (r) {
      return r == null ? t : e(r);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(e, t) {
    return function (r) {
      return r ? e(r) : t;
    };
  }
  // Requires an Array satisfying check
  static arrayOf(e) {
    return function (t) {
      if (!Array.isArray(t)) throw new Error('not an array');
      const r = [];
      return (
        t.forEach(function (i) {
          r.push(e(i));
        }),
        r
      );
    };
  }
}
var ce =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const ye = new O(d0),
  $R = 10;
function w2(n) {
  return n == null ? 'null' : (Jr(n) !== 32 && ye.throwArgumentError('invalid topic', 'topic', n), n.toLowerCase());
}
function T2(n) {
  for (n = n.slice(); n.length > 0 && n[n.length - 1] == null; ) n.pop();
  return n
    .map((e) => {
      if (Array.isArray(e)) {
        const t = {};
        e.forEach((i) => {
          t[w2(i)] = !0;
        });
        const r = Object.keys(t);
        return r.sort(), r.join('|');
      } else return w2(e);
    })
    .join('&');
}
function UR(n) {
  return n === ''
    ? []
    : n.split(/&/g).map((e) => {
        if (e === '') return [];
        const t = e.split('|').map((r) => (r === 'null' ? null : r));
        return t.length === 1 ? t[0] : t;
      });
}
function Na(n) {
  if (typeof n == 'string') {
    if (((n = n.toLowerCase()), Jr(n) === 32)) return 'tx:' + n;
    if (n.indexOf(':') === -1) return n;
  } else {
    if (Array.isArray(n)) return 'filter:*:' + T2(n);
    if (bS.isForkEvent(n)) throw (ye.warn('not implemented'), new Error('not implemented'));
    if (n && typeof n == 'object') return 'filter:' + (n.address || '*') + ':' + T2(n.topics || []);
  }
  throw new Error('invalid event - ' + n);
}
function Go() {
  return /* @__PURE__ */ new Date().getTime();
}
function A2(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
const jR = ['block', 'network', 'pending', 'poll'];
class VR {
  constructor(e, t, r) {
    U(this, 'tag', e), U(this, 'listener', t), U(this, 'once', r), (this._lastBlockNumber = -2), (this._inflight = !1);
  }
  get event() {
    switch (this.type) {
      case 'tx':
        return this.hash;
      case 'filter':
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(':')[0];
  }
  get hash() {
    const e = this.tag.split(':');
    return e[0] !== 'tx' ? null : e[1];
  }
  get filter() {
    const e = this.tag.split(':');
    if (e[0] !== 'filter') return null;
    const t = e[1],
      r = UR(e[2]),
      i = {};
    return r.length > 0 && (i.topics = r), t && t !== '*' && (i.address = t), i;
  }
  pollable() {
    return this.tag.indexOf(':') >= 0 || jR.indexOf(this.tag) >= 0;
  }
}
const zR = {
  0: { symbol: 'btc', p2pkh: 0, p2sh: 5, prefix: 'bc' },
  2: { symbol: 'ltc', p2pkh: 48, p2sh: 50, prefix: 'ltc' },
  3: { symbol: 'doge', p2pkh: 30, p2sh: 22 },
  60: { symbol: 'eth', ilk: 'eth' },
  61: { symbol: 'etc', ilk: 'eth' },
  700: { symbol: 'xdai', ilk: 'eth' },
};
function sf(n) {
  return Be(G.from(n).toHexString(), 32);
}
function E2(n) {
  return fo.encode($e([n, Bt(Pi(Pi(n)), 0, 4)]));
}
const h5 = new RegExp('^(ipfs)://(.*)$', 'i'),
  C2 = [new RegExp('^(https)://(.*)$', 'i'), new RegExp('^(data):(.*)$', 'i'), h5, new RegExp('^eip155:[0-9]+/(erc[0-9]+):(.*)$', 'i')];
function gc(n, e) {
  try {
    return ws(zu(n, e));
  } catch {}
  return null;
}
function zu(n, e) {
  if (n === '0x') return null;
  const t = G.from(Bt(n, e, e + 32)).toNumber(),
    r = G.from(Bt(n, t, t + 32)).toNumber();
  return Bt(n, t + 32, t + 32 + r);
}
function af(n) {
  return (
    n.match(/^ipfs:\/\/ipfs\//i) ? (n = n.substring(12)) : n.match(/^ipfs:\/\//i) ? (n = n.substring(7)) : ye.throwArgumentError('unsupported IPFS format', 'link', n),
    `https://gateway.ipfs.io/ipfs/${n}`
  );
}
function S2(n) {
  const e = H(n);
  if (e.length > 32) throw new Error('internal; should not happen');
  const t = new Uint8Array(32);
  return t.set(e, 32 - e.length), t;
}
function GR(n) {
  if (n.length % 32 === 0) return n;
  const e = new Uint8Array(Math.ceil(n.length / 32) * 32);
  return e.set(n), e;
}
function y5(n) {
  const e = [];
  let t = 0;
  for (let r = 0; r < n.length; r++) e.push(null), (t += 32);
  for (let r = 0; r < n.length; r++) {
    const i = H(n[r]);
    (e[r] = S2(t)), e.push(S2(i.length)), e.push(GR(i)), (t += 32 + Math.ceil(i.length / 32) * 32);
  }
  return xn(e);
}
class M2 {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(e, t, r, i) {
    U(this, 'provider', e), U(this, 'name', r), U(this, 'address', e.formatter.address(t)), U(this, '_resolvedAddress', i);
  }
  supportsWildcard() {
    return (
      this._supportsEip2544 ||
        (this._supportsEip2544 = this.provider
          .call({
            to: this.address,
            data: '0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000',
          })
          .then((e) => G.from(e).eq(1))
          .catch((e) => {
            if (e.code === O.errors.CALL_EXCEPTION) return !1;
            throw ((this._supportsEip2544 = null), e);
          })),
      this._supportsEip2544
    );
  }
  _fetch(e, t) {
    return ce(this, void 0, void 0, function* () {
      const r = {
        to: this.address,
        ccipReadEnabled: !0,
        data: xn([e, pu(this.name), t || '0x']),
      };
      let i = !1;
      (yield this.supportsWildcard()) && ((i = !0), (r.data = xn(['0x9061b923', y5([n6(this.name), r.data])])));
      try {
        let s = yield this.provider.call(r);
        return (
          H(s).length % 32 === 4 &&
            ye.throwError('resolver threw error', O.errors.CALL_EXCEPTION, {
              transaction: r,
              data: s,
            }),
          i && (s = zu(s, 0)),
          s
        );
      } catch (s) {
        if (s.code === O.errors.CALL_EXCEPTION) return null;
        throw s;
      }
    });
  }
  _fetchBytes(e, t) {
    return ce(this, void 0, void 0, function* () {
      const r = yield this._fetch(e, t);
      return r != null ? zu(r, 0) : null;
    });
  }
  _getAddress(e, t) {
    const r = zR[String(e)];
    if (
      (r == null &&
        ye.throwError(`unsupported coin type: ${e}`, O.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${e})`,
        }),
      r.ilk === 'eth')
    )
      return this.provider.formatter.address(t);
    const i = H(t);
    if (r.p2pkh != null) {
      const s = t.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75) return E2($e([[r.p2pkh], '0x' + s[2]]));
      }
    }
    if (r.p2sh != null) {
      const s = t.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75) return E2($e([[r.p2sh], '0x' + s[2]]));
      }
    }
    if (r.prefix != null) {
      const s = i[1];
      let a = i[0];
      if ((a === 0 ? s !== 20 && s !== 32 && (a = -1) : (a = -1), a >= 0 && i.length === 2 + s && s >= 1 && s <= 75)) {
        const o = x2.toWords(i.slice(2));
        return o.unshift(a), x2.encode(r.prefix, o);
      }
    }
    return null;
  }
  getAddress(e) {
    return ce(this, void 0, void 0, function* () {
      if ((e == null && (e = 60), e === 60))
        try {
          const i = yield this._fetch('0x3b3b57de');
          return i === '0x' || i === z1 ? null : this.provider.formatter.callAddress(i);
        } catch (i) {
          if (i.code === O.errors.CALL_EXCEPTION) return null;
          throw i;
        }
      const t = yield this._fetchBytes('0xf1cb7e06', sf(e));
      if (t == null || t === '0x') return null;
      const r = this._getAddress(e, t);
      return (
        r == null &&
          ye.throwError('invalid or unsupported coin data', O.errors.UNSUPPORTED_OPERATION, {
            operation: `getAddress(${e})`,
            coinType: e,
            data: t,
          }),
        r
      );
    });
  }
  getAvatar() {
    return ce(this, void 0, void 0, function* () {
      const e = [{ type: 'name', content: this.name }];
      try {
        const t = yield this.getText('avatar');
        if (t == null) return null;
        for (let r = 0; r < C2.length; r++) {
          const i = t.match(C2[r]);
          if (i == null) continue;
          const s = i[1].toLowerCase();
          switch (s) {
            case 'https':
              return e.push({ type: 'url', content: t }), { linkage: e, url: t };
            case 'data':
              return e.push({ type: 'data', content: t }), { linkage: e, url: t };
            case 'ipfs':
              return e.push({ type: 'ipfs', content: t }), { linkage: e, url: af(t) };
            case 'erc721':
            case 'erc1155': {
              const a = s === 'erc721' ? '0xc87b56dd' : '0x0e89341c';
              e.push({ type: s, content: t });
              const o = this._resolvedAddress || (yield this.getAddress()),
                u = (i[2] || '').split('/');
              if (u.length !== 2) return null;
              const l = yield this.provider.formatter.address(u[0]),
                p = Be(G.from(u[1]).toHexString(), 32);
              if (s === 'erc721') {
                const T = this.provider.formatter.callAddress(
                  yield this.provider.call({
                    to: l,
                    data: xn(['0x6352211e', p]),
                  }),
                );
                if (o !== T) return null;
                e.push({ type: 'owner', content: T });
              } else if (s === 'erc1155') {
                const T = G.from(
                  yield this.provider.call({
                    to: l,
                    data: xn(['0x00fdd58e', Be(o, 32), p]),
                  }),
                );
                if (T.isZero()) return null;
                e.push({ type: 'balance', content: T.toString() });
              }
              const h = {
                to: this.provider.formatter.address(u[0]),
                data: xn([a, p]),
              };
              let b = gc(yield this.provider.call(h), 0);
              if (b == null) return null;
              e.push({ type: 'metadata-url-base', content: b }),
                s === 'erc1155' && ((b = b.replace('{id}', p.substring(2))), e.push({ type: 'metadata-url-expanded', content: b })),
                b.match(/^ipfs:/i) && (b = af(b)),
                e.push({ type: 'metadata-url', content: b });
              const E = yield Gd(b);
              if (!E) return null;
              e.push({ type: 'metadata', content: JSON.stringify(E) });
              let x = E.image;
              if (typeof x != 'string') return null;
              if (!x.match(/^(https:\/\/|data:)/i)) {
                if (x.match(h5) == null) return null;
                e.push({ type: 'url-ipfs', content: x }), (x = af(x));
              }
              return e.push({ type: 'url', content: x }), { linkage: e, url: x };
            }
          }
        }
      } catch {}
      return null;
    });
  }
  getContentHash() {
    return ce(this, void 0, void 0, function* () {
      const e = yield this._fetchBytes('0xbc1c58d1');
      if (e == null || e === '0x') return null;
      const t = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (t) {
        const a = parseInt(t[3], 16);
        if (t[4].length === a * 2) return 'ipfs://' + fo.encode('0x' + t[1]);
      }
      const r = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (r) {
        const a = parseInt(r[3], 16);
        if (r[4].length === a * 2) return 'ipns://' + fo.encode('0x' + r[1]);
      }
      const i = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (i && i[1].length === 32 * 2) return 'bzz://' + i[1];
      const s = e.match(/^0x90b2c605([0-9a-f]*)$/);
      if (s && s[1].length === 34 * 2) {
        const a = { '=': '', '+': '-', '/': '_' };
        return 'sia://' + Vy('0x' + s[1]).replace(/[=+\/]/g, (u) => a[u]);
      }
      return ye.throwError('invalid or unsupported content hash data', O.errors.UNSUPPORTED_OPERATION, {
        operation: 'getContentHash()',
        data: e,
      });
    });
  }
  getText(e) {
    return ce(this, void 0, void 0, function* () {
      let t = Nt(e);
      (t = $e([sf(64), sf(t.length), t])), t.length % 32 !== 0 && (t = $e([t, Be('0x', 32 - (e.length % 32))]));
      const r = yield this._fetchBytes('0x59d1d43c', K(t));
      return r == null || r === '0x' ? null : ws(r);
    });
  }
}
let of = null,
  HR = 1;
class KR extends Gy {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(e) {
    if (
      (super(),
      (this._events = []),
      (this._emitted = { block: -2 }),
      (this.disableCcipRead = !1),
      (this.formatter = new.target.getFormatter()),
      U(this, 'anyNetwork', e === 'any'),
      this.anyNetwork && (e = this.detectNetwork()),
      e instanceof Promise)
    )
      (this._networkPromise = e), e.catch((t) => {}), this._ready().catch((t) => {});
    else {
      const t = Er(new.target, 'getNetwork')(e);
      t ? (U(this, '_network', t), this.emit('network', t, null)) : ye.throwArgumentError('invalid network', 'network', e);
    }
    (this._maxInternalBlockNumber = -1024), (this._lastBlockNumber = -2), (this._maxFilterBlockRange = 10), (this._pollingInterval = 4e3), (this._fastQueryDate = 0);
  }
  _ready() {
    return ce(this, void 0, void 0, function* () {
      if (this._network == null) {
        let e = null;
        if (this._networkPromise)
          try {
            e = yield this._networkPromise;
          } catch {}
        e == null && (e = yield this.detectNetwork()),
          e || ye.throwError('no network detected', O.errors.UNKNOWN_ERROR, {}),
          this._network == null && (this.anyNetwork ? (this._network = e) : U(this, '_network', e), this.emit('network', e, null));
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return Wa(() =>
      this._ready().then(
        (e) => e,
        (e) => {
          if (!(e.code === O.errors.NETWORK_ERROR && e.event === 'noNetwork')) throw e;
        },
      ),
    );
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    return of == null && (of = new ne()), of;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(e) {
    return IR(e ?? 'homestead');
  }
  ccipReadFetch(e, t, r) {
    return ce(this, void 0, void 0, function* () {
      if (this.disableCcipRead || r.length === 0) return null;
      const i = e.to.toLowerCase(),
        s = t.toLowerCase(),
        a = [];
      for (let o = 0; o < r.length; o++) {
        const u = r[o],
          l = u.replace('{sender}', i).replace('{data}', s),
          p = u.indexOf('{data}') >= 0 ? null : JSON.stringify({ data: s, sender: i }),
          h = yield Gd({ url: l, errorPassThrough: !0 }, p, (E, x) => ((E.status = x.statusCode), E));
        if (h.data) return h.data;
        const b = h.message || 'unknown error';
        if (h.status >= 400 && h.status < 500) return ye.throwError(`response not found during CCIP fetch: ${b}`, O.errors.SERVER_ERROR, { url: u, errorMessage: b });
        a.push(b);
      }
      return ye.throwError(`error encountered during CCIP fetch: ${a.map((o) => JSON.stringify(o)).join(', ')}`, O.errors.SERVER_ERROR, {
        urls: r,
        errorMessages: a,
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(e) {
    return ce(this, void 0, void 0, function* () {
      if ((yield this._ready(), e > 0))
        for (; this._internalBlockNumber; ) {
          const i = this._internalBlockNumber;
          try {
            const s = yield i;
            if (Go() - s.respTime <= e) return s.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === i) break;
          }
        }
      const t = Go(),
        r = Mt({
          blockNumber: this.perform('getBlockNumber', {}),
          networkError: this.getNetwork().then(
            (i) => null,
            (i) => i,
          ),
        }).then(({ blockNumber: i, networkError: s }) => {
          if (s) throw (this._internalBlockNumber === r && (this._internalBlockNumber = null), s);
          const a = Go();
          return (
            (i = G.from(i).toNumber()),
            i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber),
            (this._maxInternalBlockNumber = i),
            this._setFastBlockNumber(i),
            { blockNumber: i, reqTime: t, respTime: a }
          );
        });
      return (
        (this._internalBlockNumber = r),
        r.catch((i) => {
          this._internalBlockNumber === r && (this._internalBlockNumber = null);
        }),
        (yield r).blockNumber
      );
    });
  }
  poll() {
    return ce(this, void 0, void 0, function* () {
      const e = HR++,
        t = [];
      let r = null;
      try {
        r = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (i) {
        this.emit('error', i);
        return;
      }
      if ((this._setFastBlockNumber(r), this.emit('poll', e, r), r === this._lastBlockNumber)) {
        this.emit('didPoll', e);
        return;
      }
      if ((this._emitted.block === -2 && (this._emitted.block = r - 1), Math.abs(this._emitted.block - r) > 1e3))
        ye.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${r})`),
          this.emit(
            'error',
            ye.makeError('network block skew detected', O.errors.NETWORK_ERROR, {
              blockNumber: r,
              event: 'blockSkew',
              previousBlockNumber: this._emitted.block,
            }),
          ),
          this.emit('block', r);
      else for (let i = this._emitted.block + 1; i <= r; i++) this.emit('block', i);
      this._emitted.block !== r &&
        ((this._emitted.block = r),
        Object.keys(this._emitted).forEach((i) => {
          if (i === 'block') return;
          const s = this._emitted[i];
          s !== 'pending' && r - s > 12 && delete this._emitted[i];
        })),
        this._lastBlockNumber === -2 && (this._lastBlockNumber = r - 1),
        this._events.forEach((i) => {
          switch (i.type) {
            case 'tx': {
              const s = i.hash;
              let a = this.getTransactionReceipt(s)
                .then((o) => (!o || o.blockNumber == null || ((this._emitted['t:' + s] = o.blockNumber), this.emit(s, o)), null))
                .catch((o) => {
                  this.emit('error', o);
                });
              t.push(a);
              break;
            }
            case 'filter': {
              if (!i._inflight) {
                (i._inflight = !0), i._lastBlockNumber === -2 && (i._lastBlockNumber = r - 1);
                const s = i.filter;
                (s.fromBlock = i._lastBlockNumber + 1), (s.toBlock = r);
                const a = s.toBlock - this._maxFilterBlockRange;
                a > s.fromBlock && (s.fromBlock = a), s.fromBlock < 0 && (s.fromBlock = 0);
                const o = this.getLogs(s)
                  .then((u) => {
                    (i._inflight = !1),
                      u.length !== 0 &&
                        u.forEach((l) => {
                          l.blockNumber > i._lastBlockNumber && (i._lastBlockNumber = l.blockNumber),
                            (this._emitted['b:' + l.blockHash] = l.blockNumber),
                            (this._emitted['t:' + l.transactionHash] = l.blockNumber),
                            this.emit(s, l);
                        });
                  })
                  .catch((u) => {
                    this.emit('error', u), (i._inflight = !1);
                  });
                t.push(o);
              }
              break;
            }
          }
        }),
        (this._lastBlockNumber = r),
        Promise.all(t)
          .then(() => {
            this.emit('didPoll', e);
          })
          .catch((i) => {
            this.emit('error', i);
          });
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(e) {
    (this._lastBlockNumber = e - 1), this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return ce(this, void 0, void 0, function* () {
      return ye.throwError('provider does not support network detection', O.errors.UNSUPPORTED_OPERATION, {
        operation: 'provider.detectNetwork',
      });
    });
  }
  getNetwork() {
    return ce(this, void 0, void 0, function* () {
      const e = yield this._ready(),
        t = yield this.detectNetwork();
      if (e.chainId !== t.chainId) {
        if (this.anyNetwork)
          return (
            (this._network = t),
            (this._lastBlockNumber = -2),
            (this._fastBlockNumber = null),
            (this._fastBlockNumberPromise = null),
            (this._fastQueryDate = 0),
            (this._emitted.block = -2),
            (this._maxInternalBlockNumber = -1024),
            (this._internalBlockNumber = null),
            this.emit('network', t, e),
            yield A2(0),
            this._network
          );
        const r = ye.makeError('underlying network changed', O.errors.NETWORK_ERROR, {
          event: 'changed',
          network: e,
          detectedNetwork: t,
        });
        throw (this.emit('error', r), r);
      }
      return e;
    });
  }
  get blockNumber() {
    return (
      this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(
        (e) => {
          this._setFastBlockNumber(e);
        },
        (e) => {},
      ),
      this._fastBlockNumber != null ? this._fastBlockNumber : -1
    );
  }
  get polling() {
    return this._poller != null;
  }
  set polling(e) {
    e && !this._poller
      ? ((this._poller = setInterval(() => {
          this.poll();
        }, this.pollingInterval)),
        this._bootstrapPoll ||
          (this._bootstrapPoll = setTimeout(() => {
            this.poll(),
              (this._bootstrapPoll = setTimeout(() => {
                this._poller || this.poll(), (this._bootstrapPoll = null);
              }, this.pollingInterval));
          }, 0)))
      : !e && this._poller && (clearInterval(this._poller), (this._poller = null));
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(e) {
    if (typeof e != 'number' || e <= 0 || parseInt(String(e)) != e) throw new Error('invalid polling interval');
    (this._pollingInterval = e),
      this._poller &&
        (clearInterval(this._poller),
        (this._poller = setInterval(() => {
          this.poll();
        }, this._pollingInterval)));
  }
  _getFastBlockNumber() {
    const e = Go();
    return (
      e - this._fastQueryDate > 2 * this._pollingInterval &&
        ((this._fastQueryDate = e),
        (this._fastBlockNumberPromise = this.getBlockNumber().then((t) => ((this._fastBlockNumber == null || t > this._fastBlockNumber) && (this._fastBlockNumber = t), this._fastBlockNumber)))),
      this._fastBlockNumberPromise
    );
  }
  _setFastBlockNumber(e) {
    (this._fastBlockNumber != null && e < this._fastBlockNumber) ||
      ((this._fastQueryDate = Go()), (this._fastBlockNumber == null || e > this._fastBlockNumber) && ((this._fastBlockNumber = e), (this._fastBlockNumberPromise = Promise.resolve(e))));
  }
  waitForTransaction(e, t, r) {
    return ce(this, void 0, void 0, function* () {
      return this._waitForTransaction(e, t ?? 1, r || 0, null);
    });
  }
  _waitForTransaction(e, t, r, i) {
    return ce(this, void 0, void 0, function* () {
      const s = yield this.getTransactionReceipt(e);
      return (s ? s.confirmations : 0) >= t
        ? s
        : new Promise((a, o) => {
            const u = [];
            let l = !1;
            const p = function () {
                return l
                  ? !0
                  : ((l = !0),
                    u.forEach((b) => {
                      b();
                    }),
                    !1);
              },
              h = (b) => {
                b.confirmations < t || p() || a(b);
              };
            if (
              (this.on(e, h),
              u.push(() => {
                this.removeListener(e, h);
              }),
              i)
            ) {
              let b = i.startBlock,
                E = null;
              const x = (T) =>
                ce(this, void 0, void 0, function* () {
                  l ||
                    (yield A2(1e3),
                    this.getTransactionCount(i.from).then(
                      (w) =>
                        ce(this, void 0, void 0, function* () {
                          if (!l) {
                            if (w <= i.nonce) b = T;
                            else {
                              {
                                const _ = yield this.getTransaction(e);
                                if (_ && _.blockNumber != null) return;
                              }
                              for (E == null && ((E = b - 3), E < i.startBlock && (E = i.startBlock)); E <= T; ) {
                                if (l) return;
                                const _ = yield this.getBlockWithTransactions(E);
                                for (let k = 0; k < _.transactions.length; k++) {
                                  const D = _.transactions[k];
                                  if (D.hash === e) return;
                                  if (D.from === i.from && D.nonce === i.nonce) {
                                    if (l) return;
                                    const N = yield this.waitForTransaction(D.hash, t);
                                    if (p()) return;
                                    let B = 'replaced';
                                    D.data === i.data && D.to === i.to && D.value.eq(i.value) ? (B = 'repriced') : D.data === '0x' && D.from === D.to && D.value.isZero() && (B = 'cancelled'),
                                      o(
                                        ye.makeError('transaction was replaced', O.errors.TRANSACTION_REPLACED, {
                                          cancelled: B === 'replaced' || B === 'cancelled',
                                          reason: B,
                                          replacement: this._wrapTransaction(D),
                                          hash: e,
                                          receipt: N,
                                        }),
                                      );
                                    return;
                                  }
                                }
                                E++;
                              }
                            }
                            l || this.once('block', x);
                          }
                        }),
                      (w) => {
                        l || this.once('block', x);
                      },
                    ));
                });
              if (l) return;
              this.once('block', x),
                u.push(() => {
                  this.removeListener('block', x);
                });
            }
            if (typeof r == 'number' && r > 0) {
              const b = setTimeout(() => {
                p() || o(ye.makeError('timeout exceeded', O.errors.TIMEOUT, { timeout: r }));
              }, r);
              b.unref && b.unref(),
                u.push(() => {
                  clearTimeout(b);
                });
            }
          });
    });
  }
  getBlockNumber() {
    return ce(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const e = yield this.perform('getGasPrice', {});
      try {
        return G.from(e);
      } catch (t) {
        return ye.throwError('bad result from backend', O.errors.SERVER_ERROR, {
          method: 'getGasPrice',
          result: e,
          error: t,
        });
      }
    });
  }
  getBalance(e, t) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Mt({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(t),
        }),
        i = yield this.perform('getBalance', r);
      try {
        return G.from(i);
      } catch (s) {
        return ye.throwError('bad result from backend', O.errors.SERVER_ERROR, {
          method: 'getBalance',
          params: r,
          result: i,
          error: s,
        });
      }
    });
  }
  getTransactionCount(e, t) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Mt({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(t),
        }),
        i = yield this.perform('getTransactionCount', r);
      try {
        return G.from(i).toNumber();
      } catch (s) {
        return ye.throwError('bad result from backend', O.errors.SERVER_ERROR, {
          method: 'getTransactionCount',
          params: r,
          result: i,
          error: s,
        });
      }
    });
  }
  getCode(e, t) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Mt({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(t),
        }),
        i = yield this.perform('getCode', r);
      try {
        return K(i);
      } catch (s) {
        return ye.throwError('bad result from backend', O.errors.SERVER_ERROR, {
          method: 'getCode',
          params: r,
          result: i,
          error: s,
        });
      }
    });
  }
  getStorageAt(e, t, r) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield Mt({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(r),
          position: Promise.resolve(t).then((a) => Od(a)),
        }),
        s = yield this.perform('getStorageAt', i);
      try {
        return K(s);
      } catch (a) {
        return ye.throwError('bad result from backend', O.errors.SERVER_ERROR, {
          method: 'getStorageAt',
          params: i,
          result: s,
          error: a,
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(e, t, r) {
    if (t != null && Jr(t) !== 32) throw new Error('invalid response - sendTransaction');
    const i = e;
    return (
      t != null && e.hash !== t && ye.throwError('Transaction hash mismatch from Provider.sendTransaction.', O.errors.UNKNOWN_ERROR, { expectedHash: e.hash, returnedHash: t }),
      (i.wait = (s, a) =>
        ce(this, void 0, void 0, function* () {
          s == null && (s = 1), a == null && (a = 0);
          let o;
          s !== 0 &&
            r != null &&
            (o = {
              data: e.data,
              from: e.from,
              nonce: e.nonce,
              to: e.to,
              value: e.value,
              startBlock: r,
            });
          const u = yield this._waitForTransaction(e.hash, s, a, o);
          return u == null && s === 0
            ? null
            : ((this._emitted['t:' + e.hash] = u.blockNumber),
              u.status === 0 &&
                ye.throwError('transaction failed', O.errors.CALL_EXCEPTION, {
                  transactionHash: e.hash,
                  transaction: e,
                  receipt: u,
                }),
              u);
        })),
      i
    );
  }
  sendTransaction(e) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Promise.resolve(e).then((s) => K(s)),
        r = this.formatter.transaction(e);
      r.confirmations == null && (r.confirmations = 0);
      const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const s = yield this.perform('sendTransaction', { signedTransaction: t });
        return this._wrapTransaction(r, s, i);
      } catch (s) {
        throw ((s.transaction = r), (s.transactionHash = r.hash), s);
      }
    });
  }
  _getTransactionRequest(e) {
    return ce(this, void 0, void 0, function* () {
      const t = yield e,
        r = {};
      return (
        ['from', 'to'].forEach((i) => {
          t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => (s ? this._getAddress(s) : null)));
        }),
        ['gasLimit', 'gasPrice', 'maxFeePerGas', 'maxPriorityFeePerGas', 'value'].forEach((i) => {
          t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => (s ? G.from(s) : null)));
        }),
        ['type'].forEach((i) => {
          t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => s ?? null));
        }),
        t.accessList && (r.accessList = this.formatter.accessList(t.accessList)),
        ['data'].forEach((i) => {
          t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => (s ? K(s) : null)));
        }),
        this.formatter.transactionRequest(yield Mt(r))
      );
    });
  }
  _getFilter(e) {
    return ce(this, void 0, void 0, function* () {
      e = yield e;
      const t = {};
      return (
        e.address != null && (t.address = this._getAddress(e.address)),
        ['blockHash', 'topics'].forEach((r) => {
          e[r] != null && (t[r] = e[r]);
        }),
        ['fromBlock', 'toBlock'].forEach((r) => {
          e[r] != null && (t[r] = this._getBlockTag(e[r]));
        }),
        this.formatter.filter(yield Mt(t))
      );
    });
  }
  _call(e, t, r) {
    return ce(this, void 0, void 0, function* () {
      r >= $R &&
        ye.throwError('CCIP read exceeded maximum redirections', O.errors.SERVER_ERROR, {
          redirects: r,
          transaction: e,
        });
      const i = e.to,
        s = yield this.perform('call', { transaction: e, blockTag: t });
      if (r >= 0 && t === 'latest' && i != null && s.substring(0, 10) === '0x556f1830' && Jr(s) % 32 === 4)
        try {
          const a = Bt(s, 4),
            o = Bt(a, 0, 32);
          G.from(o).eq(i) ||
            ye.throwError('CCIP Read sender did not match', O.errors.CALL_EXCEPTION, {
              name: 'OffchainLookup',
              signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
              transaction: e,
              data: s,
            });
          const u = [],
            l = G.from(Bt(a, 32, 64)).toNumber(),
            p = G.from(Bt(a, l, l + 32)).toNumber(),
            h = Bt(a, l + 32);
          for (let _ = 0; _ < p; _++) {
            const k = gc(h, _ * 32);
            k == null &&
              ye.throwError('CCIP Read contained corrupt URL string', O.errors.CALL_EXCEPTION, {
                name: 'OffchainLookup',
                signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
                transaction: e,
                data: s,
              }),
              u.push(k);
          }
          const b = zu(a, 64);
          G.from(Bt(a, 100, 128)).isZero() ||
            ye.throwError('CCIP Read callback selector included junk', O.errors.CALL_EXCEPTION, {
              name: 'OffchainLookup',
              signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
              transaction: e,
              data: s,
            });
          const E = Bt(a, 96, 100),
            x = zu(a, 128),
            T = yield this.ccipReadFetch(e, b, u);
          T == null &&
            ye.throwError('CCIP Read disabled or provided no URLs', O.errors.CALL_EXCEPTION, {
              name: 'OffchainLookup',
              signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
              transaction: e,
              data: s,
            });
          const w = {
            to: i,
            data: xn([E, y5([T, x])]),
          };
          return this._call(w, t, r + 1);
        } catch (a) {
          if (a.code === O.errors.SERVER_ERROR) throw a;
        }
      try {
        return K(s);
      } catch (a) {
        return ye.throwError('bad result from backend', O.errors.SERVER_ERROR, {
          method: 'call',
          params: { transaction: e, blockTag: t },
          result: s,
          error: a,
        });
      }
    });
  }
  call(e, t) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Mt({
        transaction: this._getTransactionRequest(e),
        blockTag: this._getBlockTag(t),
        ccipReadEnabled: Promise.resolve(e.ccipReadEnabled),
      });
      return this._call(r.transaction, r.blockTag, r.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(e) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Mt({
          transaction: this._getTransactionRequest(e),
        }),
        r = yield this.perform('estimateGas', t);
      try {
        return G.from(r);
      } catch (i) {
        return ye.throwError('bad result from backend', O.errors.SERVER_ERROR, {
          method: 'estimateGas',
          params: t,
          result: r,
          error: i,
        });
      }
    });
  }
  _getAddress(e) {
    return ce(this, void 0, void 0, function* () {
      (e = yield e), typeof e != 'string' && ye.throwArgumentError('invalid address or ENS name', 'name', e);
      const t = yield this.resolveName(e);
      return (
        t == null &&
          ye.throwError('ENS name not configured', O.errors.UNSUPPORTED_OPERATION, {
            operation: `resolveName(${JSON.stringify(e)})`,
          }),
        t
      );
    });
  }
  _getBlock(e, t) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      let r = -128;
      const i = {
        includeTransactions: !!t,
      };
      if (Ae(e, 32)) i.blockHash = e;
      else
        try {
          (i.blockTag = yield this._getBlockTag(e)), Ae(i.blockTag) && (r = parseInt(i.blockTag.substring(2), 16));
        } catch {
          ye.throwArgumentError('invalid block hash or block tag', 'blockHashOrBlockTag', e);
        }
      return Wa(
        () =>
          ce(this, void 0, void 0, function* () {
            const s = yield this.perform('getBlock', i);
            if (s == null) return (i.blockHash != null && this._emitted['b:' + i.blockHash] == null) || (i.blockTag != null && r > this._emitted.block) ? null : void 0;
            if (t) {
              let a = null;
              for (let u = 0; u < s.transactions.length; u++) {
                const l = s.transactions[u];
                if (l.blockNumber == null) l.confirmations = 0;
                else if (l.confirmations == null) {
                  a == null && (a = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
                  let p = a - l.blockNumber + 1;
                  p <= 0 && (p = 1), (l.confirmations = p);
                }
              }
              const o = this.formatter.blockWithTransactions(s);
              return (o.transactions = o.transactions.map((u) => this._wrapTransaction(u))), o;
            }
            return this.formatter.block(s);
          }),
        { oncePoll: this },
      );
    });
  }
  getBlock(e) {
    return this._getBlock(e, !1);
  }
  getBlockWithTransactions(e) {
    return this._getBlock(e, !0);
  }
  getTransaction(e) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return Wa(
        () =>
          ce(this, void 0, void 0, function* () {
            const r = yield this.perform('getTransaction', t);
            if (r == null) return this._emitted['t:' + e] == null ? null : void 0;
            const i = this.formatter.transactionResponse(r);
            if (i.blockNumber == null) i.confirmations = 0;
            else if (i.confirmations == null) {
              let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
              a <= 0 && (a = 1), (i.confirmations = a);
            }
            return this._wrapTransaction(i);
          }),
        { oncePoll: this },
      );
    });
  }
  getTransactionReceipt(e) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return Wa(
        () =>
          ce(this, void 0, void 0, function* () {
            const r = yield this.perform('getTransactionReceipt', t);
            if (r == null) return this._emitted['t:' + e] == null ? null : void 0;
            if (r.blockHash == null) return;
            const i = this.formatter.receipt(r);
            if (i.blockNumber == null) i.confirmations = 0;
            else if (i.confirmations == null) {
              let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
              a <= 0 && (a = 1), (i.confirmations = a);
            }
            return i;
          }),
        { oncePoll: this },
      );
    });
  }
  getLogs(e) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Mt({ filter: this._getFilter(e) }),
        r = yield this.perform('getLogs', t);
      return (
        r.forEach((i) => {
          i.removed == null && (i.removed = !1);
        }),
        ne.arrayOf(this.formatter.filterLog.bind(this.formatter))(r)
      );
    });
  }
  getEtherPrice() {
    return ce(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform('getEtherPrice', {});
    });
  }
  _getBlockTag(e) {
    return ce(this, void 0, void 0, function* () {
      if (((e = yield e), typeof e == 'number' && e < 0)) {
        e % 1 && ye.throwArgumentError('invalid BlockTag', 'blockTag', e);
        let t = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        return (t += e), t < 0 && (t = 0), this.formatter.blockTag(t);
      }
      return this.formatter.blockTag(e);
    });
  }
  getResolver(e) {
    return ce(this, void 0, void 0, function* () {
      let t = e;
      for (;;) {
        if (t === '' || t === '.' || (e !== 'eth' && t === 'eth')) return null;
        const r = yield this._getResolver(t, 'getResolver');
        if (r != null) {
          const i = new M2(this, r, e);
          return t !== e && !(yield i.supportsWildcard()) ? null : i;
        }
        t = t.split('.').slice(1).join('.');
      }
    });
  }
  _getResolver(e, t) {
    return ce(this, void 0, void 0, function* () {
      t == null && (t = 'ENS');
      const r = yield this.getNetwork();
      r.ensAddress || ye.throwError('network does not support ENS', O.errors.UNSUPPORTED_OPERATION, { operation: t, network: r.name });
      try {
        const i = yield this.call({
          to: r.ensAddress,
          data: '0x0178b8bf' + pu(e).substring(2),
        });
        return this.formatter.callAddress(i);
      } catch {}
      return null;
    });
  }
  resolveName(e) {
    return ce(this, void 0, void 0, function* () {
      e = yield e;
      try {
        return Promise.resolve(this.formatter.address(e));
      } catch (r) {
        if (Ae(e)) throw r;
      }
      typeof e != 'string' && ye.throwArgumentError('invalid ENS name', 'name', e);
      const t = yield this.getResolver(e);
      return t ? yield t.getAddress() : null;
    });
  }
  lookupAddress(e) {
    return ce(this, void 0, void 0, function* () {
      (e = yield e), (e = this.formatter.address(e));
      const t = e.substring(2).toLowerCase() + '.addr.reverse',
        r = yield this._getResolver(t, 'lookupAddress');
      if (r == null) return null;
      const i = gc(
        yield this.call({
          to: r,
          data: '0x691f3431' + pu(t).substring(2),
        }),
        0,
      );
      return (yield this.resolveName(i)) != e ? null : i;
    });
  }
  getAvatar(e) {
    return ce(this, void 0, void 0, function* () {
      let t = null;
      if (Ae(e)) {
        const s = this.formatter.address(e).substring(2).toLowerCase() + '.addr.reverse',
          a = yield this._getResolver(s, 'getAvatar');
        if (!a) return null;
        t = new M2(this, a, s);
        try {
          const o = yield t.getAvatar();
          if (o) return o.url;
        } catch (o) {
          if (o.code !== O.errors.CALL_EXCEPTION) throw o;
        }
        try {
          const o = gc(
            yield this.call({
              to: a,
              data: '0x691f3431' + pu(s).substring(2),
            }),
            0,
          );
          t = yield this.getResolver(o);
        } catch (o) {
          if (o.code !== O.errors.CALL_EXCEPTION) throw o;
          return null;
        }
      } else if (((t = yield this.getResolver(e)), !t)) return null;
      const r = yield t.getAvatar();
      return r == null ? null : r.url;
    });
  }
  perform(e, t) {
    return ye.throwError(e + ' not implemented', O.errors.NOT_IMPLEMENTED, { operation: e });
  }
  _startEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _stopEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _addEventListener(e, t, r) {
    const i = new VR(Na(e), t, r);
    return this._events.push(i), this._startEvent(i), this;
  }
  on(e, t) {
    return this._addEventListener(e, t, !1);
  }
  once(e, t) {
    return this._addEventListener(e, t, !0);
  }
  emit(e, ...t) {
    let r = !1,
      i = [],
      s = Na(e);
    return (
      (this._events = this._events.filter((a) =>
        a.tag !== s
          ? !0
          : (setTimeout(() => {
              a.listener.apply(this, t);
            }, 0),
            (r = !0),
            a.once ? (i.push(a), !1) : !0),
      )),
      i.forEach((a) => {
        this._stopEvent(a);
      }),
      r
    );
  }
  listenerCount(e) {
    if (!e) return this._events.length;
    let t = Na(e);
    return this._events.filter((r) => r.tag === t).length;
  }
  listeners(e) {
    if (e == null) return this._events.map((r) => r.listener);
    let t = Na(e);
    return this._events.filter((r) => r.tag === t).map((r) => r.listener);
  }
  off(e, t) {
    if (t == null) return this.removeAllListeners(e);
    const r = [];
    let i = !1,
      s = Na(e);
    return (
      (this._events = this._events.filter((a) => (a.tag !== s || a.listener != t || i ? !0 : ((i = !0), r.push(a), !1)))),
      r.forEach((a) => {
        this._stopEvent(a);
      }),
      this
    );
  }
  removeAllListeners(e) {
    let t = [];
    if (e == null) (t = this._events), (this._events = []);
    else {
      const r = Na(e);
      this._events = this._events.filter((i) => (i.tag !== r ? !0 : (t.push(i), !1)));
    }
    return (
      t.forEach((r) => {
        this._stopEvent(r);
      }),
      this
    );
  }
}
var li =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, r) {
    function i(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(p) {
        try {
          l(r.next(p));
        } catch (h) {
          a(h);
        }
      }
      function u(p) {
        try {
          l(r.throw(p));
        } catch (h) {
          a(h);
        }
      }
      function l(p) {
        p.done ? s(p.value) : i(p.value).then(o, u);
      }
      l((r = r.apply(n, e || [])).next());
    });
  };
const Lt = new O(d0),
  qR = ['call', 'estimateGas'];
function yu(n, e) {
  if (n == null) return null;
  if (typeof n.message == 'string' && n.message.match('reverted')) {
    const t = Ae(n.data) ? n.data : null;
    if (!e || t) return { message: n.message, data: t };
  }
  if (typeof n == 'object') {
    for (const t in n) {
      const r = yu(n[t], e);
      if (r) return r;
    }
    return null;
  }
  if (typeof n == 'string')
    try {
      return yu(JSON.parse(n), e);
    } catch {}
  return null;
}
function m5(n, e, t) {
  const r = t.transaction || t.signedTransaction;
  if (n === 'call') {
    const s = yu(e, !0);
    if (s) return s.data;
    Lt.throwError('missing revert data in call exception; Transaction reverted without a reason string', O.errors.CALL_EXCEPTION, {
      data: '0x',
      transaction: r,
      error: e,
    });
  }
  if (n === 'estimateGas') {
    let s = yu(e.body, !1);
    s == null && (s = yu(e, !1)),
      s &&
        Lt.throwError('cannot estimate gas; transaction may fail or may require manual gas limit', O.errors.UNPREDICTABLE_GAS_LIMIT, {
          reason: s.message,
          method: n,
          transaction: r,
          error: e,
        });
  }
  let i = e.message;
  throw (
    (e.code === O.errors.SERVER_ERROR && e.error && typeof e.error.message == 'string'
      ? (i = e.error.message)
      : typeof e.body == 'string'
      ? (i = e.body)
      : typeof e.responseText == 'string' && (i = e.responseText),
    (i = (i || '').toLowerCase()),
    i.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) &&
      Lt.throwError('insufficient funds for intrinsic transaction cost', O.errors.INSUFFICIENT_FUNDS, {
        error: e,
        method: n,
        transaction: r,
      }),
    i.match(/nonce (is )?too low/i) &&
      Lt.throwError('nonce has already been used', O.errors.NONCE_EXPIRED, {
        error: e,
        method: n,
        transaction: r,
      }),
    i.match(/replacement transaction underpriced|transaction gas price.*too low/i) &&
      Lt.throwError('replacement fee too low', O.errors.REPLACEMENT_UNDERPRICED, {
        error: e,
        method: n,
        transaction: r,
      }),
    i.match(/only replay-protected/i) &&
      Lt.throwError('legacy pre-eip-155 transactions not supported', O.errors.UNSUPPORTED_OPERATION, {
        error: e,
        method: n,
        transaction: r,
      }),
    qR.indexOf(n) >= 0 &&
      i.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) &&
      Lt.throwError('cannot estimate gas; transaction may fail or may require manual gas limit', O.errors.UNPREDICTABLE_GAS_LIMIT, {
        error: e,
        method: n,
        transaction: r,
      }),
    e)
  );
}
function _2(n) {
  return new Promise(function (e) {
    setTimeout(e, n);
  });
}
function WR(n) {
  if (n.error) {
    const e = new Error(n.error.message);
    throw ((e.code = n.error.code), (e.data = n.error.data), e);
  }
  return n.result;
}
function Ho(n) {
  return n && n.toLowerCase();
}
const ph = {};
class b5 extends _a {
  constructor(e, t, r) {
    if ((super(), e !== ph)) throw new Error('do not call the JsonRpcSigner constructor directly; use provider.getSigner');
    U(this, 'provider', t),
      r == null && (r = 0),
      typeof r == 'string'
        ? (U(this, '_address', this.provider.formatter.address(r)), U(this, '_index', null))
        : typeof r == 'number'
        ? (U(this, '_index', r), U(this, '_address', null))
        : Lt.throwArgumentError('invalid address or index', 'addressOrIndex', r);
  }
  connect(e) {
    return Lt.throwError('cannot alter JSON-RPC Signer connection', O.errors.UNSUPPORTED_OPERATION, {
      operation: 'connect',
    });
  }
  connectUnchecked() {
    return new JR(ph, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address
      ? Promise.resolve(this._address)
      : this.provider.send('eth_accounts', []).then(
          (e) => (
            e.length <= this._index &&
              Lt.throwError('unknown account #' + this._index, O.errors.UNSUPPORTED_OPERATION, {
                operation: 'getAddress',
              }),
            this.provider.formatter.address(e[this._index])
          ),
        );
  }
  sendUncheckedTransaction(e) {
    e = $t(e);
    const t = this.getAddress().then((r) => (r && (r = r.toLowerCase()), r));
    if (e.gasLimit == null) {
      const r = $t(e);
      (r.from = t), (e.gasLimit = this.provider.estimateGas(r));
    }
    return (
      e.to != null &&
        (e.to = Promise.resolve(e.to).then((r) =>
          li(this, void 0, void 0, function* () {
            if (r == null) return null;
            const i = yield this.provider.resolveName(r);
            return i == null && Lt.throwArgumentError('provided ENS name resolves to null', 'tx.to', r), i;
          }),
        )),
      Mt({
        tx: Mt(e),
        sender: t,
      }).then(({ tx: r, sender: i }) => {
        r.from != null ? r.from.toLowerCase() !== i && Lt.throwArgumentError('from address mismatch', 'transaction', e) : (r.from = i);
        const s = this.provider.constructor.hexlifyTransaction(r, { from: !0 });
        return this.provider.send('eth_sendTransaction', [s]).then(
          (a) => a,
          (a) => (
            typeof a.message == 'string' &&
              a.message.match(/user denied/i) &&
              Lt.throwError('user rejected transaction', O.errors.ACTION_REJECTED, {
                action: 'sendTransaction',
                transaction: r,
              }),
            m5('sendTransaction', a, s)
          ),
        );
      })
    );
  }
  signTransaction(e) {
    return Lt.throwError('signing transactions is unsupported', O.errors.UNSUPPORTED_OPERATION, {
      operation: 'signTransaction',
    });
  }
  sendTransaction(e) {
    return li(this, void 0, void 0, function* () {
      const t = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval),
        r = yield this.sendUncheckedTransaction(e);
      try {
        return yield Wa(
          () =>
            li(this, void 0, void 0, function* () {
              const i = yield this.provider.getTransaction(r);
              if (i !== null) return this.provider._wrapTransaction(i, r, t);
            }),
          { oncePoll: this.provider },
        );
      } catch (i) {
        throw ((i.transactionHash = r), i);
      }
    });
  }
  signMessage(e) {
    return li(this, void 0, void 0, function* () {
      const t = typeof e == 'string' ? Nt(e) : e,
        r = yield this.getAddress();
      try {
        return yield this.provider.send('personal_sign', [K(t), r.toLowerCase()]);
      } catch (i) {
        throw (
          (typeof i.message == 'string' &&
            i.message.match(/user denied/i) &&
            Lt.throwError('user rejected signing', O.errors.ACTION_REJECTED, {
              action: 'signMessage',
              from: r,
              messageData: e,
            }),
          i)
        );
      }
    });
  }
  _legacySignMessage(e) {
    return li(this, void 0, void 0, function* () {
      const t = typeof e == 'string' ? Nt(e) : e,
        r = yield this.getAddress();
      try {
        return yield this.provider.send('eth_sign', [r.toLowerCase(), K(t)]);
      } catch (i) {
        throw (
          (typeof i.message == 'string' &&
            i.message.match(/user denied/i) &&
            Lt.throwError('user rejected signing', O.errors.ACTION_REJECTED, {
              action: '_legacySignMessage',
              from: r,
              messageData: e,
            }),
          i)
        );
      }
    });
  }
  _signTypedData(e, t, r) {
    return li(this, void 0, void 0, function* () {
      const i = yield Zt.resolveNames(e, t, r, (a) => this.provider.resolveName(a)),
        s = yield this.getAddress();
      try {
        return yield this.provider.send('eth_signTypedData_v4', [s.toLowerCase(), JSON.stringify(Zt.getPayload(i.domain, t, i.value))]);
      } catch (a) {
        throw (
          (typeof a.message == 'string' &&
            a.message.match(/user denied/i) &&
            Lt.throwError('user rejected signing', O.errors.ACTION_REJECTED, {
              action: '_signTypedData',
              from: s,
              messageData: { domain: i.domain, types: t, value: i.value },
            }),
          a)
        );
      }
    });
  }
  unlock(e) {
    return li(this, void 0, void 0, function* () {
      const t = this.provider,
        r = yield this.getAddress();
      return t.send('personal_unlockAccount', [r.toLowerCase(), e, null]);
    });
  }
}
class JR extends b5 {
  sendTransaction(e) {
    return this.sendUncheckedTransaction(e).then((t) => ({
      hash: t,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (r) => this.provider.waitForTransaction(t, r),
    }));
  }
}
const QR = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0,
};
class YR extends KR {
  constructor(e, t) {
    let r = t;
    r == null &&
      (r = new Promise((i, s) => {
        setTimeout(() => {
          this.detectNetwork().then(
            (a) => {
              i(a);
            },
            (a) => {
              s(a);
            },
          );
        }, 0);
      })),
      super(r),
      e || (e = Er(this.constructor, 'defaultUrl')()),
      typeof e == 'string'
        ? U(
            this,
            'connection',
            Object.freeze({
              url: e,
            }),
          )
        : U(this, 'connection', Object.freeze($t(e))),
      (this._nextId = 42);
  }
  get _cache() {
    return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache;
  }
  static defaultUrl() {
    return 'http://localhost:8545';
  }
  detectNetwork() {
    return (
      this._cache.detectNetwork ||
        ((this._cache.detectNetwork = this._uncachedDetectNetwork()),
        setTimeout(() => {
          this._cache.detectNetwork = null;
        }, 0)),
      this._cache.detectNetwork
    );
  }
  _uncachedDetectNetwork() {
    return li(this, void 0, void 0, function* () {
      yield _2(0);
      let e = null;
      try {
        e = yield this.send('eth_chainId', []);
      } catch {
        try {
          e = yield this.send('net_version', []);
        } catch {}
      }
      if (e != null) {
        const t = Er(this.constructor, 'getNetwork');
        try {
          return t(G.from(e).toNumber());
        } catch (r) {
          return Lt.throwError('could not detect network', O.errors.NETWORK_ERROR, {
            chainId: e,
            event: 'invalidNetwork',
            serverError: r,
          });
        }
      }
      return Lt.throwError('could not detect network', O.errors.NETWORK_ERROR, {
        event: 'noNetwork',
      });
    });
  }
  getSigner(e) {
    return new b5(ph, this, e);
  }
  getUncheckedSigner(e) {
    return this.getSigner(e).connectUnchecked();
  }
  listAccounts() {
    return this.send('eth_accounts', []).then((e) => e.map((t) => this.formatter.address(t)));
  }
  send(e, t) {
    const r = {
      method: e,
      params: t,
      id: this._nextId++,
      jsonrpc: '2.0',
    };
    this.emit('debug', {
      action: 'request',
      request: hs(r),
      provider: this,
    });
    const i = ['eth_chainId', 'eth_blockNumber'].indexOf(e) >= 0;
    if (i && this._cache[e]) return this._cache[e];
    const s = Gd(this.connection, JSON.stringify(r), WR).then(
      (a) => (
        this.emit('debug', {
          action: 'response',
          request: r,
          response: a,
          provider: this,
        }),
        a
      ),
      (a) => {
        throw (
          (this.emit('debug', {
            action: 'response',
            error: a,
            request: r,
            provider: this,
          }),
          a)
        );
      },
    );
    return (
      i &&
        ((this._cache[e] = s),
        setTimeout(() => {
          this._cache[e] = null;
        }, 0)),
      s
    );
  }
  prepareRequest(e, t) {
    switch (e) {
      case 'getBlockNumber':
        return ['eth_blockNumber', []];
      case 'getGasPrice':
        return ['eth_gasPrice', []];
      case 'getBalance':
        return ['eth_getBalance', [Ho(t.address), t.blockTag]];
      case 'getTransactionCount':
        return ['eth_getTransactionCount', [Ho(t.address), t.blockTag]];
      case 'getCode':
        return ['eth_getCode', [Ho(t.address), t.blockTag]];
      case 'getStorageAt':
        return ['eth_getStorageAt', [Ho(t.address), Be(t.position, 32), t.blockTag]];
      case 'sendTransaction':
        return ['eth_sendRawTransaction', [t.signedTransaction]];
      case 'getBlock':
        return t.blockTag ? ['eth_getBlockByNumber', [t.blockTag, !!t.includeTransactions]] : t.blockHash ? ['eth_getBlockByHash', [t.blockHash, !!t.includeTransactions]] : null;
      case 'getTransaction':
        return ['eth_getTransactionByHash', [t.transactionHash]];
      case 'getTransactionReceipt':
        return ['eth_getTransactionReceipt', [t.transactionHash]];
      case 'call':
        return ['eth_call', [Er(this.constructor, 'hexlifyTransaction')(t.transaction, { from: !0 }), t.blockTag]];
      case 'estimateGas':
        return ['eth_estimateGas', [Er(this.constructor, 'hexlifyTransaction')(t.transaction, { from: !0 })]];
      case 'getLogs':
        return t.filter && t.filter.address != null && (t.filter.address = Ho(t.filter.address)), ['eth_getLogs', [t.filter]];
    }
    return null;
  }
  perform(e, t) {
    return li(this, void 0, void 0, function* () {
      if (e === 'call' || e === 'estimateGas') {
        const i = t.transaction;
        if (i && i.type != null && G.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
          const s = yield this.getFeeData();
          s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && ((t = $t(t)), (t.transaction = $t(i)), delete t.transaction.type);
        }
      }
      const r = this.prepareRequest(e, t);
      r == null && Lt.throwError(e + ' not implemented', O.errors.NOT_IMPLEMENTED, { operation: e });
      try {
        return yield this.send(r[0], r[1]);
      } catch (i) {
        return m5(e, i, t);
      }
    });
  }
  _startEvent(e) {
    e.tag === 'pending' && this._startPending(), super._startEvent(e);
  }
  _startPending() {
    if (this._pendingFilter != null) return;
    const e = this,
      t = this.send('eth_newPendingTransactionFilter', []);
    (this._pendingFilter = t),
      t
        .then(function (r) {
          function i() {
            e.send('eth_getFilterChanges', [r])
              .then(function (s) {
                if (e._pendingFilter != t) return null;
                let a = Promise.resolve();
                return (
                  s.forEach(function (o) {
                    (e._emitted['t:' + o.toLowerCase()] = 'pending'),
                      (a = a.then(function () {
                        return e.getTransaction(o).then(function (u) {
                          return e.emit('pending', u), null;
                        });
                      }));
                  }),
                  a.then(function () {
                    return _2(1e3);
                  })
                );
              })
              .then(function () {
                if (e._pendingFilter != t) {
                  e.send('eth_uninstallFilter', [r]);
                  return;
                }
                return (
                  setTimeout(function () {
                    i();
                  }, 0),
                  null
                );
              })
              .catch((s) => {});
          }
          return i(), r;
        })
        .catch((r) => {});
  }
  _stopEvent(e) {
    e.tag === 'pending' && this.listenerCount('pending') === 0 && (this._pendingFilter = null), super._stopEvent(e);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(e, t) {
    const r = $t(QR);
    if (t) for (const s in t) t[s] && (r[s] = !0);
    Oy(e, r);
    const i = {};
    return (
      ['chainId', 'gasLimit', 'gasPrice', 'type', 'maxFeePerGas', 'maxPriorityFeePerGas', 'nonce', 'value'].forEach(function (s) {
        if (e[s] == null) return;
        const a = Od(G.from(e[s]));
        s === 'gasLimit' && (s = 'gas'), (i[s] = a);
      }),
      ['from', 'to', 'data'].forEach(function (s) {
        e[s] != null && (i[s] = K(e[s]));
      }),
      e.accessList && (i.accessList = Pa(e.accessList)),
      i
    );
  }
}
var XR = Object.defineProperty,
  ZR = Object.getOwnPropertyDescriptor,
  eP = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? ZR(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && XR(e, t, i), i;
  },
  Ko = (n, e) => (t, r) => e(t, r, n);
const g5 = he.createInterface('EthereumService');
let Gu = class {
  constructor(n, e, t, r, i) {
    (this.eventAggregator = n), (this.logger = e), (this.configuration = t), (this.readOnlyProvider = r), (this.walletConnector = i), (this.logger = e.scopeTo('EthereumService'));
  }
  static register(n) {
    fe.singleton(g5, Gu).register(n);
  }
  get targetedChainId() {
    return this.configuration.chainId;
  }
  lastBlock;
  async connect(n) {
    return n ? await this.walletConnector.connectTo(n) : await this.walletConnector.connect();
  }
  async getMetaMaskProvider() {
    const n = await _R({ mustBeMetaMask: !0 });
    if (!n) return null;
    if ((await n._metamask.isUnlocked()) && (await n.request({ method: 'eth_accounts' })).length) return n;
  }
  async getAccountsForProvider(n) {
    return _a.isSigner(n) ? [await n.getAddress()] : await n.listAccounts();
  }
  /**
   *
   * @param web3ModalProvider should be a Web3Provider
   * @returns
   */
  async switchToTargetedNetwork(n) {
    try {
      return (
        await n.provider.request?.({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: `0x${this.targetedChainId.toString(16)}` }],
        }),
        n.provider
      );
    } catch (e) {
      if (e.code !== 4902) return;
      throw new Error(`The ${this.configuration.chain} network is not installed in your Metamask configuration`);
    }
  }
  async addTokenToMetamask(n, e, t, r, i) {
    try {
      await n.request({
        method: 'wallet_watchAsset',
        params: {
          type: 'ERC20',
          // Initially only supports ERC20, but eventually more!
          options: {
            address: e,
            // The address that the token is at.
            symbol: t,
            // A ticker symbol or shorthand, up to 5 chars.
            decimals: r,
            // The number of decimals in the token
            image: i,
            // A string url of the token logo
          },
        },
      });
    } catch (s) {
      this.logger.error(s);
    }
  }
  async getBlock(n) {
    const e = await this.readOnlyProvider.getBlock(n);
    return (e.blockDate = new Date(e.timestamp * 1e3)), e;
  }
  getEtherscanLink(n, e = !1) {
    return SR(this.configuration.scanLink, { type: e ? 'tx' : 'address', address: n });
  }
};
Gu = eP([Ko(0, wd), Ko(1, ba), Ko(2, Ea), Ko(3, kd), Ko(4, c0)], Gu);
var tP = Object.defineProperty,
  nP = Object.getOwnPropertyDescriptor,
  rP = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? nP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && tP(e, t, i), i;
  },
  iP = (n, e) => (t, r) => e(t, r, n);
const v5 = he.createInterface('HttpService'),
  x5 = { accept: 'application/json' },
  sP = { 'content-type': 'application/json', ...x5 };
let td = class {
  constructor(n) {
    (this.logger = n), (this.logger = n.scopeTo('HttpService'));
  }
  static register(n) {
    n.register(fe.singleton(v5, td));
  }
  async call(n, e, t) {
    const r = await fetch(n, {
      body: e,
      method: e ? 'POST' : 'GET',
      headers: e ? sP : x5,
      ...t,
    });
    if (r.ok) return await r.json();
    const i = new Error(await r.text());
    return this.logger.error({ response: r, error: i }), Promise.reject(i);
  }
};
td = rP([iP(0, ba)], td);
var aP = Object.defineProperty,
  oP = Object.getOwnPropertyDescriptor,
  uP = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? oP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && aP(e, t, i), i;
  },
  R2 = (n, e) => (t, r) => e(t, r, n);
const w5 = he.createInterface('ObserverService');
let nd = class {
  constructor(n, e) {
    (this.locator = n), (this.cacheService = e);
  }
  static register(n) {
    n.register(fe.singleton(w5, nd));
  }
  /**
   * Make a object property observable and subscribe to changes in its value.
   * Viewmodels should use @watch.
   * @param obj object having the property to observe
   * @param property property to observe
   * @param method ISubscriber, handles changes in the property's values
   * @returns method to unsubscribe.  Singletons, such as services, don't need to call this.
   */
  // @cache<ObserverService>(function () {
  //   return { storage: this.cacheService };
  // })
  listen(n, e, t) {
    const r = this.locator.getObserver(n, e),
      i = {
        handleChange: t,
      };
    return r.subscribe(i), () => r.unsubscribe(i);
  }
};
nd = uP([R2(0, ga), R2(1, ml)], nd);
var lP = Object.defineProperty,
  cP = Object.getOwnPropertyDescriptor,
  dP = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? cP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && lP(e, t, i), i;
  },
  pP = (n, e) => (t, r) => e(t, r, n);
const T5 = he.createInterface('TimingService');
let rd = class {
  constructor(n) {
    this.config = n;
  }
  static register(n) {
    fe.singleton(T5, rd).register(n);
  }
  startTimer(n) {
    this.config.isDevelopment && console.time(n);
  }
  endTimer(n) {
    this.config.isDevelopment && console.timeEnd(n);
  }
};
rd = dP([pP(0, Ea)], rd);
var fP = Object.defineProperty,
  hP = Object.getOwnPropertyDescriptor,
  yP = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? hP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && fP(e, t, i), i;
  },
  er = (n, e) => (t, r) => e(t, r, n);
const mP = he.createInterface();
let fh = class {
  constructor(n, e, t, r, i, s, a, o, u, l, p, h) {
    (this.httpService = n),
      (this.numberService = e),
      (this.ethereumService = t),
      (this.browserStorageService = r),
      (this.timingService = i),
      (this.cacheService = s),
      (this.observerService = a),
      (this.encryptionService = o),
      (this.contractService = u),
      (this.tokenService = l),
      (this.ipfsService = p),
      (this.configuration = h);
  }
  static register(n) {
    n.register(fe.singleton(mP, fh)).register(nd).register(rd).register(Id).register($u).register(td).register(Uu).register(Gu).register(Xc).register(t0).register(Yc).register(co).register(po);
  }
};
fh = yP([er(0, v5), er(1, wl), er(2, g5), er(3, e0), er(4, T5), er(5, ml), er(6, w5), er(7, G6), er(8, Bo), er(9, Xy), er(10, Zy), er(11, Ea)], fh);
he.createInterface('DateServiceIntl');
var bP = Object.defineProperty,
  gP = Object.getOwnPropertyDescriptor,
  vP = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? gP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && bP(e, t, i), i;
  };
let P2 = class {
  disposables;
  constructor() {
    this.disposables = new Array();
  }
  push(n) {
    return this.disposables.push(n);
  }
  dispose(n) {
    if (n) this._dispose(n);
    else {
      for (n of this.disposables) n.dispose();
      this.disposables.length = 0;
    }
  }
  _dispose(n) {
    n.dispose(), this.disposables.splice(this.disposables.indexOf(n), 1);
  }
};
P2 = vP([Bv()], P2);
var xP = Object.defineProperty,
  wP = Object.getOwnPropertyDescriptor,
  TP = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? wP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && xP(e, t, i), i;
  },
  AP = (n, e) => (t, r) => e(t, r, n);
const EP = he.createInterface('TransactionsService');
let id = class {
  constructor(n) {
    this.eventAggregator = n;
  }
  static blocksToConfirm = 1;
  static register(n) {
    fe.singleton(EP, id).register(n);
  }
  async send(n) {
    let e;
    try {
      this.eventAggregator.publish('transaction.sending');
      const t = await n();
      return (
        this.eventAggregator.publish('transaction.sent', t),
        (e = await t.wait(1)),
        this.eventAggregator.publish('transaction.mined', { message: 'Transaction was mined', receipt: e }),
        (e = await t.wait(id.blocksToConfirm)),
        this.eventAggregator.publish('transaction.confirmed', { message: 'Transaction was confirmed', receipt: e }),
        e
      );
    } catch (t) {
      return this.eventAggregator.publish('transaction.failed', t), null;
    }
  }
};
id = TP([AP(0, wd)], id);
var CP = Object.defineProperty,
  SP = Object.getOwnPropertyDescriptor,
  MP = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? SP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && CP(e, t, i), i;
  },
  qo = (n, e) => (t, r) => e(t, r, n);
const p0 = he.createInterface('IContractStore');
let sd = class {
  constructor(n, e, t, r, i) {
    (this.contractService = n), (this.tokenService = e), (this.logger = t), (this.numberService = r), (this.tokenInfo = i);
  }
  static register(n) {
    n.register(fe.singleton(p0, sd));
  }
  async getAsset(n, e, t, r, i, s) {
    let a;
    e && (a = Number(e));
    const u = (await this.tokenInfo.tokens).find((w) => w.address === n && w.id == a);
    if (!u) {
      this.logger.error(`No token info was found for ${n}`);
      return;
    }
    const l = await this.tokenService.getTokenContract(n, u.id);
    if ((s || (u.id ? (s = await t.oraclePerERC721Id(n, u.id)) : (s = await t.oraclePerERC20(n))), !s || G.from(s).isZero())) return;
    const h = await (await this.contractService.getContract('monetary', 'Oracle', s)).getData();
    if (!h[1]) return;
    u.price = this.numberService.fromString(Ct(h[0], 18));
    let b = y2(1, 18),
      E;
    u.id || ((E = await l.totalSupply()), (b = await l.balanceOf(r)));
    let x;
    u.id ? (x = fu.Low) : (x = await t.assetTypeOfERC20(n)), i && this.populateTransactionsForAsset(i, l, r, u);
    const T = {
      quantity: b,
      token: u,
      total: 0,
      type: x,
      totalSupply: E,
    };
    return (T.total = u.id ? u.price : this.numberService.fromString(Ct(T.quantity, 18)) * u.price), T;
  }
  async populateTransactionsForAsset(n, e, t, r) {
    const i = await e.queryFilter(e.filters.Transfer(void 0, t)),
      s = await this.mapTransactions(i, 'deposit', r);
    n.push(...s);
    const a = await e.queryFilter(e.filters.Transfer(t)),
      o = await this.mapTransactions(a, 'withdrawl', r);
    n.push(...o);
  }
  async mapTransactions(n, e, t) {
    return await Promise.all(
      n.map(async (r) => {
        const i = await r.getBlock();
        return {
          address: e === 'deposit' ? r.args.from : r.args.to,
          amount: 'amount' in r.args ? r.args.amount : y2(1, 18),
          date: i.timestamp,
          id: r.transactionHash,
          token: t,
          type: e,
        };
      }),
    );
  }
};
sd = MP([qo(0, Bo), qo(1, Xy), qo(2, ba), qo(3, wl), qo(4, j6)], sd);
var _P = Object.defineProperty,
  RP = Object.getOwnPropertyDescriptor,
  PP = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? RP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && _P(e, t, i), i;
  },
  IP = (n, e) => (t, r) => e(t, r, n);
const f0 = he.createInterface('DataStore');
let ad = class {
  constructor(n) {
    this.firebaseService = n;
  }
  static register(n) {
    n.register(fe.singleton(f0, ad));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async getDocs(...n) {
    return this.firebaseService.getDocs(...n);
  }
};
ad = PP([IP(0, Yy)], ad);
function Kd(n = '') {
  const e = /* @__PURE__ */ new WeakMap();
  return function (t, r, i) {
    const s = t[r];
    if (typeof s != 'function') throw new Error(`ER: @callOnce: > ${String(r)}`);
    i.value = function (...a) {
      if (e.has(this)) return e.get(this);
      const o = s.apply(this, a);
      return e.set(this, o), o;
    };
  };
}
var kP = Object.defineProperty,
  OP = Object.getOwnPropertyDescriptor,
  qd = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? OP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && kP(e, t, i), i;
  },
  Wo = (n, e) => (t, r) => e(t, r, n);
const A5 = he.createInterface('ReserveStore');
let ca = class {
  constructor(n, e, t, r, i) {
    (this.contractStore = n), (this.contractService = e), (this.numberService = t), (this.configuration = r), (this.dataStore = i);
  }
  reserveValue;
  kCurMarketCap;
  backing;
  kCurPrice;
  kCurSupply;
  transactions = [];
  reserveAssets = [];
  kCurReserveDistribution;
  kCurMentoDistribution;
  kCurPrimaryPoolDistribution;
  minBacking;
  kGuilderCurrentPrice;
  kGuilderTotalSupply;
  kGuilderSpread;
  kGuilderInflationRate;
  kGuilderTobinTax;
  static register(n) {
    n.register(fe.singleton(A5, ca));
  }
  get kCurCirculatingDistribution() {
    return !this.kCurReserveDistribution || !this.kCurMentoDistribution || !this.kCurPrimaryPoolDistribution
      ? 0
      : 1 - (this.kCurReserveDistribution + this.kCurMentoDistribution + this.kCurPrimaryPoolDistribution);
  }
  get currentCollateralizationRatio() {
    return this.numberService.fromString(Ct(this.backing ?? 0, 2));
  }
  get currentLeverageRatio() {
    return this.backing ? this.calculateLeverage(this.backing) : 0;
  }
  get maxLeverageRatio() {
    return (1 / this.numberService.fromString(Ct(this.minBacking ?? 0, 4))) * 100;
  }
  get minCollateralizationRatio() {
    return this.numberService.fromString(Ct(this.minBacking ?? 0, 4));
  }
  get minCollateralizationValue() {
    return this.kCurMarketCap ? this.minCollateralizationRatio * this.numberService.fromString(Ct(this.kCurMarketCap, 18)) : 0;
  }
  get maxLeverageMultiplier() {
    return `${Math.round((this.maxLeverageRatio / 100) * 100) / 100}x`;
  }
  get kCurTotalValue() {
    return this.numberService.fromString(Ct(this.kCurMarketCap ?? 0, 18));
  }
  get kGuilderMarketCap() {
    return this.kGuilderCurrentPrice ? this.kGuilderCurrentPrice * this.numberService.fromString(Ct(this.kGuilderTotalSupply ?? 0, 18)) : 0;
  }
  get kCurPriceFloor() {
    return !this.reserveValue || !this.kCurSupply ? 0 : this.numberService.fromString(Ct(this.reserveValue, 18)) / this.numberService.fromString(Ct(this.kCurSupply, 18));
  }
  get kCurPriceCeiling() {
    return !this.reserveValue || !this.kCurSupply ? 0 : this.kCurPriceFloor * 1.9;
  }
  get kGuilderValueRatio() {
    return this.kCurPrice ? 4 / this.kCurPrice : 0;
  }
  async loadAssets() {
    const n = await this.getReserveContract(),
      e = n.address;
    if (!e) return;
    const t = (
      await Promise.all([
        n.allRegisteredERC20s().then((i) => i.map((s) => ({ tokenId: void 0, address: s }))),
        n.allRegisteredERC721Ids().then((i) => i.map((s) => ({ tokenId: s.id, address: s.erc721 }))),
      ])
    ).flatMap((i) => i);
    (this.reserveAssets = (await Promise.all(t.map((i) => this.contractStore.getAsset(i.address, i.tokenId, n, e, this.transactions).catch()))).filter(Boolean)), this.loadkCurData();
    const r = await n.reserveStatus();
    (this.reserveValue = r[0]), (this.kCurMarketCap = r[1]), (this.backing = r[2]), (this.minBacking = await n.minBacking());
  }
  async loadkCur() {
    if ((await this.loadkCurData(), !this.kCurSupply)) return;
    const n = this.numberService.fromString(Ct(this.kCurSupply, 18)),
      e = await this.contractService.getContract('monetary', 'CuracaoReserveToken'),
      t = await this.contractService.getContract('monetary', 'KolektivoMultiSig'),
      r = await e.balanceOf(t.address);
    this.kCurReserveDistribution = this.numberService.fromString(Ct(r, 18)) / n;
    const i = await this.contractService.getContract('monetary', 'MentoReserve'),
      s = await e.balanceOf(i.address);
    (this.kCurMentoDistribution = this.numberService.fromString(Ct(s, 18)) / n), (this.kCurPrimaryPoolDistribution = 0);
  }
  async loadkGuilder() {
    const n = await this.getReserveContract();
    if (!n.address) return;
    const t = await this.contractService.getContract('monetary', 'KolektivoGuilder');
    console.log('kGuilder Contract', t);
    const r = await n.tokenOracle();
    console.log('kGuilder Oracle Address', r);
    const i = await this.contractService.getContract('monetary', 'Oracle', r);
    console.log('kGuilder Oracle Contact', i);
    const s = await i.getData();
    console.log('DATA', s);
    const a = await t.totalSupply();
    console.log('Total Supply', a);
    const u = await (await this.contractService.getContract('monetary', 'MentoExchange')).spread();
    console.log('Spread', u);
    const p = await (await this.contractService.getContract('monetary', 'MentoReserve')).tobinTax();
    console.log('Tobin Tax', p),
      (this.kGuilderCurrentPrice = this.numberService.fromString(Ct(s[0], 18))),
      (this.kGuilderTotalSupply = a),
      (this.kGuilderSpread = this.numberService.fromString(Ct(u, 18))),
      (this.kGuilderInflationRate = 0.01),
      (this.kGuilderTobinTax = this.numberService.fromString(Ct(p, 18)));
  }
  async loadkCurData() {
    if (this.kCurPrice || this.kCurSupply) return;
    const n = await this.getReserveContract(),
      e = await n.token();
    if (!e) return;
    const t = n.address;
    if (!t) return;
    const r = await n.tokenOracle();
    if (!r) return;
    const i = await this.contractStore.getAsset(e, void 0, n, t, void 0, r);
    (this.kCurPrice = i?.token.price), (this.kCurSupply = i?.totalSupply);
  }
  getReserveContract() {
    return this.contractService.getContract('monetary', 'Reserve');
  }
  async getReserveValueOverTime(n) {
    const [e, t] = await Promise.all([this.getData('reserve', n), this.getReserveContract().then((r) => r.reserveStatus())]);
    return (
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        value: t[0],
      }),
      e
    );
  }
  async getkGuilderValueRatioOverTime(n) {
    const [e] = await Promise.all([this.getData('kGuilder', n), this.loadkCurData()]);
    return (
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        value: this.kGuilderValueRatio,
      }),
      e
    );
  }
  async getLeverageRatioValueOverTime(n) {
    const [e, [t, r]] = await Promise.all([this.getData('kCurRatio', n), this.getReserveContract().then((i) => Promise.all([i.reserveStatus(), i.minBacking()]))]);
    return (
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        currentLeverageRatio: this.calculateLeverage(t[2]),
        maxLeverageRatio: (1 / (this.numberService.fromString(Ct(r, 2)) / 100)) * 100,
      }),
      e
    );
  }
  async getkCurSupplyData(n) {
    const [e] = await Promise.all([this.getData('kCurSupply', n), this.loadkCur()]);
    return (
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        kCurCirculatingDistribution: this.kCurCirculatingDistribution,
        kCurMentoDistribution: this.kCurMentoDistribution,
        kCurPrimaryPoolDistribution: this.kCurPrimaryPoolDistribution,
        kCurReserveDistribution: this.kCurReserveDistribution,
      }),
      e
    );
  }
  async getkCurPriceOverTime(n) {
    const [e] = await Promise.all([this.getData('kCurPrice', n), this.loadkCurData(), this.loadAssets()]);
    return (
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        kCurPrice: this.kCurPrice,
        kCurPriceCeiling: this.kCurPriceCeiling,
        kCurPriceFloor: this.kCurPriceFloor,
      }),
      e
    );
  }
  get lowRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === fu.Low) ?? [];
  }
  get moderateRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === fu.Medium) ?? [];
  }
  get highRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === fu.High) ?? [];
  }
  async getRiskOverTime(n) {
    const [e, [t, r, i]] = await Promise.all([this.getData('risk', n), this.getReserveContract().then((s) => Promise.all([s.reserveStatus(), s.minBacking(), s])), this.loadAssets()]);
    return (
      (this.kCurMarketCap = t[1]),
      (this.minBacking = r),
      (this.reserveAssets = await Promise.all(this.reserveAssets?.map(async (s) => ({ ...s, type: await i.riskLevelOfERC20(s.token.address) })) ?? [])),
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        minCollateralValue: this.minCollateralizationValue,
        marketCap: this.kCurTotalValue,
        lowRisk: 0,
        moderateRisk: 0,
        highRisk: 0,
      }),
      e
    );
  }
  async getData(n, e) {
    const t = d5(e),
      r = await this.dataStore.getDocs(`${this.configuration.firebaseCollection}/${n}/${c5(e)}`, 'createdAt', 'desc', {
        fieldPath: 'createdAt',
        opStr: '>=',
        value: t,
      });
    return r.sort((i, s) => new Date(i.createdAt).getTime() - new Date(s.createdAt).getTime()), r;
  }
  calculateLeverage(n) {
    return (1 / this.numberService.fromString(Ct(n, 4))) * 100;
  }
};
qd([Kd()], ca.prototype, 'loadAssets', 1);
qd([Kd()], ca.prototype, 'loadkCur', 1);
qd([Kd()], ca.prototype, 'loadkGuilder', 1);
ca = qd([Wo(0, p0), Wo(1, Bo), Wo(2, wl), Wo(3, Ea), Wo(4, f0)], ca);
var BP = Object.defineProperty,
  NP = Object.getOwnPropertyDescriptor,
  E5 = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? NP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && BP(e, t, i), i;
  },
  Jo = (n, e) => (t, r) => e(t, r, n);
const C5 = he.createInterface('TreasuryStore');
let Hu = class {
  constructor(n, e, t, r, i) {
    (this.numberService = n), (this.contractStore = e), (this.contractService = t), (this.configuration = r), (this.dataStore = i);
  }
  totalSupply;
  totalValuation;
  treasuryDistribution;
  reservesDistribution;
  treasuryContract;
  lastRebaseTime;
  treasuryAssets = [];
  transactions = [];
  static register(n) {
    n.register(fe.singleton(C5, Hu));
  }
  get treasuryValue() {
    return this.treasuryAssets?.length === 0 ? 0 : this.treasuryAssets?.map((n) => n?.total ?? 0).sum() ?? 0;
  }
  async loadTokenData() {
    if (this.totalValuation && this.totalSupply) return;
    const n = await this.getTreasuryContract();
    (this.totalValuation = await n.totalValuation()),
      (this.totalSupply = await n.totalSupply()),
      (this.treasuryDistribution = (await this.getDistributionPercentage('Treasury')).toNumber()),
      (this.reservesDistribution = (await this.getDistributionPercentage('Reserve')).toNumber());
  }
  async loadAssets() {
    const n = await this.getTreasuryContract(),
      e = n.address;
    if (!e) return;
    const t = (
      await Promise.all([
        n.allRegisteredERC20s().then((r) => r.map((i) => ({ tokenId: void 0, address: i }))),
        n.allRegisteredERC721Ids().then((r) => r.map((i) => ({ tokenId: i.id, address: i.erc721 }))),
      ])
    ).flatMap((r) => r);
    this.treasuryAssets = (await Promise.all(t.map((r) => this.contractStore.getAsset(r.address, r.tokenId, n, e, this.transactions).catch()))).filter(Boolean);
  }
  async getValueOverTime(n) {
    const e = d5(n),
      r = (
        await this.dataStore.getDocs(`${this.configuration.firebaseCollection}/ktt/${c5(n)}`, 'createdAt', 'desc', {
          fieldPath: 'createdAt',
          opStr: '>=',
          value: e,
        })
      ).map((a) => ({
        createdAt: Number(new Date(a.createdAt)),
        value: this.numberService.fromString(Ct(a.value, 18)),
      }));
    r.sort((a, o) => new Date(a.createdAt).getTime() - new Date(o.createdAt).getTime());
    const s = await (await this.getTreasuryContract()).totalValuation();
    return (
      r.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        value: this.numberService.fromString(Ct(s, 18)),
      }),
      r
    );
  }
  async getLastRebaseTime() {
    const n = await this.getTreasuryContract(),
      e = await n.queryFilter(n.filters.Rebase());
    e.sort((t, r) => r.blockNumber - t.blockNumber), (this.lastRebaseTime = e[0] && new Date((await e[0].getBlock()).timestamp * 1e3));
  }
  get circulatingDistribution() {
    return this.treasuryDistribution == null || this.reservesDistribution == null ? 0 : 1 - (this.treasuryDistribution + this.reservesDistribution);
  }
  get currentPrice() {
    return !this.totalSupply || !this.totalValuation ? 0 : Number(Ct(this.totalSupply, 18)) / Number(Ct(this.totalValuation, 18));
  }
  async getTreasuryContract() {
    return this.treasuryContract ? this.treasuryContract : ((this.treasuryContract = await this.contractService.getContract('monetary', 'Treasury')), this.treasuryContract);
  }
  async getDistributionPercentage(n) {
    const e = (await this.contractService.getContract('monetary', n)).address;
    return !e || !this.totalSupply ? G.from(0) : (await (await this.getTreasuryContract()).balanceOf(e)).div(this.totalSupply);
  }
};
E5([Kd()], Hu.prototype, 'loadAssets', 1);
Hu = E5([Jo(0, wl), Jo(1, p0), Jo(2, Bo), Jo(3, Ea), Jo(4, f0)], Hu);
var DP = Object.defineProperty,
  FP = Object.getOwnPropertyDescriptor,
  LP = (n, e, t, r) => {
    for (var i = r > 1 ? void 0 : r ? FP(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
    return r && i && DP(e, t, i), i;
  },
  $P = (n, e) => (t, r) => e(t, r, n);
const UP = he.createInterface();
let I2 = class {
  constructor(n) {
    this.walletConnector = n;
  }
  provider;
  async connect(n) {
    this.provider = n ? await this.walletConnector.connectTo(n) : await this.walletConnector.connect();
  }
};
I2 = LP([$P(0, c0)], I2);
const jP = new O('CeloNetworks'),
  k2 = [
    {
      name: 'celo',
      chainId: 42220,
    },
    {
      name: 'alfajores',
      chainId: 44787,
    },
    {
      name: 'baklava',
      chainId: 62320,
    },
  ];
function hh(n) {
  {
    if (n == null) return null;
    if (typeof n == 'number') {
      const e = k2.filter((t) => t.chainId === n);
      return e.length
        ? { name: e[0].name, chainId: e[0].chainId }
        : {
            name: 'unknown',
            chainId: n,
          };
    }
    if (typeof n == 'string') {
      const e = k2.filter((t) => t.name === n);
      return e.length ? { name: e[0].name, chainId: e[0].chainId } : null;
    }
    if (typeof n.name == 'string' && typeof n.chainId == 'number') {
      const e = hh(n.name),
        t = hh(n.chainId);
      if (e == null && t == null)
        return {
          name: n.name,
          chainId: n.chainId,
        };
      if (e && t && e.name === t.name && e.chainId === t.chainId) return e;
    }
    return jP.throwArgumentError('network chainId mismatch', 'network', n);
  }
}
const VP = new O('celo/transactions');
function zP(n) {
  const e = vl(n);
  e.length !== 12 && e.length !== 9 && VP.throwArgumentError('invalid raw transaction', 'rawTransaction', n);
  const t = {
    nonce: Qo(e[0]).toNumber(),
    gasPrice: Qo(e[1]),
    gasLimit: Qo(e[2]),
    feeCurrency: uf(e[3]),
    gatewayFeeRecipient: uf(e[4]),
    gatewayFee: Qo(e[5]),
    to: uf(e[6]),
    value: Qo(e[7]),
    data: e[8],
    chainId: 0,
  };
  if (e.length === 9) return t;
  try {
    t.v = G.from(e[9]).toNumber();
  } catch (r) {
    return console.log(r), t;
  }
  if (((t.r = Be(e[10], 32)), (t.s = Be(e[11], 32)), G.from(t.r).isZero() && G.from(t.s).isZero())) (t.chainId = t.v), (t.v = 0);
  else {
    (t.chainId = Math.floor((t.v - 35) / 2)), t.chainId < 0 && (t.chainId = 0);
    let r = t.v - 27;
    const i = e.slice(0, 6);
    t.chainId !== 0 && (i.push(K(t.chainId)), i.push('0x'), i.push('0x'), (r -= t.chainId * 2 + 8));
    const s = Ie(ys(i));
    try {
      t.from = Oo(s, {
        r: K(t.r),
        s: K(t.s),
        recoveryParam: r,
      });
    } catch (a) {
      console.log(a);
    }
    t.hash = Ie(n);
  }
  return t;
}
function uf(n) {
  if (n !== '0x')
    try {
      return Oe(n);
    } catch {
      return n;
    }
}
function Qo(n) {
  return n === '0x' ? Fy : G.from(n);
}
const GP = new O('CeloProvider');
class HP extends YR {
  constructor(e, t) {
    super(e, t);
    const r = this.formatter.formats.block;
    (r.gasLimit = () => G.from(0)), (r.nonce = () => ''), (r.difficulty = () => 0);
    const i = this.formatter.formats.blockWithTransactions;
    (i.gasLimit = () => G.from(0)), (i.nonce = () => ''), (i.difficulty = () => 0);
  }
  /**
   * Override to parse transaction correctly
   * https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/base-provider.ts
   */
  async sendTransaction(e) {
    await this.getNetwork();
    const t = await Promise.resolve(e),
      r = K(t),
      i = zP(t);
    try {
      const s = await this.perform('sendTransaction', {
        signedTransaction: r,
      });
      return this._wrapTransaction(i, s);
    } catch (s) {
      throw ((s.transaction = i), (s.transactionHash = i.hash), s);
    }
  }
  /**
   * Override to handle alternative gas currencies
   * getGasPrice in https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/base-provider.ts
   */
  async getGasPrice(e) {
    await this.getNetwork();
    const t = e ? { feeCurrencyAddress: e } : {};
    return G.from(await this.perform('getGasPrice', t));
  }
  /**
   * Override to handle alternative gas currencies
   * prepareRequest in https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts
   */
  prepareRequest(e, t) {
    return e === 'getGasPrice' ? ['eth_gasPrice', t.feeCurrencyAddress ? [t.feeCurrencyAddress] : []] : super.prepareRequest(e, t);
  }
  static getNetwork(e) {
    const t = hh(e ?? 'celo');
    return (
      t ??
      GP.throwError(`unknown network: ${JSON.stringify(t)}`, O.errors.UNSUPPORTED_OPERATION, {
        operation: 'getNetwork',
        value: e,
      })
    );
  }
}
O.errors.INSUFFICIENT_FUNDS, O.errors.NONCE_EXPIRED, O.errors.REPLACEMENT_UNDERPRICED;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const S5 = function (n) {
    const e = [];
    let t = 0;
    for (let r = 0; r < n.length; r++) {
      let i = n.charCodeAt(r);
      i < 128
        ? (e[t++] = i)
        : i < 2048
        ? ((e[t++] = (i >> 6) | 192), (e[t++] = (i & 63) | 128))
        : (i & 64512) === 55296 && r + 1 < n.length && (n.charCodeAt(r + 1) & 64512) === 56320
        ? ((i = 65536 + ((i & 1023) << 10) + (n.charCodeAt(++r) & 1023)), (e[t++] = (i >> 18) | 240), (e[t++] = ((i >> 12) & 63) | 128), (e[t++] = ((i >> 6) & 63) | 128), (e[t++] = (i & 63) | 128))
        : ((e[t++] = (i >> 12) | 224), (e[t++] = ((i >> 6) & 63) | 128), (e[t++] = (i & 63) | 128));
    }
    return e;
  },
  KP = function (n) {
    const e = [];
    let t = 0,
      r = 0;
    for (; t < n.length; ) {
      const i = n[t++];
      if (i < 128) e[r++] = String.fromCharCode(i);
      else if (i > 191 && i < 224) {
        const s = n[t++];
        e[r++] = String.fromCharCode(((i & 31) << 6) | (s & 63));
      } else if (i > 239 && i < 365) {
        const s = n[t++],
          a = n[t++],
          o = n[t++],
          u = (((i & 7) << 18) | ((s & 63) << 12) | ((a & 63) << 6) | (o & 63)) - 65536;
        (e[r++] = String.fromCharCode(55296 + (u >> 10))), (e[r++] = String.fromCharCode(56320 + (u & 1023)));
      } else {
        const s = n[t++],
          a = n[t++];
        e[r++] = String.fromCharCode(((i & 15) << 12) | ((s & 63) << 6) | (a & 63));
      }
    }
    return e.join('');
  },
  M5 = {
    /**
     * Maps bytes to characters.
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     */
    get ENCODED_VALS() {
      return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     */
    get ENCODED_VALS_WEBSAFE() {
      return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     */
    HAS_NATIVE_SUPPORT: typeof atob == 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeByteArray(n, e) {
      if (!Array.isArray(n)) throw Error('encodeByteArray takes an array as a parameter');
      this.init_();
      const t = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
        r = [];
      for (let i = 0; i < n.length; i += 3) {
        const s = n[i],
          a = i + 1 < n.length,
          o = a ? n[i + 1] : 0,
          u = i + 2 < n.length,
          l = u ? n[i + 2] : 0,
          p = s >> 2,
          h = ((s & 3) << 4) | (o >> 4);
        let b = ((o & 15) << 2) | (l >> 6),
          E = l & 63;
        u || ((E = 64), a || (b = 64)), r.push(t[p], t[h], t[b], t[E]);
      }
      return r.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param input A string to encode.
     * @param webSafe If true, we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeString(n, e) {
      return this.HAS_NATIVE_SUPPORT && !e ? btoa(n) : this.encodeByteArray(S5(n), e);
    },
    /**
     * Base64-decode a string.
     *
     * @param input to decode.
     * @param webSafe True if we should use the
     *     alternative alphabet.
     * @return string representing the decoded value.
     */
    decodeString(n, e) {
      return this.HAS_NATIVE_SUPPORT && !e ? atob(n) : KP(this.decodeStringToByteArray(n, e));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param input Input to decode.
     * @param webSafe True if we should use the web-safe alphabet.
     * @return bytes representing the decoded value.
     */
    decodeStringToByteArray(n, e) {
      this.init_();
      const t = e ? this.charToByteMapWebSafe_ : this.charToByteMap_,
        r = [];
      for (let i = 0; i < n.length; ) {
        const s = t[n.charAt(i++)],
          o = i < n.length ? t[n.charAt(i)] : 0;
        ++i;
        const l = i < n.length ? t[n.charAt(i)] : 64;
        ++i;
        const h = i < n.length ? t[n.charAt(i)] : 64;
        if ((++i, s == null || o == null || l == null || h == null)) throw new qP();
        const b = (s << 2) | (o >> 4);
        if ((r.push(b), l !== 64)) {
          const E = ((o << 4) & 240) | (l >> 2);
          if ((r.push(E), h !== 64)) {
            const x = ((l << 6) & 192) | h;
            r.push(x);
          }
        }
      }
      return r;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_() {
      if (!this.byteToCharMap_) {
        (this.byteToCharMap_ = {}), (this.charToByteMap_ = {}), (this.byteToCharMapWebSafe_ = {}), (this.charToByteMapWebSafe_ = {});
        for (let n = 0; n < this.ENCODED_VALS.length; n++)
          (this.byteToCharMap_[n] = this.ENCODED_VALS.charAt(n)),
            (this.charToByteMap_[this.byteToCharMap_[n]] = n),
            (this.byteToCharMapWebSafe_[n] = this.ENCODED_VALS_WEBSAFE.charAt(n)),
            (this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[n]] = n),
            n >= this.ENCODED_VALS_BASE.length && ((this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(n)] = n), (this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(n)] = n));
      }
    },
  };
class qP extends Error {
  constructor() {
    super(...arguments), (this.name = 'DecodeBase64StringError');
  }
}
const WP = function (n) {
    const e = S5(n);
    return M5.encodeByteArray(e, !0);
  },
  od = function (n) {
    return WP(n).replace(/\./g, '');
  },
  JP = function (n) {
    try {
      return M5.decodeString(n, !0);
    } catch (e) {
      console.error('base64Decode failed: ', e);
    }
    return null;
  };
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function QP() {
  if (typeof self < 'u') return self;
  if (typeof window < 'u') return window;
  if (typeof oa < 'u') return oa;
  throw new Error('Unable to locate global object.');
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const YP = () => QP().__FIREBASE_DEFAULTS__,
  XP = () => {
    if (
      typeof fc > 'u' ||
      typeof {
        ALLUSERSPROFILE: 'C:\\ProgramData',
        APPDATA: 'C:\\Users\\viper\\AppData\\Roaming',
        CHROME_CRASHPAD_PIPE_NAME: '\\\\.\\pipe\\crashpad_67280_IYMAGMGUJGLXPKLQ',
        COLOR: '1',
        COLORTERM: 'truecolor',
        CommonProgramFiles: 'C:\\Program Files\\Common Files',
        'CommonProgramFiles(x86)': 'C:\\Program Files (x86)\\Common Files',
        CommonProgramW6432: 'C:\\Program Files\\Common Files',
        COMPUTERNAME: 'ULTIMATEPC',
        ComSpec: 'C:\\Windows\\system32\\cmd.exe',
        DriverData: 'C:\\Windows\\System32\\Drivers\\DriverData',
        EDITOR: 'C:\\Windows\\notepad.exe',
        FPS_BROWSER_APP_PROFILE_STRING: 'Internet Explorer',
        FPS_BROWSER_USER_PROFILE_STRING: 'Default',
        GIT_ASKPASS: 'c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh',
        HOME: 'C:\\Users\\viper',
        HOMEDRIVE: 'C:',
        HOMEPATH: '\\Users\\viper',
        INIT_CWD: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp',
        LANG: 'en_US.UTF-8',
        LOCALAPPDATA: 'C:\\Users\\viper\\AppData\\Local',
        LOGONSERVER: '\\\\ULTIMATEPC',
        NODE: 'C:\\Program Files\\nodejs\\node.exe',
        NODE_ENV: 'production',
        NODE_EXE: 'C:\\Program Files\\nodejs\\\\node.exe',
        NPM_CLI_JS: 'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
        npm_command: 'run-script',
        npm_config_cache: 'C:\\Users\\viper\\AppData\\Local\\npm-cache',
        npm_config_globalconfig: 'C:\\Program Files\\nodejs\\etc\\npmrc',
        npm_config_global_prefix: 'C:\\Program Files\\nodejs',
        npm_config_init_module: 'C:\\Users\\viper\\.npm-init.js',
        npm_config_local_prefix: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp',
        npm_config_metrics_registry: 'https://registry.npmjs.org/',
        npm_config_node_gyp: 'C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js',
        npm_config_noproxy: '',
        npm_config_prefix: 'C:\\Program Files\\nodejs',
        npm_config_shamefully_hoist: 'true',
        npm_config_userconfig: 'C:\\Users\\viper\\.npmrc',
        npm_config_user_agent: 'npm/9.5.1 node/v19.8.1 win32 x64 workspaces/false',
        npm_execpath: 'C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\bin\\npm-cli.js',
        npm_lifecycle_event: 'build:dev:chart-data-script',
        npm_lifecycle_script: 'vite build --config vite.config-lib.ts --mode development',
        npm_node_execpath: 'C:\\Program Files\\nodejs\\node.exe',
        npm_package_engines_node: '>=16.0.0',
        npm_package_json: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\package.json',
        npm_package_name: '@kolektivo/dapp',
        npm_package_version: '1.0.0',
        NPM_PREFIX_NPM_CLI_JS: 'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
        NUMBER_OF_PROCESSORS: '24',
        NVM_HOME: 'C:\\Users\\viper\\AppData\\Roaming\\nvm',
        NVM_SYMLINK: 'C:\\Program Files\\nodejs',
        OculusBase: 'C:\\Program Files\\Oculus\\',
        OneDrive: 'C:\\Users\\viper\\OneDrive',
        OneDriveConsumer: 'C:\\Users\\viper\\OneDrive',
        ORIGINAL_XDG_CURRENT_DESKTOP: 'undefined',
        OS: 'Windows_NT',
        Path: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\node_modules\\.bin;C:\\Users\\viper\\source\\node_modules\\.bin;C:\\Users\\viper\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Oculus\\Support\\oculus-runtime;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Users\\viper\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Git\\cmd;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\DTS\\Binn\\;C:\\Program Files (x86)\\Microsoft SQL Server\\160\\DTS\\Binn\\;C:\\Program Files\\Azure Data Studio\\bin;C:\\Program Files (x86)\\GnuWin32\\bin;C:\\Program Files\\dotnet\\;C:\\Users\\viper\\.cargo\\bin;C:\\Users\\viper\\AppData\\Local\\Microsoft\\PowerAppsCLI\\;C:\\Users\\viper\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\viper\\.dotnet\\tools;C:\\Users\\viper\\AppData\\Local\\Programs\\Fiddler;C:\\Users\\viper\\.dotnet\\tools',
        PATHEXT: '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL',
        PROCESSOR_ARCHITECTURE: 'AMD64',
        PROCESSOR_IDENTIFIER: 'Intel64 Family 6 Model 151 Stepping 2, GenuineIntel',
        PROCESSOR_LEVEL: '6',
        PROCESSOR_REVISION: '9702',
        ProgramData: 'C:\\ProgramData',
        ProgramFiles: 'C:\\Program Files',
        'ProgramFiles(x86)': 'C:\\Program Files (x86)',
        ProgramW6432: 'C:\\Program Files',
        PROMPT: '$P$G',
        PSModulePath:
          'C:\\Users\\viper\\OneDrive\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\PowerShell\\Modules\\',
        PUBLIC: 'C:\\Users\\Public',
        SystemDrive: 'C:',
        SystemRoot: 'C:\\Windows',
        TEMP: 'C:\\Users\\viper\\AppData\\Local\\Temp',
        TERM_PROGRAM: 'vscode',
        TERM_PROGRAM_VERSION: '1.71.2',
        TMP: 'C:\\Users\\viper\\AppData\\Local\\Temp',
        USERDOMAIN: 'ULTIMATEPC',
        USERDOMAIN_ROAMINGPROFILE: 'ULTIMATEPC',
        USERNAME: 'viper',
        USERPROFILE: 'C:\\Users\\viper',
        VSCODE_GIT_ASKPASS_EXTRA_ARGS: '--ms-enable-electron-run-as-node',
        VSCODE_GIT_ASKPASS_MAIN: 'c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js',
        VSCODE_GIT_ASKPASS_NODE: 'C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe',
        VSCODE_GIT_IPC_HANDLE: '\\\\.\\pipe\\vscode-git-860c0d3dad-sock',
        windir: 'C:\\Windows',
      } > 'u'
    )
      return;
    const n = {
      ALLUSERSPROFILE: 'C:\\ProgramData',
      APPDATA: 'C:\\Users\\viper\\AppData\\Roaming',
      CHROME_CRASHPAD_PIPE_NAME: '\\\\.\\pipe\\crashpad_67280_IYMAGMGUJGLXPKLQ',
      COLOR: '1',
      COLORTERM: 'truecolor',
      CommonProgramFiles: 'C:\\Program Files\\Common Files',
      'CommonProgramFiles(x86)': 'C:\\Program Files (x86)\\Common Files',
      CommonProgramW6432: 'C:\\Program Files\\Common Files',
      COMPUTERNAME: 'ULTIMATEPC',
      ComSpec: 'C:\\Windows\\system32\\cmd.exe',
      DriverData: 'C:\\Windows\\System32\\Drivers\\DriverData',
      EDITOR: 'C:\\Windows\\notepad.exe',
      FPS_BROWSER_APP_PROFILE_STRING: 'Internet Explorer',
      FPS_BROWSER_USER_PROFILE_STRING: 'Default',
      GIT_ASKPASS: 'c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh',
      HOME: 'C:\\Users\\viper',
      HOMEDRIVE: 'C:',
      HOMEPATH: '\\Users\\viper',
      INIT_CWD: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp',
      LANG: 'en_US.UTF-8',
      LOCALAPPDATA: 'C:\\Users\\viper\\AppData\\Local',
      LOGONSERVER: '\\\\ULTIMATEPC',
      NODE: 'C:\\Program Files\\nodejs\\node.exe',
      NODE_ENV: 'production',
      NODE_EXE: 'C:\\Program Files\\nodejs\\\\node.exe',
      NPM_CLI_JS: 'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
      npm_command: 'run-script',
      npm_config_cache: 'C:\\Users\\viper\\AppData\\Local\\npm-cache',
      npm_config_globalconfig: 'C:\\Program Files\\nodejs\\etc\\npmrc',
      npm_config_global_prefix: 'C:\\Program Files\\nodejs',
      npm_config_init_module: 'C:\\Users\\viper\\.npm-init.js',
      npm_config_local_prefix: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp',
      npm_config_metrics_registry: 'https://registry.npmjs.org/',
      npm_config_node_gyp: 'C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js',
      npm_config_noproxy: '',
      npm_config_prefix: 'C:\\Program Files\\nodejs',
      npm_config_shamefully_hoist: 'true',
      npm_config_userconfig: 'C:\\Users\\viper\\.npmrc',
      npm_config_user_agent: 'npm/9.5.1 node/v19.8.1 win32 x64 workspaces/false',
      npm_execpath: 'C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\bin\\npm-cli.js',
      npm_lifecycle_event: 'build:dev:chart-data-script',
      npm_lifecycle_script: 'vite build --config vite.config-lib.ts --mode development',
      npm_node_execpath: 'C:\\Program Files\\nodejs\\node.exe',
      npm_package_engines_node: '>=16.0.0',
      npm_package_json: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\package.json',
      npm_package_name: '@kolektivo/dapp',
      npm_package_version: '1.0.0',
      NPM_PREFIX_NPM_CLI_JS: 'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
      NUMBER_OF_PROCESSORS: '24',
      NVM_HOME: 'C:\\Users\\viper\\AppData\\Roaming\\nvm',
      NVM_SYMLINK: 'C:\\Program Files\\nodejs',
      OculusBase: 'C:\\Program Files\\Oculus\\',
      OneDrive: 'C:\\Users\\viper\\OneDrive',
      OneDriveConsumer: 'C:\\Users\\viper\\OneDrive',
      ORIGINAL_XDG_CURRENT_DESKTOP: 'undefined',
      OS: 'Windows_NT',
      Path: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\node_modules\\.bin;C:\\Users\\viper\\source\\node_modules\\.bin;C:\\Users\\viper\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Oculus\\Support\\oculus-runtime;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Users\\viper\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Git\\cmd;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\DTS\\Binn\\;C:\\Program Files (x86)\\Microsoft SQL Server\\160\\DTS\\Binn\\;C:\\Program Files\\Azure Data Studio\\bin;C:\\Program Files (x86)\\GnuWin32\\bin;C:\\Program Files\\dotnet\\;C:\\Users\\viper\\.cargo\\bin;C:\\Users\\viper\\AppData\\Local\\Microsoft\\PowerAppsCLI\\;C:\\Users\\viper\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\viper\\.dotnet\\tools;C:\\Users\\viper\\AppData\\Local\\Programs\\Fiddler;C:\\Users\\viper\\.dotnet\\tools',
      PATHEXT: '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL',
      PROCESSOR_ARCHITECTURE: 'AMD64',
      PROCESSOR_IDENTIFIER: 'Intel64 Family 6 Model 151 Stepping 2, GenuineIntel',
      PROCESSOR_LEVEL: '6',
      PROCESSOR_REVISION: '9702',
      ProgramData: 'C:\\ProgramData',
      ProgramFiles: 'C:\\Program Files',
      'ProgramFiles(x86)': 'C:\\Program Files (x86)',
      ProgramW6432: 'C:\\Program Files',
      PROMPT: '$P$G',
      PSModulePath:
        'C:\\Users\\viper\\OneDrive\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\PowerShell\\Modules\\',
      PUBLIC: 'C:\\Users\\Public',
      SystemDrive: 'C:',
      SystemRoot: 'C:\\Windows',
      TEMP: 'C:\\Users\\viper\\AppData\\Local\\Temp',
      TERM_PROGRAM: 'vscode',
      TERM_PROGRAM_VERSION: '1.71.2',
      TMP: 'C:\\Users\\viper\\AppData\\Local\\Temp',
      USERDOMAIN: 'ULTIMATEPC',
      USERDOMAIN_ROAMINGPROFILE: 'ULTIMATEPC',
      USERNAME: 'viper',
      USERPROFILE: 'C:\\Users\\viper',
      VSCODE_GIT_ASKPASS_EXTRA_ARGS: '--ms-enable-electron-run-as-node',
      VSCODE_GIT_ASKPASS_MAIN: 'c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js',
      VSCODE_GIT_ASKPASS_NODE: 'C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe',
      VSCODE_GIT_IPC_HANDLE: '\\\\.\\pipe\\vscode-git-860c0d3dad-sock',
      windir: 'C:\\Windows',
    }.__FIREBASE_DEFAULTS__;
    if (n) return JSON.parse(n);
  },
  ZP = () => {
    if (typeof document > 'u') return;
    let n;
    try {
      n = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
    } catch {
      return;
    }
    const e = n && JP(n[1]);
    return e && JSON.parse(e);
  },
  _5 = () => {
    try {
      return YP() || XP() || ZP();
    } catch (n) {
      console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${n}`);
      return;
    }
  },
  eI = (n) => {
    var e, t;
    return (t = (e = _5()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || t === void 0 ? void 0 : t[n];
  },
  tI = (n) => {
    const e = eI(n);
    if (!e) return;
    const t = e.lastIndexOf(':');
    if (t <= 0 || t + 1 === e.length) throw new Error(`Invalid host ${e} with no separate hostname and port!`);
    const r = parseInt(e.substring(t + 1), 10);
    return e[0] === '[' ? [e.substring(1, t - 1), r] : [e.substring(0, t), r];
  },
  nI = () => {
    var n;
    return (n = _5()) === null || n === void 0 ? void 0 : n.config;
  };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rI {
  constructor() {
    (this.reject = () => {}),
      (this.resolve = () => {}),
      (this.promise = new Promise((e, t) => {
        (this.resolve = e), (this.reject = t);
      }));
  }
  /**
   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(e) {
    return (t, r) => {
      t ? this.reject(t) : this.resolve(r), typeof e == 'function' && (this.promise.catch(() => {}), e.length === 1 ? e(t) : e(t, r));
    };
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function iI(n, e) {
  if (n.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  const t = {
      alg: 'none',
      type: 'JWT',
    },
    r = e || 'demo-project',
    i = n.iat || 0,
    s = n.sub || n.user_id;
  if (!s) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  const a = Object.assign(
      {
        // Set all required fields to decent defaults
        iss: `https://securetoken.google.com/${r}`,
        aud: r,
        iat: i,
        exp: i + 3600,
        auth_time: i,
        sub: s,
        user_id: s,
        firebase: {
          sign_in_provider: 'custom',
          identities: {},
        },
      },
      n,
    ),
    o = '';
  return [od(JSON.stringify(t)), od(JSON.stringify(a)), o].join('.');
}
function sI() {
  try {
    return typeof indexedDB == 'object';
  } catch {
    return !1;
  }
}
function aI() {
  return new Promise((n, e) => {
    try {
      let t = !0;
      const r = 'validate-browser-context-for-indexeddb-analytics-module',
        i = self.indexedDB.open(r);
      (i.onsuccess = () => {
        i.result.close(), t || self.indexedDB.deleteDatabase(r), n(!0);
      }),
        (i.onupgradeneeded = () => {
          t = !1;
        }),
        (i.onerror = () => {
          var s;
          e(((s = i.error) === null || s === void 0 ? void 0 : s.message) || '');
        });
    } catch (t) {
      e(t);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const oI = 'FirebaseError';
class No extends Error {
  constructor(e, t, r) {
    super(t), (this.code = e), (this.customData = r), (this.name = oI), Object.setPrototypeOf(this, No.prototype), Error.captureStackTrace && Error.captureStackTrace(this, R5.prototype.create);
  }
}
class R5 {
  constructor(e, t, r) {
    (this.service = e), (this.serviceName = t), (this.errors = r);
  }
  create(e, ...t) {
    const r = t[0] || {},
      i = `${this.service}/${e}`,
      s = this.errors[e],
      a = s ? uI(s, r) : 'Error',
      o = `${this.serviceName}: ${a} (${i}).`;
    return new No(i, o, r);
  }
}
function uI(n, e) {
  return n.replace(lI, (t, r) => {
    const i = e[r];
    return i != null ? String(i) : `<${r}?>`;
  });
}
const lI = /\{\$([^}]+)}/g;
function yh(n, e) {
  if (n === e) return !0;
  const t = Object.keys(n),
    r = Object.keys(e);
  for (const i of t) {
    if (!r.includes(i)) return !1;
    const s = n[i],
      a = e[i];
    if (O2(s) && O2(a)) {
      if (!yh(s, a)) return !1;
    } else if (s !== a) return !1;
  }
  for (const i of r) if (!t.includes(i)) return !1;
  return !0;
}
function O2(n) {
  return n !== null && typeof n == 'object';
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ei(n) {
  return n && n._delegate ? n._delegate : n;
}
class Ku {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(e, t, r) {
    (this.name = e), (this.instanceFactory = t), (this.type = r), (this.multipleInstances = !1), (this.serviceProps = {}), (this.instantiationMode = 'LAZY'), (this.onInstanceCreated = null);
  }
  setInstantiationMode(e) {
    return (this.instantiationMode = e), this;
  }
  setMultipleInstances(e) {
    return (this.multipleInstances = e), this;
  }
  setServiceProps(e) {
    return (this.serviceProps = e), this;
  }
  setInstanceCreatedCallback(e) {
    return (this.onInstanceCreated = e), this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ks = '[DEFAULT]';
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cI {
  constructor(e, t) {
    (this.name = e),
      (this.container = t),
      (this.component = null),
      (this.instances = /* @__PURE__ */ new Map()),
      (this.instancesDeferred = /* @__PURE__ */ new Map()),
      (this.instancesOptions = /* @__PURE__ */ new Map()),
      (this.onInitCallbacks = /* @__PURE__ */ new Map());
  }
  /**
   * @param identifier A provider can provide mulitple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(e) {
    const t = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(t)) {
      const r = new rI();
      if ((this.instancesDeferred.set(t, r), this.isInitialized(t) || this.shouldAutoInitialize()))
        try {
          const i = this.getOrInitializeService({
            instanceIdentifier: t,
          });
          i && r.resolve(i);
        } catch {}
    }
    return this.instancesDeferred.get(t).promise;
  }
  getImmediate(e) {
    var t;
    const r = this.normalizeInstanceIdentifier(e?.identifier),
      i = (t = e?.optional) !== null && t !== void 0 ? t : !1;
    if (this.isInitialized(r) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: r,
        });
      } catch (s) {
        if (i) return null;
        throw s;
      }
    else {
      if (i) return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component) throw Error(`Component for ${this.name} has already been provided`);
    if (((this.component = e), !!this.shouldAutoInitialize())) {
      if (pI(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: Ks });
        } catch {}
      for (const [t, r] of this.instancesDeferred.entries()) {
        const i = this.normalizeInstanceIdentifier(t);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: i,
          });
          r.resolve(s);
        } catch {}
      }
    }
  }
  clearInstance(e = Ks) {
    this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const e = Array.from(this.instances.values());
    await Promise.all([...e.filter((t) => 'INTERNAL' in t).map((t) => t.INTERNAL.delete()), ...e.filter((t) => '_delete' in t).map((t) => t._delete())]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(e = Ks) {
    return this.instances.has(e);
  }
  getOptions(e = Ks) {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    const { options: t = {} } = e,
      r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(r)) throw Error(`${this.name}(${r}) has already been initialized`);
    if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
    const i = this.getOrInitializeService({
      instanceIdentifier: r,
      options: t,
    });
    for (const [s, a] of this.instancesDeferred.entries()) {
      const o = this.normalizeInstanceIdentifier(s);
      r === o && a.resolve(i);
    }
    return i;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(e, t) {
    var r;
    const i = this.normalizeInstanceIdentifier(t),
      s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : /* @__PURE__ */ new Set();
    s.add(e), this.onInitCallbacks.set(i, s);
    const a = this.instances.get(i);
    return (
      a && e(a, i),
      () => {
        s.delete(e);
      }
    );
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(e, t) {
    const r = this.onInitCallbacks.get(t);
    if (r)
      for (const i of r)
        try {
          i(e, t);
        } catch {}
  }
  getOrInitializeService({ instanceIdentifier: e, options: t = {} }) {
    let r = this.instances.get(e);
    if (
      !r &&
      this.component &&
      ((r = this.component.instanceFactory(this.container, {
        instanceIdentifier: dI(e),
        options: t,
      })),
      this.instances.set(e, r),
      this.instancesOptions.set(e, t),
      this.invokeOnInitCallbacks(r, e),
      this.component.onInstanceCreated)
    )
      try {
        this.component.onInstanceCreated(this.container, e, r);
      } catch {}
    return r || null;
  }
  normalizeInstanceIdentifier(e = Ks) {
    return this.component ? (this.component.multipleInstances ? e : Ks) : e;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== 'EXPLICIT';
  }
}
function dI(n) {
  return n === Ks ? void 0 : n;
}
function pI(n) {
  return n.instantiationMode === 'EAGER';
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class fI {
  constructor(e) {
    (this.name = e), (this.providers = /* @__PURE__ */ new Map());
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(e) {
    const t = this.getProvider(e.name);
    if (t.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
    t.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(e) {
    if (this.providers.has(e)) return this.providers.get(e);
    const t = new cI(e, this);
    return this.providers.set(e, t), t;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Ne;
(function (n) {
  (n[(n.DEBUG = 0)] = 'DEBUG'), (n[(n.VERBOSE = 1)] = 'VERBOSE'), (n[(n.INFO = 2)] = 'INFO'), (n[(n.WARN = 3)] = 'WARN'), (n[(n.ERROR = 4)] = 'ERROR'), (n[(n.SILENT = 5)] = 'SILENT');
})(Ne || (Ne = {}));
const hI = {
    debug: Ne.DEBUG,
    verbose: Ne.VERBOSE,
    info: Ne.INFO,
    warn: Ne.WARN,
    error: Ne.ERROR,
    silent: Ne.SILENT,
  },
  yI = Ne.INFO,
  mI = {
    [Ne.DEBUG]: 'log',
    [Ne.VERBOSE]: 'log',
    [Ne.INFO]: 'info',
    [Ne.WARN]: 'warn',
    [Ne.ERROR]: 'error',
  },
  bI = (n, e, ...t) => {
    if (e < n.logLevel) return;
    const r = /* @__PURE__ */ new Date().toISOString(),
      i = mI[e];
    if (i) console[i](`[${r}]  ${n.name}:`, ...t);
    else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
  };
class P5 {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(e) {
    (this.name = e), (this._logLevel = yI), (this._logHandler = bI), (this._userLogHandler = null);
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(e) {
    if (!(e in Ne)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
    this._logLevel = e;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(e) {
    this._logLevel = typeof e == 'string' ? hI[e] : e;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(e) {
    if (typeof e != 'function') throw new TypeError('Value assigned to `logHandler` must be a function');
    this._logHandler = e;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(e) {
    this._userLogHandler = e;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, Ne.DEBUG, ...e), this._logHandler(this, Ne.DEBUG, ...e);
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, Ne.VERBOSE, ...e), this._logHandler(this, Ne.VERBOSE, ...e);
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, Ne.INFO, ...e), this._logHandler(this, Ne.INFO, ...e);
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, Ne.WARN, ...e), this._logHandler(this, Ne.WARN, ...e);
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, Ne.ERROR, ...e), this._logHandler(this, Ne.ERROR, ...e);
  }
}
const gI = (n, e) => e.some((t) => n instanceof t);
let B2, N2;
function vI() {
  return B2 || (B2 = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);
}
function xI() {
  return N2 || (N2 = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);
}
const I5 = /* @__PURE__ */ new WeakMap(),
  mh = /* @__PURE__ */ new WeakMap(),
  k5 = /* @__PURE__ */ new WeakMap(),
  lf = /* @__PURE__ */ new WeakMap(),
  h0 = /* @__PURE__ */ new WeakMap();
function wI(n) {
  const e = new Promise((t, r) => {
    const i = () => {
        n.removeEventListener('success', s), n.removeEventListener('error', a);
      },
      s = () => {
        t(ls(n.result)), i();
      },
      a = () => {
        r(n.error), i();
      };
    n.addEventListener('success', s), n.addEventListener('error', a);
  });
  return (
    e
      .then((t) => {
        t instanceof IDBCursor && I5.set(t, n);
      })
      .catch(() => {}),
    h0.set(e, n),
    e
  );
}
function TI(n) {
  if (mh.has(n)) return;
  const e = new Promise((t, r) => {
    const i = () => {
        n.removeEventListener('complete', s), n.removeEventListener('error', a), n.removeEventListener('abort', a);
      },
      s = () => {
        t(), i();
      },
      a = () => {
        r(n.error || new DOMException('AbortError', 'AbortError')), i();
      };
    n.addEventListener('complete', s), n.addEventListener('error', a), n.addEventListener('abort', a);
  });
  mh.set(n, e);
}
let bh = {
  get(n, e, t) {
    if (n instanceof IDBTransaction) {
      if (e === 'done') return mh.get(n);
      if (e === 'objectStoreNames') return n.objectStoreNames || k5.get(n);
      if (e === 'store') return t.objectStoreNames[1] ? void 0 : t.objectStore(t.objectStoreNames[0]);
    }
    return ls(n[e]);
  },
  set(n, e, t) {
    return (n[e] = t), !0;
  },
  has(n, e) {
    return n instanceof IDBTransaction && (e === 'done' || e === 'store') ? !0 : e in n;
  },
};
function AI(n) {
  bh = n(bh);
}
function EI(n) {
  return n === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)
    ? function (e, ...t) {
        const r = n.call(cf(this), e, ...t);
        return k5.set(r, e.sort ? e.sort() : [e]), ls(r);
      }
    : xI().includes(n)
    ? function (...e) {
        return n.apply(cf(this), e), ls(I5.get(this));
      }
    : function (...e) {
        return ls(n.apply(cf(this), e));
      };
}
function CI(n) {
  return typeof n == 'function' ? EI(n) : (n instanceof IDBTransaction && TI(n), gI(n, vI()) ? new Proxy(n, bh) : n);
}
function ls(n) {
  if (n instanceof IDBRequest) return wI(n);
  if (lf.has(n)) return lf.get(n);
  const e = CI(n);
  return e !== n && (lf.set(n, e), h0.set(e, n)), e;
}
const cf = (n) => h0.get(n);
function SI(n, e, { blocked: t, upgrade: r, blocking: i, terminated: s } = {}) {
  const a = indexedDB.open(n, e),
    o = ls(a);
  return (
    r &&
      a.addEventListener('upgradeneeded', (u) => {
        r(ls(a.result), u.oldVersion, u.newVersion, ls(a.transaction));
      }),
    t && a.addEventListener('blocked', () => t()),
    o
      .then((u) => {
        s && u.addEventListener('close', () => s()), i && u.addEventListener('versionchange', () => i());
      })
      .catch(() => {}),
    o
  );
}
const MI = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'],
  _I = ['put', 'add', 'delete', 'clear'],
  df = /* @__PURE__ */ new Map();
function D2(n, e) {
  if (!(n instanceof IDBDatabase && !(e in n) && typeof e == 'string')) return;
  if (df.get(e)) return df.get(e);
  const t = e.replace(/FromIndex$/, ''),
    r = e !== t,
    i = _I.includes(t);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(t in (r ? IDBIndex : IDBObjectStore).prototype) ||
    !(i || MI.includes(t))
  )
    return;
  const s = async function (a, ...o) {
    const u = this.transaction(a, i ? 'readwrite' : 'readonly');
    let l = u.store;
    return r && (l = l.index(o.shift())), (await Promise.all([l[t](...o), i && u.done]))[0];
  };
  return df.set(e, s), s;
}
AI((n) => ({
  ...n,
  get: (e, t, r) => D2(e, t) || n.get(e, t, r),
  has: (e, t) => !!D2(e, t) || n.has(e, t),
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RI {
  constructor(e) {
    this.container = e;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container
      .getProviders()
      .map((t) => {
        if (PI(t)) {
          const r = t.getImmediate();
          return `${r.library}/${r.version}`;
        } else return null;
      })
      .filter((t) => t)
      .join(' ');
  }
}
function PI(n) {
  const e = n.getComponent();
  return e?.type === 'VERSION';
}
const gh = '@firebase/app',
  F2 = '0.9.8';
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const da = new P5('@firebase/app'),
  II = '@firebase/app-compat',
  kI = '@firebase/analytics-compat',
  OI = '@firebase/analytics',
  BI = '@firebase/app-check-compat',
  NI = '@firebase/app-check',
  DI = '@firebase/auth',
  FI = '@firebase/auth-compat',
  LI = '@firebase/database',
  $I = '@firebase/database-compat',
  UI = '@firebase/functions',
  jI = '@firebase/functions-compat',
  VI = '@firebase/installations',
  zI = '@firebase/installations-compat',
  GI = '@firebase/messaging',
  HI = '@firebase/messaging-compat',
  KI = '@firebase/performance',
  qI = '@firebase/performance-compat',
  WI = '@firebase/remote-config',
  JI = '@firebase/remote-config-compat',
  QI = '@firebase/storage',
  YI = '@firebase/storage-compat',
  XI = '@firebase/firestore',
  ZI = '@firebase/firestore-compat',
  ek = 'firebase',
  tk = '9.20.0';
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const vh = '[DEFAULT]',
  nk = {
    [gh]: 'fire-core',
    [II]: 'fire-core-compat',
    [OI]: 'fire-analytics',
    [kI]: 'fire-analytics-compat',
    [NI]: 'fire-app-check',
    [BI]: 'fire-app-check-compat',
    [DI]: 'fire-auth',
    [FI]: 'fire-auth-compat',
    [LI]: 'fire-rtdb',
    [$I]: 'fire-rtdb-compat',
    [UI]: 'fire-fn',
    [jI]: 'fire-fn-compat',
    [VI]: 'fire-iid',
    [zI]: 'fire-iid-compat',
    [GI]: 'fire-fcm',
    [HI]: 'fire-fcm-compat',
    [KI]: 'fire-perf',
    [qI]: 'fire-perf-compat',
    [WI]: 'fire-rc',
    [JI]: 'fire-rc-compat',
    [QI]: 'fire-gcs',
    [YI]: 'fire-gcs-compat',
    [XI]: 'fire-fst',
    [ZI]: 'fire-fst-compat',
    'fire-js': 'fire-js',
    [ek]: 'fire-js-all',
  };
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ud = /* @__PURE__ */ new Map(),
  xh = /* @__PURE__ */ new Map();
function rk(n, e) {
  try {
    n.container.addComponent(e);
  } catch (t) {
    da.debug(`Component ${e.name} failed to register with FirebaseApp ${n.name}`, t);
  }
}
function ld(n) {
  const e = n.name;
  if (xh.has(e)) return da.debug(`There were multiple attempts to register component ${e}.`), !1;
  xh.set(e, n);
  for (const t of ud.values()) rk(t, n);
  return !0;
}
function ik(n, e) {
  const t = n.container.getProvider('heartbeat').getImmediate({ optional: !0 });
  return t && t.triggerHeartbeat(), n.container.getProvider(e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sk = {
    ['no-app']:
      /* AppError.NO_APP */
      "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
    ['bad-app-name']:
      /* AppError.BAD_APP_NAME */
      "Illegal App name: '{$appName}",
    ['duplicate-app']:
      /* AppError.DUPLICATE_APP */
      "Firebase App named '{$appName}' already exists with different options or config",
    ['app-deleted']:
      /* AppError.APP_DELETED */
      "Firebase App named '{$appName}' already deleted",
    ['no-options']:
      /* AppError.NO_OPTIONS */
      'Need to provide options, when not being deployed to hosting via source.',
    ['invalid-app-argument']:
      /* AppError.INVALID_APP_ARGUMENT */
      'firebase.{$appName}() takes either no argument or a Firebase App instance.',
    ['invalid-log-argument']:
      /* AppError.INVALID_LOG_ARGUMENT */
      'First argument to `onLog` must be null or a function.',
    ['idb-open']:
      /* AppError.IDB_OPEN */
      'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',
    ['idb-get']:
      /* AppError.IDB_GET */
      'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',
    ['idb-set']:
      /* AppError.IDB_WRITE */
      'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',
    ['idb-delete']:
      /* AppError.IDB_DELETE */
      'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',
  },
  cs = new R5('app', 'Firebase', sk);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ak {
  constructor(e, t, r) {
    (this._isDeleted = !1),
      (this._options = Object.assign({}, e)),
      (this._config = Object.assign({}, t)),
      (this._name = t.name),
      (this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled),
      (this._container = r),
      this.container.addComponent(
        new Ku(
          'app',
          () => this,
          'PUBLIC',
          /* ComponentType.PUBLIC */
        ),
      );
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), (this._automaticDataCollectionEnabled = e);
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted) throw cs.create('app-deleted', { appName: this._name });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ok = tk;
function O5(n, e = {}) {
  let t = n;
  typeof e != 'object' && (e = { name: e });
  const r = Object.assign({ name: vh, automaticDataCollectionEnabled: !1 }, e),
    i = r.name;
  if (typeof i != 'string' || !i)
    throw cs.create('bad-app-name', {
      appName: String(i),
    });
  if ((t || (t = nI()), !t))
    throw cs.create(
      'no-options',
      /* AppError.NO_OPTIONS */
    );
  const s = ud.get(i);
  if (s) {
    if (yh(t, s.options) && yh(r, s.config)) return s;
    throw cs.create('duplicate-app', { appName: i });
  }
  const a = new fI(i);
  for (const u of xh.values()) a.addComponent(u);
  const o = new ak(t, r, a);
  return ud.set(i, o), o;
}
function uk(n = vh) {
  const e = ud.get(n);
  if (!e && n === vh) return O5();
  if (!e) throw cs.create('no-app', { appName: n });
  return e;
}
function to(n, e, t) {
  var r;
  let i = (r = nk[n]) !== null && r !== void 0 ? r : n;
  t && (i += `-${t}`);
  const s = i.match(/\s|\//),
    a = e.match(/\s|\//);
  if (s || a) {
    const o = [`Unable to register library "${i}" with version "${e}":`];
    s && o.push(`library name "${i}" contains illegal characters (whitespace or "/")`),
      s && a && o.push('and'),
      a && o.push(`version name "${e}" contains illegal characters (whitespace or "/")`),
      da.warn(o.join(' '));
    return;
  }
  ld(
    new Ku(
      `${i}-version`,
      () => ({ library: i, version: e }),
      'VERSION',
      /* ComponentType.VERSION */
    ),
  );
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const lk = 'firebase-heartbeat-database',
  ck = 1,
  qu = 'firebase-heartbeat-store';
let pf = null;
function B5() {
  return (
    pf ||
      (pf = SI(lk, ck, {
        upgrade: (n, e) => {
          switch (e) {
            case 0:
              n.createObjectStore(qu);
          }
        },
      }).catch((n) => {
        throw cs.create('idb-open', {
          originalErrorMessage: n.message,
        });
      })),
    pf
  );
}
async function dk(n) {
  try {
    return (await B5()).transaction(qu).objectStore(qu).get(N5(n));
  } catch (e) {
    if (e instanceof No) da.warn(e.message);
    else {
      const t = cs.create('idb-get', {
        originalErrorMessage: e?.message,
      });
      da.warn(t.message);
    }
  }
}
async function L2(n, e) {
  try {
    const r = (await B5()).transaction(qu, 'readwrite');
    return await r.objectStore(qu).put(e, N5(n)), r.done;
  } catch (t) {
    if (t instanceof No) da.warn(t.message);
    else {
      const r = cs.create('idb-set', {
        originalErrorMessage: t?.message,
      });
      da.warn(r.message);
    }
  }
}
function N5(n) {
  return `${n.name}!${n.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pk = 1024,
  fk = 30 * 24 * 60 * 60 * 1e3;
class hk {
  constructor(e) {
    (this.container = e), (this._heartbeatsCache = null);
    const t = this.container.getProvider('app').getImmediate();
    (this._storage = new mk(t)), (this._heartbeatsCachePromise = this._storage.read().then((r) => ((this._heartbeatsCache = r), r)));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    const t = this.container.getProvider('platform-logger').getImmediate().getPlatformInfoString(),
      r = $2();
    if (
      (this._heartbeatsCache === null && (this._heartbeatsCache = await this._heartbeatsCachePromise),
      !(this._heartbeatsCache.lastSentHeartbeatDate === r || this._heartbeatsCache.heartbeats.some((i) => i.date === r)))
    )
      return (
        this._heartbeatsCache.heartbeats.push({ date: r, agent: t }),
        (this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((i) => {
          const s = new Date(i.date).valueOf();
          return Date.now() - s <= fk;
        })),
        this._storage.overwrite(this._heartbeatsCache)
      );
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    if ((this._heartbeatsCache === null && (await this._heartbeatsCachePromise), this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0)) return '';
    const e = $2(),
      { heartbeatsToSend: t, unsentEntries: r } = yk(this._heartbeatsCache.heartbeats),
      i = od(JSON.stringify({ version: 2, heartbeats: t }));
    return (
      (this._heartbeatsCache.lastSentHeartbeatDate = e),
      r.length > 0
        ? ((this._heartbeatsCache.heartbeats = r), await this._storage.overwrite(this._heartbeatsCache))
        : ((this._heartbeatsCache.heartbeats = []), this._storage.overwrite(this._heartbeatsCache)),
      i
    );
  }
}
function $2() {
  return /* @__PURE__ */ new Date().toISOString().substring(0, 10);
}
function yk(n, e = pk) {
  const t = [];
  let r = n.slice();
  for (const i of n) {
    const s = t.find((a) => a.agent === i.agent);
    if (s) {
      if ((s.dates.push(i.date), U2(t) > e)) {
        s.dates.pop();
        break;
      }
    } else if (
      (t.push({
        agent: i.agent,
        dates: [i.date],
      }),
      U2(t) > e)
    ) {
      t.pop();
      break;
    }
    r = r.slice(1);
  }
  return {
    heartbeatsToSend: t,
    unsentEntries: r,
  };
}
class mk {
  constructor(e) {
    (this.app = e), (this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck());
  }
  async runIndexedDBEnvironmentCheck() {
    return sI()
      ? aI()
          .then(() => !0)
          .catch(() => !1)
      : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    return (await this._canUseIndexedDBPromise) ? (await dk(this.app)) || { heartbeats: [] } : { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return L2(this.app, {
        lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : i.lastSentHeartbeatDate,
        heartbeats: e.heartbeats,
      });
    } else return;
  }
  // add heartbeats
  async add(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return L2(this.app, {
        lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : i.lastSentHeartbeatDate,
        heartbeats: [...i.heartbeats, ...e.heartbeats],
      });
    } else return;
  }
}
function U2(n) {
  return od(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: n }),
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function bk(n) {
  ld(
    new Ku(
      'platform-logger',
      (e) => new RI(e),
      'PRIVATE',
      /* ComponentType.PRIVATE */
    ),
  ),
    ld(
      new Ku(
        'heartbeat',
        (e) => new hk(e),
        'PRIVATE',
        /* ComponentType.PRIVATE */
      ),
    ),
    to(gh, F2, n),
    to(gh, F2, 'esm2017'),
    to('fire-js', '');
}
bk('');
var gk = 'firebase',
  vk = '9.20.0';
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
to(gk, vk, 'app');
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pn {
  constructor(e) {
    this.uid = e;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    return this.isAuthenticated() ? 'uid:' + this.uid : 'anonymous-user';
  }
  isEqual(e) {
    return e.uid === this.uid;
  }
}
(Pn.UNAUTHENTICATED = new Pn(null)), // TODO(mikelehen): Look into getting a proper uid-equivalent for
  // non-FirebaseAuth providers.
  (Pn.GOOGLE_CREDENTIALS = new Pn('google-credentials-uid')),
  (Pn.FIRST_PARTY = new Pn('first-party-uid')),
  (Pn.MOCK_USER = new Pn('mock-user'));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Do = '9.20.0';
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mo = new P5('@firebase/firestore');
function cd(n, ...e) {
  if (mo.logLevel <= Ne.DEBUG) {
    const t = e.map(m0);
    mo.debug(`Firestore (${Do}): ${n}`, ...t);
  }
}
function y0(n, ...e) {
  if (mo.logLevel <= Ne.ERROR) {
    const t = e.map(m0);
    mo.error(`Firestore (${Do}): ${n}`, ...t);
  }
}
function D5(n, ...e) {
  if (mo.logLevel <= Ne.WARN) {
    const t = e.map(m0);
    mo.warn(`Firestore (${Do}): ${n}`, ...t);
  }
}
function m0(n) {
  if (typeof n == 'string') return n;
  try {
    return (e = n), JSON.stringify(e);
  } catch {
    return n;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var e;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Rt(n = 'Unexpected state') {
  const e = `FIRESTORE (${Do}) INTERNAL ASSERTION FAILED: ` + n;
  throw (y0(e), new Error(e));
}
function bs(n, e) {
  n || Rt();
}
function Wd(n, e) {
  return n;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const j2 = 'ok',
  xk = 'cancelled',
  mu = 'unknown',
  le = 'invalid-argument',
  wk = 'deadline-exceeded',
  Tk = 'not-found',
  Ak = 'permission-denied',
  wh = 'unauthenticated',
  Ek = 'resource-exhausted',
  pa = 'failed-precondition',
  Ck = 'aborted',
  Sk = 'out-of-range',
  F5 = 'unimplemented',
  Mk = 'internal',
  _k = 'unavailable';
class se extends No {
  /** @hideconstructor */
  constructor(e, t) {
    super(e, t),
      (this.code = e),
      (this.message = t), // HACK: We write a toString property directly because Error is not a real
      // class and so inheritance does not work correctly. We could alternatively
      // do the same "back-door inheritance" trick that FirebaseError does.
      (this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class L5 {
  constructor(e, t) {
    (this.user = t), (this.type = 'OAuth'), (this.headers = /* @__PURE__ */ new Map()), this.headers.set('Authorization', `Bearer ${e}`);
  }
}
class Rk {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {}
  start(e, t) {
    e.enqueueRetryable(() => t(Pn.UNAUTHENTICATED));
  }
  shutdown() {}
}
class Pk {
  constructor(e) {
    (this.token = e),
      /**
       * Stores the listener registered with setChangeListener()
       * This isn't actually necessary since the UID never changes, but we use this
       * to verify the listen contract is adhered to in tests.
       */ (this.changeListener = null);
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {}
  start(e, t) {
    (this.changeListener = t), // Fire with initial user.
      e.enqueueRetryable(() => t(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class Ik {
  constructor(e) {
    (this.auth = null),
      e.onInit((t) => {
        this.auth = t;
      });
  }
  getToken() {
    return this.auth ? this.auth.getToken().then((e) => (e ? (bs(typeof e.accessToken == 'string'), new L5(e.accessToken, new Pn(this.auth.getUid()))) : null)) : Promise.resolve(null);
  }
  invalidateToken() {}
  start(e, t) {}
  shutdown() {}
}
class kk {
  constructor(e, t, r) {
    (this.t = e), (this.i = t), (this.o = r), (this.type = 'FirstParty'), (this.user = Pn.FIRST_PARTY), (this.u = /* @__PURE__ */ new Map());
  }
  /**
   * Gets an authorization token, using a provided factory function, or return
   * null.
   */
  h() {
    return this.o ? this.o() : null;
  }
  get headers() {
    this.u.set('X-Goog-AuthUser', this.t);
    const e = this.h();
    return e && this.u.set('Authorization', e), this.i && this.u.set('X-Goog-Iam-Authorization-Token', this.i), this.u;
  }
}
class Ok {
  constructor(e, t, r) {
    (this.t = e), (this.i = t), (this.o = r);
  }
  getToken() {
    return Promise.resolve(new kk(this.t, this.i, this.o));
  }
  start(e, t) {
    e.enqueueRetryable(() => t(Pn.FIRST_PARTY));
  }
  shutdown() {}
  invalidateToken() {}
}
class Bk {
  constructor(e) {
    (this.value = e), (this.type = 'AppCheck'), (this.headers = /* @__PURE__ */ new Map()), e && e.length > 0 && this.headers.set('x-firebase-appcheck', this.value);
  }
}
class Nk {
  constructor(e) {
    (this.l = e),
      (this.appCheck = null),
      e.onInit((t) => {
        this.appCheck = t;
      });
  }
  getToken() {
    return this.appCheck ? this.appCheck.getToken().then((e) => (e ? (bs(typeof e.token == 'string'), new Bk(e.token)) : null)) : Promise.resolve(null);
  }
  invalidateToken() {}
  start(e, t) {}
  shutdown() {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dk {
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(e, t, r, i, s, a, o, u) {
    (this.databaseId = e), (this.appId = t), (this.persistenceKey = r), (this.host = i), (this.ssl = s), (this.forceLongPolling = a), (this.autoDetectLongPolling = o), (this.useFetchStreams = u);
  }
}
class Wu {
  constructor(e, t) {
    (this.projectId = e), (this.database = t || '(default)');
  }
  static empty() {
    return new Wu('', '');
  }
  get isDefaultDatabase() {
    return this.database === '(default)';
  }
  isEqual(e) {
    return e instanceof Wu && e.projectId === this.projectId && e.database === this.database;
  }
}
class Ju {
  constructor(e, t, r) {
    t === void 0 ? (t = 0) : t > e.length && Rt(), r === void 0 ? (r = e.length - t) : r > e.length - t && Rt(), (this.segments = e), (this.offset = t), (this.len = r);
  }
  get length() {
    return this.len;
  }
  isEqual(e) {
    return Ju.comparator(this, e) === 0;
  }
  child(e) {
    const t = this.segments.slice(this.offset, this.limit());
    return (
      e instanceof Ju
        ? e.forEach((r) => {
            t.push(r);
          })
        : t.push(e),
      this.construct(t)
    );
  }
  /** The index of one past the last segment of the path. */
  limit() {
    return this.offset + this.length;
  }
  popFirst(e) {
    return (e = e === void 0 ? 1 : e), this.construct(this.segments, this.offset + e, this.length - e);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(e) {
    return this.segments[this.offset + e];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(e) {
    if (e.length < this.length) return !1;
    for (let t = 0; t < this.length; t++) if (this.get(t) !== e.get(t)) return !1;
    return !0;
  }
  isImmediateParentOf(e) {
    if (this.length + 1 !== e.length) return !1;
    for (let t = 0; t < this.length; t++) if (this.get(t) !== e.get(t)) return !1;
    return !0;
  }
  forEach(e) {
    for (let t = this.offset, r = this.limit(); t < r; t++) e(this.segments[t]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(e, t) {
    const r = Math.min(e.length, t.length);
    for (let i = 0; i < r; i++) {
      const s = e.get(i),
        a = t.get(i);
      if (s < a) return -1;
      if (s > a) return 1;
    }
    return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
  }
}
class Gt extends Ju {
  construct(e, t, r) {
    return new Gt(e, t, r);
  }
  canonicalString() {
    return this.toArray().join('/');
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Creates a resource path from the given slash-delimited string. If multiple
   * arguments are provided, all components are combined. Leading and trailing
   * slashes from all components are ignored.
   */
  static fromString(...e) {
    const t = [];
    for (const r of e) {
      if (r.indexOf('//') >= 0) throw new se(le, `Invalid segment (${r}). Paths must not contain // in them.`);
      t.push(...r.split('/').filter((i) => i.length > 0));
    }
    return new Gt(t);
  }
  static emptyPath() {
    return new Gt([]);
  }
}
const Fk = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class Kn extends Ju {
  construct(e, t, r) {
    return new Kn(e, t, r);
  }
  /**
   * Returns true if the string could be used as a segment in a field path
   * without escaping.
   */
  static isValidIdentifier(e) {
    return Fk.test(e);
  }
  canonicalString() {
    return this.toArray()
      .map((e) => ((e = e.replace(/\\/g, '\\\\').replace(/`/g, '\\`')), Kn.isValidIdentifier(e) || (e = '`' + e + '`'), e))
      .join('.');
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns true if this field references the key of a document.
   */
  isKeyField() {
    return this.length === 1 && this.get(0) === '__name__';
  }
  /**
   * The field designating the key of a document.
   */
  static keyField() {
    return new Kn(['__name__']);
  }
  /**
   * Parses a field string from the given server-formatted string.
   *
   * - Splitting the empty string is not allowed (for now at least).
   * - Empty segments within the string (e.g. if there are two consecutive
   *   separators) are not allowed.
   *
   * TODO(b/37244157): we should make this more strict. Right now, it allows
   * non-identifier path components, even if they aren't escaped.
   */
  static fromServerFormat(e) {
    const t = [];
    let r = '',
      i = 0;
    const s = () => {
      if (r.length === 0) throw new se(le, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      t.push(r), (r = '');
    };
    let a = !1;
    for (; i < e.length; ) {
      const o = e[i];
      if (o === '\\') {
        if (i + 1 === e.length) throw new se(le, 'Path has trailing escape character: ' + e);
        const u = e[i + 1];
        if (u !== '\\' && u !== '.' && u !== '`') throw new se(le, 'Path has invalid escape sequence: ' + e);
        (r += u), (i += 2);
      } else o === '`' ? ((a = !a), i++) : o !== '.' || a ? ((r += o), i++) : (s(), i++);
    }
    if ((s(), a)) throw new se(le, 'Unterminated ` in path: ' + e);
    return new Kn(t);
  }
  static emptyPath() {
    return new Kn([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class rn {
  constructor(e) {
    this.path = e;
  }
  static fromPath(e) {
    return new rn(Gt.fromString(e));
  }
  static fromName(e) {
    return new rn(Gt.fromString(e).popFirst(5));
  }
  static empty() {
    return new rn(Gt.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  /** Returns true if the document is in the specified collectionId. */
  hasCollectionId(e) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === e;
  }
  /** Returns the collection group (i.e. the name of the parent collection) for this key. */
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  /** Returns the fully qualified path to the parent collection. */
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(e) {
    return e !== null && Gt.comparator(this.path, e.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(e, t) {
    return Gt.comparator(e.path, t.path);
  }
  static isDocumentKey(e) {
    return e.length % 2 == 0;
  }
  /**
   * Creates and returns a new document key with the given segments.
   *
   * @param segments - The segments of the path to the document
   * @returns A new instance of DocumentKey
   */
  static fromSegments(e) {
    return new rn(new Gt(e.slice()));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $5(n, e, t) {
  if (!t) throw new se(le, `Function ${n}() cannot be called with an empty ${e}.`);
}
function V2(n) {
  if (!rn.isDocumentKey(n)) throw new se(le, `Invalid document reference. Document references must have an even number of segments, but ${n} has ${n.length}.`);
}
function z2(n) {
  if (rn.isDocumentKey(n)) throw new se(le, `Invalid collection reference. Collection references must have an odd number of segments, but ${n} has ${n.length}.`);
}
function Jd(n) {
  if (n === void 0) return 'undefined';
  if (n === null) return 'null';
  if (typeof n == 'string') return n.length > 20 && (n = `${n.substring(0, 20)}...`), JSON.stringify(n);
  if (typeof n == 'number' || typeof n == 'boolean') return '' + n;
  if (typeof n == 'object') {
    if (n instanceof Array) return 'an array';
    {
      const e =
        /** try to get the constructor name for an object. */
        (function (t) {
          return t.constructor ? t.constructor.name : null;
        })(n);
      return e ? `a custom ${e} object` : 'an object';
    }
  }
  return typeof n == 'function' ? 'a function' : Rt();
}
function Al(n, e) {
  if (
    ('_delegate' in n && // Unwrap Compat types
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (n = n._delegate),
    !(n instanceof e))
  ) {
    if (e.name === n.constructor.name) throw new se(le, 'Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?');
    {
      const t = Jd(n);
      throw new se(le, `Expected type '${e.name}', but it was: ${t}`);
    }
  }
  return n;
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Ql = null;
function Lk() {
  return Ql === null ? (Ql = 268435456 + Math.round(2147483648 * Math.random())) : Ql++, '0x' + Ql.toString(16);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $k(n) {
  return n == null;
}
function dd(n) {
  return n === 0 && 1 / n == -1 / 0;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Uk = {
  BatchGetDocuments: 'batchGet',
  Commit: 'commit',
  RunQuery: 'runQuery',
  RunAggregationQuery: 'runAggregationQuery',
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var G2, Te;
function H2(n) {
  if (n === void 0) return y0('RPC_ERROR', 'HTTP error has no status'), mu;
  switch (n) {
    case 200:
      return j2;
    case 400:
      return pa;
    case 401:
      return wh;
    case 403:
      return Ak;
    case 404:
      return Tk;
    case 409:
      return Ck;
    case 416:
      return Sk;
    case 429:
      return Ek;
    case 499:
      return xk;
    case 500:
      return mu;
    case 501:
      return F5;
    case 503:
      return _k;
    case 504:
      return wk;
    default:
      return n >= 200 && n < 300 ? j2 : n >= 400 && n < 500 ? pa : n >= 500 && n < 600 ? Mk : mu;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
((Te = G2 || (G2 = {}))[(Te.OK = 0)] = 'OK'),
  (Te[(Te.CANCELLED = 1)] = 'CANCELLED'),
  (Te[(Te.UNKNOWN = 2)] = 'UNKNOWN'),
  (Te[(Te.INVALID_ARGUMENT = 3)] = 'INVALID_ARGUMENT'),
  (Te[(Te.DEADLINE_EXCEEDED = 4)] = 'DEADLINE_EXCEEDED'),
  (Te[(Te.NOT_FOUND = 5)] = 'NOT_FOUND'),
  (Te[(Te.ALREADY_EXISTS = 6)] = 'ALREADY_EXISTS'),
  (Te[(Te.PERMISSION_DENIED = 7)] = 'PERMISSION_DENIED'),
  (Te[(Te.UNAUTHENTICATED = 16)] = 'UNAUTHENTICATED'),
  (Te[(Te.RESOURCE_EXHAUSTED = 8)] = 'RESOURCE_EXHAUSTED'),
  (Te[(Te.FAILED_PRECONDITION = 9)] = 'FAILED_PRECONDITION'),
  (Te[(Te.ABORTED = 10)] = 'ABORTED'),
  (Te[(Te.OUT_OF_RANGE = 11)] = 'OUT_OF_RANGE'),
  (Te[(Te.UNIMPLEMENTED = 12)] = 'UNIMPLEMENTED'),
  (Te[(Te.INTERNAL = 13)] = 'INTERNAL'),
  (Te[(Te.UNAVAILABLE = 14)] = 'UNAVAILABLE'),
  (Te[(Te.DATA_LOSS = 15)] = 'DATA_LOSS');
class jk
  /**
   * Base class for all Rest-based connections to the backend (WebChannel and
   * HTTP).
   */
  extends class {
    constructor(e) {
      (this.databaseInfo = e), (this.databaseId = e.databaseId);
      const t = e.ssl ? 'https' : 'http';
      (this.m = t + '://' + e.host), (this.p = 'projects/' + this.databaseId.projectId + '/databases/' + this.databaseId.database + '/documents');
    }
    get g() {
      return !1;
    }
    v(e, t, r, i, s) {
      const a = Lk(),
        o = this.A(e, t);
      cd('RestConnection', `Sending RPC '${e}' ${a}:`, o, r);
      const u = {};
      return (
        this.I(u, i, s),
        this.T(e, o, u, r).then(
          (l) => (cd('RestConnection', `Received RPC '${e}' ${a}: `, l), l),
          (l) => {
            throw (D5('RestConnection', `RPC '${e}' ${a} failed with error: `, l, 'url: ', o, 'request:', r), l);
          },
        )
      );
    }
    R(e, t, r, i, s, a) {
      return this.v(e, t, r, i, s);
    }
    /**
     * Modifies the headers for a request, adding any authorization token if
     * present and any additional headers for the request.
     */
    I(e, t, r) {
      (e['X-Goog-Api-Client'] = 'gl-js/ fire/' + Do), // Content-Type: text/plain will avoid preflight requests which might
        // mess with CORS and redirects by proxies. If we add custom headers
        // we will need to change this code to potentially use the $httpOverwrite
        // parameter supported by ESF to avoid triggering preflight requests.
        (e['Content-Type'] = 'text/plain'),
        this.databaseInfo.appId && (e['X-Firebase-GMPID'] = this.databaseInfo.appId),
        t && t.headers.forEach((i, s) => (e[s] = i)),
        r && r.headers.forEach((i, s) => (e[s] = i));
    }
    A(e, t) {
      const r = Uk[e];
      return `${this.m}/v1/${t}:${r}`;
    }
  }
{
  /**
   * @param databaseInfo - The connection info.
   * @param fetchImpl - `fetch` or a Polyfill that implements the fetch API.
   */
  constructor(e, t) {
    super(e), (this.P = t);
  }
  V(e, t) {
    throw new Error('Not supported by FetchConnection');
  }
  async T(e, t, r, i) {
    var s;
    const a = JSON.stringify(i);
    let o;
    try {
      o = await this.P(t, {
        method: 'POST',
        headers: r,
        body: a,
      });
    } catch (u) {
      const l = u;
      throw new se(H2(l.status), 'Request failed with error: ' + l.statusText);
    }
    if (!o.ok) {
      let u = await o.json();
      Array.isArray(u) && (u = u[0]);
      const l = (s = u?.error) === null || s === void 0 ? void 0 : s.message;
      throw new se(H2(o.status), `Request failed with error: ${l ?? o.statusText}`);
    }
    return o.json();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Vk(n) {
  const e =
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      typeof self < 'u' && (self.crypto || self.msCrypto),
    t = new Uint8Array(n);
  if (e && typeof e.getRandomValues == 'function') e.getRandomValues(t);
  else for (let r = 0; r < n; r++) t[r] = Math.floor(256 * Math.random());
  return t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zk {
  static N() {
    const e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
      t = Math.floor(256 / e.length) * e.length;
    let r = '';
    for (; r.length < 20; ) {
      const i = Vk(40);
      for (let s = 0; s < i.length; ++s) r.length < 20 && i[s] < t && (r += e.charAt(i[s] % e.length));
    }
    return r;
  }
}
function qt(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
function U5(n, e, t) {
  return n.length === e.length && n.every((r, i) => t(r, e[i]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function K2(n) {
  let e = 0;
  for (const t in n) Object.prototype.hasOwnProperty.call(n, t) && e++;
  return e;
}
function El(n, e) {
  for (const t in n) Object.prototype.hasOwnProperty.call(n, t) && e(t, n[t]);
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Gk extends Error {
  constructor() {
    super(...arguments), (this.name = 'Base64DecodeError');
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ii {
  constructor(e) {
    this.binaryString = e;
  }
  static fromBase64String(e) {
    const t = (function (r) {
      try {
        return atob(r);
      } catch (i) {
        throw typeof DOMException < 'u' && i instanceof DOMException ? new Gk('Invalid base64 string: ' + i) : i;
      }
    })(e);
    return new Ii(t);
  }
  static fromUint8Array(e) {
    const t =
      /**
       * Helper function to convert an Uint8array to a binary string.
       */
      (function (r) {
        let i = '';
        for (let s = 0; s < r.length; ++s) i += String.fromCharCode(r[s]);
        return i;
      })(e);
    return new Ii(t);
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () =>
        e < this.binaryString.length
          ? {
              value: this.binaryString.charCodeAt(e++),
              done: !1,
            }
          : {
              value: void 0,
              done: !0,
            },
    };
  }
  toBase64() {
    return (e = this.binaryString), btoa(e);
    var e;
  }
  toUint8Array() {
    return (function (e) {
      const t = new Uint8Array(e.length);
      for (let r = 0; r < e.length; r++) t[r] = e.charCodeAt(r);
      return t;
    })(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(e) {
    return qt(this.binaryString, e.binaryString);
  }
  isEqual(e) {
    return this.binaryString === e.binaryString;
  }
}
Ii.EMPTY_BYTE_STRING = new Ii('');
const Hk = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function fa(n) {
  if ((bs(!!n), typeof n == 'string')) {
    let e = 0;
    const t = Hk.exec(n);
    if ((bs(!!t), t[1])) {
      let i = t[1];
      (i = (i + '000000000').substr(0, 9)), (e = Number(i));
    }
    const r = new Date(n);
    return {
      seconds: Math.floor(r.getTime() / 1e3),
      nanos: e,
    };
  }
  return {
    seconds: Vt(n.seconds),
    nanos: Vt(n.nanos),
  };
}
function Vt(n) {
  return typeof n == 'number' ? n : typeof n == 'string' ? Number(n) : 0;
}
function Qu(n) {
  return typeof n == 'string' ? Ii.fromBase64String(n) : Ii.fromUint8Array(n);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bn {
  /**
   * Creates a new timestamp.
   *
   * @param seconds - The number of seconds of UTC time since Unix epoch
   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   *     9999-12-31T23:59:59Z inclusive.
   * @param nanoseconds - The non-negative fractions of a second at nanosecond
   *     resolution. Negative second values with fractions must still have
   *     non-negative nanoseconds values that count forward in time. Must be
   *     from 0 to 999,999,999 inclusive.
   */
  constructor(e, t) {
    if (((this.seconds = e), (this.nanoseconds = t), t < 0)) throw new se(le, 'Timestamp nanoseconds out of range: ' + t);
    if (t >= 1e9) throw new se(le, 'Timestamp nanoseconds out of range: ' + t);
    if (e < -62135596800) throw new se(le, 'Timestamp seconds out of range: ' + e);
    if (e >= 253402300800) throw new se(le, 'Timestamp seconds out of range: ' + e);
  }
  /**
   * Creates a new timestamp with the current date, with millisecond precision.
   *
   * @returns a new timestamp representing the current date.
   */
  static now() {
    return Bn.fromMillis(Date.now());
  }
  /**
   * Creates a new timestamp from the given date.
   *
   * @param date - The date to initialize the `Timestamp` from.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     date.
   */
  static fromDate(e) {
    return Bn.fromMillis(e.getTime());
  }
  /**
   * Creates a new timestamp from the given number of milliseconds.
   *
   * @param milliseconds - Number of milliseconds since Unix epoch
   *     1970-01-01T00:00:00Z.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     number of milliseconds.
   */
  static fromMillis(e) {
    const t = Math.floor(e / 1e3),
      r = Math.floor(1e6 * (e - 1e3 * t));
    return new Bn(t, r);
  }
  /**
   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
   * causes a loss of precision since `Date` objects only support millisecond
   * precision.
   *
   * @returns JavaScript `Date` object representing the same point in time as
   *     this `Timestamp`, with millisecond precision.
   */
  toDate() {
    return new Date(this.toMillis());
  }
  /**
   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
   * epoch). This operation causes a loss of precision.
   *
   * @returns The point in time corresponding to this timestamp, represented as
   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
   */
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(e) {
    return this.seconds === e.seconds ? qt(this.nanoseconds, e.nanoseconds) : qt(this.seconds, e.seconds);
  }
  /**
   * Returns true if this `Timestamp` is equal to the provided one.
   *
   * @param other - The `Timestamp` to compare against.
   * @returns true if this `Timestamp` is equal to the provided one.
   */
  isEqual(e) {
    return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
  }
  /** Returns a textual representation of this `Timestamp`. */
  toString() {
    return 'Timestamp(seconds=' + this.seconds + ', nanoseconds=' + this.nanoseconds + ')';
  }
  /** Returns a JSON-serializable representation of this `Timestamp`. */
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds,
    };
  }
  /**
   * Converts this object to a primitive string, which allows `Timestamp` objects
   * to be compared using the `>`, `<=`, `>=` and `>` operators.
   */
  valueOf() {
    const e = this.seconds - -62135596800;
    return String(e).padStart(12, '0') + '.' + String(this.nanoseconds).padStart(9, '0');
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function j5(n) {
  var e, t;
  return ((t = (((e = n?.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || t === void 0 ? void 0 : t.stringValue) === 'server_timestamp';
}
function V5(n) {
  const e = n.mapValue.fields.__previous_value__;
  return j5(e) ? V5(e) : e;
}
function Yu(n) {
  const e = fa(n.mapValue.fields.__local_write_time__.timestampValue);
  return new Bn(e.seconds, e.nanos);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yl = {
  fields: {
    __type__: {
      stringValue: '__max__',
    },
  },
};
function ha(n) {
  return 'nullValue' in n
    ? 0
    : 'booleanValue' in n
    ? 1
    : 'integerValue' in n || 'doubleValue' in n
    ? 2
    : 'timestampValue' in n
    ? 3
    : 'stringValue' in n
    ? 5
    : 'bytesValue' in n
    ? 6
    : 'referenceValue' in n
    ? 7
    : 'geoPointValue' in n
    ? 8
    : 'arrayValue' in n
    ? 9
    : 'mapValue' in n
    ? j5(n)
      ? 4
      : /** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */
      (function (e) {
          return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === '__max__';
        })(n)
      ? 9007199254740991
      : 10
    : Rt();
}
function pd(n, e) {
  if (n === e) return !0;
  const t = ha(n);
  if (t !== ha(e)) return !1;
  switch (t) {
    case 0:
    case 9007199254740991:
      return !0;
    case 1:
      return n.booleanValue === e.booleanValue;
    case 4:
      return Yu(n).isEqual(Yu(e));
    case 3:
      return (function (r, i) {
        if (typeof r.timestampValue == 'string' && typeof i.timestampValue == 'string' && r.timestampValue.length === i.timestampValue.length) return r.timestampValue === i.timestampValue;
        const s = fa(r.timestampValue),
          a = fa(i.timestampValue);
        return s.seconds === a.seconds && s.nanos === a.nanos;
      })(n, e);
    case 5:
      return n.stringValue === e.stringValue;
    case 6:
      return (function (r, i) {
        return Qu(r.bytesValue).isEqual(Qu(i.bytesValue));
      })(n, e);
    case 7:
      return n.referenceValue === e.referenceValue;
    case 8:
      return (function (r, i) {
        return Vt(r.geoPointValue.latitude) === Vt(i.geoPointValue.latitude) && Vt(r.geoPointValue.longitude) === Vt(i.geoPointValue.longitude);
      })(n, e);
    case 2:
      return (function (r, i) {
        if ('integerValue' in r && 'integerValue' in i) return Vt(r.integerValue) === Vt(i.integerValue);
        if ('doubleValue' in r && 'doubleValue' in i) {
          const s = Vt(r.doubleValue),
            a = Vt(i.doubleValue);
          return s === a ? dd(s) === dd(a) : isNaN(s) && isNaN(a);
        }
        return !1;
      })(n, e);
    case 9:
      return U5(n.arrayValue.values || [], e.arrayValue.values || [], pd);
    case 10:
      return (function (r, i) {
        const s = r.mapValue.fields || {},
          a = i.mapValue.fields || {};
        if (K2(s) !== K2(a)) return !1;
        for (const o in s) if (s.hasOwnProperty(o) && (a[o] === void 0 || !pd(s[o], a[o]))) return !1;
        return !0;
      })(n, e);
    default:
      return Rt();
  }
}
function Xu(n, e) {
  return (n.values || []).find((t) => pd(t, e)) !== void 0;
}
function fd(n, e) {
  if (n === e) return 0;
  const t = ha(n),
    r = ha(e);
  if (t !== r) return qt(t, r);
  switch (t) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return qt(n.booleanValue, e.booleanValue);
    case 2:
      return (function (i, s) {
        const a = Vt(i.integerValue || i.doubleValue),
          o = Vt(s.integerValue || s.doubleValue);
        return a < o
          ? -1
          : a > o
          ? 1
          : a === o
          ? 0
          : // one or both are NaN.
          isNaN(a)
          ? isNaN(o)
            ? 0
            : -1
          : 1;
      })(n, e);
    case 3:
      return q2(n.timestampValue, e.timestampValue);
    case 4:
      return q2(Yu(n), Yu(e));
    case 5:
      return qt(n.stringValue, e.stringValue);
    case 6:
      return (function (i, s) {
        const a = Qu(i),
          o = Qu(s);
        return a.compareTo(o);
      })(n.bytesValue, e.bytesValue);
    case 7:
      return (function (i, s) {
        const a = i.split('/'),
          o = s.split('/');
        for (let u = 0; u < a.length && u < o.length; u++) {
          const l = qt(a[u], o[u]);
          if (l !== 0) return l;
        }
        return qt(a.length, o.length);
      })(n.referenceValue, e.referenceValue);
    case 8:
      return (function (i, s) {
        const a = qt(Vt(i.latitude), Vt(s.latitude));
        return a !== 0 ? a : qt(Vt(i.longitude), Vt(s.longitude));
      })(n.geoPointValue, e.geoPointValue);
    case 9:
      return (function (i, s) {
        const a = i.values || [],
          o = s.values || [];
        for (let u = 0; u < a.length && u < o.length; ++u) {
          const l = fd(a[u], o[u]);
          if (l) return l;
        }
        return qt(a.length, o.length);
      })(n.arrayValue, e.arrayValue);
    case 10:
      return (function (i, s) {
        if (i === Yl && s === Yl) return 0;
        if (i === Yl) return 1;
        if (s === Yl) return -1;
        const a = i.fields || {},
          o = Object.keys(a),
          u = s.fields || {},
          l = Object.keys(u);
        o.sort(), l.sort();
        for (let p = 0; p < o.length && p < l.length; ++p) {
          const h = qt(o[p], l[p]);
          if (h !== 0) return h;
          const b = fd(a[o[p]], u[l[p]]);
          if (b !== 0) return b;
        }
        return qt(o.length, l.length);
      })(n.mapValue, e.mapValue);
    default:
      throw Rt();
  }
}
function q2(n, e) {
  if (typeof n == 'string' && typeof e == 'string' && n.length === e.length) return qt(n, e);
  const t = fa(n),
    r = fa(e),
    i = qt(t.seconds, r.seconds);
  return i !== 0 ? i : qt(t.nanos, r.nanos);
}
function W2(n, e) {
  return {
    referenceValue: `projects/${n.projectId}/databases/${n.database}/documents/${e.path.canonicalString()}`,
  };
}
function z5(n) {
  return !!n && 'arrayValue' in n;
}
function J2(n) {
  return !!n && 'nullValue' in n;
}
function Q2(n) {
  return !!n && 'doubleValue' in n && isNaN(Number(n.doubleValue));
}
function ff(n) {
  return !!n && 'mapValue' in n;
}
function bu(n) {
  if (n.geoPointValue)
    return {
      geoPointValue: Object.assign({}, n.geoPointValue),
    };
  if (n.timestampValue && typeof n.timestampValue == 'object')
    return {
      timestampValue: Object.assign({}, n.timestampValue),
    };
  if (n.mapValue) {
    const e = {
      mapValue: {
        fields: {},
      },
    };
    return El(n.mapValue.fields, (t, r) => (e.mapValue.fields[t] = bu(r))), e;
  }
  if (n.arrayValue) {
    const e = {
      arrayValue: {
        values: [],
      },
    };
    for (let t = 0; t < (n.arrayValue.values || []).length; ++t) e.arrayValue.values[t] = bu(n.arrayValue.values[t]);
    return e;
  }
  return Object.assign({}, n);
}
class Y2 {
  constructor(e, t) {
    (this.position = e), (this.inclusive = t);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class G5 {}
class kr extends G5 {
  constructor(e, t, r) {
    super(), (this.field = e), (this.op = t), (this.value = r);
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, t, r) {
    return e.isKeyField()
      ? t === 'in' || t === 'not-in'
        ? this.createKeyFieldInFilter(e, t, r)
        : new Kk(e, t, r)
      : t === 'array-contains'
      ? new Jk(e, r)
      : t === 'in'
      ? new Qk(e, r)
      : t === 'not-in'
      ? new Yk(e, r)
      : t === 'array-contains-any'
      ? new Xk(e, r)
      : new kr(e, t, r);
  }
  static createKeyFieldInFilter(e, t, r) {
    return t === 'in' ? new qk(e, r) : new Wk(e, r);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return this.op === '!=' ? t !== null && this.matchesComparison(fd(t, this.value)) : t !== null && ha(this.value) === ha(t) && this.matchesComparison(fd(t, this.value));
  }
  matchesComparison(e) {
    switch (this.op) {
      case '<':
        return e < 0;
      case '<=':
        return e <= 0;
      case '==':
        return e === 0;
      case '!=':
        return e !== 0;
      case '>':
        return e > 0;
      case '>=':
        return e >= 0;
      default:
        return Rt();
    }
  }
  isInequality() {
    return (
      [
        '<',
        '<=',
        '>',
        '>=',
        '!=',
        'not-in',
        /* Operator.NOT_IN */
      ].indexOf(this.op) >= 0
    );
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
  getFirstInequalityField() {
    return this.isInequality() ? this.field : null;
  }
}
class Cl extends G5 {
  constructor(e, t) {
    super(), (this.filters = e), (this.op = t), (this.F = null);
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, t) {
    return new Cl(e, t);
  }
  matches(e) {
    return this.op === 'and' ? this.filters.find((t) => !t.matches(e)) === void 0 : this.filters.find((t) => t.matches(e)) !== void 0;
  }
  getFlattenedFilters() {
    return this.F !== null || (this.F = this.filters.reduce((e, t) => e.concat(t.getFlattenedFilters()), [])), this.F;
  }
  // Returns a mutable copy of `this.filters`
  getFilters() {
    return Object.assign([], this.filters);
  }
  getFirstInequalityField() {
    const e = this.S((t) => t.isInequality());
    return e !== null ? e.field : null;
  }
  // Performs a depth-first search to find and return the first FieldFilter in the composite filter
  // that satisfies the predicate. Returns `null` if none of the FieldFilters satisfy the
  // predicate.
  S(e) {
    for (const t of this.getFlattenedFilters()) if (e(t)) return t;
    return null;
  }
}
class Kk extends kr {
  constructor(e, t, r) {
    super(e, t, r), (this.key = rn.fromName(r.referenceValue));
  }
  matches(e) {
    const t = rn.comparator(e.key, this.key);
    return this.matchesComparison(t);
  }
}
class qk extends kr {
  constructor(e, t) {
    super(e, 'in', t), (this.keys = H5('in', t));
  }
  matches(e) {
    return this.keys.some((t) => t.isEqual(e.key));
  }
}
class Wk extends kr {
  constructor(e, t) {
    super(e, 'not-in', t), (this.keys = H5('not-in', t));
  }
  matches(e) {
    return !this.keys.some((t) => t.isEqual(e.key));
  }
}
function H5(n, e) {
  var t;
  return (((t = e.arrayValue) === null || t === void 0 ? void 0 : t.values) || []).map((r) => rn.fromName(r.referenceValue));
}
class Jk extends kr {
  constructor(e, t) {
    super(e, 'array-contains', t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return z5(t) && Xu(t.arrayValue, this.value);
  }
}
class Qk extends kr {
  constructor(e, t) {
    super(e, 'in', t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return t !== null && Xu(this.value.arrayValue, t);
  }
}
class Yk extends kr {
  constructor(e, t) {
    super(e, 'not-in', t);
  }
  matches(e) {
    if (
      Xu(this.value.arrayValue, {
        nullValue: 'NULL_VALUE',
      })
    )
      return !1;
    const t = e.data.field(this.field);
    return t !== null && !Xu(this.value.arrayValue, t);
  }
}
class Xk extends kr {
  constructor(e, t) {
    super(e, 'array-contains-any', t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return !(!z5(t) || !t.arrayValue.values) && t.arrayValue.values.some((r) => Xu(this.value.arrayValue, r));
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class gu {
  constructor(e, t = 'asc') {
    (this.field = e), (this.dir = t);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cn {
  constructor(e) {
    this.timestamp = e;
  }
  static fromTimestamp(e) {
    return new cn(e);
  }
  static min() {
    return new cn(new Bn(0, 0));
  }
  static max() {
    return new cn(new Bn(253402300799, 999999999));
  }
  compareTo(e) {
    return this.timestamp._compareTo(e.timestamp);
  }
  isEqual(e) {
    return this.timestamp.isEqual(e.timestamp);
  }
  /** Returns a number representation of the version for use in spec tests. */
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return 'SnapshotVersion(' + this.timestamp.toString() + ')';
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hd {
  constructor(e, t) {
    (this.comparator = e), (this.root = t || en.EMPTY);
  }
  // Returns a copy of the map, with the specified key/value added or replaced.
  insert(e, t) {
    return new hd(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, en.BLACK, null, null));
  }
  // Returns a copy of the map, with the specified key removed.
  remove(e) {
    return new hd(this.comparator, this.root.remove(e, this.comparator).copy(null, null, en.BLACK, null, null));
  }
  // Returns the value of the node with the given key, or null.
  get(e) {
    let t = this.root;
    for (; !t.isEmpty(); ) {
      const r = this.comparator(e, t.key);
      if (r === 0) return t.value;
      r < 0 ? (t = t.left) : r > 0 && (t = t.right);
    }
    return null;
  }
  // Returns the index of the element in this sorted map, or -1 if it doesn't
  // exist.
  indexOf(e) {
    let t = 0,
      r = this.root;
    for (; !r.isEmpty(); ) {
      const i = this.comparator(e, r.key);
      if (i === 0) return t + r.left.size;
      i < 0
        ? (r = r.left)
        : // Count all nodes left of the node plus the node itself
          ((t += r.left.size + 1), (r = r.right));
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  // Returns the total number of nodes in the map.
  get size() {
    return this.root.size;
  }
  // Returns the minimum key in the map.
  minKey() {
    return this.root.minKey();
  }
  // Returns the maximum key in the map.
  maxKey() {
    return this.root.maxKey();
  }
  // Traverses the map in key order and calls the specified action function
  // for each key/value pair. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.root.inorderTraversal(e);
  }
  forEach(e) {
    this.inorderTraversal((t, r) => (e(t, r), !1));
  }
  toString() {
    const e = [];
    return this.inorderTraversal((t, r) => (e.push(`${t}:${r}`), !1)), `{${e.join(', ')}}`;
  }
  // Traverses the map in reverse key order and calls the specified action
  // function for each key/value pair. If action returns true, traversal is
  // aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.root.reverseTraversal(e);
  }
  // Returns an iterator over the SortedMap.
  getIterator() {
    return new Xl(this.root, null, this.comparator, !1);
  }
  getIteratorFrom(e) {
    return new Xl(this.root, e, this.comparator, !1);
  }
  getReverseIterator() {
    return new Xl(this.root, null, this.comparator, !0);
  }
  getReverseIteratorFrom(e) {
    return new Xl(this.root, e, this.comparator, !0);
  }
}
class Xl {
  constructor(e, t, r, i) {
    (this.isReverse = i), (this.nodeStack = []);
    let s = 1;
    for (; !e.isEmpty(); )
      if (
        ((s = t ? r(e.key, t) : 1), // flip the comparison if we're going in reverse
        t && i && (s *= -1),
        s < 0)
      )
        e = this.isReverse ? e.left : e.right;
      else {
        if (s === 0) {
          this.nodeStack.push(e);
          break;
        }
        this.nodeStack.push(e), (e = this.isReverse ? e.right : e.left);
      }
  }
  getNext() {
    let e = this.nodeStack.pop();
    const t = {
      key: e.key,
      value: e.value,
    };
    if (this.isReverse) for (e = e.left; !e.isEmpty(); ) this.nodeStack.push(e), (e = e.right);
    else for (e = e.right; !e.isEmpty(); ) this.nodeStack.push(e), (e = e.left);
    return t;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0) return null;
    const e = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: e.key,
      value: e.value,
    };
  }
}
class en {
  constructor(e, t, r, i, s) {
    (this.key = e), (this.value = t), (this.color = r ?? en.RED), (this.left = i ?? en.EMPTY), (this.right = s ?? en.EMPTY), (this.size = this.left.size + 1 + this.right.size);
  }
  // Returns a copy of the current node, optionally replacing pieces of it.
  copy(e, t, r, i, s) {
    return new en(e ?? this.key, t ?? this.value, r ?? this.color, i ?? this.left, s ?? this.right);
  }
  isEmpty() {
    return !1;
  }
  // Traverses the tree in key order and calls the specified action function
  // for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e);
  }
  // Traverses the tree in reverse key order and calls the specified action
  // function for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
  }
  // Returns the minimum node in the tree.
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  // Returns the maximum key in the tree.
  minKey() {
    return this.min().key;
  }
  // Returns the maximum key in the tree.
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  // Returns new tree, with the key/value added.
  insert(e, t, r) {
    let i = this;
    const s = r(e, i.key);
    return (i = s < 0 ? i.copy(null, null, null, i.left.insert(e, t, r), null) : s === 0 ? i.copy(null, t, null, null, null) : i.copy(null, null, null, null, i.right.insert(e, t, r))), i.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty()) return en.EMPTY;
    let e = this;
    return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), (e = e.copy(null, null, null, e.left.removeMin(), null)), e.fixUp();
  }
  // Returns new tree, with the specified item removed.
  remove(e, t) {
    let r,
      i = this;
    if (t(e, i.key) < 0) i.left.isEmpty() || i.left.isRed() || i.left.left.isRed() || (i = i.moveRedLeft()), (i = i.copy(null, null, null, i.left.remove(e, t), null));
    else {
      if ((i.left.isRed() && (i = i.rotateRight()), i.right.isEmpty() || i.right.isRed() || i.right.left.isRed() || (i = i.moveRedRight()), t(e, i.key) === 0)) {
        if (i.right.isEmpty()) return en.EMPTY;
        (r = i.right.min()), (i = i.copy(r.key, r.value, null, null, i.right.removeMin()));
      }
      i = i.copy(null, null, null, null, i.right.remove(e, t));
    }
    return i.fixUp();
  }
  isRed() {
    return this.color;
  }
  // Returns new tree after performing any needed rotations.
  fixUp() {
    let e = this;
    return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e;
  }
  moveRedLeft() {
    let e = this.colorFlip();
    return e.right.left.isRed() && ((e = e.copy(null, null, null, null, e.right.rotateRight())), (e = e.rotateLeft()), (e = e.colorFlip())), e;
  }
  moveRedRight() {
    let e = this.colorFlip();
    return e.left.left.isRed() && ((e = e.rotateRight()), (e = e.colorFlip())), e;
  }
  rotateLeft() {
    const e = this.copy(null, null, en.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, e, null);
  }
  rotateRight() {
    const e = this.copy(null, null, en.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, e);
  }
  colorFlip() {
    const e = this.left.copy(null, null, !this.left.color, null, null),
      t = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, e, t);
  }
  // For testing.
  checkMaxDepth() {
    const e = this.check();
    return Math.pow(2, e) <= this.size + 1;
  }
  // In a balanced RB tree, the black-depth (number of black nodes) from root to
  // leaves is equal on both sides.  This function verifies that or asserts.
  check() {
    if ((this.isRed() && this.left.isRed()) || this.right.isRed()) throw Rt();
    const e = this.left.check();
    if (e !== this.right.check()) throw Rt();
    return e + (this.isRed() ? 0 : 1);
  }
}
(en.EMPTY = null), (en.RED = !0), (en.BLACK = !1);
en.EMPTY = new // Represents an empty node (a leaf node in the Red-Black Tree).
(class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw Rt();
  }
  get value() {
    throw Rt();
  }
  get color() {
    throw Rt();
  }
  get left() {
    throw Rt();
  }
  get right() {
    throw Rt();
  }
  // Returns a copy of the current node.
  copy(n, e, t, r, i) {
    return this;
  }
  // Returns a copy of the tree, with the specified key/value added.
  insert(n, e, t) {
    return new en(n, e);
  }
  // Returns a copy of the tree, with the specified key removed.
  remove(n, e) {
    return this;
  }
  isEmpty() {
    return !0;
  }
  inorderTraversal(n) {
    return !1;
  }
  reverseTraversal(n) {
    return !1;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return !1;
  }
  // For testing.
  checkMaxDepth() {
    return !0;
  }
  check() {
    return 0;
  }
})();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yd {
  constructor(e) {
    (this.comparator = e), (this.data = new hd(this.comparator));
  }
  has(e) {
    return this.data.get(e) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(e) {
    return this.data.indexOf(e);
  }
  /** Iterates elements in order defined by "comparator" */
  forEach(e) {
    this.data.inorderTraversal((t, r) => (e(t), !1));
  }
  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
  forEachInRange(e, t) {
    const r = this.data.getIteratorFrom(e[0]);
    for (; r.hasNext(); ) {
      const i = r.getNext();
      if (this.comparator(i.key, e[1]) >= 0) return;
      t(i.key);
    }
  }
  /**
   * Iterates over `elem`s such that: start &lt;= elem until false is returned.
   */
  forEachWhile(e, t) {
    let r;
    for (r = t !== void 0 ? this.data.getIteratorFrom(t) : this.data.getIterator(); r.hasNext(); ) if (!e(r.getNext().key)) return;
  }
  /** Finds the least element greater than or equal to `elem`. */
  firstAfterOrEqual(e) {
    const t = this.data.getIteratorFrom(e);
    return t.hasNext() ? t.getNext().key : null;
  }
  getIterator() {
    return new X2(this.data.getIterator());
  }
  getIteratorFrom(e) {
    return new X2(this.data.getIteratorFrom(e));
  }
  /** Inserts or updates an element */
  add(e) {
    return this.copy(this.data.remove(e).insert(e, !0));
  }
  /** Deletes an element */
  delete(e) {
    return this.has(e) ? this.copy(this.data.remove(e)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(e) {
    let t = this;
    return (
      t.size < e.size && ((t = e), (e = this)),
      e.forEach((r) => {
        t = t.add(r);
      }),
      t
    );
  }
  isEqual(e) {
    if (!(e instanceof yd) || this.size !== e.size) return !1;
    const t = this.data.getIterator(),
      r = e.data.getIterator();
    for (; t.hasNext(); ) {
      const i = t.getNext().key,
        s = r.getNext().key;
      if (this.comparator(i, s) !== 0) return !1;
    }
    return !0;
  }
  toArray() {
    const e = [];
    return (
      this.forEach((t) => {
        e.push(t);
      }),
      e
    );
  }
  toString() {
    const e = [];
    return this.forEach((t) => e.push(t)), 'SortedSet(' + e.toString() + ')';
  }
  copy(e) {
    const t = new yd(this.comparator);
    return (t.data = e), t;
  }
}
class X2 {
  constructor(e) {
    this.iter = e;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ya {
  constructor(e) {
    (this.fields = e), // TODO(dimond): validation of FieldMask
      // Sort the field mask to support `FieldMask.isEqual()` and assert below.
      e.sort(Kn.comparator);
  }
  static empty() {
    return new ya([]);
  }
  /**
   * Returns a new FieldMask object that is the result of adding all the given
   * fields paths to this field mask.
   */
  unionWith(e) {
    let t = new yd(Kn.comparator);
    for (const r of this.fields) t = t.add(r);
    for (const r of e) t = t.add(r);
    return new ya(t.toArray());
  }
  /**
   * Verifies that `fieldPath` is included by at least one field in this field
   * mask.
   *
   * This is an O(n) operation, where `n` is the size of the field mask.
   */
  covers(e) {
    for (const t of this.fields) if (t.isPrefixOf(e)) return !0;
    return !1;
  }
  isEqual(e) {
    return U5(this.fields, e.fields, (t, r) => t.isEqual(r));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ir {
  constructor(e) {
    this.value = e;
  }
  static empty() {
    return new ir({
      mapValue: {},
    });
  }
  /**
   * Returns the value at the given path or null.
   *
   * @param path - the path to search
   * @returns The value at the path or null if the path is not set.
   */
  field(e) {
    if (e.isEmpty()) return this.value;
    {
      let t = this.value;
      for (let r = 0; r < e.length - 1; ++r) if (((t = (t.mapValue.fields || {})[e.get(r)]), !ff(t))) return null;
      return (t = (t.mapValue.fields || {})[e.lastSegment()]), t || null;
    }
  }
  /**
   * Sets the field to the provided value.
   *
   * @param path - The field path to set.
   * @param value - The value to set.
   */
  set(e, t) {
    this.getFieldsMap(e.popLast())[e.lastSegment()] = bu(t);
  }
  /**
   * Sets the provided fields to the provided values.
   *
   * @param data - A map of fields to values (or null for deletes).
   */
  setAll(e) {
    let t = Kn.emptyPath(),
      r = {},
      i = [];
    e.forEach((a, o) => {
      if (!t.isImmediateParentOf(o)) {
        const u = this.getFieldsMap(t);
        this.applyChanges(u, r, i), (r = {}), (i = []), (t = o.popLast());
      }
      a ? (r[o.lastSegment()] = bu(a)) : i.push(o.lastSegment());
    });
    const s = this.getFieldsMap(t);
    this.applyChanges(s, r, i);
  }
  /**
   * Removes the field at the specified path. If there is no field at the
   * specified path, nothing is changed.
   *
   * @param path - The field path to remove.
   */
  delete(e) {
    const t = this.field(e.popLast());
    ff(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()];
  }
  isEqual(e) {
    return pd(this.value, e.value);
  }
  /**
   * Returns the map that contains the leaf element of `path`. If the parent
   * entry does not yet exist, or if it is not a map, a new map will be created.
   */
  getFieldsMap(e) {
    let t = this.value;
    t.mapValue.fields ||
      (t.mapValue = {
        fields: {},
      });
    for (let r = 0; r < e.length; ++r) {
      let i = t.mapValue.fields[e.get(r)];
      (ff(i) && i.mapValue.fields) ||
        ((i = {
          mapValue: {
            fields: {},
          },
        }),
        (t.mapValue.fields[e.get(r)] = i)),
        (t = i);
    }
    return t.mapValue.fields;
  }
  /**
   * Modifies `fieldsMap` by adding, replacing or deleting the specified
   * entries.
   */
  applyChanges(e, t, r) {
    El(t, (i, s) => (e[i] = s));
    for (const i of r) delete e[i];
  }
  clone() {
    return new ir(bu(this.value));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ts {
  constructor(e, t, r, i, s, a, o) {
    (this.key = e), (this.documentType = t), (this.version = r), (this.readTime = i), (this.createTime = s), (this.data = a), (this.documentState = o);
  }
  /**
   * Creates a document with no known version or data, but which can serve as
   * base document for mutations.
   */
  static newInvalidDocument(e) {
    return new ts(
      e,
      0,
      /* version */
      cn.min(),
      /* readTime */
      cn.min(),
      /* createTime */
      cn.min(),
      ir.empty(),
      0,
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist with the given data at the
   * given version.
   */
  static newFoundDocument(e, t, r, i) {
    return new ts(
      e,
      1,
      /* version */
      t,
      /* readTime */
      cn.min(),
      /* createTime */
      r,
      i,
      0,
      /* DocumentState.SYNCED */
    );
  }
  /** Creates a new document that is known to not exist at the given version. */
  static newNoDocument(e, t) {
    return new ts(
      e,
      2,
      /* version */
      t,
      /* readTime */
      cn.min(),
      /* createTime */
      cn.min(),
      ir.empty(),
      0,
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist at the given version but
   * whose data is not known (e.g. a document that was updated without a known
   * base document).
   */
  static newUnknownDocument(e, t) {
    return new ts(
      e,
      3,
      /* version */
      t,
      /* readTime */
      cn.min(),
      /* createTime */
      cn.min(),
      ir.empty(),
      2,
      /* DocumentState.HAS_COMMITTED_MUTATIONS */
    );
  }
  /**
   * Changes the document type to indicate that it exists and that its version
   * and data are known.
   */
  convertToFoundDocument(e, t) {
    return (
      !this.createTime.isEqual(cn.min()) || (this.documentType !== 2 && this.documentType !== 0) || (this.createTime = e),
      (this.version = e),
      (this.documentType = 1),
      (this.data = t),
      (this.documentState = 0),
      this
    );
  }
  /**
   * Changes the document type to indicate that it doesn't exist at the given
   * version.
   */
  convertToNoDocument(e) {
    return (this.version = e), (this.documentType = 2), (this.data = ir.empty()), (this.documentState = 0), this;
  }
  /**
   * Changes the document type to indicate that it exists at a given version but
   * that its data is not known (e.g. a document that was updated without a known
   * base document).
   */
  convertToUnknownDocument(e) {
    return (this.version = e), (this.documentType = 3), (this.data = ir.empty()), (this.documentState = 2), this;
  }
  setHasCommittedMutations() {
    return (this.documentState = 2), this;
  }
  setHasLocalMutations() {
    return (this.documentState = 1), (this.version = cn.min()), this;
  }
  setReadTime(e) {
    return (this.readTime = e), this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(e) {
    return e instanceof ts && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data);
  }
  mutableCopy() {
    return new ts(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${
      this.documentState
    }})`;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zk {
  constructor(e, t = null, r = [], i = [], s = null, a = null, o = null) {
    (this.path = e), (this.collectionGroup = t), (this.orderBy = r), (this.filters = i), (this.limit = s), (this.startAt = a), (this.endAt = o), (this.q = null);
  }
}
function Z2(n, e = null, t = [], r = [], i = null, s = null, a = null) {
  return new Zk(n, e, t, r, i, s, a);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class b0 {
  /**
   * Initializes a Query with a path and optional additional query constraints.
   * Path must currently be empty if this is a collection group query.
   */
  constructor(e, t = null, r = [], i = [], s = null, a = 'F', o = null, u = null) {
    (this.path = e),
      (this.collectionGroup = t),
      (this.explicitOrderBy = r),
      (this.filters = i),
      (this.limit = s),
      (this.limitType = a),
      (this.startAt = o),
      (this.endAt = u),
      (this.O = null), // The corresponding `Target` of this `Query` instance.
      (this.k = null),
      this.startAt,
      this.endAt;
  }
}
function g0(n) {
  return n.explicitOrderBy.length > 0 ? n.explicitOrderBy[0].field : null;
}
function Qd(n) {
  for (const e of n.filters) {
    const t = e.getFirstInequalityField();
    if (t !== null) return t;
  }
  return null;
}
function eO(n) {
  return n.collectionGroup !== null;
}
function ev(n) {
  const e = Wd(n);
  if (e.O === null) {
    e.O = [];
    const t = Qd(e),
      r = g0(e);
    if (t !== null && r === null)
      t.isKeyField() || e.O.push(new gu(t)),
        e.O.push(
          new gu(
            Kn.keyField(),
            'asc',
            /* Direction.ASCENDING */
          ),
        );
    else {
      let i = !1;
      for (const s of e.explicitOrderBy) e.O.push(s), s.field.isKeyField() && (i = !0);
      if (!i) {
        const s = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : 'asc';
        e.O.push(new gu(Kn.keyField(), s));
      }
    }
  }
  return e.O;
}
function tO(n) {
  const e = Wd(n);
  if (!e.k)
    if (e.limitType === 'F') e.k = Z2(e.path, e.collectionGroup, ev(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t = [];
      for (const s of ev(e)) {
        const a = s.dir === 'desc' ? 'asc' : 'desc';
        t.push(new gu(s.field, a));
      }
      const r = e.endAt ? new Y2(e.endAt.position, e.endAt.inclusive) : null,
        i = e.startAt ? new Y2(e.startAt.position, e.startAt.inclusive) : null;
      e.k = Z2(e.path, e.collectionGroup, t, e.filters, e.limit, r, i);
    }
  return e.k;
}
function Th(n, e) {
  e.getFirstInequalityField(), Qd(n);
  const t = n.filters.concat([e]);
  return new b0(n.path, n.collectionGroup, n.explicitOrderBy.slice(), t, n.limit, n.limitType, n.startAt, n.endAt);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function nO(n, e) {
  return (function (t) {
    return typeof t == 'number' && Number.isInteger(t) && !dd(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER;
  })(e)
    ? /**
       * Returns an IntegerValue for `value`.
       */
      (function (t) {
        return {
          integerValue: '' + t,
        };
      })(e)
    : (function (t, r) {
        if (t.useProto3Json) {
          if (isNaN(r))
            return {
              doubleValue: 'NaN',
            };
          if (r === 1 / 0)
            return {
              doubleValue: 'Infinity',
            };
          if (r === -1 / 0)
            return {
              doubleValue: '-Infinity',
            };
        }
        return {
          doubleValue: dd(r) ? '-0' : r,
        };
      })(n, e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Yd {
  constructor() {
    this._ = void 0;
  }
}
class rO extends Yd {}
class iO extends Yd {
  constructor(e) {
    super(), (this.elements = e);
  }
}
class sO extends Yd {
  constructor(e) {
    super(), (this.elements = e);
  }
}
class aO extends Yd {
  constructor(e, t) {
    super(), (this.serializer = e), (this.C = t);
  }
}
class wi {
  constructor(e, t) {
    (this.updateTime = e), (this.exists = t);
  }
  /** Creates a new empty Precondition. */
  static none() {
    return new wi();
  }
  /** Creates a new Precondition with an exists flag. */
  static exists(e) {
    return new wi(void 0, e);
  }
  /** Creates a new Precondition based on a version a document exists at. */
  static updateTime(e) {
    return new wi(e);
  }
  /** Returns whether this Precondition is empty. */
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(e) {
    return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime);
  }
}
class Xd {}
class K5 extends Xd {
  constructor(e, t, r, i = []) {
    super(), (this.key = e), (this.value = t), (this.precondition = r), (this.fieldTransforms = i), (this.type = 0);
  }
  getFieldMask() {
    return null;
  }
}
class v0 extends Xd {
  constructor(e, t, r, i, s = []) {
    super(), (this.key = e), (this.data = t), (this.fieldMask = r), (this.precondition = i), (this.fieldTransforms = s), (this.type = 1);
  }
  getFieldMask() {
    return this.fieldMask;
  }
}
class x0 extends Xd {
  constructor(e, t) {
    super(), (this.key = e), (this.precondition = t), (this.type = 2), (this.fieldTransforms = []);
  }
  getFieldMask() {
    return null;
  }
}
class oO extends Xd {
  constructor(e, t) {
    super(), (this.key = e), (this.precondition = t), (this.type = 3), (this.fieldTransforms = []);
  }
  getFieldMask() {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const uO = (() => ({
    asc: 'ASCENDING',
    desc: 'DESCENDING',
  }))(),
  lO = (() => ({
    '<': 'LESS_THAN',
    '<=': 'LESS_THAN_OR_EQUAL',
    '>': 'GREATER_THAN',
    '>=': 'GREATER_THAN_OR_EQUAL',
    '==': 'EQUAL',
    '!=': 'NOT_EQUAL',
    'array-contains': 'ARRAY_CONTAINS',
    in: 'IN',
    'not-in': 'NOT_IN',
    'array-contains-any': 'ARRAY_CONTAINS_ANY',
  }))(),
  cO = (() => ({
    and: 'AND',
    or: 'OR',
  }))();
class dO {
  constructor(e, t) {
    (this.databaseId = e), (this.useProto3Json = t);
  }
}
function Ah(n, e) {
  return n.useProto3Json
    ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, '').replace('Z', '')}.${('000000000' + e.nanoseconds).slice(-9)}Z`
    : {
        seconds: '' + e.seconds,
        nanos: e.nanoseconds,
      };
}
function pO(n, e) {
  return n.useProto3Json ? e.toBase64() : e.toUint8Array();
}
function fO(n, e) {
  return Ah(n, e.toTimestamp());
}
function tv(n) {
  return (
    bs(!!n),
    cn.fromTimestamp(
      (function (e) {
        const t = fa(e);
        return new Bn(t.seconds, t.nanos);
      })(n),
    )
  );
}
function w0(n, e) {
  return (function (t) {
    return new Gt(['projects', t.projectId, 'databases', t.database]);
  })(n)
    .child('documents')
    .child(e)
    .canonicalString();
}
function Eh(n, e) {
  return w0(n.databaseId, e.path);
}
function hO(n, e) {
  const t = (function (i) {
    const s = Gt.fromString(i);
    return bs(W5(s)), s;
  })(e);
  if (t.get(1) !== n.databaseId.projectId) throw new se(le, 'Tried to deserialize key from different project: ' + t.get(1) + ' vs ' + n.databaseId.projectId);
  if (t.get(3) !== n.databaseId.database) throw new se(le, 'Tried to deserialize key from different database: ' + t.get(3) + ' vs ' + n.databaseId.database);
  return new rn((bs((r = t).length > 4 && r.get(4) === 'documents'), r.popFirst(5)));
  var r;
}
function nv(n, e) {
  return w0(n.databaseId, e);
}
function yO(n) {
  return new Gt(['projects', n.databaseId.projectId, 'databases', n.databaseId.database]).canonicalString();
}
function rv(n, e, t) {
  return {
    name: Eh(n, e),
    fields: t.value.mapValue.fields,
  };
}
function mO(n, e) {
  let t;
  if (e instanceof K5)
    t = {
      update: rv(n, e.key, e.value),
    };
  else if (e instanceof x0)
    t = {
      delete: Eh(n, e.key),
    };
  else if (e instanceof v0)
    t = {
      update: rv(n, e.key, e.data),
      updateMask: wO(e.fieldMask),
    };
  else {
    if (!(e instanceof oO)) return Rt();
    t = {
      verify: Eh(n, e.key),
    };
  }
  return (
    e.fieldTransforms.length > 0 &&
      (t.updateTransforms = e.fieldTransforms.map((r) =>
        (function (i, s) {
          const a = s.transform;
          if (a instanceof rO)
            return {
              fieldPath: s.field.canonicalString(),
              setToServerValue: 'REQUEST_TIME',
            };
          if (a instanceof iO)
            return {
              fieldPath: s.field.canonicalString(),
              appendMissingElements: {
                values: a.elements,
              },
            };
          if (a instanceof sO)
            return {
              fieldPath: s.field.canonicalString(),
              removeAllFromArray: {
                values: a.elements,
              },
            };
          if (a instanceof aO)
            return {
              fieldPath: s.field.canonicalString(),
              increment: a.C,
            };
          throw Rt();
        })(0, r),
      )),
    e.precondition.isNone ||
      (t.currentDocument = (function (r, i) {
        return i.updateTime !== void 0
          ? {
              updateTime: fO(r, i.updateTime),
            }
          : i.exists !== void 0
          ? {
              exists: i.exists,
            }
          : Rt();
      })(n, e.precondition)),
    t
  );
}
function bO(n, e) {
  const t = {
      structuredQuery: {},
    },
    r = e.path;
  e.collectionGroup !== null
    ? ((t.parent = nv(n, r)),
      (t.structuredQuery.from = [
        {
          collectionId: e.collectionGroup,
          allDescendants: !0,
        },
      ]))
    : ((t.parent = nv(n, r.popLast())),
      (t.structuredQuery.from = [
        {
          collectionId: r.lastSegment(),
        },
      ]));
  const i = (function (u) {
    if (u.length !== 0)
      return q5(
        Cl.create(
          u,
          'and',
          /* CompositeOperator.AND */
        ),
      );
  })(e.filters);
  i && (t.structuredQuery.where = i);
  const s = (function (u) {
    if (u.length !== 0)
      return u.map((l) =>
        // visible for testing
        (function (p) {
          return {
            field: za(p.field),
            direction: gO(p.dir),
          };
        })(l),
      );
  })(e.orderBy);
  s && (t.structuredQuery.orderBy = s);
  const a = (function (u, l) {
    return u.useProto3Json || $k(l)
      ? l
      : {
          value: l,
        };
  })(n, e.limit);
  var o;
  return (
    a !== null && (t.structuredQuery.limit = a),
    e.startAt &&
      (t.structuredQuery.startAt = {
        before: (o = e.startAt).inclusive,
        values: o.position,
      }),
    e.endAt &&
      (t.structuredQuery.endAt = (function (u) {
        return {
          before: !u.inclusive,
          values: u.position,
        };
      })(e.endAt)),
    t
  );
}
function gO(n) {
  return uO[n];
}
function vO(n) {
  return lO[n];
}
function xO(n) {
  return cO[n];
}
function za(n) {
  return {
    fieldPath: n.canonicalString(),
  };
}
function q5(n) {
  return n instanceof kr
    ? (function (e) {
        if (e.op === '==') {
          if (Q2(e.value))
            return {
              unaryFilter: {
                field: za(e.field),
                op: 'IS_NAN',
              },
            };
          if (J2(e.value))
            return {
              unaryFilter: {
                field: za(e.field),
                op: 'IS_NULL',
              },
            };
        } else if (e.op === '!=') {
          if (Q2(e.value))
            return {
              unaryFilter: {
                field: za(e.field),
                op: 'IS_NOT_NAN',
              },
            };
          if (J2(e.value))
            return {
              unaryFilter: {
                field: za(e.field),
                op: 'IS_NOT_NULL',
              },
            };
        }
        return {
          fieldFilter: {
            field: za(e.field),
            op: vO(e.op),
            value: e.value,
          },
        };
      })(n)
    : n instanceof Cl
    ? (function (e) {
        const t = e.getFilters().map((r) => q5(r));
        return t.length === 1
          ? t[0]
          : {
              compositeFilter: {
                op: xO(e.op),
                filters: t,
              },
            };
      })(n)
    : Rt();
}
function wO(n) {
  const e = [];
  return (
    n.fields.forEach((t) => e.push(t.canonicalString())),
    {
      fieldPaths: e,
    }
  );
}
function W5(n) {
  return n.length >= 4 && n.get(0) === 'projects' && n.get(2) === 'databases';
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function T0(n) {
  return new dO(
    n,
    /* useProto3Json= */
    !0,
  );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TO extends class {} {
  constructor(e, t, r, i) {
    super(), (this.authCredentials = e), (this.appCheckCredentials = t), (this.connection = r), (this.serializer = i), (this.J = !1);
  }
  X() {
    if (this.J) throw new se(pa, 'The client has already been terminated.');
  }
  /** Invokes the provided RPC with auth and AppCheck tokens. */
  v(e, t, r) {
    return (
      this.X(),
      Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
        .then(([i, s]) => this.connection.v(e, t, r, i, s))
        .catch((i) => {
          throw i.name === 'FirebaseError' ? (i.code === wh && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), i) : new se(mu, i.toString());
        })
    );
  }
  /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
  R(e, t, r, i) {
    return (
      this.X(),
      Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
        .then(([s, a]) => this.connection.R(e, t, r, s, a, i))
        .catch((s) => {
          throw s.name === 'FirebaseError' ? (s.code === wh && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), s) : new se(mu, s.toString());
        })
    );
  }
  terminate() {
    this.J = !0;
  }
}
async function A0(n, e) {
  const t = Wd(n),
    r = yO(t.serializer) + '/documents',
    i = {
      writes: e.map((s) => mO(t.serializer, s)),
    };
  await t.v('Commit', r, i);
}
async function AO(n, e) {
  const t = Wd(n),
    r = bO(t.serializer, tO(e));
  return (
    await t.R('RunQuery', r.parent, {
      structuredQuery: r.structuredQuery,
    })
  )
    .filter((i) => !!i.document)
    .map((i) =>
      (function (s, a, o) {
        const u = hO(s, a.name),
          l = tv(a.updateTime),
          p = a.createTime ? tv(a.createTime) : cn.min(),
          h = new ir({
            mapValue: {
              fields: a.fields,
            },
          }),
          b = ts.newFoundDocument(u, l, p, h);
        return o && b.setHasCommittedMutations(), o ? b.setHasCommittedMutations() : b;
      })(t.serializer, i.document, void 0),
    );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const vu = /* @__PURE__ */ new Map();
function Zd(n) {
  if (n._terminated) throw new se(pa, 'The client has already been terminated.');
  if (!vu.has(n)) {
    cd('ComponentProvider', 'Initializing Datastore');
    const s = (function (u) {
        return new jk(u, fetch.bind(null));
      })(
        ((e = n._databaseId),
        (t = n.app.options.appId || ''),
        (r = n._persistenceKey),
        (i = n._freezeSettings()),
        new Dk(e, t, r, i.host, i.ssl, i.experimentalForceLongPolling, i.experimentalAutoDetectLongPolling, i.useFetchStreams)),
      ),
      a = T0(n._databaseId),
      o = (function (u, l, p, h) {
        return new TO(u, l, p, h);
      })(n._authCredentials, n._appCheckCredentials, s, a);
    vu.set(n, o);
  }
  var e, t, r, i;
  /**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  return vu.get(n);
}
class iv {
  constructor(e) {
    var t;
    if (e.host === void 0) {
      if (e.ssl !== void 0) throw new se(le, "Can't provide ssl option if host option is not set");
      (this.host = 'firestore.googleapis.com'), (this.ssl = !0);
    } else (this.host = e.host), (this.ssl = (t = e.ssl) === null || t === void 0 || t);
    if (((this.credentials = e.credentials), (this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties), (this.cache = e.localCache), e.cacheSizeBytes === void 0))
      this.cacheSizeBytes = 41943040;
    else {
      if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576) throw new se(le, 'cacheSizeBytes must be at least 1048576');
      this.cacheSizeBytes = e.cacheSizeBytes;
    }
    (this.experimentalForceLongPolling = !!e.experimentalForceLongPolling),
      (this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling),
      (this.useFetchStreams = !!e.useFetchStreams),
      (function (r, i, s, a) {
        if (i === !0 && a === !0) throw new se(le, `${r} and ${s} cannot be used together.`);
      })('experimentalForceLongPolling', e.experimentalForceLongPolling, 'experimentalAutoDetectLongPolling', e.experimentalAutoDetectLongPolling);
  }
  isEqual(e) {
    return (
      this.host === e.host &&
      this.ssl === e.ssl &&
      this.credentials === e.credentials &&
      this.cacheSizeBytes === e.cacheSizeBytes &&
      this.experimentalForceLongPolling === e.experimentalForceLongPolling &&
      this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling &&
      this.ignoreUndefinedProperties === e.ignoreUndefinedProperties &&
      this.useFetchStreams === e.useFetchStreams
    );
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fo {
  /** @hideconstructor */
  constructor(e, t, r, i) {
    (this._authCredentials = e),
      (this._appCheckCredentials = t),
      (this._databaseId = r),
      (this._app = i),
      /**
       * Whether it's a Firestore or Firestore Lite instance.
       */ (this.type = 'firestore-lite'),
      (this._persistenceKey = '(lite)'),
      (this._settings = new iv({})),
      (this._settingsFrozen = !1);
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app) throw new se(pa, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(e) {
    if (this._settingsFrozen)
      throw new se(pa, 'Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.');
    (this._settings = new iv(e)),
      e.credentials !== void 0 &&
        (this._authCredentials = (function (t) {
          if (!t) return new Rk();
          switch (t.type) {
            case 'firstParty':
              return new Ok(t.sessionIndex || '0', t.iamToken || null, t.authTokenFactory || null);
            case 'provider':
              return t.client;
            default:
              throw new se(le, 'makeAuthCredentialsProvider failed due to invalid credential type');
          }
        })(e.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return (this._settingsFrozen = !0), this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings,
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    return (
      (function (e) {
        const t = vu.get(e);
        t && (cd('ComponentProvider', 'Removing Datastore'), vu.delete(e), t.terminate());
      })(this),
      Promise.resolve()
    );
  }
}
function EO(n, e) {
  const t = typeof n == 'object' ? n : uk(),
    r = typeof n == 'string' ? n : e || '(default)',
    i = ik(t, 'firestore/lite').getImmediate({
      identifier: r,
    });
  if (!i._initialized) {
    const s = tI('firestore');
    s && J5(i, ...s);
  }
  return i;
}
function J5(n, e, t, r = {}) {
  var i;
  const s = (n = Al(n, Fo))._getSettings();
  if (
    (s.host !== 'firestore.googleapis.com' && s.host !== e && D5('Host has been set in both settings() and useEmulator(), emulator host will be used'),
    n._setSettings(
      Object.assign(Object.assign({}, s), {
        host: `${e}:${t}`,
        ssl: !1,
      }),
    ),
    r.mockUserToken)
  ) {
    let a, o;
    if (typeof r.mockUserToken == 'string') (a = r.mockUserToken), (o = Pn.MOCK_USER);
    else {
      a = iI(r.mockUserToken, (i = n._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const u = r.mockUserToken.sub || r.mockUserToken.user_id;
      if (!u) throw new se(le, "mockUserToken must contain 'sub' or 'user_id' field!");
      o = new Pn(u);
    }
    n._authCredentials = new Pk(new L5(a, o));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Tn {
  /** @hideconstructor */
  constructor(e, t, r) {
    (this.converter = t), (this._key = r) /** The type of this Firestore reference. */, (this.type = 'document'), (this.firestore = e);
  }
  get _path() {
    return this._key.path;
  }
  /**
   * The document's identifier within its collection.
   */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  get path() {
    return this._key.path.canonicalString();
  }
  /**
   * The collection this `DocumentReference` belongs to.
   */
  get parent() {
    return new Ti(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(e) {
    return new Tn(this.firestore, e, this._key);
  }
}
class As {
  // This is the lite version of the Query class in the main SDK.
  /** @hideconstructor protected */
  constructor(e, t, r) {
    (this.converter = t), (this._query = r) /** The type of this Firestore reference. */, (this.type = 'query'), (this.firestore = e);
  }
  withConverter(e) {
    return new As(this.firestore, e, this._query);
  }
}
class Ti extends As {
  /** @hideconstructor */
  constructor(e, t, r) {
    super(e, t, new b0(r)), (this._path = r) /** The type of this Firestore reference. */, (this.type = 'collection');
  }
  /** The collection's identifier. */
  get id() {
    return this._query.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   */
  get path() {
    return this._query.path.canonicalString();
  }
  /**
   * A reference to the containing `DocumentReference` if this is a
   * subcollection. If this isn't a subcollection, the reference is null.
   */
  get parent() {
    const e = this._path.popLast();
    return e.isEmpty()
      ? null
      : new Tn(
          this.firestore,
          /* converter= */
          null,
          new rn(e),
        );
  }
  withConverter(e) {
    return new Ti(this.firestore, e, this._path);
  }
}
function Ch(n, e, ...t) {
  if (((n = ei(n)), $5('collection', 'path', e), n instanceof Fo)) {
    const r = Gt.fromString(e, ...t);
    return (
      z2(r),
      new Ti(
        n,
        /* converter= */
        null,
        r,
      )
    );
  }
  {
    if (!(n instanceof Tn || n instanceof Ti)) throw new se(le, 'Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore');
    const r = n._path.child(Gt.fromString(e, ...t));
    return (
      z2(r),
      new Ti(
        n.firestore,
        /* converter= */
        null,
        r,
      )
    );
  }
}
function vc(n, e, ...t) {
  if (
    ((n = ei(n)), // We allow omission of 'pathString' but explicitly prohibit passing in both
    // 'undefined' and 'null'.
    arguments.length === 1 && (e = zk.N()),
    $5('doc', 'path', e),
    n instanceof Fo)
  ) {
    const r = Gt.fromString(e, ...t);
    return (
      V2(r),
      new Tn(
        n,
        /* converter= */
        null,
        new rn(r),
      )
    );
  }
  {
    if (!(n instanceof Tn || n instanceof Ti)) throw new se(le, 'Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore');
    const r = n._path.child(Gt.fromString(e, ...t));
    return V2(r), new Tn(n.firestore, n instanceof Ti ? n.converter : null, new rn(r));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ma {
  /** @hideconstructor */
  constructor(e) {
    this._byteString = e;
  }
  /**
   * Creates a new `Bytes` object from the given Base64 string, converting it to
   * bytes.
   *
   * @param base64 - The Base64 string used to create the `Bytes` object.
   */
  static fromBase64String(e) {
    try {
      return new ma(Ii.fromBase64String(e));
    } catch (t) {
      throw new se(le, 'Failed to construct data from Base64 string: ' + t);
    }
  }
  /**
   * Creates a new `Bytes` object from the given Uint8Array.
   *
   * @param array - The Uint8Array used to create the `Bytes` object.
   */
  static fromUint8Array(e) {
    return new ma(Ii.fromUint8Array(e));
  }
  /**
   * Returns the underlying bytes as a Base64-encoded string.
   *
   * @returns The Base64-encoded string created from the `Bytes` object.
   */
  toBase64() {
    return this._byteString.toBase64();
  }
  /**
   * Returns the underlying bytes in a new `Uint8Array`.
   *
   * @returns The Uint8Array created from the `Bytes` object.
   */
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  /**
   * Returns a string representation of the `Bytes` object.
   *
   * @returns A string representation of the `Bytes` object.
   */
  toString() {
    return 'Bytes(base64: ' + this.toBase64() + ')';
  }
  /**
   * Returns true if this `Bytes` object is equal to the provided one.
   *
   * @param other - The `Bytes` object to compare against.
   * @returns true if this `Bytes` object is equal to the provided one.
   */
  isEqual(e) {
    return this._byteString.isEqual(e._byteString);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Sl {
  /**
   * Creates a `FieldPath` from the provided field names. If more than one field
   * name is provided, the path will point to a nested field in a document.
   *
   * @param fieldNames - A list of field names.
   */
  constructor(...e) {
    for (let t = 0; t < e.length; ++t) if (e[t].length === 0) throw new se(le, 'Invalid field name at argument $(i + 1). Field names must not be empty.');
    this._internalPath = new Kn(e);
  }
  /**
   * Returns true if this `FieldPath` is equal to the provided one.
   *
   * @param other - The `FieldPath` to compare against.
   * @returns true if this `FieldPath` is equal to the provided one.
   */
  isEqual(e) {
    return this._internalPath.isEqual(e._internalPath);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ep {
  /**
   * @param _methodName - The public API endpoint that returns this class.
   * @hideconstructor
   */
  constructor(e) {
    this._methodName = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class tp {
  /**
   * Creates a new immutable `GeoPoint` object with the provided latitude and
   * longitude values.
   * @param latitude - The latitude as number between -90 and 90.
   * @param longitude - The longitude as number between -180 and 180.
   */
  constructor(e, t) {
    if (!isFinite(e) || e < -90 || e > 90) throw new se(le, 'Latitude must be a number between -90 and 90, but was: ' + e);
    if (!isFinite(t) || t < -180 || t > 180) throw new se(le, 'Longitude must be a number between -180 and 180, but was: ' + t);
    (this._lat = e), (this._long = t);
  }
  /**
   * The latitude of this `GeoPoint` instance.
   */
  get latitude() {
    return this._lat;
  }
  /**
   * The longitude of this `GeoPoint` instance.
   */
  get longitude() {
    return this._long;
  }
  /**
   * Returns true if this `GeoPoint` is equal to the provided one.
   *
   * @param other - The `GeoPoint` to compare against.
   * @returns true if this `GeoPoint` is equal to the provided one.
   */
  isEqual(e) {
    return this._lat === e._lat && this._long === e._long;
  }
  /** Returns a JSON-serializable representation of this GeoPoint. */
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long,
    };
  }
  /**
   * Actually private to JS consumers of our API, so this function is prefixed
   * with an underscore.
   */
  _compareTo(e) {
    return qt(this._lat, e._lat) || qt(this._long, e._long);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CO = /^__.*__$/;
class SO {
  constructor(e, t, r) {
    (this.data = e), (this.fieldMask = t), (this.fieldTransforms = r);
  }
  toMutation(e, t) {
    return this.fieldMask !== null ? new v0(e, this.data, this.fieldMask, t, this.fieldTransforms) : new K5(e, this.data, t, this.fieldTransforms);
  }
}
class Q5 {
  constructor(e, t, r) {
    (this.data = e), (this.fieldMask = t), (this.fieldTransforms = r);
  }
  toMutation(e, t) {
    return new v0(e, this.data, this.fieldMask, t, this.fieldTransforms);
  }
}
function Y5(n) {
  switch (n) {
    case 0:
    case 2:
    case 1:
      return !0;
    case 3:
    case 4:
      return !1;
    default:
      throw Rt();
  }
}
class E0 {
  /**
   * Initializes a ParseContext with the given source and path.
   *
   * @param settings - The settings for the parser.
   * @param databaseId - The database ID of the Firestore instance.
   * @param serializer - The serializer to use to generate the Value proto.
   * @param ignoreUndefinedProperties - Whether to ignore undefined properties
   * rather than throw.
   * @param fieldTransforms - A mutable list of field transforms encountered
   * while parsing the data.
   * @param fieldMask - A mutable list of field paths encountered while parsing
   * the data.
   *
   * TODO(b/34871131): We don't support array paths right now, so path can be
   * null to indicate the context represents any location within an array (in
   * which case certain features will not work and errors will be somewhat
   * compromised).
   */
  constructor(e, t, r, i, s, a) {
    (this.settings = e),
      (this.databaseId = t),
      (this.serializer = r),
      (this.ignoreUndefinedProperties = i), // Minor hack: If fieldTransforms is undefined, we assume this is an
      // external call and we need to validate the entire path.
      s === void 0 && this.tt(),
      (this.fieldTransforms = s || []),
      (this.fieldMask = a || []);
  }
  get path() {
    return this.settings.path;
  }
  get et() {
    return this.settings.et;
  }
  /** Returns a new context with the specified settings overwritten. */
  nt(e) {
    return new E0(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  rt(e) {
    var t;
    const r = (t = this.path) === null || t === void 0 ? void 0 : t.child(e),
      i = this.nt({
        path: r,
        st: !1,
      });
    return i.it(e), i;
  }
  ot(e) {
    var t;
    const r = (t = this.path) === null || t === void 0 ? void 0 : t.child(e),
      i = this.nt({
        path: r,
        st: !1,
      });
    return i.tt(), i;
  }
  ut(e) {
    return this.nt({
      path: void 0,
      st: !0,
    });
  }
  ct(e) {
    return md(e, this.settings.methodName, this.settings.at || !1, this.path, this.settings.ht);
  }
  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
  contains(e) {
    return this.fieldMask.find((t) => e.isPrefixOf(t)) !== void 0 || this.fieldTransforms.find((t) => e.isPrefixOf(t.field)) !== void 0;
  }
  tt() {
    if (this.path) for (let e = 0; e < this.path.length; e++) this.it(this.path.get(e));
  }
  it(e) {
    if (e.length === 0) throw this.ct('Document fields must not be empty');
    if (Y5(this.et) && CO.test(e)) throw this.ct('Document fields cannot begin and end with "__"');
  }
}
class MO {
  constructor(e, t, r) {
    (this.databaseId = e), (this.ignoreUndefinedProperties = t), (this.serializer = r || T0(e));
  }
  /** Creates a new top-level parse context. */
  lt(e, t, r, i = !1) {
    return new E0(
      {
        et: e,
        methodName: t,
        ht: r,
        path: Kn.emptyPath(),
        st: !1,
        at: i,
      },
      this.databaseId,
      this.serializer,
      this.ignoreUndefinedProperties,
    );
  }
}
function C0(n) {
  const e = n._freezeSettings(),
    t = T0(n._databaseId);
  return new MO(n._databaseId, !!e.ignoreUndefinedProperties, t);
}
function X5(n, e, t, r, i, s = {}) {
  const a = n.lt(s.merge || s.mergeFields ? 2 : 0, e, t, i);
  S0('Data must be an object, but it was:', a, r);
  const o = Z5(r, a);
  let u, l;
  if (s.merge) (u = new ya(a.fieldMask)), (l = a.fieldTransforms);
  else if (s.mergeFields) {
    const p = [];
    for (const h of s.mergeFields) {
      const b = Sh(e, h, t);
      if (!a.contains(b)) throw new se(le, `Field '${b}' is specified in your field mask but missing from your input data.`);
      tw(p, b) || p.push(b);
    }
    (u = new ya(p)), (l = a.fieldTransforms.filter((h) => u.covers(h.field)));
  } else (u = null), (l = a.fieldTransforms);
  return new SO(new ir(o), u, l);
}
class np extends ep {
  _toFieldTransform(e) {
    if (e.et !== 2)
      throw e.et === 1 ? e.ct(`${this._methodName}() can only appear at the top level of your update data`) : e.ct(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return e.fieldMask.push(e.path), null;
  }
  isEqual(e) {
    return e instanceof np;
  }
}
function _O(n, e, t, r) {
  const i = n.lt(1, e, t);
  S0('Data must be an object, but it was:', i, r);
  const s = [],
    a = ir.empty();
  El(r, (u, l) => {
    const p = M0(e, u, t);
    l = ei(l);
    const h = i.ot(p);
    if (l instanceof np) s.push(p);
    else {
      const b = Ml(l, h);
      b != null && (s.push(p), a.set(p, b));
    }
  });
  const o = new ya(s);
  return new Q5(a, o, i.fieldTransforms);
}
function RO(n, e, t, r, i, s) {
  const a = n.lt(1, e, t),
    o = [Sh(e, r, t)],
    u = [i];
  if (s.length % 2 != 0) throw new se(le, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let b = 0; b < s.length; b += 2) o.push(Sh(e, s[b])), u.push(s[b + 1]);
  const l = [],
    p = ir.empty();
  for (let b = o.length - 1; b >= 0; --b)
    if (!tw(l, o[b])) {
      const E = o[b];
      let x = u[b];
      x = ei(x);
      const T = a.ot(E);
      if (x instanceof np) l.push(E);
      else {
        const w = Ml(x, T);
        w != null && (l.push(E), p.set(E, w));
      }
    }
  const h = new ya(l);
  return new Q5(p, h, a.fieldTransforms);
}
function PO(n, e, t, r = !1) {
  return Ml(t, n.lt(r ? 4 : 3, e));
}
function Ml(n, e) {
  if (
    ew(
      // Unwrap the API type from the Compat SDK. This will return the API type
      // from firestore-exp.
      (n = ei(n)),
    )
  )
    return S0('Unsupported field value:', e, n), Z5(n, e);
  if (n instanceof ep)
    return (
      (function (t, r) {
        if (!Y5(r.et)) throw r.ct(`${t._methodName}() can only be used with update() and set()`);
        if (!r.path) throw r.ct(`${t._methodName}() is not currently supported inside arrays`);
        const i = t._toFieldTransform(r);
        i && r.fieldTransforms.push(i);
      })(n, e),
      null
    );
  if (n === void 0 && e.ignoreUndefinedProperties) return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    (e.path && e.fieldMask.push(e.path), n instanceof Array)
  ) {
    if (e.settings.st && e.et !== 4) throw e.ct('Nested arrays are not supported');
    return (function (t, r) {
      const i = [];
      let s = 0;
      for (const a of t) {
        let o = Ml(a, r.ut(s));
        o == null && // Just include nulls in the array for fields being replaced with a
          // sentinel.
          (o = {
            nullValue: 'NULL_VALUE',
          }),
          i.push(o),
          s++;
      }
      return {
        arrayValue: {
          values: i,
        },
      };
    })(n, e);
  }
  return (function (t, r) {
    if ((t = ei(t)) === null)
      return {
        nullValue: 'NULL_VALUE',
      };
    if (typeof t == 'number') return nO(r.serializer, t);
    if (typeof t == 'boolean')
      return {
        booleanValue: t,
      };
    if (typeof t == 'string')
      return {
        stringValue: t,
      };
    if (t instanceof Date) {
      const i = Bn.fromDate(t);
      return {
        timestampValue: Ah(r.serializer, i),
      };
    }
    if (t instanceof Bn) {
      const i = new Bn(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3));
      return {
        timestampValue: Ah(r.serializer, i),
      };
    }
    if (t instanceof tp)
      return {
        geoPointValue: {
          latitude: t.latitude,
          longitude: t.longitude,
        },
      };
    if (t instanceof ma)
      return {
        bytesValue: pO(r.serializer, t._byteString),
      };
    if (t instanceof Tn) {
      const i = r.databaseId,
        s = t.firestore._databaseId;
      if (!s.isEqual(i)) throw r.ct(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${i.projectId}/${i.database}`);
      return {
        referenceValue: w0(t.firestore._databaseId || r.databaseId, t._key.path),
      };
    }
    throw r.ct(`Unsupported field value: ${Jd(t)}`);
  })(n, e);
}
function Z5(n, e) {
  const t = {};
  return (
    (function (r) {
      for (const i in r) if (Object.prototype.hasOwnProperty.call(r, i)) return !1;
      return !0;
    })(n)
      ? // If we encounter an empty object, we explicitly add it to the update
        // mask to ensure that the server creates a map entry.
        e.path && e.path.length > 0 && e.fieldMask.push(e.path)
      : El(n, (r, i) => {
          const s = Ml(i, e.rt(r));
          s != null && (t[r] = s);
        }),
    {
      mapValue: {
        fields: t,
      },
    }
  );
}
function ew(n) {
  return !(typeof n != 'object' || n === null || n instanceof Array || n instanceof Date || n instanceof Bn || n instanceof tp || n instanceof ma || n instanceof Tn || n instanceof ep);
}
function S0(n, e, t) {
  if (
    !ew(t) ||
    !(function (r) {
      return typeof r == 'object' && r !== null && (Object.getPrototypeOf(r) === Object.prototype || Object.getPrototypeOf(r) === null);
    })(t)
  ) {
    const r = Jd(t);
    throw r === 'an object' ? e.ct(n + ' a custom object') : e.ct(n + ' ' + r);
  }
}
function Sh(n, e, t) {
  if (
    // If required, replace the FieldPath Compat class with with the firestore-exp
    // FieldPath.
    (e = ei(e)) instanceof Sl
  )
    return e._internalPath;
  if (typeof e == 'string') return M0(n, e);
  throw md(
    'Field path arguments must be of type string or ',
    n,
    /* hasConverter= */
    !1,
    /* path= */
    void 0,
    t,
  );
}
const IO = new RegExp('[~\\*/\\[\\]]');
function M0(n, e, t) {
  if (e.search(IO) >= 0)
    throw md(
      `Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,
      n,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      t,
    );
  try {
    return new Sl(...e.split('.'))._internalPath;
  } catch {
    throw md(
      `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      n,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      t,
    );
  }
}
function md(n, e, t, r, i) {
  const s = r && !r.isEmpty(),
    a = i !== void 0;
  let o = `Function ${e}() called with invalid data`;
  t && (o += ' (via `toFirestore()`)'), (o += '. ');
  let u = '';
  return (s || a) && ((u += ' (found'), s && (u += ` in field ${r}`), a && (u += ` in document ${i}`), (u += ')')), new se(le, o + n + u);
}
function tw(n, e) {
  return n.some((t) => t.isEqual(e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class nw {
  // Note: This class is stripped down version of the DocumentSnapshot in
  // the legacy SDK. The changes are:
  // - No support for SnapshotMetadata.
  // - No support for SnapshotOptions.
  /** @hideconstructor protected */
  constructor(e, t, r, i, s) {
    (this._firestore = e), (this._userDataWriter = t), (this._key = r), (this._document = i), (this._converter = s);
  }
  /** Property of the `DocumentSnapshot` that provides the document's ID. */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * The `DocumentReference` for the document included in the `DocumentSnapshot`.
   */
  get ref() {
    return new Tn(this._firestore, this._converter, this._key);
  }
  /**
   * Signals whether or not the document at the snapshot's location exists.
   *
   * @returns true if the document exists.
   */
  exists() {
    return this._document !== null;
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * @returns An `Object` containing all fields in the document or `undefined`
   * if the document doesn't exist.
   */
  data() {
    if (this._document) {
      if (this._converter) {
        const e = new _0(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          /* converter= */
          null,
        );
        return this._converter.fromFirestore(e);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(e) {
    if (this._document) {
      const t = this._document.data.field(R0('DocumentSnapshot.get', e));
      if (t !== null) return this._userDataWriter.convertValue(t);
    }
  }
}
class _0 extends nw {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * @override
   * @returns An `Object` containing all fields in the document.
   */
  data() {
    return super.data();
  }
}
class rw {
  /** @hideconstructor */
  constructor(e, t) {
    (this._docs = t), (this.query = e);
  }
  /** An array of all the documents in the `QuerySnapshot`. */
  get docs() {
    return [...this._docs];
  }
  /** The number of documents in the `QuerySnapshot`. */
  get size() {
    return this.docs.length;
  }
  /** True if there are no documents in the `QuerySnapshot`. */
  get empty() {
    return this.docs.length === 0;
  }
  /**
   * Enumerates all of the documents in the `QuerySnapshot`.
   *
   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
   * each document in the snapshot.
   * @param thisArg - The `this` binding for the callback.
   */
  forEach(e, t) {
    this._docs.forEach(e, t);
  }
}
function R0(n, e) {
  return typeof e == 'string' ? M0(n, e) : e instanceof Sl ? e._internalPath : e._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class P0 {}
class I0 extends P0 {}
function iw(n, e, ...t) {
  let r = [];
  e instanceof P0 && r.push(e),
    (r = r.concat(t)),
    (function (i) {
      const s = i.filter((o) => o instanceof rp).length,
        a = i.filter((o) => o instanceof _l).length;
      if (s > 1 || (s > 0 && a > 0))
        throw new se(
          le,
          'InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.',
        );
    })(r);
  for (const i of r) n = i._apply(n);
  return n;
}
class _l extends I0 {
  /**
   * @internal
   */
  constructor(e, t, r) {
    super(), (this._field = e), (this._op = t), (this._value = r) /** The type of this query constraint */, (this.type = 'where');
  }
  static _create(e, t, r) {
    return new _l(e, t, r);
  }
  _apply(e) {
    const t = this._parse(e);
    return aw(e._query, t), new As(e.firestore, e.converter, Th(e._query, t));
  }
  _parse(e) {
    const t = C0(e.firestore);
    return (function (i, s, a, o, u, l, p) {
      let h;
      if (u.isKeyField()) {
        if (l === 'array-contains' || l === 'array-contains-any') throw new se(le, `Invalid Query. You can't perform '${l}' queries on documentId().`);
        if (l === 'in' || l === 'not-in') {
          av(p, l);
          const b = [];
          for (const E of p) b.push(sv(o, i, E));
          h = {
            arrayValue: {
              values: b,
            },
          };
        } else h = sv(o, i, p);
      } else
        (l !== 'in' && l !== 'not-in' && l !== 'array-contains-any') || av(p, l),
          (h = PO(
            a,
            s,
            p,
            /* allowArrays= */
            l === 'in' || l === 'not-in',
          ));
      return kr.create(u, l, h);
    })(e._query, 'where', t, e.firestore._databaseId, this._field, this._op, this._value);
  }
}
function sw(n, e, t) {
  const r = e,
    i = R0('where', n);
  return _l._create(i, r, t);
}
class rp extends P0 {
  /**
   * @internal
   */
  constructor(e, t) {
    super(), (this.type = e), (this._queryConstraints = t);
  }
  static _create(e, t) {
    return new rp(e, t);
  }
  _parse(e) {
    const t = this._queryConstraints.map((r) => r._parse(e)).filter((r) => r.getFilters().length > 0);
    return t.length === 1 ? t[0] : Cl.create(t, this._getOperator());
  }
  _apply(e) {
    const t = this._parse(e);
    return t.getFilters().length === 0
      ? e
      : ((function (r, i) {
          let s = r;
          const a = i.getFlattenedFilters();
          for (const o of a) aw(s, o), (s = Th(s, o));
        })(e._query, t),
        new As(e.firestore, e.converter, Th(e._query, t)));
  }
  _getQueryConstraints() {
    return this._queryConstraints;
  }
  _getOperator() {
    return this.type === 'and' ? 'and' : 'or';
  }
}
class ip extends I0 {
  /**
   * @internal
   */
  constructor(e, t) {
    super(), (this._field = e), (this._direction = t) /** The type of this query constraint */, (this.type = 'orderBy');
  }
  static _create(e, t) {
    return new ip(e, t);
  }
  _apply(e) {
    const t = (function (r, i, s) {
      if (r.startAt !== null) throw new se(le, 'Invalid query. You must not call startAt() or startAfter() before calling orderBy().');
      if (r.endAt !== null) throw new se(le, 'Invalid query. You must not call endAt() or endBefore() before calling orderBy().');
      const a = new gu(i, s);
      return (
        (function (o, u) {
          if (g0(o) === null) {
            const l = Qd(o);
            l !== null && ow(o, l, u.field);
          }
        })(r, a),
        a
      );
    })(e._query, this._field, this._direction);
    return new As(
      e.firestore,
      e.converter,
      (function (r, i) {
        const s = r.explicitOrderBy.concat([i]);
        return new b0(r.path, r.collectionGroup, s, r.filters.slice(), r.limit, r.limitType, r.startAt, r.endAt);
      })(e._query, t),
    );
  }
}
function kO(n, e = 'asc') {
  const t = e,
    r = R0('orderBy', n);
  return ip._create(r, t);
}
function sv(n, e, t) {
  if (typeof (t = ei(t)) == 'string') {
    if (t === '') throw new se(le, 'Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.');
    if (!eO(e) && t.indexOf('/') !== -1) throw new se(le, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${t}' contains a '/' character.`);
    const r = e.path.child(Gt.fromString(t));
    if (!rn.isDocumentKey(r))
      throw new se(
        le,
        `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`,
      );
    return W2(n, new rn(r));
  }
  if (t instanceof Tn) return W2(n, t._key);
  throw new se(le, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${Jd(t)}.`);
}
function av(n, e) {
  if (!Array.isArray(n) || n.length === 0) throw new se(le, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
}
function aw(n, e) {
  if (e.isInequality()) {
    const r = Qd(n),
      i = e.field;
    if (r !== null && !r.isEqual(i))
      throw new se(
        le,
        `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${r.toString()}' and '${i.toString()}'`,
      );
    const s = g0(n);
    s !== null && ow(n, i, s);
  }
  const t = (function (r, i) {
    for (const s of r) for (const a of s.getFlattenedFilters()) if (i.indexOf(a.op) >= 0) return a.op;
    return null;
  })(
    n.filters,
    (function (r) {
      switch (r) {
        case '!=':
          return [
            '!=',
            'not-in',
            /* Operator.NOT_IN */
          ];
        case 'array-contains-any':
        case 'in':
          return [
            'not-in',
            /* Operator.NOT_IN */
          ];
        case 'not-in':
          return [
            'array-contains-any',
            'in',
            'not-in',
            '!=',
            /* Operator.NOT_EQUAL */
          ];
        default:
          return [];
      }
    })(e.op),
  );
  if (t !== null)
    throw t === e.op
      ? new se(le, `Invalid query. You cannot use more than one '${e.op.toString()}' filter.`)
      : new se(le, `Invalid query. You cannot use '${e.op.toString()}' filters with '${t.toString()}' filters.`);
}
function ow(n, e, t) {
  if (!t.isEqual(e))
    throw new se(
      le,
      `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${t.toString()}' instead.`,
    );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function uw(n, e, t) {
  let r;
  return (r = n ? (t && (t.merge || t.mergeFields) ? n.toFirestore(e, t) : n.toFirestore(e)) : e), r;
}
class OO extends class {
  convertValue(e, t = 'none') {
    switch (ha(e)) {
      case 0:
        return null;
      case 1:
        return e.booleanValue;
      case 2:
        return Vt(e.integerValue || e.doubleValue);
      case 3:
        return this.convertTimestamp(e.timestampValue);
      case 4:
        return this.convertServerTimestamp(e, t);
      case 5:
        return e.stringValue;
      case 6:
        return this.convertBytes(Qu(e.bytesValue));
      case 7:
        return this.convertReference(e.referenceValue);
      case 8:
        return this.convertGeoPoint(e.geoPointValue);
      case 9:
        return this.convertArray(e.arrayValue, t);
      case 10:
        return this.convertObject(e.mapValue, t);
      default:
        throw Rt();
    }
  }
  convertObject(e, t) {
    const r = {};
    return (
      El(e.fields, (i, s) => {
        r[i] = this.convertValue(s, t);
      }),
      r
    );
  }
  convertGeoPoint(e) {
    return new tp(Vt(e.latitude), Vt(e.longitude));
  }
  convertArray(e, t) {
    return (e.values || []).map((r) => this.convertValue(r, t));
  }
  convertServerTimestamp(e, t) {
    switch (t) {
      case 'previous':
        const r = V5(e);
        return r == null ? null : this.convertValue(r, t);
      case 'estimate':
        return this.convertTimestamp(Yu(e));
      default:
        return null;
    }
  }
  convertTimestamp(e) {
    const t = fa(e);
    return new Bn(t.seconds, t.nanos);
  }
  convertDocumentKey(e, t) {
    const r = Gt.fromString(e);
    bs(W5(r));
    const i = new Wu(r.get(1), r.get(3)),
      s = new rn(r.popFirst(5));
    return (
      i.isEqual(t) || // TODO(b/64130202): Somehow support foreign references.
        y0(
          `Document ${s} contains a document reference within a different database (${i.projectId}/${i.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`,
        ),
      s
    );
  }
} {
  constructor(e) {
    super(), (this.firestore = e);
  }
  convertBytes(e) {
    return new ma(e);
  }
  convertReference(e) {
    const t = this.convertDocumentKey(e, this.firestore._databaseId);
    return new Tn(
      this.firestore,
      /* converter= */
      null,
      t,
    );
  }
}
function Mh(n) {
  (function (r) {
    if (r.limitType === 'L' && r.explicitOrderBy.length === 0) throw new se(F5, 'limitToLast() queries require specifying at least one orderBy() clause');
  })((n = Al(n, As))._query);
  const e = Zd(n.firestore),
    t = new OO(n.firestore);
  return AO(e, n._query).then((r) => {
    const i = r.map((s) => new _0(n.firestore, t, s.key, s, n.converter));
    return (
      n._query.limitType === 'L' && // Limit to last queries reverse the orderBy constraint that was
        // specified by the user. As such, we need to reverse the order of the
        // results to return the documents in the expected order.
        i.reverse(),
      new rw(n, i)
    );
  });
}
function _h(n, e, t) {
  const r = uw((n = Al(n, Tn)).converter, e, t),
    i = X5(C0(n.firestore), 'setDoc', n._key, r, n.converter !== null, t);
  return A0(Zd(n.firestore), [i.toMutation(n._key, wi.none())]);
}
function lw(n) {
  return A0(Zd((n = Al(n, Tn)).firestore), [new x0(n._key, wi.none())]);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cw {
  /** @hideconstructor */
  constructor(e, t) {
    (this._firestore = e), (this._commitHandler = t), (this._mutations = []), (this._committed = !1), (this._dataReader = C0(e));
  }
  set(e, t, r) {
    this._verifyNotCommitted();
    const i = hf(e, this._firestore),
      s = uw(i.converter, t, r),
      a = X5(this._dataReader, 'WriteBatch.set', i._key, s, i.converter !== null, r);
    return this._mutations.push(a.toMutation(i._key, wi.none())), this;
  }
  update(e, t, r, ...i) {
    this._verifyNotCommitted();
    const s = hf(e, this._firestore);
    let a;
    return (
      (a = typeof (t = ei(t)) == 'string' || t instanceof Sl ? RO(this._dataReader, 'WriteBatch.update', s._key, t, r, i) : _O(this._dataReader, 'WriteBatch.update', s._key, t)),
      this._mutations.push(a.toMutation(s._key, wi.exists(!0))),
      this
    );
  }
  /**
   * Deletes the document referred to by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be deleted.
   * @returns This `WriteBatch` instance. Used for chaining method calls.
   */
  delete(e) {
    this._verifyNotCommitted();
    const t = hf(e, this._firestore);
    return (this._mutations = this._mutations.concat(new x0(t._key, wi.none()))), this;
  }
  /**
   * Commits all of the writes in this write batch as a single atomic unit.
   *
   * The result of these writes will only be reflected in document reads that
   * occur after the returned promise resolves. If the client is offline, the
   * write fails. If you would like to see local modifications or buffer writes
   * until the client is online, use the full Firestore SDK.
   *
   * @returns A `Promise` resolved once all of the writes in the batch have been
   * successfully written to the backend as an atomic unit (note that it won't
   * resolve while you're offline).
   */
  commit() {
    return this._verifyNotCommitted(), (this._committed = !0), this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed) throw new se(pa, 'A write batch can no longer be used after commit() has been called.');
  }
}
function hf(n, e) {
  if ((n = ei(n)).firestore !== e) throw new se(le, 'Provided document reference is from a different Firestore instance.');
  return n;
}
function dw(n) {
  const e = Zd((n = Al(n, Fo)));
  return new cw(n, (t) => A0(e, t));
}
(function (n) {
  Do = n;
})(`${ok}_lite`),
  ld(
    new Ku(
      'firestore/lite',
      (n, { instanceIdentifier: e, options: t }) => {
        const r = n.getProvider('app').getImmediate(),
          i = new Fo(
            new Ik(n.getProvider('auth-internal')),
            new Nk(n.getProvider('app-check-internal')),
            (function (s, a) {
              if (!Object.prototype.hasOwnProperty.apply(s.options, ['projectId'])) throw new se(le, '"projectId" not provided in firebase.initializeApp.');
              return new Wu(s.options.projectId, a);
            })(r, e),
            r,
          );
        return t && i._setSettings(t), i;
      },
      'PUBLIC',
    ).setMultipleInstances(!0),
  ), // RUNTIME_ENV and BUILD_TARGET are replaced by real values during the compilation
  to('firestore-lite', '3.10.1', ''),
  to('firestore-lite', '3.10.1', 'esm2017');
const ov = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      Bytes: ma,
      CollectionReference: Ti,
      DocumentReference: Tn,
      DocumentSnapshot: nw,
      FieldPath: Sl,
      FieldValue: ep,
      Firestore: Fo,
      FirestoreError: se,
      GeoPoint: tp,
      Query: As,
      QueryCompositeFilterConstraint: rp,
      QueryConstraint: I0,
      QueryDocumentSnapshot: _0,
      QueryFieldFilterConstraint: _l,
      QueryOrderByConstraint: ip,
      QuerySnapshot: rw,
      Timestamp: Bn,
      WriteBatch: cw,
      collection: Ch,
      connectFirestoreEmulator: J5,
      deleteDoc: lw,
      doc: vc,
      getDocs: Mh,
      getFirestore: EO,
      orderBy: kO,
      query: iw,
      setDoc: _h,
      where: sw,
      writeBatch: dw,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
var Ht = /* @__PURE__ */ ((n) => ((n[(n.minute = 0)] = 'minute'), (n[(n.hour = 1)] = 'hour'), (n[(n.day = 2)] = 'day'), n))(Ht || {});
const yf = he
    .createContainer()
    .register(fe.instance(V6, O5({ ...LE, apiKey: globalThis.process.env.FIREBASE_API_KEY })))
    .register(fe.instance(Zy, {}))
    .register(co)
    .register(Gu)
    .register(fe.instance(UP, {}))
    .register(fe.instance(c0, {}))
    .register(fe.instance(e0, { lsGet: () => '', lsSet: () => '' }))
    .register($u)
    .register(sd)
    .register(po)
    .register(ad)
    .register(
      fe.instance(
        kd,
        new HP(
          { url: Eg, skipFetchSetup: !0 },
          {
            name: Cg.toLowerCase(),
            chainId: Ag,
          },
        ),
      ),
    )
    .register(
      fe.instance(Ea, {
        chainId: Ag,
        ipfsGateway: $E,
        chainUrl: Eg,
        chain: Cg,
        isDevelopment: !1,
        scanLink: UE,
        firebaseCollection: La,
      }),
    )
    .register(Id)
    .register(Hu)
    .register(ca)
    .register(
      fe.instance(j6, {
        tokens: A_,
      }),
    )
    .register(Uu)
    .register(fe.instance(Aa, { uf: (n) => Number(n) }))
    .register(
      fe.instance(ga, {}),
      fe.instance(wd, {}),
      fe.instance(ba, {
        scopeTo: () => {},
      }),
    ),
  BO = async () => {
    let n = !1;
    const e = 5,
      t = 1,
      r = 1;
    let i = '';
    const s = yf.get(A5);
    let a = '',
      o = 0,
      u = 0,
      l = 0,
      p = 0,
      h = 0,
      b = 0,
      E = 0,
      x = 0,
      T = 0,
      w = 0,
      _,
      k = 0,
      D = 0,
      N = 0,
      B = 0,
      j = 0;
    const z = await yf.get(Yy).connect(),
      Y = Object.values(Ht)
        .filter((A) => typeof A == 'number')
        .map((A) => A),
      ae = async (A) => {
        const M = Ch(z, `${La}/lastSync/${A}`);
        return (await Mh(M)).docs[0]?.id;
      },
      J = async (A, M, P) => {
        P && (await lw(vc(z, `${La}/lastSync/${A}/${P}`))), await _h(vc(z, `${La}/lastSync/${A}`, M.toString()), {});
      },
      oe = async (A, M, P, m) => {
        let d = m;
        typeof d != 'object' && (d = { value: m }), (d.createdAt = P), await _h(vc(z, `${La}/${A}/${M}`, P.toString()), d);
      },
      S = async (A, M, P) => {
        const m = dw(z);
        (await Mh(iw(Ch(z, `${La}/${A}/${M}`), sw('createdAt', '<', P)))).forEach((g) => m.delete(g.ref)), await m.commit();
      },
      c = async () => (await (await yf.get(C5).getTreasuryContract()).totalValuation()).toHexString(),
      y = async () => {
        await s.loadAssets(), await s.loadkCur();
      },
      v = (A) => {
        const M = /* @__PURE__ */ new Date();
        switch (A) {
          case 0:
            M.setMinutes(M.getMinutes() - 60, 0, 0);
            break;
          case 1:
            M.setHours(M.getHours() - 24, 0, 0, 0);
            break;
          case 2:
            return Number.MIN_VALUE;
        }
        return M.getTime();
      },
      C = async () => {
        (i = await c()),
          await y(),
          (a = s.reserveValue?.toHexString() ?? ''),
          (o = s.currentLeverageRatio),
          (u = s.maxLeverageRatio),
          (l = s.kCurPrice ?? 0),
          (p = s.kCurPriceCeiling),
          (h = s.kCurPriceFloor),
          (b = s.kCurReserveDistribution ?? 0),
          (E = s.kCurMentoDistribution ?? 0),
          (x = s.kCurPrimaryPoolDistribution ?? 0),
          (T = s.kCurCirculatingDistribution),
          (k = s.minCollateralizationValue),
          (D = s.kCurTotalValue),
          (N = s.lowRiskAssets.map((A) => A.total).sum()),
          (B = s.moderateRiskAssets.map((A) => A.total).sum()),
          (j = s.highRiskAssets.map((A) => A.total).sum()),
          (w = s.kGuilderValueRatio);
      };
    await Promise.all(
      Y.map(async (A) => {
        const M = await ae(Ht[A]),
          P = /* @__PURE__ */ new Date();
        let m = /* @__PURE__ */ new Date();
        if (
          (M && (m = new Date(Number(M))),
          A === 0
            ? (m.setUTCMinutes(m.getUTCMinutes() + e), m.setUTCSeconds(0, 0))
            : A === 1
            ? (m.setUTCHours(m.getUTCHours() + t), m.setUTCMinutes(0, 0, 0))
            : (m.setUTCDate(m.getUTCDate() + r), m.setUTCHours(0, 0, 0, 0)),
          P >= m || !M)
        ) {
          let d = /* @__PURE__ */ new Date();
          if (A === 0) {
            const g = 6e4 * e;
            d = new Date(Math.floor(P.getTime() / g) * g);
          } else A === 1 ? d.setUTCMinutes(0, 0, 0) : d.setUTCHours(0, 0, 0, 0);
          n || ((n = !0), (_ = C())),
            _?.then(async () => {
              await oe('kCurPrice', Ht[A], d.getTime(), { kCurPrice: l, kCurPriceCeiling: p, kCurPriceFloor: h }),
                await oe('kCurRatio', Ht[A], d.getTime(), { currentLeverageRatio: o, maxLeverageRatio: u }),
                await oe('kCurSupply', Ht[A], d.getTime(), {
                  kCurReserveDistribution: b,
                  kCurMentoDistribution: E,
                  kCurPrimaryPoolDistribution: x,
                  kCurCirculatingDistribution: T,
                }),
                await oe('ktt', Ht[A], d.getTime(), i),
                await oe('reserve', Ht[A], d.getTime(), a),
                await oe('risk', Ht[A], d.getTime(), {
                  minCollateralValue: k,
                  marketCap: D,
                  lowRisk: N,
                  moderateRisk: B,
                  highRisk: j,
                }),
                await oe('kGuilder', Ht[A], d.getTime(), w),
                await J(Ht[A], d.getTime(), M);
              const g = v(A);
              await S('kCurPrice', Ht[A], g),
                await S('kCurRatio', Ht[A], g),
                await S('kCurSupply', Ht[A], g),
                await S('ktt', Ht[A], g),
                await S('reserve', Ht[A], g),
                await S('risk', Ht[A], g),
                await S('kGuilder', Ht[A], g);
            });
        }
      }),
    );
  };
await BO();
