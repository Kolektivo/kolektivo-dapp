const c5 = 'celo',
  p5 = 42220,
  f5 = {
    monetaryBadger: {
      abi: 'Badger',
      address: '0x391002f0b25Fb2AdAFeDcD1EA1C97834FCD59CDD',
    },
    kolektivoBadger: {
      abi: 'Badger',
      address: '0x203EFD61908cA90bF0A5984f6754DB0e58162B88',
    },
    bacMD: {
      abi: 'BACRoles',
      address: '0x34886b875E588c412574426a9675e33b64d5Dd59',
    },
    bacFFD: {
      abi: 'BACRoles',
      address: '0x9D5C5a439E6edDb34562087D83f0A58DCC5672d7',
    },
    bacMC: {
      abi: 'BACRoles',
      address: '0xF3Fd37f7F54BFeF2cdA043B57e132006b6a44E47',
    },
    bacK: {
      abi: 'BACRoles',
      address: '0x659248bc8f8Ee7937a0e9f018dc5e8fFEe3A68Fd',
    },
    reserveDelegateScope: {
      abi: 'ScopeGuard',
      address: '0x2a016330C0e5169FA5C44A4f5C73E76B2543CFBa',
    },
    foodForestDelegateScope: {
      abi: 'ScopeGuard',
      address: '0xF22d9617d2B4d8DacDD708aF6615c5Af72b6a861',
    },
    monetaryMultisigScope: {
      abi: 'ScopeGuard',
      address: '0x06E26e99470462B0a75760B50685cf4bE084005B',
    },
    monetaryDelay: {
      abi: 'SecretDelay',
      address: '0x5bfD3A6c4a579A1F20d2652633cCAce90d9db62F',
    },
    foodForestDelay: {
      abi: 'SecretDelay',
      address: '0x28DD09637872D94b9Bac33041B3A9482E1904A4B',
    },
    kolektivoDelay: {
      abi: 'SecretDelay',
      address: '0xb846c1B4A959be7a666f3882Fd3F70019ccFA408',
    },
  },
  $D = {
    name: c5,
    chainId: p5,
    contracts: f5,
  },
  UD = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        chainId: p5,
        contracts: f5,
        default: $D,
        name: c5,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  y5 = 'celo',
  h5 = '42220',
  m5 = {
    GeoNFT: {
      address: '0x9fC5461A1e6CF567C7E19Befa7c0351C9C6CB719',
      abi: [
        {
          inputs: [
            {
              internalType: 'string',
              name: '_name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: '_symbol',
              type: 'string',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidIdentifier',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidLatitude',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidLongitude',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidTokenId',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'approved',
              type: 'bool',
            },
          ],
          name: 'ApprovalForAll',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'TokenModified',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'getApproved',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isApprovedForAll',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'int32',
              name: 'latitude',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: 'longitude',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'mint',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'int32',
              name: 'latitude',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: 'longitude',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'modify',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ownerOf',
          outputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'safeTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'safeTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              internalType: 'bool',
              name: 'approved',
              type: 'bool',
            },
          ],
          name: 'setApprovalForAll',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'interfaceId',
              type: 'bytes4',
            },
          ],
          name: 'supportsInterface',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'tokenData',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'int32',
              name: '',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: '',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'tokenURI',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Oracle: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'reportExpirationTime_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'reportDelay_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minimumProviders_',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'invalidProvider',
              type: 'address',
            },
          ],
          name: 'Oracle__InvalidProvider',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Oracle__NewReportTooSoonAfterPastReport',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldMinimumProviders',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newMinimumProviders',
              type: 'uint256',
            },
          ],
          name: 'MinimumProvidersChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [],
          name: 'OracleMarkedAsInvalid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [],
          name: 'OracleMarkedAsValid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
          ],
          name: 'ProviderReportPushed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'purger',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderReportsPurged',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'addProvider',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getData',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'isValid',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minimumProviders',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'providerReports',
          outputs: [
            {
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'providers',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'providersSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'purgeReports',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'purgeReportsFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
          ],
          name: 'pushReport',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'removeProvider',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportDelay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportExpirationTime',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isValid_',
              type: 'bool',
            },
          ],
          name: 'setIsValid',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'minimumProviders_',
              type: 'uint256',
            },
          ],
          name: 'setMinimumProviders',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Reserve: {
      address: '0x27C5f567443991DE535E202a4a9B6Abf24e66Da9',
      abi: [
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'tokenOracle_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'vestingVault_',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'minBacking_',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20BalanceNotSufficient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20BondingLimitExceeded',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotBondable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotRedeemable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotRegistered',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20RedeemLimitExceeded',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotBondable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotRedeemable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotRegistered',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidOracle',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__MinimumBackingLimitExceeded',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldBacking',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newBacking',
              type: 'uint256',
            },
          ],
          name: 'BackingUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sBonded',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensMinted',
              type: 'uint256',
            },
          ],
          name: 'BondedERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensMinted',
              type: 'uint256',
            },
          ],
          name: 'BondedERC721',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'DebtIncurred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'DebtPaid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20Deregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum IReserve.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              indexed: !1,
              internalType: 'enum IReserve.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'ERC20Registered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sRedeemed',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensBurned',
              type: 'uint256',
            },
          ],
          name: 'RedeemedERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensBurned',
              type: 'uint256',
            },
          ],
          name: 'RedeemedERC721Id',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldDiscount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newDiscount',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingDiscount',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldtimeLockDuration',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newtimeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingTimeLock',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetERC20Oracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20RedeemLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldDiscount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newDiscount',
              type: 'uint256',
            },
          ],
          name: 'SetERC721IdBondingDiscount',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldtimeLockDuration',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newtimeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'SetERC721IdBondingTimeLock',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetERC721IdOracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldMinBacking',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newMinBacking',
              type: 'uint256',
            },
          ],
          name: 'SetMinBacking',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldTimeLockVault',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newTimeLockVault',
              type: 'address',
            },
          ],
          name: 'SetTimeLockVault',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetTokenOracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sWithdrawn',
              type: 'uint256',
            },
          ],
          name: 'WithdrewERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'WithdrewERC721Id',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC20s',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC721Ids',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'erc721',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'id',
                  type: 'uint256',
                },
              ],
              internalType: 'struct IReserve.ERC721Id[]',
              name: '',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'assetTypeOfERC20',
          outputs: [
            {
              internalType: 'enum IReserve.AssetType',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'bondERC20All',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'bondERC20AllFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC20AllFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC20AllTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20From',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20FromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20To',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'bondERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'bondERC721IdFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC721IdFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC721IdTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingDiscountPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'bondingDiscountPerERC721Id',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingTimeLockDurationPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'bondingTimeLockDurationPerERC721Id',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'deregisterERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'deregisterERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'executeTx',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'incurDebt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Bondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Redeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdBondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdRedeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minBacking',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: '',
              type: 'bytes',
            },
          ],
          name: 'onERC721Received',
          outputs: [
            {
              internalType: 'bytes4',
              name: '',
              type: 'bytes4',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'oraclePerERC20',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oraclePerERC721Id',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'payDebt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'redeemERC20All',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20From',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20FromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20To',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'redeemERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'redeemLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              internalType: 'enum IReserve.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              internalType: 'enum IReserve.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'registerERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'registerERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC20s',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC721Ids',
          outputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserveStatus',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'riskLevelOfERC20',
          outputs: [
            {
              internalType: 'enum IReserve.RiskLevel',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
          ],
          name: 'setBondingDiscountForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
          ],
          name: 'setBondingDiscountForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setBondingTimeLockForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setBondingTimeLockForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20BondingLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20RedeemLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'minBacking_',
              type: 'uint256',
            },
          ],
          name: 'setMinBacking',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'timeLockVault_',
              type: 'address',
            },
          ],
          name: 'setTimeLockVault',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'tokenOracle_',
              type: 'address',
            },
          ],
          name: 'setTokenOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Bond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Redemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC721IdBond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC721IdRedemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'timeLockVault',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'token',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tokenOracle',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateOracleForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateOracleForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'withdrawERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'withdrawERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    CuracaoReserveToken: {
      address: '0x4D06191a0eF5ECBD55eB5c4cc9CF4796f6138840',
      abi: [
        {
          inputs: [
            {
              internalType: 'string',
              name: 'name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: 'symbol',
              type: 'string',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'ReserveToken__InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'ReserveToken__InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'ReserveToken__NotMintBurner',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'mintBurner',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'newStatus',
              type: 'bool',
            },
          ],
          name: 'UpdateMintBurner',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'mint',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'mintBurner',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              internalType: 'bool',
              name: 'status',
              type: 'bool',
            },
          ],
          name: 'setMintBurner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Treasury: {
      address: '0x74b06277Cd1efaA9f6595D25AdB54b4530d15BF5',
      abi: [
        {
          inputs: [],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'MaxSupplyReached',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20BondingLimitExceeded',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotBondable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotRedeemable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotRegistered',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20RedeemLimitExceeded',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotBondable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotRedeemable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotRegistered',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'Treasury__StaleERC20PriceDeliveredByOracle',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'Treasury__StaleERC721IdPriceDeliveredByOracle',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20Deregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'ERC20OracleUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldPrice',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newPrice',
              type: 'uint256',
            },
          ],
          name: 'ERC20PriceUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum Treasury.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              indexed: !1,
              internalType: 'enum Treasury.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'ERC20Registered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sWithdrawn',
              type: 'uint256',
            },
          ],
          name: 'ERC20Withdrawn',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsMinted',
              type: 'uint256',
            },
          ],
          name: 'ERC20sBonded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsBurned',
              type: 'uint256',
            },
          ],
          name: 'ERC20sRedeemed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'ERC721IdOracleUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldPrice',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newPrice',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdPriceUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'ERC721IdRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'ERC721IdWithdrawn',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsMinted',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdsBonded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsBurned',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdsRedeemed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'epoch',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newScalar',
              type: 'uint256',
            },
          ],
          name: 'Rebase',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20RedeemLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'EIP712_DOMAIN',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'EIP712_REVISION',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'PERMIT_TYPEHASH',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC20s',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC721Ids',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'erc721',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'id',
                  type: 'uint256',
                },
              ],
              internalType: 'struct Treasury.ERC721Id[]',
              name: '',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'assetTypeOfERC20',
          outputs: [
            {
              internalType: 'enum Treasury.AssetType',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'bondERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'deregisterERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'deregisterERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'executeTx',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Bondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Redeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdBondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdRedeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'lastRebase',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: '',
              type: 'bytes',
            },
          ],
          name: 'onERC721Received',
          outputs: [
            {
              internalType: 'bytes4',
              name: '',
              type: 'bytes4',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'oraclePerERC20',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oraclePerERC721Id',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'rebase',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'kttWad',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'redeemERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'redeemLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              internalType: 'enum Treasury.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              internalType: 'enum Treasury.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'registerERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'registerERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC20s',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC721Ids',
          outputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'riskLevelOfERC20',
          outputs: [
            {
              internalType: 'enum Treasury.RiskLevel',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'scaledBalanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'scaledTotalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20BondingLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20RedeemLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Bond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Redemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalValuation',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'transferAll',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'transferAllFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateERC20Oracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateERC721IdOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'withdrawERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'withdrawERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'Kolektivo Treasury Token': {
      address: '0x74b06277Cd1efaA9f6595D25AdB54b4530d15BF5',
      abi: 'ERC20',
    },
    KolektivoMultiSig: {
      address: '0x33a0F694DFEDEFa3e98205E9712f4d8FA422E70a',
    },
    Vault: {
      address: '0xD25E02047E76b688445ab154785F2642c6fe3f73',
      abi: [
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'liquidityProvider',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              indexed: !1,
              internalType: 'int256[]',
              name: 'deltas',
              type: 'int256[]',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'protocolFeeAmounts',
              type: 'uint256[]',
            },
          ],
          name: 'PoolBalanceChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'assetManager',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'int256',
              name: 'cashDelta',
              type: 'int256',
            },
            {
              indexed: !1,
              internalType: 'int256',
              name: 'managedDelta',
              type: 'int256',
            },
          ],
          name: 'PoolBalanceManaged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'poolAddress',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum IVault.PoolSpecialization',
              name: 'specialization',
              type: 'uint8',
            },
          ],
          name: 'PoolRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'tokenIn',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'tokenOut',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amountIn',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amountOut',
              type: 'uint256',
            },
          ],
          name: 'Swap',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
          ],
          name: 'TokensDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              indexed: !1,
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
          ],
          name: 'TokensRegistered',
          type: 'event',
        },
        {
          inputs: [],
          name: 'WETH',
          outputs: [
            {
              internalType: 'contract IWETH',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.SwapKind',
              name: 'kind',
              type: 'uint8',
            },
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'int256[]',
              name: 'limits',
              type: 'int256[]',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'batchSwap',
          outputs: [
            {
              internalType: 'int256[]',
              name: '',
              type: 'int256[]',
            },
          ],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
          ],
          name: 'deregisterTokens',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address payable',
              name: 'recipient',
              type: 'address',
            },
            {
              components: [
                {
                  internalType: 'contract IAsset[]',
                  name: 'assets',
                  type: 'address[]',
                },
                {
                  internalType: 'uint256[]',
                  name: 'minAmountsOut',
                  type: 'uint256[]',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.ExitPoolRequest',
              name: 'request',
              type: 'tuple',
            },
          ],
          name: 'exitPool',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
          ],
          name: 'getPool',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'enum IVault.PoolSpecialization',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getPoolTokenInfo',
          outputs: [
            {
              internalType: 'uint256',
              name: 'cash',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'managed',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'assetManager',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
          ],
          name: 'getPoolTokens',
          outputs: [
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              components: [
                {
                  internalType: 'contract IAsset[]',
                  name: 'assets',
                  type: 'address[]',
                },
                {
                  internalType: 'uint256[]',
                  name: 'maxAmountsIn',
                  type: 'uint256[]',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.JoinPoolRequest',
              name: 'request',
              type: 'tuple',
            },
          ],
          name: 'joinPool',
          outputs: [],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.PoolBalanceOpKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'token',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
              ],
              internalType: 'struct IVault.PoolBalanceOp[]',
              name: 'ops',
              type: 'tuple[]',
            },
          ],
          name: 'managePoolBalance',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.SwapKind',
              name: 'kind',
              type: 'uint8',
            },
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
          ],
          name: 'queryBatchSwap',
          outputs: [
            {
              internalType: 'int256[]',
              name: 'assetDeltas',
              type: 'int256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.PoolSpecialization',
              name: 'specialization',
              type: 'uint8',
            },
          ],
          name: 'registerPool',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
          ],
          name: 'registerTokens',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IAsset',
                  name: 'assetIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IAsset',
                  name: 'assetOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.SingleSwap',
              name: 'singleSwap',
              type: 'tuple',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'swap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'payable',
          type: 'function',
        },
      ],
    },
    'Test Token #1': {
      address: '0x4cB13ED364bd2c212B694921CdAca979DCA76054',
      abi: 'ERC20',
    },
    cUSD: {
      address: '0xEA8005c6a5d8D4A5Da391C5f2770dFA4FaeC4A19',
      abi: 'ERC20',
    },
    'Test Token #2': {
      address: '0x5bFE78b0d15eF0cdcA4077336e0bEbEc15CFb142',
      abi: 'ERC20',
    },
    'Test Token #3': {
      address: '0xd312bCeA257799a39e0C85d7EC45031612e4dd50',
      abi: 'ERC20',
    },
    'GeoNFT #1': {
      address: '0x9fC5461A1e6CF567C7E19Befa7c0351C9C6CB719',
      id: 1,
      abi: 'ERC721',
    },
    'GeoNFT #2': {
      address: '0x9fC5461A1e6CF567C7E19Befa7c0351C9C6CB719',
      id: 2,
      abi: 'ERC721',
    },
    'kGuilder Pool': {
      address: '0x0A6E9C14343F6273AEd659bef624A49fC0673efc',
      abi: [
        {
          inputs: [
            {
              internalType: 'contract IVault',
              name: 'vault',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: 'symbol',
              type: 'string',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'amplificationParameter',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowDuration',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodDuration',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'startValue',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'endValue',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'startTime',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'endTime',
              type: 'uint256',
            },
          ],
          name: 'AmpUpdateStarted',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'currentValue',
              type: 'uint256',
            },
          ],
          name: 'AmpUpdateStopped',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'PausedStateChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'SwapFeePercentageChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'selector',
              type: 'bytes4',
            },
          ],
          name: 'getActionId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAmplificationParameter',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'isUpdating',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'precision',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAuthorizer',
          outputs: [
            {
              internalType: 'contract IAuthorizer',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getLastInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: 'lastInvariant',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'lastInvariantAmp',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPausedState',
          outputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowEndTime',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodEndTime',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPoolId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getScalingFactors',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getSwapFeePercentage',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVault',
          outputs: [
            {
              internalType: 'contract IVault',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'addedValue',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onExitPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onJoinPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'swapRequest',
              type: 'tuple',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'indexIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'indexOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'request',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryExit',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsOut',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryJoin',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptOut',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsIn',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'poolConfig',
              type: 'bytes',
            },
          ],
          name: 'setAssetManagerPoolConfig',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'setPaused',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'setSwapFeePercentage',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'rawEndValue',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'endTime',
              type: 'uint256',
            },
          ],
          name: 'startAmplificationParameterUpdate',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stopAmplificationParameterUpdate',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'kCur Pool': {
      address: '0x5d3b4D218cd421C1A03Eac4739AB3FA42C227a96',
      abi: [
        {
          inputs: [
            {
              internalType: 'contract IVault',
              name: 'vault',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: 'symbol',
              type: 'string',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'normalizedWeights',
              type: 'uint256[]',
            },
            {
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowDuration',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodDuration',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'PausedStateChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'SwapFeePercentageChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'selector',
              type: 'bytes4',
            },
          ],
          name: 'getActionId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAuthorizer',
          outputs: [
            {
              internalType: 'contract IAuthorizer',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getLastInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getNormalizedWeights',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPausedState',
          outputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowEndTime',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodEndTime',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPoolId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getScalingFactors',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getSwapFeePercentage',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVault',
          outputs: [
            {
              internalType: 'contract IVault',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'addedValue',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onExitPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onJoinPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'request',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryExit',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsOut',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryJoin',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptOut',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsIn',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'poolConfig',
              type: 'bytes',
            },
          ],
          name: 'setAssetManagerPoolConfig',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'setPaused',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'setSwapFeePercentage',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    TimeLockVault: {
      address: '0x6165Db6659B39c816363aD643Ad54F472FD384d0',
      abi: [
        {
          inputs: [],
          name: 'InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidDuration',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'SenderCantLock',
          type: 'error',
        },
        {
          inputs: [],
          name: 'UserHasNoLocks',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'Claimed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'unlockAt',
              type: 'uint256',
            },
          ],
          name: 'Locked',
          type: 'event',
        },
        {
          inputs: [],
          name: 'claim',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'claimAt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'claimToken',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
          ],
          name: 'getLocksOf',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'token',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'unlockAt',
                  type: 'uint256',
                },
              ],
              internalType: 'struct TimeLockVault.Lock[]',
              name: 'locks',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'locker',
              type: 'address',
            },
          ],
          name: 'isLocker',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'duration',
              type: 'uint256',
            },
          ],
          name: 'lock',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    SortedOracles: {
      address: '0x81D79eB26E81882a15aBf0d5B56019Cf66466E90',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'newBreakerBox',
              type: 'address',
            },
          ],
          name: 'BreakerBoxUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'MedianUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
          ],
          name: 'OracleAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
          ],
          name: 'OracleRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'OracleReportRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'OracleReported',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'reportExpiry',
              type: 'uint256',
            },
          ],
          name: 'ReportExpirySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'reportExpiry',
              type: 'uint256',
            },
          ],
          name: 'TokenReportExpirySet',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
          ],
          name: 'addOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'breakerBox',
          outputs: [
            {
              internalType: 'contract IBreakerBox',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getOracles',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getRates',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'enum SortedLinkedListWithMedian.MedianRelation[]',
              name: '',
              type: 'uint8[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getTimestamps',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'enum SortedLinkedListWithMedian.MedianRelation[]',
              name: '',
              type: 'uint8[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getTokenReportExpirySeconds',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '_reportExpirySeconds',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'isOldestReportExpired',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isOracle',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'medianRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'medianTimestamp',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'numRates',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'numTimestamps',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oracles',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'n',
              type: 'uint256',
            },
          ],
          name: 'removeExpiredReports',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'lesserKey',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'greaterKey',
              type: 'address',
            },
          ],
          name: 'report',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportExpirySeconds',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IBreakerBox',
              name: 'newBreakerBox',
              type: 'address',
            },
          ],
          name: 'setBreakerBox',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '_reportExpirySeconds',
              type: 'uint256',
            },
          ],
          name: 'setReportExpiry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '_reportExpirySeconds',
              type: 'uint256',
            },
          ],
          name: 'setTokenReportExpiry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'tokenReportExpirySeconds',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    BAC: {
      address: '0xFD16456575188FAdC88F855d4cda6C339Fb5603f',
      abi: [
        {
          inputs: [
            {
              internalType: 'address',
              name: '_owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '_avatar',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '_target',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '_badger',
              type: 'address',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'ArraysDifferentLength',
          type: 'error',
        },
        {
          inputs: [],
          name: 'ModuleTransactionFailed',
          type: 'error',
        },
        {
          inputs: [],
          name: 'NoMembership',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'guard_',
              type: 'address',
            },
          ],
          name: 'NotIERC165Compliant',
          type: 'error',
        },
        {
          inputs: [],
          name: 'RedundantUpdateOfState',
          type: 'error',
        },
        {
          inputs: [],
          name: 'SetUpModulesAlreadyCalled',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousAvatar',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newAvatar',
              type: 'address',
            },
          ],
          name: 'AvatarSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'badgerAddress',
              type: 'address',
            },
          ],
          name: 'BadgerUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'guard',
              type: 'address',
            },
          ],
          name: 'ChangedGuard',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'initiator',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'avatar',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
          ],
          name: 'RolesModSetup',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'multisendAddress',
              type: 'address',
            },
          ],
          name: 'SetMultisendAddress',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousTarget',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newTarget',
              type: 'address',
            },
          ],
          name: 'TargetSet',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'enum ExecutionOptions',
              name: 'options',
              type: 'uint8',
            },
          ],
          name: 'allowTarget',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'avatar',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'badger',
          outputs: [
            {
              internalType: 'contract IBadger',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
            {
              internalType: 'enum Enum.Operation',
              name: 'operation',
              type: 'uint8',
            },
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
          ],
          name: 'execTransactionFromModule',
          outputs: [
            {
              internalType: 'bool',
              name: 'success',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
            {
              internalType: 'enum Enum.Operation',
              name: 'operation',
              type: 'uint8',
            },
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
          ],
          name: 'execTransactionFromModuleReturnData',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
            {
              internalType: 'bytes',
              name: '',
              type: 'bytes',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getGuard',
          outputs: [
            {
              internalType: 'address',
              name: '_guard',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'guard',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'multisend',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
          ],
          name: 'revokeTarget',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'enum ExecutionOptions',
              name: 'options',
              type: 'uint8',
            },
          ],
          name: 'scopeAllowFunction',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'bool[]',
              name: 'isParamScoped',
              type: 'bool[]',
            },
            {
              internalType: 'enum ParameterType[]',
              name: 'paramType',
              type: 'uint8[]',
            },
            {
              internalType: 'enum Comparison[]',
              name: 'paramComp',
              type: 'uint8[]',
            },
            {
              internalType: 'bytes[]',
              name: 'compValue',
              type: 'bytes[]',
            },
            {
              internalType: 'enum ExecutionOptions',
              name: 'options',
              type: 'uint8',
            },
          ],
          name: 'scopeFunction',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'enum ExecutionOptions',
              name: 'options',
              type: 'uint8',
            },
          ],
          name: 'scopeFunctionExecutionOptions',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'uint256',
              name: 'paramIndex',
              type: 'uint256',
            },
            {
              internalType: 'enum ParameterType',
              name: 'paramType',
              type: 'uint8',
            },
            {
              internalType: 'enum Comparison',
              name: 'paramComp',
              type: 'uint8',
            },
            {
              internalType: 'bytes',
              name: 'compValue',
              type: 'bytes',
            },
          ],
          name: 'scopeParameter',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'uint256',
              name: 'paramIndex',
              type: 'uint256',
            },
            {
              internalType: 'enum ParameterType',
              name: 'paramType',
              type: 'uint8',
            },
            {
              internalType: 'bytes[]',
              name: 'compValues',
              type: 'bytes[]',
            },
          ],
          name: 'scopeParameterAsOneOf',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
          ],
          name: 'scopeRevokeFunction',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
          ],
          name: 'scopeTarget',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_avatar',
              type: 'address',
            },
          ],
          name: 'setAvatar',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_guard',
              type: 'address',
            },
          ],
          name: 'setGuard',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_multisend',
              type: 'address',
            },
          ],
          name: 'setMultisend',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_target',
              type: 'address',
            },
          ],
          name: 'setTarget',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'initParams',
              type: 'bytes',
            },
          ],
          name: 'setUp',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'target',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'uint8',
              name: 'paramIndex',
              type: 'uint8',
            },
          ],
          name: 'unscopeParameter',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_newBadger',
              type: 'address',
            },
          ],
          name: 'updateBadger',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    KolektivoGuilder: {
      address: '0x757F26aCB41300F7e050E11FBBD3217318ca1eC7',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bytes32',
              name: 'oldId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'bytes32',
              name: 'newId',
              type: 'bytes32',
            },
          ],
          name: 'ExchangeIdentifierUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'factor',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'lastUpdated',
              type: 'uint256',
            },
          ],
          name: 'InflationFactorUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'rate',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'updatePeriod',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'lastUpdated',
              type: 'uint256',
            },
          ],
          name: 'InflationParametersUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'string',
              name: 'comment',
              type: 'string',
            },
          ],
          name: 'TransferComment',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'accountOwner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'accountOwner',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'blsKey',
              type: 'bytes',
            },
            {
              internalType: 'bytes',
              name: 'blsPop',
              type: 'bytes',
            },
          ],
          name: 'checkProofOfPossession',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'feeRecipient',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'gatewayFeeRecipient',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'communityFund',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'refund',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'tipTxFee',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'gatewayFee',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'baseTxFee',
              type: 'uint256',
            },
          ],
          name: 'creditGasFees',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'debitGasFees',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'aNumerator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'aDenominator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bNumerator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bDenominator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'exponent',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_decimals',
              type: 'uint256',
            },
          ],
          name: 'fractionMulExp',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'getBlockNumberFromHeader',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getEpochNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'getEpochNumberOfBlock',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getEpochSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getExchangeRegistryId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getInflationParameters',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'getParentSealBitmap',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'getVerifiedSealBitmapFromHeader',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'hashHeader',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: '_name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: '_symbol',
              type: 'string',
            },
            {
              internalType: 'uint8',
              name: '_decimals',
              type: 'uint8',
            },
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'inflationRate',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'inflationFactorUpdatePeriod',
              type: 'uint256',
            },
            {
              internalType: 'string',
              name: 'exchangeIdentifier',
              type: 'string',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'minQuorumSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minQuorumSizeInCurrentSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'mint',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'numberValidatorsInCurrentSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'numberValidatorsInSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'exchangeIdentifier',
              type: 'string',
            },
          ],
          name: 'setExchangeRegistryId',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'rate',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'updatePeriod',
              type: 'uint256',
            },
          ],
          name: 'setInflationParameters',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'string',
              name: 'comment',
              type: 'string',
            },
          ],
          name: 'transferWithComment',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'units',
              type: 'uint256',
            },
          ],
          name: 'unitsToValue',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'validatorSignerAddressFromCurrentSet',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'validatorSignerAddressFromSet',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'valueToUnits',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    Exchange: {
      address: '0xB3D5F944284846fF1B27635aF117fb11c7E9d1B1',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'goldBucket',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'stableBucket',
              type: 'uint256',
            },
          ],
          name: 'BucketsUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchanger',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'soldGold',
              type: 'bool',
            },
          ],
          name: 'Exchanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'minimumReports',
              type: 'uint256',
            },
          ],
          name: 'MinimumReportsSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'reserveFraction',
              type: 'uint256',
            },
          ],
          name: 'ReserveFractionSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'spread',
              type: 'uint256',
            },
          ],
          name: 'SpreadSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'stable',
              type: 'address',
            },
          ],
          name: 'StableTokenSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'updateFrequency',
              type: 'uint256',
            },
          ],
          name: 'UpdateFrequencySet',
          type: 'event',
        },
        {
          inputs: [],
          name: 'activateStable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'maxSellAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'buyGold',
              type: 'bool',
            },
          ],
          name: 'buy',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minBuyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'exchange',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getBuyAndSellBuckets',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getBuyTokenAmount',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getSellTokenAmount',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [],
          name: 'goldBucket',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'stableTokenIdentifier',
              type: 'string',
            },
            {
              internalType: 'uint256',
              name: '_spread',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_reserveFraction',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_updateFrequency',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_minimumReports',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'lastBucketUpdate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minimumReports',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserveFraction',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minBuyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'sell',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newMininumReports',
              type: 'uint256',
            },
          ],
          name: 'setMinimumReports',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newReserveFraction',
              type: 'uint256',
            },
          ],
          name: 'setReserveFraction',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newSpread',
              type: 'uint256',
            },
          ],
          name: 'setSpread',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newStableToken',
              type: 'address',
            },
          ],
          name: 'setStableToken',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newUpdateFrequency',
              type: 'uint256',
            },
          ],
          name: 'setUpdateFrequency',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'spread',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stable',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stableBucket',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stableTokenRegistryId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'updateFrequency',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    MentoReserve: {
      address: '0x87944070f49108d062231a8cB15A2ce1CEe48Dd4',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bytes32[]',
              name: 'symbols',
              type: 'bytes32[]',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'weights',
              type: 'uint256[]',
            },
          ],
          name: 'AssetAllocationSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'ratio',
              type: 'uint256',
            },
          ],
          name: 'DailySpendingRatioSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchangeSpender',
              type: 'address',
            },
          ],
          name: 'ExchangeSpenderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchangeSpender',
              type: 'address',
            },
          ],
          name: 'ExchangeSpenderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'otherReserveAddress',
              type: 'address',
            },
          ],
          name: 'OtherReserveAddressAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'otherReserveAddress',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'OtherReserveAddressRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'ReserveGoldTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'SpenderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'SpenderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxReserveRatioSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxStalenessThresholdSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'TokenAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'TokenRemoved',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'addExchangeSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'reserveAddress',
              type: 'address',
            },
          ],
          name: 'addOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'addSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'addToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'assetAllocationSymbols',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          name: 'assetAllocationWeights',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'exchangeSpenderAddresses',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'frozenReserveGoldDays',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'frozenReserveGoldStartBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'frozenReserveGoldStartDay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAssetAllocationSymbols',
          outputs: [
            {
              internalType: 'bytes32[]',
              name: '',
              type: 'bytes32[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAssetAllocationWeights',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getDailySpendingRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getExchangeSpenders',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getFrozenReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOrComputeTobinTax',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOtherReserveAddresses',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOtherReserveAddressesGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getReserveRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getTokens',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getUnfrozenBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getUnfrozenReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '_tobinTaxStalenessThreshold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_spendingRatio',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_frozenGold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_frozenDays',
              type: 'uint256',
            },
            {
              internalType: 'bytes32[]',
              name: '_assetAllocationSymbols',
              type: 'bytes32[]',
            },
            {
              internalType: 'uint256[]',
              name: '_assetAllocationWeights',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: '_tobinTax',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_tobinTaxReserveRatio',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isExchangeSpender',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isSpender',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'lastSpendingDay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'otherReserveAddresses',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeExchangeSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'reserveAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'removeSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32[]',
              name: 'symbols',
              type: 'bytes32[]',
            },
            {
              internalType: 'uint256[]',
              name: 'weights',
              type: 'uint256[]',
            },
          ],
          name: 'setAssetAllocations',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'ratio',
              type: 'uint256',
            },
          ],
          name: 'setDailySpendingRatio',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'frozenGold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'frozenDays',
              type: 'uint256',
            },
          ],
          name: 'setFrozenGold',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_reserveToken',
              type: 'address',
            },
          ],
          name: 'setReserveToken',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTax',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTaxReserveRatio',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTaxStalenessThreshold',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'spendingLimit',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTax',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTaxCache',
          outputs: [
            {
              internalType: 'uint128',
              name: 'numerator',
              type: 'uint128',
            },
            {
              internalType: 'uint128',
              name: 'timestamp',
              type: 'uint128',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTaxReserveRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTaxStalenessThreshold',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address payable',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferExchangeGold',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address payable',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferGold',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    MentoRegistry: {
      address: '0xB66F7f6C7C08d6132b3052D973ED4f9B74681E70',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'identifierHash',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'addr',
              type: 'address',
            },
          ],
          name: 'RegistryUpdated',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'identifierHash',
              type: 'bytes32',
            },
          ],
          name: 'getAddressFor',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'identifierHash',
              type: 'bytes32',
            },
          ],
          name: 'getAddressForOrDie',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'getAddressForString',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'getAddressForStringOrDie',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32[]',
              name: 'identifierHashes',
              type: 'bytes32[]',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
          ],
          name: 'isOneOf',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          name: 'registry',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
            {
              internalType: 'address',
              name: 'addr',
              type: 'address',
            },
          ],
          name: 'setAddressFor',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Freezer: {
      address: '0x1132A29561cB4Caa425A9C3aCF21781Fa3bB3705',
      abi: [
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    ProxyPool: {
      address: '0xC8C7c0EF04493028b1697204b59Ce32D5599B35A',
      abi: [
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pairToken_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'vault_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'reserve_',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'ceilingMultiplier_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'ceilingTradeShare_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'floorTradeShare_',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'Paused',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'Unpaused',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'totalAmountIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minTotalAmountOut',
              type: 'uint256',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'int256[]',
              name: 'limits',
              type: 'int256[]',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'batchSwapExactIn',
          outputs: [],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'maxTotalAmountIn',
              type: 'uint256',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'int256[]',
              name: 'limits',
              type: 'int256[]',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'batchSwapExactOut',
          outputs: [],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'ceilingMultiplier',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'ceilingTradeShare',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'floorTradeShare',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'inBalanceAfter',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'inBalanceBefore',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'outBalanceAfter',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'outBalanceBefore',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pairToken',
          outputs: [
            {
              internalType: 'contract ERC20',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pause',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'paused',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserve',
          outputs: [
            {
              internalType: 'contract IReserve',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserveToken',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'unpause',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'vault',
          outputs: [
            {
              internalType: 'contract IVault',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    Badger: {
      address: '0x8a41a586F66c74Ea0556242EC18eb4FA258d597C',
      abi: [
        {
          inputs: [
            {
              internalType: 'string',
              name: '_baseUri',
              type: 'string',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'TransferDisabled',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'approved',
              type: 'bool',
            },
          ],
          name: 'ApprovalForAll',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokenId',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'string',
              name: 'uri',
              type: 'string',
            },
          ],
          name: 'TokenUriUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'ids',
              type: 'uint256[]',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'values',
              type: 'uint256[]',
            },
          ],
          name: 'TransferBatch',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TransferSingle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'string',
              name: 'value',
              type: 'string',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'URI',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address[]',
              name: 'accounts',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'ids',
              type: 'uint256[]',
            },
          ],
          name: 'balanceOfBatch',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address[]',
              name: 'accounts',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'tokenIds',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: 'amounts',
              type: 'uint256[]',
            },
          ],
          name: 'burnFromMultiple',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
          ],
          name: 'isApprovedForAll',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'mint',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address[]',
              name: 'accounts',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'tokenIds',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: 'amounts',
              type: 'uint256[]',
            },
          ],
          name: 'mintToMultiple',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'ids',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: 'amounts',
              type: 'uint256[]',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'safeBatchTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'safeTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          name: 'setApprovalForAll',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'baseUri',
              type: 'string',
            },
          ],
          name: 'setBaseUri',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'tokenId',
              type: 'uint256',
            },
            {
              internalType: 'string',
              name: 'newUri',
              type: 'string',
            },
          ],
          name: 'setUri',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'interfaceId',
              type: 'bytes4',
            },
          ],
          name: 'supportsInterface',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'tokenUris',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'tokenId',
              type: 'uint256',
            },
          ],
          name: 'uri',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
  },
  jD = {
    name: y5,
    chainId: h5,
    contracts: m5,
  },
  VD = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        chainId: h5,
        contracts: m5,
        default: jD,
        name: y5,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  b5 = 'celo',
  g5 = 42220,
  v5 = {},
  zD = {
    name: b5,
    chainId: g5,
    contracts: v5,
  },
  GD = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        chainId: g5,
        contracts: v5,
        default: zD,
        name: b5,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  x5 = 'celo',
  T5 = '42220',
  w5 = {},
  qD = {
    name: x5,
    chainId: T5,
    contracts: w5,
  },
  HD = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        chainId: T5,
        contracts: w5,
        default: qD,
        name: x5,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  A5 = 'celo',
  E5 = '42220',
  S5 = {
    GeoNFT: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'string',
              name: '_name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: '_symbol',
              type: 'string',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidIdentifier',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidLatitude',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidLongitude',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'GeoNFT__InvalidTokenId',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'approved',
              type: 'bool',
            },
          ],
          name: 'ApprovalForAll',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'TokenModified',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'getApproved',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isApprovedForAll',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'int32',
              name: 'latitude',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: 'longitude',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'mint',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'int32',
              name: 'latitude',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: 'longitude',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'modify',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ownerOf',
          outputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'safeTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'safeTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              internalType: 'bool',
              name: 'approved',
              type: 'bool',
            },
          ],
          name: 'setApprovalForAll',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'interfaceId',
              type: 'bytes4',
            },
          ],
          name: 'supportsInterface',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'tokenData',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'int32',
              name: '',
              type: 'int32',
            },
            {
              internalType: 'int32',
              name: '',
              type: 'int32',
            },
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'tokenURI',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    KolektivoMultiSig: {
      address: '0xcE960DcafC201a1B4440ed5F6B63A7772a34b2Ab',
    },
    Oracle: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'reportExpirationTime_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'reportDelay_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minimumProviders_',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'invalidProvider',
              type: 'address',
            },
          ],
          name: 'Oracle__InvalidProvider',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Oracle__NewReportTooSoonAfterPastReport',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldMinimumProviders',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newMinimumProviders',
              type: 'uint256',
            },
          ],
          name: 'MinimumProvidersChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [],
          name: 'OracleMarkedAsInvalid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [],
          name: 'OracleMarkedAsValid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
          ],
          name: 'ProviderReportPushed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'purger',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'ProviderReportsPurged',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'addProvider',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getData',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'isValid',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minimumProviders',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'providerReports',
          outputs: [
            {
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'providers',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'providersSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'purgeReports',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'purgeReportsFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'payload',
              type: 'uint256',
            },
          ],
          name: 'pushReport',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'provider',
              type: 'address',
            },
          ],
          name: 'removeProvider',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportDelay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportExpirationTime',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isValid_',
              type: 'bool',
            },
          ],
          name: 'setIsValid',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'minimumProviders_',
              type: 'uint256',
            },
          ],
          name: 'setMinimumProviders',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Reserve: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'tokenOracle_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'vestingVault_',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'minBacking_',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20BalanceNotSufficient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20BondingLimitExceeded',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotBondable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotRedeemable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20NotRegistered',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC20RedeemLimitExceeded',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotBondable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotRedeemable',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__ERC721IdNotRegistered',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidOracle',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'Reserve__MinimumBackingLimitExceeded',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldBacking',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newBacking',
              type: 'uint256',
            },
          ],
          name: 'BackingUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sBonded',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensMinted',
              type: 'uint256',
            },
          ],
          name: 'BondedERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensMinted',
              type: 'uint256',
            },
          ],
          name: 'BondedERC721',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'DebtIncurred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'DebtPaid',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20Deregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum IReserve.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              indexed: !1,
              internalType: 'enum IReserve.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'ERC20Registered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sRedeemed',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensBurned',
              type: 'uint256',
            },
          ],
          name: 'RedeemedERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokensBurned',
              type: 'uint256',
            },
          ],
          name: 'RedeemedERC721Id',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldDiscount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newDiscount',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingDiscount',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldtimeLockDuration',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newtimeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingTimeLock',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetERC20Oracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20RedeemLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldDiscount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newDiscount',
              type: 'uint256',
            },
          ],
          name: 'SetERC721IdBondingDiscount',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldtimeLockDuration',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newtimeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'SetERC721IdBondingTimeLock',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetERC721IdOracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldMinBacking',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newMinBacking',
              type: 'uint256',
            },
          ],
          name: 'SetMinBacking',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldTimeLockVault',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newTimeLockVault',
              type: 'address',
            },
          ],
          name: 'SetTimeLockVault',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'SetTokenOracle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sWithdrawn',
              type: 'uint256',
            },
          ],
          name: 'WithdrewERC20',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'WithdrewERC721Id',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC20s',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC721Ids',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'erc721',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'id',
                  type: 'uint256',
                },
              ],
              internalType: 'struct IReserve.ERC721Id[]',
              name: '',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'assetTypeOfERC20',
          outputs: [
            {
              internalType: 'enum IReserve.AssetType',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'bondERC20All',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'bondERC20AllFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC20AllFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC20AllTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20From',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20FromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'erc20Amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20To',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'bondERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'bondERC721IdFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC721IdFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'bondERC721IdTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingDiscountPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'bondingDiscountPerERC721Id',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingTimeLockDurationPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'bondingTimeLockDurationPerERC721Id',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'deregisterERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'deregisterERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'executeTx',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'incurDebt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Bondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Redeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdBondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdRedeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minBacking',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: '',
              type: 'bytes',
            },
          ],
          name: 'onERC721Received',
          outputs: [
            {
              internalType: 'bytes4',
              name: '',
              type: 'bytes4',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'oraclePerERC20',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oraclePerERC721Id',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'payDebt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'redeemERC20All',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC20AllTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20From',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20FromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokenAmount',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20To',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'redeemERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdFromTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'redeemERC721IdTo',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'redeemLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              internalType: 'enum IReserve.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              internalType: 'enum IReserve.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'registerERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'registerERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC20s',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC721Ids',
          outputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserveStatus',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'riskLevelOfERC20',
          outputs: [
            {
              internalType: 'enum IReserve.RiskLevel',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
          ],
          name: 'setBondingDiscountForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
          ],
          name: 'setBondingDiscountForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setBondingTimeLockForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setBondingTimeLockForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20BondingLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20RedeemLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'minBacking_',
              type: 'uint256',
            },
          ],
          name: 'setMinBacking',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'timeLockVault_',
              type: 'address',
            },
          ],
          name: 'setTimeLockVault',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'tokenOracle_',
              type: 'address',
            },
          ],
          name: 'setTokenOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Bond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Redemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'discount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'timeLockDuration',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC721IdBond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC721IdRedemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'timeLockVault',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'token',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tokenOracle',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateOracleForERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateOracleForERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'withdrawERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'withdrawERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    CuracaoReserveToken: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'string',
              name: 'name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: 'symbol',
              type: 'string',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'ReserveToken__InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'ReserveToken__InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'ReserveToken__NotMintBurner',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'mintBurner',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'newStatus',
              type: 'bool',
            },
          ],
          name: 'UpdateMintBurner',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'mint',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'mintBurner',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              internalType: 'bool',
              name: 'status',
              type: 'bool',
            },
          ],
          name: 'setMintBurner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Treasury: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'MaxSupplyReached',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20BondingLimitExceeded',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotBondable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotRedeemable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20IsNotRegistered',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'Treasury__ERC20RedeemLimitExceeded',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotBondable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotRedeemable',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'Treasury__ERC721IdIsNotRegistered',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'Treasury__StaleERC20PriceDeliveredByOracle',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'Treasury__StaleERC721IdPriceDeliveredByOracle',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20DelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20Deregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'ERC20ListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'ERC20OracleUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldPrice',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newPrice',
              type: 'uint256',
            },
          ],
          name: 'ERC20PriceUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum Treasury.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              indexed: !1,
              internalType: 'enum Treasury.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'ERC20Registered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'erc20sWithdrawn',
              type: 'uint256',
            },
          ],
          name: 'ERC20Withdrawn',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsMinted',
              type: 'uint256',
            },
          ],
          name: 'ERC20sBonded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsBurned',
              type: 'uint256',
            },
          ],
          name: 'ERC20sRedeemed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDelistedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsBondable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdListedAsRedeemable',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'oldOracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'newOracle',
              type: 'address',
            },
          ],
          name: 'ERC721IdOracleUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldPrice',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newPrice',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdPriceUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'ERC721IdRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'ERC721IdWithdrawn',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsMinted',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdsBonded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'kttsBurned',
              type: 'uint256',
            },
          ],
          name: 'ERC721IdsRedeemed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'epoch',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newScalar',
              type: 'uint256',
            },
          ],
          name: 'Rebase',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20BondingLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'oldLimit',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'newLimit',
              type: 'uint256',
            },
          ],
          name: 'SetERC20RedeemLimit',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'EIP712_DOMAIN',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'EIP712_REVISION',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'PERMIT_TYPEHASH',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC20s',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'allRegisteredERC721Ids',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'erc721',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'id',
                  type: 'uint256',
                },
              ],
              internalType: 'struct Treasury.ERC721Id[]',
              name: '',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'assetTypeOfERC20',
          outputs: [
            {
              internalType: 'enum Treasury.AssetType',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'bondERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'bondERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'bondingLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'delistERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'delistERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'deregisterERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'deregisterERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'executeTx',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Bondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isERC20Redeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdBondable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'isERC721IdRedeemable',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'lastRebase',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
          ],
          name: 'listERC20AsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsBondable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'listERC721IdAsRedeemable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: '',
              type: 'bytes',
            },
          ],
          name: 'onERC721Received',
          outputs: [
            {
              internalType: 'bytes4',
              name: '',
              type: 'bytes4',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'oraclePerERC20',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oraclePerERC721Id',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'rebase',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'kttWad',
              type: 'uint256',
            },
          ],
          name: 'redeemERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'redeemERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'redeemLimitPerERC20',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              internalType: 'enum Treasury.AssetType',
              name: 'assetType',
              type: 'uint8',
            },
            {
              internalType: 'enum Treasury.RiskLevel',
              name: 'riskLevel',
              type: 'uint8',
            },
          ],
          name: 'registerERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'registerERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC20s',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'registeredERC721Ids',
          outputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'riskLevelOfERC20',
          outputs: [
            {
              internalType: 'enum Treasury.RiskLevel',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'who',
              type: 'address',
            },
          ],
          name: 'scaledBalanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'scaledTotalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20BondingLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setERC20RedeemLimit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Bond',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
          ],
          name: 'setupAndListERC20Redemption',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalValuation',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'transferAll',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
          ],
          name: 'transferAllFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'tokens',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateERC20Oracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'updateERC721IdOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc20',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'withdrawERC20',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'erc721',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
          ],
          name: 'withdrawERC721Id',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'Kolektivo Treasury Token': {
      address: '0x0000000000000000000000000000000000000000',
      abi: 'ERC20',
    },
    Exchange: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'goldBucket',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'stableBucket',
              type: 'uint256',
            },
          ],
          name: 'BucketsUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchanger',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'soldGold',
              type: 'bool',
            },
          ],
          name: 'Exchanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'minimumReports',
              type: 'uint256',
            },
          ],
          name: 'MinimumReportsSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'reserveFraction',
              type: 'uint256',
            },
          ],
          name: 'ReserveFractionSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'spread',
              type: 'uint256',
            },
          ],
          name: 'SpreadSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'stable',
              type: 'address',
            },
          ],
          name: 'StableTokenSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'updateFrequency',
              type: 'uint256',
            },
          ],
          name: 'UpdateFrequencySet',
          type: 'event',
        },
        {
          inputs: [],
          name: 'activateStable',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'maxSellAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'buyGold',
              type: 'bool',
            },
          ],
          name: 'buy',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minBuyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'exchange',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getBuyAndSellBuckets',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getBuyTokenAmount',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'buyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'getSellTokenAmount',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [],
          name: 'goldBucket',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'stableTokenIdentifier',
              type: 'string',
            },
            {
              internalType: 'uint256',
              name: '_spread',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_reserveFraction',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_updateFrequency',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_minimumReports',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'lastBucketUpdate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minimumReports',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserveFraction',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'sellAmount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minBuyAmount',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'sellGold',
              type: 'bool',
            },
          ],
          name: 'sell',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newMininumReports',
              type: 'uint256',
            },
          ],
          name: 'setMinimumReports',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newReserveFraction',
              type: 'uint256',
            },
          ],
          name: 'setReserveFraction',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newSpread',
              type: 'uint256',
            },
          ],
          name: 'setSpread',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newStableToken',
              type: 'address',
            },
          ],
          name: 'setStableToken',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'newUpdateFrequency',
              type: 'uint256',
            },
          ],
          name: 'setUpdateFrequency',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'spread',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stable',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stableBucket',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stableTokenRegistryId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'updateFrequency',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    MentoReserve: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bytes32[]',
              name: 'symbols',
              type: 'bytes32[]',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'weights',
              type: 'uint256[]',
            },
          ],
          name: 'AssetAllocationSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'ratio',
              type: 'uint256',
            },
          ],
          name: 'DailySpendingRatioSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchangeSpender',
              type: 'address',
            },
          ],
          name: 'ExchangeSpenderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'exchangeSpender',
              type: 'address',
            },
          ],
          name: 'ExchangeSpenderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'otherReserveAddress',
              type: 'address',
            },
          ],
          name: 'OtherReserveAddressAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'otherReserveAddress',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'OtherReserveAddressRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'ReserveGoldTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'SpenderAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'SpenderRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxReserveRatioSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TobinTaxStalenessThresholdSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'TokenAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'TokenRemoved',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'addExchangeSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'reserveAddress',
              type: 'address',
            },
          ],
          name: 'addOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'addSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'addToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'assetAllocationSymbols',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          name: 'assetAllocationWeights',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'exchangeSpenderAddresses',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'frozenReserveGoldDays',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'frozenReserveGoldStartBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'frozenReserveGoldStartDay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAssetAllocationSymbols',
          outputs: [
            {
              internalType: 'bytes32[]',
              name: '',
              type: 'bytes32[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAssetAllocationWeights',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getDailySpendingRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getExchangeSpenders',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getFrozenReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOrComputeTobinTax',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOtherReserveAddresses',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOtherReserveAddressesGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getReserveRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getTokens',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getUnfrozenBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getUnfrozenReserveGoldBalance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '_tobinTaxStalenessThreshold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_spendingRatio',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_frozenGold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_frozenDays',
              type: 'uint256',
            },
            {
              internalType: 'bytes32[]',
              name: '_assetAllocationSymbols',
              type: 'bytes32[]',
            },
            {
              internalType: 'uint256[]',
              name: '_assetAllocationWeights',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: '_tobinTax',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_tobinTaxReserveRatio',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isExchangeSpender',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isSpender',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'lastSpendingDay',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'otherReserveAddresses',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeExchangeSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'reserveAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeOtherReserveAddress',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'removeSpender',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeToken',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32[]',
              name: 'symbols',
              type: 'bytes32[]',
            },
            {
              internalType: 'uint256[]',
              name: 'weights',
              type: 'uint256[]',
            },
          ],
          name: 'setAssetAllocations',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'ratio',
              type: 'uint256',
            },
          ],
          name: 'setDailySpendingRatio',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'frozenGold',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'frozenDays',
              type: 'uint256',
            },
          ],
          name: 'setFrozenGold',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_reserveToken',
              type: 'address',
            },
          ],
          name: 'setReserveToken',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTax',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTaxReserveRatio',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'setTobinTaxStalenessThreshold',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'spendingLimit',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTax',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTaxCache',
          outputs: [
            {
              internalType: 'uint128',
              name: 'numerator',
              type: 'uint128',
            },
            {
              internalType: 'uint128',
              name: 'timestamp',
              type: 'uint128',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTaxReserveRatio',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'tobinTaxStalenessThreshold',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address payable',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferExchangeGold',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address payable',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferGold',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'kGuilder Pool': {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'contract IVault',
              name: 'vault',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: 'symbol',
              type: 'string',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'amplificationParameter',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowDuration',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodDuration',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'startValue',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'endValue',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'startTime',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'endTime',
              type: 'uint256',
            },
          ],
          name: 'AmpUpdateStarted',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'currentValue',
              type: 'uint256',
            },
          ],
          name: 'AmpUpdateStopped',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'PausedStateChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'SwapFeePercentageChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'selector',
              type: 'bytes4',
            },
          ],
          name: 'getActionId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAmplificationParameter',
          outputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'bool',
              name: 'isUpdating',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'precision',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAuthorizer',
          outputs: [
            {
              internalType: 'contract IAuthorizer',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getLastInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: 'lastInvariant',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'lastInvariantAmp',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPausedState',
          outputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowEndTime',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodEndTime',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPoolId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getScalingFactors',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getSwapFeePercentage',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVault',
          outputs: [
            {
              internalType: 'contract IVault',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'addedValue',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onExitPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onJoinPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'swapRequest',
              type: 'tuple',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'indexIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'indexOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'request',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryExit',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsOut',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryJoin',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptOut',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsIn',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'poolConfig',
              type: 'bytes',
            },
          ],
          name: 'setAssetManagerPoolConfig',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'setPaused',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'setSwapFeePercentage',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'rawEndValue',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'endTime',
              type: 'uint256',
            },
          ],
          name: 'startAmplificationParameterUpdate',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'stopAmplificationParameterUpdate',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    'kCur Pool': {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'contract IVault',
              name: 'vault',
              type: 'address',
            },
            {
              internalType: 'string',
              name: 'name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: 'symbol',
              type: 'string',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'normalizedWeights',
              type: 'uint256[]',
            },
            {
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowDuration',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodDuration',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'PausedStateChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'SwapFeePercentageChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          inputs: [],
          name: 'DOMAIN_SEPARATOR',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'selector',
              type: 'bytes4',
            },
          ],
          name: 'getActionId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getAuthorizer',
          outputs: [
            {
              internalType: 'contract IAuthorizer',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getLastInvariant',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getNormalizedWeights',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPausedState',
          outputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
            {
              internalType: 'uint256',
              name: 'pauseWindowEndTime',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bufferPeriodEndTime',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getPoolId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getScalingFactors',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getSwapFeePercentage',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVault',
          outputs: [
            {
              internalType: 'contract IVault',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'addedValue',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
          ],
          name: 'nonces',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onExitPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'onJoinPool',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'tokenOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'lastChangeBlock',
                  type: 'uint256',
                },
                {
                  internalType: 'address',
                  name: 'from',
                  type: 'address',
                },
                {
                  internalType: 'address',
                  name: 'to',
                  type: 'address',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IPoolSwapStructs.SwapRequest',
              name: 'request',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'balanceTokenOut',
              type: 'uint256',
            },
          ],
          name: 'onSwap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
            {
              internalType: 'uint8',
              name: 'v',
              type: 'uint8',
            },
            {
              internalType: 'bytes32',
              name: 'r',
              type: 'bytes32',
            },
            {
              internalType: 'bytes32',
              name: 's',
              type: 'bytes32',
            },
          ],
          name: 'permit',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryExit',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsOut',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'protocolSwapFeePercentage',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'userData',
              type: 'bytes',
            },
          ],
          name: 'queryJoin',
          outputs: [
            {
              internalType: 'uint256',
              name: 'bptOut',
              type: 'uint256',
            },
            {
              internalType: 'uint256[]',
              name: 'amountsIn',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'poolConfig',
              type: 'bytes',
            },
          ],
          name: 'setAssetManagerPoolConfig',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'paused',
              type: 'bool',
            },
          ],
          name: 'setPaused',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'swapFeePercentage',
              type: 'uint256',
            },
          ],
          name: 'setSwapFeePercentage',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    TimeLockVault: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [],
          name: 'InvalidAmount',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidDuration',
          type: 'error',
        },
        {
          inputs: [],
          name: 'InvalidRecipient',
          type: 'error',
        },
        {
          inputs: [],
          name: 'SenderCantLock',
          type: 'error',
        },
        {
          inputs: [],
          name: 'UserHasNoLocks',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'Claimed',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'unlockAt',
              type: 'uint256',
            },
          ],
          name: 'Locked',
          type: 'event',
        },
        {
          inputs: [],
          name: 'claim',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'claimAt',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'claimToken',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
          ],
          name: 'getLocksOf',
          outputs: [
            {
              components: [
                {
                  internalType: 'address',
                  name: 'token',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'unlockAt',
                  type: 'uint256',
                },
              ],
              internalType: 'struct TimeLockVault.Lock[]',
              name: 'locks',
              type: 'tuple[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'locker',
              type: 'address',
            },
          ],
          name: 'isLocker',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'receiver',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'duration',
              type: 'uint256',
            },
          ],
          name: 'lock',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    SortedOracles: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'newBreakerBox',
              type: 'address',
            },
          ],
          name: 'BreakerBoxUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'MedianUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
          ],
          name: 'OracleAdded',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
          ],
          name: 'OracleRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
          ],
          name: 'OracleReportRemoved',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'oracle',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'timestamp',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'OracleReported',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'reportExpiry',
              type: 'uint256',
            },
          ],
          name: 'ReportExpirySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'reportExpiry',
              type: 'uint256',
            },
          ],
          name: 'TokenReportExpirySet',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
          ],
          name: 'addOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'breakerBox',
          outputs: [
            {
              internalType: 'contract IBreakerBox',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getOracles',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getRates',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'enum SortedLinkedListWithMedian.MedianRelation[]',
              name: '',
              type: 'uint8[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getTimestamps',
          outputs: [
            {
              internalType: 'address[]',
              name: '',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
            {
              internalType: 'enum SortedLinkedListWithMedian.MedianRelation[]',
              name: '',
              type: 'uint8[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getTokenReportExpirySeconds',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '_reportExpirySeconds',
              type: 'uint256',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'isOldestReportExpired',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'isOracle',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'medianRate',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'medianTimestamp',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'numRates',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'numTimestamps',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'oracles',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'n',
              type: 'uint256',
            },
          ],
          name: 'removeExpiredReports',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'oracleAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'removeOracle',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'lesserKey',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'greaterKey',
              type: 'address',
            },
          ],
          name: 'report',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reportExpirySeconds',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'contract IBreakerBox',
              name: 'newBreakerBox',
              type: 'address',
            },
          ],
          name: 'setBreakerBox',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '_reportExpirySeconds',
              type: 'uint256',
            },
          ],
          name: 'setReportExpiry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_token',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: '_reportExpirySeconds',
              type: 'uint256',
            },
          ],
          name: 'setTokenReportExpiry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          name: 'tokenReportExpirySeconds',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    BAC: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'address',
              name: '_owner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '_avatar',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '_target',
              type: 'address',
            },
            {
              internalType: 'address',
              name: '_badger',
              type: 'address',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'ArraysDifferentLength',
          type: 'error',
        },
        {
          inputs: [],
          name: 'ModuleTransactionFailed',
          type: 'error',
        },
        {
          inputs: [],
          name: 'NoMembership',
          type: 'error',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'guard_',
              type: 'address',
            },
          ],
          name: 'NotIERC165Compliant',
          type: 'error',
        },
        {
          inputs: [],
          name: 'RedundantUpdateOfState',
          type: 'error',
        },
        {
          inputs: [],
          name: 'SetUpModulesAlreadyCalled',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousAvatar',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newAvatar',
              type: 'address',
            },
          ],
          name: 'AvatarSet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'badgerAddress',
              type: 'address',
            },
          ],
          name: 'BadgerUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'guard',
              type: 'address',
            },
          ],
          name: 'ChangedGuard',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'initiator',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'avatar',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'address',
              name: 'target',
              type: 'address',
            },
          ],
          name: 'RolesModSetup',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'multisendAddress',
              type: 'address',
            },
          ],
          name: 'SetMultisendAddress',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousTarget',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newTarget',
              type: 'address',
            },
          ],
          name: 'TargetSet',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'enum ExecutionOptions',
              name: 'options',
              type: 'uint8',
            },
          ],
          name: 'allowTarget',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'avatar',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'badger',
          outputs: [
            {
              internalType: 'contract IBadger',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
            {
              internalType: 'enum Enum.Operation',
              name: 'operation',
              type: 'uint8',
            },
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
          ],
          name: 'execTransactionFromModule',
          outputs: [
            {
              internalType: 'bool',
              name: 'success',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
            {
              internalType: 'enum Enum.Operation',
              name: 'operation',
              type: 'uint8',
            },
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
          ],
          name: 'execTransactionFromModuleReturnData',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
            {
              internalType: 'bytes',
              name: '',
              type: 'bytes',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getGuard',
          outputs: [
            {
              internalType: 'address',
              name: '_guard',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'guard',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'multisend',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
          ],
          name: 'revokeTarget',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'enum ExecutionOptions',
              name: 'options',
              type: 'uint8',
            },
          ],
          name: 'scopeAllowFunction',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'bool[]',
              name: 'isParamScoped',
              type: 'bool[]',
            },
            {
              internalType: 'enum ParameterType[]',
              name: 'paramType',
              type: 'uint8[]',
            },
            {
              internalType: 'enum Comparison[]',
              name: 'paramComp',
              type: 'uint8[]',
            },
            {
              internalType: 'bytes[]',
              name: 'compValue',
              type: 'bytes[]',
            },
            {
              internalType: 'enum ExecutionOptions',
              name: 'options',
              type: 'uint8',
            },
          ],
          name: 'scopeFunction',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'enum ExecutionOptions',
              name: 'options',
              type: 'uint8',
            },
          ],
          name: 'scopeFunctionExecutionOptions',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'uint256',
              name: 'paramIndex',
              type: 'uint256',
            },
            {
              internalType: 'enum ParameterType',
              name: 'paramType',
              type: 'uint8',
            },
            {
              internalType: 'enum Comparison',
              name: 'paramComp',
              type: 'uint8',
            },
            {
              internalType: 'bytes',
              name: 'compValue',
              type: 'bytes',
            },
          ],
          name: 'scopeParameter',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'uint256',
              name: 'paramIndex',
              type: 'uint256',
            },
            {
              internalType: 'enum ParameterType',
              name: 'paramType',
              type: 'uint8',
            },
            {
              internalType: 'bytes[]',
              name: 'compValues',
              type: 'bytes[]',
            },
          ],
          name: 'scopeParameterAsOneOf',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
          ],
          name: 'scopeRevokeFunction',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
          ],
          name: 'scopeTarget',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_avatar',
              type: 'address',
            },
          ],
          name: 'setAvatar',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_guard',
              type: 'address',
            },
          ],
          name: 'setGuard',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_multisend',
              type: 'address',
            },
          ],
          name: 'setMultisend',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_target',
              type: 'address',
            },
          ],
          name: 'setTarget',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'initParams',
              type: 'bytes',
            },
          ],
          name: 'setUp',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'target',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'badgeId',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'targetAddress',
              type: 'address',
            },
            {
              internalType: 'bytes4',
              name: 'functionSig',
              type: 'bytes4',
            },
            {
              internalType: 'uint8',
              name: 'paramIndex',
              type: 'uint8',
            },
          ],
          name: 'unscopeParameter',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '_newBadger',
              type: 'address',
            },
          ],
          name: 'updateBadger',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    KolektivoGuilder: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'owner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Approval',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'bytes32',
              name: 'oldId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'bytes32',
              name: 'newId',
              type: 'bytes32',
            },
          ],
          name: 'ExchangeIdentifierUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'factor',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'lastUpdated',
              type: 'uint256',
            },
          ],
          name: 'InflationFactorUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'rate',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'updatePeriod',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'lastUpdated',
              type: 'uint256',
            },
          ],
          name: 'InflationParametersUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'Transfer',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'string',
              name: 'comment',
              type: 'string',
            },
          ],
          name: 'TransferComment',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'accountOwner',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
          ],
          name: 'allowance',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'approve',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'accountOwner',
              type: 'address',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'bytes',
              name: 'blsKey',
              type: 'bytes',
            },
            {
              internalType: 'bytes',
              name: 'blsPop',
              type: 'bytes',
            },
          ],
          name: 'checkProofOfPossession',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'feeRecipient',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'gatewayFeeRecipient',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'communityFund',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'refund',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'tipTxFee',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'gatewayFee',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'baseTxFee',
              type: 'uint256',
            },
          ],
          name: 'creditGasFees',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'debitGasFees',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'decimals',
          outputs: [
            {
              internalType: 'uint8',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'decreaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'aNumerator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'aDenominator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bNumerator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'bDenominator',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'exponent',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '_decimals',
              type: 'uint256',
            },
          ],
          name: 'fractionMulExp',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'getBlockNumberFromHeader',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getEpochNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'getEpochNumberOfBlock',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getEpochSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getExchangeRegistryId',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getInflationParameters',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'getParentSealBitmap',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'getVerifiedSealBitmapFromHeader',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'getVersionNumber',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'pure',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes',
              name: 'header',
              type: 'bytes',
            },
          ],
          name: 'hashHeader',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'spender',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'increaseAllowance',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: '_name',
              type: 'string',
            },
            {
              internalType: 'string',
              name: '_symbol',
              type: 'string',
            },
            {
              internalType: 'uint8',
              name: '_decimals',
              type: 'uint8',
            },
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'inflationRate',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'inflationFactorUpdatePeriod',
              type: 'uint256',
            },
            {
              internalType: 'string',
              name: 'exchangeIdentifier',
              type: 'string',
            },
          ],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'minQuorumSize',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'minQuorumSizeInCurrentSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'mint',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'name',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'numberValidatorsInCurrentSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'numberValidatorsInSet',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'exchangeIdentifier',
              type: 'string',
            },
          ],
          name: 'setExchangeRegistryId',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'rate',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'updatePeriod',
              type: 'uint256',
            },
          ],
          name: 'setInflationParameters',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'symbol',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'totalSupply',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transfer',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'transferFrom',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
            {
              internalType: 'string',
              name: 'comment',
              type: 'string',
            },
          ],
          name: 'transferWithComment',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'units',
              type: 'uint256',
            },
          ],
          name: 'unitsToValue',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
          ],
          name: 'validatorSignerAddressFromCurrentSet',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'index',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'blockNumber',
              type: 'uint256',
            },
          ],
          name: 'validatorSignerAddressFromSet',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'valueToUnits',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    Vault: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'liquidityProvider',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              indexed: !1,
              internalType: 'int256[]',
              name: 'deltas',
              type: 'int256[]',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'protocolFeeAmounts',
              type: 'uint256[]',
            },
          ],
          name: 'PoolBalanceChanged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'assetManager',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'int256',
              name: 'cashDelta',
              type: 'int256',
            },
            {
              indexed: !1,
              internalType: 'int256',
              name: 'managedDelta',
              type: 'int256',
            },
          ],
          name: 'PoolBalanceManaged',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'poolAddress',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'enum IVault.PoolSpecialization',
              name: 'specialization',
              type: 'uint8',
            },
          ],
          name: 'PoolRegistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'tokenIn',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'contract IERC20',
              name: 'tokenOut',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amountIn',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'amountOut',
              type: 'uint256',
            },
          ],
          name: 'Swap',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
          ],
          name: 'TokensDeregistered',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              indexed: !1,
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              indexed: !1,
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
          ],
          name: 'TokensRegistered',
          type: 'event',
        },
        {
          inputs: [],
          name: 'WETH',
          outputs: [
            {
              internalType: 'contract IWETH',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.SwapKind',
              name: 'kind',
              type: 'uint8',
            },
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'int256[]',
              name: 'limits',
              type: 'int256[]',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'batchSwap',
          outputs: [
            {
              internalType: 'int256[]',
              name: '',
              type: 'int256[]',
            },
          ],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
          ],
          name: 'deregisterTokens',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address payable',
              name: 'recipient',
              type: 'address',
            },
            {
              components: [
                {
                  internalType: 'contract IAsset[]',
                  name: 'assets',
                  type: 'address[]',
                },
                {
                  internalType: 'uint256[]',
                  name: 'minAmountsOut',
                  type: 'uint256[]',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.ExitPoolRequest',
              name: 'request',
              type: 'tuple',
            },
          ],
          name: 'exitPool',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
          ],
          name: 'getPool',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'enum IVault.PoolSpecialization',
              name: '',
              type: 'uint8',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20',
              name: 'token',
              type: 'address',
            },
          ],
          name: 'getPoolTokenInfo',
          outputs: [
            {
              internalType: 'uint256',
              name: 'cash',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'managed',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
            {
              internalType: 'address',
              name: 'assetManager',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
          ],
          name: 'getPoolTokens',
          outputs: [
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'balances',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256',
              name: 'lastChangeBlock',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'recipient',
              type: 'address',
            },
            {
              components: [
                {
                  internalType: 'contract IAsset[]',
                  name: 'assets',
                  type: 'address[]',
                },
                {
                  internalType: 'uint256[]',
                  name: 'maxAmountsIn',
                  type: 'uint256[]',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.JoinPoolRequest',
              name: 'request',
              type: 'tuple',
            },
          ],
          name: 'joinPool',
          outputs: [],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'enum IVault.PoolBalanceOpKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'contract IERC20',
                  name: 'token',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
              ],
              internalType: 'struct IVault.PoolBalanceOp[]',
              name: 'ops',
              type: 'tuple[]',
            },
          ],
          name: 'managePoolBalance',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.SwapKind',
              name: 'kind',
              type: 'uint8',
            },
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
          ],
          name: 'queryBatchSwap',
          outputs: [
            {
              internalType: 'int256[]',
              name: 'assetDeltas',
              type: 'int256[]',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'enum IVault.PoolSpecialization',
              name: 'specialization',
              type: 'uint8',
            },
          ],
          name: 'registerPool',
          outputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'poolId',
              type: 'bytes32',
            },
            {
              internalType: 'contract IERC20[]',
              name: 'tokens',
              type: 'address[]',
            },
            {
              internalType: 'address[]',
              name: 'assetManagers',
              type: 'address[]',
            },
          ],
          name: 'registerTokens',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'enum IVault.SwapKind',
                  name: 'kind',
                  type: 'uint8',
                },
                {
                  internalType: 'contract IAsset',
                  name: 'assetIn',
                  type: 'address',
                },
                {
                  internalType: 'contract IAsset',
                  name: 'assetOut',
                  type: 'address',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.SingleSwap',
              name: 'singleSwap',
              type: 'tuple',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'uint256',
              name: 'limit',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'swap',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'payable',
          type: 'function',
        },
      ],
    },
    MentoRegistry: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'bool',
              name: 'isImplementation',
              type: 'bool',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
            {
              indexed: !0,
              internalType: 'bytes32',
              name: 'identifierHash',
              type: 'bytes32',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'addr',
              type: 'address',
            },
          ],
          name: 'RegistryUpdated',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'identifierHash',
              type: 'bytes32',
            },
          ],
          name: 'getAddressFor',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: 'identifierHash',
              type: 'bytes32',
            },
          ],
          name: 'getAddressForOrDie',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'getAddressForString',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
          ],
          name: 'getAddressForStringOrDie',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'initialize',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32[]',
              name: 'identifierHashes',
              type: 'bytes32[]',
            },
            {
              internalType: 'address',
              name: 'sender',
              type: 'address',
            },
          ],
          name: 'isOneOf',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes32',
              name: '',
              type: 'bytes32',
            },
          ],
          name: 'registry',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'identifier',
              type: 'string',
            },
            {
              internalType: 'address',
              name: 'addr',
              type: 'address',
            },
          ],
          name: 'setAddressFor',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    Freezer: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint8',
              name: 'version',
              type: 'uint8',
            },
          ],
          name: 'Initialized',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'RegistrySet',
          type: 'event',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'registry',
          outputs: [
            {
              internalType: 'contract IRegistry',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'registryAddress',
              type: 'address',
            },
          ],
          name: 'setRegistry',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
      ],
    },
    ProxyPool: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pairToken_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'vault_',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'reserve_',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'ceilingMultiplier_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'ceilingTradeShare_',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'floorTradeShare_',
              type: 'uint256',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'InvalidPendingOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByOwner',
          type: 'error',
        },
        {
          inputs: [],
          name: 'OnlyCallableByPendingOwner',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'NewOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousPendingOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newPendingOwner',
              type: 'address',
            },
          ],
          name: 'NewPendingOwner',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'Paused',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
          ],
          name: 'Unpaused',
          type: 'event',
        },
        {
          inputs: [],
          name: 'acceptOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'totalAmountIn',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'minTotalAmountOut',
              type: 'uint256',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'int256[]',
              name: 'limits',
              type: 'int256[]',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'batchSwapExactIn',
          outputs: [],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [
            {
              components: [
                {
                  internalType: 'bytes32',
                  name: 'poolId',
                  type: 'bytes32',
                },
                {
                  internalType: 'uint256',
                  name: 'assetInIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'assetOutIndex',
                  type: 'uint256',
                },
                {
                  internalType: 'uint256',
                  name: 'amount',
                  type: 'uint256',
                },
                {
                  internalType: 'bytes',
                  name: 'userData',
                  type: 'bytes',
                },
              ],
              internalType: 'struct IVault.BatchSwapStep[]',
              name: 'swaps',
              type: 'tuple[]',
            },
            {
              internalType: 'contract IAsset[]',
              name: 'assets',
              type: 'address[]',
            },
            {
              internalType: 'uint256',
              name: 'maxTotalAmountIn',
              type: 'uint256',
            },
            {
              components: [
                {
                  internalType: 'address',
                  name: 'sender',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'fromInternalBalance',
                  type: 'bool',
                },
                {
                  internalType: 'address payable',
                  name: 'recipient',
                  type: 'address',
                },
                {
                  internalType: 'bool',
                  name: 'toInternalBalance',
                  type: 'bool',
                },
              ],
              internalType: 'struct IVault.FundManagement',
              name: 'funds',
              type: 'tuple',
            },
            {
              internalType: 'int256[]',
              name: 'limits',
              type: 'int256[]',
            },
            {
              internalType: 'uint256',
              name: 'deadline',
              type: 'uint256',
            },
          ],
          name: 'batchSwapExactOut',
          outputs: [],
          stateMutability: 'payable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'ceilingMultiplier',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'ceilingTradeShare',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'floorTradeShare',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'inBalanceAfter',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'inBalanceBefore',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'outBalanceAfter',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'outBalanceBefore',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pairToken',
          outputs: [
            {
              internalType: 'contract ERC20',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pause',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'paused',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'pendingOwner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserve',
          outputs: [
            {
              internalType: 'contract IReserve',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'reserveToken',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'pendingOwner_',
              type: 'address',
            },
          ],
          name: 'setPendingOwner',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'unpause',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'vault',
          outputs: [
            {
              internalType: 'contract IVault',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    Badger: {
      address: '0x0000000000000000000000000000000000000000',
      abi: [
        {
          inputs: [
            {
              internalType: 'string',
              name: '_baseUri',
              type: 'string',
            },
          ],
          stateMutability: 'nonpayable',
          type: 'constructor',
        },
        {
          inputs: [],
          name: 'TransferDisabled',
          type: 'error',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'bool',
              name: 'approved',
              type: 'bool',
            },
          ],
          name: 'ApprovalForAll',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'previousOwner',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'OwnershipTransferred',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'tokenId',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'string',
              name: 'uri',
              type: 'string',
            },
          ],
          name: 'TokenUriUpdated',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'ids',
              type: 'uint256[]',
            },
            {
              indexed: !1,
              internalType: 'uint256[]',
              name: 'values',
              type: 'uint256[]',
            },
          ],
          name: 'TransferBatch',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !0,
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              indexed: !0,
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              indexed: !1,
              internalType: 'uint256',
              name: 'value',
              type: 'uint256',
            },
          ],
          name: 'TransferSingle',
          type: 'event',
        },
        {
          anonymous: !1,
          inputs: [
            {
              indexed: !1,
              internalType: 'string',
              name: 'value',
              type: 'string',
            },
            {
              indexed: !0,
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'URI',
          type: 'event',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
          ],
          name: 'balanceOf',
          outputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address[]',
              name: 'accounts',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'ids',
              type: 'uint256[]',
            },
          ],
          name: 'balanceOfBatch',
          outputs: [
            {
              internalType: 'uint256[]',
              name: '',
              type: 'uint256[]',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'burn',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address[]',
              name: 'accounts',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'tokenIds',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: 'amounts',
              type: 'uint256[]',
            },
          ],
          name: 'burnFromMultiple',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'operator',
              type: 'address',
            },
          ],
          name: 'isApprovedForAll',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'account',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
          ],
          name: 'mint',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address[]',
              name: 'accounts',
              type: 'address[]',
            },
            {
              internalType: 'uint256[]',
              name: 'tokenIds',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: 'amounts',
              type: 'uint256[]',
            },
          ],
          name: 'mintToMultiple',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [],
          name: 'owner',
          outputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [],
          name: 'renounceOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256[]',
              name: 'ids',
              type: 'uint256[]',
            },
            {
              internalType: 'uint256[]',
              name: 'amounts',
              type: 'uint256[]',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'safeBatchTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'from',
              type: 'address',
            },
            {
              internalType: 'address',
              name: 'to',
              type: 'address',
            },
            {
              internalType: 'uint256',
              name: 'id',
              type: 'uint256',
            },
            {
              internalType: 'uint256',
              name: 'amount',
              type: 'uint256',
            },
            {
              internalType: 'bytes',
              name: 'data',
              type: 'bytes',
            },
          ],
          name: 'safeTransferFrom',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: '',
              type: 'address',
            },
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          name: 'setApprovalForAll',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'string',
              name: 'baseUri',
              type: 'string',
            },
          ],
          name: 'setBaseUri',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'tokenId',
              type: 'uint256',
            },
            {
              internalType: 'string',
              name: 'newUri',
              type: 'string',
            },
          ],
          name: 'setUri',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'bytes4',
              name: 'interfaceId',
              type: 'bytes4',
            },
          ],
          name: 'supportsInterface',
          outputs: [
            {
              internalType: 'bool',
              name: '',
              type: 'bool',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: '',
              type: 'uint256',
            },
          ],
          name: 'tokenUris',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'address',
              name: 'newOwner',
              type: 'address',
            },
          ],
          name: 'transferOwnership',
          outputs: [],
          stateMutability: 'nonpayable',
          type: 'function',
        },
        {
          inputs: [
            {
              internalType: 'uint256',
              name: 'tokenId',
              type: 'uint256',
            },
          ],
          name: 'uri',
          outputs: [
            {
              internalType: 'string',
              name: '',
              type: 'string',
            },
          ],
          stateMutability: 'view',
          type: 'function',
        },
      ],
    },
    cUSD: {
      address: '0x765DE816845861e75A25fCA122bb6898B8B1282a',
      abi: 'ERC20',
    },
  },
  KD = {
    name: A5,
    chainId: E5,
    contracts: S5,
  },
  WD = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        chainId: E5,
        contracts: S5,
        default: KD,
        name: A5,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  C5 = [
    {
      inputs: [
        {
          internalType: 'string',
          name: '_baseUri',
          type: 'string',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'constructor',
    },
    {
      inputs: [],
      name: 'TransferDisabled',
      type: 'error',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'account',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'approved',
          type: 'bool',
        },
      ],
      name: 'ApprovalForAll',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousOwner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'OwnershipTransferred',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'tokenId',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'string',
          name: 'uri',
          type: 'string',
        },
      ],
      name: 'TokenUriUpdated',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256[]',
          name: 'ids',
          type: 'uint256[]',
        },
        {
          indexed: !1,
          internalType: 'uint256[]',
          name: 'values',
          type: 'uint256[]',
        },
      ],
      name: 'TransferBatch',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
      ],
      name: 'TransferSingle',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'string',
          name: 'value',
          type: 'string',
        },
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'URI',
      type: 'event',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'account',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'balanceOf',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address[]',
          name: 'accounts',
          type: 'address[]',
        },
        {
          internalType: 'uint256[]',
          name: 'ids',
          type: 'uint256[]',
        },
      ],
      name: 'balanceOfBatch',
      outputs: [
        {
          internalType: 'uint256[]',
          name: '',
          type: 'uint256[]',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'account',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'burn',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address[]',
          name: 'accounts',
          type: 'address[]',
        },
        {
          internalType: 'uint256[]',
          name: 'tokenIds',
          type: 'uint256[]',
        },
        {
          internalType: 'uint256[]',
          name: 'amounts',
          type: 'uint256[]',
        },
      ],
      name: 'burnFromMultiple',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'account',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
      ],
      name: 'isApprovedForAll',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'account',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'mint',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address[]',
          name: 'accounts',
          type: 'address[]',
        },
        {
          internalType: 'uint256[]',
          name: 'tokenIds',
          type: 'uint256[]',
        },
        {
          internalType: 'uint256[]',
          name: 'amounts',
          type: 'uint256[]',
        },
      ],
      name: 'mintToMultiple',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'owner',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'renounceOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256[]',
          name: 'ids',
          type: 'uint256[]',
        },
        {
          internalType: 'uint256[]',
          name: 'amounts',
          type: 'uint256[]',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
      ],
      name: 'safeBatchTransferFrom',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
      ],
      name: 'safeTransferFrom',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      name: 'setApprovalForAll',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'string',
          name: 'baseUri',
          type: 'string',
        },
      ],
      name: 'setBaseUri',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'tokenId',
          type: 'uint256',
        },
        {
          internalType: 'string',
          name: 'newUri',
          type: 'string',
        },
      ],
      name: 'setUri',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes4',
          name: 'interfaceId',
          type: 'bytes4',
        },
      ],
      name: 'supportsInterface',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      name: 'tokenUris',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'transferOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'tokenId',
          type: 'uint256',
        },
      ],
      name: 'uri',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
  ],
  M5 = [
    {
      inputs: [
        {
          internalType: 'address',
          name: '_owner',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '_avatar',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '_target',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '_badger',
          type: 'address',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'constructor',
    },
    {
      inputs: [],
      name: 'ArraysDifferentLength',
      type: 'error',
    },
    {
      inputs: [],
      name: 'ModuleTransactionFailed',
      type: 'error',
    },
    {
      inputs: [],
      name: 'NoMembership',
      type: 'error',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'guard_',
          type: 'address',
        },
      ],
      name: 'NotIERC165Compliant',
      type: 'error',
    },
    {
      inputs: [],
      name: 'RedundantUpdateOfState',
      type: 'error',
    },
    {
      inputs: [],
      name: 'SetUpModulesAlreadyCalled',
      type: 'error',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousAvatar',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newAvatar',
          type: 'address',
        },
      ],
      name: 'AvatarSet',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'badgerAddress',
          type: 'address',
        },
      ],
      name: 'BadgerUpdated',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'guard',
          type: 'address',
        },
      ],
      name: 'ChangedGuard',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'uint8',
          name: 'version',
          type: 'uint8',
        },
      ],
      name: 'Initialized',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousOwner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'OwnershipTransferred',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'initiator',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'avatar',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'RolesModSetup',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'multisendAddress',
          type: 'address',
        },
      ],
      name: 'SetMultisendAddress',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousTarget',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newTarget',
          type: 'address',
        },
      ],
      name: 'TargetSet',
      type: 'event',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'enum ExecutionOptions',
          name: 'options',
          type: 'uint8',
        },
      ],
      name: 'allowTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'avatar',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'badger',
      outputs: [
        {
          internalType: 'contract IBadger',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
      ],
      name: 'execTransactionFromModule',
      outputs: [
        {
          internalType: 'bool',
          name: 'success',
          type: 'bool',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
      ],
      name: 'execTransactionFromModuleReturnData',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
        {
          internalType: 'bytes',
          name: '',
          type: 'bytes',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'getGuard',
      outputs: [
        {
          internalType: 'address',
          name: '_guard',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'guard',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'multisend',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'owner',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'renounceOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
      ],
      name: 'revokeTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'enum ExecutionOptions',
          name: 'options',
          type: 'uint8',
        },
      ],
      name: 'scopeAllowFunction',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'bool[]',
          name: 'isParamScoped',
          type: 'bool[]',
        },
        {
          internalType: 'enum ParameterType[]',
          name: 'paramType',
          type: 'uint8[]',
        },
        {
          internalType: 'enum Comparison[]',
          name: 'paramComp',
          type: 'uint8[]',
        },
        {
          internalType: 'bytes[]',
          name: 'compValue',
          type: 'bytes[]',
        },
        {
          internalType: 'enum ExecutionOptions',
          name: 'options',
          type: 'uint8',
        },
      ],
      name: 'scopeFunction',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'enum ExecutionOptions',
          name: 'options',
          type: 'uint8',
        },
      ],
      name: 'scopeFunctionExecutionOptions',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'uint256',
          name: 'paramIndex',
          type: 'uint256',
        },
        {
          internalType: 'enum ParameterType',
          name: 'paramType',
          type: 'uint8',
        },
        {
          internalType: 'enum Comparison',
          name: 'paramComp',
          type: 'uint8',
        },
        {
          internalType: 'bytes',
          name: 'compValue',
          type: 'bytes',
        },
      ],
      name: 'scopeParameter',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'uint256',
          name: 'paramIndex',
          type: 'uint256',
        },
        {
          internalType: 'enum ParameterType',
          name: 'paramType',
          type: 'uint8',
        },
        {
          internalType: 'bytes[]',
          name: 'compValues',
          type: 'bytes[]',
        },
      ],
      name: 'scopeParameterAsOneOf',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
      ],
      name: 'scopeRevokeFunction',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
      ],
      name: 'scopeTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_avatar',
          type: 'address',
        },
      ],
      name: 'setAvatar',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_guard',
          type: 'address',
        },
      ],
      name: 'setGuard',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_multisend',
          type: 'address',
        },
      ],
      name: 'setMultisend',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_target',
          type: 'address',
        },
      ],
      name: 'setTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes',
          name: 'initParams',
          type: 'bytes',
        },
      ],
      name: 'setUp',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'target',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'transferOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'badgeId',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: 'targetAddress',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'uint8',
          name: 'paramIndex',
          type: 'uint8',
        },
      ],
      name: 'unscopeParameter',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_newBadger',
          type: 'address',
        },
      ],
      name: 'updateBadger',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  _5 = [
    {
      inputs: [
        {
          internalType: 'address',
          name: '_owner',
          type: 'address',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'constructor',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'uint8',
          name: 'version',
          type: 'uint8',
        },
      ],
      name: 'Initialized',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousOwner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'OwnershipTransferred',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'initiator',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
      ],
      name: 'ScopeGuardSetup',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
      ],
      name: 'SetDelegateCallAllowedOnTarget',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
      ],
      name: 'SetFallbackAllowedOnTarget',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
      ],
      name: 'SetFunctionAllowedOnTarget',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
      ],
      name: 'SetTargetAllowed',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'scoped',
          type: 'bool',
        },
      ],
      name: 'SetTargetScoped',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
      ],
      name: 'SetValueAllowedOnTarget',
      type: 'event',
    },
    {
      stateMutability: 'nonpayable',
      type: 'fallback',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'allowedTargets',
      outputs: [
        {
          internalType: 'bool',
          name: 'allowed',
          type: 'bool',
        },
        {
          internalType: 'bool',
          name: 'scoped',
          type: 'bool',
        },
        {
          internalType: 'bool',
          name: 'delegateCallAllowed',
          type: 'bool',
        },
        {
          internalType: 'bool',
          name: 'fallbackAllowed',
          type: 'bool',
        },
        {
          internalType: 'bool',
          name: 'valueAllowed',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      name: 'checkAfterExecution',
      outputs: [],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
        {
          internalType: 'address payable',
          name: '',
          type: 'address',
        },
        {
          internalType: 'bytes',
          name: '',
          type: 'bytes',
        },
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'checkTransaction',
      outputs: [],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
      ],
      name: 'isAllowedFunction',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'isAllowedTarget',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'isAllowedToDelegateCall',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'isScoped',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'isValueAllowed',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'isfallbackAllowed',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'owner',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'renounceOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bytes4',
          name: 'functionSig',
          type: 'bytes4',
        },
        {
          internalType: 'bool',
          name: 'allow',
          type: 'bool',
        },
      ],
      name: 'setAllowedFunction',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'allow',
          type: 'bool',
        },
      ],
      name: 'setDelegateCallAllowedOnTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'allow',
          type: 'bool',
        },
      ],
      name: 'setFallbackAllowedOnTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'scoped',
          type: 'bool',
        },
      ],
      name: 'setScoped',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'allow',
          type: 'bool',
        },
      ],
      name: 'setTargetAllowed',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes',
          name: 'initializeParams',
          type: 'bytes',
        },
      ],
      name: 'setUp',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'allow',
          type: 'bool',
        },
      ],
      name: 'setValueAllowedOnTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes4',
          name: 'interfaceId',
          type: 'bytes4',
        },
      ],
      name: 'supportsInterface',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'pure',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'transferOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  R5 = [
    {
      inputs: [
        {
          internalType: 'address',
          name: '_owner',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '_avatar',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '_target',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: '_cooldown',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: '_expiration',
          type: 'uint256',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'constructor',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'AlreadyDisabledModule',
      type: 'error',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'AlreadyEnabledModule',
      type: 'error',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'InvalidModule',
      type: 'error',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'sender',
          type: 'address',
        },
      ],
      name: 'NotAuthorized',
      type: 'error',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'guard_',
          type: 'address',
        },
      ],
      name: 'NotIERC165Compliant',
      type: 'error',
    },
    {
      inputs: [],
      name: 'RedundantUpdateOfState',
      type: 'error',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousAvatar',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newAvatar',
          type: 'address',
        },
      ],
      name: 'AvatarSet',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'guard',
          type: 'address',
        },
      ],
      name: 'ChangedGuard',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'initiator',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'avatar',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'address',
          name: 'target',
          type: 'address',
        },
      ],
      name: 'DelaySetup',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'DisabledModule',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'EnabledModule',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'ExecutionFromModuleFailure',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'ExecutionFromModuleSuccess',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'uint8',
          name: 'version',
          type: 'uint8',
        },
      ],
      name: 'Initialized',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousOwner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'OwnershipTransferred',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'queueIndex',
          type: 'uint256',
        },
        {
          indexed: !0,
          internalType: 'bytes32',
          name: 'txHash',
          type: 'bytes32',
        },
        {
          indexed: !1,
          internalType: 'string',
          name: 'uri',
          type: 'string',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'salt',
          type: 'uint256',
        },
      ],
      name: 'SecretTransactionAdded',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          indexed: !1,
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: '_salt',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'txIndex',
          type: 'uint256',
        },
      ],
      name: 'SecretTransactionExecuted',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'previousTarget',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'newTarget',
          type: 'address',
        },
      ],
      name: 'TargetSet',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'queueIndex',
          type: 'uint256',
        },
        {
          indexed: !0,
          internalType: 'bytes32',
          name: 'txHash',
          type: 'bytes32',
        },
        {
          indexed: !1,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          indexed: !1,
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
      ],
      name: 'TransactionAdded',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !1,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          indexed: !1,
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'txIndex',
          type: 'uint256',
        },
      ],
      name: 'TransactionExecuted',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'startingApprovedTrxNonce',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'numberOfTrxApproved',
          type: 'uint256',
        },
      ],
      name: 'TransactionsApproved',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'startingVetoedTrxNonce',
          type: 'uint256',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'numberOfTrxVetoed',
          type: 'uint256',
        },
      ],
      name: 'TransactionsVetoed',
      type: 'event',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '_transactions',
          type: 'uint256',
        },
      ],
      name: 'approveNext',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'approved',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'avatar',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'prevModule',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'disableModule',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'module',
          type: 'address',
        },
      ],
      name: 'enableModule',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes32',
          name: 'hashedTransaction',
          type: 'bytes32',
        },
        {
          internalType: 'string',
          name: 'uri',
          type: 'string',
        },
      ],
      name: 'enqueueSecretTx',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
      ],
      name: 'execTransactionFromModule',
      outputs: [
        {
          internalType: 'bool',
          name: 'success',
          type: 'bool',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
      ],
      name: 'execTransactionFromModuleReturnData',
      outputs: [
        {
          internalType: 'bool',
          name: 'success',
          type: 'bool',
        },
        {
          internalType: 'bytes',
          name: 'returnData',
          type: 'bytes',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          internalType: 'uint256',
          name: '_salt',
          type: 'uint256',
        },
      ],
      name: 'executeNextSecretTx',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
      ],
      name: 'executeNextTx',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'getGuard',
      outputs: [
        {
          internalType: 'address',
          name: '_guard',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'start',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'pageSize',
          type: 'uint256',
        },
      ],
      name: 'getModulesPaginated',
      outputs: [
        {
          internalType: 'address[]',
          name: 'array',
          type: 'address[]',
        },
        {
          internalType: 'address',
          name: 'next',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
        {
          internalType: 'uint256',
          name: '_salt',
          type: 'uint256',
        },
      ],
      name: 'getSecretTransactionHash',
      outputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
      ],
      stateMutability: 'pure',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
        {
          internalType: 'enum Enum.Operation',
          name: 'operation',
          type: 'uint8',
        },
      ],
      name: 'getTransactionHash',
      outputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
      ],
      stateMutability: 'pure',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '_nonce',
          type: 'uint256',
        },
      ],
      name: 'getTxCreatedAt',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '_nonce',
          type: 'uint256',
        },
      ],
      name: 'getTxHash',
      outputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'guard',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_module',
          type: 'address',
        },
      ],
      name: 'isModuleEnabled',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'owner',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'queuePointer',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'renounceOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'salt',
      outputs: [
        {
          internalType: 'uint256',
          name: '_value',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_avatar',
          type: 'address',
        },
      ],
      name: 'setAvatar',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_guard',
          type: 'address',
        },
      ],
      name: 'setGuard',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '_target',
          type: 'address',
        },
      ],
      name: 'setTarget',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'cooldown',
          type: 'uint256',
        },
      ],
      name: 'setTxCooldown',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'expiration',
          type: 'uint256',
        },
      ],
      name: 'setTxExpiration',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes',
          name: 'initParams',
          type: 'bytes',
        },
      ],
      name: 'setUp',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'skipExpired',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'target',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'newOwner',
          type: 'address',
        },
      ],
      name: 'transferOwnership',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'txCooldown',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      name: 'txCreatedAt',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'txExpiration',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      name: 'txHash',
      outputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'txNonce',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '_newTxNonce',
          type: 'uint256',
        },
      ],
      name: 'vetoTransactionsTill',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '_newTxNonce',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: '_transactions',
          type: 'uint256',
        },
      ],
      name: 'vetoTransactionsTillAndApprove',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  JD = {
    Badger: C5,
    BACRoles: M5,
    ScopeGuard: _5,
    SecretDelay: R5,
  },
  QD = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        BACRoles: M5,
        Badger: C5,
        ScopeGuard: _5,
        SecretDelay: R5,
        default: JD,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  YD = {},
  XD = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        default: YD,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  I5 = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'spender',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'Approval',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'Transfer',
      type: 'event',
    },
    {
      inputs: [],
      name: 'DOMAIN_SEPARATOR',
      outputs: [
        {
          internalType: 'bytes32',
          name: '',
          type: 'bytes32',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'allowance',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'spender',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'approve',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'balanceOf',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'decimals',
      outputs: [
        {
          internalType: 'uint8',
          name: '',
          type: 'uint8',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'name',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'nonces',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'spender',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'value',
          type: 'uint256',
        },
        {
          internalType: 'uint256',
          name: 'deadline',
          type: 'uint256',
        },
        {
          internalType: 'uint8',
          name: 'v',
          type: 'uint8',
        },
        {
          internalType: 'bytes32',
          name: 'r',
          type: 'bytes32',
        },
        {
          internalType: 'bytes32',
          name: 's',
          type: 'bytes32',
        },
      ],
      name: 'permit',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [],
      name: 'symbol',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'totalSupply',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'transfer',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'amount',
          type: 'uint256',
        },
      ],
      name: 'transferFrom',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  O5 = [
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'spender',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'Approval',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
        {
          indexed: !1,
          internalType: 'bool',
          name: 'approved',
          type: 'bool',
        },
      ],
      name: 'ApprovalForAll',
      type: 'event',
    },
    {
      anonymous: !1,
      inputs: [
        {
          indexed: !0,
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          indexed: !0,
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'Transfer',
      type: 'event',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'spender',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'approve',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
      ],
      name: 'balanceOf',
      outputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: '',
          type: 'uint256',
        },
      ],
      name: 'getApproved',
      outputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
        {
          internalType: 'address',
          name: '',
          type: 'address',
        },
      ],
      name: 'isApprovedForAll',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'name',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'ownerOf',
      outputs: [
        {
          internalType: 'address',
          name: 'owner',
          type: 'address',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'safeTransferFrom',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
        {
          internalType: 'bytes',
          name: 'data',
          type: 'bytes',
        },
      ],
      name: 'safeTransferFrom',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'operator',
          type: 'address',
        },
        {
          internalType: 'bool',
          name: 'approved',
          type: 'bool',
        },
      ],
      name: 'setApprovalForAll',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'bytes4',
          name: 'interfaceId',
          type: 'bytes4',
        },
      ],
      name: 'supportsInterface',
      outputs: [
        {
          internalType: 'bool',
          name: '',
          type: 'bool',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [],
      name: 'symbol',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'tokenURI',
      outputs: [
        {
          internalType: 'string',
          name: '',
          type: 'string',
        },
      ],
      stateMutability: 'view',
      type: 'function',
    },
    {
      inputs: [
        {
          internalType: 'address',
          name: 'from',
          type: 'address',
        },
        {
          internalType: 'address',
          name: 'to',
          type: 'address',
        },
        {
          internalType: 'uint256',
          name: 'id',
          type: 'uint256',
        },
      ],
      name: 'transferFrom',
      outputs: [],
      stateMutability: 'nonpayable',
      type: 'function',
    },
  ],
  ZD = {
    ERC20: I5,
    ERC721: O5,
  },
  eB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        ERC20: I5,
        ERC721: O5,
        default: ZD,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  );
var tB = k5,
  Qv = 128,
  nB = 127,
  iB = ~nB,
  rB = Math.pow(2, 31);
function k5(n, e, t) {
  (e = e || []), (t = t || 0);
  for (var i = t; n >= rB; ) (e[t++] = (n & 255) | Qv), (n /= 128);
  for (; n & iB; ) (e[t++] = (n & 255) | Qv), (n >>>= 7);
  return (e[t] = n | 0), (k5.bytes = t - i + 1), e;
}
var sB = oh,
  aB = 128,
  Yv = 127;
function oh(n, i) {
  var t = 0,
    i = i || 0,
    r = 0,
    s = i,
    a,
    o = n.length;
  do {
    if (s >= o) throw ((oh.bytes = 0), new RangeError('Could not decode varint'));
    (a = n[s++]), (t += r < 28 ? (a & Yv) << r : (a & Yv) * Math.pow(2, r)), (r += 7);
  } while (a >= aB);
  return (oh.bytes = s - i), t;
}
var oB = Math.pow(2, 7),
  uB = Math.pow(2, 14),
  lB = Math.pow(2, 21),
  dB = Math.pow(2, 28),
  cB = Math.pow(2, 35),
  pB = Math.pow(2, 42),
  fB = Math.pow(2, 49),
  yB = Math.pow(2, 56),
  hB = Math.pow(2, 63),
  mB = function (n) {
    return n < oB ? 1 : n < uB ? 2 : n < lB ? 3 : n < dB ? 4 : n < cB ? 5 : n < pB ? 6 : n < fB ? 7 : n < yB ? 8 : n < hB ? 9 : 10;
  },
  bB = {
    encode: tB,
    decode: sB,
    encodingLength: mB,
  },
  $c = bB;
const uh = (n, e = 0) => [$c.decode(n, e), $c.decode.bytes],
  Uc = (n, e, t = 0) => ($c.encode(n, e, t), e),
  jc = (n) => $c.encodingLength(n),
  gB = (n, e) => {
    if (n === e) return !0;
    if (n.byteLength !== e.byteLength) return !1;
    for (let t = 0; t < n.byteLength; t++) if (n[t] !== e[t]) return !1;
    return !0;
  },
  fm = (n) => {
    if (n instanceof Uint8Array && n.constructor.name === 'Uint8Array') return n;
    if (n instanceof ArrayBuffer) return new Uint8Array(n);
    if (ArrayBuffer.isView(n)) return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
    throw new Error('Unknown type, must be binary type');
  },
  vB = (n) => new TextEncoder().encode(n),
  xB = (n) => new TextDecoder().decode(n),
  TB = (n, e) => {
    const t = e.byteLength,
      i = jc(n),
      r = i + jc(t),
      s = new Uint8Array(r + t);
    return Uc(n, s, 0), Uc(t, s, i), s.set(e, r), new ym(n, t, e, s);
  },
  wB = (n) => {
    const e = fm(n),
      [t, i] = uh(e),
      [r, s] = uh(e.subarray(i)),
      a = e.subarray(i + s);
    if (a.byteLength !== r) throw new Error('Incorrect length');
    return new ym(t, r, a, e);
  },
  AB = (n, e) => {
    if (n === e) return !0;
    {
      const t =
        /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
        e;
      return n.code === t.code && n.size === t.size && t.bytes instanceof Uint8Array && gB(n.bytes, t.bytes);
    }
  };
class ym {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(e, t, i, r) {
    (this.code = e), (this.size = t), (this.digest = i), (this.bytes = r);
  }
}
function EB(n, e) {
  if (n.length >= 255) throw new TypeError('Alphabet too long');
  for (var t = new Uint8Array(256), i = 0; i < t.length; i++) t[i] = 255;
  for (var r = 0; r < n.length; r++) {
    var s = n.charAt(r),
      a = s.charCodeAt(0);
    if (t[a] !== 255) throw new TypeError(s + ' is ambiguous');
    t[a] = r;
  }
  var o = n.length,
    u = n.charAt(0),
    l = Math.log(o) / Math.log(256),
    c = Math.log(256) / Math.log(o);
  function f(v) {
    if ((v instanceof Uint8Array || (ArrayBuffer.isView(v) ? (v = new Uint8Array(v.buffer, v.byteOffset, v.byteLength)) : Array.isArray(v) && (v = Uint8Array.from(v))), !(v instanceof Uint8Array)))
      throw new TypeError('Expected Uint8Array');
    if (v.length === 0) return '';
    for (var T = 0, A = 0, _ = 0, O = v.length; _ !== O && v[_] === 0; ) _++, T++;
    for (var B = ((O - _) * c + 1) >>> 0, P = new Uint8Array(B); _ !== O; ) {
      for (var N = v[_], U = 0, W = B - 1; (N !== 0 || U < A) && W !== -1; W--, U++) (N += (256 * P[W]) >>> 0), (P[W] = N % o >>> 0), (N = (N / o) >>> 0);
      if (N !== 0) throw new Error('Non-zero carry');
      (A = U), _++;
    }
    for (var z = B - A; z !== B && P[z] === 0; ) z++;
    for (var Y = u.repeat(T); z < B; ++z) Y += n.charAt(P[z]);
    return Y;
  }
  function m(v) {
    if (typeof v != 'string') throw new TypeError('Expected String');
    if (v.length === 0) return new Uint8Array();
    var T = 0;
    if (v[T] !== ' ') {
      for (var A = 0, _ = 0; v[T] === u; ) A++, T++;
      for (var O = ((v.length - T) * l + 1) >>> 0, B = new Uint8Array(O); v[T]; ) {
        var P = t[v.charCodeAt(T)];
        if (P === 255) return;
        for (var N = 0, U = O - 1; (P !== 0 || N < _) && U !== -1; U--, N++) (P += (o * B[U]) >>> 0), (B[U] = P % 256 >>> 0), (P = (P / 256) >>> 0);
        if (P !== 0) throw new Error('Non-zero carry');
        (_ = N), T++;
      }
      if (v[T] !== ' ') {
        for (var W = O - _; W !== O && B[W] === 0; ) W++;
        for (var z = new Uint8Array(A + (O - W)), Y = A; W !== O; ) z[Y++] = B[W++];
        return z;
      }
    }
  }
  function w(v) {
    var T = m(v);
    if (T) return T;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: f,
    decodeUnsafe: m,
    decode: w,
  };
}
var SB = EB,
  CB = SB;
class MB {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(e, t, i) {
    (this.name = e), (this.prefix = t), (this.baseEncode = i);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(e) {
    if (e instanceof Uint8Array) return `${this.prefix}${this.baseEncode(e)}`;
    throw Error('Unknown type, must be binary type');
  }
}
class _B {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, t, i) {
    if (((this.name = e), (this.prefix = t), t.codePointAt(0) === void 0)) throw new Error('Invalid prefix character');
    (this.prefixCodePoint = /** @type {number} */ t.codePointAt(0)), (this.baseDecode = i);
  }
  /**
   * @param {string} text
   */
  decode(e) {
    if (typeof e == 'string') {
      if (e.codePointAt(0) !== this.prefixCodePoint) throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else throw Error('Can only multibase decode strings');
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return P5(this, e);
  }
}
class RB {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(e) {
    this.decoders = e;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return P5(this, e);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(e) {
    const t =
        /** @type {Prefix} */
        e[0],
      i = this.decoders[t];
    if (i) return i.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const P5 = (n, e) =>
  new RB(
    /** @type {Decoders<L|R>} */
    {
      ...(n.decoders || {
        [/** @type API.UnibaseDecoder<L> */
        n.prefix]: n,
      }),
      ...(e.decoders || {
        [/** @type API.UnibaseDecoder<R> */
        e.prefix]: e,
      }),
    },
  );
class IB {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, t, i, r) {
    (this.name = e), (this.prefix = t), (this.baseEncode = i), (this.baseDecode = r), (this.encoder = new MB(e, t, i)), (this.decoder = new _B(e, t, r));
  }
  /**
   * @param {Uint8Array} input
   */
  encode(e) {
    return this.encoder.encode(e);
  }
  /**
   * @param {string} input
   */
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Rp = ({ name: n, prefix: e, encode: t, decode: i }) => new IB(n, e, t, i),
  Hl = ({ prefix: n, name: e, alphabet: t }) => {
    const { encode: i, decode: r } = CB(t, e);
    return Rp({
      prefix: n,
      name: e,
      encode: i,
      /**
       * @param {string} text
       */
      decode: (s) => fm(r(s)),
    });
  },
  OB = (n, e, t, i) => {
    const r = {};
    for (let c = 0; c < e.length; ++c) r[e[c]] = c;
    let s = n.length;
    for (; n[s - 1] === '='; ) --s;
    const a = new Uint8Array(((s * t) / 8) | 0);
    let o = 0,
      u = 0,
      l = 0;
    for (let c = 0; c < s; ++c) {
      const f = r[n[c]];
      if (f === void 0) throw new SyntaxError(`Non-${i} character`);
      (u = (u << t) | f), (o += t), o >= 8 && ((o -= 8), (a[l++] = 255 & (u >> o)));
    }
    if (o >= t || 255 & (u << (8 - o))) throw new SyntaxError('Unexpected end of data');
    return a;
  },
  kB = (n, e, t) => {
    const i = e[e.length - 1] === '=',
      r = (1 << t) - 1;
    let s = '',
      a = 0,
      o = 0;
    for (let u = 0; u < n.length; ++u) for (o = (o << 8) | n[u], a += 8; a > t; ) (a -= t), (s += e[r & (o >> a)]);
    if ((a && (s += e[r & (o << (t - a))]), i)) for (; (s.length * t) & 7; ) s += '=';
    return s;
  },
  yn = ({ name: n, prefix: e, bitsPerChar: t, alphabet: i }) =>
    Rp({
      prefix: e,
      name: n,
      encode(r) {
        return kB(r, i, t);
      },
      decode(r) {
        return OB(r, i, t, n);
      },
    }),
  vr = Hl({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz',
  }),
  PB = Hl({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ',
  }),
  NB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base58btc: vr,
        base58flickr: PB,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Du = yn({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5,
  }),
  DB = yn({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5,
  }),
  BB = yn({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5,
  }),
  FB = yn({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5,
  }),
  LB = yn({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5,
  }),
  $B = yn({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5,
  }),
  UB = yn({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5,
  }),
  jB = yn({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5,
  }),
  VB = yn({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5,
  }),
  zB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base32: Du,
        base32hex: LB,
        base32hexpad: UB,
        base32hexpadupper: jB,
        base32hexupper: $B,
        base32pad: BB,
        base32padupper: FB,
        base32upper: DB,
        base32z: VB,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  lh = (n, e) => {
    const { bytes: t, version: i } = n;
    switch (i) {
      case 0:
        return qB(
          t,
          dh(n),
          /** @type {API.MultibaseEncoder<"z">} */
          e || vr.encoder,
        );
      default:
        return HB(
          t,
          dh(n),
          /** @type {API.MultibaseEncoder<Prefix>} */
          e || Du.encoder,
        );
    }
  },
  Xv = /* @__PURE__ */ new WeakMap(),
  dh = (n) => {
    const e = Xv.get(n);
    if (e == null) {
      const t = /* @__PURE__ */ new Map();
      return Xv.set(n, t), t;
    }
    return e;
  };
class rn {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(e, t, i, r) {
    (this.code = t), (this.version = e), (this.multihash = i), (this.bytes = r), (this['/'] = r);
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0:
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      case 1: {
        const { code: e, multihash: t } = this;
        if (e !== du) throw new Error('Cannot convert a non dag-pb CID to CIDv0');
        if (t.code !== KB) throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          rn.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            t,
          )
        );
      }
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: t } = this.multihash,
          i = TB(e, t);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          rn.createV1(this.code, i)
        );
      }
      case 1:
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      default:
        throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(e) {
    return rn.equals(this, e);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(e, t) {
    const i =
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      t;
    return i && e.code === i.code && e.version === i.version && AB(e.multihash, i.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(e) {
    return lh(this, e);
  }
  toJSON() {
    return { '/': lh(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return 'CID';
  }
  // Legacy
  [Symbol.for('nodejs.util.inspect.custom')]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(e) {
    if (e == null) return null;
    const t =
      /** @type {any} */
      e;
    if (t instanceof rn) return t;
    if ((t['/'] != null && t['/'] === t.bytes) || t.asCID === t) {
      const { version: i, code: r, multihash: s, bytes: a } = t;
      return new rn(
        i,
        r,
        /** @type {API.MultihashDigest<Alg>} */
        s,
        a || Zv(i, r, s.bytes),
      );
    } else if (t[WB] === !0) {
      const { version: i, multihash: r, code: s } = t,
        a =
          /** @type {API.MultihashDigest<Alg>} */
          wB(r);
      return rn.create(i, s, a);
    } else return null;
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(e, t, i) {
    if (typeof t != 'number') throw new Error('String codecs are no longer supported');
    if (!(i.bytes instanceof Uint8Array)) throw new Error('Invalid digest');
    switch (e) {
      case 0: {
        if (t !== du) throw new Error(`Version 0 CID must use dag-pb (code: ${du}) block encoding`);
        return new rn(e, t, i, i.bytes);
      }
      case 1: {
        const r = Zv(e, t, i.bytes);
        return new rn(e, t, i, r);
      }
      default:
        throw new Error('Invalid version');
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(e) {
    return rn.create(0, du, e);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(e, t) {
    return rn.create(1, e, t);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(e) {
    const [t, i] = rn.decodeFirst(e);
    if (i.length) throw new Error('Incorrect length');
    return t;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(e) {
    const t = rn.inspectBytes(e),
      i = t.size - t.multihashSize,
      r = fm(e.subarray(i, i + t.multihashSize));
    if (r.byteLength !== t.multihashSize) throw new Error('Incorrect length');
    const s = r.subarray(t.multihashSize - t.digestSize),
      a = new ym(t.multihashCode, t.digestSize, s, r);
    return [
      t.version === 0
        ? rn.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            a,
          )
        : rn.createV1(t.codec, a),
      e.subarray(t.size),
    ];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(e) {
    let t = 0;
    const i = () => {
      const [f, m] = uh(e.subarray(t));
      return (t += m), f;
    };
    let r =
        /** @type {V} */
        i(),
      s =
        /** @type {C} */
        du;
    if (/** @type {number} */ (r === 18 ? ((r = /** @type {V} */ 0), (t = 0)) : (s = /** @type {C} */ i()), r !== 0 && r !== 1)) throw new RangeError(`Invalid CID version ${r}`);
    const a = t,
      o =
        /** @type {A} */
        i(),
      u = i(),
      l = t + u,
      c = l - a;
    return { version: r, codec: s, multihashCode: o, digestSize: u, multihashSize: c, size: l };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(e, t) {
    const [i, r] = GB(e, t),
      s = rn.decode(r);
    if (s.version === 0 && e[0] !== 'Q') throw Error('Version 0 CID string must not include multibase prefix');
    return dh(s).set(i, e), s;
  }
}
const GB = (n, e) => {
    switch (n[0]) {
      case 'Q': {
        const t = e || vr;
        return [
          /** @type {Prefix} */
          vr.prefix,
          t.decode(`${vr.prefix}${n}`),
        ];
      }
      case vr.prefix: {
        const t = e || vr;
        return [
          /** @type {Prefix} */
          vr.prefix,
          t.decode(n),
        ];
      }
      case Du.prefix: {
        const t = e || Du;
        return [
          /** @type {Prefix} */
          Du.prefix,
          t.decode(n),
        ];
      }
      default: {
        if (e == null) throw Error('To parse non base32 or base58btc encoded CID multibase decoder must be provided');
        return [
          /** @type {Prefix} */
          n[0],
          e.decode(n),
        ];
      }
    }
  },
  qB = (n, e, t) => {
    const { prefix: i } = t;
    if (i !== vr.prefix) throw Error(`Cannot string encode V0 in ${t.name} encoding`);
    const r = e.get(i);
    if (r == null) {
      const s = t.encode(n).slice(1);
      return e.set(i, s), s;
    } else return r;
  },
  HB = (n, e, t) => {
    const { prefix: i } = t,
      r = e.get(i);
    if (r == null) {
      const s = t.encode(n);
      return e.set(i, s), s;
    } else return r;
  },
  du = 112,
  KB = 18,
  Zv = (n, e, t) => {
    const i = jc(n),
      r = i + jc(e),
      s = new Uint8Array(r + t.byteLength);
    return Uc(n, s, 0), Uc(e, s, i), s.set(t, r), s;
  },
  WB = Symbol.for('@ipld/js-cid/CID'),
  JB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        CID: rn,
        format: lh,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  );
function N5(n) {
  return globalThis.Buffer != null ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : n;
}
function D5(n = 0) {
  return globalThis.Buffer?.allocUnsafe != null ? N5(globalThis.Buffer.allocUnsafe(n)) : new Uint8Array(n);
}
function QB(n, e) {
  e == null && (e = n.reduce((r, s) => r + s.length, 0));
  const t = D5(e);
  let i = 0;
  for (const r of n) t.set(r, i), (i += r.length);
  return N5(t);
}
const YB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        concat: QB,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  XB = Rp({
    prefix: '\0',
    name: 'identity',
    encode: (n) => xB(n),
    decode: (n) => vB(n),
  }),
  ZB = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        identity: XB,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  eF = yn({
    prefix: '0',
    name: 'base2',
    alphabet: '01',
    bitsPerChar: 1,
  }),
  tF = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base2: eF,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  nF = yn({
    prefix: '7',
    name: 'base8',
    alphabet: '01234567',
    bitsPerChar: 3,
  }),
  iF = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base8: nF,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  rF = Hl({
    prefix: '9',
    name: 'base10',
    alphabet: '0123456789',
  }),
  sF = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base10: rF,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  aF = yn({
    prefix: 'f',
    name: 'base16',
    alphabet: '0123456789abcdef',
    bitsPerChar: 4,
  }),
  oF = yn({
    prefix: 'F',
    name: 'base16upper',
    alphabet: '0123456789ABCDEF',
    bitsPerChar: 4,
  }),
  uF = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base16: aF,
        base16upper: oF,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  lF = Hl({
    prefix: 'k',
    name: 'base36',
    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz',
  }),
  dF = Hl({
    prefix: 'K',
    name: 'base36upper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ',
  }),
  cF = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base36: lF,
        base36upper: dF,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  pF = yn({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6,
  }),
  fF = yn({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6,
  }),
  yF = yn({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6,
  }),
  hF = yn({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6,
  }),
  mF = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base64: pF,
        base64pad: fF,
        base64url: yF,
        base64urlpad: hF,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  B5 = Array.from(
    '',
  ),
  bF =
    /** @type {string[]} */
    B5.reduce(
      (n, e, t) => ((n[t] = e), n),
      /** @type {string[]} */
      [],
    ),
  gF =
    /** @type {number[]} */
    B5.reduce(
      (n, e, t) => (
        (n[
          /** @type {number} */
          e.codePointAt(0)
        ] = t),
        n
      ),
      /** @type {number[]} */
      [],
    );
function vF(n) {
  return n.reduce((e, t) => ((e += bF[t]), e), '');
}
function xF(n) {
  const e = [];
  for (const t of n) {
    const i =
      gF[
        /** @type {number} */
        t.codePointAt(0)
      ];
    if (i === void 0) throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i);
  }
  return new Uint8Array(e);
}
const TF = Rp({
    prefix: '',
    name: 'base256emoji',
    encode: vF,
    decode: xF,
  }),
  wF = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        base256emoji: TF,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  );
new TextEncoder();
new TextDecoder();
const ex = { ...ZB, ...tF, ...iF, ...sF, ...uF, ...zB, ...cF, ...NB, ...mF, ...wF };
function F5(n, e, t, i) {
  return {
    name: n,
    prefix: e,
    encoder: {
      name: n,
      prefix: e,
      encode: t,
    },
    decoder: {
      decode: i,
    },
  };
}
const tx = F5(
    'utf8',
    'u',
    (n) => 'u' + new TextDecoder('utf8').decode(n),
    (n) => new TextEncoder().encode(n.substring(1)),
  ),
  qf = F5(
    'ascii',
    'a',
    (n) => {
      let e = 'a';
      for (let t = 0; t < n.length; t++) e += String.fromCharCode(n[t]);
      return e;
    },
    (n) => {
      n = n.substring(1);
      const e = D5(n.length);
      for (let t = 0; t < n.length; t++) e[t] = n.charCodeAt(t);
      return e;
    },
  ),
  AF = {
    utf8: tx,
    'utf-8': tx,
    hex: ex.base16,
    latin1: qf,
    ascii: qf,
    binary: qf,
    ...ex,
  };
function EF(n, e = 'utf8') {
  const t = AF[e];
  if (t == null) throw new Error(`Unsupported encoding "${e}"`);
  return (e === 'utf8' || e === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null
    ? globalThis.Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString('utf8')
    : t.encoder.encode(n).substring(1);
}
const SF = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      toString: EF,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
export { LD as seed };

function L5(n, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != 'string' && !Array.isArray(i)) {
      for (const r in i)
        if (r !== 'default' && !(r in n)) {
          const s = Object.getOwnPropertyDescriptor(i, r);
          s &&
            Object.defineProperty(
              n,
              r,
              s.get
                ? s
                : {
                    enumerable: !0,
                    get: () => i[r],
                  },
            );
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: 'Module' }));
}
function jn(n) {
  return (typeof n == 'object' && n !== null) || typeof n == 'function';
}
function ch(n) {
  return n == null;
}
let Bu = /* @__PURE__ */ new WeakMap();
const vn = (n, e, t, i, r) => new TypeError(`${n}(${e.map(String).join(',')}) - Expected '${t}' to be of type ${r}, but got: ${Object.prototype.toString.call(i)} (${String(i)})`);
function Ss(n) {
  switch (typeof n) {
    case 'undefined':
    case 'string':
    case 'symbol':
      return n;
    default:
      return `${n}`;
  }
}
function $5(n) {
  switch (typeof n) {
    case 'string':
    case 'symbol':
      return n;
    default:
      return `${n}`;
  }
}
function U5(n) {
  switch (typeof n) {
    case 'undefined':
    case 'string':
    case 'symbol':
      return n;
    default:
      throw new TypeError(`Invalid metadata propertyKey: ${n}.`);
  }
}
function ml(n, e, t) {
  let i = Bu.get(n);
  if (i === void 0) {
    if (!t) return;
    (i = /* @__PURE__ */ new Map()), Bu.set(n, i);
  }
  let r = i.get(e);
  if (r === void 0) {
    if (!t) return;
    (r = /* @__PURE__ */ new Map()), i.set(e, r);
  }
  return r;
}
function ph(n, e, t) {
  const i = ml(e, t, !1);
  return i === void 0 ? !1 : i.has(n);
}
function nx(n, e, t) {
  if (ph(n, e, t)) return !0;
  const i = fh(e);
  return i !== null ? nx(n, i, t) : !1;
}
function ix(n, e, t) {
  const i = ml(e, t, !1);
  if (i !== void 0) return i.get(n);
}
function rx(n, e, t) {
  if (ph(n, e, t)) return ix(n, e, t);
  const i = fh(e);
  if (i !== null) return rx(n, i, t);
}
function sx(n, e, t, i) {
  ml(t, i, !0).set(n, e);
}
function ax(n, e) {
  const t = [],
    i = ml(n, e, !1);
  if (i === void 0) return t;
  const r = i.keys();
  let s = 0;
  for (const a of r) (t[s] = a), ++s;
  return t;
}
function ox(n, e) {
  const t = ax(n, e),
    i = fh(n);
  if (i === null) return t;
  const r = ox(i, e),
    s = t.length;
  if (s === 0) return r;
  const a = r.length;
  if (a === 0) return t;
  const o = /* @__PURE__ */ new Set(),
    u = [];
  let l = 0,
    c;
  for (let f = 0; f < s; ++f) (c = t[f]), o.has(c) || (o.add(c), (u[l] = c), ++l);
  for (let f = 0; f < a; ++f) (c = r[f]), o.has(c) || (o.add(c), (u[l] = c), ++l);
  return u;
}
function j5(n, e, t) {
  const i = ml(n, t, !1);
  return i === void 0 ? !1 : i.delete(e);
}
function V5(n, e) {
  function t(i, r) {
    if (!jn(i)) throw vn('@metadata', [n, e, i, r], 'target', i, 'Object or Function');
    sx(n, e, i, U5(r));
  }
  return t;
}
function z5(n, e, t, i) {
  if (t !== void 0) {
    if (!Array.isArray(n)) throw vn('Metadata.decorate', [n, e, t, i], 'decorators', n, 'Array');
    if (!jn(e)) throw vn('Metadata.decorate', [n, e, t, i], 'target', e, 'Object or Function');
    if (!jn(i) && !ch(i)) throw vn('Metadata.decorate', [n, e, t, i], 'attributes', i, 'Object, Function, null, or undefined');
    return i === null && (i = void 0), (t = $5(t)), q5(n, e, t, i);
  } else {
    if (!Array.isArray(n)) throw vn('Metadata.decorate', [n, e, t, i], 'decorators', n, 'Array');
    if (typeof e != 'function') throw vn('Metadata.decorate', [n, e, t, i], 'target', e, 'Function');
    return G5(n, e);
  }
}
function G5(n, e) {
  for (let t = n.length - 1; t >= 0; --t) {
    const i = n[t],
      r = i(e);
    if (!ch(r)) {
      if (typeof r != 'function') throw vn('DecorateConstructor', [n, e], 'decorated', r, 'Function, null, or undefined');
      e = r;
    }
  }
  return e;
}
function q5(n, e, t, i) {
  for (let r = n.length - 1; r >= 0; --r) {
    const s = n[r],
      a = s(e, t, i);
    if (!ch(a)) {
      if (!jn(a)) throw vn('DecorateProperty', [n, e, t, i], 'decorated', a, 'Object, Function, null, or undefined');
      i = a;
    }
  }
  return i;
}
function ux(n, e, t, i) {
  if (!jn(t)) throw vn('Metadata.define', [n, e, t, i], 'target', t, 'Object or Function');
  return sx(n, e, t, Ss(i));
}
function lx(n, e, t) {
  if (!jn(e)) throw vn('Metadata.has', [n, e, t], 'target', e, 'Object or Function');
  return nx(n, e, Ss(t));
}
function dx(n, e, t) {
  if (!jn(e)) throw vn('Metadata.hasOwn', [n, e, t], 'target', e, 'Object or Function');
  return ph(n, e, Ss(t));
}
function cx(n, e, t) {
  if (!jn(e)) throw vn('Metadata.get', [n, e, t], 'target', e, 'Object or Function');
  return rx(n, e, Ss(t));
}
function px(n, e, t) {
  if (!jn(e)) throw vn('Metadata.getOwn', [n, e, t], 'target', e, 'Object or Function');
  return ix(n, e, Ss(t));
}
function fx(n, e) {
  if (!jn(n)) throw vn('Metadata.getKeys', [n, e], 'target', n, 'Object or Function');
  return ox(n, Ss(e));
}
function yx(n, e) {
  if (!jn(n)) throw vn('Metadata.getOwnKeys', [n, e], 'target', n, 'Object or Function');
  return ax(n, Ss(e));
}
function hx(n, e, t) {
  if (!jn(e)) throw vn('Metadata.delete', [n, e, t], 'target', e, 'Object or Function');
  return j5(e, n, Ss(t));
}
const ur = {
    define: ux,
    has: lx,
    hasOwn: dx,
    get: cx,
    getOwn: px,
    getKeys: fx,
    getOwnKeys: yx,
    delete: hx,
  },
  H5 = (n, e, t, i, r) => {
    if (
      !Reflect.defineProperty(n, e, {
        writable: i,
        enumerable: !1,
        configurable: r,
        value: t,
      })
    )
      throw Hf(`AUR1000:${e}`);
  },
  yu = '[[$au]]',
  K5 = (n) => yu in n,
  hm = (n, e, t) =>
    [
      [yu, Bu],
      ['metadata', V5],
      ['decorate', z5],
      ['defineMetadata', ux],
      ['hasMetadata', lx],
      ['hasOwnMetadata', dx],
      ['getMetadata', cx],
      ['getOwnMetadata', px],
      ['getMetadataKeys', fx],
      ['getOwnMetadataKeys', yx],
      ['deleteMetadata', hx],
    ].forEach(([i, r]) => H5(n, i, r, e, t)),
  W5 = (n, e = !0, t = !1, i = !0, r = !0) => {
    if (K5(n)) {
      if (n[yu] === Bu) return;
      if (n[yu] instanceof WeakMap) {
        Bu = n[yu];
        return;
      }
      throw Hf('AUR1001');
    }
    const s = 'metadata decorate defineMetadata hasMetadata hasOwnMetadata getMetadata getOwnMetadata getMetadataKeys getOwnMetadataKeys deleteMetadata'.split(' ').filter((a) => a in Reflect);
    if (s.length > 0)
      if (e) {
        const a = s.map(function (o) {
          const u = `${Reflect[o].toString().slice(0, 100)}...`;
          return `${o}:
${u}`;
        }).join(`

`);
        throw Hf(`AUR1002:${a}`);
      } else t && hm(n, i, r);
    else hm(n, i, r);
  },
  Hf = (n) => new Error(n),
  fh = Object.getPrototypeOf,
  Io = String,
  Vn = ur.getOwn,
  J5 = ur.hasOwn,
  gs = ur.define,
  da = (n) => typeof n == 'function',
  jd = (n) => typeof n == 'string',
  Sr = () => /* @__PURE__ */ Object.create(null),
  tn = (n) => new Error(n),
  Kl = {},
  Fu = (n) => {
    switch (typeof n) {
      case 'number':
        return n >= 0 && (n | 0) === n;
      case 'string': {
        const e = Kl[n];
        if (e !== void 0) return e;
        const t = n.length;
        if (t === 0) return (Kl[n] = !1);
        let i = 0,
          r = 0;
        for (; r < t; ++r) if (((i = hn(n, r)), (r === 0 && i === 48 && t > 1) || i < 48 || i > 57)) return (Kl[n] = !1);
        return (Kl[n] = !0);
      }
      default:
        return !1;
    }
  },
  mx = /* @__PURE__ */ (function () {
    const n = Object.assign(Sr(), {
        0: !0,
        1: !0,
        2: !0,
        3: !0,
        4: !0,
        5: !0,
        6: !0,
        7: !0,
        8: !0,
        9: !0,
      }),
      e = (t) => (t === '' ? 0 : t !== t.toUpperCase() ? 3 : t !== t.toLowerCase() ? 2 : n[t] === !0 ? 1 : 0);
    return (t, i) => {
      const r = t.length;
      if (r === 0) return t;
      let s = !1,
        a = '',
        o,
        u = '',
        l = 0,
        c = t.charAt(0),
        f = e(c),
        m = 0;
      for (; m < r; ++m)
        (o = l), (u = c), (l = f), (c = t.charAt(m + 1)), (f = e(c)), l === 0 ? a.length > 0 && (s = !0) : (!s && a.length > 0 && l === 2 && (s = o === 3 || f === 3), (a += i(u, s)), (s = !1));
      return a;
    };
  })(),
  ti = /* @__PURE__ */ (function () {
    const n = Sr(),
      e = (t, i) => (i ? t.toUpperCase() : t.toLowerCase());
    return (t) => {
      let i = n[t];
      return i === void 0 && (i = n[t] = mx(t, e)), i;
    };
  })(),
  Q5 = /* @__PURE__ */ (function () {
    const n = Sr();
    return (e) => {
      let t = n[e];
      return t === void 0 && ((t = ti(e)), t.length > 0 && (t = t[0].toUpperCase() + t.slice(1)), (n[e] = t)), t;
    };
  })(),
  bx = /* @__PURE__ */ (function () {
    const n = Sr(),
      e = (t, i) => (i ? `-${t.toLowerCase()}` : t.toLowerCase());
    return (t) => {
      let i = n[t];
      return i === void 0 && (i = n[t] = mx(t, e)), i;
    };
  })(),
  Gp = (n) => {
    const e = n.length,
      t = Array(e);
    let i = 0;
    for (; i < e; ++i) t[i] = n[i];
    return t;
  },
  Oo = (n, e, t) => ({
    configurable: !0,
    enumerable: t.enumerable,
    get() {
      const i = t.value.bind(this);
      return (
        Reflect.defineProperty(this, e, {
          value: i,
          writable: !0,
          configurable: !0,
          enumerable: t.enumerable,
        }),
        i
      );
    },
  }),
  Vt = (...n) => {
    const e = [];
    let t = 0;
    const i = n.length;
    let r = 0,
      s,
      a = 0;
    for (; a < i; ++a)
      if (((s = n[a]), s !== void 0)) {
        r = s.length;
        let o = 0;
        for (; o < r; ++o) e[t++] = s[o];
      }
    return e;
  },
  Ln = (...n) => {
    const e = n.length;
    let t,
      i = 0;
    for (; e > i; ++i) if (((t = n[i]), t !== void 0)) return t;
    throw tn('No default value found');
  },
  Y5 = /* @__PURE__ */ (function () {
    const n = Function.prototype,
      e = Object.getPrototypeOf,
      t = /* @__PURE__ */ new WeakMap();
    let i = n,
      r = 0,
      s;
    return function (a) {
      if (((s = t.get(a)), s === void 0)) for (t.set(a, (s = [(i = a)])), r = 0; (i = e(i)) !== n; ) s[++r] = i;
      return s;
    };
  })();
function Lu(...n) {
  return Object.assign(Sr(), ...n);
}
const mm = /* @__PURE__ */ (function () {
    const n = /* @__PURE__ */ new WeakMap();
    let e = !1,
      t = '',
      i = 0;
    return (r) => (
      (e = n.get(r)),
      e === void 0 &&
        ((t = r.toString()),
        (i = t.length),
        (e =
          i >= 29 &&
          i <= 100 &&
          hn(t, i - 1) === 125 &&
          hn(t, i - 2) <= 32 &&
          hn(t, i - 3) === 93 &&
          hn(t, i - 4) === 101 &&
          hn(t, i - 5) === 100 &&
          hn(t, i - 6) === 111 &&
          hn(t, i - 7) === 99 &&
          hn(t, i - 8) === 32 &&
          hn(t, i - 9) === 101 &&
          hn(t, i - 10) === 118 &&
          hn(t, i - 11) === 105 &&
          hn(t, i - 12) === 116 &&
          hn(t, i - 13) === 97 &&
          hn(t, i - 14) === 110 &&
          hn(t, i - 15) === 88),
        n.set(r, e)),
      e
    );
  })(),
  Re = (n, e) => (n instanceof Promise ? n.then(e) : e(n)),
  Yt = (...n) => {
    let e,
      t,
      i,
      r = 0,
      s = n.length;
    for (; r < s; ++r) (e = n[r]), (e = n[r]) instanceof Promise && (t === void 0 ? (t = e) : i === void 0 ? (i = [t, e]) : i.push(e));
    return i === void 0 ? t : Promise.all(i);
  },
  hn = (n, e) => n.charCodeAt(e),
  sa = 'au:annotation',
  Cr = (n, e) => (e === void 0 ? `${sa}:${n}` : `${sa}:${n}:${e}`),
  yh = (n, e) => {
    const t = Vn(sa, n);
    t === void 0 ? gs(sa, [e], n) : t.push(e);
  },
  X5 = Object.freeze({
    name: 'au:annotation',
    appendTo: yh,
    set(n, e, t) {
      gs(Cr(e), t, n);
    },
    get: (n, e) => Vn(Cr(e), n),
    getKeys(n) {
      let e = Vn(sa, n);
      return e === void 0 && gs(sa, (e = []), n), e;
    },
    isKey: (n) => n.startsWith(sa),
    keyFor: Cr,
  }),
  ji = 'au:resource',
  Kf = (n) => J5(ji, n),
  Wf = (n) => {
    const e = Vn(ji, n);
    return e === void 0 ? je : e.map((t) => Vn(t, n));
  },
  Z5 = Object.freeze({
    name: ji,
    appendTo(n, e) {
      const t = Vn(ji, n);
      t === void 0 ? gs(ji, [e], n) : t.push(e);
    },
    has: Kf,
    getAll: Wf,
    getKeys(n) {
      let e = Vn(ji, n);
      return e === void 0 && gs(ji, (e = []), n), e;
    },
    isKey: (n) => n.startsWith(ji),
    keyFor(n, e) {
      return e === void 0 ? `${ji}:${n}` : `${ji}:${n}:${e}`;
    },
  }),
  ko = {
    annotation: X5,
    resource: Z5,
  },
  gx = Object.prototype.hasOwnProperty;
function xi(n, e, t, i) {
  let r = Vn(Cr(n), t);
  return r === void 0 ? ((r = e[n]), r === void 0 ? ((r = t[n]), r === void 0 || !gx.call(t, n) ? i() : r) : r) : r;
}
function ri(n, e, t) {
  let i = Vn(Cr(n), e);
  return i === void 0 ? ((i = e[n]), i === void 0 || !gx.call(e, n) ? t() : i) : i;
}
function Nn(n, e, t) {
  const i = e[n];
  return i === void 0 ? t() : i;
}
const e3 = new Set(
  'Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise RangeError ReferenceError RegExp Set SharedArrayBuffer String SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet'.split(
    ' ',
  ),
);
let t3 = 0;
class hu {
  get depth() {
    return this.parent === null ? 0 : this.parent.depth + 1;
  }
  constructor(e, t) {
    (this.parent = e),
      (this.config = t),
      (this.id = ++t3),
      (this.t = 0),
      (this.i = /* @__PURE__ */ new Map()),
      e === null
        ? ((this.root = this), (this.u = /* @__PURE__ */ new Map()), (this.h = /* @__PURE__ */ new Map()), (this.res = Sr()))
        : ((this.root = e.root), (this.u = /* @__PURE__ */ new Map()), (this.h = e.h), t.inheritParentResources ? (this.res = Object.assign(Sr(), e.res, this.root.res)) : (this.res = Sr())),
      this.u.set(Po, n3);
  }
  register(...e) {
    if (++this.t === 100) throw a3(e);
    let t,
      i,
      r,
      s,
      a,
      o = 0,
      u = e.length;
    for (; o < u; ++o)
      if (((t = e[o]), !!jn(t)))
        if (bd(t)) t.register(this);
        else if (Kf(t)) {
          const l = Wf(t);
          if (l.length === 1) l[0].register(this);
          else for (s = 0, a = l.length; a > s; ) l[s].register(this), ++s;
        } else if (r3(t)) me.singleton(t, t).register(this);
        else for (i = Object.keys(t), s = 0, a = i.length; s < a; ++s) (r = t[i[s]]), jn(r) && (bd(r) ? r.register(this) : this.register(r));
    return --this.t, this;
  }
  registerResolver(e, t, i = !1) {
    Wl(e);
    const r = this.u,
      s = r.get(e);
    if (s == null) {
      if ((r.set(e, t), s3(e))) {
        if (this.res[e] !== void 0) throw o3(e);
        this.res[e] = t;
      }
    } else s instanceof fi && s.R === 4 ? s._state.push(t) : r.set(e, new fi(e, 4, [s, t]));
    return i && this.i.set(e, t), t;
  }
  registerTransformer(e, t) {
    const i = this.getResolver(e);
    if (i == null) return !1;
    if (i.getFactory) {
      const r = i.getFactory(this);
      return r == null ? !1 : (r.registerTransformer(t), !0);
    }
    return !1;
  }
  getResolver(e, t = !0) {
    if ((Wl(e), e.resolve !== void 0)) return e;
    let i = this,
      r,
      s;
    for (; i != null; )
      if (((r = i.u.get(e)), r == null)) {
        if (i.parent == null) return (s = gm(e) ? this : i), t ? this.$(e, s) : null;
        i = i.parent;
      } else return r;
    return null;
  }
  has(e, t = !1) {
    return this.u.has(e) ? !0 : t && this.parent != null ? this.parent.has(e, !0) : !1;
  }
  get(e) {
    if ((Wl(e), e.$isResolver)) return e.resolve(this, this);
    let t = this,
      i,
      r;
    for (; t != null; )
      if (((i = t.u.get(e)), i == null)) {
        if (t.parent == null) return (r = gm(e) ? this : t), (i = this.$(e, r)), i.resolve(t, this);
        t = t.parent;
      } else return i.resolve(t, this);
    throw u3(e);
  }
  getAll(e, t = !1) {
    Wl(e);
    const i = this;
    let r = i,
      s;
    if (t) {
      let a = je;
      for (; r != null; ) (s = r.u.get(e)), s != null && (a = a.concat(bm(s, r, i))), (r = r.parent);
      return a;
    } else
      for (; r != null; )
        if (((s = r.u.get(e)), s == null)) {
          if (((r = r.parent), r == null)) return je;
        } else return bm(s, r, i);
    return je;
  }
  invoke(e, t) {
    if (mm(e)) throw xm(e);
    return t === void 0 ? new e(...mu(e).map(Vd, this)) : new e(...mu(e).map(Vd, this), ...t);
  }
  getFactory(e) {
    let t = this.h.get(e);
    if (t === void 0) {
      if (mm(e)) throw xm(e);
      this.h.set(e, (t = new O3(e, mu(e))));
    }
    return t;
  }
  registerFactory(e, t) {
    this.h.set(e, t);
  }
  createChild(e) {
    return e === void 0 && this.config.inheritParentResources
      ? this.config === Ji.DEFAULT
        ? new hu(this, this.config)
        : new hu(
            this,
            Ji.from({
              ...this.config,
              inheritParentResources: !1,
            }),
          )
      : new hu(this, Ji.from(e ?? this.config));
  }
  disposeResolvers() {
    const e = this.u,
      t = this.i;
    let i, r;
    for ([r, i] of t.entries()) i.dispose(), e.delete(r);
    t.clear();
  }
  find(e, t) {
    const i = e.keyFrom(t);
    let r = this.res[i];
    if ((r === void 0 && ((r = this.root.res[i]), r === void 0)) || r === null) return null;
    if (da(r.getFactory)) {
      const s = r.getFactory(this);
      if (s == null) return null;
      const a = Vn(e.name, s.Type);
      return a === void 0 ? null : a;
    }
    return null;
  }
  create(e, t) {
    const i = e.keyFrom(t);
    let r = this.res[i];
    return r === void 0 ? ((r = this.root.res[i]), r === void 0 ? null : r.resolve(this.root, this) ?? null) : r.resolve(this, this) ?? null;
  }
  dispose() {
    this.i.size > 0 && this.disposeResolvers(), this.u.clear();
  }
  $(e, t) {
    if (!da(e)) throw l3(e);
    if (e3.has(e.name)) throw d3(e);
    if (bd(e)) {
      const i = e.register(t, e);
      if (!(i instanceof Object) || i.resolve == null) {
        const r = t.u.get(e);
        if (r != null) return r;
        throw vm();
      }
      return i;
    } else if (Kf(e)) {
      const i = Wf(e);
      if (i.length === 1) i[0].register(t);
      else {
        const s = i.length;
        for (let a = 0; a < s; ++a) i[a].register(t);
      }
      const r = t.u.get(e);
      if (r != null) return r;
      throw vm();
    } else {
      if (e.$isInterface) throw c3(e.friendlyName);
      {
        const i = this.config.defaultResolver(e, t);
        return t.u.set(e, i), i;
      }
    }
  }
}
function Wl(n) {
  if (n == null) throw tn('AUR0014');
}
const bm = (n, e, t) => {
    if (n instanceof fi && n.R === 4) {
      const i = n._state;
      let r = i.length;
      const s = new Array(r);
      for (; r--; ) s[r] = i[r].resolve(e, t);
      return s;
    }
    return [n.resolve(e, t)];
  },
  n3 = {
    $isResolver: !0,
    resolve(n, e) {
      return e;
    },
  },
  bd = (n) => da(n.register),
  i3 = (n) => bd(n) && typeof n.registerInRequestor == 'boolean',
  gm = (n) => i3(n) && n.registerInRequestor,
  r3 = (n) => n.prototype !== void 0,
  s3 = (n) => jd(n) && n.indexOf(':') > 0,
  a3 = (n) => tn(`AUR0006:${n.map(Io)}`),
  o3 = (n) => tn(`AUR0007:${Io(n)}`),
  u3 = (n) => tn(`AUR0008:${Io(n)}`),
  l3 = (n) => tn(`AUR0009:${Io(n)}`),
  d3 = (n) => tn(`AUR0010:${n.name}`),
  vm = () => tn('AUR0011'),
  c3 = (n) => tn(`AUR0012:${n}`),
  xm = (n) => tn(`AUR0015:${n.name}`),
  vx = (n, e) => new fi(n, 0, e),
  hh = (n, e) => new fi(n, 1, e),
  p3 = (n, e) => new fi(n, 2, e),
  f3 = (n, e) => new fi(n, 3, e),
  y3 = (n, e) => new fi(n, 3, xx(e)),
  h3 = (n, e) => new fi(e, 5, n),
  m3 = (n, ...e) => new k3(n, e),
  Tm = /* @__PURE__ */ new WeakMap(),
  xx = (n) => (e, t, i) => {
    let r = Tm.get(e);
    if ((r === void 0 && Tm.set(e, (r = /* @__PURE__ */ new WeakMap())), r.has(i))) return r.get(i);
    const s = n(e, t, i);
    return r.set(i, s), s;
  };
W5(Reflect, !1, !1);
class b3 {
  constructor(e, t) {
    (this.c = e), (this.k = t);
  }
  instance(e) {
    return this.C(0, e);
  }
  singleton(e) {
    return this.C(1, e);
  }
  transient(e) {
    return this.C(2, e);
  }
  callback(e) {
    return this.C(3, e);
  }
  cachedCallback(e) {
    return this.C(3, xx(e));
  }
  aliasTo(e) {
    return this.C(5, e);
  }
  C(e, t) {
    const { c: i, k: r } = this;
    return (this.c = this.k = void 0), i.registerResolver(r, new fi(r, e, t));
  }
}
const Xo = (n) => {
    const e = n.slice(),
      t = Object.keys(n),
      i = t.length;
    let r;
    for (let s = 0; s < i; ++s) (r = t[s]), Fu(r) || (e[r] = n[r]);
    return e;
  },
  g3 = {
    none(n) {
      throw v3(n);
    },
    singleton: (n) => new fi(n, 1, n),
    transient: (n) => new fi(n, 2, n),
  },
  v3 = (n) => tn(`AUR0002:${Io(n)}`);
class Ji {
  constructor(e, t) {
    (this.inheritParentResources = e), (this.defaultResolver = t);
  }
  static from(e) {
    return e === void 0 || e === Ji.DEFAULT ? Ji.DEFAULT : new Ji(e.inheritParentResources ?? !1, e.defaultResolver ?? g3.singleton);
  }
}
Ji.DEFAULT = Ji.from({});
const x3 = (n) => new hu(null, Ji.from(n)),
  Tx = (n) => {
    const e = Cr('di:paramtypes');
    return Vn(e, n);
  },
  T3 = (n) => Vn('design:paramtypes', n),
  Wa = (n) => {
    const e = Cr('di:paramtypes');
    let t = Vn(e, n);
    return t === void 0 && (gs(e, (t = []), n), yh(n, e)), t;
  },
  mu = (n) => {
    const e = Cr('di:dependencies');
    let t = Vn(e, n);
    if (t === void 0) {
      const i = n.inject;
      if (i === void 0) {
        const r = be.getDesignParamtypes(n),
          s = Tx(n);
        if (r === void 0)
          if (s === void 0) {
            const a = Object.getPrototypeOf(n);
            da(a) && a !== Function.prototype ? (t = Xo(mu(a))) : (t = []);
          } else t = Xo(s);
        else if (s === void 0) t = Xo(r);
        else {
          t = Xo(r);
          let a = s.length,
            o,
            u = 0;
          for (; u < a; ++u) (o = s[u]), o !== void 0 && (t[u] = o);
          const l = Object.keys(s);
          let c;
          for (u = 0, a = l.length, u = 0; u < a; ++u) (c = l[u]), Fu(c) || (t[c] = s[c]);
        }
      } else t = Xo(i);
      gs(e, t, n), yh(n, e);
    }
    return t;
  },
  Ur = (n, e) => {
    const t = da(n) ? n : e,
      i = (jd(n) ? n : void 0) ?? '(anonymous)',
      r = function (s, a, o) {
        if (s == null || new.target !== void 0) throw w3(i);
        const u = Wa(s);
        u[o] = r;
      };
    return (r.$isInterface = !0), (r.friendlyName = i), t != null && (r.register = (s, a) => t(new b3(s, a ?? r))), (r.toString = () => `InterfaceSymbol<${i}>`), r;
  },
  w3 = (n) => tn(`AUR0001:${n}`),
  be = {
    createContainer: x3,
    getDesignParamtypes: T3,
    getAnnotationParamtypes: Tx,
    getOrCreateAnnotationParamTypes: Wa,
    getDependencies: mu,
    createInterface: Ur,
    inject(...n) {
      return (e, t, i) => {
        if (typeof i == 'number') {
          const r = Wa(e),
            s = n[0];
          s !== void 0 && (r[i] = s);
        } else if (t) {
          const r = Wa(e.constructor),
            s = n[0];
          s !== void 0 && (r[t] = s);
        } else if (i) {
          const r = i.value,
            s = Wa(r);
          let a,
            o = 0;
          for (; o < n.length; ++o) (a = n[o]), a !== void 0 && (s[o] = a);
        } else {
          const r = Wa(e);
          let s,
            a = 0;
          for (; a < n.length; ++a) (s = n[a]), s !== void 0 && (r[a] = s);
        }
      };
    },
    transient(n) {
      return (
        (n.register = function (e) {
          return me.transient(n, n).register(e, n);
        }),
        (n.registerInRequestor = !1),
        n
      );
    },
    singleton(n, e = S3) {
      return (
        (n.register = function (t) {
          return me.singleton(n, n).register(t, n);
        }),
        (n.registerInRequestor = e.scoped),
        n
      );
    },
  },
  Po = /* @__PURE__ */ Ur('IContainer'),
  A3 = Po;
function E3(n) {
  return function (e) {
    const t = function (i, r, s) {
      mh(t)(i, r, s);
    };
    return (
      (t.$isResolver = !0),
      (t.resolve = function (i, r) {
        return n(e, i, r);
      }),
      t
    );
  };
}
const mh = be.inject;
function wm(n) {
  return be.transient(n);
}
function wx(n) {
  return n == null ? wm : wm(n);
}
const S3 = {
    scoped: !1,
  },
  C3 = (n) => (e, t) => {
    t = !!t;
    const i = function (r, s, a) {
      mh(i)(r, s, a);
    };
    return (
      (i.$isResolver = !0),
      (i.resolve = function (r, s) {
        return n(e, r, s, t);
      }),
      i
    );
  },
  Ax = /* @__PURE__ */ C3((n, e, t, i) => t.getAll(n, i)),
  Ex = /* @__PURE__ */ E3((n, e, t) => {
    if (t.has(n, !0)) return t.get(n);
  }),
  Vc = (n, e, t) => {
    mh(Vc)(n, e, t);
  };
Vc.$isResolver = !0;
Vc.resolve = () => {};
let fi = class {
  constructor(e, t, i) {
    (this.k = e), (this.R = t), (this._state = i), (this.resolving = !1);
  }
  get $isResolver() {
    return !0;
  }
  register(e, t) {
    return e.registerResolver(t || this.k, this);
  }
  resolve(e, t) {
    switch (this.R) {
      case 0:
        return this._state;
      case 1: {
        if (this.resolving) throw M3(this._state.name);
        return (this.resolving = !0), (this._state = e.getFactory(this._state).construct(t)), (this.R = 0), (this.resolving = !1), this._state;
      }
      case 2: {
        const i = e.getFactory(this._state);
        if (i === null) throw _3(this.k);
        return i.construct(t);
      }
      case 3:
        return this._state(e, t, this);
      case 4:
        return this._state[0].resolve(e, t);
      case 5:
        return t.get(this._state);
      default:
        throw R3(this.R);
    }
  }
  getFactory(e) {
    switch (this.R) {
      case 1:
      case 2:
        return e.getFactory(this._state);
      case 5:
        return e.getResolver(this._state)?.getFactory?.(e) ?? null;
      default:
        return null;
    }
  }
};
const M3 = (n) => tn(`AUR0003:${n}`),
  _3 = (n) => tn(`AUR0004:${Io(n)}`),
  R3 = (n) => tn(`AUR0005:${n}`);
function Vd(n) {
  return this.get(n);
}
function I3(n, e) {
  return e(n);
}
class O3 {
  constructor(e, t) {
    (this.Type = e), (this.dependencies = t), (this.transformers = null);
  }
  construct(e, t) {
    let i;
    return (
      t === void 0 ? (i = new this.Type(...this.dependencies.map(Vd, e))) : (i = new this.Type(...this.dependencies.map(Vd, e), ...t)), this.transformers == null ? i : this.transformers.reduce(I3, i)
    );
  }
  registerTransformer(e) {
    (this.transformers ?? (this.transformers = [])).push(e);
  }
}
class k3 {
  constructor(e, t) {
    (this.key = e), (this.params = t);
  }
  register(e) {
    e.has(this.key, !0) ? e.get(this.key).register(e, ...this.params) : e.register(...this.params.filter((t) => typeof t == 'object'));
  }
}
const me = {
  instance: vx,
  singleton: hh,
  transient: p3,
  callback: f3,
  cachedCallback: y3,
  aliasTo: h3,
  defer: m3,
};
class ln {
  get friendlyName() {
    return this.A;
  }
  constructor(e, t) {
    (this._ = null), (this.A = e), t !== void 0 && (this._ = t);
  }
  prepare(e) {
    this._ = e;
  }
  get $isResolver() {
    return !0;
  }
  resolve() {
    if (this._ == null) throw P3(this.A);
    return this._;
  }
  dispose() {
    this._ = null;
  }
}
const P3 = (n) => tn(`AUR0013:${n}`),
  je = Object.freeze([]),
  N3 = Object.freeze({});
function Mr() {}
const bl = /* @__PURE__ */ Ur('IPlatform');
function jr(n, e, t, i) {
  var r = arguments.length,
    s = r < 3 ? e : i === null ? (i = Object.getOwnPropertyDescriptor(e, t)) : i,
    a;
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') s = Reflect.decorate(n, e, t, i);
  else for (var o = n.length - 1; o >= 0; o--) (a = n[o]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}
function na(n, e) {
  return function (t, i) {
    e(t, i, n);
  };
}
var Am;
(function (n) {
  (n[(n.trace = 0)] = 'trace'),
    (n[(n.debug = 1)] = 'debug'),
    (n[(n.info = 2)] = 'info'),
    (n[(n.warn = 3)] = 'warn'),
    (n[(n.error = 4)] = 'error'),
    (n[(n.fatal = 5)] = 'fatal'),
    (n[(n.none = 6)] = 'none');
})(Am || (Am = {}));
var Em;
(function (n) {
  (n[(n.noColors = 0)] = 'noColors'), (n[(n.colors = 1)] = 'colors');
})(Em || (Em = {}));
const bh = /* @__PURE__ */ Ur('ILogConfig', (n) => n.instance(new Sx(0, 3))),
  gh = /* @__PURE__ */ Ur('ISink'),
  D3 = /* @__PURE__ */ Ur('ILogEventFactory', (n) => n.singleton(Jf)),
  _a = /* @__PURE__ */ Ur('ILogger', (n) => n.singleton(Or)),
  B3 = /* @__PURE__ */ Ur('ILogScope'),
  F3 = Object.freeze({
    key: Cr('logger-sink-handles'),
    define(n, e) {
      return gs(this.key, e.handles, n.prototype), n;
    },
    getHandles(n) {
      return ur.get(this.key, n);
    },
  }),
  fr = Lu({
    red(n) {
      return `\x1B[31m${n}\x1B[39m`;
    },
    green(n) {
      return `\x1B[32m${n}\x1B[39m`;
    },
    yellow(n) {
      return `\x1B[33m${n}\x1B[39m`;
    },
    blue(n) {
      return `\x1B[34m${n}\x1B[39m`;
    },
    magenta(n) {
      return `\x1B[35m${n}\x1B[39m`;
    },
    cyan(n) {
      return `\x1B[36m${n}\x1B[39m`;
    },
    white(n) {
      return `\x1B[37m${n}\x1B[39m`;
    },
    grey(n) {
      return `\x1B[90m${n}\x1B[39m`;
    },
  });
class Sx {
  constructor(e, t) {
    (this.colorOptions = e), (this.level = t);
  }
}
const Sm = (function () {
    const n = [
      Lu({
        TRC: 'TRC',
        DBG: 'DBG',
        INF: 'INF',
        WRN: 'WRN',
        ERR: 'ERR',
        FTL: 'FTL',
        QQQ: '???',
      }),
      Lu({
        TRC: fr.grey('TRC'),
        DBG: fr.grey('DBG'),
        INF: fr.white('INF'),
        WRN: fr.yellow('WRN'),
        ERR: fr.red('ERR'),
        FTL: fr.red('FTL'),
        QQQ: fr.grey('???'),
      }),
    ];
    return (e, t) => (e <= 0 ? n[t].TRC : e <= 1 ? n[t].DBG : e <= 2 ? n[t].INF : e <= 3 ? n[t].WRN : e <= 4 ? n[t].ERR : e <= 5 ? n[t].FTL : n[t].QQQ);
  })(),
  L3 = (n, e) => (e === 0 ? n.join('.') : n.map(fr.cyan).join('.')),
  Cm = (n, e) => (e === 0 ? new Date(n).toISOString() : fr.grey(new Date(n).toISOString()));
class $3 {
  constructor(e, t, i, r, s, a) {
    (this.severity = e), (this.message = t), (this.optionalParams = i), (this.scope = r), (this.colorOptions = s), (this.timestamp = a);
  }
  toString() {
    const { severity: e, message: t, scope: i, colorOptions: r, timestamp: s } = this;
    return i.length === 0 ? `${Cm(s, r)} [${Sm(e, r)}] ${t}` : `${Cm(s, r)} [${Sm(e, r)} ${L3(i, r)}] ${t}`;
  }
}
let Jf = class {
  constructor(e) {
    this.config = e;
  }
  createLogEvent(e, t, i, r) {
    return new $3(t, i, r, e.scope, this.config.colorOptions, Date.now());
  }
};
Jf = jr([na(0, bh)], Jf);
let Mm = class Cx {
  static register(e) {
    hh(gh, Cx).register(e);
  }
  constructor(e) {
    const t = e.console;
    this.handleEvent = function (r) {
      const s = r.optionalParams;
      if (s === void 0 || s.length === 0) {
        const a = r.toString();
        switch (r.severity) {
          case 0:
          case 1:
            return t.debug(a);
          case 2:
            return t.info(a);
          case 3:
            return t.warn(a);
          case 4:
          case 5:
            return t.error(a);
        }
      } else {
        let a = r.toString(),
          o = 0;
        for (; a.includes('%s'); ) a = a.replace('%s', String(s[o++]));
        switch (r.severity) {
          case 0:
          case 1:
            return t.debug(a, ...s.slice(o));
          case 2:
            return t.info(a, ...s.slice(o));
          case 3:
            return t.warn(a, ...s.slice(o));
          case 4:
          case 5:
            return t.error(a, ...s.slice(o));
        }
      }
    };
  }
};
Mm = jr([na(0, bl)], Mm);
let Or = class Mx {
  constructor(e, t, i, r = [], s = null) {
    (this.scope = r), (this.O = Sr());
    let a, o, u, l, c, f;
    if (((this.config = e), (this.f = t), (this.sinks = i), s === null)) {
      (this.root = this), (this.parent = this), (a = this.I = []), (o = this.j = []), (u = this.L = []), (l = this.M = []), (c = this.T = []), (f = this.F = []);
      for (const m of i) {
        const w = F3.getHandles(m);
        (w?.includes(0) ?? !0) && a.push(m),
          (w?.includes(1) ?? !0) && o.push(m),
          (w?.includes(2) ?? !0) && u.push(m),
          (w?.includes(3) ?? !0) && l.push(m),
          (w?.includes(4) ?? !0) && c.push(m),
          (w?.includes(5) ?? !0) && f.push(m);
      }
    } else (this.root = s.root), (this.parent = s), (a = this.I = s.I), (o = this.j = s.j), (u = this.L = s.L), (l = this.M = s.M), (c = this.T = s.T), (f = this.F = s.F);
  }
  trace(e, ...t) {
    this.config.level <= 0 && this.U(this.I, 0, e, t);
  }
  debug(e, ...t) {
    this.config.level <= 1 && this.U(this.j, 1, e, t);
  }
  info(e, ...t) {
    this.config.level <= 2 && this.U(this.L, 2, e, t);
  }
  warn(e, ...t) {
    this.config.level <= 3 && this.U(this.M, 3, e, t);
  }
  error(e, ...t) {
    this.config.level <= 4 && this.U(this.T, 4, e, t);
  }
  fatal(e, ...t) {
    this.config.level <= 5 && this.U(this.F, 5, e, t);
  }
  scopeTo(e) {
    const t = this.O;
    let i = t[e];
    return i === void 0 && (i = t[e] = new Mx(this.config, this.f, void 0, this.scope.concat(e), this)), i;
  }
  U(e, t, i, r) {
    const s = da(i) ? i() : i,
      a = this.f.createLogEvent(this, t, s, r);
    for (let o = 0, u = e.length; o < u; ++o) e[o].handleEvent(a);
  }
};
jr([Oo], Or.prototype, 'trace', null);
jr([Oo], Or.prototype, 'debug', null);
jr([Oo], Or.prototype, 'info', null);
jr([Oo], Or.prototype, 'warn', null);
jr([Oo], Or.prototype, 'error', null);
jr([Oo], Or.prototype, 'fatal', null);
Or = jr([na(0, bh), na(1, D3), na(2, Ax(gh)), na(3, Ex(B3)), na(4, Vc)], Or);
Lu({
  create({ level: n = 3, colorOptions: e = 0, sinks: t = [] } = {}) {
    return Lu({
      register(i) {
        i.register(vx(bh, new Sx(e, n)));
        for (const r of t) da(r) ? i.register(hh(gh, r)) : i.register(r);
        return i;
      },
    });
  },
});
class U3 {
  constructor(e, t) {
    (this.type = e), (this.cb = t);
  }
  handle(e) {
    e instanceof this.type && this.cb.call(null, e);
  }
}
const zc = /* @__PURE__ */ Ur('IEventAggregator', (n) => n.singleton(j3));
class j3 {
  constructor() {
    (this.eventLookup = {}), (this.messageHandlers = []);
  }
  publish(e, t) {
    if (!e) throw tn(`Invalid channel name or instance: ${e}.`);
    if (jd(e)) {
      let i = this.eventLookup[e];
      if (i !== void 0) {
        i = i.slice();
        let r = i.length;
        for (; r-- > 0; ) i[r](t, e);
      }
    } else {
      const i = this.messageHandlers.slice();
      let r = i.length;
      for (; r-- > 0; ) i[r].handle(e);
    }
  }
  subscribe(e, t) {
    if (!e) throw tn(`Invalid channel name or type: ${e}.`);
    let i, r;
    return (
      jd(e) ? (this.eventLookup[e] === void 0 && (this.eventLookup[e] = []), (i = t), (r = this.eventLookup[e])) : ((i = new U3(e, t)), (r = this.messageHandlers)),
      r.push(i),
      {
        dispose() {
          const s = r.indexOf(i);
          s !== -1 && r.splice(s, 1);
        },
      }
    );
  }
  subscribeOnce(e, t) {
    const i = this.subscribe(e, (r, s) => {
      i.dispose(), t(r, s);
    });
    return i;
  }
}
const Gc = Object,
  V3 = Gc.prototype.hasOwnProperty,
  yi = Reflect.defineProperty,
  ae = (n) => new Error(n),
  li = (n) => typeof n == 'function',
  bu = (n) => n instanceof Gc,
  vs = (n) => n instanceof Array,
  gl = (n) => n instanceof Set,
  fs = (n) => n instanceof Map,
  vh = Gc.is;
function kr(n, e, t) {
  return (
    yi(n, e, {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: t,
    }),
    t
  );
}
function xr(n, e, t) {
  e in n || kr(n, e, t);
}
const _x = Object.assign,
  vl = String,
  No = be.createInterface,
  gu = () => Gc.create(null),
  xh = ur.getOwn,
  Th = ur.define;
ko.annotation.keyFor;
ko.resource.keyFor;
ko.resource.appendTo;
var _m;
(function (n) {
  (n[(n.AccessThis = 0)] = 'AccessThis'),
    (n[(n.AccessScope = 1)] = 'AccessScope'),
    (n[(n.ArrayLiteral = 2)] = 'ArrayLiteral'),
    (n[(n.ObjectLiteral = 3)] = 'ObjectLiteral'),
    (n[(n.PrimitiveLiteral = 4)] = 'PrimitiveLiteral'),
    (n[(n.Template = 5)] = 'Template'),
    (n[(n.Unary = 6)] = 'Unary'),
    (n[(n.CallScope = 7)] = 'CallScope'),
    (n[(n.CallMember = 8)] = 'CallMember'),
    (n[(n.CallFunction = 9)] = 'CallFunction'),
    (n[(n.AccessMember = 10)] = 'AccessMember'),
    (n[(n.AccessKeyed = 11)] = 'AccessKeyed'),
    (n[(n.TaggedTemplate = 12)] = 'TaggedTemplate'),
    (n[(n.Binary = 13)] = 'Binary'),
    (n[(n.Conditional = 14)] = 'Conditional'),
    (n[(n.Assign = 15)] = 'Assign'),
    (n[(n.ArrowFunction = 16)] = 'ArrowFunction'),
    (n[(n.ValueConverter = 17)] = 'ValueConverter'),
    (n[(n.BindingBehavior = 18)] = 'BindingBehavior'),
    (n[(n.ArrayBindingPattern = 19)] = 'ArrayBindingPattern'),
    (n[(n.ObjectBindingPattern = 20)] = 'ObjectBindingPattern'),
    (n[(n.BindingIdentifier = 21)] = 'BindingIdentifier'),
    (n[(n.ForOfStatement = 22)] = 'ForOfStatement'),
    (n[(n.Interpolation = 23)] = 'Interpolation'),
    (n[(n.ArrayDestructuring = 24)] = 'ArrayDestructuring'),
    (n[(n.ObjectDestructuring = 25)] = 'ObjectDestructuring'),
    (n[(n.DestructuringAssignmentLeaf = 26)] = 'DestructuringAssignmentLeaf'),
    (n[(n.DestructuringAssignmentRestLeaf = 27)] = 'DestructuringAssignmentRestLeaf'),
    (n[(n.Custom = 28)] = 'Custom');
})(_m || (_m = {}));
class wh {
  constructor(e) {
    (this.value = e), (this.$kind = 28);
  }
  evaluate(e, t, i) {
    return this.value;
  }
  assign(e, t, i) {
    return i;
  }
  bind(e, t) {}
  unbind(e, t) {}
  accept(e) {}
}
class z3 {
  constructor(e, t, i) {
    (this.expression = e), (this.name = t), (this.args = i), (this.$kind = 18), (this.key = `_bb_${t}`);
  }
}
class $u {
  constructor(e, t, i) {
    (this.expression = e), (this.name = t), (this.args = i), (this.$kind = 17);
  }
}
class G3 {
  constructor(e, t) {
    (this.target = e), (this.value = t), (this.$kind = 15);
  }
}
class q3 {
  constructor(e, t, i) {
    (this.condition = e), (this.yes = t), (this.no = i), (this.$kind = 14);
  }
}
class _r {
  constructor(e = 0) {
    (this.ancestor = e), (this.$kind = 0);
  }
}
_r.$this = new _r(0);
_r.$parent = new _r(1);
class gd {
  constructor(e, t = 0) {
    (this.name = e), (this.ancestor = t), (this.$kind = 1);
  }
}
class Qf {
  constructor(e, t, i = !1) {
    (this.object = e), (this.name = t), (this.optional = i), (this.$kind = 10);
  }
}
class Rx {
  constructor(e, t, i = !1) {
    (this.object = e), (this.key = t), (this.optional = i), (this.$kind = 11);
  }
}
class Ix {
  constructor(e, t, i = 0, r = !1) {
    (this.name = e), (this.args = t), (this.ancestor = i), (this.optional = r), (this.$kind = 7);
  }
}
class zd {
  constructor(e, t, i, r = !1, s = !1) {
    (this.object = e), (this.name = t), (this.args = i), (this.optionalMember = r), (this.optionalCall = s), (this.$kind = 8);
  }
}
class vd {
  constructor(e, t, i = !1) {
    (this.func = e), (this.args = t), (this.optional = i), (this.$kind = 9);
  }
}
class H3 {
  constructor(e, t, i) {
    (this.operation = e), (this.left = t), (this.right = i), (this.$kind = 13);
  }
}
class K3 {
  constructor(e, t) {
    (this.operation = e), (this.expression = t), (this.$kind = 6);
  }
}
class cn {
  constructor(e) {
    (this.value = e), (this.$kind = 4);
  }
}
cn.$undefined = new cn(void 0);
cn.$null = new cn(null);
cn.$true = new cn(!0);
cn.$false = new cn(!1);
cn.$empty = new cn('');
class Yf {
  constructor(e) {
    (this.elements = e), (this.$kind = 2);
  }
}
Yf.$empty = new Yf(je);
class Xf {
  constructor(e, t) {
    (this.keys = e), (this.values = t), (this.$kind = 3);
  }
}
Xf.$empty = new Xf(je, je);
class Gd {
  constructor(e, t = je) {
    (this.cooked = e), (this.expressions = t), (this.$kind = 5);
  }
}
Gd.$empty = new Gd(['']);
class Ox {
  constructor(e, t, i, r = je) {
    (this.cooked = e), (this.func = i), (this.expressions = r), (this.$kind = 12), (e.raw = t);
  }
}
class W3 {
  constructor(e) {
    (this.elements = e), (this.$kind = 19);
  }
}
class J3 {
  constructor(e, t) {
    (this.keys = e), (this.values = t), (this.$kind = 20);
  }
}
class qd {
  constructor(e) {
    (this.name = e), (this.$kind = 21);
  }
}
class Q3 {
  constructor(e, t, i) {
    (this.declaration = e), (this.iterable = t), (this.semiIdx = i), (this.$kind = 22);
  }
}
class kx {
  constructor(e, t = je) {
    (this.parts = e), (this.expressions = t), (this.$kind = 23), (this.isMulti = t.length > 1), (this.firstExpression = t[0]);
  }
}
class Y3 {
  constructor(e, t, i, r) {
    (this.$kind = e), (this.list = t), (this.source = i), (this.initializer = r);
  }
}
class Px {
  constructor(e, t, i) {
    (this.target = e), (this.source = t), (this.initializer = i), (this.$kind = 26);
  }
}
class Zf {
  constructor(e, t, i = !1) {
    (this.args = e), (this.body = t), (this.rest = i), (this.$kind = 16);
  }
}
class Rm {
  constructor(e, t) {
    e !== void 0 && (this[e] = t);
  }
}
class pn {
  constructor(e, t, i, r) {
    (this.parent = e), (this.bindingContext = t), (this.overrideContext = i), (this.isBoundary = r);
  }
  static getContext(e, t, i) {
    if (e == null) throw Im();
    let r = e.overrideContext,
      s = e;
    if (i > 0) {
      for (; i > 0; ) if ((i--, (s = s.parent), s == null)) return;
      return (r = s.overrideContext), t in r ? r : s.bindingContext;
    }
    for (; s != null && !s.isBoundary && !(t in s.overrideContext) && !(t in s.bindingContext); ) s = s.parent;
    return s == null ? e.bindingContext : ((r = s.overrideContext), t in r ? r : s.bindingContext);
  }
  static create(e, t, i) {
    if (e == null) throw X3();
    return new pn(null, e, t ?? new Om(), i ?? !1);
  }
  static fromParent(e, t) {
    if (e == null) throw Im();
    return new pn(e, t, new Om(), !1);
  }
}
const Im = () => ae('AUR0203'),
  X3 = () => ae('AUR0204');
class Om {}
const ey = pn.getContext;
function G(n, e, t, i) {
  switch (n.$kind) {
    case 0: {
      let r = e.overrideContext,
        s = e,
        a = n.ancestor;
      for (; a-- && r; ) (s = s.parent), (r = s?.overrideContext ?? null);
      return a < 1 && s ? s.bindingContext : void 0;
    }
    case 1: {
      const r = ey(e, n.name, n.ancestor);
      i !== null && i.observe(r, n.name);
      const s = r[n.name];
      if (s == null && n.name === '$host') throw ae('AUR0105');
      return t?.strict ? (t?.boundFn && li(s) ? s.bind(r) : s) : s == null ? '' : t?.boundFn && li(s) ? s.bind(r) : s;
    }
    case 2:
      return n.elements.map((r) => G(r, e, t, i));
    case 3: {
      const r = {};
      for (let s = 0; s < n.keys.length; ++s) r[n.keys[s]] = G(n.values[s], e, t, i);
      return r;
    }
    case 4:
      return n.value;
    case 5: {
      let r = n.cooked[0];
      for (let s = 0; s < n.expressions.length; ++s) (r += String(G(n.expressions[s], e, t, i))), (r += n.cooked[s + 1]);
      return r;
    }
    case 6:
      switch (n.operation) {
        case 'void':
          return void G(n.expression, e, t, i);
        case 'typeof':
          return typeof G(n.expression, e, t, i);
        case '!':
          return !G(n.expression, e, t, i);
        case '-':
          return -G(n.expression, e, t, i);
        case '+':
          return +G(n.expression, e, t, i);
        default:
          throw ae(`AUR0109:${n.operation}`);
      }
    case 7: {
      const r = n.args.map((o) => G(o, e, t, i)),
        s = ey(e, n.name, n.ancestor),
        a = km(t?.strictFnCall, s, n.name);
      return a ? a.apply(s, r) : void 0;
    }
    case 8: {
      const r = G(n.object, e, t, i),
        s = n.args.map((u) => G(u, e, t, i)),
        a = km(t?.strictFnCall, r, n.name);
      let o;
      return a && ((o = a.apply(r, s)), vs(r) && tA.includes(n.name) && i?.observeCollection(r)), o;
    }
    case 9: {
      const r = G(n.func, e, t, i);
      if (li(r)) return r(...n.args.map((s) => G(s, e, t, i)));
      if (!t?.strictFnCall && r == null) return;
      throw ae('AUR0107');
    }
    case 16:
      return (...s) => {
        const a = n.args,
          o = n.rest,
          u = a.length - 1,
          l = a.reduce((f, m, w) => (o && w === u ? (f[m.name] = s.slice(w)) : (f[m.name] = s[w]), f), {}),
          c = pn.fromParent(e, l);
        return G(n.body, c, t, i);
      };
    case 10: {
      const r = G(n.object, e, t, i);
      let s;
      return t?.strict
        ? r == null
          ? void 0
          : (i !== null && i.observe(r, n.name), (s = r[n.name]), t?.boundFn && li(s) ? s.bind(r) : s)
        : (i !== null && bu(r) && i.observe(r, n.name), r ? ((s = r[n.name]), t?.boundFn && li(s) ? s.bind(r) : s) : '');
    }
    case 11: {
      const r = G(n.object, e, t, i),
        s = G(n.key, e, t, i);
      return bu(r) ? (i !== null && i.observe(r, s), r[s]) : r?.[s];
    }
    case 12: {
      const r = n.expressions.map((a) => G(a, e, t, i)),
        s = G(n.func, e, t, i);
      if (!li(s)) throw ae('AUR0110');
      return s(n.cooked, ...r);
    }
    case 13: {
      const r = n.left,
        s = n.right;
      switch (n.operation) {
        case '&&':
          return G(r, e, t, i) && G(s, e, t, i);
        case '||':
          return G(r, e, t, i) || G(s, e, t, i);
        case '??':
          return G(r, e, t, i) ?? G(s, e, t, i);
        case '==':
          return G(r, e, t, i) == G(s, e, t, i);
        case '===':
          return G(r, e, t, i) === G(s, e, t, i);
        case '!=':
          return G(r, e, t, i) != G(s, e, t, i);
        case '!==':
          return G(r, e, t, i) !== G(s, e, t, i);
        case 'instanceof': {
          const a = G(s, e, t, i);
          return li(a) ? G(r, e, t, i) instanceof a : !1;
        }
        case 'in': {
          const a = G(s, e, t, i);
          return bu(a) ? G(r, e, t, i) in a : !1;
        }
        case '+': {
          const a = G(r, e, t, i),
            o = G(s, e, t, i);
          if (t?.strict) return a + o;
          if (!a || !o) {
            if (Pm(a) || Pm(o)) return (a || 0) + (o || 0);
            if (Nm(a) || Nm(o)) return (a || '') + (o || '');
          }
          return a + o;
        }
        case '-':
          return G(r, e, t, i) - G(s, e, t, i);
        case '*':
          return G(r, e, t, i) * G(s, e, t, i);
        case '/':
          return G(r, e, t, i) / G(s, e, t, i);
        case '%':
          return G(r, e, t, i) % G(s, e, t, i);
        case '<':
          return G(r, e, t, i) < G(s, e, t, i);
        case '>':
          return G(r, e, t, i) > G(s, e, t, i);
        case '<=':
          return G(r, e, t, i) <= G(s, e, t, i);
        case '>=':
          return G(r, e, t, i) >= G(s, e, t, i);
        default:
          throw ae(`AUR0108:${n.operation}`);
      }
    }
    case 14:
      return G(n.condition, e, t, i) ? G(n.yes, e, t, i) : G(n.no, e, t, i);
    case 15:
      return bn(n.target, e, t, G(n.value, e, t, i));
    case 17: {
      const r = t?.getConverter?.(n.name);
      if (r == null) throw ae(`AUR0103:${n.name}`);
      return 'toView' in r ? r.toView(G(n.expression, e, t, i), ...n.args.map((s) => G(s, e, t, i))) : G(n.expression, e, t, i);
    }
    case 18:
      return G(n.expression, e, t, i);
    case 21:
      return n.name;
    case 22:
      return G(n.iterable, e, t, i);
    case 23:
      if (n.isMulti) {
        let r = n.parts[0],
          s = 0;
        for (; s < n.expressions.length; ++s) (r += vl(G(n.expressions[s], e, t, i))), (r += n.parts[s + 1]);
        return r;
      } else return `${n.parts[0]}${G(n.firstExpression, e, t, i)}${n.parts[1]}`;
    case 26:
      return G(n.target, e, t, i);
    case 24:
      return n.list.map((r) => G(r, e, t, i));
    case 19:
    case 20:
    case 25:
    default:
      return;
    case 28:
      return n.evaluate(e, t, i);
  }
}
function bn(n, e, t, i) {
  switch (n.$kind) {
    case 1: {
      if (n.name === '$host') throw ae('AUR0106');
      const r = ey(e, n.name, n.ancestor);
      return (r[n.name] = i);
    }
    case 10: {
      const r = G(n.object, e, t, null);
      return (
        bu(r)
          ? n.name === 'length' && vs(r) && !isNaN(i)
            ? r.splice(i)
            : (r[n.name] = i)
          : bn(n.object, e, t, {
              [n.name]: i,
            }),
        i
      );
    }
    case 11: {
      const r = G(n.object, e, t, null),
        s = G(n.key, e, t, null);
      if (vs(r)) {
        if (s === 'length' && !isNaN(i)) return r.splice(i), i;
        if (Fu(s)) return r.splice(s, 1, i), i;
      }
      return (r[s] = i);
    }
    case 15:
      return bn(n.value, e, t, i), bn(n.target, e, t, i);
    case 17: {
      const r = t?.getConverter?.(n.name);
      if (r == null) throw Nx(n.name);
      return 'fromView' in r && (i = r.fromView(i, ...n.args.map((s) => G(s, e, t, null)))), bn(n.expression, e, t, i);
    }
    case 18:
      return bn(n.expression, e, t, i);
    case 24:
    case 25: {
      const r = n.list,
        s = r.length;
      let a, o;
      for (a = 0; a < s; a++)
        switch (((o = r[a]), o.$kind)) {
          case 26:
            bn(o, e, t, i);
            break;
          case 24:
          case 25: {
            if (typeof i != 'object' || i === null) throw ae('AUR0112');
            let u = G(o.source, pn.create(i), t, null);
            u === void 0 && o.initializer && (u = G(o.initializer, e, t, null)), bn(o, e, t, u);
            break;
          }
        }
      break;
    }
    case 26: {
      if (n instanceof Px) {
        if (i == null) return;
        if (typeof i != 'object') throw ae('AUR0112');
        let r = G(n.source, pn.create(i), t, null);
        r === void 0 && n.initializer && (r = G(n.initializer, e, t, null)), bn(n.target, e, t, r);
      } else {
        if (i == null) return;
        if (typeof i != 'object') throw ae('AUR0112');
        const r = n.indexOrProperties;
        let s;
        if (Fu(r)) {
          if (!Array.isArray(i)) throw ae('AUR0112');
          s = i.slice(r);
        } else s = Object.entries(i).reduce((a, [o, u]) => (r.includes(o) || (a[o] = u), a), {});
        bn(n.target, e, t, s);
      }
      break;
    }
    case 28:
      return n.assign(e, t, i);
    default:
      return;
  }
}
function Pi(n, e, t) {
  switch (n.$kind) {
    case 18: {
      const i = n.name,
        r = n.key,
        s = t.getBehavior?.(i);
      if (s == null) throw Z3(i);
      if (t[r] === void 0) (t[r] = s), s.bind?.(e, t, ...n.args.map((a) => G(a, e, t, null)));
      else throw eA(i);
      Pi(n.expression, e, t);
      return;
    }
    case 17: {
      const i = n.name,
        r = t.getConverter?.(i);
      if (r == null) throw Nx(i);
      const s = r.signals;
      if (s != null) {
        const a = t.getSignaler?.(),
          o = s.length;
        let u = 0;
        for (; u < o; ++u) a?.addSignalListener(s[u], t);
      }
      Pi(n.expression, e, t);
      return;
    }
    case 22: {
      Pi(n.iterable, e, t);
      break;
    }
    case 28:
      n.bind?.(e, t);
  }
}
function pi(n, e, t) {
  switch (n.$kind) {
    case 18: {
      const i = n.key,
        r = t;
      r[i] !== void 0 && (r[i].unbind?.(e, t), (r[i] = void 0)), pi(n.expression, e, t);
      break;
    }
    case 17: {
      const i = t.getConverter?.(n.name);
      if (i?.signals === void 0) return;
      const r = t.getSignaler?.();
      let s = 0;
      for (; s < i.signals.length; ++s) r?.removeSignalListener(i.signals[s], t);
      pi(n.expression, e, t);
      break;
    }
    case 22: {
      pi(n.iterable, e, t);
      break;
    }
    case 28:
      n.unbind?.(e, t);
  }
}
const Z3 = (n) => ae(`AUR0101:${n}`),
  eA = (n) => ae(`AUR0102:${n}`),
  Nx = (n) => ae(`AUR0103:${n}`),
  km = (n, e, t) => {
    const i = e == null ? null : e[t];
    if (li(i)) return i;
    if (!n && i == null) return null;
    throw ae(`AUR0111:${t}`);
  },
  Pm = (n) => {
    switch (typeof n) {
      case 'number':
      case 'bigint':
        return !0;
      default:
        return !1;
    }
  },
  Nm = (n) => {
    switch (typeof n) {
      case 'string':
        return !0;
      case 'object':
        return n instanceof Date;
      default:
        return !1;
    }
  },
  tA = 'at map filter includes indexOf lastIndexOf findIndex find flat flatMap join reduce reduceRight slice every some sort'.split(' '),
  Dm = /* @__PURE__ */ be.createInterface('ICoercionConfiguration');
var Bm;
(function (n) {
  (n[(n.indexed = 8)] = 'indexed'), (n[(n.keyed = 4)] = 'keyed'), (n[(n.array = 9)] = 'array'), (n[(n.map = 6)] = 'map'), (n[(n.set = 7)] = 'set');
})(Bm || (Bm = {}));
var Fm;
(function (n) {
  (n[(n.None = 0)] = 'None'),
    (n[(n.Observer = 1)] = 'Observer'),
    (n[(n.Node = 2)] = 'Node'),
    (n[(n.Layout = 4)] = 'Layout'),
    (n[(n.Primtive = 8)] = 'Primtive'),
    (n[(n.Array = 18)] = 'Array'),
    (n[(n.Set = 34)] = 'Set'),
    (n[(n.Map = 66)] = 'Map');
})(Fm || (Fm = {}));
function ca(n = 0) {
  const e = Array(n);
  let t = 0;
  for (; t < n; ) e[t] = t++;
  return (e.deletedIndices = []), (e.deletedItems = []), (e.isIndexMap = !0), e;
}
function nA(n) {
  const e = n.slice();
  return (e.deletedIndices = n.deletedIndices.slice()), (e.deletedItems = n.deletedItems.slice()), (e.isIndexMap = !0), e;
}
function Gn(n) {
  return n == null ? Lm : Lm(n);
}
function Lm(n) {
  const e = n.prototype;
  yi(e, 'subs', {
    get: rA,
  }),
    xr(e, 'subscribe', sA),
    xr(e, 'unsubscribe', aA);
}
class iA {
  constructor() {
    (this.count = 0), (this.t = []);
  }
  add(e) {
    return this.t.includes(e) ? !1 : ((this.t[this.t.length] = e), ++this.count, !0);
  }
  remove(e) {
    const t = this.t.indexOf(e);
    return t !== -1 ? (this.t.splice(t, 1), --this.count, !0) : !1;
  }
  notify(e, t) {
    const i = this.t.slice(0),
      r = i.length;
    let s = 0;
    for (; s < r; ++s) i[s].handleChange(e, t);
  }
  notifyCollection(e, t) {
    const i = this.t.slice(0),
      r = i.length;
    let s = 0;
    for (; s < r; ++s) i[s].handleCollectionChange(e, t);
  }
}
function rA() {
  return kr(this, 'subs', new iA());
}
function sA(n) {
  return this.subs.add(n);
}
function aA(n) {
  return this.subs.remove(n);
}
class Dx {
  constructor(e) {
    (this.owner = e), (this.type = 18), (this.v = (this.o = e.collection).length);
  }
  getValue() {
    return this.o.length;
  }
  setValue(e) {
    e !== this.v && (Number.isNaN(e) || (this.o.splice(e), (this.v = this.o.length)));
  }
  handleCollectionChange(e, t) {
    const i = this.v,
      r = this.o.length;
    (this.v = r) !== i && this.subs.notify(this.v, i);
  }
}
class Ah {
  constructor(e) {
    (this.owner = e), (this.v = (this.o = e.collection).size), (this.type = fs(this.o) ? 66 : 34);
  }
  getValue() {
    return this.o.size;
  }
  setValue() {
    throw ae('AUR02');
  }
  handleCollectionChange(e, t) {
    const i = this.v,
      r = this.o.size;
    (this.v = r) !== i && this.subs.notify(this.v, i);
  }
}
function Bx(n) {
  const e = n.prototype;
  xr(e, 'subscribe', oA), xr(e, 'unsubscribe', uA), Gn(n);
}
function oA(n) {
  this.subs.add(n) && this.subs.count === 1 && this.owner.subscribe(this);
}
function uA(n) {
  this.subs.remove(n) && this.subs.count === 0 && this.owner.subscribe(this);
}
Bx(Dx);
Bx(Ah);
const $m = Symbol.for('__au_arr_obs__'),
  yr = Array[$m] ?? kr(Array, $m, /* @__PURE__ */ new WeakMap());
function lA(n, e) {
  return n === e ? 0 : ((n = n === null ? 'null' : n.toString()), (e = e === null ? 'null' : e.toString()), n < e ? -1 : 1);
}
function dA(n, e) {
  return n === void 0 ? (e === void 0 ? 0 : 1) : e === void 0 ? -1 : 0;
}
function cA(n, e, t, i, r) {
  let s, a, o, u, l, c, f;
  for (c = t + 1; c < i; c++) {
    for (s = n[c], a = e[c], f = c - 1; f >= t && ((o = n[f]), (u = e[f]), (l = r(o, s)), l > 0); f--) (n[f + 1] = o), (e[f + 1] = u);
    (n[f + 1] = s), (e[f + 1] = a);
  }
}
function Hd(n, e, t, i, r) {
  let s = 0,
    a = 0,
    o,
    u,
    l,
    c,
    f,
    m,
    w,
    v,
    T,
    A,
    _,
    O,
    B,
    P,
    N,
    U,
    W,
    z,
    Y;
  for (;;) {
    if (i - t <= 10) {
      cA(n, e, t, i, r);
      return;
    }
    (s = t + ((i - t) >> 1)),
      (o = n[t]),
      (c = e[t]),
      (u = n[i - 1]),
      (f = e[i - 1]),
      (l = n[s]),
      (m = e[s]),
      (w = r(o, u)),
      w > 0 && ((A = o), (_ = c), (o = u), (c = f), (u = A), (f = _)),
      (v = r(o, l)),
      v >= 0 ? ((A = o), (_ = c), (o = l), (c = m), (l = u), (m = f), (u = A), (f = _)) : ((T = r(u, l)), T > 0 && ((A = u), (_ = f), (u = l), (f = m), (l = A), (m = _))),
      (n[t] = o),
      (e[t] = c),
      (n[i - 1] = l),
      (e[i - 1] = m),
      (O = u),
      (B = f),
      (P = t + 1),
      (N = i - 1),
      (n[s] = n[P]),
      (e[s] = e[P]),
      (n[P] = O),
      (e[P] = B);
    e: for (a = P + 1; a < N; a++)
      if (((U = n[a]), (W = e[a]), (z = r(U, O)), z < 0)) (n[a] = n[P]), (e[a] = e[P]), (n[P] = U), (e[P] = W), P++;
      else if (z > 0) {
        do {
          if ((N--, N == a)) break e;
          (Y = n[N]), (z = r(Y, O));
        } while (z > 0);
        (n[a] = n[N]), (e[a] = e[N]), (n[N] = U), (e[N] = W), z < 0 && ((U = n[a]), (W = e[a]), (n[a] = n[P]), (e[a] = e[P]), (n[P] = U), (e[P] = W), P++);
      }
    i - N < P - t ? (Hd(n, e, N, i, r), (i = P)) : (Hd(n, e, t, P, r), (t = N));
  }
}
const Pr = Array.prototype,
  pA = Pr.push,
  qp = Pr.unshift,
  Hp = Pr.pop,
  Kp = Pr.shift,
  Jl = Pr.splice,
  fA = Pr.reverse,
  yA = Pr.sort,
  Fx = ['push', 'unshift', 'pop', 'shift', 'splice', 'reverse', 'sort'],
  Lx = {
    push: function (...n) {
      const e = yr.get(this);
      if (e === void 0) return pA.apply(this, n);
      const t = this.length,
        i = n.length;
      if (i === 0) return t;
      this.length = e.indexMap.length = t + i;
      let r = t;
      for (; r < this.length; ) (this[r] = n[r - t]), (e.indexMap[r] = -2), r++;
      return e.notify(), this.length;
    },
    unshift: function (...n) {
      const e = yr.get(this);
      if (e === void 0) return qp.apply(this, n);
      const t = n.length,
        i = new Array(t);
      let r = 0;
      for (; r < t; ) i[r++] = -2;
      qp.apply(e.indexMap, i);
      const s = qp.apply(this, n);
      return e.notify(), s;
    },
    pop: function () {
      const n = yr.get(this);
      if (n === void 0) return Hp.call(this);
      const e = n.indexMap,
        t = Hp.call(this),
        i = e.length - 1;
      return e[i] > -1 && (e.deletedIndices.push(e[i]), e.deletedItems.push(t)), Hp.call(e), n.notify(), t;
    },
    shift: function () {
      const n = yr.get(this);
      if (n === void 0) return Kp.call(this);
      const e = n.indexMap,
        t = Kp.call(this);
      return e[0] > -1 && (e.deletedIndices.push(e[0]), e.deletedItems.push(t)), Kp.call(e), n.notify(), t;
    },
    splice: function (...n) {
      const e = n[0],
        t = n[1],
        i = yr.get(this);
      if (i === void 0) return Jl.apply(this, n);
      const r = this.length,
        s = e | 0,
        a = s < 0 ? Math.max(r + s, 0) : Math.min(s, r),
        o = i.indexMap,
        u = n.length,
        l = u === 0 ? 0 : u === 1 ? r - a : t;
      let c = a;
      if (l > 0) {
        const m = c + l;
        for (; c < m; ) o[c] > -1 && (o.deletedIndices.push(o[c]), o.deletedItems.push(this[c])), c++;
      }
      if (((c = 0), u > 2)) {
        const m = u - 2,
          w = new Array(m);
        for (; c < m; ) w[c++] = -2;
        Jl.call(o, e, t, ...w);
      } else Jl.apply(o, n);
      const f = Jl.apply(this, n);
      return (l > 0 || c > 0) && i.notify(), f;
    },
    reverse: function () {
      const n = yr.get(this);
      if (n === void 0) return fA.call(this), this;
      const e = this.length,
        t = (e / 2) | 0;
      let i = 0;
      for (; i !== t; ) {
        const r = e - i - 1,
          s = this[i],
          a = n.indexMap[i],
          o = this[r],
          u = n.indexMap[r];
        (this[i] = o), (n.indexMap[i] = u), (this[r] = s), (n.indexMap[r] = a), i++;
      }
      return n.notify(), this;
    },
    sort: function (n) {
      const e = yr.get(this);
      if (e === void 0) return yA.call(this, n), this;
      let t = this.length;
      if (t < 2) return this;
      Hd(this, e.indexMap, 0, t, dA);
      let i = 0;
      for (; i < t && this[i] !== void 0; ) i++;
      (n === void 0 || !li(n)) && (n = lA), Hd(this, e.indexMap, 0, i, n);
      let r = !1;
      for (i = 0, t = e.indexMap.length; t > i; ++i)
        if (e.indexMap[i] !== i) {
          r = !0;
          break;
        }
      return r && e.notify(), this;
    },
  };
for (const n of Fx)
  yi(Lx[n], 'observing', {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1,
  });
let Um = !1;
const jm = '__au_arr_on__';
function hA() {
  if (!(xh(jm, Array) ?? !1)) {
    Th(jm, !0, Array);
    for (const n of Fx) Pr[n].observing !== !0 && kr(Pr, n, Lx[n]);
  }
}
class $x {
  constructor(e) {
    (this.type = 18), Um || ((Um = !0), hA()), (this.indexObservers = {}), (this.collection = e), (this.indexMap = ca(e.length)), (this.lenObs = void 0), yr.set(e, this);
  }
  notify() {
    this.subs;
    const e = this.indexMap,
      t = this.collection,
      i = t.length;
    (this.indexMap = ca(i)), this.subs.notifyCollection(t, e);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new Dx(this));
  }
  getIndexObserver(e) {
    var t;
    return (t = this.indexObservers)[e] ?? (t[e] = new Ux(this, e));
  }
}
class Ux {
  constructor(e, t) {
    (this.owner = e), (this.index = t), (this.doNotCache = !0), (this.value = this.getValue());
  }
  getValue() {
    return this.owner.collection[this.index];
  }
  setValue(e) {
    if (e === this.getValue()) return;
    const t = this.owner,
      i = this.index,
      r = t.indexMap;
    r[i] > -1 && r.deletedIndices.push(r[i]), (r[i] = -2), (t.collection[i] = e), t.notify();
  }
  handleCollectionChange(e, t) {
    const i = this.index;
    if (t[i] === i) return;
    const s = this.value,
      a = (this.value = this.getValue());
    s !== a && this.subs.notify(a, s);
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && this.owner.subscribe(this);
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && this.owner.unsubscribe(this);
  }
}
Gn($x);
Gn(Ux);
function vu(n) {
  let e = yr.get(n);
  return e === void 0 && (e = new $x(n)), e;
}
const mA = (n, e) => n - e;
function bA(n) {
  let e = 0,
    t = 0,
    i = 0;
  const r = nA(n);
  r.deletedIndices.length > 1 && r.deletedIndices.sort(mA);
  const s = r.length;
  for (; i < s; ++i) {
    for (; r.deletedIndices[t] <= i - e; ) ++t, --e;
    r[i] === -2 ? ++e : (r[i] += e);
  }
  return r;
}
function gA(n, e) {
  const t = n.slice(),
    i = e.length;
  let r = 0,
    s = 0;
  for (; r < i; ) (s = e[r]), s !== -2 && (n[r] = t[s]), ++r;
}
const Vm = Symbol.for('__au_set_obs__'),
  xu = Set[Vm] ?? kr(Set, Vm, /* @__PURE__ */ new WeakMap()),
  Uu = Set.prototype,
  zm = Uu.add,
  Gm = Uu.clear,
  qm = Uu.delete,
  jx = ['add', 'clear', 'delete'],
  Vx = {
    add: function (n) {
      const e = xu.get(this);
      if (e === void 0) return zm.call(this, n), this;
      const t = this.size;
      return zm.call(this, n), this.size === t ? this : ((e.indexMap[t] = -2), e.notify(), this);
    },
    clear: function () {
      const n = xu.get(this);
      if (n === void 0) return Gm.call(this);
      if (this.size > 0) {
        const t = n.indexMap;
        let i = 0;
        for (const r of this.keys()) t[i] > -1 && (t.deletedIndices.push(t[i]), t.deletedItems.push(r)), i++;
        Gm.call(this), (t.length = 0), n.notify();
      }
    },
    delete: function (n) {
      const e = xu.get(this);
      if (e === void 0) return qm.call(this, n);
      if (this.size === 0) return !1;
      let i = 0;
      const r = e.indexMap;
      for (const s of this.keys()) {
        if (s === n) {
          r[i] > -1 && (r.deletedIndices.push(r[i]), r.deletedItems.push(s)), r.splice(i, 1);
          const a = qm.call(this, n);
          return a === !0 && e.notify(), a;
        }
        i++;
      }
      return !1;
    },
  },
  vA = {
    writable: !0,
    enumerable: !1,
    configurable: !0,
  };
for (const n of jx)
  yi(Vx[n], 'observing', {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1,
  });
let Hm = !1;
const Km = '__au_set_on__';
function xA() {
  if (!(xh(Km, Set) ?? !1)) {
    Th(Km, !0, Set);
    for (const n of jx)
      Uu[n].observing !== !0 &&
        yi(Uu, n, {
          ...vA,
          value: Vx[n],
        });
  }
}
class zx {
  constructor(e) {
    (this.type = 34), Hm || ((Hm = !0), xA()), (this.collection = e), (this.indexMap = ca(e.size)), (this.lenObs = void 0), xu.set(e, this);
  }
  notify() {
    this.subs;
    const e = this.indexMap,
      t = this.collection,
      i = t.size;
    (this.indexMap = ca(i)), this.subs.notifyCollection(t, e);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new Ah(this));
  }
}
Gn(zx);
function Kd(n) {
  let e = xu.get(n);
  return e === void 0 && (e = new zx(n)), e;
}
const Wm = Symbol.for('__au_map_obs__'),
  Tu = Map[Wm] ?? kr(Map, Wm, /* @__PURE__ */ new WeakMap()),
  ju = Map.prototype,
  Jm = ju.set,
  Qm = ju.clear,
  Ym = ju.delete,
  Gx = ['set', 'clear', 'delete'],
  qx = {
    set: function (n, e) {
      const t = Tu.get(this);
      if (t === void 0) return Jm.call(this, n, e), this;
      const i = this.get(n),
        r = this.size;
      if ((Jm.call(this, n, e), this.size === r)) {
        let a = 0;
        for (const o of this.entries()) {
          if (o[0] === n) return o[1] !== i && (t.indexMap.deletedIndices.push(t.indexMap[a]), t.indexMap.deletedItems.push(o), (t.indexMap[a] = -2), t.notify()), this;
          a++;
        }
        return this;
      }
      return (t.indexMap[r] = -2), t.notify(), this;
    },
    clear: function () {
      const n = Tu.get(this);
      if (n === void 0) return Qm.call(this);
      if (this.size > 0) {
        const t = n.indexMap;
        let i = 0;
        for (const r of this.keys()) t[i] > -1 && (t.deletedIndices.push(t[i]), t.deletedItems.push(r)), i++;
        Qm.call(this), (t.length = 0), n.notify();
      }
    },
    delete: function (n) {
      const e = Tu.get(this);
      if (e === void 0) return Ym.call(this, n);
      if (this.size === 0) return !1;
      let i = 0;
      const r = e.indexMap;
      for (const s of this.keys()) {
        if (s === n) {
          r[i] > -1 && (r.deletedIndices.push(r[i]), r.deletedItems.push(s)), r.splice(i, 1);
          const a = Ym.call(this, n);
          return a === !0 && e.notify(), a;
        }
        ++i;
      }
      return !1;
    },
  },
  TA = {
    writable: !0,
    enumerable: !1,
    configurable: !0,
  };
for (const n of Gx)
  yi(qx[n], 'observing', {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1,
  });
let Xm = !1;
const Zm = '__au_map_on__';
function wA() {
  if (!(xh(Zm, Map) ?? !1)) {
    Th(Zm, !0, Map);
    for (const n of Gx)
      ju[n].observing !== !0 &&
        yi(ju, n, {
          ...TA,
          value: qx[n],
        });
  }
}
class Hx {
  constructor(e) {
    (this.type = 66), Xm || ((Xm = !0), wA()), (this.collection = e), (this.indexMap = ca(e.size)), (this.lenObs = void 0), Tu.set(e, this);
  }
  notify() {
    const e = this.subs,
      t = this.indexMap,
      i = this.collection,
      r = i.size;
    (this.indexMap = ca(r)), e.notifyCollection(i, t);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new Ah(this));
  }
}
Gn(Hx);
function Wd(n) {
  let e = Tu.get(n);
  return e === void 0 && (e = new Hx(n)), e;
}
function AA() {
  return kr(this, 'obs', new RA(this));
}
function EA(n, e) {
  this.obs.add(this.oL.getObserver(n, e));
}
function SA(n) {
  let e;
  if (vs(n)) e = vu(n);
  else if (gl(n)) e = Kd(n);
  else if (fs(n)) e = Wd(n);
  else throw ae('AUR0210');
  this.obs.add(e);
}
function CA(n) {
  this.obs.add(n);
}
function MA() {
  throw ae('AUR2011:handleChange');
}
function _A() {
  throw ae('AUR2011:handleCollectionChange');
}
class RA {
  constructor(e) {
    (this.version = 0), (this.count = 0), (this.o = /* @__PURE__ */ new Map()), (this.b = e);
  }
  add(e) {
    this.o.has(e) || (e.subscribe(this.b), ++this.count), this.o.set(e, this.version);
  }
  clear() {
    this.o.forEach(OA, this), (this.count = this.o.size);
  }
  clearAll() {
    this.o.forEach(IA, this), this.o.clear(), (this.count = 0);
  }
}
function IA(n, e) {
  e.unsubscribe(this.b);
}
function OA(n, e) {
  this.version !== n && (e.unsubscribe(this.b), this.o.delete(e));
}
function eb(n) {
  const e = n.prototype;
  return (
    xr(e, 'observe', EA),
    xr(e, 'observeCollection', SA),
    xr(e, 'subscribeTo', CA),
    yi(e, 'obs', {
      get: AA,
    }),
    xr(e, 'handleChange', MA),
    xr(e, 'handleCollectionChange', _A),
    n
  );
}
function Fi(n) {
  return n == null ? eb : eb(n);
}
const Eh = No('IExpressionParser', (n) => n.singleton(kA));
class kA {
  constructor() {
    (this.i = gu()), (this.u = gu()), (this.h = gu());
  }
  parse(e, t) {
    let i;
    switch (t) {
      case 32:
        return new wh(e);
      case 1:
        return (i = this.h[e]), i === void 0 && (i = this.h[e] = this.$parse(e, t)), i;
      case 2:
        return (i = this.u[e]), i === void 0 && (i = this.u[e] = this.$parse(e, t)), i;
      default: {
        if (e.length === 0) {
          if ((t & 24) > 0) return cn.$empty;
          throw JA();
        }
        return (i = this.i[e]), i === void 0 && (i = this.i[e] = this.$parse(e, t)), i;
      }
    }
  }
  $parse(e, t) {
    return (Pe = e), (_e = 0), (er = e.length), (Xn = 0), (pa = 0), (ee = 6291456), (ze = ''), (At = fa(0)), (Ne = !0), (Ie = !1), (Ch = -1), kt(61, t === void 0 ? 16 : t);
  }
}
function Sh(n) {
  switch (n) {
    case 98:
      return 8;
    case 116:
      return 9;
    case 110:
      return 10;
    case 118:
      return 11;
    case 102:
      return 12;
    case 114:
      return 13;
    case 34:
      return 34;
    case 39:
      return 39;
    case 92:
      return 92;
    default:
      return n;
  }
}
const PA = cn.$false,
  NA = cn.$true,
  DA = cn.$null,
  Kx = cn.$undefined,
  wu = _r.$this,
  Wp = _r.$parent;
var tb;
(function (n) {
  (n[(n.None = 0)] = 'None'),
    (n[(n.Interpolation = 1)] = 'Interpolation'),
    (n[(n.IsIterator = 2)] = 'IsIterator'),
    (n[(n.IsChainable = 4)] = 'IsChainable'),
    (n[(n.IsFunction = 8)] = 'IsFunction'),
    (n[(n.IsProperty = 16)] = 'IsProperty'),
    (n[(n.IsCustom = 32)] = 'IsCustom');
})(tb || (tb = {}));
let Pe = '',
  _e = 0,
  er = 0,
  Xn = 0,
  pa = 0,
  ee = 6291456,
  ze = '',
  At,
  Ne = !0,
  Ie = !1,
  Ch = -1;
const Vu = String.fromCharCode,
  fa = (n) => Pe.charCodeAt(n),
  uo = () => Pe.slice(pa, _e);
function kt(n, e) {
  if (e === 32) return new wh(Pe);
  if (_e === 0) {
    if (e & 1) return VA();
    if ((ce(), ee & 4194304)) throw HA();
  }
  (Ne = 513 > n), (Ie = !1);
  let t = !1,
    i,
    r = 0;
  if (ee & 131072) {
    const s = wd[ee & 63];
    ce(), (i = new K3(s, kt(514, e))), (Ne = !1);
  } else {
    e: switch (ee) {
      case 12294:
        (r = Xn), (Ne = !1);
        do
          switch ((ce(), ++r, ee)) {
            case 65545:
              if ((ce(), !(ee & 12288))) throw pr();
              break;
            case 10:
            case 11:
              throw pr();
            case 2162700:
              if (((Ie = !0), ce(), !(ee & 12288))) {
                (i = r === 0 ? wu : r === 1 ? Wp : new _r(r)), (t = !0);
                break e;
              }
              break;
            default:
              if (ee & 2097152) {
                i = r === 0 ? wu : r === 1 ? Wp : new _r(r);
                break e;
              }
              throw KA();
          }
        while (ee === 12294);
      case 4096: {
        const s = ze;
        if ((e & 2 ? (i = new qd(s)) : (i = new gd(s, r)), (Ne = !Ie), ce(), Ci(50))) {
          if (ee === 524296) throw e1();
          const a = Ie,
            o = Xn;
          ++Xn;
          const u = kt(62, 0);
          (Ie = a), (Xn = o), (Ne = !1), (i = new Zf([new qd(s)], u));
        }
        break;
      }
      case 10:
        throw rE();
      case 11:
        throw ty();
      case 12292:
        switch (((Ne = !1), ce(), Xn)) {
          case 0:
            i = wu;
            break;
          case 1:
            i = Wp;
            break;
          default:
            i = new _r(Xn);
            break;
        }
        break;
      case 2688007:
        i = LA(e);
        break;
      case 2688016:
        i = Pe.search(/\s+of\s+/) > _e ? BA() : $A(e);
        break;
      case 524296:
        i = jA(e);
        break;
      case 2163759:
        (i = new Gd([ze])), (Ne = !1), ce();
        break;
      case 2163760:
        i = Jp(e, i, !1);
        break;
      case 16384:
      case 32768:
        (i = new cn(ze)), (Ne = !1), ce();
        break;
      case 8194:
      case 8195:
      case 8193:
      case 8192:
        (i = wd[ee & 63]), (Ne = !1), ce();
        break;
      default:
        throw _e >= er ? WA() : Qp();
    }
    if (e & 2) return UA(i);
    if (514 < n) return i;
    if (ee === 10 || ee === 11) throw pr();
    if (i.$kind === 0)
      switch (ee) {
        case 2162700:
          if (((Ie = !0), (Ne = !1), ce(), !(ee & 13312))) throw Mh();
          if (ee & 12288) (i = new gd(ze, i.ancestor)), ce();
          else if (ee === 2688007) i = new vd(i, Gi(), !0);
          else if (ee === 2688016) i = xd(i, !0);
          else throw Td();
          break;
        case 65545:
          if (((Ne = !Ie), ce(), !(ee & 12288))) throw pr();
          (i = new gd(ze, i.ancestor)), ce();
          break;
        case 10:
        case 11:
          throw pr();
        case 2688007:
          i = new vd(i, Gi(), t);
          break;
        case 2688016:
          i = xd(i, t);
          break;
        case 2163759:
          i = nb(i);
          break;
        case 2163760:
          i = Jp(e, i, !0);
          break;
      }
    for (; (ee & 65536) > 0; )
      switch (ee) {
        case 2162700:
          i = FA(i);
          break;
        case 65545:
          if ((ce(), !(ee & 12288))) throw pr();
          i = Wx(i, !1);
          break;
        case 10:
        case 11:
          throw pr();
        case 2688007:
          i.$kind === 1 ? (i = new Ix(i.name, Gi(), i.ancestor, !1)) : i.$kind === 10 ? (i = new zd(i.object, i.name, Gi(), i.optional, !1)) : (i = new vd(i, Gi(), !1));
          break;
        case 2688016:
          i = xd(i, !1);
          break;
        case 2163759:
          if (Ie) throw Td();
          i = nb(i);
          break;
        case 2163760:
          if (Ie) throw Td();
          i = Jp(e, i, !0);
          break;
      }
  }
  if (ee === 10 || ee === 11) throw pr();
  if (513 < n) return i;
  for (; (ee & 262144) > 0; ) {
    const s = ee;
    if ((s & 960) <= n) break;
    ce(), (i = new H3(wd[s & 63], i, kt(s & 960, e))), (Ne = !1);
  }
  if (63 < n) return i;
  if (Ci(6291478)) {
    const s = kt(62, e);
    Ni(6291476), (i = new q3(i, s, kt(62, e))), (Ne = !1);
  }
  if (62 < n) return i;
  if (Ci(4194349)) {
    if (!Ne) throw QA();
    i = new G3(i, kt(62, e));
  }
  if (61 < n) return i;
  for (; Ci(6291480); ) {
    if (ee === 6291456) throw YA();
    const s = ze;
    ce();
    const a = new Array();
    for (; Ci(6291476); ) a.push(kt(62, e));
    i = new $u(i, s, a);
  }
  for (; Ci(6291479); ) {
    if (ee === 6291456) throw XA();
    const s = ze;
    ce();
    const a = new Array();
    for (; Ci(6291476); ) a.push(kt(62, e));
    i = new z3(i, s, a);
  }
  if (ee !== 6291456) {
    if ((e & 1) > 0 && ee === 7340045) return i;
    if ((e & 4) > 0 && ee === 6291477) {
      if (_e === er) throw Qp();
      return (Ch = _e - 1), i;
    }
    throw uo() === 'of' ? ZA() : Qp();
  }
  return i;
}
function BA() {
  const n = [],
    e = new Y3(24, n, void 0, void 0);
  let t = '',
    i = !0,
    r = 0;
  for (; i; )
    switch ((ce(), ee)) {
      case 7340051:
        (i = !1), s();
        break;
      case 6291471:
        s();
        break;
      case 4096:
        t = uo();
        break;
      default:
        throw nE();
    }
  return Ni(7340051), e;
  function s() {
    t !== '' ? (n.push(new Px(new Qf(wu, t), new Rx(wu, new cn(r++)), void 0)), (t = '')) : r++;
  }
}
function Gi() {
  const n = Ie;
  ce();
  const e = [];
  for (; ee !== 7340046 && (e.push(kt(62, 0)), !!Ci(6291471)); );
  return Ni(7340046), (Ne = !1), (Ie = n), e;
}
function xd(n, e) {
  const t = Ie;
  return ce(), (n = new Rx(n, kt(62, 0), e)), Ni(7340051), (Ne = !t), (Ie = t), n;
}
function FA(n) {
  if (((Ie = !0), (Ne = !1), ce(), !(ee & 13312))) throw Mh();
  if (ee & 12288) return Wx(n, !0);
  if (ee === 2688007) return n.$kind === 1 ? new Ix(n.name, Gi(), n.ancestor, !0) : n.$kind === 10 ? new zd(n.object, n.name, Gi(), n.optional, !0) : new vd(n, Gi(), !0);
  if (ee === 2688016) return xd(n, !0);
  throw Td();
}
function Wx(n, e) {
  const t = ze;
  switch (ee) {
    case 2162700: {
      (Ie = !0), (Ne = !1);
      const i = _e,
        r = pa,
        s = ee,
        a = At,
        o = ze,
        u = Ne,
        l = Ie;
      if ((ce(), !(ee & 13312))) throw Mh();
      return ee === 2688007 ? new zd(n, t, Gi(), e, !0) : ((_e = i), (pa = r), (ee = s), (At = a), (ze = o), (Ne = u), (Ie = l), new Qf(n, t, e));
    }
    case 2688007:
      return (Ne = !1), new zd(n, t, Gi(), e, !1);
    default:
      return (Ne = !Ie), ce(), new Qf(n, t, e);
  }
}
function LA(n) {
  ce();
  const e = _e,
    t = pa,
    i = ee,
    r = At,
    s = ze,
    a = Ne,
    o = Ie,
    u = [];
  let l = 1,
    c = !1;
  e: for (;;) {
    if (ee === 11) {
      if ((ce(), ee !== 4096)) throw pr();
      if ((u.push(new qd(ze)), ce(), ee === 6291471)) throw iE();
      if (ee !== 7340046 || (ce(), ee !== 50)) throw ty();
      ce();
      const w = Ie,
        v = Xn;
      ++Xn;
      const T = kt(62, 0);
      return (Ie = w), (Xn = v), (Ne = !1), new Zf(u, T, !0);
    }
    switch (ee) {
      case 4096:
        u.push(new qd(ze)), ce();
        break;
      case 7340046:
        ce();
        break e;
      case 524296:
      case 2688016:
        ce(), (l = 4);
        break;
      case 6291471:
        (l = 2), (c = !0);
        break e;
      case 2688007:
        l = 2;
        break e;
      default:
        ce(), (l = 2);
        break;
    }
    switch (ee) {
      case 6291471:
        if ((ce(), (c = !0), l === 1)) break;
        break e;
      case 7340046:
        ce();
        break e;
      case 4194349:
        l === 1 && (l = 3);
        break e;
      case 50:
        if (c) throw Ql();
        ce(), (l = 2);
        break e;
      default:
        l === 1 && (l = 2);
        break e;
    }
  }
  if (ee === 50) {
    if (l === 1) {
      if ((ce(), ee === 524296)) throw e1();
      const w = Ie,
        v = Xn;
      ++Xn;
      const T = kt(62, 0);
      return (Ie = w), (Xn = v), (Ne = !1), new Zf(u, T);
    }
    throw Ql();
  } else if (l === 1 && u.length === 0) throw Xx(50);
  if (c)
    switch (l) {
      case 2:
        throw Ql();
      case 3:
        throw rb();
      case 4:
        throw sb();
    }
  (_e = e), (pa = t), (ee = i), (At = r), (ze = s), (Ne = a), (Ie = o);
  const f = Ie,
    m = kt(62, n);
  if (((Ie = f), Ni(7340046), ee === 50))
    switch (l) {
      case 2:
        throw Ql();
      case 3:
        throw rb();
      case 4:
        throw sb();
    }
  return m;
}
function $A(n) {
  const e = Ie;
  ce();
  const t = new Array();
  for (; ee !== 7340051; )
    if (Ci(6291471)) {
      if ((t.push(Kx), ee === 7340051)) break;
    } else if ((t.push(kt(62, n & -3)), Ci(6291471))) {
      if (ee === 7340051) break;
    } else break;
  return (Ie = e), Ni(7340051), n & 2 ? new W3(t) : ((Ne = !1), new Yf(t));
}
function UA(n) {
  if (!(n.$kind & 23) || ee !== 4204593) throw ib();
  ce();
  const e = n,
    t = kt(61, 4);
  return new Q3(e, t, Ch);
}
function jA(n) {
  const e = Ie,
    t = new Array(),
    i = new Array();
  for (ce(); ee !== 7340045; ) {
    if ((t.push(ze), ee & 49152)) ce(), Ni(6291476), i.push(kt(62, n & -3));
    else if (ee & 12288) {
      const r = At,
        s = ee,
        a = _e;
      ce(), Ci(6291476) ? i.push(kt(62, n & -3)) : ((At = r), (ee = s), (_e = a), i.push(kt(515, n & -3)));
    } else throw eE();
    ee !== 7340045 && Ni(6291471);
  }
  return (Ie = e), Ni(7340045), n & 2 ? new J3(t, i) : ((Ne = !1), new Xf(t, i));
}
function VA() {
  const n = [],
    e = [],
    t = er;
  let i = '';
  for (; _e < t; ) {
    switch (At) {
      case 36:
        if (fa(_e + 1) === 123) {
          n.push(i), (i = ''), (_e += 2), (At = fa(_e)), ce();
          const r = kt(61, 1);
          e.push(r);
          continue;
        } else i += '$';
        break;
      case 92:
        i += Vu(Sh(ve()));
        break;
      default:
        i += Vu(At);
    }
    ve();
  }
  return e.length ? (n.push(i), new kx(n, e)) : null;
}
function Jp(n, e, t) {
  const i = Ie,
    r = [ze];
  Ni(2163760);
  const s = [kt(62, n)];
  for (; (ee = qA()) !== 2163759; ) r.push(ze), Ni(2163760), s.push(kt(62, n));
  return r.push(ze), (Ne = !1), (Ie = i), t ? (ce(), new Ox(r, r, e, s)) : (ce(), new Gd(r, s));
}
function nb(n) {
  Ne = !1;
  const e = [ze];
  return ce(), new Ox(e, e, n);
}
function ce() {
  for (; _e < er; ) if (((pa = _e), (ee = Be[At]()) != null)) return;
  ee = 6291456;
}
function ve() {
  return (At = fa(++_e));
}
function zA() {
  for (; _h[ve()]; );
  const n = sE[(ze = uo())];
  return n === void 0 ? 4096 : n;
}
function Jx(n) {
  let e = At;
  if (n === !1) {
    do e = ve();
    while (e <= 57 && e >= 48);
    if (e !== 46) return (ze = parseInt(uo(), 10)), 32768;
    if (((e = ve()), _e >= er)) return (ze = parseInt(uo().slice(0, -1), 10)), 32768;
  }
  if (e <= 57 && e >= 48)
    do e = ve();
    while (e <= 57 && e >= 48);
  else At = fa(--_e);
  return (ze = parseFloat(uo())), 32768;
}
function GA() {
  const n = At;
  ve();
  let e = 0;
  const t = new Array();
  let i = _e;
  for (; At !== n; )
    if (At === 92) t.push(Pe.slice(i, _e)), ve(), (e = Sh(At)), ve(), t.push(Vu(e)), (i = _e);
    else {
      if (_e >= er) throw tE();
      ve();
    }
  const r = Pe.slice(i, _e);
  return ve(), t.push(r), (ze = t.join('')), 16384;
}
function Qx() {
  let n = !0,
    e = '';
  for (; ve() !== 96; )
    if (At === 36)
      if (_e + 1 < er && fa(_e + 1) === 123) {
        _e++, (n = !1);
        break;
      } else e += '$';
    else if (At === 92) e += Vu(Sh(ve()));
    else {
      if (_e >= er) throw Yx();
      e += Vu(At);
    }
  return ve(), (ze = e), n ? 2163759 : 2163760;
}
const qA = () => {
    if (_e >= er) throw Yx();
    return _e--, Qx();
  },
  Ci = (n) => (ee === n ? (ce(), !0) : !1),
  Ni = (n) => {
    if (ee === n) ce();
    else throw Xx(n);
  },
  HA = () => ae(`AUR0151:${Pe}`),
  ty = () => ae(`AUR0152:${Pe}`),
  pr = () => ae(`AUR0153:${Pe}`),
  KA = () => ae(`AUR0154:${Pe}`),
  WA = () => ae(`AUR0155:${Pe}`),
  Qp = () => ae(`AUR0156:${Pe}`),
  JA = () => ae('AUR0157'),
  QA = () => ae(`AUR0158:${Pe}`),
  YA = () => ae(`AUR0159:${Pe}`),
  XA = () => ae(`AUR0160:${Pe}`),
  ZA = () => ae(`AUR0161:${Pe}`),
  ib = () => ae(`AUR0163:${Pe}`),
  eE = () => ae(`AUR0164:${Pe}`),
  tE = () => ae(`AUR0165:${Pe}`),
  Yx = () => ae(`AUR0166:${Pe}`),
  Xx = (n) => ae(`AUR0167:${Pe}<${wd[n & 63]}`),
  Zx = () => {
    throw ae(`AUR0168:${Pe}`);
  };
Zx.notMapped = !0;
const nE = () => ae(`AUR0170:${Pe}`),
  Mh = () => ae(`AUR0171:${Pe}`),
  Td = () => ae(`AUR0172:${Pe}`),
  Ql = () => ae(`AUR0173:${Pe}`),
  rb = () => ae(`AUR0174:${Pe}`),
  sb = () => ae(`AUR0175:${Pe}`),
  iE = () => ae(`AUR0176:${Pe}`),
  e1 = () => ae(`AUR0178:${Pe}`),
  rE = () => ae(`AUR0179:${Pe}`),
  wd = [
    PA,
    NA,
    DA,
    Kx,
    '$this',
    null,
    '$parent',
    '(',
    '{',
    '.',
    '..',
    '...',
    '?.',
    '}',
    ')',
    ',',
    '[',
    ']',
    ':',
    ';',
    '?',
    "'",
    '"',
    '&',
    '|',
    '??',
    '||',
    '&&',
    '==',
    '!=',
    '===',
    '!==',
    '<',
    '>',
    '<=',
    '>=',
    'in',
    'instanceof',
    '+',
    '-',
    'typeof',
    'void',
    '*',
    '%',
    '/',
    '=',
    '!',
    2163759,
    2163760,
    'of',
    '=>',
  ],
  sE = _x(/* @__PURE__ */ Object.create(null), {
    true: 8193,
    null: 8194,
    false: 8192,
    undefined: 8195,
    $this: 12292,
    $parent: 12294,
    in: 6562212,
    instanceof: 6562213,
    typeof: 139304,
    void: 139305,
    of: 4204593,
  }),
  Do = {
    AsciiIdPart: [36, 0, 48, 58, 65, 91, 95, 0, 97, 123],
    IdStart: [
      36, 0, 65, 91, 95, 0, 97, 123, 170, 0, 186, 0, 192, 215, 216, 247, 248, 697, 736, 741, 7424, 7462, 7468, 7517, 7522, 7526, 7531, 7544, 7545, 7615, 7680, 7936, 8305, 0, 8319, 0, 8336, 8349, 8490,
      8492, 8498, 0, 8526, 0, 8544, 8585, 11360, 11392, 42786, 42888, 42891, 42927, 42928, 42936, 42999, 43008, 43824, 43867, 43868, 43877, 64256, 64263, 65313, 65339, 65345, 65371,
    ],
    Digit: [48, 58],
    Skip: [0, 33, 127, 161],
  },
  Bo = (n, e, t, i) => {
    const r = t.length;
    for (let s = 0; s < r; s += 2) {
      const a = t[s];
      let o = t[s + 1];
      if (((o = o > 0 ? o : a + 1), n && n.fill(i, a, o), e)) for (let u = a; u < o; u++) e.add(u);
    }
  },
  qn = (n) => () => (ve(), n),
  aE = /* @__PURE__ */ new Set();
Bo(null, aE, Do.AsciiIdPart, !0);
const _h = new Uint8Array(65535);
Bo(_h, null, Do.IdStart, 1);
Bo(_h, null, Do.Digit, 1);
const Be = new Array(65535);
Be.fill(Zx, 0, 65535);
Bo(Be, null, Do.Skip, () => (ve(), null));
Bo(Be, null, Do.IdStart, zA);
Bo(Be, null, Do.Digit, () => Jx(!1));
Be[34] = Be[39] = () => GA();
Be[96] = () => Qx();
Be[33] = () => (ve() !== 61 ? 131118 : ve() !== 61 ? 6553949 : (ve(), 6553951));
Be[61] = () => (ve() === 62 ? (ve(), 50) : At !== 61 ? 4194349 : ve() !== 61 ? 6553948 : (ve(), 6553950));
Be[38] = () => (ve() !== 38 ? 6291479 : (ve(), 6553883));
Be[124] = () => (ve() !== 124 ? 6291480 : (ve(), 6553818));
Be[63] = () => {
  if (ve() === 46) {
    const n = fa(_e + 1);
    return n <= 48 || n >= 57 ? (ve(), 2162700) : 6291478;
  }
  return At !== 63 ? 6291478 : (ve(), 6553753);
};
Be[46] = () => (ve() <= 57 && At >= 48 ? Jx(!0) : At === 46 ? (ve() !== 46 ? 10 : (ve(), 11)) : 65545);
Be[60] = () => (ve() !== 61 ? 6554016 : (ve(), 6554018));
Be[62] = () => (ve() !== 61 ? 6554017 : (ve(), 6554019));
Be[37] = qn(6554155);
Be[40] = qn(2688007);
Be[41] = qn(7340046);
Be[42] = qn(6554154);
Be[43] = qn(2490854);
Be[44] = qn(6291471);
Be[45] = qn(2490855);
Be[47] = qn(6554156);
Be[58] = qn(6291476);
Be[59] = qn(6291477);
Be[91] = qn(2688016);
Be[93] = qn(7340051);
Be[123] = qn(524296);
Be[125] = qn(7340045);
let Ae = null;
const no = [];
let Nr = !1;
function oE() {
  Nr = !1;
}
function uE() {
  Nr = !0;
}
function Rh() {
  return Ae;
}
function Ih(n) {
  if (n == null) throw ae('AUR0206');
  if (Ae == null) {
    (Ae = n), (no[0] = Ae), (Nr = !0);
    return;
  }
  if (Ae === n) throw ae('AUR0207');
  no.push(n), (Ae = n), (Nr = !0);
}
function Oh(n) {
  if (n == null) throw ae('AUR0208');
  if (Ae !== n) throw ae('AUR0209');
  no.pop(), (Ae = no.length > 0 ? no[no.length - 1] : null), (Nr = Ae != null);
}
const lE = Object.freeze({
    get current() {
      return Ae;
    },
    get connecting() {
      return Nr;
    },
    enter: Ih,
    exit: Oh,
    pause: oE,
    resume: uE,
  }),
  mo = Reflect.get,
  dE = Object.prototype.toString,
  ny = /* @__PURE__ */ new WeakMap(),
  t1 = '__au_nw__',
  n1 = '__au_nw';
function i1(n) {
  switch (dE.call(n)) {
    case '[object Object]':
      return n.constructor[t1] !== !0;
    case '[object Array]':
    case '[object Map]':
    case '[object Set]':
      return !0;
    default:
      return !1;
  }
}
const Fo = '__raw__';
function xe(n) {
  return i1(n) ? qc(n) : n;
}
function qc(n) {
  return ny.get(n) ?? cE(n);
}
function ke(n) {
  return n[Fo] ?? n;
}
function Rn(n) {
  return (i1(n) && n[Fo]) || n;
}
function kh(n, e) {
  return e === 'constructor' || e === '__proto__' || e === '$observers' || e === Symbol.toPrimitive || e === Symbol.toStringTag || n.constructor[`${n1}_${vl(e)}__`] === !0;
}
function cE(n) {
  const e = vs(n) ? fE : fs(n) || gl(n) ? BE : pE,
    t = new Proxy(n, e);
  return ny.set(n, t), ny.set(t, t), t;
}
const pE = {
    get(n, e, t) {
      if (e === Fo) return n;
      const i = Rh();
      return !Nr || kh(n, e) || i == null ? mo(n, e, t) : (i.observe(n, e), xe(mo(n, e, t)));
    },
  },
  fE = {
    get(n, e, t) {
      if (e === Fo) return n;
      if (!Nr || kh(n, e) || Ae == null) return mo(n, e, t);
      switch (e) {
        case 'length':
          return Ae.observe(n, 'length'), n.length;
        case 'map':
          return yE;
        case 'includes':
          return bE;
        case 'indexOf':
          return gE;
        case 'lastIndexOf':
          return vE;
        case 'every':
          return hE;
        case 'filter':
          return mE;
        case 'find':
          return TE;
        case 'findIndex':
          return xE;
        case 'flat':
          return wE;
        case 'flatMap':
          return AE;
        case 'join':
          return EE;
        case 'push':
          return CE;
        case 'pop':
          return SE;
        case 'reduce':
          return NE;
        case 'reduceRight':
          return DE;
        case 'reverse':
          return IE;
        case 'shift':
          return ME;
        case 'unshift':
          return _E;
        case 'slice':
          return PE;
        case 'splice':
          return RE;
        case 'some':
          return OE;
        case 'sort':
          return kE;
        case 'keys':
          return r1;
        case 'values':
        case Symbol.iterator:
          return iy;
        case 'entries':
          return ry;
      }
      return Ae.observe(n, e), xe(mo(n, e, t));
    },
    ownKeys(n) {
      return Rh()?.observe(n, 'length'), Reflect.ownKeys(n);
    },
  };
function yE(n, e) {
  const t = ke(this),
    i = t.map((r, s) => Rn(n.call(e, xe(r), s, this)));
  return Rt(Ae, t), xe(i);
}
function hE(n, e) {
  const t = ke(this),
    i = t.every((r, s) => n.call(e, xe(r), s, this));
  return Rt(Ae, t), i;
}
function mE(n, e) {
  const t = ke(this),
    i = t.filter((r, s) => Rn(n.call(e, xe(r), s, this)));
  return Rt(Ae, t), xe(i);
}
function bE(n) {
  const e = ke(this),
    t = e.includes(Rn(n));
  return Rt(Ae, e), t;
}
function gE(n) {
  const e = ke(this),
    t = e.indexOf(Rn(n));
  return Rt(Ae, e), t;
}
function vE(n) {
  const e = ke(this),
    t = e.lastIndexOf(Rn(n));
  return Rt(Ae, e), t;
}
function xE(n, e) {
  const t = ke(this),
    i = t.findIndex((r, s) => Rn(n.call(e, xe(r), s, this)));
  return Rt(Ae, t), i;
}
function TE(n, e) {
  const t = ke(this),
    i = t.find((r, s) => n(xe(r), s, this), e);
  return Rt(Ae, t), xe(i);
}
function wE() {
  const n = ke(this);
  return Rt(Ae, n), xe(n.flat());
}
function AE(n, e) {
  const t = ke(this);
  return Rt(Ae, t), qc(t.flatMap((i, r) => xe(n.call(e, xe(i), r, this))));
}
function EE(n) {
  const e = ke(this);
  return Rt(Ae, e), e.join(n);
}
function SE() {
  return xe(ke(this).pop());
}
function CE(...n) {
  return ke(this).push(...n);
}
function ME() {
  return xe(ke(this).shift());
}
function _E(...n) {
  return ke(this).unshift(...n);
}
function RE(...n) {
  return xe(ke(this).splice(...n));
}
function IE(...n) {
  const e = ke(this),
    t = e.reverse();
  return Rt(Ae, e), xe(t);
}
function OE(n, e) {
  const t = ke(this),
    i = t.some((r, s) => Rn(n.call(e, xe(r), s, this)));
  return Rt(Ae, t), i;
}
function kE(n) {
  const e = ke(this),
    t = e.sort(n);
  return Rt(Ae, e), xe(t);
}
function PE(n, e) {
  const t = ke(this);
  return Rt(Ae, t), qc(t.slice(n, e));
}
function NE(n, e) {
  const t = ke(this),
    i = t.reduce((r, s, a) => n(r, xe(s), a, this), e);
  return Rt(Ae, t), xe(i);
}
function DE(n, e) {
  const t = ke(this),
    i = t.reduceRight((r, s, a) => n(r, xe(s), a, this), e);
  return Rt(Ae, t), xe(i);
}
const BE = {
  get(n, e, t) {
    if (e === Fo) return n;
    const i = Rh();
    if (!Nr || kh(n, e) || i == null) return mo(n, e, t);
    switch (e) {
      case 'size':
        return i.observe(n, 'size'), n.size;
      case 'clear':
        return VE;
      case 'delete':
        return zE;
      case 'forEach':
        return FE;
      case 'add':
        if (gl(n)) return jE;
        break;
      case 'get':
        if (fs(n)) return $E;
        break;
      case 'set':
        if (fs(n)) return UE;
        break;
      case 'has':
        return LE;
      case 'keys':
        return r1;
      case 'values':
        return iy;
      case 'entries':
        return ry;
      case Symbol.iterator:
        return fs(n) ? ry : iy;
    }
    return xe(mo(n, e, t));
  },
};
function FE(n, e) {
  const t = ke(this);
  return (
    Rt(Ae, t),
    t.forEach((i, r) => {
      n.call(e, xe(i), xe(r), this);
    })
  );
}
function LE(n) {
  const e = ke(this);
  return Rt(Ae, e), e.has(Rn(n));
}
function $E(n) {
  const e = ke(this);
  return Rt(Ae, e), xe(e.get(Rn(n)));
}
function UE(n, e) {
  return xe(ke(this).set(Rn(n), Rn(e)));
}
function jE(n) {
  return xe(ke(this).add(Rn(n)));
}
function VE() {
  return xe(ke(this).clear());
}
function zE(n) {
  return xe(ke(this).delete(Rn(n)));
}
function r1() {
  const n = ke(this);
  Rt(Ae, n);
  const e = n.keys();
  return {
    next() {
      const t = e.next(),
        i = t.value,
        r = t.done;
      return r
        ? {
            value: void 0,
            done: r,
          }
        : {
            value: xe(i),
            done: r,
          };
    },
    [Symbol.iterator]() {
      return this;
    },
  };
}
function iy() {
  const n = ke(this);
  Rt(Ae, n);
  const e = n.values();
  return {
    next() {
      const t = e.next(),
        i = t.value,
        r = t.done;
      return r
        ? {
            value: void 0,
            done: r,
          }
        : {
            value: xe(i),
            done: r,
          };
    },
    [Symbol.iterator]() {
      return this;
    },
  };
}
function ry() {
  const n = ke(this);
  Rt(Ae, n);
  const e = n.entries();
  return {
    next() {
      const t = e.next(),
        i = t.value,
        r = t.done;
      return r
        ? {
            value: void 0,
            done: r,
          }
        : {
            value: [xe(i[0]), xe(i[1])],
            done: r,
          };
    },
    [Symbol.iterator]() {
      return this;
    },
  };
}
const Rt = (n, e) => n?.observeCollection(e),
  GE = Object.freeze({
    getProxy: qc,
    getRaw: ke,
    wrap: xe,
    unwrap: Rn,
    rawKey: Fo,
  });
class xl {
  static create(e, t, i, r, s) {
    const a = i.get,
      o = i.set,
      u = new xl(e, a, o, s, r);
    return (
      yi(e, t, {
        enumerable: i.enumerable,
        configurable: !0,
        get: _x(() => u.getValue(), {
          getObserver: () => u,
        }),
        set: (l) => {
          u.setValue(l);
        },
      }),
      u
    );
  }
  constructor(e, t, i, r, s) {
    (this.type = 1), (this.v = void 0), (this.ov = void 0), (this.ir = !1), (this.D = !1), (this.o = e), (this.$get = t), (this.$set = i), (this.up = r), (this.oL = s);
  }
  getValue() {
    return this.subs.count === 0 ? this.$get.call(this.o, this) : (this.D && (this.compute(), (this.D = !1)), this.v);
  }
  setValue(e) {
    if (li(this.$set)) e !== this.v && ((this.ir = !0), this.$set.call(this.o, e), (this.ir = !1), this.run());
    else throw ae('AUR0221');
  }
  handleChange() {
    (this.D = !0), this.subs.count > 0 && this.run();
  }
  handleCollectionChange() {
    (this.D = !0), this.subs.count > 0 && this.run();
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.compute(), (this.D = !1));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && ((this.D = !0), this.obs.clearAll());
  }
  run() {
    if (this.ir) return;
    const e = this.v,
      t = this.compute();
    (this.D = !1), vh(t, e) || ((this.ov = e), (ab = this.ov), (this.ov = this.v), this.subs.notify(this.v, ab));
  }
  compute() {
    (this.ir = !0), this.obs.version++;
    try {
      return Ih(this), (this.v = Rn(this.$get.call(this.up ? xe(this.o) : this.o, this)));
    } finally {
      this.obs.clear(), (this.ir = !1), Oh(this);
    }
  }
}
Fi(xl);
Gn(xl);
let ab;
const s1 = No('IDirtyChecker', (n) => n.singleton(a1)),
  qE = {
    timeoutsPerCheck: 25,
    disabled: !1,
    throw: !1,
    resetToDefault() {
      (this.timeoutsPerCheck = 6), (this.disabled = !1), (this.throw = !1);
    },
  },
  HE = {
    persistent: !0,
  };
class a1 {
  constructor(e) {
    (this.p = e),
      (this.tracked = []),
      (this.A = null),
      (this.C = 0),
      (this.check = () => {
        if (++this.C < qE.timeoutsPerCheck) return;
        this.C = 0;
        const t = this.tracked,
          i = t.length;
        let r,
          s = 0;
        for (; s < i; ++s) (r = t[s]), r.isDirty() && r.flush();
      });
  }
  createProperty(e, t) {
    return new o1(this, e, t);
  }
  addProperty(e) {
    this.tracked.push(e), this.tracked.length === 1 && (this.A = this.p.taskQueue.queueTask(this.check, HE));
  }
  removeProperty(e) {
    this.tracked.splice(this.tracked.indexOf(e), 1), this.tracked.length === 0 && (this.A.cancel(), (this.A = null));
  }
}
a1.inject = [bl];
class o1 {
  constructor(e, t, i) {
    (this.obj = t), (this.key = i), (this.type = 0), (this.ov = void 0), (this.O = e);
  }
  getValue() {
    return this.obj[this.key];
  }
  setValue(e) {
    throw ae(`Trying to set value for property ${vl(this.key)} in dirty checker`);
  }
  isDirty() {
    return this.ov !== this.obj[this.key];
  }
  flush() {
    const e = this.ov,
      t = this.getValue();
    (this.ov = t), this.subs.notify(t, e);
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && ((this.ov = this.obj[this.key]), this.O.addProperty(this));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && this.O.removeProperty(this);
  }
}
Gn(o1);
class KE {
  get doNotCache() {
    return !0;
  }
  constructor(e, t) {
    (this.type = 0), (this.o = e), (this.k = t);
  }
  getValue() {
    return this.o[this.k];
  }
  setValue() {}
  subscribe() {}
  unsubscribe() {}
}
class u1 {
  constructor() {
    this.type = 0;
  }
  getValue(e, t) {
    return e[t];
  }
  setValue(e, t, i) {
    t[i] = e;
  }
}
class Ph {
  constructor(e, t) {
    (this.type = 1), (this.v = void 0), (this.iO = !1), (this.o = e), (this.k = t);
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    if (this.iO) {
      if (vh(e, this.v)) return;
      (Jd = this.v), (this.v = e), this.subs.notify(e, Jd);
    } else this.o[this.k] = e;
  }
  subscribe(e) {
    this.iO === !1 && this.start(), this.subs.add(e);
  }
  start() {
    return (
      this.iO === !1 &&
        ((this.iO = !0),
        (this.v = this.o[this.k]),
        yi(this.o, this.k, {
          enumerable: !0,
          configurable: !0,
          get: () => this.getValue(),
          set: (e) => {
            this.setValue(e);
          },
        })),
      this
    );
  }
  stop() {
    return (
      this.iO &&
        (yi(this.o, this.k, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: this.v,
        }),
        (this.iO = !1)),
      this
    );
  }
}
class WE {
  constructor(e, t, i, r) {
    (this.type = 1), (this.v = void 0), (this.ov = void 0), (this.o = e), (this.S = i), (this.hs = li(i));
    const s = e[t];
    (this.cb = li(s) ? s : void 0), (this.v = r);
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.hs && (e = this.S(e, null)), vh(e, this.v) || ((this.ov = this.v), (this.v = e), this.cb?.call(this.o, this.v, this.ov), (Jd = this.ov), (this.ov = this.v), this.subs.notify(this.v, Jd));
  }
}
Gn(Ph);
Gn(WE);
let Jd;
const sy = new u1(),
  Ra = No('IObserverLocator', (n) => n.singleton(l1)),
  Qd = No('INodeObserverLocator', (n) => n.cachedCallback((e) => new JE()));
class JE {
  handles() {
    return !1;
  }
  getObserver() {
    return sy;
  }
  getAccessor() {
    return sy;
  }
}
class l1 {
  constructor(e, t) {
    (this.R = []), (this.O = e), (this.T = t);
  }
  addAdapter(e) {
    this.R.push(e);
  }
  getObserver(e, t) {
    if (e == null) throw YE(t);
    if (!bu(e)) return new KE(e, t);
    const i = d1(e);
    let r = i[t];
    return r === void 0 && ((r = this.createObserver(e, t)), r.doNotCache || (i[t] = r)), r;
  }
  getAccessor(e, t) {
    const i = e.$observers?.[t];
    return i !== void 0 ? i : this.T.handles(e, t, this) ? this.T.getAccessor(e, t, this) : sy;
  }
  getArrayObserver(e) {
    return vu(e);
  }
  getMapObserver(e) {
    return Wd(e);
  }
  getSetObserver(e) {
    return Kd(e);
  }
  createObserver(e, t) {
    if (this.T.handles(e, t, this)) return this.T.getObserver(e, t, this);
    switch (t) {
      case 'length':
        if (vs(e)) return vu(e).getLengthObserver();
        break;
      case 'size':
        if (fs(e)) return Wd(e).getLengthObserver();
        if (gl(e)) return Kd(e).getLengthObserver();
        break;
      default:
        if (vs(e) && Fu(t)) return vu(e).getIndexObserver(Number(t));
        break;
    }
    let i = ub(e, t);
    if (i === void 0) {
      let r = ob(e);
      for (; r !== null && ((i = ub(r, t)), i === void 0); ) r = ob(r);
    }
    if (i !== void 0 && !V3.call(i, 'value')) {
      let r = this.P(e, t, i);
      return r == null && (r = (i.get?.getObserver ?? i.set?.getObserver)?.(e, this)), r ?? (i.configurable ? xl.create(e, t, i, this, !0) : this.O.createProperty(e, t));
    }
    return new Ph(e, t);
  }
  P(e, t, i) {
    if (this.R.length > 0)
      for (const r of this.R) {
        const s = r.getObserver(e, t, i, this);
        if (s != null) return s;
      }
    return null;
  }
}
l1.inject = [s1, Qd];
const QE = (n) => {
    let e;
    return vs(n) ? (e = vu(n)) : fs(n) ? (e = Wd(n)) : gl(n) && (e = Kd(n)), e;
  },
  ob = Object.getPrototypeOf,
  ub = Object.getOwnPropertyDescriptor,
  d1 = (n) => {
    let e = n.$observers;
    return (
      e === void 0 &&
        yi(n, '$observers', {
          enumerable: !1,
          value: (e = gu()),
        }),
      e
    );
  },
  YE = (n) => ae(`AUR0199:${vl(n)}`);
No('IObservation', (n) => n.singleton(XE));
class XE {
  static get inject() {
    return [Ra];
  }
  constructor(e) {
    this.oL = e;
  }
  run(e) {
    const t = new c1(this.oL, e);
    return t.run(), t;
  }
}
class c1 {
  constructor(e, t) {
    (this.oL = e), (this.fn = t), (this.maxRunCount = 10), (this.queued = !1), (this.running = !1), (this.runCount = 0), (this.stopped = !1);
  }
  handleChange() {
    (this.queued = !0), this.run();
  }
  handleCollectionChange() {
    (this.queued = !0), this.run();
  }
  run() {
    if (this.stopped) throw ae('AUR0225');
    if (!this.running) {
      ++this.runCount, (this.running = !0), (this.queued = !1), ++this.obs.version;
      try {
        Ih(this), this.fn(this);
      } finally {
        this.obs.clear(), (this.running = !1), Oh(this);
      }
      if (this.queued) {
        if (this.runCount > this.maxRunCount) throw ((this.runCount = 0), ae('AUR0226'));
        this.run();
      } else this.runCount = 0;
    }
  }
  stop() {
    (this.stopped = !0), this.obs.clearAll();
  }
}
Fi(c1);
function ZE(n, e) {
  if (n == null) return (i, r) => t(i, r);
  return t(n, e);
  function t(i, r) {
    !r ? kr(i, t1, !0) : kr(i.constructor, `${n1}_${vl(r)}__`, !0);
  }
}
const Hc = No('ISignaler', (n) => n.singleton(e4));
class e4 {
  constructor() {
    this.signals = gu();
  }
  dispatchSignal(e) {
    const t = this.signals[e];
    if (t === void 0) return;
    let i;
    for (i of t.keys()) i.handleChange(void 0, void 0);
  }
  addSignalListener(e, t) {
    const i = this.signals,
      r = i[e];
    r === void 0 ? (i[e] = /* @__PURE__ */ new Set([t])) : r.add(t);
  }
  removeSignalListener(e, t) {
    this.signals[e]?.delete(t);
  }
}
class t4 extends Error {
  constructor(e) {
    super('Task was canceled.'), (this.task = e);
  }
}
var lb;
(function (n) {
  (n[(n.pending = 0)] = 'pending'), (n[(n.running = 1)] = 'running'), (n[(n.completed = 2)] = 'completed'), (n[(n.canceled = 3)] = 'canceled');
})(lb || (lb = {}));
var db;
(function (n) {
  (n[(n.render = 0)] = 'render'), (n[(n.macroTask = 1)] = 'macroTask'), (n[(n.postRender = 2)] = 'postRender');
})(db || (db = {}));
function Z(n, e, t, i) {
  var r = arguments.length,
    s = r < 3 ? e : i === null ? (i = Object.getOwnPropertyDescriptor(e, t)) : i,
    a;
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') s = Reflect.decorate(n, e, t, i);
  else for (var o = n.length - 1; o >= 0; o--) (a = n[o]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}
function Tn(n, e) {
  return function (t, i) {
    e(t, i, n);
  };
}
const In = ur.getOwn,
  Tl = ur.hasOwn,
  Nt = ur.define,
  { annotation: Nh, resource: p1 } = ko,
  kn = Nh.keyFor,
  Ia = p1.keyFor,
  Oa = p1.appendTo,
  Dh = Nh.appendTo,
  n4 = Nh.getKeys,
  Cs = Object,
  Lo = String,
  Bh = Cs.prototype,
  Jn = () => Cs.create(null),
  se = (n) => new Error(n),
  ys = Bh.hasOwnProperty,
  Vr = Cs.freeze,
  Fh = Cs.assign,
  f1 = Cs.getOwnPropertyNames,
  y1 = Cs.keys,
  cb = Jn(),
  pb = (n, e, t) => {
    if (cb[e] === !0) return !0;
    if (!Et(e)) return !1;
    const i = e.slice(0, 5);
    return (cb[e] = i === 'aria-' || i === 'data-' || t.isStandardSvgAttribute(n, e));
  },
  un = (n) => n instanceof Promise,
  tr = (n) => n instanceof Array,
  ei = (n) => typeof n == 'function',
  Et = (n) => typeof n == 'string',
  i4 = Cs.defineProperty,
  Yd = (n) => {
    throw n;
  },
  wl = Cs.is,
  ay = Reflect.defineProperty,
  Ii = (n, e, t) => (
    ay(n, e, {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: t,
    }),
    t
  ),
  h1 = (n, e, t) => n.addSignalListener(e, t),
  m1 = (n, e, t) => n.removeSignalListener(e, t);
function Ue(n, e) {
  let t;
  function i(r, s) {
    arguments.length > 1 && (t.property = s), Nt(os, ls.create(s, r, t), r.constructor, s), Dh(r.constructor, Tr.keyFrom(s));
  }
  if (arguments.length > 1) {
    (t = {}), i(n, e);
    return;
  } else if (Et(n)) return (t = {}), i;
  return (t = n === void 0 ? {} : n), i;
}
function r4(n) {
  return n.startsWith(os);
}
const os = kn('bindable'),
  Tr = Vr({
    name: os,
    keyFrom: (n) => `${os}:${n}`,
    from(n, ...e) {
      const t = {},
        i = Array.isArray;
      function r(o) {
        t[o] = ls.create(o, n);
      }
      function s(o, u) {
        t[o] = u instanceof ls ? u : ls.create(o, n, u);
      }
      function a(o) {
        i(o) ? o.forEach(r) : o instanceof ls ? (t[o.property] = o) : o !== void 0 && y1(o).forEach((u) => s(u, o[u]));
      }
      return e.forEach(a), t;
    },
    for(n) {
      let e;
      const t = {
        add(i) {
          let r, s;
          return (
            Et(i)
              ? ((r = i),
                (s = {
                  property: r,
                }))
              : ((r = i.property), (s = i)),
            (e = ls.create(r, n, s)),
            Tl(os, n, r) || Dh(n, Tr.keyFrom(r)),
            Nt(os, e, n, r),
            t
          );
        },
        mode(i) {
          return (e.mode = i), t;
        },
        callback(i) {
          return (e.callback = i), t;
        },
        attribute(i) {
          return (e.attribute = i), t;
        },
        primary() {
          return (e.primary = !0), t;
        },
        set(i) {
          return (e.set = i), t;
        },
      };
      return t;
    },
    getAll(n) {
      const e = os.length + 1,
        t = [],
        i = Y5(n);
      let r = i.length,
        s = 0,
        a,
        o,
        u,
        l;
      for (; --r >= 0; ) for (u = i[r], a = n4(u).filter(r4), o = a.length, l = 0; l < o; ++l) t[s++] = In(os, u, a[l].slice(e));
      return t;
    },
  });
class ls {
  constructor(e, t, i, r, s, a) {
    (this.attribute = e), (this.callback = t), (this.mode = i), (this.primary = r), (this.property = s), (this.set = a);
  }
  static create(e, t, i = {}) {
    return new ls(Ln(i.attribute, bx(e)), Ln(i.callback, `${e}Changed`), Ln(i.mode, 2), Ln(i.primary, !1), Ln(i.property, e), Ln(i.set, s4(e, t, i)));
  }
}
const oy = {
  key: kn('coercer'),
  define(n, e) {
    Nt(oy.key, n[e].bind(n), n);
  },
  for(n) {
    return In(oy.key, n);
  },
};
function s4(n, e, t = {}) {
  const i = t.type ?? ur.get('design:type', e, n) ?? null;
  if (i == null) return Mr;
  let r;
  switch (i) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
      r = i;
      break;
    default: {
      const s = i.coerce;
      r = typeof s == 'function' ? s.bind(i) : oy.for(i) ?? Mr;
      break;
    }
  }
  return r === Mr ? r : a4(r, t.nullable);
}
function a4(n, e) {
  return function (t, i) {
    return i?.enableCoercion ? ((e ?? !(i?.coerceNullish ?? !1)) && t == null ? t : n(t, i)) : t;
  };
}
class b1 {
  get type() {
    return 1;
  }
  constructor(e, t, i, r, s, a) {
    (this.set = r), (this.$controller = s), (this.i = a), (this.v = void 0), (this.ov = void 0);
    const o = e[i],
      u = e.propertyChanged,
      l = (this.u = ei(o)),
      c = (this.A = ei(u)),
      f = (this.hs = r !== Mr);
    let m;
    (this.o = e),
      (this.k = t),
      (this.C = c ? u : Mr),
      (this.cb = l ? o : Mr),
      this.cb === void 0 && !c && !f ? (this.iO = !1) : ((this.iO = !0), (m = e[t]), (this.v = f && m !== void 0 ? r(m, this.i) : m), this.R());
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.hs && (e = this.set(e, this.i));
    const t = this.v;
    if (this.iO) {
      if (wl(e, t)) return;
      (this.v = e),
        (this.ov = t),
        (this.$controller == null || this.$controller.isBound) && (this.u && this.cb.call(this.o, e, t), this.A && this.C.call(this.o, this.k, e, t)),
        this.subs.notify(this.v, this.ov);
    } else this.o[this.k] = e;
  }
  subscribe(e) {
    this.iO && ((this.iO = !0), (this.v = this.hs ? this.set(this.o[this.k], this.i) : this.o[this.k]), this.R()), this.subs.add(e);
  }
  R() {
    Reflect.defineProperty(this.o, this.k, {
      enumerable: !0,
      configurable: !0,
      get: () => this.v,
      set: (e) => {
        this.setValue(e);
      },
    });
  }
}
Gn(b1);
const fb = function (n) {
    function e(t, i, r) {
      be.inject(e)(t, i, r);
    }
    return (
      (e.$isResolver = !0),
      (e.resolve = function (t, i) {
        return i.root === i || i.has(n, !1) ? i.get(n) : i.root.get(n);
      }),
      e
    );
  },
  Ut = be.createInterface,
  $o = me.singleton,
  Al = me.aliasTo,
  g1 = me.transient,
  St = (n, e, t) => n.registerResolver(e, t);
function o4(...n) {
  return function (e) {
    const t = kn('aliases'),
      i = In(t, e);
    i === void 0 ? Nt(t, n, e) : i.push(...n);
  };
}
function El(n, e, t, i) {
  for (let r = 0, s = n.length; r < s; ++r) me.aliasTo(t, e.keyFrom(n[r])).register(i);
}
function Hn(n) {
  return function (e) {
    return Xd.define(n, e);
  };
}
class Lh {
  constructor(e, t, i, r) {
    (this.Type = e), (this.name = t), (this.aliases = i), (this.key = r);
  }
  static create(e, t) {
    let i, r;
    return (
      Et(e)
        ? ((i = e),
          (r = {
            name: i,
          }))
        : ((i = e.name), (r = e)),
      new Lh(t, Ln(uy(t, 'name'), i), Vt(uy(t, 'aliases'), r.aliases, t.aliases), Xd.keyFrom(i))
    );
  }
  register(e) {
    const { Type: t, key: i, aliases: r } = this;
    $o(i, t).register(e), Al(i, t).register(e), El(r, Xd, i, e);
  }
}
const Ws = Ia('binding-behavior'),
  uy = (n, e) => In(kn(e), n),
  Xd = Vr({
    name: Ws,
    keyFrom(n) {
      return `${Ws}:${n}`;
    },
    isType(n) {
      return ei(n) && Tl(Ws, n);
    },
    define(n, e) {
      const t = Lh.create(n, e);
      return Nt(Ws, t, t.Type), Nt(Ws, t, t), Oa(e, Ws), t.Type;
    },
    getDefinition(n) {
      const e = In(Ws, n);
      if (e === void 0) throw se(`AUR0151:${n.name}`);
      return e;
    },
    annotate(n, e, t) {
      Nt(kn(e), t, n);
    },
    getAnnotation: uy,
  }),
  Yp = /* @__PURE__ */ new Map();
class Kc {
  bind(e, t) {
    Yp.set(t, t.mode), (t.mode = this.mode);
  }
  unbind(e, t) {
    (t.mode = Yp.get(t)), Yp.delete(t);
  }
}
class u4 extends Kc {
  get mode() {
    return 1;
  }
}
class l4 extends Kc {
  get mode() {
    return 2;
  }
}
class d4 extends Kc {
  get mode() {
    return 4;
  }
}
class c4 extends Kc {
  get mode() {
    return 6;
  }
}
Hn('oneTime')(u4);
Hn('toView')(l4);
Hn('fromView')(d4);
Hn('twoWay')(c4);
const Xp = /* @__PURE__ */ new WeakMap(),
  p4 = 200;
class v1 {
  constructor(e) {
    this.p = e;
  }
  bind(e, t, i, r) {
    const s = {
        type: 'debounce',
        delay: i ?? p4,
        now: this.p.performanceNow,
        queue: this.p.taskQueue,
        signals: Et(r) ? [r] : r ?? je,
      },
      a = t.limit?.(s);
    a == null || Xp.set(t, a);
  }
  unbind(e, t) {
    Xp.get(t)?.dispose(), Xp.delete(t);
  }
}
v1.inject = [bl];
Hn('debounce')(v1);
class x1 {
  constructor(e) {
    (this.B = /* @__PURE__ */ new Map()), (this._ = e);
  }
  bind(e, t, ...i) {
    if (!('handleChange' in t)) throw se('AUR0817');
    if (i.length === 0) throw se('AUR0818');
    this.B.set(t, i);
    let r;
    for (r of i) h1(this._, r, t);
  }
  unbind(e, t) {
    const i = this.B.get(t);
    this.B.delete(t);
    let r;
    for (r of i) m1(this._, r, t);
  }
}
x1.inject = [Hc];
Hn('signal')(x1);
const Zp = /* @__PURE__ */ new WeakMap(),
  f4 = 200;
class T1 {
  constructor(e) {
    (this.I = e.performanceNow), (this.T = e.taskQueue);
  }
  bind(e, t, i, r) {
    const s = {
        type: 'throttle',
        delay: i ?? f4,
        now: this.I,
        queue: this.T,
        signals: Et(r) ? [r] : r ?? je,
      },
      a = t.limit?.(s);
    a == null || Zp.set(t, a);
  }
  unbind(e, t) {
    Zp.get(t)?.dispose(), Zp.delete(t);
  }
}
T1.inject = [bl];
Hn('throttle')(T1);
const zr = bl;
function w1(n) {
  return function (e) {
    return jh(n, e);
  };
}
function bi(n) {
  return function (e) {
    return jh(
      Et(n)
        ? {
            isTemplateController: !0,
            name: n,
          }
        : {
            isTemplateController: !0,
            ...n,
          },
      e,
    );
  };
}
class $h {
  get type() {
    return 2;
  }
  constructor(e, t, i, r, s, a, o, u, l, c) {
    (this.Type = e),
      (this.name = t),
      (this.aliases = i),
      (this.key = r),
      (this.defaultBindingMode = s),
      (this.isTemplateController = a),
      (this.bindables = o),
      (this.noMultiBindings = u),
      (this.watches = l),
      (this.dependencies = c);
  }
  static create(e, t) {
    let i, r;
    return (
      Et(e)
        ? ((i = e),
          (r = {
            name: i,
          }))
        : ((i = e.name), (r = e)),
      new $h(
        t,
        Ln(rs(t, 'name'), i),
        Vt(rs(t, 'aliases'), r.aliases, t.aliases),
        Uh(i),
        Ln(rs(t, 'defaultBindingMode'), r.defaultBindingMode, t.defaultBindingMode, 2),
        Ln(rs(t, 'isTemplateController'), r.isTemplateController, t.isTemplateController, !1),
        Tr.from(t, ...Tr.getAll(t), rs(t, 'bindables'), t.bindables, r.bindables),
        Ln(rs(t, 'noMultiBindings'), r.noMultiBindings, t.noMultiBindings, !1),
        Vt(dy.getAnnotation(t), t.watches),
        Vt(rs(t, 'dependencies'), r.dependencies, t.dependencies),
      )
    );
  }
  register(e) {
    const { Type: t, key: i, aliases: r } = this;
    g1(i, t).register(e), Al(i, t).register(e), El(r, Vh, i, e);
  }
}
const aa = Ia('custom-attribute'),
  Uh = (n) => `${aa}:${n}`,
  rs = (n, e) => In(kn(e), n),
  y4 = (n) => ei(n) && Tl(aa, n),
  A1 = (n, e) => cu(n, Uh(e)) ?? void 0,
  jh = (n, e) => {
    const t = $h.create(n, e);
    return Nt(aa, t, t.Type), Nt(aa, t, t), Oa(e, aa), t.Type;
  },
  ly = (n) => {
    const e = In(aa, n);
    if (e === void 0) throw se(`AUR0759:${n.name}`);
    return e;
  },
  Vh = Vr({
    name: aa,
    keyFrom: Uh,
    isType: y4,
    for: A1,
    define: jh,
    getDefinition: ly,
    annotate(n, e, t) {
      Nt(kn(e), t, n);
    },
    getAnnotation: rs,
  }),
  h4 = je,
  Yl = kn('watch'),
  dy = Vr({
    name: Yl,
    add(n, e) {
      let t = In(Yl, n);
      t == null && Nt(Yl, (t = []), n), t.push(e);
    },
    getAnnotation(n) {
      return In(Yl, n) ?? h4;
    },
  });
function E1(n) {
  return function (e) {
    return S1(n, e);
  };
}
const ef = /* @__PURE__ */ new WeakMap();
class qi {
  get type() {
    return 1;
  }
  constructor(e, t, i, r, s, a, o, u, l, c, f, m, w, v, T, A, _, O, B, P) {
    (this.Type = e),
      (this.name = t),
      (this.aliases = i),
      (this.key = r),
      (this.cache = s),
      (this.capture = a),
      (this.template = o),
      (this.instructions = u),
      (this.dependencies = l),
      (this.injectable = c),
      (this.needsCompile = f),
      (this.surrogates = m),
      (this.bindables = w),
      (this.containerless = v),
      (this.isStrictBinding = T),
      (this.shadowOptions = A),
      (this.hasSlots = _),
      (this.enhance = O),
      (this.watches = B),
      (this.processContent = P);
  }
  static create(e, t = null) {
    if (t === null) {
      const r = e;
      if (Et(r)) throw se(`AUR0761:${e}`);
      const s = Nn('name', r, cy);
      return (
        ei(r.Type) ? (t = r.Type) : (t = C1(Q5(s))),
        new qi(
          t,
          s,
          Vt(r.aliases),
          Nn('key', r, () => Ad(s)),
          Nn('cache', r, tf),
          Nn('capture', r, An),
          Nn('template', r, si),
          Vt(r.instructions),
          Vt(r.dependencies),
          Nn('injectable', r, si),
          Nn('needsCompile', r, nf),
          Vt(r.surrogates),
          Tr.from(t, r.bindables),
          Nn('containerless', r, An),
          Nn('isStrictBinding', r, An),
          Nn('shadowOptions', r, si),
          Nn('hasSlots', r, An),
          Nn('enhance', r, An),
          Nn('watches', r, b4),
          ri('processContent', t, si),
        )
      );
    }
    if (Et(e))
      return new qi(
        t,
        e,
        Vt(Ei(t, 'aliases'), t.aliases),
        Ad(e),
        ri('cache', t, tf),
        ri('capture', t, An),
        ri('template', t, si),
        Vt(Ei(t, 'instructions'), t.instructions),
        Vt(Ei(t, 'dependencies'), t.dependencies),
        ri('injectable', t, si),
        ri('needsCompile', t, nf),
        Vt(Ei(t, 'surrogates'), t.surrogates),
        Tr.from(t, ...Tr.getAll(t), Ei(t, 'bindables'), t.bindables),
        ri('containerless', t, An),
        ri('isStrictBinding', t, An),
        ri('shadowOptions', t, si),
        ri('hasSlots', t, An),
        ri('enhance', t, An),
        Vt(dy.getAnnotation(t), t.watches),
        ri('processContent', t, si),
      );
    const i = Nn('name', e, cy);
    return new qi(
      t,
      i,
      Vt(Ei(t, 'aliases'), e.aliases, t.aliases),
      Ad(i),
      xi('cache', e, t, tf),
      xi('capture', e, t, An),
      xi('template', e, t, si),
      Vt(Ei(t, 'instructions'), e.instructions, t.instructions),
      Vt(Ei(t, 'dependencies'), e.dependencies, t.dependencies),
      xi('injectable', e, t, si),
      xi('needsCompile', e, t, nf),
      Vt(Ei(t, 'surrogates'), e.surrogates, t.surrogates),
      Tr.from(t, ...Tr.getAll(t), Ei(t, 'bindables'), t.bindables, e.bindables),
      xi('containerless', e, t, An),
      xi('isStrictBinding', e, t, An),
      xi('shadowOptions', e, t, si),
      xi('hasSlots', e, t, An),
      xi('enhance', e, t, An),
      Vt(e.watches, dy.getAnnotation(t), t.watches),
      xi('processContent', e, t, si),
    );
  }
  static getOrCreate(e) {
    if (e instanceof qi) return e;
    if (ef.has(e)) return ef.get(e);
    const t = qi.create(e);
    return ef.set(e, t), Nt(en, t, t.Type), t;
  }
  register(e) {
    const { Type: t, key: i, aliases: r } = this;
    e.has(i, !1) || (g1(i, t).register(e), Al(i, t).register(e), El(r, lo, i, e));
  }
}
const m4 = {
    name: void 0,
    searchParents: !1,
    optional: !1,
  },
  tf = () => 0,
  si = () => null,
  An = () => !1,
  nf = () => !0,
  b4 = () => je,
  en = Ia('custom-element'),
  Ad = (n) => `${en}:${n}`,
  cy = (() => {
    let n = 0;
    return () => `unnamed-${++n}`;
  })(),
  g4 = (n, e, t) => {
    Nt(kn(e), t, n);
  },
  S1 = (n, e) => {
    const t = qi.create(n, e);
    return Nt(en, t, t.Type), Nt(en, t, t), Oa(t.Type, en), t.Type;
  },
  v4 = (n) => ei(n) && Tl(en, n),
  oa = (n, e = m4) => {
    if (e.name === void 0 && e.searchParents !== !0) {
      const i = cu(n, en);
      if (i === null) {
        if (e.optional === !0) return null;
        throw se('AUR0762');
      }
      return i;
    }
    if (e.name !== void 0) {
      if (e.searchParents !== !0) {
        const s = cu(n, en);
        if (s === null) throw se('AUR0763');
        return s.is(e.name) ? s : void 0;
      }
      let i = n,
        r = !1;
      for (; i !== null; ) {
        const s = cu(i, en);
        if (s !== null && ((r = !0), s.is(e.name))) return s;
        i = fy(i);
      }
      if (r) return;
      throw se('AUR0764');
    }
    let t = n;
    for (; t !== null; ) {
      const i = cu(t, en);
      if (i !== null) return i;
      t = fy(t);
    }
    throw se('AUR0765');
  },
  Ei = (n, e) => In(kn(e), n),
  py = (n) => {
    const e = In(en, n);
    if (e === void 0) throw se(`AUR0760:${n.name}`);
    return e;
  },
  x4 = () => {
    const n = function (e, t, i) {
      const r = be.getOrCreateAnnotationParamTypes(e);
      return (r[i] = n), e;
    };
    return (
      (n.register = function (e) {
        return {
          resolve(t, i) {
            return i.has(n, !0) ? i.get(n) : null;
          },
        };
      }),
      n
    );
  },
  C1 = (function () {
    const n = {
        value: '',
        writable: !1,
        enumerable: !1,
        configurable: !0,
      },
      e = {};
    return function (t, i = e) {
      const r = class {};
      return (n.value = t), Reflect.defineProperty(r, 'name', n), i !== e && Fh(r.prototype, i), r;
    };
  })(),
  lo = Vr({
    name: en,
    keyFrom: Ad,
    isType: v4,
    for: oa,
    define: S1,
    getDefinition: py,
    annotate: g4,
    getAnnotation: Ei,
    generateName: cy,
    createInjectable: x4,
    generateType: C1,
  });
kn('processContent');
const T4 = 'au-start',
  w4 = 'au-end',
  yb = (n, e) => n.document.createComment(e),
  A4 = (n) => {
    const e = yb(n, w4);
    return (e.$start = yb(n, T4)), e;
  },
  E4 = (n, e) => n.document.createTextNode(e),
  S4 = (n, e, t) => n.insertBefore(e, t),
  Xl = (n, e, t) => {
    if (n === null) return;
    const i = t.length;
    let r = 0;
    for (; i > r; ) n.insertBefore(t[r], e), ++r;
  },
  C4 = (n) => {
    const e = n.previousSibling;
    let t;
    if (e?.nodeType === 8 && e.textContent === 'au-end') {
      if (((t = e), (t.$start = t.previousSibling) == null)) throw hb();
      return n.parentNode?.removeChild(n), t;
    } else throw hb();
  },
  zh = (n, e) => new n.ownerDocument.defaultView.MutationObserver(e),
  hb = () => se('AURxxxx');
class M4 {}
function cu(n, e) {
  return n.$au?.[e] ?? null;
}
function En(n, e, t) {
  var i;
  ((i = n).$au ?? (i.$au = new M4()))[e] = t;
}
const bo = /* @__PURE__ */ Ut('INode'),
  On = /* @__PURE__ */ Ut('IRenderLocation'),
  mb = /* @__PURE__ */ Ut('CssModules'),
  Zd = /* @__PURE__ */ new WeakMap();
function fy(n) {
  if (Zd.has(n)) return Zd.get(n);
  let e = 0,
    t = n.nextSibling;
  for (; t !== null; ) {
    if (t.nodeType === 8)
      switch (t.textContent) {
        case 'au-start':
          ++e;
          break;
        case 'au-end':
          if (e-- === 0) return t;
      }
    t = t.nextSibling;
  }
  if (n.parentNode === null && n.nodeType === 11) {
    const i = oa(n);
    if (i === void 0) return null;
    if (i.mountTarget === 2) return fy(i.host);
  }
  return n.parentNode;
}
function _4(n, e) {
  if (n.platform !== void 0 && !(n instanceof n.platform.Node)) {
    const t = n.childNodes;
    for (let i = 0, r = t.length; i < r; ++i) Zd.set(t[i], e);
  } else Zd.set(n, e);
}
function Gh(n) {
  if (ec(n)) return n;
  const e = n.ownerDocument.createComment('au-end'),
    t = (e.$start = n.ownerDocument.createComment('au-start')),
    i = n.parentNode;
  return i !== null && (i.replaceChild(e, n), i.insertBefore(t, e)), e;
}
function ec(n) {
  return n.textContent === 'au-end';
}
class rf {
  get firstChild() {
    return this.P;
  }
  get lastChild() {
    return this.L;
  }
  constructor(e, t) {
    (this.platform = e), (this.next = void 0), (this.M = !1), (this.$ = !1), (this.ref = null), (this.f = t);
    const i = t.querySelectorAll('.au');
    let r = 0,
      s = i.length,
      a,
      o = (this.t = Array(s));
    for (; s > r; ) (a = i[r]), a.nodeName === 'AU-M' ? (o[r] = C4(a)) : (o[r] = a), ++r;
    const u = t.childNodes,
      l = (this.childNodes = Array((s = u.length)));
    for (r = 0; s > r; ) (l[r] = u[r]), ++r;
    (this.P = t.firstChild), (this.L = t.lastChild);
  }
  findTargets() {
    return this.t;
  }
  insertBefore(e) {
    if (this.$ && this.ref) this.addToLinked();
    else {
      const t = e.parentNode;
      if (this.M) {
        let i = this.P,
          r;
        const s = this.L;
        for (; i != null && ((r = i.nextSibling), t.insertBefore(i, e), i !== s); ) i = r;
      } else (this.M = !0), e.parentNode.insertBefore(this.f, e);
    }
  }
  appendTo(e, t = !1) {
    if (this.M) {
      let i = this.P,
        r;
      const s = this.L;
      for (; i != null && ((r = i.nextSibling), e.appendChild(i), i !== s); ) i = r;
    } else (this.M = !0), t || e.appendChild(this.f);
  }
  remove() {
    if (this.M) {
      this.M = !1;
      const e = this.f,
        t = this.L;
      let i,
        r = this.P;
      for (; r !== null && ((i = r.nextSibling), e.appendChild(r), r !== t); ) r = i;
    }
  }
  addToLinked() {
    const e = this.ref,
      t = e.parentNode;
    if (this.M) {
      let i = this.P,
        r;
      const s = this.L;
      for (; i != null && ((r = i.nextSibling), t.insertBefore(i, e), i !== s); ) i = r;
    } else (this.M = !0), t.insertBefore(this.f, e);
  }
  unlink() {
    (this.$ = !1), (this.next = void 0), (this.ref = void 0);
  }
  link(e) {
    (this.$ = !0), ec(e) ? (this.ref = e) : ((this.next = e), this.U());
  }
  U() {
    this.next !== void 0 ? (this.ref = this.next.firstChild) : (this.ref = void 0);
  }
}
const bb = (n, e, t, i) => {
    n.addEventListener(e, t, i);
  },
  gb = (n, e, t, i) => {
    n.removeEventListener(e, t, i);
  },
  qh = (n) => {
    let e;
    const t = n.prototype;
    Ii(t, 'subscribe', function (i) {
      if (this.subs.add(i) && this.subs.count === 1) {
        for (e of this.cf.events) bb(this.q, e, this);
        (this.F = !0), this.O?.();
      }
    }),
      Ii(t, 'unsubscribe', function (i) {
        if (this.subs.remove(i) && this.subs.count === 0) {
          for (e of this.cf.events) gb(this.q, e, this);
          (this.F = !1), this.H?.();
        }
      }),
      Ii(t, 'useConfig', function (i) {
        if (((this.cf = i), this.F)) {
          for (e of this.cf.events) gb(this.q, e, this);
          for (e of this.cf.events) bb(this.q, e, this);
        }
      });
  },
  Wc = (n) => {
    Ii(n.prototype, 'subscribe', Mr), Ii(n.prototype, 'unsubscribe', Mr);
  };
class M1 {
  get doNotCache() {
    return !0;
  }
  constructor(e) {
    (this.obj = e), (this.type = 6), (this.value = ''), (this.ov = ''), (this.V = {}), (this.N = 0), (this.j = !1);
  }
  getValue() {
    return this.value;
  }
  setValue(e) {
    (this.value = e), (this.j = e !== this.ov), this.W();
  }
  W() {
    if (this.j) {
      this.j = !1;
      const e = this.value,
        t = this.V,
        i = _1(e);
      let r = this.N;
      if (((this.ov = e), i.length > 0 && this.G(i), (this.N += 1), r === 0)) return;
      r -= 1;
      for (const s in t) !ys.call(t, s) || t[s] !== r || this.obj.classList.remove(s);
    }
  }
  G(e) {
    const t = this.obj,
      i = e.length;
    let r = 0,
      s;
    for (; r < i; r++) (s = e[r]), s.length !== 0 && ((this.V[s] = this.N), t.classList.add(s));
  }
}
function _1(n) {
  if (Et(n)) return vb(n);
  if (typeof n != 'object') return je;
  if (n instanceof Array) {
    const i = n.length;
    if (i > 0) {
      const r = [];
      let s = 0;
      for (; i > s; ++s) r.push(..._1(n[s]));
      return r;
    } else return je;
  }
  const e = [];
  let t;
  for (t in n) n[t] && (t.includes(' ') ? e.push(...vb(t)) : e.push(t));
  return e;
}
function vb(n) {
  const e = n.match(/\S+/g);
  return e === null ? je : e;
}
Wc(M1);
const xb = /* @__PURE__ */ Ut('IShadowDOMStyles'),
  R4 = /* @__PURE__ */ Ut('IShadowDOMGlobalStyles', (n) =>
    n.instance({
      applyTo: Mr,
    }),
  );
function Sl(n) {
  return function (e) {
    return tc.define(n, e);
  };
}
class Hh {
  constructor(e, t, i, r) {
    (this.Type = e), (this.name = t), (this.aliases = i), (this.key = r);
  }
  static create(e, t) {
    let i, r;
    return (
      Et(e)
        ? ((i = e),
          (r = {
            name: i,
          }))
        : ((i = e.name), (r = e)),
      new Hh(t, Ln(yy(t, 'name'), i), Vt(yy(t, 'aliases'), r.aliases, t.aliases), tc.keyFrom(i))
    );
  }
  register(e) {
    const { Type: t, key: i, aliases: r } = this;
    me.singleton(i, t).register(e), me.aliasTo(i, t).register(e), El(r, tc, i, e);
  }
}
const Js = Ia('value-converter'),
  yy = (n, e) => In(kn(e), n),
  tc = Vr({
    name: Js,
    keyFrom: (n) => `${Js}:${n}`,
    isType(n) {
      return ei(n) && Tl(Js, n);
    },
    define(n, e) {
      const t = Hh.create(n, e);
      return Nt(Js, t, t.Type), Nt(Js, t, t), Oa(e, Js), t.Type;
    },
    getDefinition(n) {
      const e = In(Js, n);
      if (e === void 0) throw se(`AUR0152:${n.name}`);
      return e;
    },
    annotate(n, e, t) {
      Nt(kn(e), t, n);
    },
    getAnnotation: yy,
  });
class I4 {
  constructor(e, t) {
    (this.v = void 0), (this.b = e), (this.K = t);
  }
  flush() {
    this.b.updateSource(this.v);
  }
  handleChange(e, t) {
    const i = this.b;
    e !== G(i.ast, i.s, i, null) && ((this.v = e), this.K.add(this));
  }
}
const Uo = (n) => {
    Ii(n.prototype, 'useScope', function (e) {
      this.s = e;
    });
  },
  lr =
    (n, e = !0) =>
    (t) => {
      const i = t.prototype;
      n != null &&
        ay(i, 'strict', {
          enumerable: !0,
          get: function () {
            return n;
          },
        }),
        ay(i, 'strictFnCall', {
          enumerable: !0,
          get: function () {
            return e;
          },
        }),
        Ii(i, 'get', function (r) {
          return this.l.get(r);
        }),
        Ii(i, 'getSignaler', function () {
          return this.l.root.get(Hc);
        }),
        Ii(i, 'getConverter', function (r) {
          const s = tc.keyFrom(r);
          let a = Zl.get(this);
          return a == null && Zl.set(this, (a = new Tb())), a[s] ?? (a[s] = this.l.get(fb(s)));
        }),
        Ii(i, 'getBehavior', function (r) {
          const s = Xd.keyFrom(r);
          let a = Zl.get(this);
          return a == null && Zl.set(this, (a = new Tb())), a[s] ?? (a[s] = this.l.get(fb(s)));
        });
    },
  Zl = /* @__PURE__ */ new WeakMap();
class Tb {}
const O4 = /* @__PURE__ */ Ut('IFlushQueue', (n) => n.singleton(k4));
class k4 {
  constructor() {
    (this.Y = !1), (this.Z = /* @__PURE__ */ new Set());
  }
  get count() {
    return this.Z.size;
  }
  add(e) {
    if ((this.Z.add(e), !this.Y)) {
      this.Y = !0;
      try {
        this.Z.forEach(P4);
      } finally {
        this.Y = !1;
      }
    }
  }
  clear() {
    this.Z.clear(), (this.Y = !1);
  }
}
function P4(n, e, t) {
  t.delete(n), n.flush();
}
const sf = /* @__PURE__ */ new WeakSet(),
  ka = (n, e) => {
    Ii(n.prototype, 'limit', function (t) {
      if (sf.has(this)) throw se('AURXXXX: a rate limit has already been applied.');
      sf.add(this);
      const i = e(this, t),
        r = t.signals,
        s = r.length > 0 ? this.get(Hc) : null,
        a = this[i],
        o = (...c) => a.call(this, ...c),
        u = t.type === 'debounce' ? N4(t, o, this) : D4(t, o, this),
        l = s
          ? {
              handleChange: u.flush,
            }
          : null;
      return (
        (this[i] = u),
        s && r.forEach((c) => h1(s, c, l)),
        {
          dispose: () => {
            s && r.forEach((c) => m1(s, c, l)), sf.delete(this), u.dispose(), delete this[i];
          },
        }
      );
    });
  },
  N4 = (n, e, t) => {
    let i,
      r,
      s,
      a = !1;
    const o = n.queue,
      u = () => e(s),
      l = (f) => {
        (s = f),
          t.isBound
            ? ((r = i),
              (i = o.queueTask(u, {
                delay: n.delay,
                reusable: !1,
              })),
              r?.cancel())
            : u();
      },
      c = (l.dispose = () => {
        r?.cancel(), i?.cancel(), (r = i = void 0);
      });
    return (
      (l.flush = () => {
        (a = i?.status === 0), c(), a && u();
      }),
      l
    );
  },
  D4 = (n, e, t) => {
    let i,
      r,
      s = 0,
      a = 0,
      o,
      u = !1;
    const l = n.queue,
      c = () => n.now(),
      f = () => e(o),
      m = (v) => {
        (o = v),
          t.isBound
            ? ((a = c() - s),
              (r = i),
              a > n.delay
                ? ((s = c()), f())
                : (i = l.queueTask(
                    () => {
                      (s = c()), f();
                    },
                    {
                      delay: n.delay - a,
                      reusable: !1,
                    },
                  )),
              r?.cancel())
            : f();
      },
      w = (m.dispose = () => {
        r?.cancel(), i?.cancel(), (r = i = void 0);
      });
    return (
      (m.flush = () => {
        (u = i?.status === 0), w(), u && f();
      }),
      m
    );
  },
  { enter: B4, exit: F4 } = lE,
  { wrap: L4, unwrap: $4 } = GE;
class R1 {
  get value() {
    return this.v;
  }
  constructor(e, t, i, r, s) {
    (this.obj = e), (this.$get = i), (this.useProxy = s), (this.isBound = !1), (this.running = !1), (this.v = void 0), (this.cb = r), (this.oL = t);
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  bind() {
    this.isBound || (this.compute(), (this.isBound = !0));
  }
  unbind() {
    this.isBound && ((this.isBound = !1), this.obs.clearAll());
  }
  run() {
    if (!this.isBound || this.running) return;
    const e = this.obj,
      t = this.v,
      i = this.compute();
    wl(i, t) || this.cb.call(e, i, t, e);
  }
  compute() {
    (this.running = !0), this.obs.version++;
    try {
      return B4(this), (this.v = $4(this.$get.call(void 0, this.useProxy ? L4(this.obj) : this.obj, this)));
    } finally {
      this.obs.clear(), (this.running = !1), F4(this);
    }
  }
}
class Kh {
  get value() {
    return this.v;
  }
  constructor(e, t, i, r, s) {
    (this.scope = e), (this.l = t), (this.oL = i), (this.isBound = !1), (this.boundFn = !1), (this.obj = e.bindingContext), (this.J = r), (this.cb = s);
  }
  handleChange(e) {
    const t = this.J,
      i = this.obj,
      r = this.v;
    (t.$kind === 1 && this.obs.count === 1) || (this.obs.version++, (e = G(t, this.scope, this, this)), this.obs.clear()), wl(e, r) || ((this.v = e), this.cb.call(i, e, r, i));
  }
  bind() {
    this.isBound || (this.obs.version++, (this.v = G(this.J, this.scope, this, this)), this.obs.clear(), (this.isBound = !0));
  }
  unbind() {
    this.isBound && ((this.isBound = !1), this.obs.clearAll(), (this.v = void 0));
  }
}
Fi(R1);
Fi(Kh);
lr(!0)(Kh);
const Ja = /* @__PURE__ */ Ut('ILifecycleHooks');
class U4 {
  constructor(e, t) {
    (this.definition = e), (this.instance = t);
  }
}
class Wh {
  constructor(e, t) {
    (this.Type = e), (this.propertyNames = t);
  }
  static create(e, t) {
    const i = /* @__PURE__ */ new Set();
    let r = t.prototype;
    for (; r !== Bh; ) {
      for (const s of f1(r)) s !== 'constructor' && !s.startsWith('_') && i.add(s);
      r = Object.getPrototypeOf(r);
    }
    return new Wh(t, i);
  }
  register(e) {
    $o(Ja, this.Type).register(e);
  }
}
const wb = /* @__PURE__ */ new WeakMap(),
  ed = kn('lifecycle-hooks'),
  Ab = Vr({
    name: ed,
    define(n, e) {
      const t = Wh.create(n, e);
      return Nt(ed, t, e), Oa(e, ed), t.Type;
    },
    resolve(n) {
      let e = wb.get(n);
      if (e === void 0) {
        wb.set(n, (e = new j4()));
        const t = n.root,
          i = t.id === n.id ? n.getAll(Ja) : n.has(Ja, !1) ? t.getAll(Ja).concat(n.getAll(Ja)) : t.getAll(Ja);
        let r, s, a, o, u;
        for (r of i) {
          (s = In(ed, r.constructor)), (a = new U4(s, r));
          for (o of s.propertyNames) (u = e[o]), u === void 0 ? (e[o] = [a]) : u.push(a);
        }
      }
      return e;
    },
  });
class j4 {}
class I1 {
  constructor(e, t, i) {
    (this.type = 7), (this.v = null), (this.ov = null), (this.j = !1), (this.o = e), (this.tt = t), (this.et = i);
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    (this.v = e), (this.j = e !== this.ov), this.W();
  }
  W() {
    if (this.j)
      switch (((this.j = !1), (this.ov = this.v), this.et)) {
        case 'class': {
          this.o.classList.toggle(this.tt, !!this.v);
          break;
        }
        case 'style': {
          let e = '',
            t = this.v;
          Et(t) && t.includes('!important') && ((e = 'important'), (t = t.replace('!important', ''))), this.o.style.setProperty(this.tt, t, e);
          break;
        }
        default:
          this.v == null ? this.o.removeAttribute(this.et) : this.o.setAttribute(this.et, Lo(this.v));
      }
  }
  handleMutation(e) {
    let t = !1;
    for (let i = 0, r = e.length; r > i; ++i) {
      const s = e[i];
      if (s.type === 'attributes' && s.attributeName === this.tt) {
        t = !0;
        break;
      }
    }
    if (t) {
      let i;
      switch (this.et) {
        case 'class':
          i = this.o.classList.contains(this.tt);
          break;
        case 'style':
          i = this.o.style.getPropertyValue(this.tt);
          break;
        default:
          throw se(`AUR0651:${this.et}`);
      }
      i !== this.v && ((this.ov = this.v), (this.v = i), (this.j = !1), this.it());
    }
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && ((this.v = this.ov = this.o.getAttribute(this.tt)), V4(this.o, this));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && z4(this.o, this);
  }
  it() {
    (Eb = this.ov), (this.ov = this.v), this.subs.notify(this.v, Eb);
  }
}
Gn(I1);
const V4 = (n, e) => {
    n.$eMObs === void 0 && (n.$eMObs = /* @__PURE__ */ new Set()),
      n.$mObs === void 0 &&
        (n.$mObs = zh(n, G4)).observe(n, {
          attributes: !0,
        }),
      n.$eMObs.add(e);
  },
  z4 = (n, e) => {
    const t = n.$eMObs;
    return t && t.delete(e) ? (t.size === 0 && (n.$mObs.disconnect(), (n.$mObs = void 0)), !0) : !1;
  },
  G4 = (n) => {
    n[0].target.$eMObs.forEach(q4, n);
  };
function q4(n) {
  n.handleMutation(this);
}
let Eb;
const H4 = {
  reusable: !1,
  preempt: !0,
};
class Cl {
  constructor(e, t, i, r, s, a, o, u, l) {
    (this.targetAttribute = o),
      (this.targetProperty = u),
      (this.mode = l),
      (this.isBound = !1),
      (this.s = void 0),
      (this.st = null),
      (this.v = void 0),
      (this.boundFn = !1),
      (this.l = t),
      (this.ast = s),
      (this.nt = e),
      (this.target = a),
      (this.oL = i),
      (this.T = r);
  }
  updateTarget(e) {
    this.rt.setValue(e, this.target, this.targetProperty);
  }
  handleChange() {
    if (!this.isBound) return;
    let e;
    this.obs.version++;
    const t = G(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    this.obs.clear(),
      t !== this.v &&
        ((this.v = t),
        this.nt.state !== 1 && (this.rt.type & 4) > 0
          ? ((e = this.st),
            (this.st = this.T.queueTask(() => {
              (this.st = null), this.updateTarget(t);
            }, H4)),
            e?.cancel())
          : this.updateTarget(t));
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e),
      Pi(this.ast, e, this),
      this.rt ?? (this.rt = new I1(this.target, this.targetProperty, this.targetAttribute)),
      this.mode & 3 && this.updateTarget((this.v = G(this.ast, e, this, (this.mode & 2) > 0 ? this : null))),
      (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), pi(this.ast, this.s, this), (this.s = void 0), (this.v = void 0), this.st?.cancel(), (this.st = null), this.obs.clearAll());
  }
}
Uo(Cl);
ka(Cl, () => 'updateTarget');
Fi(Cl);
lr(!0)(Cl);
const O1 = {
  reusable: !1,
  preempt: !0,
};
class K4 {
  constructor(e, t, i, r, s, a, o, u) {
    (this.ast = s),
      (this.target = a),
      (this.targetProperty = o),
      (this.mode = u),
      (this.isBound = !1),
      (this.s = void 0),
      (this.st = null),
      (this.nt = e),
      (this.oL = i),
      (this.T = r),
      (this.rt = i.getAccessor(a, o));
    const l = s.expressions,
      c = (this.partBindings = Array(l.length)),
      f = l.length;
    let m = 0;
    for (; f > m; ++m) c[m] = new Ml(l[m], a, o, t, i, this);
  }
  ot() {
    this.updateTarget();
  }
  updateTarget() {
    const e = this.partBindings,
      t = this.ast.parts,
      i = e.length;
    let r = '',
      s = 0;
    if (i === 1) r = t[0] + e[0].v + t[1];
    else for (r = t[0]; i > s; ++s) r += e[s].v + t[s + 1];
    const a = this.rt,
      o = this.nt.state !== 1 && (a.type & 4) > 0;
    let u;
    o
      ? ((u = this.st),
        (this.st = this.T.queueTask(() => {
          (this.st = null), a.setValue(r, this.target, this.targetProperty);
        }, O1)),
        u?.cancel(),
        (u = null))
      : a.setValue(r, this.target, this.targetProperty);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    this.s = e;
    const t = this.partBindings,
      i = t.length;
    let r = 0;
    for (; i > r; ++r) t[r].bind(e);
    this.updateTarget(), (this.isBound = !0);
  }
  unbind() {
    if (!this.isBound) return;
    (this.isBound = !1), (this.s = void 0);
    const e = this.partBindings,
      t = e.length;
    let i = 0;
    for (; t > i; ++i) e[i].unbind();
    this.st?.cancel(), (this.st = null);
  }
}
class Ml {
  constructor(e, t, i, r, s, a) {
    (this.ast = e),
      (this.target = t),
      (this.targetProperty = i),
      (this.owner = a),
      (this.mode = 2),
      (this.task = null),
      (this.isBound = !1),
      (this.v = ''),
      (this.boundFn = !1),
      (this.l = r),
      (this.oL = s);
  }
  updateTarget() {
    this.owner.ot();
  }
  handleChange() {
    if (!this.isBound) return;
    this.obs.version++;
    const e = G(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    this.obs.clear(), e != this.v && ((this.v = e), tr(e) && this.observeCollection(e), this.updateTarget());
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), Pi(this.ast, e, this), (this.v = G(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null)), tr(this.v) && this.observeCollection(this.v), (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), pi(this.ast, this.s, this), (this.s = void 0), this.obs.clearAll());
  }
}
Uo(Ml);
ka(Ml, () => 'updateTarget');
Fi(Ml);
lr(!0)(Ml);
class _l {
  constructor(e, t, i, r, s, a, o, u) {
    (this.p = s),
      (this.ast = a),
      (this.target = o),
      (this.strict = u),
      (this.isBound = !1),
      (this.mode = 2),
      (this.st = null),
      (this.v = ''),
      (this.boundFn = !1),
      (this.l = t),
      (this.nt = e),
      (this.oL = i),
      (this.T = r);
  }
  updateTarget(e) {
    const t = this.target,
      i = this.p.Node,
      r = this.v;
    (this.v = e), r instanceof i && r.parentNode?.removeChild(r), e instanceof i ? ((t.textContent = ''), t.parentNode?.insertBefore(e, t)) : (t.textContent = Lo(e));
  }
  handleChange() {
    if (!this.isBound) return;
    this.obs.version++;
    const e = G(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    if ((this.obs.clear(), e === this.v)) {
      this.st?.cancel(), (this.st = null);
      return;
    }
    this.nt.state !== 1 ? this.lt(e) : this.updateTarget(e);
  }
  handleCollectionChange() {
    if (!this.isBound) return;
    this.obs.version++;
    const e = (this.v = G(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null));
    this.obs.clear(), tr(e) && this.observeCollection(e), this.nt.state !== 1 ? this.lt(e) : this.updateTarget(e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), Pi(this.ast, e, this);
    const t = (this.v = G(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null));
    tr(t) && this.observeCollection(t), this.updateTarget(t), (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), pi(this.ast, this.s, this), (this.s = void 0), this.obs.clearAll(), this.st?.cancel(), (this.st = null));
  }
  lt(e) {
    const t = this.st;
    (this.st = this.T.queueTask(() => {
      (this.st = null), this.updateTarget(e);
    }, O1)),
      t?.cancel();
  }
}
Uo(_l);
ka(_l, () => 'updateTarget');
Fi()(_l);
lr(void 0, !1)(_l);
class Rl {
  constructor(e, t, i, r, s = !1) {
    (this.ast = i), (this.targetProperty = r), (this.isBound = !1), (this.s = void 0), (this.target = null), (this.boundFn = !1), (this.l = e), (this.oL = t), (this.ht = s);
  }
  updateTarget() {
    this.target[this.targetProperty] = this.v;
  }
  handleChange() {
    this.isBound && (this.obs.version++, (this.v = G(this.ast, this.s, this, this)), this.obs.clear(), this.updateTarget());
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), (this.target = this.ht ? e.bindingContext : e.overrideContext), Pi(this.ast, e, this), (this.v = G(this.ast, this.s, this, this)), this.updateTarget(), (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), pi(this.ast, this.s, this), (this.s = void 0), this.obs.clearAll());
  }
}
Uo(Rl);
ka(Rl, () => 'updateTarget');
Fi(Rl);
lr(!0)(Rl);
class Gr {
  constructor(e, t, i, r, s, a, o, u) {
    (this.ast = s),
      (this.target = a),
      (this.targetProperty = o),
      (this.mode = u),
      (this.isBound = !1),
      (this.s = void 0),
      (this.rt = void 0),
      (this.st = null),
      (this.ct = null),
      (this.boundFn = !1),
      (this.l = t),
      (this.nt = e),
      (this.T = r),
      (this.oL = i);
  }
  updateTarget(e) {
    this.rt.setValue(e, this.target, this.targetProperty);
  }
  updateSource(e) {
    bn(this.ast, this.s, this, e);
  }
  handleChange() {
    if (!this.isBound) return;
    this.obs.version++;
    const e = G(this.ast, this.s, this, (this.mode & 2) > 0 ? this : null);
    this.obs.clear(),
      this.nt.state !== 1 && (this.rt.type & 4) > 0
        ? ((af = this.st),
          (this.st = this.T.queueTask(() => {
            this.updateTarget(e), (this.st = null);
          }, W4)),
          af?.cancel(),
          (af = null))
        : this.updateTarget(e);
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), Pi(this.ast, e, this);
    const t = this.oL,
      i = this.mode;
    let r = this.rt;
    r || (i & 4 ? (r = t.getObserver(this.target, this.targetProperty)) : (r = t.getAccessor(this.target, this.targetProperty)), (this.rt = r));
    const s = (i & 2) > 0;
    i & 3 && this.updateTarget(G(this.ast, this.s, this, s ? this : null)),
      i & 4 && (r.subscribe(this.ct ?? (this.ct = new I4(this, this.l.get(O4)))), s || this.updateSource(r.getValue(this.target, this.targetProperty))),
      (this.isBound = !0);
  }
  unbind() {
    this.isBound &&
      ((this.isBound = !1), pi(this.ast, this.s, this), (this.s = void 0), this.ct && (this.rt.unsubscribe(this.ct), (this.ct = null)), this.st?.cancel(), (this.st = null), this.obs.clearAll());
  }
  useTargetObserver(e) {
    this.rt?.unsubscribe(this), (this.rt = e).subscribe(this);
  }
  useTargetSubscriber(e) {
    if (this.ct != null) throw se('AURxxxx: binding already has a target subscriber');
    this.ct = e;
  }
}
Uo(Gr);
ka(Gr, (n) => (n.mode & 4 ? 'updateSource' : 'updateTarget'));
Fi(Gr);
lr(!0, !1)(Gr);
let af = null;
const W4 = {
  reusable: !1,
  preempt: !0,
};
class k1 {
  constructor(e, t, i) {
    (this.ast = t), (this.target = i), (this.isBound = !1), (this.s = void 0), (this.l = e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), Pi(this.ast, e, this), bn(this.ast, this.s, this, this.target), (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), G(this.ast, this.s, this, null) === this.target && bn(this.ast, this.s, this, null), pi(this.ast, this.s, this), (this.s = void 0));
  }
}
lr(!1)(k1);
class J4 {
  constructor(e, t = !1) {
    (this.prevent = e), (this.capture = t);
  }
}
class Il {
  constructor(e, t, i, r, s) {
    (this.ast = t), (this.target = i), (this.targetEvent = r), (this.isBound = !1), (this.self = !1), (this.boundFn = !0), (this.l = e), (this.ut = s);
  }
  callSource(e) {
    const t = this.s.overrideContext;
    t.$event = e;
    let i = G(this.ast, this.s, this, null);
    return delete t.$event, ei(i) && (i = i(e)), i !== !0 && this.ut.prevent && e.preventDefault(), i;
  }
  handleEvent(e) {
    (this.self && this.target !== e.composedPath()[0]) || this.callSource(e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e) return;
      this.unbind();
    }
    (this.s = e), Pi(this.ast, e, this), this.target.addEventListener(this.targetEvent, this, this.ut), (this.isBound = !0);
  }
  unbind() {
    this.isBound && ((this.isBound = !1), pi(this.ast, this.s, this), (this.s = void 0), this.target.removeEventListener(this.targetEvent, this, this.ut));
  }
}
Uo(Il);
ka(Il, () => 'callSource');
lr(!0, !0)(Il);
const ni = /* @__PURE__ */ Ut('IViewFactory');
class Jc {
  constructor(e, t) {
    (this.isCaching = !1), (this.ft = null), (this.dt = -1), (this.name = t.name), (this.container = e), (this.def = t);
  }
  setCacheSize(e, t) {
    e && (e === '*' ? (e = Jc.maxCacheSize) : Et(e) && (e = parseInt(e, 10)), (this.dt === -1 || !t) && (this.dt = e)), this.dt > 0 ? (this.ft = []) : (this.ft = null), (this.isCaching = this.dt > 0);
  }
  canReturnToCache(e) {
    return this.ft != null && this.ft.length < this.dt;
  }
  tryReturnToCache(e) {
    return this.canReturnToCache(e) ? (this.ft.push(e), !0) : !1;
  }
  create(e) {
    const t = this.ft;
    let i;
    return t != null && t.length > 0 ? ((i = t.pop()), i) : ((i = ci.$view(this, e)), i);
  }
}
Jc.maxCacheSize = 65535;
const P1 = /* @__PURE__ */ Ut('IAuSlotsInfo');
class N1 {
  constructor(e) {
    this.projectedSlots = e;
  }
}
const Q4 = /* @__PURE__ */ Ut('IAuSlotWatcher');
var Sb;
(function (n) {
  (n.hydrateElement = 'ra'),
    (n.hydrateAttribute = 'rb'),
    (n.hydrateTemplateController = 'rc'),
    (n.hydrateLetElement = 'rd'),
    (n.setProperty = 're'),
    (n.interpolation = 'rf'),
    (n.propertyBinding = 'rg'),
    (n.letBinding = 'ri'),
    (n.refBinding = 'rj'),
    (n.iteratorBinding = 'rk'),
    (n.multiAttr = 'rl'),
    (n.textBinding = 'ha'),
    (n.listenerBinding = 'hb'),
    (n.attributeBinding = 'hc'),
    (n.stylePropertyBinding = 'hd'),
    (n.setAttribute = 'he'),
    (n.setClassAttribute = 'hf'),
    (n.setStyleAttribute = 'hg'),
    (n.spreadBinding = 'hs'),
    (n.spreadElementProp = 'hp');
})(Sb || (Sb = {}));
const jo = /* @__PURE__ */ Ut('Instruction');
class Ol {
  constructor(e, t, i) {
    (this.from = e), (this.to = t), (this.mode = i), (this.type = 'rg');
  }
}
class Y4 {
  constructor(e, t, i) {
    (this.forOf = e), (this.to = t), (this.props = i), (this.type = 'rk');
  }
}
class X4 {
  constructor(e, t) {
    (this.from = e), (this.to = t), (this.type = 'rj');
  }
}
class Z4 {
  constructor(e, t, i) {
    (this.value = e), (this.to = t), (this.command = i), (this.type = 'rl');
  }
}
class D1 {
  constructor(e, t, i, r) {
    (this.from = e), (this.to = t), (this.preventDefault = i), (this.capture = r), (this.type = 'hb');
  }
}
class Jh {
  constructor(e, t, i) {
    (this.attr = e), (this.from = t), (this.to = i), (this.type = 'hc');
  }
}
class e8 {
  constructor() {
    this.type = 'hs';
  }
}
const B1 = /* @__PURE__ */ Ut('ITemplateCompiler'),
  F1 = /* @__PURE__ */ Ut('IRenderer');
function qt(n) {
  return function (t) {
    return (
      (t.register = function (i) {
        $o(F1, this).register(i);
      }),
      i4(t.prototype, 'target', {
        configurable: !0,
        get: function () {
          return n;
        },
      }),
      t
    );
  };
}
function qr(n, e, t) {
  return Et(e) ? n.parse(e, t) : e;
}
function Qc(n) {
  return n.viewModel != null ? n.viewModel : n;
}
function t8(n, e) {
  if (e === 'element') return n;
  switch (e) {
    case 'controller':
      return oa(n);
    case 'view':
      throw se('AUR0750');
    case 'view-model':
      return oa(n).viewModel;
    default: {
      const t = A1(n, e);
      if (t !== void 0) return t.viewModel;
      const i = oa(n, {
        name: e,
      });
      if (i === void 0) throw se(`AUR0751:${e}`);
      return i.viewModel;
    }
  }
}
let Cb = class {
  render(e, t, i) {
    const r = Qc(t);
    r.$observers?.[i.to] !== void 0 ? r.$observers[i.to].setValue(i.value) : (r[i.to] = i.value);
  }
};
Cb = Z([qt('re')], Cb);
let Mb = class {
  static get inject() {
    return [Pa];
  }
  constructor(e) {
    this.r = e;
  }
  render(e, t, i, r, s, a) {
    let o, u, l, c;
    const f = i.res,
      m = i.projections,
      w = e.container;
    switch (typeof f) {
      case 'string':
        if (((o = w.find(lo, f)), o == null)) throw se(`AUR0752:${f}@${e.name}`);
        break;
      default:
        o = f;
    }
    const T = i.containerless || o.containerless ? Gh(t) : null,
      A = a8(r, e, t, i, T, m == null ? void 0 : new N1(y1(m)));
    (u = o.Type), (l = A.invoke(u)), St(A, u, new ln(o.key, l)), (c = ci.$el(A, l, t, i, o, T)), En(t, o.key, c);
    const _ = this.r.renderers,
      O = i.props,
      B = O.length;
    let P = 0,
      N;
    for (; B > P; ) (N = O[P]), _[N.type].render(e, c, N, r, s, a), ++P;
    e.addChild(c);
  }
};
Mb = Z([qt('ra')], Mb);
let _b = class {
  static get inject() {
    return [Pa];
  }
  constructor(e) {
    this.r = e;
  }
  render(e, t, i, r, s, a) {
    let o = e.container,
      u;
    switch (typeof i.res) {
      case 'string':
        if (((u = o.find(Vh, i.res)), u == null)) throw se(`AUR0753:${i.res}@${e.name}`);
        break;
      default:
        u = i.res;
    }
    const l = j1(r, u, e, t, i, void 0, void 0),
      c = ci.$attr(l.ctn, l.vm, t, u);
    En(t, u.key, c);
    const f = this.r.renderers,
      m = i.props,
      w = m.length;
    let v = 0,
      T;
    for (; w > v; ) (T = m[v]), f[T.type].render(e, c, T, r, s, a), ++v;
    e.addChild(c);
  }
};
_b = Z([qt('rb')], _b);
let Rb = class {
  static get inject() {
    return [Pa, zr];
  }
  constructor(e, t) {
    (this.r = e), (this.p = t);
  }
  render(e, t, i, r, s, a) {
    let o = e.container,
      u;
    switch (typeof i.res) {
      case 'string':
        if (((u = o.find(Vh, i.res)), u == null)) throw se(`AUR0754:${i.res}@${e.name}`);
        break;
      default:
        u = i.res;
    }
    const l = this.r.getViewFactory(i.def, o),
      c = Gh(t),
      f = j1(this.p, u, e, t, i, l, c),
      m = ci.$attr(f.ctn, f.vm, t, u);
    En(c, u.key, m), f.vm.link?.(e, m, t, i);
    const w = this.r.renderers,
      v = i.props,
      T = v.length;
    let A = 0,
      _;
    for (; T > A; ) (_ = v[A]), w[_.type].render(e, m, _, r, s, a), ++A;
    e.addChild(m);
  }
};
Rb = Z([qt('rc')], Rb);
let Ib = class {
  render(e, t, i, r, s, a) {
    t.remove();
    const o = i.instructions,
      u = i.toBindingContext,
      l = e.container,
      c = o.length;
    let f,
      m,
      w = 0;
    for (; c > w; ) (f = o[w]), (m = qr(s, f.from, 16)), e.addBinding(new Rl(l, a, m, f.to, u)), ++w;
  }
};
Ib = Z([qt('rd')], Ib);
let Ob = class {
  render(e, t, i, r, s) {
    e.addBinding(new k1(e.container, qr(s, i.from, 16), t8(t, i.to)));
  }
};
Ob = Z([qt('rj')], Ob);
let kb = class {
  render(e, t, i, r, s, a) {
    e.addBinding(new K4(e, e.container, a, r.domWriteQueue, qr(s, i.from, 1), Qc(t), i.to, 2));
  }
};
kb = Z([qt('rf')], kb);
let Pb = class {
  render(e, t, i, r, s, a) {
    e.addBinding(new Gr(e, e.container, a, r.domWriteQueue, qr(s, i.from, 16), Qc(t), i.to, i.mode));
  }
};
Pb = Z([qt('rg')], Pb);
let Nb = class {
  render(e, t, i, r, s, a) {
    e.addBinding(new Gr(e, e.container, a, r.domWriteQueue, qr(s, i.forOf, 2), Qc(t), i.to, 2));
  }
};
Nb = Z([qt('rk')], Nb);
let Db = class {
  render(e, t, i, r, s, a) {
    e.addBinding(new _l(e, e.container, a, r.domWriteQueue, r, qr(s, i.from, 16), S4(t.parentNode, E4(r, ''), t), i.strict));
  }
};
Db = Z([qt('ha')], Db);
let Bb = class {
  render(e, t, i, r, s) {
    e.addBinding(new Il(e.container, qr(s, i.from, 8), t, i.to, new J4(i.preventDefault, i.capture)));
  }
};
Bb = Z([qt('hb')], Bb);
let Fb = class {
  render(e, t, i) {
    t.setAttribute(i.to, i.value);
  }
};
Fb = Z([qt('he')], Fb);
let Lb = class {
  render(e, t, i) {
    i8(t.classList, i.value);
  }
};
Lb = Z([qt('hf')], Lb);
let $b = class {
  render(e, t, i) {
    t.style.cssText += i.value;
  }
};
$b = Z([qt('hg')], $b);
let Ub = class {
  render(e, t, i, r, s, a) {
    e.addBinding(new Gr(e, e.container, a, r.domWriteQueue, qr(s, i.from, 16), t.style, i.to, 2));
  }
};
Ub = Z([qt('hd')], Ub);
let jb = class {
  render(e, t, i, r, s, a) {
    const o = e.container,
      u = o.has(mb, !1) ? o.get(mb) : null;
    e.addBinding(
      new Cl(
        e,
        o,
        a,
        r.domWriteQueue,
        qr(s, i.from, 16),
        t,
        i.attr,
        u == null
          ? i.to
          : i.to
              .split(/\s/g)
              .map((l) => u[l] ?? l)
              .join(' '),
        2,
      ),
    );
  }
};
jb = Z([qt('hc')], jb);
let Vb = class {
  static get inject() {
    return [B1, Pa];
  }
  constructor(e, t) {
    (this.xt = e), (this.r = t);
  }
  render(e, t, i, r, s, a) {
    const u = e.container.get(nc),
      l = this.r.renderers,
      c = (m) => {
        let w = m,
          v = u;
        for (; v != null && w > 0; ) (v = v.parent), --w;
        if (v == null) throw se('No scope context for spread binding.');
        return v;
      },
      f = (m) => {
        const w = c(m),
          v = r8(w),
          T = this.xt.compileSpread(w.controller.definition, w.instruction?.captures ?? je, w.controller.container, t);
        let A;
        for (A of T)
          switch (A.type) {
            case 'hs':
              f(m + 1);
              break;
            case 'hp':
              l[A.instructions.type].render(v, oa(t), A.instructions, r, s, a);
              break;
            default:
              l[A.type].render(v, t, A, r, s, a);
          }
        e.addBinding(v);
      };
    f(0);
  }
};
Vb = Z([qt('hs')], Vb);
class n8 {
  get container() {
    return this.locator;
  }
  get definition() {
    return this.ctrl.definition;
  }
  get isStrictBinding() {
    return this.ctrl.isStrictBinding;
  }
  get state() {
    return this.ctrl.state;
  }
  constructor(e, t) {
    (this.wt = e), (this.yt = t), (this.isBound = !1), (this.ctrl = t.controller), (this.locator = this.ctrl.container);
  }
  get(e) {
    return this.locator.get(e);
  }
  bind(e) {
    if (this.isBound) return;
    this.isBound = !0;
    const t = (this.scope = this.yt.controller.scope.parent ?? void 0);
    if (t == null) throw se('Invalid spreading. Context scope is null/undefined');
    this.wt.forEach((i) => i.bind(t));
  }
  unbind() {
    this.wt.forEach((e) => e.unbind()), (this.isBound = !1);
  }
  addBinding(e) {
    this.wt.push(e);
  }
  addChild(e) {
    if (e.vmKind !== 1) throw se('Spread binding does not support spreading custom attributes/template controllers');
    this.ctrl.addChild(e);
  }
}
function i8(n, e) {
  const t = e.length;
  let i = 0;
  for (let r = 0; r < t; ++r) e.charCodeAt(r) === 32 ? (r !== i && n.add(e.slice(i, r)), (i = r + 1)) : r + 1 === t && n.add(e.slice(i));
}
const r8 = (n) => new n8([], n),
  L1 = 'IController',
  $1 = 'IInstruction',
  s8 = 'IRenderLocation',
  Qh = 'ISlotsInfo';
function a8(n, e, t, i, r, s) {
  const a = e.container.createChild();
  return (
    St(a, n.HTMLElement, St(a, n.Element, St(a, bo, new ln('ElementResolver', t)))),
    St(a, Yc, new ln(L1, e)),
    St(a, jo, new ln($1, i)),
    St(a, On, r == null ? z1 : new V1(r)),
    St(a, ni, G1),
    St(a, P1, s == null ? q1 : new ln(Qh, s)),
    a
  );
}
class U1 {
  get $isResolver() {
    return !0;
  }
  constructor(e) {
    this.f = e;
  }
  resolve() {
    const e = this.f;
    if (e === null) throw se('AUR7055');
    if (!Et(e.name) || e.name.length === 0) throw se('AUR0756');
    return e;
  }
}
function j1(n, e, t, i, r, s, a, o) {
  const u = t.container.createChild();
  return (
    St(u, n.HTMLElement, St(u, n.Element, St(u, bo, new ln('ElementResolver', i)))),
    (t = t instanceof ci ? t : t.ctrl),
    St(u, Yc, new ln(L1, t)),
    St(u, jo, new ln($1, r)),
    St(u, On, a == null ? z1 : new ln(s8, a)),
    St(u, ni, s == null ? G1 : new U1(s)),
    St(u, P1, o == null ? q1 : new ln(Qh, o)),
    {
      vm: u.invoke(e.Type),
      ctn: u,
    }
  );
}
class V1 {
  get name() {
    return 'IRenderLocation';
  }
  get $isResolver() {
    return !0;
  }
  constructor(e) {
    this.l = e;
  }
  resolve() {
    return this.l;
  }
}
const z1 = new V1(null),
  G1 = new U1(null),
  q1 = new ln(Qh, new N1(je)),
  Pa = /* @__PURE__ */ Ut('IRendering', (n) => n.singleton(H1));
class H1 {
  get renderers() {
    return this.kt ?? (this.kt = this.At.getAll(F1, !1).reduce((e, t) => ((e[t.target] = t), e), Jn()));
  }
  constructor(e) {
    (this.Ct = /* @__PURE__ */ new WeakMap()), (this.Rt = /* @__PURE__ */ new WeakMap());
    const t = e.root;
    (this.p = (this.At = t).get(zr)), (this.ep = t.get(Eh)), (this.oL = t.get(Ra)), (this.Bt = new rf(this.p, this.p.document.createDocumentFragment()));
  }
  compile(e, t, i) {
    if (e.needsCompile !== !1) {
      const r = this.Ct,
        s = t.get(B1);
      let a = r.get(e);
      return a == null ? r.set(e, (a = s.compile(e, t, i))) : t.register(...a.dependencies), a;
    }
    return e;
  }
  getViewFactory(e, t) {
    return new Jc(t, qi.getOrCreate(e));
  }
  createNodes(e) {
    if (e.enhance === !0) return new rf(this.p, e.template);
    let t,
      i = !1;
    const r = this.Rt,
      s = this.p,
      a = s.document;
    if (r.has(e)) t = r.get(e);
    else {
      const o = e.template;
      let u;
      o === null
        ? (t = null)
        : o instanceof s.Node
        ? o.nodeName === 'TEMPLATE'
          ? ((t = o.content), (i = !0))
          : (t = a.createDocumentFragment()).appendChild(o.cloneNode(!0))
        : ((u = a.createElement('template')), Et(o) && (u.innerHTML = o), (t = u.content), (i = !0)),
        r.set(e, t);
    }
    return t == null ? this.Bt : new rf(this.p, i ? a.importNode(t, !0) : a.adoptNode(t.cloneNode(!0)));
  }
  render(e, t, i, r) {
    const s = i.instructions,
      a = this.renderers,
      o = t.length;
    if (t.length !== s.length) throw se(`AUR0757:${o}<>${s.length}`);
    let u = 0,
      l = 0,
      c = 0,
      f,
      m,
      w;
    if (o > 0)
      for (; o > u; ) {
        for (f = s[u], w = t[u], l = 0, c = f.length; c > l; ) (m = f[l]), a[m.type].render(e, w, m, this.p, this.ep, this.oL), ++l;
        ++u;
      }
    if (r != null && ((f = i.surrogates), (c = f.length) > 0)) for (l = 0; c > l; ) (m = f[l]), a[m.type].render(e, r, m, this.p, this.ep, this.oL), ++l;
  }
}
H1.inject = [Po];
var zb;
(function (n) {
  (n[(n.none = 0)] = 'none'), (n[(n.host = 1)] = 'host'), (n[(n.shadowRoot = 2)] = 'shadowRoot'), (n[(n.location = 3)] = 'location');
})(zb || (zb = {}));
const o8 = {
    optional: !0,
  },
  ts = /* @__PURE__ */ new WeakMap();
class ci {
  get lifecycleHooks() {
    return this.St;
  }
  get isActive() {
    return (this.state & 3) > 0 && (this.state & 4) === 0;
  }
  get name() {
    if (this.parent === null)
      switch (this.vmKind) {
        case 1:
          return `[${this.definition.name}]`;
        case 0:
          return this.definition.name;
        case 2:
          return this.viewFactory.name;
      }
    switch (this.vmKind) {
      case 1:
        return `${this.parent.name}>[${this.definition.name}]`;
      case 0:
        return `${this.parent.name}>${this.definition.name}`;
      case 2:
        return this.viewFactory.name === this.parent.definition?.name ? `${this.parent.name}[view]` : `${this.parent.name}[view:${this.viewFactory.name}]`;
    }
  }
  get hooks() {
    return this._t;
  }
  get viewModel() {
    return this.It;
  }
  set viewModel(e) {
    (this.It = e), (this._t = e == null || this.vmKind === 2 ? io.none : new io(e));
  }
  constructor(e, t, i, r, s, a, o) {
    (this.container = e),
      (this.vmKind = t),
      (this.definition = i),
      (this.viewFactory = r),
      (this.host = a),
      (this.head = null),
      (this.tail = null),
      (this.next = null),
      (this.parent = null),
      (this.bindings = null),
      (this.children = null),
      (this.hasLockedScope = !1),
      (this.isStrictBinding = !1),
      (this.scope = null),
      (this.isBound = !1),
      (this.hostController = null),
      (this.mountTarget = 0),
      (this.shadowRoot = null),
      (this.nodes = null),
      (this.location = null),
      (this.St = null),
      (this.state = 0),
      (this.Tt = !1),
      (this.$initiator = null),
      (this.$resolve = void 0),
      (this.$reject = void 0),
      (this.$promise = void 0),
      (this.Et = 0),
      (this.Pt = 0),
      (this.Lt = 0),
      (this.It = s),
      (this._t = t === 2 ? io.none : new io(s)),
      (this.location = o),
      (this.r = e.root.get(Pa));
  }
  static getCached(e) {
    return ts.get(e);
  }
  static getCachedOrThrow(e) {
    const t = ci.getCached(e);
    if (t === void 0) throw se(`AUR0500:${e}`);
    return t;
  }
  static $el(e, t, i, r, s = void 0, a = null) {
    if (ts.has(t)) return ts.get(t);
    s = s ?? py(t.constructor);
    const o = new ci(e, 0, s, null, t, i, a),
      u = e.get(Ex(nc));
    return s.dependencies.length > 0 && e.register(...s.dependencies), St(e, nc, new ln('IHydrationContext', new c8(o, r, u))), ts.set(t, o), (r == null || r.hydrate !== !1) && o.hE(r, u), o;
  }
  static $attr(e, t, i, r) {
    if (ts.has(t)) return ts.get(t);
    r = r ?? ly(t.constructor);
    const s = new ci(e, 1, r, null, t, i, null);
    return r.dependencies.length > 0 && e.register(...r.dependencies), ts.set(t, s), s.Mt(), s;
  }
  static $view(e, t = void 0) {
    const i = new ci(e.container, 2, null, e, null, null, null);
    return (i.parent = t ?? null), i.Dt(), i;
  }
  hE(e, t) {
    const i = this.container,
      r = this.It;
    let s = this.definition;
    if (((this.scope = pn.create(r, null, !0)), s.watches.length > 0 && Hb(this, i, s, r), Gb(this, s, r), this._t.hasDefine)) {
      const a = r.define(this, t, s);
      a !== void 0 && a !== s && (s = qi.getOrCreate(a));
    }
    (this.St = Ab.resolve(i)), s.register(i), s.injectable !== null && St(i, s.injectable, new ln('definition.injectable', r)), (e == null || e.hydrate !== !1) && (this.hS(e), this.hC());
  }
  hS(e) {
    this.St.hydrating != null && this.St.hydrating.forEach(f8, this), this._t.hasHydrating && this.It.hydrating(this);
    const t = (this.$t = this.r.compile(this.definition, this.container, e)),
      { shadowOptions: i, isStrictBinding: r, hasSlots: s, containerless: a } = t;
    let o = this.location;
    if (
      ((this.isStrictBinding = r),
      (this.hostController = oa(this.host, o8)) !== null &&
        ((this.host = this.container.root.get(zr).document.createElement(this.definition.name)), a && o == null && (o = this.location = Gh(this.host))),
      En(this.host, en, this),
      En(this.host, this.definition.key, this),
      i !== null || s)
    ) {
      if (o != null) throw se('AUR0501');
      En((this.shadowRoot = this.host.attachShadow(i ?? d8)), en, this), En(this.shadowRoot, this.definition.key, this), (this.mountTarget = 2);
    } else o != null ? (En(o, en, this), En(o, this.definition.key, this), (this.mountTarget = 3)) : (this.mountTarget = 1);
    (this.It.$controller = this), (this.nodes = this.r.createNodes(t)), this.St.hydrated !== void 0 && this.St.hydrated.forEach(y8, this), this._t.hasHydrated && this.It.hydrated(this);
  }
  hC() {
    this.r.render(this, this.nodes.findTargets(), this.$t, this.host), this.St.created !== void 0 && this.St.created.forEach(Qb, this), this._t.hasCreated && this.It.created(this);
  }
  Mt() {
    const e = this.definition,
      t = this.It;
    e.watches.length > 0 && Hb(this, this.container, e, t),
      Gb(this, e, t),
      (t.$controller = this),
      (this.St = Ab.resolve(this.container)),
      this.St.created !== void 0 && this.St.created.forEach(Qb, this),
      this._t.hasCreated && this.It.created(this);
  }
  Dt() {
    (this.$t = this.r.compile(this.viewFactory.def, this.container, null)),
      (this.isStrictBinding = this.$t.isStrictBinding),
      this.r.render(this, (this.nodes = this.r.createNodes(this.$t)).findTargets(), this.$t, void 0);
  }
  activate(e, t, i) {
    switch (this.state) {
      case 0:
      case 8:
        if (!(t === null || t.isActive)) return;
        this.state = 1;
        break;
      case 2:
        return;
      case 32:
        throw se(`AUR0502:${this.name}`);
      default:
        throw se(`AUR0503:${this.name} ${Jb(this.state)}`);
    }
    switch (((this.parent = t), this.vmKind)) {
      case 0:
        this.scope.parent = i ?? null;
        break;
      case 1:
        this.scope = i ?? null;
        break;
      case 2:
        if (i == null) throw se('AUR0504');
        this.hasLockedScope || (this.scope = i);
        break;
    }
    this.isStrictBinding, (this.$initiator = e), this.Ut();
    let r;
    return (
      this.vmKind !== 2 && this.St.binding != null && (r = Yt(...this.St.binding.map(h8, this))),
      this._t.hasBinding && (r = Yt(r, this.It.binding(this.$initiator, this.parent))),
      un(r)
        ? (this.qt(),
          r
            .then(() => {
              this.bind();
            })
            .catch((s) => {
              this.Ft(s);
            }),
          this.$promise)
        : (this.bind(), this.$promise)
    );
  }
  bind() {
    let e = 0,
      t = 0,
      i;
    if (this.bindings !== null) for (e = 0, t = this.bindings.length; t > e; ) this.bindings[e].bind(this.scope), ++e;
    if ((this.vmKind !== 2 && this.St.bound != null && (i = Yt(...this.St.bound.map(m8, this))), this._t.hasBound && (i = Yt(i, this.It.bound(this.$initiator, this.parent))), un(i))) {
      this.qt(),
        i
          .then(() => {
            (this.isBound = !0), this.Ot();
          })
          .catch((r) => {
            this.Ft(r);
          });
      return;
    }
    (this.isBound = !0), this.Ot();
  }
  Ht(...e) {
    switch (this.mountTarget) {
      case 1:
        this.host.append(...e);
        break;
      case 2:
        this.shadowRoot.append(...e);
        break;
      case 3: {
        let t = 0;
        for (; t < e.length; ++t) this.location.parentNode.insertBefore(e[t], this.location);
        break;
      }
    }
  }
  Ot() {
    if (this.hostController !== null)
      switch (this.mountTarget) {
        case 1:
        case 2:
          this.hostController.Ht(this.host);
          break;
        case 3:
          this.hostController.Ht(this.location.$start, this.location);
          break;
      }
    switch (this.mountTarget) {
      case 1:
        this.nodes.appendTo(this.host, this.definition != null && this.definition.enhance);
        break;
      case 2: {
        const i = this.container;
        (i.has(xb, !1) ? i.get(xb) : i.get(R4)).applyTo(this.shadowRoot), this.nodes.appendTo(this.shadowRoot);
        break;
      }
      case 3:
        this.nodes.insertBefore(this.location);
        break;
    }
    let e = 0,
      t;
    if (
      (this.vmKind !== 2 && this.St.attaching != null && (t = Yt(...this.St.attaching.map(b8, this))),
      this._t.hasAttaching && (t = Yt(t, this.It.attaching(this.$initiator, this.parent))),
      un(t) &&
        (this.qt(),
        this.Ut(),
        t
          .then(() => {
            this.Vt();
          })
          .catch((i) => {
            this.Ft(i);
          })),
      this.children !== null)
    )
      for (; e < this.children.length; ++e) this.children[e].activate(this.$initiator, this, this.scope);
    this.Vt();
  }
  deactivate(e, t) {
    switch (this.state & -17) {
      case 2:
        this.state = 4;
        break;
      case 0:
      case 8:
      case 32:
      case 40:
        return;
      default:
        throw se(`AUR0505:${this.name} ${Jb(this.state)}`);
    }
    (this.$initiator = e), e === this && this.Nt();
    let i = 0,
      r;
    if (this.children !== null) for (i = 0; i < this.children.length; ++i) this.children[i].deactivate(e, this);
    if (
      (this.vmKind !== 2 && this.St.detaching != null && (r = Yt(...this.St.detaching.map(v8, this))),
      this._t.hasDetaching && (r = Yt(r, this.It.detaching(this.$initiator, this.parent))),
      un(r) &&
        (this.qt(),
        e.Nt(),
        r
          .then(() => {
            e.jt();
          })
          .catch((s) => {
            e.Ft(s);
          })),
      e.head === null ? (e.head = this) : (e.tail.next = this),
      (e.tail = this),
      e === this)
    )
      return this.jt(), this.$promise;
  }
  removeNodes() {
    switch (this.vmKind) {
      case 0:
      case 2:
        this.nodes.remove(), this.nodes.unlink();
    }
    if (this.hostController !== null)
      switch (this.mountTarget) {
        case 1:
        case 2:
          this.host.remove();
          break;
        case 3:
          this.location.$start.remove(), this.location.remove();
          break;
      }
  }
  unbind() {
    let e = 0;
    if (this.bindings !== null) for (; e < this.bindings.length; ++e) this.bindings[e].unbind();
    switch (((this.parent = null), this.vmKind)) {
      case 1:
        this.scope = null;
        break;
      case 2:
        this.hasLockedScope || (this.scope = null), (this.state & 16) === 16 && !this.viewFactory.tryReturnToCache(this) && this.$initiator === this && this.dispose();
        break;
      case 0:
        this.scope.parent = null;
        break;
    }
    (this.state = 8), (this.$initiator = null), this.Wt();
  }
  qt() {
    this.$promise === void 0 &&
      ((this.$promise = new Promise((e, t) => {
        (this.$resolve = e), (this.$reject = t);
      })),
      this.$initiator !== this && this.parent.qt());
  }
  Wt() {
    this.$promise !== void 0 && ((of = this.$resolve), (this.$resolve = this.$reject = this.$promise = void 0), of(), (of = void 0));
  }
  Ft(e) {
    this.$promise !== void 0 && ((uf = this.$reject), (this.$resolve = this.$reject = this.$promise = void 0), uf(e), (uf = void 0)), this.$initiator !== this && this.parent.Ft(e);
  }
  Ut() {
    ++this.Et, this.$initiator !== this && this.parent.Ut();
  }
  Vt() {
    if (--this.Et === 0) {
      if ((this.vmKind !== 2 && this.St.attached != null && (Qs = Yt(...this.St.attached.map(g8, this))), this._t.hasAttached && (Qs = Yt(Qs, this.It.attached(this.$initiator))), un(Qs))) {
        this.qt(),
          Qs.then(() => {
            (this.state = 2), this.Wt(), this.$initiator !== this && this.parent.Vt();
          }).catch((e) => {
            this.Ft(e);
          }),
          (Qs = void 0);
        return;
      }
      (Qs = void 0), (this.state = 2), this.Wt();
    }
    this.$initiator !== this && this.parent.Vt();
  }
  Nt() {
    ++this.Pt;
  }
  jt() {
    if (--this.Pt === 0) {
      this.zt(), this.removeNodes();
      let e = this.$initiator.head,
        t;
      for (; e !== null; )
        e !== this && (e.debug && e.logger.trace('detach()'), e.removeNodes()),
          e.vmKind !== 2 && e.St.unbinding != null && (t = Yt(...e.St.unbinding.map(x8, this))),
          e._t.hasUnbinding && (e.debug && e.logger.trace('unbinding()'), (t = Yt(t, e.viewModel.unbinding(e.$initiator, e.parent)))),
          un(t) &&
            (this.qt(),
            this.zt(),
            t
              .then(() => {
                this.Gt();
              })
              .catch((i) => {
                this.Ft(i);
              })),
          (t = void 0),
          (e = e.next);
      this.Gt();
    }
  }
  zt() {
    ++this.Lt;
  }
  Gt() {
    if (--this.Lt === 0) {
      let e = this.$initiator.head,
        t = null;
      for (; e !== null; ) e !== this && ((e.isBound = !1), e.unbind()), (t = e.next), (e.next = null), (e = t);
      (this.head = this.tail = null), (this.isBound = !1), this.unbind();
    }
  }
  addBinding(e) {
    this.bindings === null ? (this.bindings = [e]) : (this.bindings[this.bindings.length] = e);
  }
  addChild(e) {
    this.children === null ? (this.children = [e]) : (this.children[this.children.length] = e);
  }
  is(e) {
    switch (this.vmKind) {
      case 1:
        return ly(this.It.constructor).name === e;
      case 0:
        return py(this.It.constructor).name === e;
      case 2:
        return this.viewFactory.name === e;
    }
  }
  lockScope(e) {
    (this.scope = e), (this.hasLockedScope = !0);
  }
  setHost(e) {
    return this.vmKind === 0 && (En(e, en, this), En(e, this.definition.key, this)), (this.host = e), (this.mountTarget = 1), this;
  }
  setShadowRoot(e) {
    return this.vmKind === 0 && (En(e, en, this), En(e, this.definition.key, this)), (this.shadowRoot = e), (this.mountTarget = 2), this;
  }
  setLocation(e) {
    return this.vmKind === 0 && (En(e, en, this), En(e, this.definition.key, this)), (this.location = e), (this.mountTarget = 3), this;
  }
  release() {
    this.state |= 16;
  }
  dispose() {
    (this.state & 32) !== 32 &&
      ((this.state |= 32),
      this._t.hasDispose && this.It.dispose(),
      this.children !== null && (this.children.forEach(p8), (this.children = null)),
      (this.hostController = null),
      (this.scope = null),
      (this.nodes = null),
      (this.location = null),
      (this.viewFactory = null),
      this.It !== null && (ts.delete(this.It), (this.It = null)),
      (this.It = null),
      (this.host = null),
      (this.shadowRoot = null),
      this.container.disposeResolvers());
  }
  accept(e) {
    if (e(this) === !0 || (this._t.hasAccept && this.It.accept(e) === !0)) return !0;
    if (this.children !== null) {
      const { children: t } = this;
      for (let i = 0, r = t.length; i < r; ++i) if (t[i].accept(e) === !0) return !0;
    }
  }
}
function u8(n) {
  let e = n.$observers;
  return (
    e === void 0 &&
      Reflect.defineProperty(n, '$observers', {
        enumerable: !1,
        value: (e = {}),
      }),
    e
  );
}
function Gb(n, e, t) {
  const i = e.bindables,
    r = f1(i),
    s = r.length;
  if (s > 0) {
    let a,
      o,
      u = 0;
    const l = u8(t),
      c = n.container,
      f = c.has(Dm, !0) ? c.get(Dm) : null;
    for (; u < s; ++u) (a = r[u]), l[a] === void 0 && ((o = i[a]), (l[a] = new b1(t, a, o.callback, o.set, n, f)));
  }
}
const qb = /* @__PURE__ */ new Map(),
  l8 = (n) => {
    let e = qb.get(n);
    return e == null && ((e = new gd(n, 0)), qb.set(n, e)), e;
  };
function Hb(n, e, t, i) {
  const r = e.get(Ra),
    s = e.get(Eh),
    a = t.watches,
    o = n.vmKind === 0 ? n.scope : pn.create(i, null, !0),
    u = a.length;
  let l,
    c,
    f,
    m = 0;
  for (; u > m; ++m) {
    if ((({ expression: l, callback: c } = a[m]), (c = ei(c) ? c : Reflect.get(i, c)), !ei(c))) throw se(`AUR0506:${Lo(c)}`);
    ei(l) ? n.addBinding(new R1(i, r, l, c, !0)) : ((f = Et(l) ? s.parse(l, 16) : l8(l)), n.addBinding(new Kh(o, e, r, f, c)));
  }
}
class io {
  constructor(e) {
    (this.hasDefine = 'define' in e),
      (this.hasHydrating = 'hydrating' in e),
      (this.hasHydrated = 'hydrated' in e),
      (this.hasCreated = 'created' in e),
      (this.hasBinding = 'binding' in e),
      (this.hasBound = 'bound' in e),
      (this.hasAttaching = 'attaching' in e),
      (this.hasAttached = 'attached' in e),
      (this.hasDetaching = 'detaching' in e),
      (this.hasUnbinding = 'unbinding' in e),
      (this.hasDispose = 'dispose' in e),
      (this.hasAccept = 'accept' in e);
  }
}
io.none = new io({});
const d8 = {
  mode: 'open',
};
var Kb;
(function (n) {
  (n[(n.customElement = 0)] = 'customElement'), (n[(n.customAttribute = 1)] = 'customAttribute'), (n[(n.synthetic = 2)] = 'synthetic');
})(Kb || (Kb = {}));
var Wb;
(function (n) {
  (n[(n.none = 0)] = 'none'),
    (n[(n.activating = 1)] = 'activating'),
    (n[(n.activated = 2)] = 'activated'),
    (n[(n.deactivating = 4)] = 'deactivating'),
    (n[(n.deactivated = 8)] = 'deactivated'),
    (n[(n.released = 16)] = 'released'),
    (n[(n.disposed = 32)] = 'disposed');
})(Wb || (Wb = {}));
function Jb(n) {
  const e = [];
  return (
    (n & 1) === 1 && e.push('activating'),
    (n & 2) === 2 && e.push('activated'),
    (n & 4) === 4 && e.push('deactivating'),
    (n & 8) === 8 && e.push('deactivated'),
    (n & 16) === 16 && e.push('released'),
    (n & 32) === 32 && e.push('disposed'),
    e.length === 0 ? 'none' : e.join('|')
  );
}
const Yc = /* @__PURE__ */ Ut('IController'),
  nc = /* @__PURE__ */ Ut('IHydrationContext');
class c8 {
  constructor(e, t, i) {
    (this.instruction = t), (this.parent = i), (this.controller = e);
  }
}
function p8(n) {
  n.dispose();
}
function Qb(n) {
  n.instance.created(this.It, this);
}
function f8(n) {
  n.instance.hydrating(this.It, this);
}
function y8(n) {
  n.instance.hydrated(this.It, this);
}
function h8(n) {
  return n.instance.binding(this.It, this.$initiator, this.parent);
}
function m8(n) {
  return n.instance.bound(this.It, this.$initiator, this.parent);
}
function b8(n) {
  return n.instance.attaching(this.It, this.$initiator, this.parent);
}
function g8(n) {
  return n.instance.attached(this.It, this.$initiator);
}
function v8(n) {
  return n.instance.detaching(this.It, this.$initiator, this.parent);
}
function x8(n) {
  return n.instance.unbinding(this.It, this.$initiator, this.parent);
}
let of, uf, Qs;
class Yh {
  constructor(e, t, i, r) {
    if (((this.chars = e), (this.repeat = t), (this.isSymbol = i), (this.isInverted = r), r))
      switch (e.length) {
        case 0:
          this.has = this.ne;
          break;
        case 1:
          this.has = this.re;
          break;
        default:
          this.has = this.oe;
      }
    else
      switch (e.length) {
        case 0:
          this.has = this.le;
          break;
        case 1:
          this.has = this.he;
          break;
        default:
          this.has = this.ae;
      }
  }
  equals(e) {
    return this.chars === e.chars && this.repeat === e.repeat && this.isSymbol === e.isSymbol && this.isInverted === e.isInverted;
  }
  ae(e) {
    return this.chars.includes(e);
  }
  he(e) {
    return this.chars === e;
  }
  le(e) {
    return !1;
  }
  oe(e) {
    return !this.chars.includes(e);
  }
  re(e) {
    return this.chars !== e;
  }
  ne(e) {
    return !0;
  }
}
class T8 {
  constructor() {
    (this.parts = je), (this.ce = ''), (this.ue = {}), (this.fe = {});
  }
  get pattern() {
    const e = this.ce;
    return e === '' ? null : e;
  }
  set pattern(e) {
    e == null ? ((this.ce = ''), (this.parts = je)) : ((this.ce = e), (this.parts = this.fe[e]));
  }
  append(e, t) {
    const i = this.ue;
    i[e] === void 0 ? (i[e] = t) : (i[e] += t);
  }
  next(e) {
    const t = this.ue;
    let i;
    t[e] !== void 0 && ((i = this.fe), i[e] === void 0 ? (i[e] = [t[e]]) : i[e].push(t[e]), (t[e] = void 0));
  }
}
class Xh {
  get ce() {
    return this.de ? this.me[0] : null;
  }
  constructor(e, ...t) {
    (this.charSpec = e), (this.ge = []), (this.pe = null), (this.de = !1), (this.me = t);
  }
  findChild(e) {
    const t = this.ge,
      i = t.length;
    let r = null,
      s = 0;
    for (; s < i; ++s) if (((r = t[s]), e.equals(r.charSpec))) return r;
    return null;
  }
  append(e, t) {
    const i = this.me;
    i.includes(t) || i.push(t);
    let r = this.findChild(e);
    return r == null && ((r = new Xh(e, t)), this.ge.push(r), e.repeat && r.ge.push(r)), r;
  }
  findMatches(e, t) {
    const i = [],
      r = this.ge,
      s = r.length;
    let a = 0,
      o = null,
      u = 0,
      l = 0;
    for (; u < s; ++u)
      if (((o = r[u]), o.charSpec.has(e)))
        if ((i.push(o), (a = o.me.length), (l = 0), o.charSpec.isSymbol)) for (; l < a; ++l) t.next(o.me[l]);
        else for (; l < a; ++l) t.append(o.me[l], e);
    return i;
  }
}
class Yb {
  constructor(e) {
    this.text = e;
    const t = (this.ve = e.length),
      i = (this.be = []);
    let r = 0;
    for (; t > r; ++r) i.push(new Yh(e[r], !1, !1, !1));
  }
  eachChar(e) {
    const t = this.ve,
      i = this.be;
    let r = 0;
    for (; t > r; ++r) e(i[r]);
  }
}
class w8 {
  constructor(e) {
    (this.text = 'PART'), (this.xe = new Yh(e, !0, !1, !0));
  }
  eachChar(e) {
    e(this.xe);
  }
}
class A8 {
  constructor(e) {
    (this.text = e), (this.xe = new Yh(e, !1, !0, !1));
  }
  eachChar(e) {
    e(this.xe);
  }
}
class E8 {
  constructor() {
    (this.statics = 0), (this.dynamics = 0), (this.symbols = 0);
  }
}
const S8 = /* @__PURE__ */ Ut('ISyntaxInterpreter', (n) => n.singleton(C8));
class C8 {
  constructor() {
    (this.we = new Xh(null)), (this.ye = [this.we]);
  }
  add(e) {
    e = e.slice(0).sort((m, w) => (m.pattern > w.pattern ? 1 : -1));
    const t = e.length;
    let i,
      r,
      s,
      a,
      o,
      u,
      l,
      c = 0,
      f;
    for (; t > c; ) {
      for (i = this.we, r = e[c], s = r.pattern, a = new E8(), o = this.ke(r, a), u = o.length, l = (m) => (i = i.append(m, s)), f = 0; u > f; ++f) o[f].eachChar(l);
      (i.pe = a), (i.de = !0), ++c;
    }
  }
  interpret(e) {
    const t = new T8(),
      i = e.length;
    let r = this.ye,
      s = 0,
      a;
    for (; s < i && ((r = this.Ae(r, e.charAt(s), t)), r.length !== 0); ++s);
    return (r = r.filter(M8)), r.length > 0 && (r.sort(_8), (a = r[0]), a.charSpec.isSymbol || t.next(a.ce), (t.pattern = a.ce)), t;
  }
  Ae(e, t, i) {
    const r = [];
    let s = null;
    const a = e.length;
    let o = 0;
    for (; o < a; ++o) (s = e[o]), r.push(...s.findMatches(t, i));
    return r;
  }
  ke(e, t) {
    const i = [],
      r = e.pattern,
      s = r.length,
      a = e.symbols;
    let o = 0,
      u = 0,
      l = '';
    for (; o < s; )
      (l = r.charAt(o)),
        a.length === 0 || !a.includes(l)
          ? o === u && l === 'P' && r.slice(o, o + 4) === 'PART'
            ? ((u = o = o + 4), i.push(new w8(a)), ++t.dynamics)
            : ++o
          : o !== u
          ? (i.push(new Yb(r.slice(u, o))), ++t.statics, (u = o))
          : (i.push(new A8(r.slice(u, o + 1))), ++t.symbols, (u = ++o));
    return u !== o && (i.push(new Yb(r.slice(u, o))), ++t.statics), i;
  }
}
function M8(n) {
  return n.de;
}
function _8(n, e) {
  const t = n.pe,
    i = e.pe;
  return t.statics !== i.statics ? i.statics - t.statics : t.dynamics !== i.dynamics ? i.dynamics - t.dynamics : t.symbols !== i.symbols ? i.symbols - t.symbols : 0;
}
class hi {
  constructor(e, t, i, r) {
    (this.rawName = e), (this.rawValue = t), (this.target = i), (this.command = r);
  }
}
const K1 = /* @__PURE__ */ Ut('IAttributePattern'),
  R8 = /* @__PURE__ */ Ut('IAttributeParser', (n) => n.singleton(W1));
class W1 {
  constructor(e, t) {
    (this.ft = {}), (this.Ce = e);
    const i = (this.me = {}),
      r = t.reduce((s, a) => {
        const o = J1(a.constructor);
        return o.forEach((u) => (i[u.pattern] = a)), s.concat(o);
      }, je);
    e.add(r);
  }
  parse(e, t) {
    let i = this.ft[e];
    i == null && (i = this.ft[e] = this.Ce.interpret(e));
    const r = i.pattern;
    return r == null ? new hi(e, t, e, null) : this.me[r][r](e, t, i.parts);
  }
}
W1.inject = [S8, Ax(K1)];
function Hr(...n) {
  return function (t) {
    return O8.define(n, t);
  };
}
class I8 {
  constructor(e) {
    (this.Type = e), (this.name = void 0);
  }
  register(e) {
    $o(K1, this.Type).register(e);
  }
}
const lf = Ia('attribute-pattern'),
  Ed = 'attribute-pattern-definitions',
  J1 = (n) => ko.annotation.get(n, Ed),
  O8 = Vr({
    name: lf,
    definitionAnnotationKey: Ed,
    define(n, e) {
      const t = new I8(e);
      return Nt(lf, t, e), Oa(e, lf), ko.annotation.set(e, Ed, n), Dh(e, Ed), e;
    },
    getPatternDefinitions: J1,
  });
let Xb = class {
  'PART.PART'(e, t, i) {
    return new hi(e, t, i[0], i[1]);
  }
  'PART.PART.PART'(e, t, i) {
    return new hi(e, t, `${i[0]}.${i[1]}`, i[2]);
  }
};
Xb = Z(
  [
    Hr(
      {
        pattern: 'PART.PART',
        symbols: '.',
      },
      {
        pattern: 'PART.PART.PART',
        symbols: '.',
      },
    ),
  ],
  Xb,
);
let Zb = class {
  ref(e, t, i) {
    return new hi(e, t, 'element', 'ref');
  }
  'PART.ref'(e, t, i) {
    return new hi(e, t, i[0], 'ref');
  }
};
Zb = Z(
  [
    Hr(
      {
        pattern: 'ref',
        symbols: '',
      },
      {
        pattern: 'PART.ref',
        symbols: '.',
      },
    ),
  ],
  Zb,
);
let eg = class {
  ':PART'(e, t, i) {
    return new hi(e, t, i[0], 'bind');
  }
};
eg = Z(
  [
    Hr({
      pattern: ':PART',
      symbols: ':',
    }),
  ],
  eg,
);
let tg = class {
  '@PART'(e, t, i) {
    return new hi(e, t, i[0], 'trigger');
  }
};
tg = Z(
  [
    Hr({
      pattern: '@PART',
      symbols: '@',
    }),
  ],
  tg,
);
let ng = class {
  '...$attrs'(e, t, i) {
    return new hi(e, t, '', '...$attrs');
  }
};
ng = Z(
  [
    Hr({
      pattern: '...$attrs',
      symbols: '',
    }),
  ],
  ng,
);
var ig;
(function (n) {
  (n[(n.None = 0)] = 'None'), (n[(n.IgnoreAttr = 1)] = 'IgnoreAttr');
})(ig || (ig = {}));
function Kn(n) {
  return function (e) {
    return Y1.define(n, e);
  };
}
class Zh {
  constructor(e, t, i, r, s) {
    (this.Type = e), (this.name = t), (this.aliases = i), (this.key = r), (this.type = s);
  }
  static create(e, t) {
    let i, r;
    return (
      Et(e)
        ? ((i = e),
          (r = {
            name: i,
          }))
        : ((i = e.name), (r = e)),
      new Zh(t, Ln(Sd(t, 'name'), i), Vt(Sd(t, 'aliases'), r.aliases, t.aliases), Q1(i), Ln(Sd(t, 'type'), r.type, t.type, null))
    );
  }
  register(e) {
    const { Type: t, key: i, aliases: r } = this;
    $o(i, t).register(e), Al(i, t).register(e), El(r, Y1, i, e);
  }
}
const pu = Ia('binding-command'),
  Q1 = (n) => `${pu}:${n}`,
  Sd = (n, e) => In(kn(e), n),
  Y1 = Vr({
    name: pu,
    keyFrom: Q1,
    define(n, e) {
      const t = Zh.create(n, e);
      return Nt(pu, t, t.Type), Nt(pu, t, t), Oa(e, pu), t.Type;
    },
    getAnnotation: Sd,
  });
let rg = class {
  get type() {
    return 0;
  }
  build(e, t, i) {
    let s = e.attr.target,
      a = e.attr.rawValue;
    return e.bindable == null ? (s = i.map(e.node, s) ?? ti(s)) : (a === '' && e.def.type === 1 && (a = ti(s)), (s = e.bindable.property)), new Ol(t.parse(a, 16), s, 1);
  }
};
rg = Z([Kn('one-time')], rg);
let sg = class {
  get type() {
    return 0;
  }
  build(e, t, i) {
    let s = e.attr.target,
      a = e.attr.rawValue;
    return e.bindable == null ? (s = i.map(e.node, s) ?? ti(s)) : (a === '' && e.def.type === 1 && (a = ti(s)), (s = e.bindable.property)), new Ol(t.parse(a, 16), s, 2);
  }
};
sg = Z([Kn('to-view')], sg);
let ag = class {
  get type() {
    return 0;
  }
  build(e, t, i) {
    const r = e.attr;
    let s = r.target,
      a = r.rawValue;
    return e.bindable == null ? (s = i.map(e.node, s) ?? ti(s)) : (a === '' && e.def.type === 1 && (a = ti(s)), (s = e.bindable.property)), new Ol(t.parse(a, 16), s, 4);
  }
};
ag = Z([Kn('from-view')], ag);
let og = class {
  get type() {
    return 0;
  }
  build(e, t, i) {
    const r = e.attr;
    let s = r.target,
      a = r.rawValue;
    return e.bindable == null ? (s = i.map(e.node, s) ?? ti(s)) : (a === '' && e.def.type === 1 && (a = ti(s)), (s = e.bindable.property)), new Ol(t.parse(a, 16), s, 6);
  }
};
og = Z([Kn('two-way')], og);
let ug = class {
  get type() {
    return 0;
  }
  build(e, t, i) {
    const r = e.attr,
      s = e.bindable;
    let a,
      o,
      u = r.target,
      l = r.rawValue;
    return (
      s == null
        ? ((o = i.isTwoWay(e.node, u) ? 6 : 2), (u = i.map(e.node, u) ?? ti(u)))
        : (l === '' && e.def.type === 1 && (l = ti(u)), (a = e.def.defaultBindingMode), (o = s.mode === 8 || s.mode == null ? (a == null || a === 8 ? 2 : a) : s.mode), (u = s.property)),
      new Ol(t.parse(l, 16), u, o)
    );
  }
};
ug = Z([Kn('bind')], ug);
let lg = class {
  get type() {
    return 0;
  }
  static get inject() {
    return [R8];
  }
  constructor(e) {
    this.Re = e;
  }
  build(e, t) {
    const i = e.bindable === null ? ti(e.attr.target) : e.bindable.property,
      r = t.parse(e.attr.rawValue, 2);
    let s = je;
    if (r.semiIdx > -1) {
      const a = e.attr.rawValue.slice(r.semiIdx + 1),
        o = a.indexOf(':');
      if (o > -1) {
        const u = a.slice(0, o).trim(),
          l = a.slice(o + 1).trim(),
          c = this.Re.parse(u, l);
        s = [new Z4(l, c.target, c.command)];
      }
    }
    return new Y4(r, i, s);
  }
};
lg = Z([Kn('for')], lg);
let dg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new D1(t.parse(e.attr.rawValue, 8), e.attr.target, !0, !1);
  }
};
dg = Z([Kn('trigger')], dg);
let cg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new D1(t.parse(e.attr.rawValue, 8), e.attr.target, !1, !0);
  }
};
cg = Z([Kn('capture')], cg);
let pg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Jh(e.attr.target, t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
pg = Z([Kn('attr')], pg);
let fg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Jh('style', t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
fg = Z([Kn('style')], fg);
let yg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Jh('class', t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
yg = Z([Kn('class')], yg);
let hg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new X4(t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
hg = Z([Kn('ref')], hg);
let mg = class {
  get type() {
    return 1;
  }
  build(e) {
    return new e8();
  }
};
mg = Z([Kn('...$attrs')], mg);
const k8 = /* @__PURE__ */ Ut('ISVGAnalyzer', (n) => n.singleton(P8));
class P8 {
  isStandardSvgAttribute(e, t) {
    return !1;
  }
}
var bg;
(function (n) {
  (n[(n.oneTime = 1)] = 'oneTime'), (n[(n.toView = 2)] = 'toView'), (n[(n.fromView = 4)] = 'fromView'), (n[(n.twoWay = 6)] = 'twoWay'), (n[(n.default = 8)] = 'default');
})(bg || (bg = {}));
const gg = Jn();
class zu {
  static forNs(e) {
    return gg[e] ?? (gg[e] = new zu(e));
  }
  constructor(e) {
    (this.ns = e), (this.type = 6);
  }
  getValue(e, t) {
    return e.getAttributeNS(this.ns, t);
  }
  setValue(e, t, i) {
    e == null ? t.removeAttributeNS(this.ns, i) : t.setAttributeNS(this.ns, i, e);
  }
}
Wc(zu);
class X1 {
  constructor() {
    this.type = 6;
  }
  getValue(e, t) {
    return e.getAttribute(t);
  }
  setValue(e, t, i) {
    e == null ? t.removeAttribute(i) : t.setAttribute(i, e);
  }
}
Wc(X1);
const Cd = new X1(),
  N8 = {
    childList: !0,
    subtree: !0,
    characterData: !0,
  };
function vg(n, e) {
  return n === e;
}
class e0 {
  constructor(e, t, i, r) {
    (this.type = 7), (this.v = void 0), (this.ov = void 0), (this.j = !1), (this.Ee = void 0), (this.Pe = void 0), (this.iO = !1), (this.F = !1), (this.q = e), (this.oL = r), (this.cf = i);
  }
  getValue() {
    return this.iO ? this.v : this.q.multiple ? D8(this.q.options) : this.q.value;
  }
  setValue(e) {
    (this.ov = this.v), (this.v = e), (this.j = e !== this.ov), this.Le(e instanceof Array ? e : null), this.W();
  }
  W() {
    this.j && ((this.j = !1), this.syncOptions());
  }
  handleCollectionChange() {
    this.syncOptions();
  }
  syncOptions() {
    const e = this.v,
      t = this.q,
      i = tr(e),
      r = t.matcher ?? vg,
      s = t.options;
    let a = s.length;
    for (; a-- > 0; ) {
      const o = s[a],
        u = ys.call(o, 'model') ? o.model : o.value;
      if (i) {
        o.selected = e.findIndex((l) => !!r(u, l)) !== -1;
        continue;
      }
      o.selected = !!r(u, e);
    }
  }
  syncValue() {
    const e = this.q,
      t = e.options,
      i = t.length,
      r = this.v;
    let s = 0;
    if (e.multiple) {
      if (!(r instanceof Array)) return !0;
      let u;
      const l = e.matcher || vg,
        c = [];
      for (; s < i; ) (u = t[s]), u.selected && c.push(ys.call(u, 'model') ? u.model : u.value), ++s;
      let f;
      for (s = 0; s < r.length; ) (f = r[s]), c.findIndex((m) => !!l(f, m)) === -1 ? r.splice(s, 1) : ++s;
      for (s = 0; s < c.length; ) (f = c[s]), r.findIndex((m) => !!l(f, m)) === -1 && r.push(f), ++s;
      return !1;
    }
    let a = null,
      o;
    for (; s < i; ) {
      if (((o = t[s]), o.selected)) {
        a = ys.call(o, 'model') ? o.model : o.value;
        break;
      }
      ++s;
    }
    return (this.ov = this.v), (this.v = a), !0;
  }
  O() {
    (this.Pe = zh(this.q, this.Me.bind(this))).observe(this.q, N8), this.Le(this.v instanceof Array ? this.v : null), (this.iO = !0);
  }
  H() {
    this.Pe.disconnect(), this.Ee?.unsubscribe(this), (this.Pe = this.Ee = void 0), (this.iO = !1);
  }
  Le(e) {
    if ((this.Ee?.unsubscribe(this), (this.Ee = void 0), e != null)) {
      if (!this.q.multiple) throw se('AUR0654');
      (this.Ee = this.oL.getArrayObserver(e)).subscribe(this);
    }
  }
  handleEvent() {
    this.syncValue() && this.it();
  }
  Me(e) {
    this.syncOptions(), this.syncValue() && this.it();
  }
  it() {
    (xg = this.ov), (this.ov = this.v), this.subs.notify(this.v, xg);
  }
}
qh(e0);
Gn(e0);
function D8(n) {
  const e = [];
  if (n.length === 0) return e;
  const t = n.length;
  let i = 0,
    r;
  for (; t > i; ) (r = n[i]), r.selected && (e[e.length] = ys.call(r, 'model') ? r.model : r.value), ++i;
  return e;
}
let xg;
const B8 = '--';
class Z1 {
  constructor(e) {
    (this.obj = e), (this.type = 6), (this.v = ''), (this.ov = ''), (this.styles = {}), (this.version = 0), (this.j = !1);
  }
  getValue() {
    return this.obj.style.cssText;
  }
  setValue(e) {
    (this.v = e), (this.j = e !== this.ov), this.W();
  }
  De(e) {
    const t = [],
      i = /url\([^)]+$/;
    let r = 0,
      s = '',
      a,
      o,
      u,
      l;
    for (; r < e.length; ) {
      if (((a = e.indexOf(';', r)), a === -1 && (a = e.length), (s += e.substring(r, a)), (r = a + 1), i.test(s))) {
        s += ';';
        continue;
      }
      (o = s.indexOf(':')), (u = s.substring(0, o).trim()), (l = s.substring(o + 1).trim()), t.push([u, l]), (s = '');
    }
    return t;
  }
  $e(e) {
    let t, i;
    const r = [];
    for (i in e)
      if (((t = e[i]), t != null)) {
        if (Et(t)) {
          if (i.startsWith(B8)) {
            r.push([i, t]);
            continue;
          }
          r.push([bx(i), t]);
          continue;
        }
        r.push(...this.Ue(t));
      }
    return r;
  }
  qe(e) {
    const t = e.length;
    if (t > 0) {
      const i = [];
      let r = 0;
      for (; t > r; ++r) i.push(...this.Ue(e[r]));
      return i;
    }
    return je;
  }
  Ue(e) {
    return Et(e) ? this.De(e) : e instanceof Array ? this.qe(e) : e instanceof Object ? this.$e(e) : je;
  }
  W() {
    if (this.j) {
      this.j = !1;
      const e = this.v,
        t = this.styles,
        i = this.Ue(e);
      let r,
        s = this.version;
      this.ov = e;
      let a,
        o,
        u,
        l = 0;
      const c = i.length;
      for (; l < c; ++l) (a = i[l]), (o = a[0]), (u = a[1]), this.setProperty(o, u), (t[o] = s);
      if (((this.styles = t), (this.version += 1), s === 0)) return;
      s -= 1;
      for (r in t) !ys.call(t, r) || t[r] !== s || this.obj.style.removeProperty(r);
    }
  }
  setProperty(e, t) {
    let i = '';
    t != null && ei(t.indexOf) && t.includes('!important') && ((i = 'important'), (t = t.replace('!important', ''))), this.obj.style.setProperty(e, t, i);
  }
  bind() {
    this.v = this.ov = this.obj.style.cssText;
  }
}
Wc(Z1);
class t0 {
  constructor(e, t, i) {
    (this.type = 7), (this.v = ''), (this.ov = ''), (this.j = !1), (this.F = !1), (this.q = e), (this.k = t), (this.cf = i);
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    wl(e, this.v) || ((this.ov = this.v), (this.v = e), (this.j = !0), this.cf.readonly || this.W());
  }
  W() {
    this.j && ((this.j = !1), (this.q[this.k] = this.v ?? this.cf.default), this.it());
  }
  handleEvent() {
    (this.ov = this.v), (this.v = this.q[this.k]), this.ov !== this.v && ((this.j = !1), this.it());
  }
  O() {
    this.v = this.ov = this.q[this.k];
  }
  it() {
    (Tg = this.ov), (this.ov = this.v), this.subs.notify(this.v, Tg);
  }
}
qh(t0);
Gn(t0);
let Tg;
const Ys = 'http://www.w3.org/1999/xlink',
  wg = 'http://www.w3.org/XML/1998/namespace',
  Ag = 'http://www.w3.org/2000/xmlns/',
  Eg = Fh(Jn(), {
    'xlink:actuate': ['actuate', Ys],
    'xlink:arcrole': ['arcrole', Ys],
    'xlink:href': ['href', Ys],
    'xlink:role': ['role', Ys],
    'xlink:show': ['show', Ys],
    'xlink:title': ['title', Ys],
    'xlink:type': ['type', Ys],
    'xml:lang': ['lang', wg],
    'xml:space': ['space', wg],
    xmlns: ['xmlns', Ag],
    'xmlns:xlink': ['xlink', Ag],
  }),
  eT = new u1();
eT.type = 6;
class Gu {
  constructor(e, t, i, r) {
    (this.locator = e), (this.platform = t), (this.dirtyChecker = i), (this.svgAnalyzer = r), (this.allowDirtyCheck = !0), (this.Fe = Jn()), (this.Oe = Jn()), (this.He = Jn()), (this.Ve = Jn());
    const s = ['change', 'input'],
      a = {
        events: s,
        default: '',
      };
    this.useConfig({
      INPUT: {
        value: a,
        valueAsNumber: {
          events: s,
          default: 0,
        },
        checked: {
          type: n0,
          events: s,
        },
        files: {
          events: s,
          readonly: !0,
        },
      },
      SELECT: {
        value: {
          type: e0,
          events: ['change'],
          default: '',
        },
      },
      TEXTAREA: {
        value: a,
      },
    });
    const o = {
        events: ['change', 'input', 'blur', 'keyup', 'paste'],
        default: '',
      },
      u = {
        events: ['scroll'],
        default: 0,
      };
    this.useConfigGlobal({
      scrollTop: u,
      scrollLeft: u,
      textContent: o,
      innerHTML: o,
    }),
      this.overrideAccessorGlobal('css', 'style', 'class'),
      this.overrideAccessor({
        INPUT: ['value', 'checked', 'model'],
        SELECT: ['value'],
        TEXTAREA: ['value'],
      });
  }
  static register(e) {
    Al(Qd, Gu).register(e), $o(Qd, Gu).register(e);
  }
  handles(e, t) {
    return e instanceof this.platform.Node;
  }
  useConfig(e, t, i) {
    const r = this.Fe;
    let s;
    if (Et(e)) (s = r[e] ?? (r[e] = Jn())), s[t] == null ? (s[t] = i) : td(e, t);
    else
      for (const a in e) {
        s = r[a] ?? (r[a] = Jn());
        const o = e[a];
        for (t in o) s[t] == null ? (s[t] = o[t]) : td(a, t);
      }
  }
  useConfigGlobal(e, t) {
    const i = this.Oe;
    if (typeof e == 'object') for (const r in e) i[r] == null ? (i[r] = e[r]) : td('*', r);
    else i[e] == null ? (i[e] = t) : td('*', e);
  }
  getAccessor(e, t, i) {
    if (t in this.Ve || t in (this.He[e.tagName] ?? N3)) return this.getObserver(e, t, i);
    switch (t) {
      case 'src':
      case 'href':
      case 'role':
      case 'minLength':
      case 'maxLength':
      case 'placeholder':
      case 'size':
      case 'pattern':
      case 'title':
        return Cd;
      default: {
        const r = Eg[t];
        return r !== void 0 ? zu.forNs(r[1]) : pb(e, t, this.svgAnalyzer) ? Cd : eT;
      }
    }
  }
  overrideAccessor(e, t) {
    var i, r;
    let s;
    if (Et(e)) (s = (i = this.He)[e] ?? (i[e] = Jn())), (s[t] = !0);
    else for (const a in e) for (const o of e[a]) (s = (r = this.He)[a] ?? (r[a] = Jn())), (s[o] = !0);
  }
  overrideAccessorGlobal(...e) {
    for (const t of e) this.Ve[t] = !0;
  }
  getNodeObserverConfig(e, t) {
    return this.Fe[e.tagName]?.[t] ?? this.Oe[t];
  }
  getNodeObserver(e, t, i) {
    const r = this.Fe[e.tagName]?.[t] ?? this.Oe[t];
    let s;
    return r != null ? ((s = new (r.type ?? t0)(e, t, r, i, this.locator)), s.doNotCache || (d1(e)[t] = s), s) : null;
  }
  getObserver(e, t, i) {
    switch (t) {
      case 'class':
        return new M1(e);
      case 'css':
      case 'style':
        return new Z1(e);
    }
    const r = this.getNodeObserver(e, t, i);
    if (r != null) return r;
    const s = Eg[t];
    if (s !== void 0) return zu.forNs(s[1]);
    if (pb(e, t, this.svgAnalyzer)) return Cd;
    if (t in e.constructor.prototype) {
      if (this.allowDirtyCheck) return this.dirtyChecker.createProperty(e, t);
      throw se(`AUR0652:${Lo(t)}`);
    } else return new Ph(e, t);
  }
}
Gu.inject = [A3, zr, s1, k8];
function F8(n, e) {
  if (n instanceof Array) return e.getArrayObserver(n);
  if (n instanceof Map) return e.getMapObserver(n);
  if (n instanceof Set) return e.getSetObserver(n);
}
function td(n, e) {
  throw se(`AUR0653:${Lo(e)}@${n}`);
}
function Sg(n, e) {
  return n === e;
}
class n0 {
  constructor(e, t, i, r) {
    (this.type = 7), (this.v = void 0), (this.ov = void 0), (this.Ne = void 0), (this.je = void 0), (this.F = !1), (this.q = e), (this.oL = r), (this.cf = i);
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    const t = this.v;
    e !== t && ((this.v = e), (this.ov = t), this.We(), this.ze(), this.it());
  }
  handleCollectionChange() {
    this.ze();
  }
  handleChange(e, t) {
    this.ze();
  }
  ze() {
    const e = this.v,
      t = this.q,
      i = ys.call(t, 'model') ? t.model : t.value,
      r = t.type === 'radio',
      s = t.matcher !== void 0 ? t.matcher : Sg;
    if (r) t.checked = !!s(e, i);
    else if (e === !0) t.checked = !0;
    else {
      let a = !1;
      if (tr(e)) a = e.findIndex((o) => !!s(o, i)) !== -1;
      else if (e instanceof Set) {
        for (const o of e)
          if (s(o, i)) {
            a = !0;
            break;
          }
      } else if (e instanceof Map)
        for (const o of e) {
          const u = o[0],
            l = o[1];
          if (s(u, i) && l === !0) {
            a = !0;
            break;
          }
        }
      t.checked = a;
    }
  }
  handleEvent() {
    let e = (this.ov = this.v);
    const t = this.q,
      i = ys.call(t, 'model') ? t.model : t.value,
      r = t.checked,
      s = t.matcher !== void 0 ? t.matcher : Sg;
    if (t.type === 'checkbox') {
      if (tr(e)) {
        const a = e.findIndex((o) => !!s(o, i));
        r && a === -1 ? e.push(i) : !r && a !== -1 && e.splice(a, 1);
        return;
      } else if (e instanceof Set) {
        const a = {};
        let o = a;
        for (const u of e)
          if (s(u, i) === !0) {
            o = u;
            break;
          }
        r && o === a ? e.add(i) : !r && o !== a && e.delete(o);
        return;
      } else if (e instanceof Map) {
        let a;
        for (const o of e) {
          const u = o[0];
          if (s(u, i) === !0) {
            a = u;
            break;
          }
        }
        e.set(a, r);
        return;
      }
      e = r;
    } else if (r) e = i;
    else return;
    (this.v = e), this.it();
  }
  O() {
    this.We();
  }
  H() {
    this.Ne?.unsubscribe(this), this.je?.unsubscribe(this), (this.Ne = this.je = void 0);
  }
  it() {
    (Cg = this.ov), (this.ov = this.v), this.subs.notify(this.v, Cg);
  }
  We() {
    const e = this.q;
    (this.je ?? (this.je = e.$observers?.model ?? e.$observers?.value))?.subscribe(this),
      this.Ne?.unsubscribe(this),
      (this.Ne = void 0),
      e.type === 'checkbox' && (this.Ne = F8(this.v, this.oL))?.subscribe(this);
  }
}
qh(n0);
Gn(n0);
let Cg;
class L8 {
  bind(e, t) {
    if (!(t instanceof Gr)) throw se('AURxxxx');
    t.useTargetObserver(Cd);
  }
}
Hn('attr')(L8);
class $8 {
  bind(e, t) {
    if (!(t instanceof Il)) throw se('AUR0801');
    t.self = !0;
  }
  unbind(e, t) {
    t.self = !1;
  }
}
Hn('self')($8);
class tT {
  constructor(e, t) {
    if (!(t instanceof Gu))
      throw se('AURxxxx: updateTrigger binding behavior only works with the default implementation of Aurelia HTML observation. Implement your own node observation + updateTrigger');
    (this.oL = e), (this.Ge = t);
  }
  bind(e, t, ...i) {
    if (i.length === 0) throw se('AUR0802');
    if (!(t instanceof Gr) || !(t.mode & 4)) throw se('AUR0803');
    const r = this.Ge.getNodeObserverConfig(t.target, t.targetProperty);
    if (r == null) throw se('AURxxxx');
    const s = this.Ge.getNodeObserver(t.target, t.targetProperty, this.oL);
    s.useConfig({
      readonly: r.readonly,
      default: r.default,
      events: i,
    }),
      t.useTargetObserver(s);
  }
}
tT.inject = [Ra, Qd];
Hn('updateTrigger')(tT);
class go {
  constructor(e, t) {
    (this.elseFactory = void 0),
      (this.elseView = void 0),
      (this.ifView = void 0),
      (this.view = void 0),
      (this.value = !1),
      (this.cache = !0),
      (this.pending = void 0),
      (this.Xe = !1),
      (this.Ke = 0),
      (this.Qe = e),
      (this.l = t);
  }
  attaching(e, t) {
    let i;
    const r = this.$controller,
      s = this.Ke++,
      a = () => !this.Xe && this.Ke === s + 1;
    return Re(this.pending, () => {
      a() &&
        ((this.pending = void 0),
        this.value
          ? (i = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this.Qe.create())
          : (i = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create()),
        i != null &&
          (i.setLocation(this.l),
          (this.pending = Re(i.activate(e, r, r.scope), () => {
            a() && (this.pending = void 0);
          }))));
    });
  }
  detaching(e, t) {
    return (
      (this.Xe = !0),
      Re(this.pending, () => {
        (this.Xe = !1), (this.pending = void 0), this.view?.deactivate(e, this.$controller);
      })
    );
  }
  valueChanged(e, t) {
    if (!this.$controller.isActive || ((e = !!e), (t = !!t), e === t)) return;
    const i = this.view,
      r = this.$controller,
      s = this.Ke++,
      a = () => !this.Xe && this.Ke === s + 1;
    let o;
    return Re(
      this.pending,
      () =>
        (this.pending = Re(i?.deactivate(i, r), () => {
          if (
            a() &&
            (e
              ? (o = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this.Qe.create())
              : (o = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create()),
            o != null)
          )
            return (
              o.setLocation(this.l),
              Re(o.activate(o, r, r.scope), () => {
                a() && (this.pending = void 0);
              })
            );
        })),
    );
  }
  dispose() {
    this.ifView?.dispose(), this.elseView?.dispose(), (this.ifView = this.elseView = this.view = void 0);
  }
  accept(e) {
    if (this.view?.accept(e) === !0) return !0;
  }
}
go.inject = [ni, On];
Z([Ue], go.prototype, 'value', void 0);
Z(
  [
    Ue({
      set: (n) => n === '' || (!!n && n !== 'false'),
    }),
  ],
  go.prototype,
  'cache',
  void 0,
);
bi('if')(go);
class nT {
  constructor(e) {
    this.f = e;
  }
  link(e, t, i, r) {
    const s = e.children,
      a = s[s.length - 1];
    if (a instanceof go) a.elseFactory = this.f;
    else if (a.viewModel instanceof go) a.viewModel.elseFactory = this.f;
    else throw se('AUR0810');
  }
}
nT.inject = [ni];
bi({
  name: 'else',
})(nT);
function U8(n) {
  n.dispose();
}
const j8 = [18, 17];
class i0 {
  constructor(e, t, i, r, s) {
    (this.views = []),
      (this.key = null),
      (this.Ye = /* @__PURE__ */ new Map()),
      (this.Ze = /* @__PURE__ */ new Map()),
      (this.Je = void 0),
      (this.ti = !1),
      (this.ei = !1),
      (this.ii = null),
      (this.si = void 0),
      (this.ni = !1);
    const a = e.props[0].props[0];
    if (a !== void 0) {
      const { to: o, value: u, command: l } = a;
      if (o === 'key')
        if (l === null) this.key = u;
        else if (l === 'bind') this.key = t.parse(u, 16);
        else throw se(`AUR775:${l}`);
      else throw se(`AUR776:${o}`);
    }
    (this.l = i), (this.ri = r), (this.f = s);
  }
  binding(e, t) {
    const i = this.ri.bindings,
      r = i.length;
    let s,
      a,
      o = 0;
    for (; r > o; ++o)
      if (((s = i[o]), s.target === this && s.targetProperty === 'items')) {
        (a = this.forOf = s.ast), (this.oi = s);
        let l = a.iterable;
        for (; l != null && j8.includes(l.$kind); ) (l = l.expression), (this.ti = !0);
        this.ii = l;
        break;
      }
    this.li();
    const u = a.declaration;
    (this.ni = u.$kind === 24 || u.$kind === 25) || (this.local = G(u, this.$controller.scope, s, null));
  }
  attaching(e, t) {
    return this.hi(), this.ai(e);
  }
  detaching(e, t) {
    return this.li(), this.ui(e);
  }
  unbinding(e, t) {
    this.Ze.clear(), this.Ye.clear();
  }
  itemsChanged() {
    this.$controller.isActive && (this.li(), this.hi(), this.fi(this.items, void 0));
  }
  handleCollectionChange(e, t) {
    const i = this.$controller;
    if (i.isActive) {
      if (this.ti) {
        if (this.ei) return;
        (this.ei = !0), (this.items = G(this.forOf.iterable, i.scope, this.oi, null)), (this.ei = !1);
        return;
      }
      this.hi(), this.fi(e, t);
    }
  }
  fi(e, t) {
    const i = this.views,
      r = i.length,
      s = this.key,
      a = s !== null;
    if (a || t === void 0) {
      const o = this.local,
        u = this.si,
        l = u.length,
        c = this.forOf,
        f = c.declaration,
        m = this.oi,
        w = this.ni;
      t = ca(l);
      let v = 0;
      if (r === 0) for (; v < l; ++v) t[v] = -2;
      else if (l === 0)
        if (w) for (v = 0; v < r; ++v) t.deletedIndices.push(v), t.deletedItems.push(G(f, i[v].scope, m, null));
        else for (v = 0; v < r; ++v) t.deletedIndices.push(v), t.deletedItems.push(i[v].scope.bindingContext[o]);
      else {
        const T = Array(r);
        if (w) for (v = 0; v < r; ++v) T[v] = G(f, i[v].scope, m, null);
        else for (v = 0; v < r; ++v) T[v] = i[v].scope.bindingContext[o];
        let A,
          _,
          O,
          B,
          P = 0;
        const N = r - 1,
          U = l - 1,
          W = /* @__PURE__ */ new Map(),
          z = /* @__PURE__ */ new Map(),
          Y = this.Ye,
          ue = this.Ze,
          J = this.$controller.scope;
        v = 0;
        e: {
          for (;;) {
            if (
              (a ? ((A = T[v]), (_ = u[v]), (O = ja(Y, s, A, Xs(ue, A, c, J, m, o, w), m)), (B = ja(Y, s, _, Xs(ue, _, c, J, m, o, w), m))) : ((A = O = Zs(T[v], v)), (_ = B = Zs(u[v], v))), O !== B)
            ) {
              Y.set(A, O), Y.set(_, B);
              break;
            }
            if ((++v, v > N || v > U)) break e;
          }
          if (N !== U) break e;
          for (P = U; ; ) {
            if (
              (a ? ((A = T[P]), (_ = u[P]), (O = ja(Y, s, A, Xs(ue, A, c, J, m, o, w), m)), (B = ja(Y, s, _, Xs(ue, _, c, J, m, o, w), m))) : ((A = O = Zs(T[v], v)), (_ = B = Zs(u[v], v))), O !== B)
            ) {
              Y.set(A, O), Y.set(_, B);
              break;
            }
            if ((--P, v > P)) break e;
          }
        }
        const le = v,
          C = v;
        for (v = C; v <= U; ++v) Y.has((_ = a ? u[v] : Zs(u[v], v))) ? (B = Y.get(_)) : ((B = a ? ja(Y, s, _, Xs(ue, _, c, J, m, o, w), m) : _), Y.set(_, B)), z.set(B, v);
        for (v = le; v <= N; ++v)
          Y.has((A = a ? T[v] : Zs(T[v], v))) ? (O = Y.get(A)) : (O = a ? ja(Y, s, A, i[v].scope, m) : A),
            W.set(O, v),
            z.has(O) ? (t[z.get(O)] = v) : (t.deletedIndices.push(v), t.deletedItems.push(A));
        for (v = C; v <= U; ++v) W.has(Y.get(a ? u[v] : Zs(u[v], v))) || (t[v] = -2);
        W.clear(), z.clear();
      }
    }
    if (t === void 0) {
      const o = Re(this.ui(null), () => this.ai(null));
      un(o) && o.catch(Yd);
    } else {
      const o = bA(t);
      if (o.deletedIndices.length > 0) {
        const u = Re(this.di(o), () => this.mi(r, o));
        un(u) && u.catch(Yd);
      } else this.mi(r, o);
    }
  }
  li() {
    const e = this.$controller.scope;
    let t = this.gi,
      i = this.ti,
      r;
    i && ((t = this.gi = G(this.ii, e, this.oi, null) ?? null), (i = this.ti = !wl(this.items, t)));
    const s = this.Je;
    this.$controller.isActive ? ((r = this.Je = QE(i ? t : this.items)), s !== r && (s?.unsubscribe(this), r?.subscribe(this))) : (s?.unsubscribe(this), (this.Je = void 0));
  }
  hi() {
    const { items: e } = this;
    if (tr(e)) {
      this.si = e;
      return;
    }
    const t = [];
    Mg(e, (i, r) => {
      t[r] = i;
    }),
      (this.si = t);
  }
  ai(e) {
    let t, i, r, s;
    const { $controller: a, f: o, local: u, l, items: c, Ze: f, oi: m, forOf: w, ni: v } = this,
      T = a.scope,
      A = G8(c),
      _ = (this.views = Array(A));
    if (
      (Mg(c, (O, B) => {
        (r = _[B] = o.create().setLocation(l)), r.nodes.unlink(), (s = Xs(f, O, w, T, m, u, v)), id(s.overrideContext, B, A), (i = r.activate(e ?? r, a, s)), un(i) && (t ?? (t = [])).push(i);
      }),
      t !== void 0)
    )
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  ui(e) {
    let t,
      i,
      r,
      s = 0;
    const { views: a, $controller: o } = this,
      u = a.length;
    for (; u > s; ++s) (r = a[s]), r.release(), (i = r.deactivate(e ?? r, o)), un(i) && (t ?? (t = [])).push(i);
    if (t !== void 0) return t.length === 1 ? t[0] : Promise.all(t);
  }
  di(e) {
    let t, i, r;
    const { $controller: s, views: a } = this,
      o = e.deletedIndices,
      u = o.length;
    let l = 0;
    for (; u > l; ++l) (r = a[o[l]]), r.release(), (i = r.deactivate(r, s)), un(i) && (t ?? (t = [])).push(i);
    l = 0;
    let c = 0;
    for (; u > l; ++l) (c = o[l] - l), a.splice(c, 1);
    if (t !== void 0) return t.length === 1 ? t[0] : Promise.all(t);
  }
  mi(e, t) {
    let i,
      r,
      s,
      a,
      o = 0;
    const { $controller: u, f: l, local: c, si: f, l: m, views: w, ni: v, oi: T, Ze: A, forOf: _ } = this,
      O = t.length;
    for (; O > o; ++o) t[o] === -2 && ((s = l.create()), w.splice(o, 0, s));
    if (w.length !== O) throw z8(w.length, O);
    const B = u.scope,
      P = t.length;
    gA(w, t);
    const N = V8(t),
      U = N.length,
      W = _.declaration;
    let z,
      Y = U - 1;
    for (o = P - 1; o >= 0; --o)
      (s = w[o]),
        (z = w[o + 1]),
        s.nodes.link(z?.nodes ?? m),
        t[o] === -2
          ? ((a = Xs(A, f[o], _, B, T, c, v)), id(a.overrideContext, o, P), s.setLocation(m), (r = s.activate(s, u, a)), un(r) && (i ?? (i = [])).push(r))
          : Y < 0 || U === 1 || o !== N[Y]
          ? (v ? bn(W, s.scope, T, f[o]) : (s.scope.bindingContext[c] = f[o]), id(s.scope.overrideContext, o, P), s.nodes.insertBefore(s.location))
          : (v ? bn(W, s.scope, T, f[o]) : (s.scope.bindingContext[c] = f[o]), e !== P && id(s.scope.overrideContext, o, P), --Y);
    if (i !== void 0) return i.length === 1 ? i[0] : Promise.all(i);
  }
  dispose() {
    this.views.forEach(U8), (this.views = void 0);
  }
  accept(e) {
    const { views: t } = this;
    if (t !== void 0) {
      for (let i = 0, r = t.length; i < r; ++i) if (t[i].accept(e) === !0) return !0;
    }
  }
}
i0.inject = [jo, Eh, On, Yc, ni];
Z([Ue], i0.prototype, 'items', void 0);
bi('repeat')(i0);
let ic = 16,
  cr = new Int32Array(ic),
  nd = new Int32Array(ic);
function V8(n) {
  const e = n.length;
  e > ic && ((ic = e), (cr = new Int32Array(e)), (nd = new Int32Array(e)));
  let t = 0,
    i = 0,
    r = 0,
    s = 0,
    a = 0,
    o = 0,
    u = 0,
    l = 0;
  for (; s < e; s++)
    if (((i = n[s]), i !== -2)) {
      if (((a = cr[t]), (r = n[a]), r !== -2 && r < i)) {
        (nd[s] = a), (cr[++t] = s);
        continue;
      }
      for (o = 0, u = t; o < u; ) (l = (o + u) >> 1), (r = n[cr[l]]), r !== -2 && r < i ? (o = l + 1) : (u = l);
      (r = n[cr[o]]), (i < r || r === -2) && (o > 0 && (nd[s] = cr[o - 1]), (cr[o] = s));
    }
  s = ++t;
  const c = new Int32Array(s);
  for (i = cr[t - 1]; t-- > 0; ) (c[t] = i), (i = nd[i]);
  for (; s-- > 0; ) cr[s] = 0;
  return c;
}
const z8 = (n, e) => se(`AUR0814:${n}!=${e}`),
  id = (n, e, t) => {
    const i = e === 0,
      r = e === t - 1,
      s = e % 2 === 0;
    (n.$index = e), (n.$first = i), (n.$last = r), (n.$middle = !i && !r), (n.$even = s), (n.$odd = !s), (n.$length = t);
  },
  rc = Bh.toString,
  G8 = (n) => {
    switch (rc.call(n)) {
      case '[object Array]':
        return n.length;
      case '[object Map]':
        return n.size;
      case '[object Set]':
        return n.size;
      case '[object Number]':
        return n;
      case '[object Null]':
        return 0;
      case '[object Undefined]':
        return 0;
      default:
        throw se(`Cannot count ${rc.call(n)}`);
    }
  },
  Mg = (n, e) => {
    switch (rc.call(n)) {
      case '[object Array]':
        return q8(n, e);
      case '[object Map]':
        return H8(n, e);
      case '[object Set]':
        return K8(n, e);
      case '[object Number]':
        return W8(n, e);
      case '[object Null]':
        return;
      case '[object Undefined]':
        return;
      default:
        throw se(`Cannot iterate over ${rc.call(n)}`);
    }
  },
  q8 = (n, e) => {
    const t = n.length;
    let i = 0;
    for (; i < t; ++i) e(n[i], i, n);
  },
  H8 = (n, e) => {
    let t = -0,
      i;
    for (i of n.entries()) e(i, t++, n);
  },
  K8 = (n, e) => {
    let t = 0,
      i;
    for (i of n.keys()) e(i, t++, n);
  },
  W8 = (n, e) => {
    let t = 0;
    for (; t < n; ++t) e(t, t, n);
  },
  ja = (n, e, t, i, r) => {
    let s = n.get(t);
    return s === void 0 && (typeof e == 'string' ? (s = t[e]) : (s = G(e, i, r, null)), n.set(t, s)), s;
  },
  Xs = (n, e, t, i, r, s, a) => {
    let o = n.get(e);
    return o === void 0 && (a ? bn(t.declaration, (o = pn.fromParent(i, new Rm())), r, e) : (o = pn.fromParent(i, new Rm(s, e))), n.set(e, o)), o;
  },
  Zs = (n, e) => {
    const t = typeof n;
    switch (t) {
      case 'object':
        if (n !== null) return n;
      case 'string':
      case 'number':
      case 'bigint':
      case 'undefined':
      case 'boolean':
        return `${e}${t}${n}`;
      default:
        return n;
    }
  };
class r0 {
  constructor(e, t) {
    this.view = e.create().setLocation(t);
  }
  valueChanged(e, t) {
    const i = this.$controller,
      r = this.view.bindings;
    let s,
      a = 0,
      o = 0;
    if (i.isActive && r != null) for (s = pn.fromParent(i.scope, e === void 0 ? {} : e), o = r.length; o > a; ++a) r[a].bind(s);
  }
  attaching(e, t) {
    const { $controller: i, value: r } = this,
      s = pn.fromParent(i.scope, r === void 0 ? {} : r);
    return this.view.activate(e, i, s);
  }
  detaching(e, t) {
    return this.view.deactivate(e, this.$controller);
  }
  dispose() {
    this.view.dispose(), (this.view = void 0);
  }
  accept(e) {
    if (this.view?.accept(e) === !0) return !0;
  }
}
r0.inject = [ni, On];
Z([Ue], r0.prototype, 'value', void 0);
bi('with')(r0);
let sc = class {
  constructor(e, t) {
    (this.f = e), (this.l = t), (this.cases = []), (this.activeCases = []), (this.promise = void 0);
  }
  link(e, t, i, r) {
    this.view = this.f.create(this.$controller).setLocation(this.l);
  }
  attaching(e, t) {
    const i = this.view,
      r = this.$controller;
    return this.queue(() => i.activate(e, r, r.scope)), this.queue(() => this.swap(e, this.value)), this.promise;
  }
  detaching(e, t) {
    return this.queue(() => this.view.deactivate(e, this.$controller)), this.promise;
  }
  dispose() {
    this.view?.dispose(), (this.view = void 0);
  }
  valueChanged(e, t) {
    this.$controller.isActive && this.queue(() => this.swap(null, this.value));
  }
  caseChanged(e) {
    this.queue(() => this.pi(e));
  }
  pi(e) {
    const t = e.isMatch(this.value),
      i = this.activeCases,
      r = i.length;
    if (!t) return r > 0 && i[0].id === e.id ? this.vi(null) : void 0;
    if (r > 0 && i[0].id < e.id) return;
    const s = [];
    let a = e.fallThrough;
    if (!a) s.push(e);
    else {
      const o = this.cases,
        u = o.indexOf(e);
      for (let l = u, c = o.length; l < c && a; l++) {
        const f = o[l];
        s.push(f), (a = f.fallThrough);
      }
    }
    return Re(this.vi(null, s), () => ((this.activeCases = s), this.bi(null)));
  }
  swap(e, t) {
    const i = [];
    let r = !1;
    for (const a of this.cases) if (((r || a.isMatch(t)) && (i.push(a), (r = a.fallThrough)), i.length > 0 && !r)) break;
    const s = this.defaultCase;
    return (
      i.length === 0 && s !== void 0 && i.push(s),
      Re(this.activeCases.length > 0 ? this.vi(e, i) : void 0, () => {
        if (((this.activeCases = i), i.length !== 0)) return this.bi(e);
      })
    );
  }
  bi(e) {
    const t = this.$controller;
    if (!t.isActive) return;
    const i = this.activeCases,
      r = i.length;
    if (r === 0) return;
    const s = t.scope;
    return r === 1 ? i[0].activate(e, s) : Yt(...i.map((a) => a.activate(e, s)));
  }
  vi(e, t = []) {
    const i = this.activeCases,
      r = i.length;
    if (r !== 0) {
      if (r === 1) {
        const s = i[0];
        return t.includes(s) ? void 0 : ((i.length = 0), s.deactivate(e));
      }
      return Re(Yt(...i.reduce((s, a) => (t.includes(a) || s.push(a.deactivate(e)), s), [])), () => {
        i.length = 0;
      });
    }
  }
  queue(e) {
    const t = this.promise;
    let i;
    i = this.promise = Re(Re(t, e), () => {
      this.promise === i && (this.promise = void 0);
    });
  }
  accept(e) {
    if (this.$controller.accept(e) === !0 || this.activeCases.some((t) => t.accept(e))) return !0;
  }
};
Z([Ue], sc.prototype, 'value', void 0);
sc = Z([bi('switch'), Tn(0, ni), Tn(1, On)], sc);
let J8 = 0,
  vo = class {
    constructor(e, t, i, r) {
      (this.f = e),
        (this.xi = t),
        (this.l = i),
        (this.id = ++J8),
        (this.fallThrough = !1),
        (this.view = void 0),
        (this.wi = r.config.level <= 1),
        (this.yi = r.scopeTo(`${this.constructor.name}-#${this.id}`));
    }
    link(e, t, i, r) {
      const a = e.parent?.viewModel;
      if (a instanceof sc) (this.$switch = a), this.linkToSwitch(a);
      else throw se('AUR0815');
    }
    detaching(e, t) {
      return this.deactivate(e);
    }
    isMatch(e) {
      this.yi.debug('isMatch()');
      const t = this.value;
      return tr(t) ? (this.Je === void 0 && (this.Je = this.ki(t)), t.includes(e)) : t === e;
    }
    valueChanged(e, t) {
      tr(e) ? (this.Je?.unsubscribe(this), (this.Je = this.ki(e))) : this.Je !== void 0 && this.Je.unsubscribe(this), this.$switch.caseChanged(this);
    }
    handleCollectionChange() {
      this.$switch.caseChanged(this);
    }
    activate(e, t) {
      let i = this.view;
      if ((i === void 0 && (i = this.view = this.f.create().setLocation(this.l)), !i.isActive)) return i.activate(e ?? i, this.$controller, t);
    }
    deactivate(e) {
      const t = this.view;
      if (!(t === void 0 || !t.isActive)) return t.deactivate(e ?? t, this.$controller);
    }
    dispose() {
      this.Je?.unsubscribe(this), this.view?.dispose(), (this.view = void 0);
    }
    linkToSwitch(e) {
      e.cases.push(this);
    }
    ki(e) {
      const t = this.xi.getArrayObserver(e);
      return t.subscribe(this), t;
    }
    accept(e) {
      return this.$controller.accept(e) === !0 ? !0 : this.view?.accept(e);
    }
  };
vo.inject = [ni, Ra, On, _a];
Z([Ue], vo.prototype, 'value', void 0);
Z(
  [
    Ue({
      set: (n) => {
        switch (n) {
          case 'true':
            return !0;
          case 'false':
            return !1;
          default:
            return !!n;
        }
      },
      mode: 1,
    }),
  ],
  vo.prototype,
  'fallThrough',
  void 0,
);
vo = Z([bi('case')], vo);
let _g = class extends vo {
  linkToSwitch(e) {
    if (e.defaultCase !== void 0) throw se('AUR0816');
    e.defaultCase = this;
  }
};
_g = Z([bi('default-case')], _g);
let ac = class {
  constructor(e, t, i, r) {
    (this.f = e), (this.l = t), (this.p = i), (this.preSettledTask = null), (this.postSettledTask = null), (this.logger = r.scopeTo('promise.resolve'));
  }
  link(e, t, i, r) {
    this.view = this.f.create(this.$controller).setLocation(this.l);
  }
  attaching(e, t) {
    const i = this.view,
      r = this.$controller;
    return Re(i.activate(e, r, (this.viewScope = pn.fromParent(r.scope, {}))), () => this.swap(e));
  }
  valueChanged(e, t) {
    this.$controller.isActive && this.swap(null);
  }
  swap(e) {
    const t = this.value;
    if (!un(t)) {
      this.logger.warn(`The value '${Lo(t)}' is not a promise. No change will be done.`);
      return;
    }
    const i = this.p.domWriteQueue,
      r = this.fulfilled,
      s = this.rejected,
      a = this.pending,
      o = this.viewScope;
    let u;
    const l = {
        reusable: !1,
      },
      c = () => {
        Yt(
          (u = (this.preSettledTask = i.queueTask(() => Yt(r?.deactivate(e), s?.deactivate(e), a?.activate(e, o)), l)).result.catch((f) => {
            if (!(f instanceof t4)) throw f;
          })),
          t.then(
            (f) => {
              if (this.value !== t) return;
              const m = () => {
                this.postSettlePromise = (this.postSettledTask = i.queueTask(() => Yt(a?.deactivate(e), s?.deactivate(e), r?.activate(e, o, f)), l)).result;
              };
              this.preSettledTask.status === 1 ? u.then(m) : (this.preSettledTask.cancel(), m());
            },
            (f) => {
              if (this.value !== t) return;
              const m = () => {
                this.postSettlePromise = (this.postSettledTask = i.queueTask(() => Yt(a?.deactivate(e), r?.deactivate(e), s?.activate(e, o, f)), l)).result;
              };
              this.preSettledTask.status === 1 ? u.then(m) : (this.preSettledTask.cancel(), m());
            },
          ),
        );
      };
    this.postSettledTask?.status === 1 ? this.postSettlePromise.then(c) : (this.postSettledTask?.cancel(), c());
  }
  detaching(e, t) {
    return this.preSettledTask?.cancel(), this.postSettledTask?.cancel(), (this.preSettledTask = this.postSettledTask = null), this.view.deactivate(e, this.$controller);
  }
  dispose() {
    this.view?.dispose(), (this.view = void 0);
  }
};
Z([Ue], ac.prototype, 'value', void 0);
ac = Z([bi('promise'), Tn(0, ni), Tn(1, On), Tn(2, zr), Tn(3, _a)], ac);
let hy = class {
  constructor(e, t) {
    (this.f = e), (this.l = t), (this.view = void 0);
  }
  link(e, t, i, r) {
    s0(e).pending = this;
  }
  activate(e, t) {
    let i = this.view;
    if ((i === void 0 && (i = this.view = this.f.create().setLocation(this.l)), !i.isActive)) return i.activate(i, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive)) return t.deactivate(t, this.$controller);
  }
  detaching(e) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), (this.view = void 0);
  }
};
Z(
  [
    Ue({
      mode: 2,
    }),
  ],
  hy.prototype,
  'value',
  void 0,
);
hy = Z([bi('pending'), Tn(0, ni), Tn(1, On)], hy);
let my = class {
  constructor(e, t) {
    (this.f = e), (this.l = t), (this.view = void 0);
  }
  link(e, t, i, r) {
    s0(e).fulfilled = this;
  }
  activate(e, t, i) {
    this.value = i;
    let r = this.view;
    if ((r === void 0 && (r = this.view = this.f.create().setLocation(this.l)), !r.isActive)) return r.activate(r, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive)) return t.deactivate(t, this.$controller);
  }
  detaching(e, t) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), (this.view = void 0);
  }
};
Z(
  [
    Ue({
      mode: 4,
    }),
  ],
  my.prototype,
  'value',
  void 0,
);
my = Z([bi('then'), Tn(0, ni), Tn(1, On)], my);
let by = class {
  constructor(e, t) {
    (this.f = e), (this.l = t), (this.view = void 0);
  }
  link(e, t, i, r) {
    s0(e).rejected = this;
  }
  activate(e, t, i) {
    this.value = i;
    let r = this.view;
    if ((r === void 0 && (r = this.view = this.f.create().setLocation(this.l)), !r.isActive)) return r.activate(r, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive)) return t.deactivate(t, this.$controller);
  }
  detaching(e, t) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), (this.view = void 0);
  }
};
Z(
  [
    Ue({
      mode: 4,
    }),
  ],
  by.prototype,
  'value',
  void 0,
);
by = Z([bi('catch'), Tn(0, ni), Tn(1, On)], by);
function s0(n) {
  const t = n.parent?.viewModel;
  if (t instanceof ac) return t;
  throw se('AUR0813');
}
let Rg = class {
  'promise.resolve'(e, t, i) {
    return new hi(e, t, 'promise', 'bind');
  }
};
Rg = Z(
  [
    Hr({
      pattern: 'promise.resolve',
      symbols: '',
    }),
  ],
  Rg,
);
let Ig = class {
  then(e, t, i) {
    return new hi(e, t, 'then', 'from-view');
  }
};
Ig = Z(
  [
    Hr({
      pattern: 'then',
      symbols: '',
    }),
  ],
  Ig,
);
let Og = class {
  catch(e, t, i) {
    return new hi(e, t, 'catch', 'from-view');
  }
};
Og = Z(
  [
    Hr({
      pattern: 'catch',
      symbols: '',
    }),
  ],
  Og,
);
class a0 {
  constructor(e, t) {
    (this.Ai = !1), (this.Ci = e), (this.p = t);
  }
  binding() {
    this.valueChanged();
  }
  valueChanged() {
    this.$controller.isActive ? this.Ri() : (this.Ai = !0);
  }
  attached() {
    this.Ai && ((this.Ai = !1), this.Ri()), this.Ci.addEventListener('focus', this), this.Ci.addEventListener('blur', this);
  }
  detaching() {
    const e = this.Ci;
    e.removeEventListener('focus', this), e.removeEventListener('blur', this);
  }
  handleEvent(e) {
    e.type === 'focus' ? (this.value = !0) : this.Bi || (this.value = !1);
  }
  Ri() {
    const e = this.Ci,
      t = this.Bi,
      i = this.value;
    i && !t ? e.focus() : !i && t && e.blur();
  }
  get Bi() {
    return this.Ci === this.p.document.activeElement;
  }
}
a0.inject = [bo, zr];
Z(
  [
    Ue({
      mode: 6,
    }),
  ],
  a0.prototype,
  'value',
  void 0,
);
w1('focus')(a0);
class Li {
  constructor(e, t, i) {
    (this.position = 'beforeend'), (this.strict = !1), (this.p = i), (this.Si = i.document.createElement('div')), (this.view = e.create()).setLocation((this._i = A4(i))), _4(this.view.nodes, t);
  }
  attaching(e) {
    this.callbackContext == null && (this.callbackContext = this.$controller.scope.bindingContext);
    const t = (this.Si = this.Ii());
    return this.Ti(t, this.position), this.Ei(e, t);
  }
  detaching(e) {
    return this.Pi(e, this.Si);
  }
  targetChanged() {
    const { $controller: e } = this;
    if (!e.isActive) return;
    const t = this.Ii();
    if (this.Si === t) return;
    this.Si = t;
    const i = Re(this.Pi(null, t), () => (this.Ti(t, this.position), this.Ei(null, t)));
    un(i) && i.catch(Yd);
  }
  positionChanged() {
    const { $controller: e, Si: t } = this;
    if (!e.isActive) return;
    const i = Re(this.Pi(null, t), () => (this.Ti(t, this.position), this.Ei(null, t)));
    un(i) && i.catch(Yd);
  }
  Ei(e, t) {
    const { activating: i, callbackContext: r, view: s } = this;
    return Re(i?.call(r, t, s), () => this.Li(e, t));
  }
  Li(e, t) {
    const { $controller: i, view: r } = this;
    if (e === null) r.nodes.insertBefore(this._i);
    else return Re(r.activate(e ?? r, i, i.scope), () => this.Mi(t));
    return this.Mi(t);
  }
  Mi(e) {
    const { activated: t, callbackContext: i, view: r } = this;
    return t?.call(i, e, r);
  }
  Pi(e, t) {
    const { deactivating: i, callbackContext: r, view: s } = this;
    return Re(i?.call(r, t, s), () => this.Di(e, t));
  }
  Di(e, t) {
    const { $controller: i, view: r } = this;
    if (e === null) r.nodes.remove();
    else return Re(r.deactivate(e, i), () => this.$i(t));
    return this.$i(t);
  }
  $i(e) {
    const { deactivated: t, callbackContext: i, view: r } = this;
    return t?.call(i, e, r);
  }
  Ii() {
    const e = this.p,
      t = e.document;
    let i = this.target,
      r = this.renderContext;
    if (i === '') {
      if (this.strict) throw se('AUR0811');
      return t.body;
    }
    if (Et(i)) {
      let s = t;
      Et(r) && (r = t.querySelector(r)), r instanceof e.Node && (s = r), (i = s.querySelector(i));
    }
    if (i instanceof e.Node) return i;
    if (i == null) {
      if (this.strict) throw se('AUR0812');
      return t.body;
    }
    return i;
  }
  Ti(e, t) {
    const i = this._i,
      r = i.$start,
      s = e.parentNode,
      a = [r, i];
    switch (t) {
      case 'beforeend':
        Xl(e, null, a);
        break;
      case 'afterbegin':
        Xl(e, e.firstChild, a);
        break;
      case 'beforebegin':
        Xl(s, e, a);
        break;
      case 'afterend':
        Xl(s, e.nextSibling, a);
        break;
      default:
        throw new Error('Invalid portal insertion position');
    }
  }
  dispose() {
    this.view.dispose(), (this.view = void 0), (this.callbackContext = null);
  }
  accept(e) {
    if (this.view?.accept(e) === !0) return !0;
  }
}
Li.inject = [ni, On, zr];
Z(
  [
    Ue({
      primary: !0,
    }),
  ],
  Li.prototype,
  'target',
  void 0,
);
Z([Ue()], Li.prototype, 'position', void 0);
Z(
  [
    Ue({
      callback: 'targetChanged',
    }),
  ],
  Li.prototype,
  'renderContext',
  void 0,
);
Z([Ue()], Li.prototype, 'strict', void 0);
Z([Ue()], Li.prototype, 'deactivating', void 0);
Z([Ue()], Li.prototype, 'activating', void 0);
Z([Ue()], Li.prototype, 'deactivated', void 0);
Z([Ue()], Li.prototype, 'activated', void 0);
Z([Ue()], Li.prototype, 'callbackContext', void 0);
bi('portal')(Li);
let oc = class {
  static get inject() {
    return [On, jo, nc, Pa];
  }
  constructor(e, t, i, r) {
    (this.Ui = null), (this.qi = null), (this.Fi = !1), (this.expose = null), (this.slotchange = null), (this.Oi = /* @__PURE__ */ new Set()), (this.Je = null);
    let s, a;
    const o = t.auSlot,
      u = i.instruction?.projections?.[o.name],
      l = i.controller;
    (this.name = o.name),
      u == null
        ? ((s = r.getViewFactory(o.fallback, l.container)), (this.Hi = !1))
        : ((a = i.parent.controller.container.createChild()),
          St(a, l.definition.Type, new ln(void 0, l.viewModel)),
          (s = r.getViewFactory(u, a)),
          (this.Hi = !0),
          (this.Vi = l.container.getAll(Q4, !1)?.filter((c) => c.slotName === '*' || c.slotName === o.name) ?? je)),
      (this.Ni = (this.Vi ?? (this.Vi = je)).length > 0),
      (this.ji = i),
      (this.view = s.create().setLocation((this.l = e)));
  }
  get nodes() {
    const e = [],
      t = this.l;
    let i = t.$start.nextSibling;
    for (; i != null && i !== t; ) i.nodeType !== 8 && e.push(i), (i = i.nextSibling);
    return e;
  }
  subscribe(e) {
    this.Oi.add(e);
  }
  unsubscribe(e) {
    this.Oi.delete(e);
  }
  binding(e, t) {
    this.Ui = this.$controller.scope.parent;
    let i;
    this.Hi && ((i = this.ji.controller.scope.parent), ((this.qi = pn.fromParent(i, i.bindingContext)).overrideContext.$host = this.expose ?? this.Ui.bindingContext));
  }
  attaching(e, t) {
    return Re(this.view.activate(e, this.$controller, this.Hi ? this.qi : this.Ui), () => {
      this.Ni && (this.Vi.forEach((i) => i.watch(this)), this.We(), this.Wi(), (this.Fi = !0));
    });
  }
  detaching(e, t) {
    return (this.Fi = !1), this.zi(), this.Vi.forEach((i) => i.unwatch(this)), this.view.deactivate(e, this.$controller);
  }
  exposeChanged(e) {
    this.Hi && this.qi != null && (this.qi.overrideContext.$host = e);
  }
  dispose() {
    this.view.dispose(), (this.view = void 0);
  }
  accept(e) {
    if (this.view?.accept(e) === !0) return !0;
  }
  We() {
    if (this.Je != null) return;
    const e = this.l,
      t = e.parentElement;
    t != null &&
      (this.Je = zh(t, (i) => {
        Q8(e, i) && this.Wi();
      })).observe(t, {
        childList: !0,
      });
  }
  zi() {
    this.Je?.disconnect(), (this.Je = null);
  }
  Wi() {
    const e = this.nodes,
      t = new Set(this.Oi);
    let i;
    this.Fi && this.slotchange?.call(void 0, this.name, e);
    for (i of t) i.handleSlotChange(this, e);
  }
};
Z([Ue], oc.prototype, 'expose', void 0);
Z([Ue], oc.prototype, 'slotchange', void 0);
oc = Z(
  [
    E1({
      name: 'au-slot',
      template: null,
      containerless: !0,
    }),
  ],
  oc,
);
const rd = (n, e) => n.compareDocumentPosition(e),
  Q8 = (n, e) => {
    for (const { addedNodes: t, removedNodes: i, nextSibling: r } of e) {
      let s = 0,
        a = t.length,
        o;
      for (; s < a; ++s) if (((o = t[s]), rd(n.$start, o) === 4 && rd(n, o) === 2)) return !0;
      if (i.length > 0 && r != null && rd(n.$start, r) === 4 && rd(n, r) === 2) return !0;
    }
  };
var kg;
(function (n) {
  (n[(n.Element = 1)] = 'Element'), (n[(n.Attribute = 2)] = 'Attribute');
})(kg || (kg = {}));
class kl {
  static get inject() {
    return [Po, Yc, bo, On, zr, jo, wx(X8)];
  }
  get pending() {
    return this.Gi;
  }
  get composition() {
    return this.Xi;
  }
  constructor(e, t, i, r, s, a, o) {
    (this.c = e), (this.parent = t), (this.host = i), (this.l = r), (this.p = s), (this.scopeBehavior = 'auto'), (this.Xi = void 0), (this.r = e.get(Pa)), (this.Ki = a), (this.Qi = o);
  }
  attaching(e, t) {
    return (this.Gi = Re(this.queue(new Pg(this.template, this.component, this.model, void 0), e), (i) => {
      this.Qi.isCurrent(i) && (this.Gi = void 0);
    }));
  }
  detaching(e) {
    const t = this.Xi,
      i = this.Gi;
    return this.Qi.invalidate(), (this.Xi = this.Gi = void 0), Re(i, () => t?.deactivate(e));
  }
  propertyChanged(e) {
    if (e === 'model' && this.Xi != null) {
      this.Xi.update(this.model);
      return;
    }
    this.Gi = Re(this.Gi, () =>
      Re(this.queue(new Pg(this.template, this.component, this.model, e), void 0), (t) => {
        this.Qi.isCurrent(t) && (this.Gi = void 0);
      }),
    );
  }
  queue(e, t) {
    const i = this.Qi,
      r = this.Xi;
    return Re(i.create(e), (s) =>
      i.isCurrent(s)
        ? Re(this.compose(s), (a) =>
            i.isCurrent(s)
              ? Re(a.activate(t), () =>
                  i.isCurrent(s) ? ((this.Xi = a), Re(r?.deactivate(t), () => s)) : Re(a.controller.deactivate(a.controller, this.$controller), () => (a.controller.dispose(), s)),
                )
              : (a.controller.dispose(), s),
          )
        : s,
    );
  }
  compose(e) {
    let t, i, r;
    const { Yi: s, Zi: a, Ji: o } = e.change,
      { c: u, host: l, $controller: c, l: f } = this,
      m = this.getDef(a),
      w = u.createChild(),
      v = f == null ? l.parentNode : f.parentNode;
    if (m !== null) {
      if (m.containerless) throw se('AUR0806');
      f == null
        ? ((i = l), (r = () => {}))
        : ((i = v.insertBefore(this.p.document.createElement(m.name), f)),
          (r = () => {
            i.remove();
          })),
        (t = this.ts(w, a, i));
    } else (i = f ?? l), (t = this.ts(w, a, i));
    const T = () => {
      if (m !== null) {
        const A = ci.$el(
          w,
          t,
          i,
          {
            projections: this.Ki.projections,
          },
          m,
        );
        return new Dg(
          A,
          (_) => A.activate(_ ?? A, c, c.scope.parent),
          (_) => Re(A.deactivate(_ ?? A, c), r),
          (_) => t.activate?.(_),
          e,
        );
      } else {
        const A = qi.create({
            name: lo.generateName(),
            template: s,
          }),
          _ = this.r.getViewFactory(A, w),
          O = ci.$view(_, c),
          B = this.scopeBehavior === 'auto' ? pn.fromParent(this.parent.scope, t) : pn.create(t);
        return (
          ec(i) ? O.setLocation(i) : O.setHost(i),
          new Dg(
            O,
            (P) => O.activate(P ?? O, c, B),
            (P) => O.deactivate(P ?? O, c),
            (P) => t.activate?.(P),
            e,
          )
        );
      }
    };
    return 'activate' in t ? Re(t.activate(o), () => T()) : T();
  }
  ts(e, t, i) {
    if (t == null) return new Y8();
    if (typeof t == 'object') return t;
    const r = this.p,
      s = ec(i);
    St(e, r.Element, St(e, bo, new ln('ElementResolver', s ? null : i))), St(e, On, new ln('IRenderLocation', s ? i : null));
    const a = e.invoke(t);
    return St(e, t, new ln('au-compose.component', a)), a;
  }
  getDef(e) {
    const t = ei(e) ? e : e?.constructor;
    return lo.isType(t) ? lo.getDefinition(t) : null;
  }
}
Z([Ue], kl.prototype, 'template', void 0);
Z([Ue], kl.prototype, 'component', void 0);
Z([Ue], kl.prototype, 'model', void 0);
Z(
  [
    Ue({
      set: (n) => {
        if (n === 'scoped' || n === 'auto') return n;
        throw se('AUR0805');
      },
    }),
  ],
  kl.prototype,
  'scopeBehavior',
  void 0,
);
E1('au-compose')(kl);
class Y8 {}
class X8 {
  constructor() {
    this.id = 0;
  }
  isCurrent(e) {
    return e.id === this.id;
  }
  create(e) {
    return Re(e.load(), (t) => new Z8(++this.id, t));
  }
  invalidate() {
    this.id++;
  }
}
class Pg {
  constructor(e, t, i, r) {
    (this.Yi = e), (this.Zi = t), (this.Ji = i), (this.es = r);
  }
  load() {
    return un(this.Yi) || un(this.Zi) ? Promise.all([this.Yi, this.Zi]).then(([e, t]) => new Ng(e, t, this.Ji, this.es)) : new Ng(this.Yi, this.Zi, this.Ji, this.es);
  }
}
class Ng {
  constructor(e, t, i, r) {
    (this.Yi = e), (this.Zi = t), (this.Ji = i), (this.es = r);
  }
}
class Z8 {
  constructor(e, t) {
    (this.id = e), (this.change = t);
  }
}
class Dg {
  constructor(e, t, i, r, s) {
    (this.controller = e), (this.start = t), (this.stop = i), (this.update = r), (this.context = s), (this.state = 0);
  }
  activate(e) {
    if (this.state !== 0) throw se(`AUR0807:${this.controller.name}`);
    return (this.state = 1), this.start(e);
  }
  deactivate(e) {
    switch (this.state) {
      case 1:
        return (this.state = -1), this.stop(e);
      case -1:
        throw se('AUR0808');
      default:
        this.state = -1;
    }
  }
}
const eS = /* @__PURE__ */ Ut('ISanitizer', (n) =>
  n.singleton(
    class {
      sanitize() {
        throw se('"sanitize" method not implemented');
      }
    },
  ),
);
let gy = class {
  constructor(e) {
    this.ss = e;
  }
  toView(e) {
    return e == null ? null : this.ss.sanitize(e);
  }
};
gy = Z([Tn(0, eS)], gy);
Sl('sanitize')(gy);
Fh(Jn(), {
  id: !0,
  name: !0,
  'au-slot': !0,
  'as-element': !0,
});
Ia('compiler-hooks');
let qu = class {
  constructor(e, t, i) {
    (this.el = e),
      (this.p = t),
      (this.Ts = !1),
      (this.st = null),
      (this.$val = ''),
      (this.$prio = ''),
      (this.update = () => {
        (this.st = null),
          !!this.value !== this.Es &&
            (this.Es === this.Ps
              ? ((this.Es = !this.Ps),
                (this.$val = this.el.style.getPropertyValue('display')),
                (this.$prio = this.el.style.getPropertyPriority('display')),
                this.el.style.setProperty('display', 'none', 'important'))
              : ((this.Es = this.Ps), this.el.style.setProperty('display', this.$val, this.$prio), this.el.getAttribute('style') === '' && this.el.removeAttribute('style')));
      }),
      (this.Es = this.Ps = i.alias !== 'hide');
  }
  binding() {
    (this.Ts = !0), this.update();
  }
  detaching() {
    (this.Ts = !1), this.st?.cancel(), (this.st = null);
  }
  valueChanged() {
    this.Ts && this.st === null && (this.st = this.p.domWriteQueue.queueTask(this.update));
  }
};
Z([Ue], qu.prototype, 'value', void 0);
qu = Z([Tn(0, bo), Tn(1, zr), Tn(2, jo)], qu);
o4('hide')(qu);
w1('show')(qu);
const Ms = be.createInterface();
var br = typeof globalThis < 'u' ? globalThis : typeof window < 'u' ? window : typeof global < 'u' ? global : typeof self < 'u' ? self : {};
function tS(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, 'default') ? n.default : n;
}
function Dt(n) {
  if (n.__esModule) return n;
  var e = n.default;
  if (typeof e == 'function') {
    var t = function i() {
      if (this instanceof i) {
        var r = [null];
        r.push.apply(r, arguments);
        var s = Function.bind.apply(e, r);
        return new s();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, '__esModule', { value: !0 }),
    Object.keys(n).forEach(function (i) {
      var r = Object.getOwnPropertyDescriptor(n, i);
      Object.defineProperty(
        t,
        i,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return n[i];
              },
            },
      );
    }),
    t
  );
}
var vy = {},
  nS = {
    get exports() {
      return vy;
    },
    set exports(n) {
      vy = n;
    },
  };
const iS = {},
  rS = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        default: iS,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  sS = /* @__PURE__ */ Dt(rS);
(function (n) {
  (function (e, t) {
    function i(C, d) {
      if (!C) throw new Error(d || 'Assertion failed');
    }
    function r(C, d) {
      C.super_ = d;
      var y = function () {};
      (y.prototype = d.prototype), (C.prototype = new y()), (C.prototype.constructor = C);
    }
    function s(C, d, y) {
      if (s.isBN(C)) return C;
      (this.negative = 0), (this.words = null), (this.length = 0), (this.red = null), C !== null && ((d === 'le' || d === 'be') && ((y = d), (d = 10)), this._init(C || 0, d || 10, y || 'be'));
    }
    typeof e == 'object' ? (e.exports = s) : (t.BN = s), (s.BN = s), (s.wordSize = 26);
    var a;
    try {
      typeof window < 'u' && typeof window.Buffer < 'u' ? (a = window.Buffer) : (a = sS.Buffer);
    } catch {}
    (s.isBN = function (d) {
      return d instanceof s ? !0 : d !== null && typeof d == 'object' && d.constructor.wordSize === s.wordSize && Array.isArray(d.words);
    }),
      (s.max = function (d, y) {
        return d.cmp(y) > 0 ? d : y;
      }),
      (s.min = function (d, y) {
        return d.cmp(y) < 0 ? d : y;
      }),
      (s.prototype._init = function (d, y, g) {
        if (typeof d == 'number') return this._initNumber(d, y, g);
        if (typeof d == 'object') return this._initArray(d, y, g);
        y === 'hex' && (y = 16), i(y === (y | 0) && y >= 2 && y <= 36), (d = d.toString().replace(/\s+/g, ''));
        var S = 0;
        d[0] === '-' && (S++, (this.negative = 1)), S < d.length && (y === 16 ? this._parseHex(d, S, g) : (this._parseBase(d, y, S), g === 'le' && this._initArray(this.toArray(), y, g)));
      }),
      (s.prototype._initNumber = function (d, y, g) {
        d < 0 && ((this.negative = 1), (d = -d)),
          d < 67108864
            ? ((this.words = [d & 67108863]), (this.length = 1))
            : d < 4503599627370496
            ? ((this.words = [d & 67108863, (d / 67108864) & 67108863]), (this.length = 2))
            : (i(d < 9007199254740992), (this.words = [d & 67108863, (d / 67108864) & 67108863, 1]), (this.length = 3)),
          g === 'le' && this._initArray(this.toArray(), y, g);
      }),
      (s.prototype._initArray = function (d, y, g) {
        if ((i(typeof d.length == 'number'), d.length <= 0)) return (this.words = [0]), (this.length = 1), this;
        (this.length = Math.ceil(d.length / 3)), (this.words = new Array(this.length));
        for (var S = 0; S < this.length; S++) this.words[S] = 0;
        var E,
          M,
          I = 0;
        if (g === 'be')
          for (S = d.length - 1, E = 0; S >= 0; S -= 3)
            (M = d[S] | (d[S - 1] << 8) | (d[S - 2] << 16)), (this.words[E] |= (M << I) & 67108863), (this.words[E + 1] = (M >>> (26 - I)) & 67108863), (I += 24), I >= 26 && ((I -= 26), E++);
        else if (g === 'le')
          for (S = 0, E = 0; S < d.length; S += 3)
            (M = d[S] | (d[S + 1] << 8) | (d[S + 2] << 16)), (this.words[E] |= (M << I) & 67108863), (this.words[E + 1] = (M >>> (26 - I)) & 67108863), (I += 24), I >= 26 && ((I -= 26), E++);
        return this._strip();
      });
    function o(C, d) {
      var y = C.charCodeAt(d);
      if (y >= 48 && y <= 57) return y - 48;
      if (y >= 65 && y <= 70) return y - 55;
      if (y >= 97 && y <= 102) return y - 87;
      i(!1, 'Invalid character in ' + C);
    }
    function u(C, d, y) {
      var g = o(C, y);
      return y - 1 >= d && (g |= o(C, y - 1) << 4), g;
    }
    s.prototype._parseHex = function (d, y, g) {
      (this.length = Math.ceil((d.length - y) / 6)), (this.words = new Array(this.length));
      for (var S = 0; S < this.length; S++) this.words[S] = 0;
      var E = 0,
        M = 0,
        I;
      if (g === 'be') for (S = d.length - 1; S >= y; S -= 2) (I = u(d, y, S) << E), (this.words[M] |= I & 67108863), E >= 18 ? ((E -= 18), (M += 1), (this.words[M] |= I >>> 26)) : (E += 8);
      else {
        var b = d.length - y;
        for (S = b % 2 === 0 ? y + 1 : y; S < d.length; S += 2) (I = u(d, y, S) << E), (this.words[M] |= I & 67108863), E >= 18 ? ((E -= 18), (M += 1), (this.words[M] |= I >>> 26)) : (E += 8);
      }
      this._strip();
    };
    function l(C, d, y, g) {
      for (var S = 0, E = 0, M = Math.min(C.length, y), I = d; I < M; I++) {
        var b = C.charCodeAt(I) - 48;
        (S *= g), b >= 49 ? (E = b - 49 + 10) : b >= 17 ? (E = b - 17 + 10) : (E = b), i(b >= 0 && E < g, 'Invalid character'), (S += E);
      }
      return S;
    }
    (s.prototype._parseBase = function (d, y, g) {
      (this.words = [0]), (this.length = 1);
      for (var S = 0, E = 1; E <= 67108863; E *= y) S++;
      S--, (E = (E / y) | 0);
      for (var M = d.length - g, I = M % S, b = Math.min(M, M - I) + g, p = 0, x = g; x < b; x += S)
        (p = l(d, x, x + S, y)), this.imuln(E), this.words[0] + p < 67108864 ? (this.words[0] += p) : this._iaddn(p);
      if (I !== 0) {
        var k = 1;
        for (p = l(d, x, d.length, y), x = 0; x < I; x++) k *= y;
        this.imuln(k), this.words[0] + p < 67108864 ? (this.words[0] += p) : this._iaddn(p);
      }
      this._strip();
    }),
      (s.prototype.copy = function (d) {
        d.words = new Array(this.length);
        for (var y = 0; y < this.length; y++) d.words[y] = this.words[y];
        (d.length = this.length), (d.negative = this.negative), (d.red = this.red);
      });
    function c(C, d) {
      (C.words = d.words), (C.length = d.length), (C.negative = d.negative), (C.red = d.red);
    }
    if (
      ((s.prototype._move = function (d) {
        c(d, this);
      }),
      (s.prototype.clone = function () {
        var d = new s(null);
        return this.copy(d), d;
      }),
      (s.prototype._expand = function (d) {
        for (; this.length < d; ) this.words[this.length++] = 0;
        return this;
      }),
      (s.prototype._strip = function () {
        for (; this.length > 1 && this.words[this.length - 1] === 0; ) this.length--;
        return this._normSign();
      }),
      (s.prototype._normSign = function () {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }),
      typeof Symbol < 'u' && typeof Symbol.for == 'function')
    )
      try {
        s.prototype[Symbol.for('nodejs.util.inspect.custom')] = f;
      } catch {
        s.prototype.inspect = f;
      }
    else s.prototype.inspect = f;
    function f() {
      return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    }
    var m = [
        '',
        '0',
        '00',
        '000',
        '0000',
        '00000',
        '000000',
        '0000000',
        '00000000',
        '000000000',
        '0000000000',
        '00000000000',
        '000000000000',
        '0000000000000',
        '00000000000000',
        '000000000000000',
        '0000000000000000',
        '00000000000000000',
        '000000000000000000',
        '0000000000000000000',
        '00000000000000000000',
        '000000000000000000000',
        '0000000000000000000000',
        '00000000000000000000000',
        '000000000000000000000000',
        '0000000000000000000000000',
      ],
      w = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
      v = [
        0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6,
        4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176,
      ];
    (s.prototype.toString = function (d, y) {
      (d = d || 10), (y = y | 0 || 1);
      var g;
      if (d === 16 || d === 'hex') {
        g = '';
        for (var S = 0, E = 0, M = 0; M < this.length; M++) {
          var I = this.words[M],
            b = (((I << S) | E) & 16777215).toString(16);
          (E = (I >>> (24 - S)) & 16777215), (S += 2), S >= 26 && ((S -= 26), M--), E !== 0 || M !== this.length - 1 ? (g = m[6 - b.length] + b + g) : (g = b + g);
        }
        for (E !== 0 && (g = E.toString(16) + g); g.length % y !== 0; ) g = '0' + g;
        return this.negative !== 0 && (g = '-' + g), g;
      }
      if (d === (d | 0) && d >= 2 && d <= 36) {
        var p = w[d],
          x = v[d];
        g = '';
        var k = this.clone();
        for (k.negative = 0; !k.isZero(); ) {
          var h = k.modrn(x).toString(d);
          (k = k.idivn(x)), k.isZero() ? (g = h + g) : (g = m[p - h.length] + h + g);
        }
        for (this.isZero() && (g = '0' + g); g.length % y !== 0; ) g = '0' + g;
        return this.negative !== 0 && (g = '-' + g), g;
      }
      i(!1, 'Base should be between 2 and 36');
    }),
      (s.prototype.toNumber = function () {
        var d = this.words[0];
        return (
          this.length === 2
            ? (d += this.words[1] * 67108864)
            : this.length === 3 && this.words[2] === 1
            ? (d += 4503599627370496 + this.words[1] * 67108864)
            : this.length > 2 && i(!1, 'Number can only safely store up to 53 bits'),
          this.negative !== 0 ? -d : d
        );
      }),
      (s.prototype.toJSON = function () {
        return this.toString(16, 2);
      }),
      a &&
        (s.prototype.toBuffer = function (d, y) {
          return this.toArrayLike(a, d, y);
        }),
      (s.prototype.toArray = function (d, y) {
        return this.toArrayLike(Array, d, y);
      });
    var T = function (d, y) {
      return d.allocUnsafe ? d.allocUnsafe(y) : new d(y);
    };
    (s.prototype.toArrayLike = function (d, y, g) {
      this._strip();
      var S = this.byteLength(),
        E = g || Math.max(1, S);
      i(S <= E, 'byte array longer than desired length'), i(E > 0, 'Requested array length <= 0');
      var M = T(d, E),
        I = y === 'le' ? 'LE' : 'BE';
      return this['_toArrayLike' + I](M, S), M;
    }),
      (s.prototype._toArrayLikeLE = function (d, y) {
        for (var g = 0, S = 0, E = 0, M = 0; E < this.length; E++) {
          var I = (this.words[E] << M) | S;
          (d[g++] = I & 255),
            g < d.length && (d[g++] = (I >> 8) & 255),
            g < d.length && (d[g++] = (I >> 16) & 255),
            M === 6 ? (g < d.length && (d[g++] = (I >> 24) & 255), (S = 0), (M = 0)) : ((S = I >>> 24), (M += 2));
        }
        if (g < d.length) for (d[g++] = S; g < d.length; ) d[g++] = 0;
      }),
      (s.prototype._toArrayLikeBE = function (d, y) {
        for (var g = d.length - 1, S = 0, E = 0, M = 0; E < this.length; E++) {
          var I = (this.words[E] << M) | S;
          (d[g--] = I & 255),
            g >= 0 && (d[g--] = (I >> 8) & 255),
            g >= 0 && (d[g--] = (I >> 16) & 255),
            M === 6 ? (g >= 0 && (d[g--] = (I >> 24) & 255), (S = 0), (M = 0)) : ((S = I >>> 24), (M += 2));
        }
        if (g >= 0) for (d[g--] = S; g >= 0; ) d[g--] = 0;
      }),
      Math.clz32
        ? (s.prototype._countBits = function (d) {
            return 32 - Math.clz32(d);
          })
        : (s.prototype._countBits = function (d) {
            var y = d,
              g = 0;
            return y >= 4096 && ((g += 13), (y >>>= 13)), y >= 64 && ((g += 7), (y >>>= 7)), y >= 8 && ((g += 4), (y >>>= 4)), y >= 2 && ((g += 2), (y >>>= 2)), g + y;
          }),
      (s.prototype._zeroBits = function (d) {
        if (d === 0) return 26;
        var y = d,
          g = 0;
        return y & 8191 || ((g += 13), (y >>>= 13)), y & 127 || ((g += 7), (y >>>= 7)), y & 15 || ((g += 4), (y >>>= 4)), y & 3 || ((g += 2), (y >>>= 2)), y & 1 || g++, g;
      }),
      (s.prototype.bitLength = function () {
        var d = this.words[this.length - 1],
          y = this._countBits(d);
        return (this.length - 1) * 26 + y;
      });
    function A(C) {
      for (var d = new Array(C.bitLength()), y = 0; y < d.length; y++) {
        var g = (y / 26) | 0,
          S = y % 26;
        d[y] = (C.words[g] >>> S) & 1;
      }
      return d;
    }
    (s.prototype.zeroBits = function () {
      if (this.isZero()) return 0;
      for (var d = 0, y = 0; y < this.length; y++) {
        var g = this._zeroBits(this.words[y]);
        if (((d += g), g !== 26)) break;
      }
      return d;
    }),
      (s.prototype.byteLength = function () {
        return Math.ceil(this.bitLength() / 8);
      }),
      (s.prototype.toTwos = function (d) {
        return this.negative !== 0 ? this.abs().inotn(d).iaddn(1) : this.clone();
      }),
      (s.prototype.fromTwos = function (d) {
        return this.testn(d - 1) ? this.notn(d).iaddn(1).ineg() : this.clone();
      }),
      (s.prototype.isNeg = function () {
        return this.negative !== 0;
      }),
      (s.prototype.neg = function () {
        return this.clone().ineg();
      }),
      (s.prototype.ineg = function () {
        return this.isZero() || (this.negative ^= 1), this;
      }),
      (s.prototype.iuor = function (d) {
        for (; this.length < d.length; ) this.words[this.length++] = 0;
        for (var y = 0; y < d.length; y++) this.words[y] = this.words[y] | d.words[y];
        return this._strip();
      }),
      (s.prototype.ior = function (d) {
        return i((this.negative | d.negative) === 0), this.iuor(d);
      }),
      (s.prototype.or = function (d) {
        return this.length > d.length ? this.clone().ior(d) : d.clone().ior(this);
      }),
      (s.prototype.uor = function (d) {
        return this.length > d.length ? this.clone().iuor(d) : d.clone().iuor(this);
      }),
      (s.prototype.iuand = function (d) {
        var y;
        this.length > d.length ? (y = d) : (y = this);
        for (var g = 0; g < y.length; g++) this.words[g] = this.words[g] & d.words[g];
        return (this.length = y.length), this._strip();
      }),
      (s.prototype.iand = function (d) {
        return i((this.negative | d.negative) === 0), this.iuand(d);
      }),
      (s.prototype.and = function (d) {
        return this.length > d.length ? this.clone().iand(d) : d.clone().iand(this);
      }),
      (s.prototype.uand = function (d) {
        return this.length > d.length ? this.clone().iuand(d) : d.clone().iuand(this);
      }),
      (s.prototype.iuxor = function (d) {
        var y, g;
        this.length > d.length ? ((y = this), (g = d)) : ((y = d), (g = this));
        for (var S = 0; S < g.length; S++) this.words[S] = y.words[S] ^ g.words[S];
        if (this !== y) for (; S < y.length; S++) this.words[S] = y.words[S];
        return (this.length = y.length), this._strip();
      }),
      (s.prototype.ixor = function (d) {
        return i((this.negative | d.negative) === 0), this.iuxor(d);
      }),
      (s.prototype.xor = function (d) {
        return this.length > d.length ? this.clone().ixor(d) : d.clone().ixor(this);
      }),
      (s.prototype.uxor = function (d) {
        return this.length > d.length ? this.clone().iuxor(d) : d.clone().iuxor(this);
      }),
      (s.prototype.inotn = function (d) {
        i(typeof d == 'number' && d >= 0);
        var y = Math.ceil(d / 26) | 0,
          g = d % 26;
        this._expand(y), g > 0 && y--;
        for (var S = 0; S < y; S++) this.words[S] = ~this.words[S] & 67108863;
        return g > 0 && (this.words[S] = ~this.words[S] & (67108863 >> (26 - g))), this._strip();
      }),
      (s.prototype.notn = function (d) {
        return this.clone().inotn(d);
      }),
      (s.prototype.setn = function (d, y) {
        i(typeof d == 'number' && d >= 0);
        var g = (d / 26) | 0,
          S = d % 26;
        return this._expand(g + 1), y ? (this.words[g] = this.words[g] | (1 << S)) : (this.words[g] = this.words[g] & ~(1 << S)), this._strip();
      }),
      (s.prototype.iadd = function (d) {
        var y;
        if (this.negative !== 0 && d.negative === 0) return (this.negative = 0), (y = this.isub(d)), (this.negative ^= 1), this._normSign();
        if (this.negative === 0 && d.negative !== 0) return (d.negative = 0), (y = this.isub(d)), (d.negative = 1), y._normSign();
        var g, S;
        this.length > d.length ? ((g = this), (S = d)) : ((g = d), (S = this));
        for (var E = 0, M = 0; M < S.length; M++) (y = (g.words[M] | 0) + (S.words[M] | 0) + E), (this.words[M] = y & 67108863), (E = y >>> 26);
        for (; E !== 0 && M < g.length; M++) (y = (g.words[M] | 0) + E), (this.words[M] = y & 67108863), (E = y >>> 26);
        if (((this.length = g.length), E !== 0)) (this.words[this.length] = E), this.length++;
        else if (g !== this) for (; M < g.length; M++) this.words[M] = g.words[M];
        return this;
      }),
      (s.prototype.add = function (d) {
        var y;
        return d.negative !== 0 && this.negative === 0
          ? ((d.negative = 0), (y = this.sub(d)), (d.negative ^= 1), y)
          : d.negative === 0 && this.negative !== 0
          ? ((this.negative = 0), (y = d.sub(this)), (this.negative = 1), y)
          : this.length > d.length
          ? this.clone().iadd(d)
          : d.clone().iadd(this);
      }),
      (s.prototype.isub = function (d) {
        if (d.negative !== 0) {
          d.negative = 0;
          var y = this.iadd(d);
          return (d.negative = 1), y._normSign();
        } else if (this.negative !== 0) return (this.negative = 0), this.iadd(d), (this.negative = 1), this._normSign();
        var g = this.cmp(d);
        if (g === 0) return (this.negative = 0), (this.length = 1), (this.words[0] = 0), this;
        var S, E;
        g > 0 ? ((S = this), (E = d)) : ((S = d), (E = this));
        for (var M = 0, I = 0; I < E.length; I++) (y = (S.words[I] | 0) - (E.words[I] | 0) + M), (M = y >> 26), (this.words[I] = y & 67108863);
        for (; M !== 0 && I < S.length; I++) (y = (S.words[I] | 0) + M), (M = y >> 26), (this.words[I] = y & 67108863);
        if (M === 0 && I < S.length && S !== this) for (; I < S.length; I++) this.words[I] = S.words[I];
        return (this.length = Math.max(this.length, I)), S !== this && (this.negative = 1), this._strip();
      }),
      (s.prototype.sub = function (d) {
        return this.clone().isub(d);
      });
    function _(C, d, y) {
      y.negative = d.negative ^ C.negative;
      var g = (C.length + d.length) | 0;
      (y.length = g), (g = (g - 1) | 0);
      var S = C.words[0] | 0,
        E = d.words[0] | 0,
        M = S * E,
        I = M & 67108863,
        b = (M / 67108864) | 0;
      y.words[0] = I;
      for (var p = 1; p < g; p++) {
        for (var x = b >>> 26, k = b & 67108863, h = Math.min(p, d.length - 1), R = Math.max(0, p - C.length + 1); R <= h; R++) {
          var L = (p - R) | 0;
          (S = C.words[L] | 0), (E = d.words[R] | 0), (M = S * E + k), (x += (M / 67108864) | 0), (k = M & 67108863);
        }
        (y.words[p] = k | 0), (b = x | 0);
      }
      return b !== 0 ? (y.words[p] = b | 0) : y.length--, y._strip();
    }
    var O = function (d, y, g) {
      var S = d.words,
        E = y.words,
        M = g.words,
        I = 0,
        b,
        p,
        x,
        k = S[0] | 0,
        h = k & 8191,
        R = k >>> 13,
        L = S[1] | 0,
        F = L & 8191,
        $ = L >>> 13,
        te = S[2] | 0,
        Q = te & 8191,
        X = te >>> 13,
        Ct = S[3] | 0,
        ne = Ct & 8191,
        ye = Ct >>> 13,
        ks = S[4] | 0,
        qe = ks & 8191,
        He = ks >>> 13,
        Ps = S[5] | 0,
        Ke = Ps & 8191,
        We = Ps >>> 13,
        Ns = S[6] | 0,
        Je = Ns & 8191,
        Qe = Ns >>> 13,
        Ds = S[7] | 0,
        Ye = Ds & 8191,
        Xe = Ds >>> 13,
        Bs = S[8] | 0,
        Ze = Bs & 8191,
        et = Bs >>> 13,
        Fs = S[9] | 0,
        tt = Fs & 8191,
        nt = Fs >>> 13,
        Ls = E[0] | 0,
        it = Ls & 8191,
        rt = Ls >>> 13,
        $s = E[1] | 0,
        st = $s & 8191,
        at = $s >>> 13,
        Us = E[2] | 0,
        ot = Us & 8191,
        ut = Us >>> 13,
        js = E[3] | 0,
        lt = js & 8191,
        dt = js >>> 13,
        Vs = E[4] | 0,
        ct = Vs & 8191,
        pt = Vs >>> 13,
        zs = E[5] | 0,
        ft = zs & 8191,
        yt = zs >>> 13,
        Gs = E[6] | 0,
        ht = Gs & 8191,
        mt = Gs >>> 13,
        qs = E[7] | 0,
        bt = qs & 8191,
        gt = qs >>> 13,
        Hs = E[8] | 0,
        vt = Hs & 8191,
        xt = Hs >>> 13,
        Ks = E[9] | 0,
        Tt = Ks & 8191,
        wt = Ks >>> 13;
      (g.negative = d.negative ^ y.negative), (g.length = 19), (b = Math.imul(h, it)), (p = Math.imul(h, rt)), (p = (p + Math.imul(R, it)) | 0), (x = Math.imul(R, rt));
      var Qr = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Qr >>> 26)) | 0),
        (Qr &= 67108863),
        (b = Math.imul(F, it)),
        (p = Math.imul(F, rt)),
        (p = (p + Math.imul($, it)) | 0),
        (x = Math.imul($, rt)),
        (b = (b + Math.imul(h, st)) | 0),
        (p = (p + Math.imul(h, at)) | 0),
        (p = (p + Math.imul(R, st)) | 0),
        (x = (x + Math.imul(R, at)) | 0);
      var Yr = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Yr >>> 26)) | 0),
        (Yr &= 67108863),
        (b = Math.imul(Q, it)),
        (p = Math.imul(Q, rt)),
        (p = (p + Math.imul(X, it)) | 0),
        (x = Math.imul(X, rt)),
        (b = (b + Math.imul(F, st)) | 0),
        (p = (p + Math.imul(F, at)) | 0),
        (p = (p + Math.imul($, st)) | 0),
        (x = (x + Math.imul($, at)) | 0),
        (b = (b + Math.imul(h, ot)) | 0),
        (p = (p + Math.imul(h, ut)) | 0),
        (p = (p + Math.imul(R, ot)) | 0),
        (x = (x + Math.imul(R, ut)) | 0);
      var Xr = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Xr >>> 26)) | 0),
        (Xr &= 67108863),
        (b = Math.imul(ne, it)),
        (p = Math.imul(ne, rt)),
        (p = (p + Math.imul(ye, it)) | 0),
        (x = Math.imul(ye, rt)),
        (b = (b + Math.imul(Q, st)) | 0),
        (p = (p + Math.imul(Q, at)) | 0),
        (p = (p + Math.imul(X, st)) | 0),
        (x = (x + Math.imul(X, at)) | 0),
        (b = (b + Math.imul(F, ot)) | 0),
        (p = (p + Math.imul(F, ut)) | 0),
        (p = (p + Math.imul($, ot)) | 0),
        (x = (x + Math.imul($, ut)) | 0),
        (b = (b + Math.imul(h, lt)) | 0),
        (p = (p + Math.imul(h, dt)) | 0),
        (p = (p + Math.imul(R, lt)) | 0),
        (x = (x + Math.imul(R, dt)) | 0);
      var Zr = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Zr >>> 26)) | 0),
        (Zr &= 67108863),
        (b = Math.imul(qe, it)),
        (p = Math.imul(qe, rt)),
        (p = (p + Math.imul(He, it)) | 0),
        (x = Math.imul(He, rt)),
        (b = (b + Math.imul(ne, st)) | 0),
        (p = (p + Math.imul(ne, at)) | 0),
        (p = (p + Math.imul(ye, st)) | 0),
        (x = (x + Math.imul(ye, at)) | 0),
        (b = (b + Math.imul(Q, ot)) | 0),
        (p = (p + Math.imul(Q, ut)) | 0),
        (p = (p + Math.imul(X, ot)) | 0),
        (x = (x + Math.imul(X, ut)) | 0),
        (b = (b + Math.imul(F, lt)) | 0),
        (p = (p + Math.imul(F, dt)) | 0),
        (p = (p + Math.imul($, lt)) | 0),
        (x = (x + Math.imul($, dt)) | 0),
        (b = (b + Math.imul(h, ct)) | 0),
        (p = (p + Math.imul(h, pt)) | 0),
        (p = (p + Math.imul(R, ct)) | 0),
        (x = (x + Math.imul(R, pt)) | 0);
      var es = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (es >>> 26)) | 0),
        (es &= 67108863),
        (b = Math.imul(Ke, it)),
        (p = Math.imul(Ke, rt)),
        (p = (p + Math.imul(We, it)) | 0),
        (x = Math.imul(We, rt)),
        (b = (b + Math.imul(qe, st)) | 0),
        (p = (p + Math.imul(qe, at)) | 0),
        (p = (p + Math.imul(He, st)) | 0),
        (x = (x + Math.imul(He, at)) | 0),
        (b = (b + Math.imul(ne, ot)) | 0),
        (p = (p + Math.imul(ne, ut)) | 0),
        (p = (p + Math.imul(ye, ot)) | 0),
        (x = (x + Math.imul(ye, ut)) | 0),
        (b = (b + Math.imul(Q, lt)) | 0),
        (p = (p + Math.imul(Q, dt)) | 0),
        (p = (p + Math.imul(X, lt)) | 0),
        (x = (x + Math.imul(X, dt)) | 0),
        (b = (b + Math.imul(F, ct)) | 0),
        (p = (p + Math.imul(F, pt)) | 0),
        (p = (p + Math.imul($, ct)) | 0),
        (x = (x + Math.imul($, pt)) | 0),
        (b = (b + Math.imul(h, ft)) | 0),
        (p = (p + Math.imul(h, yt)) | 0),
        (p = (p + Math.imul(R, ft)) | 0),
        (x = (x + Math.imul(R, yt)) | 0);
      var Ip = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Ip >>> 26)) | 0),
        (Ip &= 67108863),
        (b = Math.imul(Je, it)),
        (p = Math.imul(Je, rt)),
        (p = (p + Math.imul(Qe, it)) | 0),
        (x = Math.imul(Qe, rt)),
        (b = (b + Math.imul(Ke, st)) | 0),
        (p = (p + Math.imul(Ke, at)) | 0),
        (p = (p + Math.imul(We, st)) | 0),
        (x = (x + Math.imul(We, at)) | 0),
        (b = (b + Math.imul(qe, ot)) | 0),
        (p = (p + Math.imul(qe, ut)) | 0),
        (p = (p + Math.imul(He, ot)) | 0),
        (x = (x + Math.imul(He, ut)) | 0),
        (b = (b + Math.imul(ne, lt)) | 0),
        (p = (p + Math.imul(ne, dt)) | 0),
        (p = (p + Math.imul(ye, lt)) | 0),
        (x = (x + Math.imul(ye, dt)) | 0),
        (b = (b + Math.imul(Q, ct)) | 0),
        (p = (p + Math.imul(Q, pt)) | 0),
        (p = (p + Math.imul(X, ct)) | 0),
        (x = (x + Math.imul(X, pt)) | 0),
        (b = (b + Math.imul(F, ft)) | 0),
        (p = (p + Math.imul(F, yt)) | 0),
        (p = (p + Math.imul($, ft)) | 0),
        (x = (x + Math.imul($, yt)) | 0),
        (b = (b + Math.imul(h, ht)) | 0),
        (p = (p + Math.imul(h, mt)) | 0),
        (p = (p + Math.imul(R, ht)) | 0),
        (x = (x + Math.imul(R, mt)) | 0);
      var Op = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Op >>> 26)) | 0),
        (Op &= 67108863),
        (b = Math.imul(Ye, it)),
        (p = Math.imul(Ye, rt)),
        (p = (p + Math.imul(Xe, it)) | 0),
        (x = Math.imul(Xe, rt)),
        (b = (b + Math.imul(Je, st)) | 0),
        (p = (p + Math.imul(Je, at)) | 0),
        (p = (p + Math.imul(Qe, st)) | 0),
        (x = (x + Math.imul(Qe, at)) | 0),
        (b = (b + Math.imul(Ke, ot)) | 0),
        (p = (p + Math.imul(Ke, ut)) | 0),
        (p = (p + Math.imul(We, ot)) | 0),
        (x = (x + Math.imul(We, ut)) | 0),
        (b = (b + Math.imul(qe, lt)) | 0),
        (p = (p + Math.imul(qe, dt)) | 0),
        (p = (p + Math.imul(He, lt)) | 0),
        (x = (x + Math.imul(He, dt)) | 0),
        (b = (b + Math.imul(ne, ct)) | 0),
        (p = (p + Math.imul(ne, pt)) | 0),
        (p = (p + Math.imul(ye, ct)) | 0),
        (x = (x + Math.imul(ye, pt)) | 0),
        (b = (b + Math.imul(Q, ft)) | 0),
        (p = (p + Math.imul(Q, yt)) | 0),
        (p = (p + Math.imul(X, ft)) | 0),
        (x = (x + Math.imul(X, yt)) | 0),
        (b = (b + Math.imul(F, ht)) | 0),
        (p = (p + Math.imul(F, mt)) | 0),
        (p = (p + Math.imul($, ht)) | 0),
        (x = (x + Math.imul($, mt)) | 0),
        (b = (b + Math.imul(h, bt)) | 0),
        (p = (p + Math.imul(h, gt)) | 0),
        (p = (p + Math.imul(R, bt)) | 0),
        (x = (x + Math.imul(R, gt)) | 0);
      var kp = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (kp >>> 26)) | 0),
        (kp &= 67108863),
        (b = Math.imul(Ze, it)),
        (p = Math.imul(Ze, rt)),
        (p = (p + Math.imul(et, it)) | 0),
        (x = Math.imul(et, rt)),
        (b = (b + Math.imul(Ye, st)) | 0),
        (p = (p + Math.imul(Ye, at)) | 0),
        (p = (p + Math.imul(Xe, st)) | 0),
        (x = (x + Math.imul(Xe, at)) | 0),
        (b = (b + Math.imul(Je, ot)) | 0),
        (p = (p + Math.imul(Je, ut)) | 0),
        (p = (p + Math.imul(Qe, ot)) | 0),
        (x = (x + Math.imul(Qe, ut)) | 0),
        (b = (b + Math.imul(Ke, lt)) | 0),
        (p = (p + Math.imul(Ke, dt)) | 0),
        (p = (p + Math.imul(We, lt)) | 0),
        (x = (x + Math.imul(We, dt)) | 0),
        (b = (b + Math.imul(qe, ct)) | 0),
        (p = (p + Math.imul(qe, pt)) | 0),
        (p = (p + Math.imul(He, ct)) | 0),
        (x = (x + Math.imul(He, pt)) | 0),
        (b = (b + Math.imul(ne, ft)) | 0),
        (p = (p + Math.imul(ne, yt)) | 0),
        (p = (p + Math.imul(ye, ft)) | 0),
        (x = (x + Math.imul(ye, yt)) | 0),
        (b = (b + Math.imul(Q, ht)) | 0),
        (p = (p + Math.imul(Q, mt)) | 0),
        (p = (p + Math.imul(X, ht)) | 0),
        (x = (x + Math.imul(X, mt)) | 0),
        (b = (b + Math.imul(F, bt)) | 0),
        (p = (p + Math.imul(F, gt)) | 0),
        (p = (p + Math.imul($, bt)) | 0),
        (x = (x + Math.imul($, gt)) | 0),
        (b = (b + Math.imul(h, vt)) | 0),
        (p = (p + Math.imul(h, xt)) | 0),
        (p = (p + Math.imul(R, vt)) | 0),
        (x = (x + Math.imul(R, xt)) | 0);
      var Pp = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Pp >>> 26)) | 0),
        (Pp &= 67108863),
        (b = Math.imul(tt, it)),
        (p = Math.imul(tt, rt)),
        (p = (p + Math.imul(nt, it)) | 0),
        (x = Math.imul(nt, rt)),
        (b = (b + Math.imul(Ze, st)) | 0),
        (p = (p + Math.imul(Ze, at)) | 0),
        (p = (p + Math.imul(et, st)) | 0),
        (x = (x + Math.imul(et, at)) | 0),
        (b = (b + Math.imul(Ye, ot)) | 0),
        (p = (p + Math.imul(Ye, ut)) | 0),
        (p = (p + Math.imul(Xe, ot)) | 0),
        (x = (x + Math.imul(Xe, ut)) | 0),
        (b = (b + Math.imul(Je, lt)) | 0),
        (p = (p + Math.imul(Je, dt)) | 0),
        (p = (p + Math.imul(Qe, lt)) | 0),
        (x = (x + Math.imul(Qe, dt)) | 0),
        (b = (b + Math.imul(Ke, ct)) | 0),
        (p = (p + Math.imul(Ke, pt)) | 0),
        (p = (p + Math.imul(We, ct)) | 0),
        (x = (x + Math.imul(We, pt)) | 0),
        (b = (b + Math.imul(qe, ft)) | 0),
        (p = (p + Math.imul(qe, yt)) | 0),
        (p = (p + Math.imul(He, ft)) | 0),
        (x = (x + Math.imul(He, yt)) | 0),
        (b = (b + Math.imul(ne, ht)) | 0),
        (p = (p + Math.imul(ne, mt)) | 0),
        (p = (p + Math.imul(ye, ht)) | 0),
        (x = (x + Math.imul(ye, mt)) | 0),
        (b = (b + Math.imul(Q, bt)) | 0),
        (p = (p + Math.imul(Q, gt)) | 0),
        (p = (p + Math.imul(X, bt)) | 0),
        (x = (x + Math.imul(X, gt)) | 0),
        (b = (b + Math.imul(F, vt)) | 0),
        (p = (p + Math.imul(F, xt)) | 0),
        (p = (p + Math.imul($, vt)) | 0),
        (x = (x + Math.imul($, xt)) | 0),
        (b = (b + Math.imul(h, Tt)) | 0),
        (p = (p + Math.imul(h, wt)) | 0),
        (p = (p + Math.imul(R, Tt)) | 0),
        (x = (x + Math.imul(R, wt)) | 0);
      var Np = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Np >>> 26)) | 0),
        (Np &= 67108863),
        (b = Math.imul(tt, st)),
        (p = Math.imul(tt, at)),
        (p = (p + Math.imul(nt, st)) | 0),
        (x = Math.imul(nt, at)),
        (b = (b + Math.imul(Ze, ot)) | 0),
        (p = (p + Math.imul(Ze, ut)) | 0),
        (p = (p + Math.imul(et, ot)) | 0),
        (x = (x + Math.imul(et, ut)) | 0),
        (b = (b + Math.imul(Ye, lt)) | 0),
        (p = (p + Math.imul(Ye, dt)) | 0),
        (p = (p + Math.imul(Xe, lt)) | 0),
        (x = (x + Math.imul(Xe, dt)) | 0),
        (b = (b + Math.imul(Je, ct)) | 0),
        (p = (p + Math.imul(Je, pt)) | 0),
        (p = (p + Math.imul(Qe, ct)) | 0),
        (x = (x + Math.imul(Qe, pt)) | 0),
        (b = (b + Math.imul(Ke, ft)) | 0),
        (p = (p + Math.imul(Ke, yt)) | 0),
        (p = (p + Math.imul(We, ft)) | 0),
        (x = (x + Math.imul(We, yt)) | 0),
        (b = (b + Math.imul(qe, ht)) | 0),
        (p = (p + Math.imul(qe, mt)) | 0),
        (p = (p + Math.imul(He, ht)) | 0),
        (x = (x + Math.imul(He, mt)) | 0),
        (b = (b + Math.imul(ne, bt)) | 0),
        (p = (p + Math.imul(ne, gt)) | 0),
        (p = (p + Math.imul(ye, bt)) | 0),
        (x = (x + Math.imul(ye, gt)) | 0),
        (b = (b + Math.imul(Q, vt)) | 0),
        (p = (p + Math.imul(Q, xt)) | 0),
        (p = (p + Math.imul(X, vt)) | 0),
        (x = (x + Math.imul(X, xt)) | 0),
        (b = (b + Math.imul(F, Tt)) | 0),
        (p = (p + Math.imul(F, wt)) | 0),
        (p = (p + Math.imul($, Tt)) | 0),
        (x = (x + Math.imul($, wt)) | 0);
      var Dp = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Dp >>> 26)) | 0),
        (Dp &= 67108863),
        (b = Math.imul(tt, ot)),
        (p = Math.imul(tt, ut)),
        (p = (p + Math.imul(nt, ot)) | 0),
        (x = Math.imul(nt, ut)),
        (b = (b + Math.imul(Ze, lt)) | 0),
        (p = (p + Math.imul(Ze, dt)) | 0),
        (p = (p + Math.imul(et, lt)) | 0),
        (x = (x + Math.imul(et, dt)) | 0),
        (b = (b + Math.imul(Ye, ct)) | 0),
        (p = (p + Math.imul(Ye, pt)) | 0),
        (p = (p + Math.imul(Xe, ct)) | 0),
        (x = (x + Math.imul(Xe, pt)) | 0),
        (b = (b + Math.imul(Je, ft)) | 0),
        (p = (p + Math.imul(Je, yt)) | 0),
        (p = (p + Math.imul(Qe, ft)) | 0),
        (x = (x + Math.imul(Qe, yt)) | 0),
        (b = (b + Math.imul(Ke, ht)) | 0),
        (p = (p + Math.imul(Ke, mt)) | 0),
        (p = (p + Math.imul(We, ht)) | 0),
        (x = (x + Math.imul(We, mt)) | 0),
        (b = (b + Math.imul(qe, bt)) | 0),
        (p = (p + Math.imul(qe, gt)) | 0),
        (p = (p + Math.imul(He, bt)) | 0),
        (x = (x + Math.imul(He, gt)) | 0),
        (b = (b + Math.imul(ne, vt)) | 0),
        (p = (p + Math.imul(ne, xt)) | 0),
        (p = (p + Math.imul(ye, vt)) | 0),
        (x = (x + Math.imul(ye, xt)) | 0),
        (b = (b + Math.imul(Q, Tt)) | 0),
        (p = (p + Math.imul(Q, wt)) | 0),
        (p = (p + Math.imul(X, Tt)) | 0),
        (x = (x + Math.imul(X, wt)) | 0);
      var Bp = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Bp >>> 26)) | 0),
        (Bp &= 67108863),
        (b = Math.imul(tt, lt)),
        (p = Math.imul(tt, dt)),
        (p = (p + Math.imul(nt, lt)) | 0),
        (x = Math.imul(nt, dt)),
        (b = (b + Math.imul(Ze, ct)) | 0),
        (p = (p + Math.imul(Ze, pt)) | 0),
        (p = (p + Math.imul(et, ct)) | 0),
        (x = (x + Math.imul(et, pt)) | 0),
        (b = (b + Math.imul(Ye, ft)) | 0),
        (p = (p + Math.imul(Ye, yt)) | 0),
        (p = (p + Math.imul(Xe, ft)) | 0),
        (x = (x + Math.imul(Xe, yt)) | 0),
        (b = (b + Math.imul(Je, ht)) | 0),
        (p = (p + Math.imul(Je, mt)) | 0),
        (p = (p + Math.imul(Qe, ht)) | 0),
        (x = (x + Math.imul(Qe, mt)) | 0),
        (b = (b + Math.imul(Ke, bt)) | 0),
        (p = (p + Math.imul(Ke, gt)) | 0),
        (p = (p + Math.imul(We, bt)) | 0),
        (x = (x + Math.imul(We, gt)) | 0),
        (b = (b + Math.imul(qe, vt)) | 0),
        (p = (p + Math.imul(qe, xt)) | 0),
        (p = (p + Math.imul(He, vt)) | 0),
        (x = (x + Math.imul(He, xt)) | 0),
        (b = (b + Math.imul(ne, Tt)) | 0),
        (p = (p + Math.imul(ne, wt)) | 0),
        (p = (p + Math.imul(ye, Tt)) | 0),
        (x = (x + Math.imul(ye, wt)) | 0);
      var Fp = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Fp >>> 26)) | 0),
        (Fp &= 67108863),
        (b = Math.imul(tt, ct)),
        (p = Math.imul(tt, pt)),
        (p = (p + Math.imul(nt, ct)) | 0),
        (x = Math.imul(nt, pt)),
        (b = (b + Math.imul(Ze, ft)) | 0),
        (p = (p + Math.imul(Ze, yt)) | 0),
        (p = (p + Math.imul(et, ft)) | 0),
        (x = (x + Math.imul(et, yt)) | 0),
        (b = (b + Math.imul(Ye, ht)) | 0),
        (p = (p + Math.imul(Ye, mt)) | 0),
        (p = (p + Math.imul(Xe, ht)) | 0),
        (x = (x + Math.imul(Xe, mt)) | 0),
        (b = (b + Math.imul(Je, bt)) | 0),
        (p = (p + Math.imul(Je, gt)) | 0),
        (p = (p + Math.imul(Qe, bt)) | 0),
        (x = (x + Math.imul(Qe, gt)) | 0),
        (b = (b + Math.imul(Ke, vt)) | 0),
        (p = (p + Math.imul(Ke, xt)) | 0),
        (p = (p + Math.imul(We, vt)) | 0),
        (x = (x + Math.imul(We, xt)) | 0),
        (b = (b + Math.imul(qe, Tt)) | 0),
        (p = (p + Math.imul(qe, wt)) | 0),
        (p = (p + Math.imul(He, Tt)) | 0),
        (x = (x + Math.imul(He, wt)) | 0);
      var Lp = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Lp >>> 26)) | 0),
        (Lp &= 67108863),
        (b = Math.imul(tt, ft)),
        (p = Math.imul(tt, yt)),
        (p = (p + Math.imul(nt, ft)) | 0),
        (x = Math.imul(nt, yt)),
        (b = (b + Math.imul(Ze, ht)) | 0),
        (p = (p + Math.imul(Ze, mt)) | 0),
        (p = (p + Math.imul(et, ht)) | 0),
        (x = (x + Math.imul(et, mt)) | 0),
        (b = (b + Math.imul(Ye, bt)) | 0),
        (p = (p + Math.imul(Ye, gt)) | 0),
        (p = (p + Math.imul(Xe, bt)) | 0),
        (x = (x + Math.imul(Xe, gt)) | 0),
        (b = (b + Math.imul(Je, vt)) | 0),
        (p = (p + Math.imul(Je, xt)) | 0),
        (p = (p + Math.imul(Qe, vt)) | 0),
        (x = (x + Math.imul(Qe, xt)) | 0),
        (b = (b + Math.imul(Ke, Tt)) | 0),
        (p = (p + Math.imul(Ke, wt)) | 0),
        (p = (p + Math.imul(We, Tt)) | 0),
        (x = (x + Math.imul(We, wt)) | 0);
      var $p = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + ($p >>> 26)) | 0),
        ($p &= 67108863),
        (b = Math.imul(tt, ht)),
        (p = Math.imul(tt, mt)),
        (p = (p + Math.imul(nt, ht)) | 0),
        (x = Math.imul(nt, mt)),
        (b = (b + Math.imul(Ze, bt)) | 0),
        (p = (p + Math.imul(Ze, gt)) | 0),
        (p = (p + Math.imul(et, bt)) | 0),
        (x = (x + Math.imul(et, gt)) | 0),
        (b = (b + Math.imul(Ye, vt)) | 0),
        (p = (p + Math.imul(Ye, xt)) | 0),
        (p = (p + Math.imul(Xe, vt)) | 0),
        (x = (x + Math.imul(Xe, xt)) | 0),
        (b = (b + Math.imul(Je, Tt)) | 0),
        (p = (p + Math.imul(Je, wt)) | 0),
        (p = (p + Math.imul(Qe, Tt)) | 0),
        (x = (x + Math.imul(Qe, wt)) | 0);
      var Up = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Up >>> 26)) | 0),
        (Up &= 67108863),
        (b = Math.imul(tt, bt)),
        (p = Math.imul(tt, gt)),
        (p = (p + Math.imul(nt, bt)) | 0),
        (x = Math.imul(nt, gt)),
        (b = (b + Math.imul(Ze, vt)) | 0),
        (p = (p + Math.imul(Ze, xt)) | 0),
        (p = (p + Math.imul(et, vt)) | 0),
        (x = (x + Math.imul(et, xt)) | 0),
        (b = (b + Math.imul(Ye, Tt)) | 0),
        (p = (p + Math.imul(Ye, wt)) | 0),
        (p = (p + Math.imul(Xe, Tt)) | 0),
        (x = (x + Math.imul(Xe, wt)) | 0);
      var jp = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (jp >>> 26)) | 0),
        (jp &= 67108863),
        (b = Math.imul(tt, vt)),
        (p = Math.imul(tt, xt)),
        (p = (p + Math.imul(nt, vt)) | 0),
        (x = Math.imul(nt, xt)),
        (b = (b + Math.imul(Ze, Tt)) | 0),
        (p = (p + Math.imul(Ze, wt)) | 0),
        (p = (p + Math.imul(et, Tt)) | 0),
        (x = (x + Math.imul(et, wt)) | 0);
      var Vp = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      (I = (((x + (p >>> 13)) | 0) + (Vp >>> 26)) | 0), (Vp &= 67108863), (b = Math.imul(tt, Tt)), (p = Math.imul(tt, wt)), (p = (p + Math.imul(nt, Tt)) | 0), (x = Math.imul(nt, wt));
      var zp = (((I + b) | 0) + ((p & 8191) << 13)) | 0;
      return (
        (I = (((x + (p >>> 13)) | 0) + (zp >>> 26)) | 0),
        (zp &= 67108863),
        (M[0] = Qr),
        (M[1] = Yr),
        (M[2] = Xr),
        (M[3] = Zr),
        (M[4] = es),
        (M[5] = Ip),
        (M[6] = Op),
        (M[7] = kp),
        (M[8] = Pp),
        (M[9] = Np),
        (M[10] = Dp),
        (M[11] = Bp),
        (M[12] = Fp),
        (M[13] = Lp),
        (M[14] = $p),
        (M[15] = Up),
        (M[16] = jp),
        (M[17] = Vp),
        (M[18] = zp),
        I !== 0 && ((M[19] = I), g.length++),
        g
      );
    };
    Math.imul || (O = _);
    function B(C, d, y) {
      (y.negative = d.negative ^ C.negative), (y.length = C.length + d.length);
      for (var g = 0, S = 0, E = 0; E < y.length - 1; E++) {
        var M = S;
        S = 0;
        for (var I = g & 67108863, b = Math.min(E, d.length - 1), p = Math.max(0, E - C.length + 1); p <= b; p++) {
          var x = E - p,
            k = C.words[x] | 0,
            h = d.words[p] | 0,
            R = k * h,
            L = R & 67108863;
          (M = (M + ((R / 67108864) | 0)) | 0), (L = (L + I) | 0), (I = L & 67108863), (M = (M + (L >>> 26)) | 0), (S += M >>> 26), (M &= 67108863);
        }
        (y.words[E] = I), (g = M), (M = S);
      }
      return g !== 0 ? (y.words[E] = g) : y.length--, y._strip();
    }
    function P(C, d, y) {
      return B(C, d, y);
    }
    (s.prototype.mulTo = function (d, y) {
      var g,
        S = this.length + d.length;
      return this.length === 10 && d.length === 10 ? (g = O(this, d, y)) : S < 63 ? (g = _(this, d, y)) : S < 1024 ? (g = B(this, d, y)) : (g = P(this, d, y)), g;
    }),
      (s.prototype.mul = function (d) {
        var y = new s(null);
        return (y.words = new Array(this.length + d.length)), this.mulTo(d, y);
      }),
      (s.prototype.mulf = function (d) {
        var y = new s(null);
        return (y.words = new Array(this.length + d.length)), P(this, d, y);
      }),
      (s.prototype.imul = function (d) {
        return this.clone().mulTo(d, this);
      }),
      (s.prototype.imuln = function (d) {
        var y = d < 0;
        y && (d = -d), i(typeof d == 'number'), i(d < 67108864);
        for (var g = 0, S = 0; S < this.length; S++) {
          var E = (this.words[S] | 0) * d,
            M = (E & 67108863) + (g & 67108863);
          (g >>= 26), (g += (E / 67108864) | 0), (g += M >>> 26), (this.words[S] = M & 67108863);
        }
        return g !== 0 && ((this.words[S] = g), this.length++), y ? this.ineg() : this;
      }),
      (s.prototype.muln = function (d) {
        return this.clone().imuln(d);
      }),
      (s.prototype.sqr = function () {
        return this.mul(this);
      }),
      (s.prototype.isqr = function () {
        return this.imul(this.clone());
      }),
      (s.prototype.pow = function (d) {
        var y = A(d);
        if (y.length === 0) return new s(1);
        for (var g = this, S = 0; S < y.length && y[S] === 0; S++, g = g.sqr());
        if (++S < y.length) for (var E = g.sqr(); S < y.length; S++, E = E.sqr()) y[S] !== 0 && (g = g.mul(E));
        return g;
      }),
      (s.prototype.iushln = function (d) {
        i(typeof d == 'number' && d >= 0);
        var y = d % 26,
          g = (d - y) / 26,
          S = (67108863 >>> (26 - y)) << (26 - y),
          E;
        if (y !== 0) {
          var M = 0;
          for (E = 0; E < this.length; E++) {
            var I = this.words[E] & S,
              b = ((this.words[E] | 0) - I) << y;
            (this.words[E] = b | M), (M = I >>> (26 - y));
          }
          M && ((this.words[E] = M), this.length++);
        }
        if (g !== 0) {
          for (E = this.length - 1; E >= 0; E--) this.words[E + g] = this.words[E];
          for (E = 0; E < g; E++) this.words[E] = 0;
          this.length += g;
        }
        return this._strip();
      }),
      (s.prototype.ishln = function (d) {
        return i(this.negative === 0), this.iushln(d);
      }),
      (s.prototype.iushrn = function (d, y, g) {
        i(typeof d == 'number' && d >= 0);
        var S;
        y ? (S = (y - (y % 26)) / 26) : (S = 0);
        var E = d % 26,
          M = Math.min((d - E) / 26, this.length),
          I = 67108863 ^ ((67108863 >>> E) << E),
          b = g;
        if (((S -= M), (S = Math.max(0, S)), b)) {
          for (var p = 0; p < M; p++) b.words[p] = this.words[p];
          b.length = M;
        }
        if (M !== 0)
          if (this.length > M) for (this.length -= M, p = 0; p < this.length; p++) this.words[p] = this.words[p + M];
          else (this.words[0] = 0), (this.length = 1);
        var x = 0;
        for (p = this.length - 1; p >= 0 && (x !== 0 || p >= S); p--) {
          var k = this.words[p] | 0;
          (this.words[p] = (x << (26 - E)) | (k >>> E)), (x = k & I);
        }
        return b && x !== 0 && (b.words[b.length++] = x), this.length === 0 && ((this.words[0] = 0), (this.length = 1)), this._strip();
      }),
      (s.prototype.ishrn = function (d, y, g) {
        return i(this.negative === 0), this.iushrn(d, y, g);
      }),
      (s.prototype.shln = function (d) {
        return this.clone().ishln(d);
      }),
      (s.prototype.ushln = function (d) {
        return this.clone().iushln(d);
      }),
      (s.prototype.shrn = function (d) {
        return this.clone().ishrn(d);
      }),
      (s.prototype.ushrn = function (d) {
        return this.clone().iushrn(d);
      }),
      (s.prototype.testn = function (d) {
        i(typeof d == 'number' && d >= 0);
        var y = d % 26,
          g = (d - y) / 26,
          S = 1 << y;
        if (this.length <= g) return !1;
        var E = this.words[g];
        return !!(E & S);
      }),
      (s.prototype.imaskn = function (d) {
        i(typeof d == 'number' && d >= 0);
        var y = d % 26,
          g = (d - y) / 26;
        if ((i(this.negative === 0, 'imaskn works only with positive numbers'), this.length <= g)) return this;
        if ((y !== 0 && g++, (this.length = Math.min(g, this.length)), y !== 0)) {
          var S = 67108863 ^ ((67108863 >>> y) << y);
          this.words[this.length - 1] &= S;
        }
        return this._strip();
      }),
      (s.prototype.maskn = function (d) {
        return this.clone().imaskn(d);
      }),
      (s.prototype.iaddn = function (d) {
        return (
          i(typeof d == 'number'),
          i(d < 67108864),
          d < 0
            ? this.isubn(-d)
            : this.negative !== 0
            ? this.length === 1 && (this.words[0] | 0) <= d
              ? ((this.words[0] = d - (this.words[0] | 0)), (this.negative = 0), this)
              : ((this.negative = 0), this.isubn(d), (this.negative = 1), this)
            : this._iaddn(d)
        );
      }),
      (s.prototype._iaddn = function (d) {
        this.words[0] += d;
        for (var y = 0; y < this.length && this.words[y] >= 67108864; y++) (this.words[y] -= 67108864), y === this.length - 1 ? (this.words[y + 1] = 1) : this.words[y + 1]++;
        return (this.length = Math.max(this.length, y + 1)), this;
      }),
      (s.prototype.isubn = function (d) {
        if ((i(typeof d == 'number'), i(d < 67108864), d < 0)) return this.iaddn(-d);
        if (this.negative !== 0) return (this.negative = 0), this.iaddn(d), (this.negative = 1), this;
        if (((this.words[0] -= d), this.length === 1 && this.words[0] < 0)) (this.words[0] = -this.words[0]), (this.negative = 1);
        else for (var y = 0; y < this.length && this.words[y] < 0; y++) (this.words[y] += 67108864), (this.words[y + 1] -= 1);
        return this._strip();
      }),
      (s.prototype.addn = function (d) {
        return this.clone().iaddn(d);
      }),
      (s.prototype.subn = function (d) {
        return this.clone().isubn(d);
      }),
      (s.prototype.iabs = function () {
        return (this.negative = 0), this;
      }),
      (s.prototype.abs = function () {
        return this.clone().iabs();
      }),
      (s.prototype._ishlnsubmul = function (d, y, g) {
        var S = d.length + g,
          E;
        this._expand(S);
        var M,
          I = 0;
        for (E = 0; E < d.length; E++) {
          M = (this.words[E + g] | 0) + I;
          var b = (d.words[E] | 0) * y;
          (M -= b & 67108863), (I = (M >> 26) - ((b / 67108864) | 0)), (this.words[E + g] = M & 67108863);
        }
        for (; E < this.length - g; E++) (M = (this.words[E + g] | 0) + I), (I = M >> 26), (this.words[E + g] = M & 67108863);
        if (I === 0) return this._strip();
        for (i(I === -1), I = 0, E = 0; E < this.length; E++) (M = -(this.words[E] | 0) + I), (I = M >> 26), (this.words[E] = M & 67108863);
        return (this.negative = 1), this._strip();
      }),
      (s.prototype._wordDiv = function (d, y) {
        var g = this.length - d.length,
          S = this.clone(),
          E = d,
          M = E.words[E.length - 1] | 0,
          I = this._countBits(M);
        (g = 26 - I), g !== 0 && ((E = E.ushln(g)), S.iushln(g), (M = E.words[E.length - 1] | 0));
        var b = S.length - E.length,
          p;
        if (y !== 'mod') {
          (p = new s(null)), (p.length = b + 1), (p.words = new Array(p.length));
          for (var x = 0; x < p.length; x++) p.words[x] = 0;
        }
        var k = S.clone()._ishlnsubmul(E, 1, b);
        k.negative === 0 && ((S = k), p && (p.words[b] = 1));
        for (var h = b - 1; h >= 0; h--) {
          var R = (S.words[E.length + h] | 0) * 67108864 + (S.words[E.length + h - 1] | 0);
          for (R = Math.min((R / M) | 0, 67108863), S._ishlnsubmul(E, R, h); S.negative !== 0; ) R--, (S.negative = 0), S._ishlnsubmul(E, 1, h), S.isZero() || (S.negative ^= 1);
          p && (p.words[h] = R);
        }
        return (
          p && p._strip(),
          S._strip(),
          y !== 'div' && g !== 0 && S.iushrn(g),
          {
            div: p || null,
            mod: S,
          }
        );
      }),
      (s.prototype.divmod = function (d, y, g) {
        if ((i(!d.isZero()), this.isZero()))
          return {
            div: new s(0),
            mod: new s(0),
          };
        var S, E, M;
        return this.negative !== 0 && d.negative === 0
          ? ((M = this.neg().divmod(d, y)),
            y !== 'mod' && (S = M.div.neg()),
            y !== 'div' && ((E = M.mod.neg()), g && E.negative !== 0 && E.iadd(d)),
            {
              div: S,
              mod: E,
            })
          : this.negative === 0 && d.negative !== 0
          ? ((M = this.divmod(d.neg(), y)),
            y !== 'mod' && (S = M.div.neg()),
            {
              div: S,
              mod: M.mod,
            })
          : this.negative & d.negative
          ? ((M = this.neg().divmod(d.neg(), y)),
            y !== 'div' && ((E = M.mod.neg()), g && E.negative !== 0 && E.isub(d)),
            {
              div: M.div,
              mod: E,
            })
          : d.length > this.length || this.cmp(d) < 0
          ? {
              div: new s(0),
              mod: this,
            }
          : d.length === 1
          ? y === 'div'
            ? {
                div: this.divn(d.words[0]),
                mod: null,
              }
            : y === 'mod'
            ? {
                div: null,
                mod: new s(this.modrn(d.words[0])),
              }
            : {
                div: this.divn(d.words[0]),
                mod: new s(this.modrn(d.words[0])),
              }
          : this._wordDiv(d, y);
      }),
      (s.prototype.div = function (d) {
        return this.divmod(d, 'div', !1).div;
      }),
      (s.prototype.mod = function (d) {
        return this.divmod(d, 'mod', !1).mod;
      }),
      (s.prototype.umod = function (d) {
        return this.divmod(d, 'mod', !0).mod;
      }),
      (s.prototype.divRound = function (d) {
        var y = this.divmod(d);
        if (y.mod.isZero()) return y.div;
        var g = y.div.negative !== 0 ? y.mod.isub(d) : y.mod,
          S = d.ushrn(1),
          E = d.andln(1),
          M = g.cmp(S);
        return M < 0 || (E === 1 && M === 0) ? y.div : y.div.negative !== 0 ? y.div.isubn(1) : y.div.iaddn(1);
      }),
      (s.prototype.modrn = function (d) {
        var y = d < 0;
        y && (d = -d), i(d <= 67108863);
        for (var g = (1 << 26) % d, S = 0, E = this.length - 1; E >= 0; E--) S = (g * S + (this.words[E] | 0)) % d;
        return y ? -S : S;
      }),
      (s.prototype.modn = function (d) {
        return this.modrn(d);
      }),
      (s.prototype.idivn = function (d) {
        var y = d < 0;
        y && (d = -d), i(d <= 67108863);
        for (var g = 0, S = this.length - 1; S >= 0; S--) {
          var E = (this.words[S] | 0) + g * 67108864;
          (this.words[S] = (E / d) | 0), (g = E % d);
        }
        return this._strip(), y ? this.ineg() : this;
      }),
      (s.prototype.divn = function (d) {
        return this.clone().idivn(d);
      }),
      (s.prototype.egcd = function (d) {
        i(d.negative === 0), i(!d.isZero());
        var y = this,
          g = d.clone();
        y.negative !== 0 ? (y = y.umod(d)) : (y = y.clone());
        for (var S = new s(1), E = new s(0), M = new s(0), I = new s(1), b = 0; y.isEven() && g.isEven(); ) y.iushrn(1), g.iushrn(1), ++b;
        for (var p = g.clone(), x = y.clone(); !y.isZero(); ) {
          for (var k = 0, h = 1; !(y.words[0] & h) && k < 26; ++k, h <<= 1);
          if (k > 0) for (y.iushrn(k); k-- > 0; ) (S.isOdd() || E.isOdd()) && (S.iadd(p), E.isub(x)), S.iushrn(1), E.iushrn(1);
          for (var R = 0, L = 1; !(g.words[0] & L) && R < 26; ++R, L <<= 1);
          if (R > 0) for (g.iushrn(R); R-- > 0; ) (M.isOdd() || I.isOdd()) && (M.iadd(p), I.isub(x)), M.iushrn(1), I.iushrn(1);
          y.cmp(g) >= 0 ? (y.isub(g), S.isub(M), E.isub(I)) : (g.isub(y), M.isub(S), I.isub(E));
        }
        return {
          a: M,
          b: I,
          gcd: g.iushln(b),
        };
      }),
      (s.prototype._invmp = function (d) {
        i(d.negative === 0), i(!d.isZero());
        var y = this,
          g = d.clone();
        y.negative !== 0 ? (y = y.umod(d)) : (y = y.clone());
        for (var S = new s(1), E = new s(0), M = g.clone(); y.cmpn(1) > 0 && g.cmpn(1) > 0; ) {
          for (var I = 0, b = 1; !(y.words[0] & b) && I < 26; ++I, b <<= 1);
          if (I > 0) for (y.iushrn(I); I-- > 0; ) S.isOdd() && S.iadd(M), S.iushrn(1);
          for (var p = 0, x = 1; !(g.words[0] & x) && p < 26; ++p, x <<= 1);
          if (p > 0) for (g.iushrn(p); p-- > 0; ) E.isOdd() && E.iadd(M), E.iushrn(1);
          y.cmp(g) >= 0 ? (y.isub(g), S.isub(E)) : (g.isub(y), E.isub(S));
        }
        var k;
        return y.cmpn(1) === 0 ? (k = S) : (k = E), k.cmpn(0) < 0 && k.iadd(d), k;
      }),
      (s.prototype.gcd = function (d) {
        if (this.isZero()) return d.abs();
        if (d.isZero()) return this.abs();
        var y = this.clone(),
          g = d.clone();
        (y.negative = 0), (g.negative = 0);
        for (var S = 0; y.isEven() && g.isEven(); S++) y.iushrn(1), g.iushrn(1);
        do {
          for (; y.isEven(); ) y.iushrn(1);
          for (; g.isEven(); ) g.iushrn(1);
          var E = y.cmp(g);
          if (E < 0) {
            var M = y;
            (y = g), (g = M);
          } else if (E === 0 || g.cmpn(1) === 0) break;
          y.isub(g);
        } while (!0);
        return g.iushln(S);
      }),
      (s.prototype.invm = function (d) {
        return this.egcd(d).a.umod(d);
      }),
      (s.prototype.isEven = function () {
        return (this.words[0] & 1) === 0;
      }),
      (s.prototype.isOdd = function () {
        return (this.words[0] & 1) === 1;
      }),
      (s.prototype.andln = function (d) {
        return this.words[0] & d;
      }),
      (s.prototype.bincn = function (d) {
        i(typeof d == 'number');
        var y = d % 26,
          g = (d - y) / 26,
          S = 1 << y;
        if (this.length <= g) return this._expand(g + 1), (this.words[g] |= S), this;
        for (var E = S, M = g; E !== 0 && M < this.length; M++) {
          var I = this.words[M] | 0;
          (I += E), (E = I >>> 26), (I &= 67108863), (this.words[M] = I);
        }
        return E !== 0 && ((this.words[M] = E), this.length++), this;
      }),
      (s.prototype.isZero = function () {
        return this.length === 1 && this.words[0] === 0;
      }),
      (s.prototype.cmpn = function (d) {
        var y = d < 0;
        if (this.negative !== 0 && !y) return -1;
        if (this.negative === 0 && y) return 1;
        this._strip();
        var g;
        if (this.length > 1) g = 1;
        else {
          y && (d = -d), i(d <= 67108863, 'Number is too big');
          var S = this.words[0] | 0;
          g = S === d ? 0 : S < d ? -1 : 1;
        }
        return this.negative !== 0 ? -g | 0 : g;
      }),
      (s.prototype.cmp = function (d) {
        if (this.negative !== 0 && d.negative === 0) return -1;
        if (this.negative === 0 && d.negative !== 0) return 1;
        var y = this.ucmp(d);
        return this.negative !== 0 ? -y | 0 : y;
      }),
      (s.prototype.ucmp = function (d) {
        if (this.length > d.length) return 1;
        if (this.length < d.length) return -1;
        for (var y = 0, g = this.length - 1; g >= 0; g--) {
          var S = this.words[g] | 0,
            E = d.words[g] | 0;
          if (S !== E) {
            S < E ? (y = -1) : S > E && (y = 1);
            break;
          }
        }
        return y;
      }),
      (s.prototype.gtn = function (d) {
        return this.cmpn(d) === 1;
      }),
      (s.prototype.gt = function (d) {
        return this.cmp(d) === 1;
      }),
      (s.prototype.gten = function (d) {
        return this.cmpn(d) >= 0;
      }),
      (s.prototype.gte = function (d) {
        return this.cmp(d) >= 0;
      }),
      (s.prototype.ltn = function (d) {
        return this.cmpn(d) === -1;
      }),
      (s.prototype.lt = function (d) {
        return this.cmp(d) === -1;
      }),
      (s.prototype.lten = function (d) {
        return this.cmpn(d) <= 0;
      }),
      (s.prototype.lte = function (d) {
        return this.cmp(d) <= 0;
      }),
      (s.prototype.eqn = function (d) {
        return this.cmpn(d) === 0;
      }),
      (s.prototype.eq = function (d) {
        return this.cmp(d) === 0;
      }),
      (s.red = function (d) {
        return new J(d);
      }),
      (s.prototype.toRed = function (d) {
        return i(!this.red, 'Already a number in reduction context'), i(this.negative === 0, 'red works only with positives'), d.convertTo(this)._forceRed(d);
      }),
      (s.prototype.fromRed = function () {
        return i(this.red, 'fromRed works only with numbers in reduction context'), this.red.convertFrom(this);
      }),
      (s.prototype._forceRed = function (d) {
        return (this.red = d), this;
      }),
      (s.prototype.forceRed = function (d) {
        return i(!this.red, 'Already a number in reduction context'), this._forceRed(d);
      }),
      (s.prototype.redAdd = function (d) {
        return i(this.red, 'redAdd works only with red numbers'), this.red.add(this, d);
      }),
      (s.prototype.redIAdd = function (d) {
        return i(this.red, 'redIAdd works only with red numbers'), this.red.iadd(this, d);
      }),
      (s.prototype.redSub = function (d) {
        return i(this.red, 'redSub works only with red numbers'), this.red.sub(this, d);
      }),
      (s.prototype.redISub = function (d) {
        return i(this.red, 'redISub works only with red numbers'), this.red.isub(this, d);
      }),
      (s.prototype.redShl = function (d) {
        return i(this.red, 'redShl works only with red numbers'), this.red.shl(this, d);
      }),
      (s.prototype.redMul = function (d) {
        return i(this.red, 'redMul works only with red numbers'), this.red._verify2(this, d), this.red.mul(this, d);
      }),
      (s.prototype.redIMul = function (d) {
        return i(this.red, 'redMul works only with red numbers'), this.red._verify2(this, d), this.red.imul(this, d);
      }),
      (s.prototype.redSqr = function () {
        return i(this.red, 'redSqr works only with red numbers'), this.red._verify1(this), this.red.sqr(this);
      }),
      (s.prototype.redISqr = function () {
        return i(this.red, 'redISqr works only with red numbers'), this.red._verify1(this), this.red.isqr(this);
      }),
      (s.prototype.redSqrt = function () {
        return i(this.red, 'redSqrt works only with red numbers'), this.red._verify1(this), this.red.sqrt(this);
      }),
      (s.prototype.redInvm = function () {
        return i(this.red, 'redInvm works only with red numbers'), this.red._verify1(this), this.red.invm(this);
      }),
      (s.prototype.redNeg = function () {
        return i(this.red, 'redNeg works only with red numbers'), this.red._verify1(this), this.red.neg(this);
      }),
      (s.prototype.redPow = function (d) {
        return i(this.red && !d.red, 'redPow(normalNum)'), this.red._verify1(this), this.red.pow(this, d);
      });
    var N = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null,
    };
    function U(C, d) {
      (this.name = C), (this.p = new s(d, 16)), (this.n = this.p.bitLength()), (this.k = new s(1).iushln(this.n).isub(this.p)), (this.tmp = this._tmp());
    }
    (U.prototype._tmp = function () {
      var d = new s(null);
      return (d.words = new Array(Math.ceil(this.n / 13))), d;
    }),
      (U.prototype.ireduce = function (d) {
        var y = d,
          g;
        do this.split(y, this.tmp), (y = this.imulK(y)), (y = y.iadd(this.tmp)), (g = y.bitLength());
        while (g > this.n);
        var S = g < this.n ? -1 : y.ucmp(this.p);
        return S === 0 ? ((y.words[0] = 0), (y.length = 1)) : S > 0 ? y.isub(this.p) : y.strip !== void 0 ? y.strip() : y._strip(), y;
      }),
      (U.prototype.split = function (d, y) {
        d.iushrn(this.n, 0, y);
      }),
      (U.prototype.imulK = function (d) {
        return d.imul(this.k);
      });
    function W() {
      U.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    r(W, U),
      (W.prototype.split = function (d, y) {
        for (var g = 4194303, S = Math.min(d.length, 9), E = 0; E < S; E++) y.words[E] = d.words[E];
        if (((y.length = S), d.length <= 9)) {
          (d.words[0] = 0), (d.length = 1);
          return;
        }
        var M = d.words[9];
        for (y.words[y.length++] = M & g, E = 10; E < d.length; E++) {
          var I = d.words[E] | 0;
          (d.words[E - 10] = ((I & g) << 4) | (M >>> 22)), (M = I);
        }
        (M >>>= 22), (d.words[E - 10] = M), M === 0 && d.length > 10 ? (d.length -= 10) : (d.length -= 9);
      }),
      (W.prototype.imulK = function (d) {
        (d.words[d.length] = 0), (d.words[d.length + 1] = 0), (d.length += 2);
        for (var y = 0, g = 0; g < d.length; g++) {
          var S = d.words[g] | 0;
          (y += S * 977), (d.words[g] = y & 67108863), (y = S * 64 + ((y / 67108864) | 0));
        }
        return d.words[d.length - 1] === 0 && (d.length--, d.words[d.length - 1] === 0 && d.length--), d;
      });
    function z() {
      U.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    r(z, U);
    function Y() {
      U.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    r(Y, U);
    function ue() {
      U.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    r(ue, U),
      (ue.prototype.imulK = function (d) {
        for (var y = 0, g = 0; g < d.length; g++) {
          var S = (d.words[g] | 0) * 19 + y,
            E = S & 67108863;
          (S >>>= 26), (d.words[g] = E), (y = S);
        }
        return y !== 0 && (d.words[d.length++] = y), d;
      }),
      (s._prime = function (d) {
        if (N[d]) return N[d];
        var y;
        if (d === 'k256') y = new W();
        else if (d === 'p224') y = new z();
        else if (d === 'p192') y = new Y();
        else if (d === 'p25519') y = new ue();
        else throw new Error('Unknown prime ' + d);
        return (N[d] = y), y;
      });
    function J(C) {
      if (typeof C == 'string') {
        var d = s._prime(C);
        (this.m = d.p), (this.prime = d);
      } else i(C.gtn(1), 'modulus must be greater than 1'), (this.m = C), (this.prime = null);
    }
    (J.prototype._verify1 = function (d) {
      i(d.negative === 0, 'red works only with positives'), i(d.red, 'red works only with red numbers');
    }),
      (J.prototype._verify2 = function (d, y) {
        i((d.negative | y.negative) === 0, 'red works only with positives'), i(d.red && d.red === y.red, 'red works only with red numbers');
      }),
      (J.prototype.imod = function (d) {
        return this.prime ? this.prime.ireduce(d)._forceRed(this) : (c(d, d.umod(this.m)._forceRed(this)), d);
      }),
      (J.prototype.neg = function (d) {
        return d.isZero() ? d.clone() : this.m.sub(d)._forceRed(this);
      }),
      (J.prototype.add = function (d, y) {
        this._verify2(d, y);
        var g = d.add(y);
        return g.cmp(this.m) >= 0 && g.isub(this.m), g._forceRed(this);
      }),
      (J.prototype.iadd = function (d, y) {
        this._verify2(d, y);
        var g = d.iadd(y);
        return g.cmp(this.m) >= 0 && g.isub(this.m), g;
      }),
      (J.prototype.sub = function (d, y) {
        this._verify2(d, y);
        var g = d.sub(y);
        return g.cmpn(0) < 0 && g.iadd(this.m), g._forceRed(this);
      }),
      (J.prototype.isub = function (d, y) {
        this._verify2(d, y);
        var g = d.isub(y);
        return g.cmpn(0) < 0 && g.iadd(this.m), g;
      }),
      (J.prototype.shl = function (d, y) {
        return this._verify1(d), this.imod(d.ushln(y));
      }),
      (J.prototype.imul = function (d, y) {
        return this._verify2(d, y), this.imod(d.imul(y));
      }),
      (J.prototype.mul = function (d, y) {
        return this._verify2(d, y), this.imod(d.mul(y));
      }),
      (J.prototype.isqr = function (d) {
        return this.imul(d, d.clone());
      }),
      (J.prototype.sqr = function (d) {
        return this.mul(d, d);
      }),
      (J.prototype.sqrt = function (d) {
        if (d.isZero()) return d.clone();
        var y = this.m.andln(3);
        if ((i(y % 2 === 1), y === 3)) {
          var g = this.m.add(new s(1)).iushrn(2);
          return this.pow(d, g);
        }
        for (var S = this.m.subn(1), E = 0; !S.isZero() && S.andln(1) === 0; ) E++, S.iushrn(1);
        i(!S.isZero());
        var M = new s(1).toRed(this),
          I = M.redNeg(),
          b = this.m.subn(1).iushrn(1),
          p = this.m.bitLength();
        for (p = new s(2 * p * p).toRed(this); this.pow(p, b).cmp(I) !== 0; ) p.redIAdd(I);
        for (var x = this.pow(p, S), k = this.pow(d, S.addn(1).iushrn(1)), h = this.pow(d, S), R = E; h.cmp(M) !== 0; ) {
          for (var L = h, F = 0; L.cmp(M) !== 0; F++) L = L.redSqr();
          i(F < R);
          var $ = this.pow(x, new s(1).iushln(R - F - 1));
          (k = k.redMul($)), (x = $.redSqr()), (h = h.redMul(x)), (R = F);
        }
        return k;
      }),
      (J.prototype.invm = function (d) {
        var y = d._invmp(this.m);
        return y.negative !== 0 ? ((y.negative = 0), this.imod(y).redNeg()) : this.imod(y);
      }),
      (J.prototype.pow = function (d, y) {
        if (y.isZero()) return new s(1).toRed(this);
        if (y.cmpn(1) === 0) return d.clone();
        var g = 4,
          S = new Array(1 << g);
        (S[0] = new s(1).toRed(this)), (S[1] = d);
        for (var E = 2; E < S.length; E++) S[E] = this.mul(S[E - 1], d);
        var M = S[0],
          I = 0,
          b = 0,
          p = y.bitLength() % 26;
        for (p === 0 && (p = 26), E = y.length - 1; E >= 0; E--) {
          for (var x = y.words[E], k = p - 1; k >= 0; k--) {
            var h = (x >> k) & 1;
            if ((M !== S[0] && (M = this.sqr(M)), h === 0 && I === 0)) {
              b = 0;
              continue;
            }
            (I <<= 1), (I |= h), b++, !(b !== g && (E !== 0 || k !== 0)) && ((M = this.mul(M, S[I])), (b = 0), (I = 0));
          }
          p = 26;
        }
        return M;
      }),
      (J.prototype.convertTo = function (d) {
        var y = d.umod(this.m);
        return y === d ? y.clone() : y;
      }),
      (J.prototype.convertFrom = function (d) {
        var y = d.clone();
        return (y.red = null), y;
      }),
      (s.mont = function (d) {
        return new le(d);
      });
    function le(C) {
      J.call(this, C),
        (this.shift = this.m.bitLength()),
        this.shift % 26 !== 0 && (this.shift += 26 - (this.shift % 26)),
        (this.r = new s(1).iushln(this.shift)),
        (this.r2 = this.imod(this.r.sqr())),
        (this.rinv = this.r._invmp(this.m)),
        (this.minv = this.rinv.mul(this.r).isubn(1).div(this.m)),
        (this.minv = this.minv.umod(this.r)),
        (this.minv = this.r.sub(this.minv));
    }
    r(le, J),
      (le.prototype.convertTo = function (d) {
        return this.imod(d.ushln(this.shift));
      }),
      (le.prototype.convertFrom = function (d) {
        var y = this.imod(d.mul(this.rinv));
        return (y.red = null), y;
      }),
      (le.prototype.imul = function (d, y) {
        if (d.isZero() || y.isZero()) return (d.words[0] = 0), (d.length = 1), d;
        var g = d.imul(y),
          S = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          E = g.isub(S).iushrn(this.shift),
          M = E;
        return E.cmp(this.m) >= 0 ? (M = E.isub(this.m)) : E.cmpn(0) < 0 && (M = E.iadd(this.m)), M._forceRed(this);
      }),
      (le.prototype.mul = function (d, y) {
        if (d.isZero() || y.isZero()) return new s(0)._forceRed(this);
        var g = d.mul(y),
          S = g.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
          E = g.isub(S).iushrn(this.shift),
          M = E;
        return E.cmp(this.m) >= 0 ? (M = E.isub(this.m)) : E.cmpn(0) < 0 && (M = E.iadd(this.m)), M._forceRed(this);
      }),
      (le.prototype.invm = function (d) {
        var y = this.imod(d._invmp(this.m).mul(this.r2));
        return y._forceRed(this);
      });
  })(n, br);
})(nS);
const he = vy,
  aS = 'logger/5.7.0';
let Bg = !1,
  Fg = !1;
const Md = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let Lg = Md.default,
  df = null;
function oS() {
  try {
    const n = [];
    if (
      (['NFD', 'NFC', 'NFKD', 'NFKC'].forEach((e) => {
        try {
          if ('test'.normalize(e) !== 'test') throw new Error('bad normalize');
        } catch {
          n.push(e);
        }
      }),
      n.length)
    )
      throw new Error('missing ' + n.join(', '));
    if (String.fromCharCode(233).normalize('NFD') !== String.fromCharCode(101, 769)) throw new Error('broken implementation');
  } catch (n) {
    return n.message;
  }
  return null;
}
const $g = oS();
var uc;
(function (n) {
  (n.DEBUG = 'DEBUG'), (n.INFO = 'INFO'), (n.WARNING = 'WARNING'), (n.ERROR = 'ERROR'), (n.OFF = 'OFF');
})(uc || (uc = {}));
var ui;
(function (n) {
  (n.UNKNOWN_ERROR = 'UNKNOWN_ERROR'),
    (n.NOT_IMPLEMENTED = 'NOT_IMPLEMENTED'),
    (n.UNSUPPORTED_OPERATION = 'UNSUPPORTED_OPERATION'),
    (n.NETWORK_ERROR = 'NETWORK_ERROR'),
    (n.SERVER_ERROR = 'SERVER_ERROR'),
    (n.TIMEOUT = 'TIMEOUT'),
    (n.BUFFER_OVERRUN = 'BUFFER_OVERRUN'),
    (n.NUMERIC_FAULT = 'NUMERIC_FAULT'),
    (n.MISSING_NEW = 'MISSING_NEW'),
    (n.INVALID_ARGUMENT = 'INVALID_ARGUMENT'),
    (n.MISSING_ARGUMENT = 'MISSING_ARGUMENT'),
    (n.UNEXPECTED_ARGUMENT = 'UNEXPECTED_ARGUMENT'),
    (n.CALL_EXCEPTION = 'CALL_EXCEPTION'),
    (n.INSUFFICIENT_FUNDS = 'INSUFFICIENT_FUNDS'),
    (n.NONCE_EXPIRED = 'NONCE_EXPIRED'),
    (n.REPLACEMENT_UNDERPRICED = 'REPLACEMENT_UNDERPRICED'),
    (n.UNPREDICTABLE_GAS_LIMIT = 'UNPREDICTABLE_GAS_LIMIT'),
    (n.TRANSACTION_REPLACED = 'TRANSACTION_REPLACED'),
    (n.ACTION_REJECTED = 'ACTION_REJECTED');
})(ui || (ui = {}));
const Ug = '0123456789abcdef';
let D = class Ht {
  constructor(e) {
    Object.defineProperty(this, 'version', {
      enumerable: !0,
      value: e,
      writable: !1,
    });
  }
  _log(e, t) {
    const i = e.toLowerCase();
    Md[i] == null && this.throwArgumentError('invalid log level name', 'logLevel', e), !(Lg > Md[i]) && console.log.apply(console, t);
  }
  debug(...e) {
    this._log(Ht.levels.DEBUG, e);
  }
  info(...e) {
    this._log(Ht.levels.INFO, e);
  }
  warn(...e) {
    this._log(Ht.levels.WARNING, e);
  }
  makeError(e, t, i) {
    if (Fg) return this.makeError('censored error', t, {});
    t || (t = Ht.errors.UNKNOWN_ERROR), i || (i = {});
    const r = [];
    Object.keys(i).forEach((u) => {
      const l = i[u];
      try {
        if (l instanceof Uint8Array) {
          let c = '';
          for (let f = 0; f < l.length; f++) (c += Ug[l[f] >> 4]), (c += Ug[l[f] & 15]);
          r.push(u + '=Uint8Array(0x' + c + ')');
        } else r.push(u + '=' + JSON.stringify(l));
      } catch {
        r.push(u + '=' + JSON.stringify(i[u].toString()));
      }
    }),
      r.push(`code=${t}`),
      r.push(`version=${this.version}`);
    const s = e;
    let a = '';
    switch (t) {
      case ui.NUMERIC_FAULT: {
        a = 'NUMERIC_FAULT';
        const u = e;
        switch (u) {
          case 'overflow':
          case 'underflow':
          case 'division-by-zero':
            a += '-' + u;
            break;
          case 'negative-power':
          case 'negative-width':
            a += '-unsupported';
            break;
          case 'unbound-bitwise-result':
            a += '-unbound-result';
            break;
        }
        break;
      }
      case ui.CALL_EXCEPTION:
      case ui.INSUFFICIENT_FUNDS:
      case ui.MISSING_NEW:
      case ui.NONCE_EXPIRED:
      case ui.REPLACEMENT_UNDERPRICED:
      case ui.TRANSACTION_REPLACED:
      case ui.UNPREDICTABLE_GAS_LIMIT:
        a = t;
        break;
    }
    a && (e += ' [ See: https://links.ethers.org/v5-errors-' + a + ' ]'), r.length && (e += ' (' + r.join(', ') + ')');
    const o = new Error(e);
    return (
      (o.reason = s),
      (o.code = t),
      Object.keys(i).forEach(function (u) {
        o[u] = i[u];
      }),
      o
    );
  }
  throwError(e, t, i) {
    throw this.makeError(e, t, i);
  }
  throwArgumentError(e, t, i) {
    return this.throwError(e, Ht.errors.INVALID_ARGUMENT, {
      argument: t,
      value: i,
    });
  }
  assert(e, t, i, r) {
    e || this.throwError(t, i, r);
  }
  assertArgument(e, t, i, r) {
    e || this.throwArgumentError(t, i, r);
  }
  checkNormalize(e) {
    $g &&
      this.throwError('platform missing String.prototype.normalize', Ht.errors.UNSUPPORTED_OPERATION, {
        operation: 'String.prototype.normalize',
        form: $g,
      });
  }
  checkSafeUint53(e, t) {
    typeof e == 'number' &&
      (t == null && (t = 'value not safe'),
      (e < 0 || e >= 9007199254740991) &&
        this.throwError(t, Ht.errors.NUMERIC_FAULT, {
          operation: 'checkSafeInteger',
          fault: 'out-of-safe-range',
          value: e,
        }),
      e % 1 &&
        this.throwError(t, Ht.errors.NUMERIC_FAULT, {
          operation: 'checkSafeInteger',
          fault: 'non-integer',
          value: e,
        }));
  }
  checkArgumentCount(e, t, i) {
    i ? (i = ': ' + i) : (i = ''),
      e < t &&
        this.throwError('missing argument' + i, Ht.errors.MISSING_ARGUMENT, {
          count: e,
          expectedCount: t,
        }),
      e > t &&
        this.throwError('too many arguments' + i, Ht.errors.UNEXPECTED_ARGUMENT, {
          count: e,
          expectedCount: t,
        });
  }
  checkNew(e, t) {
    (e === Object || e == null) && this.throwError('missing new', Ht.errors.MISSING_NEW, { name: t.name });
  }
  checkAbstract(e, t) {
    e === t
      ? this.throwError('cannot instantiate abstract class ' + JSON.stringify(t.name) + ' directly; use a sub-class', Ht.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: 'new' })
      : (e === Object || e == null) && this.throwError('missing new', Ht.errors.MISSING_NEW, { name: t.name });
  }
  static globalLogger() {
    return df || (df = new Ht(aS)), df;
  }
  static setCensorship(e, t) {
    if (
      (!e &&
        t &&
        this.globalLogger().throwError('cannot permanently disable censorship', Ht.errors.UNSUPPORTED_OPERATION, {
          operation: 'setCensorship',
        }),
      Bg)
    ) {
      if (!e) return;
      this.globalLogger().throwError('error censorship permanent', Ht.errors.UNSUPPORTED_OPERATION, {
        operation: 'setCensorship',
      });
    }
    (Fg = !!e), (Bg = !!t);
  }
  static setLogLevel(e) {
    const t = Md[e.toLowerCase()];
    if (t == null) {
      Ht.globalLogger().warn('invalid log level - ' + e);
      return;
    }
    Lg = t;
  }
  static from(e) {
    return new Ht(e);
  }
};
D.errors = ui;
D.levels = uc;
const uS = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        get ErrorCode() {
          return ui;
        },
        get LogLevel() {
          return uc;
        },
        Logger: D,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  lS = 'bytes/5.7.0',
  It = new D(lS);
function iT(n) {
  return !!n.toHexString;
}
function co(n) {
  return (
    n.slice ||
      (n.slice = function () {
        const e = Array.prototype.slice.call(arguments);
        return co(new Uint8Array(Array.prototype.slice.apply(n, e)));
      }),
    n
  );
}
function Pl(n) {
  return (Me(n) && !(n.length % 2)) || Na(n);
}
function jg(n) {
  return typeof n == 'number' && n == n && n % 1 === 0;
}
function Na(n) {
  if (n == null) return !1;
  if (n.constructor === Uint8Array) return !0;
  if (typeof n == 'string' || !jg(n.length) || n.length < 0) return !1;
  for (let e = 0; e < n.length; e++) {
    const t = n[e];
    if (!jg(t) || t < 0 || t >= 256) return !1;
  }
  return !0;
}
function H(n, e) {
  if ((e || (e = {}), typeof n == 'number')) {
    It.checkSafeUint53(n, 'invalid arrayify value');
    const t = [];
    for (; n; ) t.unshift(n & 255), (n = parseInt(String(n / 256)));
    return t.length === 0 && t.push(0), co(new Uint8Array(t));
  }
  if ((e.allowMissingPrefix && typeof n == 'string' && n.substring(0, 2) !== '0x' && (n = '0x' + n), iT(n) && (n = n.toHexString()), Me(n))) {
    let t = n.substring(2);
    t.length % 2 && (e.hexPad === 'left' ? (t = '0' + t) : e.hexPad === 'right' ? (t += '0') : It.throwArgumentError('hex data is odd-length', 'value', n));
    const i = [];
    for (let r = 0; r < t.length; r += 2) i.push(parseInt(t.substring(r, r + 2), 16));
    return co(new Uint8Array(i));
  }
  return Na(n) ? co(new Uint8Array(n)) : It.throwArgumentError('invalid arrayify value', 'value', n);
}
function Ge(n) {
  const e = n.map((r) => H(r)),
    t = e.reduce((r, s) => r + s.length, 0),
    i = new Uint8Array(t);
  return e.reduce((r, s) => (i.set(s, r), r + s.length), 0), co(i);
}
function Qi(n) {
  let e = H(n);
  if (e.length === 0) return e;
  let t = 0;
  for (; t < e.length && e[t] === 0; ) t++;
  return t && (e = e.slice(t)), e;
}
function Au(n, e) {
  (n = H(n)), n.length > e && It.throwArgumentError('value out of range', 'value', arguments[0]);
  const t = new Uint8Array(e);
  return t.set(n, e - n.length), co(t);
}
function Me(n, e) {
  return !(typeof n != 'string' || !n.match(/^0x[0-9A-Fa-f]*$/) || (e && n.length !== 2 + 2 * e));
}
const cf = '0123456789abcdef';
function K(n, e) {
  if ((e || (e = {}), typeof n == 'number')) {
    It.checkSafeUint53(n, 'invalid hexlify value');
    let t = '';
    for (; n; ) (t = cf[n & 15] + t), (n = Math.floor(n / 16));
    return t.length ? (t.length % 2 && (t = '0' + t), '0x' + t) : '0x00';
  }
  if (typeof n == 'bigint') return (n = n.toString(16)), n.length % 2 ? '0x0' + n : '0x' + n;
  if ((e.allowMissingPrefix && typeof n == 'string' && n.substring(0, 2) !== '0x' && (n = '0x' + n), iT(n))) return n.toHexString();
  if (Me(n))
    return n.length % 2 && (e.hexPad === 'left' ? (n = '0x0' + n.substring(2)) : e.hexPad === 'right' ? (n += '0') : It.throwArgumentError('hex data is odd-length', 'value', n)), n.toLowerCase();
  if (Na(n)) {
    let t = '0x';
    for (let i = 0; i < n.length; i++) {
      let r = n[i];
      t += cf[(r & 240) >> 4] + cf[r & 15];
    }
    return t;
  }
  return It.throwArgumentError('invalid hexlify value', 'value', n);
}
function nr(n) {
  if (typeof n != 'string') n = K(n);
  else if (!Me(n) || n.length % 2) return null;
  return (n.length - 2) / 2;
}
function Lt(n, e, t) {
  return (
    typeof n != 'string' ? (n = K(n)) : (!Me(n) || n.length % 2) && It.throwArgumentError('invalid hexData', 'value', n),
    (e = 2 + 2 * e),
    t != null ? '0x' + n.substring(e, 2 + 2 * t) : '0x' + n.substring(e)
  );
}
function Cn(n) {
  let e = '0x';
  return (
    n.forEach((t) => {
      e += K(t).substring(2);
    }),
    e
  );
}
function Xc(n) {
  const e = rT(K(n, { hexPad: 'left' }));
  return e === '0x' ? '0x0' : e;
}
function rT(n) {
  typeof n != 'string' && (n = K(n)), Me(n) || It.throwArgumentError('invalid hex string', 'value', n), (n = n.substring(2));
  let e = 0;
  for (; e < n.length && n[e] === '0'; ) e++;
  return '0x' + n.substring(e);
}
function Le(n, e) {
  for (
    typeof n != 'string' ? (n = K(n)) : Me(n) || It.throwArgumentError('invalid hex string', 'value', n), n.length > 2 * e + 2 && It.throwArgumentError('value out of range', 'value', arguments[1]);
    n.length < 2 * e + 2;

  )
    n = '0x0' + n.substring(2);
  return n;
}
function Da(n) {
  const e = {
    r: '0x',
    s: '0x',
    _vs: '0x',
    recoveryParam: 0,
    v: 0,
    yParityAndS: '0x',
    compact: '0x',
  };
  if (Pl(n)) {
    let t = H(n);
    t.length === 64
      ? ((e.v = 27 + (t[32] >> 7)), (t[32] &= 127), (e.r = K(t.slice(0, 32))), (e.s = K(t.slice(32, 64))))
      : t.length === 65
      ? ((e.r = K(t.slice(0, 32))), (e.s = K(t.slice(32, 64))), (e.v = t[64]))
      : It.throwArgumentError('invalid signature string', 'signature', n),
      e.v < 27 && (e.v === 0 || e.v === 1 ? (e.v += 27) : It.throwArgumentError('signature invalid v byte', 'signature', n)),
      (e.recoveryParam = 1 - (e.v % 2)),
      e.recoveryParam && (t[32] |= 128),
      (e._vs = K(t.slice(32, 64)));
  } else {
    if (((e.r = n.r), (e.s = n.s), (e.v = n.v), (e.recoveryParam = n.recoveryParam), (e._vs = n._vs), e._vs != null)) {
      const r = Au(H(e._vs), 32);
      e._vs = K(r);
      const s = r[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? (e.recoveryParam = s) : e.recoveryParam !== s && It.throwArgumentError('signature recoveryParam mismatch _vs', 'signature', n), (r[0] &= 127);
      const a = K(r);
      e.s == null ? (e.s = a) : e.s !== a && It.throwArgumentError('signature v mismatch _vs', 'signature', n);
    }
    if (e.recoveryParam == null)
      e.v == null ? It.throwArgumentError('signature missing v and recoveryParam', 'signature', n) : e.v === 0 || e.v === 1 ? (e.recoveryParam = e.v) : (e.recoveryParam = 1 - (e.v % 2));
    else if (e.v == null) e.v = 27 + e.recoveryParam;
    else {
      const r = e.v === 0 || e.v === 1 ? e.v : 1 - (e.v % 2);
      e.recoveryParam !== r && It.throwArgumentError('signature recoveryParam mismatch v', 'signature', n);
    }
    e.r == null || !Me(e.r) ? It.throwArgumentError('signature missing or invalid r', 'signature', n) : (e.r = Le(e.r, 32)),
      e.s == null || !Me(e.s) ? It.throwArgumentError('signature missing or invalid s', 'signature', n) : (e.s = Le(e.s, 32));
    const t = H(e.s);
    t[0] >= 128 && It.throwArgumentError('signature s out of range', 'signature', n), e.recoveryParam && (t[0] |= 128);
    const i = K(t);
    e._vs && (Me(e._vs) || It.throwArgumentError('signature invalid _vs', 'signature', n), (e._vs = Le(e._vs, 32))),
      e._vs == null ? (e._vs = i) : e._vs !== i && It.throwArgumentError('signature _vs mismatch v and s', 'signature', n);
  }
  return (e.yParityAndS = e._vs), (e.compact = e.r + e.yParityAndS.substring(2)), e;
}
function xy(n) {
  return (n = Da(n)), K(Ge([n.r, n.s, n.recoveryParam ? '0x1c' : '0x1b']));
}
const dS = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        arrayify: H,
        concat: Ge,
        hexConcat: Cn,
        hexDataLength: nr,
        hexDataSlice: Lt,
        hexStripZeros: rT,
        hexValue: Xc,
        hexZeroPad: Le,
        hexlify: K,
        isBytes: Na,
        isBytesLike: Pl,
        isHexString: Me,
        joinSignature: xy,
        splitSignature: Da,
        stripZeros: Qi,
        zeroPad: Au,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  sT = 'bignumber/5.7.0';
var Hu = he.BN;
const hr = new D(sT),
  pf = {},
  Vg = 9007199254740991;
function cS(n) {
  return n != null && (q.isBigNumber(n) || (typeof n == 'number' && n % 1 === 0) || (typeof n == 'string' && !!n.match(/^-?[0-9]+$/)) || Me(n) || typeof n == 'bigint' || Na(n));
}
let zg = !1;
class q {
  constructor(e, t) {
    e !== pf &&
      hr.throwError('cannot call constructor directly; use BigNumber.from', D.errors.UNSUPPORTED_OPERATION, {
        operation: 'new (BigNumber)',
      }),
      (this._hex = t),
      (this._isBigNumber = !0),
      Object.freeze(this);
  }
  fromTwos(e) {
    return Dn(Te(this).fromTwos(e));
  }
  toTwos(e) {
    return Dn(Te(this).toTwos(e));
  }
  abs() {
    return this._hex[0] === '-' ? q.from(this._hex.substring(1)) : this;
  }
  add(e) {
    return Dn(Te(this).add(Te(e)));
  }
  sub(e) {
    return Dn(Te(this).sub(Te(e)));
  }
  div(e) {
    return q.from(e).isZero() && ai('division-by-zero', 'div'), Dn(Te(this).div(Te(e)));
  }
  mul(e) {
    return Dn(Te(this).mul(Te(e)));
  }
  mod(e) {
    const t = Te(e);
    return t.isNeg() && ai('division-by-zero', 'mod'), Dn(Te(this).umod(t));
  }
  pow(e) {
    const t = Te(e);
    return t.isNeg() && ai('negative-power', 'pow'), Dn(Te(this).pow(t));
  }
  and(e) {
    const t = Te(e);
    return (this.isNegative() || t.isNeg()) && ai('unbound-bitwise-result', 'and'), Dn(Te(this).and(t));
  }
  or(e) {
    const t = Te(e);
    return (this.isNegative() || t.isNeg()) && ai('unbound-bitwise-result', 'or'), Dn(Te(this).or(t));
  }
  xor(e) {
    const t = Te(e);
    return (this.isNegative() || t.isNeg()) && ai('unbound-bitwise-result', 'xor'), Dn(Te(this).xor(t));
  }
  mask(e) {
    return (this.isNegative() || e < 0) && ai('negative-width', 'mask'), Dn(Te(this).maskn(e));
  }
  shl(e) {
    return (this.isNegative() || e < 0) && ai('negative-width', 'shl'), Dn(Te(this).shln(e));
  }
  shr(e) {
    return (this.isNegative() || e < 0) && ai('negative-width', 'shr'), Dn(Te(this).shrn(e));
  }
  eq(e) {
    return Te(this).eq(Te(e));
  }
  lt(e) {
    return Te(this).lt(Te(e));
  }
  lte(e) {
    return Te(this).lte(Te(e));
  }
  gt(e) {
    return Te(this).gt(Te(e));
  }
  gte(e) {
    return Te(this).gte(Te(e));
  }
  isNegative() {
    return this._hex[0] === '-';
  }
  isZero() {
    return Te(this).isZero();
  }
  toNumber() {
    try {
      return Te(this).toNumber();
    } catch {
      ai('overflow', 'toNumber', this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {}
    return hr.throwError('this platform does not support BigInt', D.errors.UNSUPPORTED_OPERATION, {
      value: this.toString(),
    });
  }
  toString() {
    return (
      arguments.length > 0 &&
        (arguments[0] === 10
          ? zg || ((zg = !0), hr.warn('BigNumber.toString does not accept any parameters; base-10 is assumed'))
          : arguments[0] === 16
          ? hr.throwError('BigNumber.toString does not accept any parameters; use bigNumber.toHexString()', D.errors.UNEXPECTED_ARGUMENT, {})
          : hr.throwError('BigNumber.toString does not accept parameters', D.errors.UNEXPECTED_ARGUMENT, {})),
      Te(this).toString(10)
    );
  }
  toHexString() {
    return this._hex;
  }
  toJSON(e) {
    return { type: 'BigNumber', hex: this.toHexString() };
  }
  static from(e) {
    if (e instanceof q) return e;
    if (typeof e == 'string') return e.match(/^-?0x[0-9a-f]+$/i) ? new q(pf, Ku(e)) : e.match(/^-?[0-9]+$/) ? new q(pf, Ku(new Hu(e))) : hr.throwArgumentError('invalid BigNumber string', 'value', e);
    if (typeof e == 'number') return e % 1 && ai('underflow', 'BigNumber.from', e), (e >= Vg || e <= -Vg) && ai('overflow', 'BigNumber.from', e), q.from(String(e));
    const t = e;
    if (typeof t == 'bigint') return q.from(t.toString());
    if (Na(t)) return q.from(K(t));
    if (t)
      if (t.toHexString) {
        const i = t.toHexString();
        if (typeof i == 'string') return q.from(i);
      } else {
        let i = t._hex;
        if ((i == null && t.type === 'BigNumber' && (i = t.hex), typeof i == 'string' && (Me(i) || (i[0] === '-' && Me(i.substring(1)))))) return q.from(i);
      }
    return hr.throwArgumentError('invalid BigNumber value', 'value', e);
  }
  static isBigNumber(e) {
    return !!(e && e._isBigNumber);
  }
}
function Ku(n) {
  if (typeof n != 'string') return Ku(n.toString(16));
  if (n[0] === '-') return (n = n.substring(1)), n[0] === '-' && hr.throwArgumentError('invalid hex', 'value', n), (n = Ku(n)), n === '0x00' ? n : '-' + n;
  if ((n.substring(0, 2) !== '0x' && (n = '0x' + n), n === '0x')) return '0x00';
  for (n.length % 2 && (n = '0x0' + n.substring(2)); n.length > 4 && n.substring(0, 4) === '0x00'; ) n = '0x' + n.substring(4);
  return n;
}
function Dn(n) {
  return q.from(Ku(n));
}
function Te(n) {
  const e = q.from(n).toHexString();
  return e[0] === '-' ? new Hu('-' + e.substring(3), 16) : new Hu(e.substring(2), 16);
}
function ai(n, e, t) {
  const i = { fault: n, operation: e };
  return t != null && (i.value = t), hr.throwError(n, D.errors.NUMERIC_FAULT, i);
}
function pS(n) {
  return new Hu(n, 36).toString(16);
}
function fS(n) {
  return new Hu(n, 16).toString(36);
}
const Mn = new D(sT),
  Eu = {},
  aT = q.from(0),
  oT = q.from(-1);
function uT(n, e, t, i) {
  const r = { fault: e, operation: t };
  return i !== void 0 && (r.value = i), Mn.throwError(n, D.errors.NUMERIC_FAULT, r);
}
let Su = '0';
for (; Su.length < 256; ) Su += Su;
function o0(n) {
  if (typeof n != 'number')
    try {
      n = q.from(n).toNumber();
    } catch {}
  return typeof n == 'number' && n >= 0 && n <= 256 && !(n % 1) ? '1' + Su.substring(0, n) : Mn.throwArgumentError('invalid decimal size', 'decimals', n);
}
function _d(n, e) {
  e == null && (e = 0);
  const t = o0(e);
  n = q.from(n);
  const i = n.lt(aT);
  i && (n = n.mul(oT));
  let r = n.mod(t).toString();
  for (; r.length < t.length - 1; ) r = '0' + r;
  r = r.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const s = n.div(t).toString();
  return t.length === 1 ? (n = s) : (n = s + '.' + r), i && (n = '-' + n), n;
}
function Ui(n, e) {
  e == null && (e = 0);
  const t = o0(e);
  (typeof n != 'string' || !n.match(/^-?[0-9.]+$/)) && Mn.throwArgumentError('invalid decimal value', 'value', n);
  const i = n.substring(0, 1) === '-';
  i && (n = n.substring(1)), n === '.' && Mn.throwArgumentError('missing value', 'value', n);
  const r = n.split('.');
  r.length > 2 && Mn.throwArgumentError('too many decimal points', 'value', n);
  let s = r[0],
    a = r[1];
  for (s || (s = '0'), a || (a = '0'); a[a.length - 1] === '0'; ) a = a.substring(0, a.length - 1);
  for (a.length > t.length - 1 && uT('fractional component exceeds decimals', 'underflow', 'parseFixed'), a === '' && (a = '0'); a.length < t.length - 1; ) a += '0';
  const o = q.from(s),
    u = q.from(a);
  let l = o.mul(t).add(u);
  return i && (l = l.mul(oT)), l;
}
class po {
  constructor(e, t, i, r) {
    e !== Eu &&
      Mn.throwError('cannot use FixedFormat constructor; use FixedFormat.from', D.errors.UNSUPPORTED_OPERATION, {
        operation: 'new FixedFormat',
      }),
      (this.signed = t),
      (this.width = i),
      (this.decimals = r),
      (this.name = (t ? '' : 'u') + 'fixed' + String(i) + 'x' + String(r)),
      (this._multiplier = o0(r)),
      Object.freeze(this);
  }
  static from(e) {
    if (e instanceof po) return e;
    typeof e == 'number' && (e = `fixed128x${e}`);
    let t = !0,
      i = 128,
      r = 18;
    if (typeof e == 'string') {
      if (e !== 'fixed')
        if (e === 'ufixed') t = !1;
        else {
          const s = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          s || Mn.throwArgumentError('invalid fixed format', 'format', e), (t = s[1] !== 'u'), (i = parseInt(s[2])), (r = parseInt(s[3]));
        }
    } else if (e) {
      const s = (a, o, u) => (e[a] == null ? u : (typeof e[a] !== o && Mn.throwArgumentError('invalid fixed format (' + a + ' not ' + o + ')', 'format.' + a, e[a]), e[a]));
      (t = s('signed', 'boolean', t)), (i = s('width', 'number', i)), (r = s('decimals', 'number', r));
    }
    return (
      i % 8 && Mn.throwArgumentError('invalid fixed format width (not byte aligned)', 'format.width', i),
      r > 80 && Mn.throwArgumentError('invalid fixed format (decimals too large)', 'format.decimals', r),
      new po(Eu, t, i, r)
    );
  }
}
class sn {
  constructor(e, t, i, r) {
    e !== Eu &&
      Mn.throwError('cannot use FixedNumber constructor; use FixedNumber.from', D.errors.UNSUPPORTED_OPERATION, {
        operation: 'new FixedFormat',
      }),
      (this.format = r),
      (this._hex = t),
      (this._value = i),
      (this._isFixedNumber = !0),
      Object.freeze(this);
  }
  _checkFormat(e) {
    this.format.name !== e.format.name && Mn.throwArgumentError('incompatible format; use fixedNumber.toFormat', 'other', e);
  }
  addUnsafe(e) {
    this._checkFormat(e);
    const t = Ui(this._value, this.format.decimals),
      i = Ui(e._value, e.format.decimals);
    return sn.fromValue(t.add(i), this.format.decimals, this.format);
  }
  subUnsafe(e) {
    this._checkFormat(e);
    const t = Ui(this._value, this.format.decimals),
      i = Ui(e._value, e.format.decimals);
    return sn.fromValue(t.sub(i), this.format.decimals, this.format);
  }
  mulUnsafe(e) {
    this._checkFormat(e);
    const t = Ui(this._value, this.format.decimals),
      i = Ui(e._value, e.format.decimals);
    return sn.fromValue(t.mul(i).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(e) {
    this._checkFormat(e);
    const t = Ui(this._value, this.format.decimals),
      i = Ui(e._value, e.format.decimals);
    return sn.fromValue(t.mul(this.format._multiplier).div(i), this.format.decimals, this.format);
  }
  floor() {
    const e = this.toString().split('.');
    e.length === 1 && e.push('0');
    let t = sn.from(e[0], this.format);
    const i = !e[1].match(/^(0*)$/);
    return this.isNegative() && i && (t = t.subUnsafe(Gg.toFormat(t.format))), t;
  }
  ceiling() {
    const e = this.toString().split('.');
    e.length === 1 && e.push('0');
    let t = sn.from(e[0], this.format);
    const i = !e[1].match(/^(0*)$/);
    return !this.isNegative() && i && (t = t.addUnsafe(Gg.toFormat(t.format))), t;
  }
  // @TODO: Support other rounding algorithms
  round(e) {
    e == null && (e = 0);
    const t = this.toString().split('.');
    if ((t.length === 1 && t.push('0'), (e < 0 || e > 80 || e % 1) && Mn.throwArgumentError('invalid decimal count', 'decimals', e), t[1].length <= e)) return this;
    const i = sn.from('1' + Su.substring(0, e), this.format),
      r = yS.toFormat(this.format);
    return this.mulUnsafe(i).addUnsafe(r).floor().divUnsafe(i);
  }
  isZero() {
    return this._value === '0.0' || this._value === '0';
  }
  isNegative() {
    return this._value[0] === '-';
  }
  toString() {
    return this._value;
  }
  toHexString(e) {
    if (e == null) return this._hex;
    e % 8 && Mn.throwArgumentError('invalid byte width', 'width', e);
    const t = q.from(this._hex).fromTwos(this.format.width).toTwos(e).toHexString();
    return Le(t, e / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(e) {
    return sn.fromString(this._value, e);
  }
  static fromValue(e, t, i) {
    return i == null && t != null && !cS(t) && ((i = t), (t = null)), t == null && (t = 0), i == null && (i = 'fixed'), sn.fromString(_d(e, t), po.from(i));
  }
  static fromString(e, t) {
    t == null && (t = 'fixed');
    const i = po.from(t),
      r = Ui(e, i.decimals);
    !i.signed && r.lt(aT) && uT('unsigned value cannot be negative', 'overflow', 'value', e);
    let s = null;
    i.signed ? (s = r.toTwos(i.width).toHexString()) : ((s = r.toHexString()), (s = Le(s, i.width / 8)));
    const a = _d(r, i.decimals);
    return new sn(Eu, s, a, i);
  }
  static fromBytes(e, t) {
    t == null && (t = 'fixed');
    const i = po.from(t);
    if (H(e).length > i.width / 8) throw new Error('overflow');
    let r = q.from(e);
    i.signed && (r = r.fromTwos(i.width));
    const s = r.toTwos((i.signed ? 0 : 1) + i.width).toHexString(),
      a = _d(r, i.decimals);
    return new sn(Eu, s, a, i);
  }
  static from(e, t) {
    if (typeof e == 'string') return sn.fromString(e, t);
    if (Na(e)) return sn.fromBytes(e, t);
    try {
      return sn.fromValue(e, 0, t);
    } catch (i) {
      if (i.code !== D.errors.INVALID_ARGUMENT) throw i;
    }
    return Mn.throwArgumentError('invalid FixedNumber value', 'value', e);
  }
  static isFixedNumber(e) {
    return !!(e && e._isFixedNumber);
  }
}
const Gg = sn.from(1),
  yS = sn.from('0.5'),
  hS = 'properties/5.7.0';
var mS =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
const lc = new D(hS);
function j(n, e, t) {
  Object.defineProperty(n, e, {
    enumerable: !0,
    value: t,
    writable: !1,
  });
}
function Oi(n, e) {
  for (let t = 0; t < 32; t++) {
    if (n[e]) return n[e];
    if (!n.prototype || typeof n.prototype != 'object') break;
    n = Object.getPrototypeOf(n.prototype).constructor;
  }
  return null;
}
function Ot(n) {
  return mS(this, void 0, void 0, function* () {
    const e = Object.keys(n).map((i) => {
      const r = n[i];
      return Promise.resolve(r).then((s) => ({ key: i, value: s }));
    });
    return (yield Promise.all(e)).reduce((i, r) => ((i[r.key] = r.value), i), {});
  });
}
function u0(n, e) {
  (!n || typeof n != 'object') && lc.throwArgumentError('invalid object', 'object', n),
    Object.keys(n).forEach((t) => {
      e[t] || lc.throwArgumentError('invalid object key - ' + t, 'transaction:' + t, n);
    });
}
function Gt(n) {
  const e = {};
  for (const t in n) e[t] = n[t];
  return e;
}
const bS = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function lT(n) {
  if (n == null || bS[typeof n]) return !0;
  if (Array.isArray(n) || typeof n == 'object') {
    if (!Object.isFrozen(n)) return !1;
    const e = Object.keys(n);
    for (let t = 0; t < e.length; t++) {
      let i = null;
      try {
        i = n[e[t]];
      } catch {
        continue;
      }
      if (!lT(i)) return !1;
    }
    return !0;
  }
  return lc.throwArgumentError(`Cannot deepCopy ${typeof n}`, 'object', n);
}
function gS(n) {
  if (lT(n)) return n;
  if (Array.isArray(n)) return Object.freeze(n.map((e) => xs(e)));
  if (typeof n == 'object') {
    const e = {};
    for (const t in n) {
      const i = n[t];
      i !== void 0 && j(e, t, xs(i));
    }
    return e;
  }
  return lc.throwArgumentError(`Cannot deepCopy ${typeof n}`, 'object', n);
}
function xs(n) {
  return gS(n);
}
class _s {
  constructor(e) {
    for (const t in e) this[t] = xs(e[t]);
  }
}
const vS = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        Description: _s,
        checkProperties: u0,
        deepCopy: xs,
        defineReadOnly: j,
        getStatic: Oi,
        resolveProperties: Ot,
        shallowCopy: Gt,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Nl = 'abi/5.7.0',
  Se = new D(Nl),
  ya = {};
let qg = { calldata: !0, memory: !0, storage: !0 },
  xS = { calldata: !0, memory: !0 };
function sd(n, e) {
  if (n === 'bytes' || n === 'string') {
    if (qg[e]) return !0;
  } else if (n === 'address') {
    if (e === 'payable') return !0;
  } else if ((n.indexOf('[') >= 0 || n === 'tuple') && xS[e]) return !0;
  return (qg[e] || e === 'payable') && Se.throwArgumentError('invalid modifier', 'name', e), !1;
}
function TS(n, e) {
  let t = n;
  function i(o) {
    Se.throwArgumentError(`unexpected character at position ${o}`, 'param', n);
  }
  n = n.replace(/\s/g, ' ');
  function r(o) {
    let u = { type: '', name: '', parent: o, state: { allowType: !0 } };
    return e && (u.indexed = !1), u;
  }
  let s = { type: '', name: '', state: { allowType: !0 } },
    a = s;
  for (let o = 0; o < n.length; o++) {
    let u = n[o];
    switch (u) {
      case '(':
        a.state.allowType && a.type === '' ? (a.type = 'tuple') : a.state.allowParams || i(o), (a.state.allowType = !1), (a.type = Qa(a.type)), (a.components = [r(a)]), (a = a.components[0]);
        break;
      case ')':
        delete a.state, a.name === 'indexed' && (e || i(o), (a.indexed = !0), (a.name = '')), sd(a.type, a.name) && (a.name = ''), (a.type = Qa(a.type));
        let l = a;
        (a = a.parent), a || i(o), delete l.parent, (a.state.allowParams = !1), (a.state.allowName = !0), (a.state.allowArray = !0);
        break;
      case ',':
        delete a.state, a.name === 'indexed' && (e || i(o), (a.indexed = !0), (a.name = '')), sd(a.type, a.name) && (a.name = ''), (a.type = Qa(a.type));
        let c = r(a.parent);
        a.parent.components.push(c), delete a.parent, (a = c);
        break;
      case ' ':
        a.state.allowType && a.type !== '' && ((a.type = Qa(a.type)), delete a.state.allowType, (a.state.allowName = !0), (a.state.allowParams = !0)),
          a.state.allowName &&
            a.name !== '' &&
            (a.name === 'indexed' ? (e || i(o), a.indexed && i(o), (a.indexed = !0), (a.name = '')) : sd(a.type, a.name) ? (a.name = '') : (a.state.allowName = !1));
        break;
      case '[':
        a.state.allowArray || i(o), (a.type += u), (a.state.allowArray = !1), (a.state.allowName = !1), (a.state.readArray = !0);
        break;
      case ']':
        a.state.readArray || i(o), (a.type += u), (a.state.readArray = !1), (a.state.allowArray = !0), (a.state.allowName = !0);
        break;
      default:
        a.state.allowType
          ? ((a.type += u), (a.state.allowParams = !0), (a.state.allowArray = !0))
          : a.state.allowName
          ? ((a.name += u), delete a.state.allowArray)
          : a.state.readArray
          ? (a.type += u)
          : i(o);
    }
  }
  return (
    a.parent && Se.throwArgumentError('unexpected eof', 'param', n),
    delete s.state,
    a.name === 'indexed' ? (e || i(t.length - 7), a.indexed && i(t.length - 7), (a.indexed = !0), (a.name = '')) : sd(a.type, a.name) && (a.name = ''),
    (s.type = Qa(s.type)),
    s
  );
}
function Rd(n, e) {
  for (let t in e) j(n, t, e[t]);
}
const Oe = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: 'sighash',
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: 'minimal',
    // Human-Readable with nice spacing, including all names
    full: 'full',
    // JSON-format a la Solidity
    json: 'json',
  }),
  wS = new RegExp(/^(.*)\[([0-9]*)\]$/);
class Wt {
  constructor(e, t) {
    e !== ya &&
      Se.throwError('use fromString', D.errors.UNSUPPORTED_OPERATION, {
        operation: 'new ParamType()',
      }),
      Rd(this, t);
    let i = this.type.match(wS);
    i
      ? Rd(this, {
          arrayLength: parseInt(i[2] || '-1'),
          arrayChildren: Wt.fromObject({
            type: i[1],
            components: this.components,
          }),
          baseType: 'array',
        })
      : Rd(this, {
          arrayLength: null,
          arrayChildren: null,
          baseType: this.components != null ? 'tuple' : this.type,
        }),
      (this._isParamType = !0),
      Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(e) {
    if ((e || (e = Oe.sighash), Oe[e] || Se.throwArgumentError('invalid format type', 'format', e), e === Oe.json)) {
      let i = {
        type: this.baseType === 'tuple' ? 'tuple' : this.type,
        name: this.name || void 0,
      };
      return typeof this.indexed == 'boolean' && (i.indexed = this.indexed), this.components && (i.components = this.components.map((r) => JSON.parse(r.format(e)))), JSON.stringify(i);
    }
    let t = '';
    return (
      this.baseType === 'array'
        ? ((t += this.arrayChildren.format(e)), (t += '[' + (this.arrayLength < 0 ? '' : String(this.arrayLength)) + ']'))
        : this.baseType === 'tuple'
        ? (e !== Oe.sighash && (t += this.type), (t += '(' + this.components.map((i) => i.format(e)).join(e === Oe.full ? ', ' : ',') + ')'))
        : (t += this.type),
      e !== Oe.sighash && (this.indexed === !0 && (t += ' indexed'), e === Oe.full && this.name && (t += ' ' + this.name)),
      t
    );
  }
  static from(e, t) {
    return typeof e == 'string' ? Wt.fromString(e, t) : Wt.fromObject(e);
  }
  static fromObject(e) {
    return Wt.isParamType(e)
      ? e
      : new Wt(ya, {
          name: e.name || null,
          type: Qa(e.type),
          indexed: e.indexed == null ? null : !!e.indexed,
          components: e.components ? e.components.map(Wt.fromObject) : null,
        });
  }
  static fromString(e, t) {
    function i(r) {
      return Wt.fromObject({
        name: r.name,
        type: r.type,
        indexed: r.indexed,
        components: r.components,
      });
    }
    return i(TS(e, !!t));
  }
  static isParamType(e) {
    return !!(e != null && e._isParamType);
  }
}
function Wu(n, e) {
  return ES(n).map((t) => Wt.fromString(t, e));
}
class Ki {
  constructor(e, t) {
    e !== ya &&
      Se.throwError('use a static from method', D.errors.UNSUPPORTED_OPERATION, {
        operation: 'new Fragment()',
      }),
      Rd(this, t),
      (this._isFragment = !0),
      Object.freeze(this);
  }
  static from(e) {
    return Ki.isFragment(e) ? e : typeof e == 'string' ? Ki.fromString(e) : Ki.fromObject(e);
  }
  static fromObject(e) {
    if (Ki.isFragment(e)) return e;
    switch (e.type) {
      case 'function':
        return _i.fromObject(e);
      case 'event':
        return Hi.fromObject(e);
      case 'constructor':
        return Mi.fromObject(e);
      case 'error':
        return wr.fromObject(e);
      case 'fallback':
      case 'receive':
        return null;
    }
    return Se.throwArgumentError('invalid fragment object', 'value', e);
  }
  static fromString(e) {
    return (
      (e = e.replace(/\s/g, ' ')),
      (e = e.replace(/\(/g, ' (').replace(/\)/g, ') ').replace(/\s+/g, ' ')),
      (e = e.trim()),
      e.split(' ')[0] === 'event'
        ? Hi.fromString(e.substring(5).trim())
        : e.split(' ')[0] === 'function'
        ? _i.fromString(e.substring(8).trim())
        : e.split('(')[0].trim() === 'constructor'
        ? Mi.fromString(e.trim())
        : e.split(' ')[0] === 'error'
        ? wr.fromString(e.substring(5).trim())
        : Se.throwArgumentError('unsupported fragment', 'value', e)
    );
  }
  static isFragment(e) {
    return !!(e && e._isFragment);
  }
}
class Hi extends Ki {
  format(e) {
    if ((e || (e = Oe.sighash), Oe[e] || Se.throwArgumentError('invalid format type', 'format', e), e === Oe.json))
      return JSON.stringify({
        type: 'event',
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e))),
      });
    let t = '';
    return (
      e !== Oe.sighash && (t += 'event '),
      (t += this.name + '(' + this.inputs.map((i) => i.format(e)).join(e === Oe.full ? ', ' : ',') + ') '),
      e !== Oe.sighash && this.anonymous && (t += 'anonymous '),
      t.trim()
    );
  }
  static from(e) {
    return typeof e == 'string' ? Hi.fromString(e) : Hi.fromObject(e);
  }
  static fromObject(e) {
    if (Hi.isEventFragment(e)) return e;
    e.type !== 'event' && Se.throwArgumentError('invalid event object', 'value', e);
    const t = {
      name: Ju(e.name),
      anonymous: e.anonymous,
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
      type: 'event',
    };
    return new Hi(ya, t);
  }
  static fromString(e) {
    let t = e.match(Qu);
    t || Se.throwArgumentError('invalid event string', 'value', e);
    let i = !1;
    return (
      t[3].split(' ').forEach((r) => {
        switch (r.trim()) {
          case 'anonymous':
            i = !0;
            break;
          case '':
            break;
          default:
            Se.warn('unknown modifier: ' + r);
        }
      }),
      Hi.fromObject({
        name: t[1].trim(),
        anonymous: i,
        inputs: Wu(t[2], !0),
        type: 'event',
      })
    );
  }
  static isEventFragment(e) {
    return e && e._isFragment && e.type === 'event';
  }
}
function dT(n, e) {
  e.gas = null;
  let t = n.split('@');
  return t.length !== 1
    ? (t.length > 2 && Se.throwArgumentError('invalid human-readable ABI signature', 'value', n),
      t[1].match(/^[0-9]+$/) || Se.throwArgumentError('invalid human-readable ABI signature gas', 'value', n),
      (e.gas = q.from(t[1])),
      t[0])
    : n;
}
function cT(n, e) {
  (e.constant = !1),
    (e.payable = !1),
    (e.stateMutability = 'nonpayable'),
    n.split(' ').forEach((t) => {
      switch (t.trim()) {
        case 'constant':
          e.constant = !0;
          break;
        case 'payable':
          (e.payable = !0), (e.stateMutability = 'payable');
          break;
        case 'nonpayable':
          (e.payable = !1), (e.stateMutability = 'nonpayable');
          break;
        case 'pure':
          (e.constant = !0), (e.stateMutability = 'pure');
          break;
        case 'view':
          (e.constant = !0), (e.stateMutability = 'view');
          break;
        case 'external':
        case 'public':
        case '':
          break;
        default:
          console.log('unknown modifier: ' + t);
      }
    });
}
function pT(n) {
  let e = {
    constant: !1,
    payable: !0,
    stateMutability: 'payable',
  };
  return (
    n.stateMutability != null
      ? ((e.stateMutability = n.stateMutability),
        (e.constant = e.stateMutability === 'view' || e.stateMutability === 'pure'),
        n.constant != null && !!n.constant !== e.constant && Se.throwArgumentError('cannot have constant function with mutability ' + e.stateMutability, 'value', n),
        (e.payable = e.stateMutability === 'payable'),
        n.payable != null && !!n.payable !== e.payable && Se.throwArgumentError('cannot have payable function with mutability ' + e.stateMutability, 'value', n))
      : n.payable != null
      ? ((e.payable = !!n.payable),
        n.constant == null && !e.payable && n.type !== 'constructor' && Se.throwArgumentError('unable to determine stateMutability', 'value', n),
        (e.constant = !!n.constant),
        e.constant ? (e.stateMutability = 'view') : (e.stateMutability = e.payable ? 'payable' : 'nonpayable'),
        e.payable && e.constant && Se.throwArgumentError('cannot have constant payable function', 'value', n))
      : n.constant != null
      ? ((e.constant = !!n.constant), (e.payable = !e.constant), (e.stateMutability = e.constant ? 'view' : 'payable'))
      : n.type !== 'constructor' && Se.throwArgumentError('unable to determine stateMutability', 'value', n),
    e
  );
}
class Mi extends Ki {
  format(e) {
    if ((e || (e = Oe.sighash), Oe[e] || Se.throwArgumentError('invalid format type', 'format', e), e === Oe.json))
      return JSON.stringify({
        type: 'constructor',
        stateMutability: this.stateMutability !== 'nonpayable' ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e))),
      });
    e === Oe.sighash &&
      Se.throwError('cannot format a constructor for sighash', D.errors.UNSUPPORTED_OPERATION, {
        operation: 'format(sighash)',
      });
    let t = 'constructor(' + this.inputs.map((i) => i.format(e)).join(e === Oe.full ? ', ' : ',') + ') ';
    return this.stateMutability && this.stateMutability !== 'nonpayable' && (t += this.stateMutability + ' '), t.trim();
  }
  static from(e) {
    return typeof e == 'string' ? Mi.fromString(e) : Mi.fromObject(e);
  }
  static fromObject(e) {
    if (Mi.isConstructorFragment(e)) return e;
    e.type !== 'constructor' && Se.throwArgumentError('invalid constructor object', 'value', e);
    let t = pT(e);
    t.constant && Se.throwArgumentError('constructor cannot be constant', 'value', e);
    const i = {
      name: null,
      type: e.type,
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? q.from(e.gas) : null,
    };
    return new Mi(ya, i);
  }
  static fromString(e) {
    let t = { type: 'constructor' };
    e = dT(e, t);
    let i = e.match(Qu);
    return (!i || i[1].trim() !== 'constructor') && Se.throwArgumentError('invalid constructor string', 'value', e), (t.inputs = Wu(i[2].trim(), !1)), cT(i[3].trim(), t), Mi.fromObject(t);
  }
  static isConstructorFragment(e) {
    return e && e._isFragment && e.type === 'constructor';
  }
}
class _i extends Mi {
  format(e) {
    if ((e || (e = Oe.sighash), Oe[e] || Se.throwArgumentError('invalid format type', 'format', e), e === Oe.json))
      return JSON.stringify({
        type: 'function',
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== 'nonpayable' ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e))),
        outputs: this.outputs.map((i) => JSON.parse(i.format(e))),
      });
    let t = '';
    return (
      e !== Oe.sighash && (t += 'function '),
      (t += this.name + '(' + this.inputs.map((i) => i.format(e)).join(e === Oe.full ? ', ' : ',') + ') '),
      e !== Oe.sighash &&
        (this.stateMutability ? this.stateMutability !== 'nonpayable' && (t += this.stateMutability + ' ') : this.constant && (t += 'view '),
        this.outputs && this.outputs.length && (t += 'returns (' + this.outputs.map((i) => i.format(e)).join(', ') + ') '),
        this.gas != null && (t += '@' + this.gas.toString() + ' ')),
      t.trim()
    );
  }
  static from(e) {
    return typeof e == 'string' ? _i.fromString(e) : _i.fromObject(e);
  }
  static fromObject(e) {
    if (_i.isFunctionFragment(e)) return e;
    e.type !== 'function' && Se.throwArgumentError('invalid function object', 'value', e);
    let t = pT(e);
    const i = {
      type: e.type,
      name: Ju(e.name),
      constant: t.constant,
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
      outputs: e.outputs ? e.outputs.map(Wt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? q.from(e.gas) : null,
    };
    return new _i(ya, i);
  }
  static fromString(e) {
    let t = { type: 'function' };
    e = dT(e, t);
    let i = e.split(' returns ');
    i.length > 2 && Se.throwArgumentError('invalid function string', 'value', e);
    let r = i[0].match(Qu);
    if ((r || Se.throwArgumentError('invalid function signature', 'value', e), (t.name = r[1].trim()), t.name && Ju(t.name), (t.inputs = Wu(r[2], !1)), cT(r[3].trim(), t), i.length > 1)) {
      let s = i[1].match(Qu);
      (s[1].trim() != '' || s[3].trim() != '') && Se.throwArgumentError('unexpected tokens', 'value', e), (t.outputs = Wu(s[2], !1));
    } else t.outputs = [];
    return _i.fromObject(t);
  }
  static isFunctionFragment(e) {
    return e && e._isFragment && e.type === 'function';
  }
}
function Hg(n) {
  const e = n.format();
  return (e === 'Error(string)' || e === 'Panic(uint256)') && Se.throwArgumentError(`cannot specify user defined ${e} error`, 'fragment', n), n;
}
class wr extends Ki {
  format(e) {
    if ((e || (e = Oe.sighash), Oe[e] || Se.throwArgumentError('invalid format type', 'format', e), e === Oe.json))
      return JSON.stringify({
        type: 'error',
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e))),
      });
    let t = '';
    return e !== Oe.sighash && (t += 'error '), (t += this.name + '(' + this.inputs.map((i) => i.format(e)).join(e === Oe.full ? ', ' : ',') + ') '), t.trim();
  }
  static from(e) {
    return typeof e == 'string' ? wr.fromString(e) : wr.fromObject(e);
  }
  static fromObject(e) {
    if (wr.isErrorFragment(e)) return e;
    e.type !== 'error' && Se.throwArgumentError('invalid error object', 'value', e);
    const t = {
      type: e.type,
      name: Ju(e.name),
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
    };
    return Hg(new wr(ya, t));
  }
  static fromString(e) {
    let t = { type: 'error' },
      i = e.match(Qu);
    return i || Se.throwArgumentError('invalid error signature', 'value', e), (t.name = i[1].trim()), t.name && Ju(t.name), (t.inputs = Wu(i[2], !1)), Hg(wr.fromObject(t));
  }
  static isErrorFragment(e) {
    return e && e._isFragment && e.type === 'error';
  }
}
function Qa(n) {
  return n.match(/^uint($|[^1-9])/) ? (n = 'uint256' + n.substring(4)) : n.match(/^int($|[^1-9])/) && (n = 'int256' + n.substring(3)), n;
}
const AS = new RegExp('^[a-zA-Z$_][a-zA-Z0-9$_]*$');
function Ju(n) {
  return (!n || !n.match(AS)) && Se.throwArgumentError(`invalid identifier "${n}"`, 'value', n), n;
}
const Qu = new RegExp('^([^)(]*)\\((.*)\\)([^)(]*)$');
function ES(n) {
  n = n.trim();
  let e = [],
    t = '',
    i = 0;
  for (let r = 0; r < n.length; r++) {
    let s = n[r];
    s === ',' && i === 0 ? (e.push(t), (t = '')) : ((t += s), s === '(' ? i++ : s === ')' && (i--, i === -1 && Se.throwArgumentError('unbalanced parenthesis', 'value', n)));
  }
  return t && e.push(t), e;
}
const l0 = new D(Nl);
function fT(n) {
  const e = [],
    t = function (i, r) {
      if (Array.isArray(r))
        for (let s in r) {
          const a = i.slice();
          a.push(s);
          try {
            t(a, r[s]);
          } catch (o) {
            e.push({ path: a, error: o });
          }
        }
    };
  return t([], n), e;
}
class Kr {
  constructor(e, t, i, r) {
    (this.name = e), (this.type = t), (this.localName = i), (this.dynamic = r);
  }
  _throwError(e, t) {
    l0.throwArgumentError(e, this.localName, t);
  }
}
class Ty {
  constructor(e) {
    j(this, 'wordSize', e || 32), (this._data = []), (this._dataLength = 0), (this._padding = new Uint8Array(e));
  }
  get data() {
    return Cn(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(e) {
    return this._data.push(e), (this._dataLength += e.length), e.length;
  }
  appendWriter(e) {
    return this._writeData(Ge(e._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(e) {
    let t = H(e);
    const i = t.length % this.wordSize;
    return i && (t = Ge([t, this._padding.slice(i)])), this._writeData(t);
  }
  _getValue(e) {
    let t = H(q.from(e));
    return (
      t.length > this.wordSize &&
        l0.throwError('value out-of-bounds', D.errors.BUFFER_OVERRUN, {
          length: this.wordSize,
          offset: t.length,
        }),
      t.length % this.wordSize && (t = Ge([this._padding.slice(t.length % this.wordSize), t])),
      t
    );
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(e) {
    return this._writeData(this._getValue(e));
  }
  writeUpdatableValue() {
    const e = this._data.length;
    return (
      this._data.push(this._padding),
      (this._dataLength += this.wordSize),
      (t) => {
        this._data[e] = this._getValue(t);
      }
    );
  }
}
class dc {
  constructor(e, t, i, r) {
    j(this, '_data', H(e)), j(this, 'wordSize', t || 32), j(this, '_coerceFunc', i), j(this, 'allowLoose', r), (this._offset = 0);
  }
  get data() {
    return K(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(e, t) {
    let i = e.match('^u?int([0-9]+)$');
    return i && parseInt(i[1]) <= 48 && (t = t.toNumber()), t;
  }
  coerce(e, t) {
    return this._coerceFunc ? this._coerceFunc(e, t) : dc.coerce(e, t);
  }
  _peekBytes(e, t, i) {
    let r = Math.ceil(t / this.wordSize) * this.wordSize;
    return (
      this._offset + r > this._data.length &&
        (this.allowLoose && i && this._offset + t <= this._data.length
          ? (r = t)
          : l0.throwError('data out-of-bounds', D.errors.BUFFER_OVERRUN, {
              length: this._data.length,
              offset: this._offset + r,
            })),
      this._data.slice(this._offset, this._offset + r)
    );
  }
  subReader(e) {
    return new dc(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(e, t) {
    let i = this._peekBytes(0, e, !!t);
    return (this._offset += i.length), i.slice(0, e);
  }
  readValue() {
    return q.from(this.readBytes(this.wordSize));
  }
}
const ha = typeof global < 'u' ? global : typeof self < 'u' ? self : typeof window < 'u' ? window : {};
function yT() {
  throw new Error('setTimeout has not been defined');
}
function hT() {
  throw new Error('clearTimeout has not been defined');
}
var ss = yT,
  as = hT;
typeof ha.setTimeout == 'function' && (ss = setTimeout);
typeof ha.clearTimeout == 'function' && (as = clearTimeout);
function mT(n) {
  if (ss === setTimeout) return setTimeout(n, 0);
  if ((ss === yT || !ss) && setTimeout) return (ss = setTimeout), setTimeout(n, 0);
  try {
    return ss(n, 0);
  } catch {
    try {
      return ss.call(null, n, 0);
    } catch {
      return ss.call(this, n, 0);
    }
  }
}
function SS(n) {
  if (as === clearTimeout) return clearTimeout(n);
  if ((as === hT || !as) && clearTimeout) return (as = clearTimeout), clearTimeout(n);
  try {
    return as(n);
  } catch {
    try {
      return as.call(null, n);
    } catch {
      return as.call(this, n);
    }
  }
}
var Ar = [],
  fo = !1,
  ra,
  Id = -1;
function CS() {
  !fo || !ra || ((fo = !1), ra.length ? (Ar = ra.concat(Ar)) : (Id = -1), Ar.length && bT());
}
function bT() {
  if (!fo) {
    var n = mT(CS);
    fo = !0;
    for (var e = Ar.length; e; ) {
      for (ra = Ar, Ar = []; ++Id < e; ) ra && ra[Id].run();
      (Id = -1), (e = Ar.length);
    }
    (ra = null), (fo = !1), SS(n);
  }
}
function MS(n) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var t = 1; t < arguments.length; t++) e[t - 1] = arguments[t];
  Ar.push(new gT(n, e)), Ar.length === 1 && !fo && mT(bT);
}
function gT(n, e) {
  (this.fun = n), (this.array = e);
}
gT.prototype.run = function () {
  this.fun.apply(null, this.array);
};
var _S = 'browser',
  RS = 'browser',
  IS = !0,
  OS = {},
  kS = [],
  PS = '',
  NS = {},
  DS = {},
  BS = {};
function Ba() {}
var FS = Ba,
  LS = Ba,
  $S = Ba,
  US = Ba,
  jS = Ba,
  VS = Ba,
  zS = Ba;
function GS(n) {
  throw new Error('process.binding is not supported');
}
function qS() {
  return '/';
}
function HS(n) {
  throw new Error('process.chdir is not supported');
}
function KS() {
  return 0;
}
var Ya = ha.performance || {},
  WS =
    Ya.now ||
    Ya.mozNow ||
    Ya.msNow ||
    Ya.oNow ||
    Ya.webkitNow ||
    function () {
      return /* @__PURE__ */ new Date().getTime();
    };
function JS(n) {
  var e = WS.call(Ya) * 1e-3,
    t = Math.floor(e),
    i = Math.floor((e % 1) * 1e9);
  return n && ((t = t - n[0]), (i = i - n[1]), i < 0 && (t--, (i += 1e9))), [t, i];
}
var QS = /* @__PURE__ */ new Date();
function YS() {
  var n = /* @__PURE__ */ new Date(),
    e = n - QS;
  return e / 1e3;
}
var Od = {
    nextTick: MS,
    title: _S,
    browser: IS,
    env: OS,
    argv: kS,
    version: PS,
    versions: NS,
    on: FS,
    addListener: LS,
    once: $S,
    off: US,
    removeListener: jS,
    removeAllListeners: VS,
    emit: zS,
    binding: GS,
    cwd: qS,
    chdir: HS,
    umask: KS,
    hrtime: JS,
    platform: RS,
    release: DS,
    config: BS,
    uptime: YS,
  },
  wy = {},
  XS = {
    get exports() {
      return wy;
    },
    set exports(n) {
      wy = n;
    },
  };
(function (n) {
  (function () {
    var e = 'input is invalid type',
      t = 'finalize already called',
      i = typeof window == 'object',
      r = i ? window : {};
    r.JS_SHA3_NO_WINDOW && (i = !1);
    var s = !i && typeof self == 'object',
      a = !r.JS_SHA3_NO_NODE_JS && typeof Od == 'object' && Od.versions && Od.versions.node;
    a ? (r = br) : s && (r = self);
    var o = !r.JS_SHA3_NO_COMMON_JS && !0 && n.exports,
      u = !r.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < 'u',
      l = '0123456789abcdef'.split(''),
      c = [31, 7936, 2031616, 520093696],
      f = [4, 1024, 262144, 67108864],
      m = [1, 256, 65536, 16777216],
      w = [6, 1536, 393216, 100663296],
      v = [0, 8, 16, 24],
      T = [
        1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139,
        2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424,
        2147483648,
      ],
      A = [224, 256, 384, 512],
      _ = [128, 256],
      O = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'],
      B = {
        128: 168,
        256: 136,
      };
    (r.JS_SHA3_NO_NODE_JS || !Array.isArray) &&
      (Array.isArray = function (h) {
        return Object.prototype.toString.call(h) === '[object Array]';
      }),
      u &&
        (r.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) &&
        (ArrayBuffer.isView = function (h) {
          return typeof h == 'object' && h.buffer && h.buffer.constructor === ArrayBuffer;
        });
    for (
      var P = function (h, R, L) {
          return function (F) {
            return new p(h, R, h).update(F)[L]();
          };
        },
        N = function (h, R, L) {
          return function (F, $) {
            return new p(h, R, $).update(F)[L]();
          };
        },
        U = function (h, R, L) {
          return function (F, $, te, Q) {
            return d['cshake' + h].update(F, $, te, Q)[L]();
          };
        },
        W = function (h, R, L) {
          return function (F, $, te, Q) {
            return d['kmac' + h].update(F, $, te, Q)[L]();
          };
        },
        z = function (h, R, L, F) {
          for (var $ = 0; $ < O.length; ++$) {
            var te = O[$];
            h[te] = R(L, F, te);
          }
          return h;
        },
        Y = function (h, R) {
          var L = P(h, R, 'hex');
          return (
            (L.create = function () {
              return new p(h, R, h);
            }),
            (L.update = function (F) {
              return L.create().update(F);
            }),
            z(L, P, h, R)
          );
        },
        ue = function (h, R) {
          var L = N(h, R, 'hex');
          return (
            (L.create = function (F) {
              return new p(h, R, F);
            }),
            (L.update = function (F, $) {
              return L.create($).update(F);
            }),
            z(L, N, h, R)
          );
        },
        J = function (h, R) {
          var L = B[h],
            F = U(h, R, 'hex');
          return (
            (F.create = function ($, te, Q) {
              return !te && !Q ? d['shake' + h].create($) : new p(h, R, $).bytepad([te, Q], L);
            }),
            (F.update = function ($, te, Q, X) {
              return F.create(te, Q, X).update($);
            }),
            z(F, U, h, R)
          );
        },
        le = function (h, R) {
          var L = B[h],
            F = W(h, R, 'hex');
          return (
            (F.create = function ($, te, Q) {
              return new x(h, R, te).bytepad(['KMAC', Q], L).bytepad([$], L);
            }),
            (F.update = function ($, te, Q, X) {
              return F.create($, Q, X).update(te);
            }),
            z(F, W, h, R)
          );
        },
        C = [
          { name: 'keccak', padding: m, bits: A, createMethod: Y },
          { name: 'sha3', padding: w, bits: A, createMethod: Y },
          { name: 'shake', padding: c, bits: _, createMethod: ue },
          { name: 'cshake', padding: f, bits: _, createMethod: J },
          { name: 'kmac', padding: f, bits: _, createMethod: le },
        ],
        d = {},
        y = [],
        g = 0;
      g < C.length;
      ++g
    )
      for (var S = C[g], E = S.bits, M = 0; M < E.length; ++M) {
        var I = S.name + '_' + E[M];
        if ((y.push(I), (d[I] = S.createMethod(E[M], S.padding)), S.name !== 'sha3')) {
          var b = S.name + E[M];
          y.push(b), (d[b] = d[I]);
        }
      }
    function p(h, R, L) {
      (this.blocks = []),
        (this.s = []),
        (this.padding = R),
        (this.outputBits = L),
        (this.reset = !0),
        (this.finalized = !1),
        (this.block = 0),
        (this.start = 0),
        (this.blockCount = (1600 - (h << 1)) >> 5),
        (this.byteCount = this.blockCount << 2),
        (this.outputBlocks = L >> 5),
        (this.extraBytes = (L & 31) >> 3);
      for (var F = 0; F < 50; ++F) this.s[F] = 0;
    }
    (p.prototype.update = function (h) {
      if (this.finalized) throw new Error(t);
      var R,
        L = typeof h;
      if (L !== 'string') {
        if (L === 'object') {
          if (h === null) throw new Error(e);
          if (u && h.constructor === ArrayBuffer) h = new Uint8Array(h);
          else if (!Array.isArray(h) && (!u || !ArrayBuffer.isView(h))) throw new Error(e);
        } else throw new Error(e);
        R = !0;
      }
      for (var F = this.blocks, $ = this.byteCount, te = h.length, Q = this.blockCount, X = 0, Ct = this.s, ne, ye; X < te; ) {
        if (this.reset) for (this.reset = !1, F[0] = this.block, ne = 1; ne < Q + 1; ++ne) F[ne] = 0;
        if (R) for (ne = this.start; X < te && ne < $; ++X) F[ne >> 2] |= h[X] << v[ne++ & 3];
        else
          for (ne = this.start; X < te && ne < $; ++X)
            (ye = h.charCodeAt(X)),
              ye < 128
                ? (F[ne >> 2] |= ye << v[ne++ & 3])
                : ye < 2048
                ? ((F[ne >> 2] |= (192 | (ye >> 6)) << v[ne++ & 3]), (F[ne >> 2] |= (128 | (ye & 63)) << v[ne++ & 3]))
                : ye < 55296 || ye >= 57344
                ? ((F[ne >> 2] |= (224 | (ye >> 12)) << v[ne++ & 3]), (F[ne >> 2] |= (128 | ((ye >> 6) & 63)) << v[ne++ & 3]), (F[ne >> 2] |= (128 | (ye & 63)) << v[ne++ & 3]))
                : ((ye = 65536 + (((ye & 1023) << 10) | (h.charCodeAt(++X) & 1023))),
                  (F[ne >> 2] |= (240 | (ye >> 18)) << v[ne++ & 3]),
                  (F[ne >> 2] |= (128 | ((ye >> 12) & 63)) << v[ne++ & 3]),
                  (F[ne >> 2] |= (128 | ((ye >> 6) & 63)) << v[ne++ & 3]),
                  (F[ne >> 2] |= (128 | (ye & 63)) << v[ne++ & 3]));
        if (((this.lastByteIndex = ne), ne >= $)) {
          for (this.start = ne - $, this.block = F[Q], ne = 0; ne < Q; ++ne) Ct[ne] ^= F[ne];
          k(Ct), (this.reset = !0);
        } else this.start = ne;
      }
      return this;
    }),
      (p.prototype.encode = function (h, R) {
        var L = h & 255,
          F = 1,
          $ = [L];
        for (h = h >> 8, L = h & 255; L > 0; ) $.unshift(L), (h = h >> 8), (L = h & 255), ++F;
        return R ? $.push(F) : $.unshift(F), this.update($), $.length;
      }),
      (p.prototype.encodeString = function (h) {
        var R,
          L = typeof h;
        if (L !== 'string') {
          if (L === 'object') {
            if (h === null) throw new Error(e);
            if (u && h.constructor === ArrayBuffer) h = new Uint8Array(h);
            else if (!Array.isArray(h) && (!u || !ArrayBuffer.isView(h))) throw new Error(e);
          } else throw new Error(e);
          R = !0;
        }
        var F = 0,
          $ = h.length;
        if (R) F = $;
        else
          for (var te = 0; te < h.length; ++te) {
            var Q = h.charCodeAt(te);
            Q < 128 ? (F += 1) : Q < 2048 ? (F += 2) : Q < 55296 || Q >= 57344 ? (F += 3) : ((Q = 65536 + (((Q & 1023) << 10) | (h.charCodeAt(++te) & 1023))), (F += 4));
          }
        return (F += this.encode(F * 8)), this.update(h), F;
      }),
      (p.prototype.bytepad = function (h, R) {
        for (var L = this.encode(R), F = 0; F < h.length; ++F) L += this.encodeString(h[F]);
        var $ = R - (L % R),
          te = [];
        return (te.length = $), this.update(te), this;
      }),
      (p.prototype.finalize = function () {
        if (!this.finalized) {
          this.finalized = !0;
          var h = this.blocks,
            R = this.lastByteIndex,
            L = this.blockCount,
            F = this.s;
          if (((h[R >> 2] |= this.padding[R & 3]), this.lastByteIndex === this.byteCount)) for (h[0] = h[L], R = 1; R < L + 1; ++R) h[R] = 0;
          for (h[L - 1] |= 2147483648, R = 0; R < L; ++R) F[R] ^= h[R];
          k(F);
        }
      }),
      (p.prototype.toString = p.prototype.hex =
        function () {
          this.finalize();
          for (var h = this.blockCount, R = this.s, L = this.outputBlocks, F = this.extraBytes, $ = 0, te = 0, Q = '', X; te < L; ) {
            for ($ = 0; $ < h && te < L; ++$, ++te)
              (X = R[$]), (Q += l[(X >> 4) & 15] + l[X & 15] + l[(X >> 12) & 15] + l[(X >> 8) & 15] + l[(X >> 20) & 15] + l[(X >> 16) & 15] + l[(X >> 28) & 15] + l[(X >> 24) & 15]);
            te % h === 0 && (k(R), ($ = 0));
          }
          return F && ((X = R[$]), (Q += l[(X >> 4) & 15] + l[X & 15]), F > 1 && (Q += l[(X >> 12) & 15] + l[(X >> 8) & 15]), F > 2 && (Q += l[(X >> 20) & 15] + l[(X >> 16) & 15])), Q;
        }),
      (p.prototype.arrayBuffer = function () {
        this.finalize();
        var h = this.blockCount,
          R = this.s,
          L = this.outputBlocks,
          F = this.extraBytes,
          $ = 0,
          te = 0,
          Q = this.outputBits >> 3,
          X;
        F ? (X = new ArrayBuffer((L + 1) << 2)) : (X = new ArrayBuffer(Q));
        for (var Ct = new Uint32Array(X); te < L; ) {
          for ($ = 0; $ < h && te < L; ++$, ++te) Ct[te] = R[$];
          te % h === 0 && k(R);
        }
        return F && ((Ct[$] = R[$]), (X = X.slice(0, Q))), X;
      }),
      (p.prototype.buffer = p.prototype.arrayBuffer),
      (p.prototype.digest = p.prototype.array =
        function () {
          this.finalize();
          for (var h = this.blockCount, R = this.s, L = this.outputBlocks, F = this.extraBytes, $ = 0, te = 0, Q = [], X, Ct; te < L; ) {
            for ($ = 0; $ < h && te < L; ++$, ++te) (X = te << 2), (Ct = R[$]), (Q[X] = Ct & 255), (Q[X + 1] = (Ct >> 8) & 255), (Q[X + 2] = (Ct >> 16) & 255), (Q[X + 3] = (Ct >> 24) & 255);
            te % h === 0 && k(R);
          }
          return F && ((X = te << 2), (Ct = R[$]), (Q[X] = Ct & 255), F > 1 && (Q[X + 1] = (Ct >> 8) & 255), F > 2 && (Q[X + 2] = (Ct >> 16) & 255)), Q;
        });
    function x(h, R, L) {
      p.call(this, h, R, L);
    }
    (x.prototype = new p()),
      (x.prototype.finalize = function () {
        return this.encode(this.outputBits, !0), p.prototype.finalize.call(this);
      });
    var k = function (h) {
      var R,
        L,
        F,
        $,
        te,
        Q,
        X,
        Ct,
        ne,
        ye,
        ks,
        qe,
        He,
        Ps,
        Ke,
        We,
        Ns,
        Je,
        Qe,
        Ds,
        Ye,
        Xe,
        Bs,
        Ze,
        et,
        Fs,
        tt,
        nt,
        Ls,
        it,
        rt,
        $s,
        st,
        at,
        Us,
        ot,
        ut,
        js,
        lt,
        dt,
        Vs,
        ct,
        pt,
        zs,
        ft,
        yt,
        Gs,
        ht,
        mt,
        qs,
        bt,
        gt,
        Hs,
        vt,
        xt,
        Ks,
        Tt,
        wt,
        Qr,
        Yr,
        Xr,
        Zr,
        es;
      for (F = 0; F < 48; F += 2)
        ($ = h[0] ^ h[10] ^ h[20] ^ h[30] ^ h[40]),
          (te = h[1] ^ h[11] ^ h[21] ^ h[31] ^ h[41]),
          (Q = h[2] ^ h[12] ^ h[22] ^ h[32] ^ h[42]),
          (X = h[3] ^ h[13] ^ h[23] ^ h[33] ^ h[43]),
          (Ct = h[4] ^ h[14] ^ h[24] ^ h[34] ^ h[44]),
          (ne = h[5] ^ h[15] ^ h[25] ^ h[35] ^ h[45]),
          (ye = h[6] ^ h[16] ^ h[26] ^ h[36] ^ h[46]),
          (ks = h[7] ^ h[17] ^ h[27] ^ h[37] ^ h[47]),
          (qe = h[8] ^ h[18] ^ h[28] ^ h[38] ^ h[48]),
          (He = h[9] ^ h[19] ^ h[29] ^ h[39] ^ h[49]),
          (R = qe ^ ((Q << 1) | (X >>> 31))),
          (L = He ^ ((X << 1) | (Q >>> 31))),
          (h[0] ^= R),
          (h[1] ^= L),
          (h[10] ^= R),
          (h[11] ^= L),
          (h[20] ^= R),
          (h[21] ^= L),
          (h[30] ^= R),
          (h[31] ^= L),
          (h[40] ^= R),
          (h[41] ^= L),
          (R = $ ^ ((Ct << 1) | (ne >>> 31))),
          (L = te ^ ((ne << 1) | (Ct >>> 31))),
          (h[2] ^= R),
          (h[3] ^= L),
          (h[12] ^= R),
          (h[13] ^= L),
          (h[22] ^= R),
          (h[23] ^= L),
          (h[32] ^= R),
          (h[33] ^= L),
          (h[42] ^= R),
          (h[43] ^= L),
          (R = Q ^ ((ye << 1) | (ks >>> 31))),
          (L = X ^ ((ks << 1) | (ye >>> 31))),
          (h[4] ^= R),
          (h[5] ^= L),
          (h[14] ^= R),
          (h[15] ^= L),
          (h[24] ^= R),
          (h[25] ^= L),
          (h[34] ^= R),
          (h[35] ^= L),
          (h[44] ^= R),
          (h[45] ^= L),
          (R = Ct ^ ((qe << 1) | (He >>> 31))),
          (L = ne ^ ((He << 1) | (qe >>> 31))),
          (h[6] ^= R),
          (h[7] ^= L),
          (h[16] ^= R),
          (h[17] ^= L),
          (h[26] ^= R),
          (h[27] ^= L),
          (h[36] ^= R),
          (h[37] ^= L),
          (h[46] ^= R),
          (h[47] ^= L),
          (R = ye ^ (($ << 1) | (te >>> 31))),
          (L = ks ^ ((te << 1) | ($ >>> 31))),
          (h[8] ^= R),
          (h[9] ^= L),
          (h[18] ^= R),
          (h[19] ^= L),
          (h[28] ^= R),
          (h[29] ^= L),
          (h[38] ^= R),
          (h[39] ^= L),
          (h[48] ^= R),
          (h[49] ^= L),
          (Ps = h[0]),
          (Ke = h[1]),
          (yt = (h[11] << 4) | (h[10] >>> 28)),
          (Gs = (h[10] << 4) | (h[11] >>> 28)),
          (nt = (h[20] << 3) | (h[21] >>> 29)),
          (Ls = (h[21] << 3) | (h[20] >>> 29)),
          (Yr = (h[31] << 9) | (h[30] >>> 23)),
          (Xr = (h[30] << 9) | (h[31] >>> 23)),
          (ct = (h[40] << 18) | (h[41] >>> 14)),
          (pt = (h[41] << 18) | (h[40] >>> 14)),
          (at = (h[2] << 1) | (h[3] >>> 31)),
          (Us = (h[3] << 1) | (h[2] >>> 31)),
          (We = (h[13] << 12) | (h[12] >>> 20)),
          (Ns = (h[12] << 12) | (h[13] >>> 20)),
          (ht = (h[22] << 10) | (h[23] >>> 22)),
          (mt = (h[23] << 10) | (h[22] >>> 22)),
          (it = (h[33] << 13) | (h[32] >>> 19)),
          (rt = (h[32] << 13) | (h[33] >>> 19)),
          (Zr = (h[42] << 2) | (h[43] >>> 30)),
          (es = (h[43] << 2) | (h[42] >>> 30)),
          (vt = (h[5] << 30) | (h[4] >>> 2)),
          (xt = (h[4] << 30) | (h[5] >>> 2)),
          (ot = (h[14] << 6) | (h[15] >>> 26)),
          (ut = (h[15] << 6) | (h[14] >>> 26)),
          (Je = (h[25] << 11) | (h[24] >>> 21)),
          (Qe = (h[24] << 11) | (h[25] >>> 21)),
          (qs = (h[34] << 15) | (h[35] >>> 17)),
          (bt = (h[35] << 15) | (h[34] >>> 17)),
          ($s = (h[45] << 29) | (h[44] >>> 3)),
          (st = (h[44] << 29) | (h[45] >>> 3)),
          (Ze = (h[6] << 28) | (h[7] >>> 4)),
          (et = (h[7] << 28) | (h[6] >>> 4)),
          (Ks = (h[17] << 23) | (h[16] >>> 9)),
          (Tt = (h[16] << 23) | (h[17] >>> 9)),
          (js = (h[26] << 25) | (h[27] >>> 7)),
          (lt = (h[27] << 25) | (h[26] >>> 7)),
          (Ds = (h[36] << 21) | (h[37] >>> 11)),
          (Ye = (h[37] << 21) | (h[36] >>> 11)),
          (gt = (h[47] << 24) | (h[46] >>> 8)),
          (Hs = (h[46] << 24) | (h[47] >>> 8)),
          (zs = (h[8] << 27) | (h[9] >>> 5)),
          (ft = (h[9] << 27) | (h[8] >>> 5)),
          (Fs = (h[18] << 20) | (h[19] >>> 12)),
          (tt = (h[19] << 20) | (h[18] >>> 12)),
          (wt = (h[29] << 7) | (h[28] >>> 25)),
          (Qr = (h[28] << 7) | (h[29] >>> 25)),
          (dt = (h[38] << 8) | (h[39] >>> 24)),
          (Vs = (h[39] << 8) | (h[38] >>> 24)),
          (Xe = (h[48] << 14) | (h[49] >>> 18)),
          (Bs = (h[49] << 14) | (h[48] >>> 18)),
          (h[0] = Ps ^ (~We & Je)),
          (h[1] = Ke ^ (~Ns & Qe)),
          (h[10] = Ze ^ (~Fs & nt)),
          (h[11] = et ^ (~tt & Ls)),
          (h[20] = at ^ (~ot & js)),
          (h[21] = Us ^ (~ut & lt)),
          (h[30] = zs ^ (~yt & ht)),
          (h[31] = ft ^ (~Gs & mt)),
          (h[40] = vt ^ (~Ks & wt)),
          (h[41] = xt ^ (~Tt & Qr)),
          (h[2] = We ^ (~Je & Ds)),
          (h[3] = Ns ^ (~Qe & Ye)),
          (h[12] = Fs ^ (~nt & it)),
          (h[13] = tt ^ (~Ls & rt)),
          (h[22] = ot ^ (~js & dt)),
          (h[23] = ut ^ (~lt & Vs)),
          (h[32] = yt ^ (~ht & qs)),
          (h[33] = Gs ^ (~mt & bt)),
          (h[42] = Ks ^ (~wt & Yr)),
          (h[43] = Tt ^ (~Qr & Xr)),
          (h[4] = Je ^ (~Ds & Xe)),
          (h[5] = Qe ^ (~Ye & Bs)),
          (h[14] = nt ^ (~it & $s)),
          (h[15] = Ls ^ (~rt & st)),
          (h[24] = js ^ (~dt & ct)),
          (h[25] = lt ^ (~Vs & pt)),
          (h[34] = ht ^ (~qs & gt)),
          (h[35] = mt ^ (~bt & Hs)),
          (h[44] = wt ^ (~Yr & Zr)),
          (h[45] = Qr ^ (~Xr & es)),
          (h[6] = Ds ^ (~Xe & Ps)),
          (h[7] = Ye ^ (~Bs & Ke)),
          (h[16] = it ^ (~$s & Ze)),
          (h[17] = rt ^ (~st & et)),
          (h[26] = dt ^ (~ct & at)),
          (h[27] = Vs ^ (~pt & Us)),
          (h[36] = qs ^ (~gt & zs)),
          (h[37] = bt ^ (~Hs & ft)),
          (h[46] = Yr ^ (~Zr & vt)),
          (h[47] = Xr ^ (~es & xt)),
          (h[8] = Xe ^ (~Ps & We)),
          (h[9] = Bs ^ (~Ke & Ns)),
          (h[18] = $s ^ (~Ze & Fs)),
          (h[19] = st ^ (~et & tt)),
          (h[28] = ct ^ (~at & ot)),
          (h[29] = pt ^ (~Us & ut)),
          (h[38] = gt ^ (~zs & yt)),
          (h[39] = Hs ^ (~ft & Gs)),
          (h[48] = Zr ^ (~vt & Ks)),
          (h[49] = es ^ (~xt & Tt)),
          (h[0] ^= T[F]),
          (h[1] ^= T[F + 1]);
    };
    if (o) n.exports = d;
    else for (g = 0; g < y.length; ++g) r[y[g]] = d[y[g]];
  })();
})(XS);
const ZS = wy;
function De(n) {
  return '0x' + ZS.keccak_256(H(n));
}
const eC = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        keccak256: De,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  tC = 'rlp/5.7.0',
  Vi = new D(tC);
function Kg(n) {
  const e = [];
  for (; n; ) e.unshift(n & 255), (n >>= 8);
  return e;
}
function Wg(n, e, t) {
  let i = 0;
  for (let r = 0; r < t; r++) i = i * 256 + n[e + r];
  return i;
}
function vT(n) {
  if (Array.isArray(n)) {
    let i = [];
    if (
      (n.forEach(function (s) {
        i = i.concat(vT(s));
      }),
      i.length <= 55)
    )
      return i.unshift(192 + i.length), i;
    const r = Kg(i.length);
    return r.unshift(247 + r.length), r.concat(i);
  }
  Pl(n) || Vi.throwArgumentError('RLP object must be BytesLike', 'object', n);
  const e = Array.prototype.slice.call(H(n));
  if (e.length === 1 && e[0] <= 127) return e;
  if (e.length <= 55) return e.unshift(128 + e.length), e;
  const t = Kg(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
function Ts(n) {
  return K(vT(n));
}
function Jg(n, e, t, i) {
  const r = [];
  for (; t < e + 1 + i; ) {
    const s = xT(n, t);
    r.push(s.result), (t += s.consumed), t > e + 1 + i && Vi.throwError('child data too short', D.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + i, result: r };
}
function xT(n, e) {
  if ((n.length === 0 && Vi.throwError('data too short', D.errors.BUFFER_OVERRUN, {}), n[e] >= 248)) {
    const t = n[e] - 247;
    e + 1 + t > n.length && Vi.throwError('data short segment too short', D.errors.BUFFER_OVERRUN, {});
    const i = Wg(n, e + 1, t);
    return e + 1 + t + i > n.length && Vi.throwError('data long segment too short', D.errors.BUFFER_OVERRUN, {}), Jg(n, e, e + 1 + t, t + i);
  } else if (n[e] >= 192) {
    const t = n[e] - 192;
    return e + 1 + t > n.length && Vi.throwError('data array too short', D.errors.BUFFER_OVERRUN, {}), Jg(n, e, e + 1, t);
  } else if (n[e] >= 184) {
    const t = n[e] - 183;
    e + 1 + t > n.length && Vi.throwError('data array too short', D.errors.BUFFER_OVERRUN, {});
    const i = Wg(n, e + 1, t);
    e + 1 + t + i > n.length && Vi.throwError('data array too short', D.errors.BUFFER_OVERRUN, {});
    const r = K(n.slice(e + 1 + t, e + 1 + t + i));
    return { consumed: 1 + t + i, result: r };
  } else if (n[e] >= 128) {
    const t = n[e] - 128;
    e + 1 + t > n.length && Vi.throwError('data too short', D.errors.BUFFER_OVERRUN, {});
    const i = K(n.slice(e + 1, e + 1 + t));
    return { consumed: 1 + t, result: i };
  }
  return { consumed: 1, result: K(n[e]) };
}
function Dl(n) {
  const e = H(n),
    t = xT(e, 0);
  return t.consumed !== e.length && Vi.throwArgumentError('invalid rlp data', 'data', n), t.result;
}
const nC = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        decode: Dl,
        encode: Ts,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  iC = 'address/5.7.0',
  ds = new D(iC);
function Qg(n) {
  Me(n, 20) || ds.throwArgumentError('invalid address', 'address', n), (n = n.toLowerCase());
  const e = n.substring(2).split(''),
    t = new Uint8Array(40);
  for (let r = 0; r < 40; r++) t[r] = e[r].charCodeAt(0);
  const i = H(De(t));
  for (let r = 0; r < 40; r += 2) i[r >> 1] >> 4 >= 8 && (e[r] = e[r].toUpperCase()), (i[r >> 1] & 15) >= 8 && (e[r + 1] = e[r + 1].toUpperCase());
  return '0x' + e.join('');
}
const rC = 9007199254740991;
function sC(n) {
  return Math.log10 ? Math.log10(n) : Math.log(n) / Math.LN10;
}
const d0 = {};
for (let n = 0; n < 10; n++) d0[String(n)] = String(n);
for (let n = 0; n < 26; n++) d0[String.fromCharCode(65 + n)] = String(10 + n);
const Yg = Math.floor(sC(rC));
function TT(n) {
  (n = n.toUpperCase()), (n = n.substring(4) + n.substring(0, 2) + '00');
  let e = n
    .split('')
    .map((i) => d0[i])
    .join('');
  for (; e.length >= Yg; ) {
    let i = e.substring(0, Yg);
    e = (parseInt(i, 10) % 97) + e.substring(i.length);
  }
  let t = String(98 - (parseInt(e, 10) % 97));
  for (; t.length < 2; ) t = '0' + t;
  return t;
}
function Fe(n) {
  let e = null;
  if ((typeof n != 'string' && ds.throwArgumentError('invalid address', 'address', n), n.match(/^(0x)?[0-9a-fA-F]{40}$/)))
    n.substring(0, 2) !== '0x' && (n = '0x' + n), (e = Qg(n)), n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== n && ds.throwArgumentError('bad address checksum', 'address', n);
  else if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (n.substring(2, 4) !== TT(n) && ds.throwArgumentError('bad icap checksum', 'address', n), e = pS(n.substring(4)); e.length < 40; ) e = '0' + e;
    e = Qg('0x' + e);
  } else ds.throwArgumentError('invalid address', 'address', n);
  return e;
}
function aC(n) {
  try {
    return Fe(n), !0;
  } catch {}
  return !1;
}
function oC(n) {
  let e = fS(Fe(n).substring(2)).toUpperCase();
  for (; e.length < 30; ) e = '0' + e;
  return 'XE' + TT('XE00' + e) + e;
}
function c0(n) {
  let e = null;
  try {
    e = Fe(n.from);
  } catch {
    ds.throwArgumentError('missing from address', 'transaction', n);
  }
  const t = Qi(H(q.from(n.nonce).toHexString()));
  return Fe(Lt(De(Ts([e, t])), 12));
}
function uC(n, e, t) {
  return (
    nr(e) !== 32 && ds.throwArgumentError('salt must be 32 bytes', 'salt', e),
    nr(t) !== 32 && ds.throwArgumentError('initCodeHash must be 32 bytes', 'initCodeHash', t),
    Fe(Lt(De(Ge(['0xff', Fe(n), e, t])), 12))
  );
}
const lC = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      getAddress: Fe,
      getContractAddress: c0,
      getCreate2Address: uC,
      getIcapAddress: oC,
      isAddress: aC,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
class dC extends Kr {
  constructor(e) {
    super('address', 'address', e, !1);
  }
  defaultValue() {
    return '0x0000000000000000000000000000000000000000';
  }
  encode(e, t) {
    try {
      t = Fe(t);
    } catch (i) {
      this._throwError(i.message, t);
    }
    return e.writeValue(t);
  }
  decode(e) {
    return Fe(Le(e.readValue().toHexString(), 20));
  }
}
class cC extends Kr {
  constructor(e) {
    super(e.name, e.type, void 0, e.dynamic), (this.coder = e);
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, t) {
    return this.coder.encode(e, t);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
const ro = new D(Nl);
function wT(n, e, t) {
  let i = null;
  if (Array.isArray(t)) i = t;
  else if (t && typeof t == 'object') {
    let u = {};
    i = e.map((l) => {
      const c = l.localName;
      return (
        c ||
          ro.throwError('cannot encode object for signature with missing names', D.errors.INVALID_ARGUMENT, {
            argument: 'values',
            coder: l,
            value: t,
          }),
        u[c] &&
          ro.throwError('cannot encode object for signature with duplicate names', D.errors.INVALID_ARGUMENT, {
            argument: 'values',
            coder: l,
            value: t,
          }),
        (u[c] = !0),
        t[c]
      );
    });
  } else ro.throwArgumentError('invalid tuple value', 'tuple', t);
  e.length !== i.length && ro.throwArgumentError('types/value length mismatch', 'tuple', t);
  let r = new Ty(n.wordSize),
    s = new Ty(n.wordSize),
    a = [];
  e.forEach((u, l) => {
    let c = i[l];
    if (u.dynamic) {
      let f = s.length;
      u.encode(s, c);
      let m = r.writeUpdatableValue();
      a.push((w) => {
        m(w + f);
      });
    } else u.encode(r, c);
  }),
    a.forEach((u) => {
      u(r.length);
    });
  let o = n.appendWriter(r);
  return (o += n.appendWriter(s)), o;
}
function AT(n, e) {
  let t = [],
    i = n.subReader(0);
  e.forEach((s) => {
    let a = null;
    if (s.dynamic) {
      let o = n.readValue(),
        u = i.subReader(o.toNumber());
      try {
        a = s.decode(u);
      } catch (l) {
        if (l.code === D.errors.BUFFER_OVERRUN) throw l;
        (a = l), (a.baseType = s.name), (a.name = s.localName), (a.type = s.type);
      }
    } else
      try {
        a = s.decode(n);
      } catch (o) {
        if (o.code === D.errors.BUFFER_OVERRUN) throw o;
        (a = o), (a.baseType = s.name), (a.name = s.localName), (a.type = s.type);
      }
    a != null && t.push(a);
  });
  const r = e.reduce((s, a) => {
    const o = a.localName;
    return o && (s[o] || (s[o] = 0), s[o]++), s;
  }, {});
  e.forEach((s, a) => {
    let o = s.localName;
    if (!o || r[o] !== 1 || (o === 'length' && (o = '_length'), t[o] != null)) return;
    const u = t[a];
    u instanceof Error
      ? Object.defineProperty(t, o, {
          enumerable: !0,
          get: () => {
            throw u;
          },
        })
      : (t[o] = u);
  });
  for (let s = 0; s < t.length; s++) {
    const a = t[s];
    a instanceof Error &&
      Object.defineProperty(t, s, {
        enumerable: !0,
        get: () => {
          throw a;
        },
      });
  }
  return Object.freeze(t);
}
class pC extends Kr {
  constructor(e, t, i) {
    const r = e.type + '[' + (t >= 0 ? t : '') + ']',
      s = t === -1 || e.dynamic;
    super('array', r, i, s), (this.coder = e), (this.length = t);
  }
  defaultValue() {
    const e = this.coder.defaultValue(),
      t = [];
    for (let i = 0; i < this.length; i++) t.push(e);
    return t;
  }
  encode(e, t) {
    Array.isArray(t) || this._throwError('expected array value', t);
    let i = this.length;
    i === -1 && ((i = t.length), e.writeValue(t.length)), ro.checkArgumentCount(t.length, i, 'coder array' + (this.localName ? ' ' + this.localName : ''));
    let r = [];
    for (let s = 0; s < t.length; s++) r.push(this.coder);
    return wT(e, r, t);
  }
  decode(e) {
    let t = this.length;
    t === -1 &&
      ((t = e.readValue().toNumber()),
      t * 32 > e._data.length &&
        ro.throwError('insufficient data length', D.errors.BUFFER_OVERRUN, {
          length: e._data.length,
          count: t,
        }));
    let i = [];
    for (let r = 0; r < t; r++) i.push(new cC(this.coder));
    return e.coerce(this.name, AT(e, i));
  }
}
class fC extends Kr {
  constructor(e) {
    super('bool', 'bool', e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    return e.writeValue(t ? 1 : 0);
  }
  decode(e) {
    return e.coerce(this.type, !e.readValue().isZero());
  }
}
class ET extends Kr {
  constructor(e, t) {
    super(e, e, t, !0);
  }
  defaultValue() {
    return '0x';
  }
  encode(e, t) {
    t = H(t);
    let i = e.writeValue(t.length);
    return (i += e.writeBytes(t)), i;
  }
  decode(e) {
    return e.readBytes(e.readValue().toNumber(), !0);
  }
}
class yC extends ET {
  constructor(e) {
    super('bytes', e);
  }
  decode(e) {
    return e.coerce(this.name, K(super.decode(e)));
  }
}
class hC extends Kr {
  constructor(e, t) {
    let i = 'bytes' + String(e);
    super(i, i, t, !1), (this.size = e);
  }
  defaultValue() {
    return '0x0000000000000000000000000000000000000000000000000000000000000000'.substring(0, 2 + this.size * 2);
  }
  encode(e, t) {
    let i = H(t);
    return i.length !== this.size && this._throwError('incorrect data length', t), e.writeBytes(i);
  }
  decode(e) {
    return e.coerce(this.name, K(e.readBytes(this.size)));
  }
}
class mC extends Kr {
  constructor(e) {
    super('null', '', e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, t) {
    return t != null && this._throwError('not null', t), e.writeBytes([]);
  }
  decode(e) {
    return e.readBytes(0), e.coerce(this.name, null);
  }
}
const bC = '0x0000000000000000000000000000000000000000',
  gC = /* @__PURE__ */ q.from(-1),
  p0 = /* @__PURE__ */ q.from(0),
  vC = /* @__PURE__ */ q.from(1),
  xC = /* @__PURE__ */ q.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'),
  ST = '0x0000000000000000000000000000000000000000000000000000000000000000';
class TC extends Kr {
  constructor(e, t, i) {
    const r = (t ? 'int' : 'uint') + e * 8;
    super(r, r, i, !1), (this.size = e), (this.signed = t);
  }
  defaultValue() {
    return 0;
  }
  encode(e, t) {
    let i = q.from(t),
      r = xC.mask(e.wordSize * 8);
    if (this.signed) {
      let s = r.mask(this.size * 8 - 1);
      (i.gt(s) || i.lt(s.add(vC).mul(gC))) && this._throwError('value out-of-bounds', t);
    } else (i.lt(p0) || i.gt(r.mask(this.size * 8))) && this._throwError('value out-of-bounds', t);
    return (i = i.toTwos(this.size * 8).mask(this.size * 8)), this.signed && (i = i.fromTwos(this.size * 8).toTwos(8 * e.wordSize)), e.writeValue(i);
  }
  decode(e) {
    let t = e.readValue().mask(this.size * 8);
    return this.signed && (t = t.fromTwos(this.size * 8)), e.coerce(this.name, t);
  }
}
const wC = 'strings/5.7.0',
  CT = new D(wC);
var ir;
(function (n) {
  (n.current = ''), (n.NFC = 'NFC'), (n.NFD = 'NFD'), (n.NFKC = 'NFKC'), (n.NFKD = 'NFKD');
})(ir || (ir = {}));
var Fn;
(function (n) {
  (n.UNEXPECTED_CONTINUE = 'unexpected continuation byte'),
    (n.BAD_PREFIX = 'bad codepoint prefix'),
    (n.OVERRUN = 'string overrun'),
    (n.MISSING_CONTINUE = 'missing continuation byte'),
    (n.OUT_OF_RANGE = 'out of UTF-8 range'),
    (n.UTF16_SURROGATE = 'UTF-16 surrogate'),
    (n.OVERLONG = 'overlong representation');
})(Fn || (Fn = {}));
function AC(n, e, t, i, r) {
  return CT.throwArgumentError(`invalid codepoint at offset ${e}; ${n}`, 'bytes', t);
}
function MT(n, e, t, i, r) {
  if (n === Fn.BAD_PREFIX || n === Fn.UNEXPECTED_CONTINUE) {
    let s = 0;
    for (let a = e + 1; a < t.length && t[a] >> 6 === 2; a++) s++;
    return s;
  }
  return n === Fn.OVERRUN ? t.length - e - 1 : 0;
}
function EC(n, e, t, i, r) {
  return n === Fn.OVERLONG ? (i.push(r), 0) : (i.push(65533), MT(n, e, t));
}
const _T = Object.freeze({
  error: AC,
  ignore: MT,
  replace: EC,
});
function f0(n, e) {
  e == null && (e = _T.error), (n = H(n));
  const t = [];
  let i = 0;
  for (; i < n.length; ) {
    const r = n[i++];
    if (!(r >> 7)) {
      t.push(r);
      continue;
    }
    let s = null,
      a = null;
    if ((r & 224) === 192) (s = 1), (a = 127);
    else if ((r & 240) === 224) (s = 2), (a = 2047);
    else if ((r & 248) === 240) (s = 3), (a = 65535);
    else {
      (r & 192) === 128 ? (i += e(Fn.UNEXPECTED_CONTINUE, i - 1, n, t)) : (i += e(Fn.BAD_PREFIX, i - 1, n, t));
      continue;
    }
    if (i - 1 + s >= n.length) {
      i += e(Fn.OVERRUN, i - 1, n, t);
      continue;
    }
    let o = r & ((1 << (8 - s - 1)) - 1);
    for (let u = 0; u < s; u++) {
      let l = n[i];
      if ((l & 192) != 128) {
        (i += e(Fn.MISSING_CONTINUE, i, n, t)), (o = null);
        break;
      }
      (o = (o << 6) | (l & 63)), i++;
    }
    if (o !== null) {
      if (o > 1114111) {
        i += e(Fn.OUT_OF_RANGE, i - 1 - s, n, t, o);
        continue;
      }
      if (o >= 55296 && o <= 57343) {
        i += e(Fn.UTF16_SURROGATE, i - 1 - s, n, t, o);
        continue;
      }
      if (o <= a) {
        i += e(Fn.OVERLONG, i - 1 - s, n, t, o);
        continue;
      }
      t.push(o);
    }
  }
  return t;
}
function $t(n, e = ir.current) {
  e != ir.current && (CT.checkNormalize(), (n = n.normalize(e)));
  let t = [];
  for (let i = 0; i < n.length; i++) {
    const r = n.charCodeAt(i);
    if (r < 128) t.push(r);
    else if (r < 2048) t.push((r >> 6) | 192), t.push((r & 63) | 128);
    else if ((r & 64512) == 55296) {
      i++;
      const s = n.charCodeAt(i);
      if (i >= n.length || (s & 64512) !== 56320) throw new Error('invalid utf-8 string');
      const a = 65536 + ((r & 1023) << 10) + (s & 1023);
      t.push((a >> 18) | 240), t.push(((a >> 12) & 63) | 128), t.push(((a >> 6) & 63) | 128), t.push((a & 63) | 128);
    } else t.push((r >> 12) | 224), t.push(((r >> 6) & 63) | 128), t.push((r & 63) | 128);
  }
  return H(t);
}
function ff(n) {
  const e = '0000' + n.toString(16);
  return '\\u' + e.substring(e.length - 4);
}
function SC(n, e) {
  return (
    '"' +
    f0(n, e)
      .map((t) => {
        if (t < 256) {
          switch (t) {
            case 8:
              return '\\b';
            case 9:
              return '\\t';
            case 10:
              return '\\n';
            case 13:
              return '\\r';
            case 34:
              return '\\"';
            case 92:
              return '\\\\';
          }
          if (t >= 32 && t < 127) return String.fromCharCode(t);
        }
        return t <= 65535 ? ff(t) : ((t -= 65536), ff(((t >> 10) & 1023) + 55296) + ff((t & 1023) + 56320));
      })
      .join('') +
    '"'
  );
}
function Ay(n) {
  return n.map((e) => (e <= 65535 ? String.fromCharCode(e) : ((e -= 65536), String.fromCharCode(((e >> 10) & 1023) + 55296, (e & 1023) + 56320)))).join('');
}
function Rs(n, e) {
  return Ay(f0(n, e));
}
function cc(n, e = ir.current) {
  return f0($t(n, e));
}
function CC(n) {
  const e = $t(n);
  if (e.length > 31) throw new Error('bytes32 string must be less than 32 bytes');
  return K(Ge([e, ST]).slice(0, 32));
}
function MC(n) {
  const e = H(n);
  if (e.length !== 32) throw new Error('invalid bytes32 - not 32 bytes long');
  if (e[31] !== 0) throw new Error('invalid bytes32 string - no null terminator');
  let t = 31;
  for (; e[t - 1] === 0; ) t--;
  return Rs(e.slice(0, t));
}
function _C(n) {
  if (n.length % 4 !== 0) throw new Error('bad data');
  let e = [];
  for (let t = 0; t < n.length; t += 4) e.push(parseInt(n.substring(t, t + 4), 16));
  return e;
}
function y0(n, e) {
  e ||
    (e = function (r) {
      return [parseInt(r, 16)];
    });
  let t = 0,
    i = {};
  return (
    n.split(',').forEach((r) => {
      let s = r.split(':');
      (t += parseInt(s[0], 16)), (i[t] = e(s[1]));
    }),
    i
  );
}
function RT(n) {
  let e = 0;
  return n.split(',').map((t) => {
    let i = t.split('-');
    i.length === 1 ? (i[1] = '0') : i[1] === '' && (i[1] = '1');
    let r = e + parseInt(i[0], 16);
    return (e = parseInt(i[1], 16)), { l: r, h: e };
  });
}
function h0(n, e) {
  let t = 0;
  for (let i = 0; i < e.length; i++) {
    let r = e[i];
    if (((t += r.l), n >= t && n <= t + r.h && (n - t) % (r.d || 1) === 0)) {
      if (r.e && r.e.indexOf(n - t) !== -1) continue;
      return r;
    }
  }
  return null;
}
const RC = RT(
    '221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d',
  ),
  IC = 'ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff'.split(',').map((n) => parseInt(n, 16)),
  OC = [
    { h: 25, s: 32, l: 65 },
    { h: 30, s: 32, e: [23], l: 127 },
    { h: 54, s: 1, e: [48], l: 64, d: 2 },
    { h: 14, s: 1, l: 57, d: 2 },
    { h: 44, s: 1, l: 17, d: 2 },
    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
    { h: 16, s: 1, l: 68, d: 2 },
    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
    { h: 26, s: 32, e: [17], l: 435 },
    { h: 22, s: 1, l: 71, d: 2 },
    { h: 15, s: 80, l: 40 },
    { h: 31, s: 32, l: 16 },
    { h: 32, s: 1, l: 80, d: 2 },
    { h: 52, s: 1, l: 42, d: 2 },
    { h: 12, s: 1, l: 55, d: 2 },
    { h: 40, s: 1, e: [38], l: 15, d: 2 },
    { h: 14, s: 1, l: 48, d: 2 },
    { h: 37, s: 48, l: 49 },
    { h: 148, s: 1, l: 6351, d: 2 },
    { h: 88, s: 1, l: 160, d: 2 },
    { h: 15, s: 16, l: 704 },
    { h: 25, s: 26, l: 854 },
    { h: 25, s: 32, l: 55915 },
    { h: 37, s: 40, l: 1247 },
    { h: 25, s: -119711, l: 53248 },
    { h: 25, s: -119763, l: 52 },
    { h: 25, s: -119815, l: 52 },
    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
    { h: 25, s: -119919, l: 52 },
    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
    { h: 25, s: -120075, l: 52 },
    { h: 25, s: -120127, l: 52 },
    { h: 25, s: -120179, l: 52 },
    { h: 25, s: -120231, l: 52 },
    { h: 25, s: -120283, l: 52 },
    { h: 25, s: -120335, l: 52 },
    { h: 24, s: -119543, e: [17], l: 56 },
    { h: 24, s: -119601, e: [17], l: 58 },
    { h: 24, s: -119659, e: [17], l: 58 },
    { h: 24, s: -119717, e: [17], l: 58 },
    { h: 24, s: -119775, e: [17], l: 58 },
  ],
  kC = y0(
    'b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3',
  ),
  PC = y0(
    '179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7',
  ),
  NC = y0(
    'df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D',
    _C,
  ),
  DC = RT('80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001');
function BC(n) {
  return n.reduce(
    (e, t) => (
      t.forEach((i) => {
        e.push(i);
      }),
      e
    ),
    [],
  );
}
function FC(n) {
  return !!h0(n, RC);
}
function LC(n) {
  let e = h0(n, OC);
  if (e) return [n + e.s];
  let t = kC[n];
  if (t) return t;
  let i = PC[n];
  if (i) return [n + i[0]];
  let r = NC[n];
  return r || null;
}
function $C(n) {
  return !!h0(n, DC);
}
function UC(n) {
  if (n.match(/^[a-z0-9-]*$/i) && n.length <= 59) return n.toLowerCase();
  let e = cc(n);
  (e = BC(
    e.map((i) => {
      if (IC.indexOf(i) >= 0) return [];
      if (i >= 65024 && i <= 65039) return [];
      let r = LC(i);
      return r || [i];
    }),
  )),
    (e = cc(Ay(e), ir.NFKC)),
    e.forEach((i) => {
      if ($C(i)) throw new Error('STRINGPREP_CONTAINS_PROHIBITED');
    }),
    e.forEach((i) => {
      if (FC(i)) throw new Error('STRINGPREP_CONTAINS_UNASSIGNED');
    });
  let t = Ay(e);
  if (t.substring(0, 1) === '-' || t.substring(2, 4) === '--' || t.substring(t.length - 1) === '-') throw new Error('invalid hyphen');
  return t;
}
const jC = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      get UnicodeNormalizationForm() {
        return ir;
      },
      Utf8ErrorFuncs: _T,
      get Utf8ErrorReason() {
        return Fn;
      },
      _toEscapedUtf8String: SC,
      formatBytes32String: CC,
      nameprep: UC,
      parseBytes32String: MC,
      toUtf8Bytes: $t,
      toUtf8CodePoints: cc,
      toUtf8String: Rs,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
class VC extends ET {
  constructor(e) {
    super('string', e);
  }
  defaultValue() {
    return '';
  }
  encode(e, t) {
    return super.encode(e, $t(t));
  }
  decode(e) {
    return Rs(super.decode(e));
  }
}
class ad extends Kr {
  constructor(e, t) {
    let i = !1;
    const r = [];
    e.forEach((a) => {
      a.dynamic && (i = !0), r.push(a.type);
    });
    const s = 'tuple(' + r.join(',') + ')';
    super('tuple', s, t, i), (this.coders = e);
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((i) => {
      e.push(i.defaultValue());
    });
    const t = this.coders.reduce((i, r) => {
      const s = r.localName;
      return s && (i[s] || (i[s] = 0), i[s]++), i;
    }, {});
    return (
      this.coders.forEach((i, r) => {
        let s = i.localName;
        !s || t[s] !== 1 || (s === 'length' && (s = '_length'), e[s] == null && (e[s] = e[r]));
      }),
      Object.freeze(e)
    );
  }
  encode(e, t) {
    return wT(e, this.coders, t);
  }
  decode(e) {
    return e.coerce(this.name, AT(e, this.coders));
  }
}
const od = new D(Nl),
  zC = new RegExp(/^bytes([0-9]*)$/),
  GC = new RegExp(/^(u?int)([0-9]*)$/);
class IT {
  constructor(e) {
    j(this, 'coerceFunc', e || null);
  }
  _getCoder(e) {
    switch (e.baseType) {
      case 'address':
        return new dC(e.name);
      case 'bool':
        return new fC(e.name);
      case 'string':
        return new VC(e.name);
      case 'bytes':
        return new yC(e.name);
      case 'array':
        return new pC(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
      case 'tuple':
        return new ad(
          (e.components || []).map((i) => this._getCoder(i)),
          e.name,
        );
      case '':
        return new mC(e.name);
    }
    let t = e.type.match(GC);
    if (t) {
      let i = parseInt(t[2] || '256');
      return (i === 0 || i > 256 || i % 8 !== 0) && od.throwArgumentError('invalid ' + t[1] + ' bit length', 'param', e), new TC(i / 8, t[1] === 'int', e.name);
    }
    if (((t = e.type.match(zC)), t)) {
      let i = parseInt(t[1]);
      return (i === 0 || i > 32) && od.throwArgumentError('invalid bytes length', 'param', e), new hC(i, e.name);
    }
    return od.throwArgumentError('invalid type', 'type', e.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(e, t) {
    return new dc(e, this._getWordSize(), this.coerceFunc, t);
  }
  _getWriter() {
    return new Ty(this._getWordSize());
  }
  getDefaultValue(e) {
    const t = e.map((r) => this._getCoder(Wt.from(r)));
    return new ad(t, '_').defaultValue();
  }
  encode(e, t) {
    e.length !== t.length &&
      od.throwError('types/values length mismatch', D.errors.INVALID_ARGUMENT, {
        count: { types: e.length, values: t.length },
        value: { types: e, values: t },
      });
    const i = e.map((a) => this._getCoder(Wt.from(a))),
      r = new ad(i, '_'),
      s = this._getWriter();
    return r.encode(s, t), s.data;
  }
  decode(e, t, i) {
    const r = e.map((a) => this._getCoder(Wt.from(a)));
    return new ad(r, '_').decode(this._getReader(H(t), i));
  }
}
const OT = new IT();
function cs(n) {
  return De($t(n));
}
const kT = 'hash/5.7.0';
function m0(n) {
  n = atob(n);
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n.charCodeAt(t));
  return H(e);
}
function b0(n) {
  n = H(n);
  let e = '';
  for (let t = 0; t < n.length; t++) e += String.fromCharCode(n[t]);
  return btoa(e);
}
const qC = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      decode: m0,
      encode: b0,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
function PT(n, e) {
  e == null && (e = 1);
  const t = [],
    i = t.forEach,
    r = function (s, a) {
      i.call(s, function (o) {
        a > 0 && Array.isArray(o) ? r(o, a - 1) : t.push(o);
      });
    };
  return r(n, e), t;
}
function HC(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = n[t];
    e[i[0]] = i[1];
  }
  return e;
}
function KC(n) {
  let e = 0;
  function t() {
    return (n[e++] << 8) | n[e++];
  }
  let i = t(),
    r = 1,
    s = [0, 1];
  for (let N = 1; N < i; N++) s.push((r += t()));
  let a = t(),
    o = e;
  e += a;
  let u = 0,
    l = 0;
  function c() {
    return u == 0 && ((l = (l << 8) | n[e++]), (u = 8)), (l >> --u) & 1;
  }
  const f = 31,
    m = Math.pow(2, f),
    w = m >>> 1,
    v = w >> 1,
    T = m - 1;
  let A = 0;
  for (let N = 0; N < f; N++) A = (A << 1) | c();
  let _ = [],
    O = 0,
    B = m;
  for (;;) {
    let N = Math.floor(((A - O + 1) * r - 1) / B),
      U = 0,
      W = i;
    for (; W - U > 1; ) {
      let ue = (U + W) >>> 1;
      N < s[ue] ? (W = ue) : (U = ue);
    }
    if (U == 0) break;
    _.push(U);
    let z = O + Math.floor((B * s[U]) / r),
      Y = O + Math.floor((B * s[U + 1]) / r) - 1;
    for (; !((z ^ Y) & w); ) (A = ((A << 1) & T) | c()), (z = (z << 1) & T), (Y = ((Y << 1) & T) | 1);
    for (; z & ~Y & v; ) (A = (A & w) | ((A << 1) & (T >>> 1)) | c()), (z = (z << 1) ^ w), (Y = ((Y ^ w) << 1) | w | 1);
    (O = z), (B = 1 + Y - z);
  }
  let P = i - 4;
  return _.map((N) => {
    switch (N - P) {
      case 3:
        return P + 65792 + ((n[o++] << 16) | (n[o++] << 8) | n[o++]);
      case 2:
        return P + 256 + ((n[o++] << 8) | n[o++]);
      case 1:
        return P + n[o++];
      default:
        return N - 1;
    }
  });
}
function WC(n) {
  let e = 0;
  return () => n[e++];
}
function JC(n) {
  return WC(KC(n));
}
function QC(n) {
  return n & 1 ? ~n >> 1 : n >> 1;
}
function YC(n, e) {
  let t = Array(n);
  for (let i = 0; i < n; i++) t[i] = 1 + e();
  return t;
}
function Xg(n, e) {
  let t = Array(n);
  for (let i = 0, r = -1; i < n; i++) t[i] = r += 1 + e();
  return t;
}
function XC(n, e) {
  let t = Array(n);
  for (let i = 0, r = 0; i < n; i++) t[i] = r += QC(e());
  return t;
}
function pc(n, e) {
  let t = Xg(n(), n),
    i = n(),
    r = Xg(i, n),
    s = YC(i, n);
  for (let a = 0; a < i; a++) for (let o = 0; o < s[a]; o++) t.push(r[a] + o);
  return e ? t.map((a) => e[a]) : t;
}
function ZC(n) {
  let e = [];
  for (;;) {
    let t = n();
    if (t == 0) break;
    e.push(tM(t, n));
  }
  for (;;) {
    let t = n() - 1;
    if (t < 0) break;
    e.push(nM(t, n));
  }
  return HC(PT(e));
}
function eM(n) {
  let e = [];
  for (;;) {
    let t = n();
    if (t == 0) break;
    e.push(t);
  }
  return e;
}
function NT(n, e, t) {
  let i = Array(n)
    .fill(void 0)
    .map(() => []);
  for (let r = 0; r < e; r++) XC(n, t).forEach((s, a) => i[a].push(s));
  return i;
}
function tM(n, e) {
  let t = 1 + e(),
    i = e(),
    r = eM(e),
    s = NT(r.length, 1 + n, e);
  return PT(
    s.map((a, o) => {
      const u = a[0],
        l = a.slice(1);
      return Array(r[o])
        .fill(void 0)
        .map((c, f) => {
          let m = f * i;
          return [u + f * t, l.map((w) => w + m)];
        });
    }),
  );
}
function nM(n, e) {
  let t = 1 + e();
  return NT(t, 1 + n, e).map((r) => [r[0], r.slice(1)]);
}
function iM(n) {
  let e = pc(n).sort((i, r) => i - r);
  return t();
  function t() {
    let i = [];
    for (;;) {
      let l = pc(n, e);
      if (l.length == 0) break;
      i.push({ set: new Set(l), node: t() });
    }
    i.sort((l, c) => c.set.size - l.set.size);
    let r = n(),
      s = r % 3;
    r = (r / 3) | 0;
    let a = !!(r & 1);
    r >>= 1;
    let o = r == 1,
      u = r == 2;
    return { branches: i, valid: s, fe0f: a, save: o, check: u };
  }
}
function rM() {
  return JC(
    m0(
      'AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA==',
    ),
  );
}
const Zc = rM(),
  sM = new Set(pc(Zc)),
  aM = new Set(pc(Zc)),
  oM = ZC(Zc),
  uM = iM(Zc),
  Zg = 45,
  e2 = 95;
function DT(n) {
  return cc(n);
}
function lM(n) {
  return n.filter((e) => e != 65039);
}
function BT(n) {
  for (let e of n.split('.')) {
    let t = DT(e);
    try {
      for (let i = t.lastIndexOf(e2) - 1; i >= 0; i--) if (t[i] !== e2) throw new Error('underscore only allowed at start');
      if (t.length >= 4 && t.every((i) => i < 128) && t[2] === Zg && t[3] === Zg) throw new Error('invalid label extension');
    } catch (i) {
      throw new Error(`Invalid label "${e}": ${i.message}`);
    }
  }
  return n;
}
function dM(n) {
  return BT(cM(n, lM));
}
function cM(n, e) {
  let t = DT(n).reverse(),
    i = [];
  for (; t.length; ) {
    let r = fM(t);
    if (r) {
      i.push(...e(r));
      continue;
    }
    let s = t.pop();
    if (sM.has(s)) {
      i.push(s);
      continue;
    }
    if (aM.has(s)) continue;
    let a = oM[s];
    if (a) {
      i.push(...a);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`);
  }
  return BT(pM(String.fromCodePoint(...i)));
}
function pM(n) {
  return n.normalize('NFC');
}
function fM(n, e) {
  var t;
  let i = uM,
    r,
    s,
    a = [],
    o = n.length;
  for (e && (e.length = 0); o; ) {
    let u = n[--o];
    if (((i = (t = i.branches.find((l) => l.set.has(u))) === null || t === void 0 ? void 0 : t.node), !i)) break;
    if (i.save) s = u;
    else if (i.check && u === s) break;
    a.push(u), i.fe0f && (a.push(65039), o > 0 && n[o - 1] == 65039 && o--), i.valid && ((r = a.slice()), i.valid == 2 && r.splice(1, 1), e && e.push(...n.slice(o).reverse()), (n.length = o));
  }
  return r;
}
const yM = new D(kT),
  FT = new Uint8Array(32);
FT.fill(0);
function t2(n) {
  if (n.length === 0) throw new Error('invalid ENS name; empty component');
  return n;
}
function ep(n) {
  const e = $t(dM(n)),
    t = [];
  if (n.length === 0) return t;
  let i = 0;
  for (let r = 0; r < e.length; r++) e[r] === 46 && (t.push(t2(e.slice(i, r))), (i = r + 1));
  if (i >= e.length) throw new Error('invalid ENS name; empty component');
  return t.push(t2(e.slice(i))), t;
}
function hM(n) {
  return ep(n)
    .map((e) => Rs(e))
    .join('.');
}
function mM(n) {
  try {
    return ep(n).length !== 0;
  } catch {}
  return !1;
}
function Cu(n) {
  typeof n != 'string' && yM.throwArgumentError('invalid ENS name; not a string', 'name', n);
  let e = FT;
  const t = ep(n);
  for (; t.length; ) e = De(Ge([e, De(t.pop())]));
  return K(e);
}
function LT(n) {
  return (
    K(
      Ge(
        ep(n).map((e) => {
          if (e.length > 63) throw new Error('invalid DNS encoded entry; length exceeds 63 bytes');
          const t = new Uint8Array(e.length + 1);
          return t.set(e, 1), (t[0] = t.length - 1), t;
        }),
      ),
    ) + '00'
  );
}
const $T = `Ethereum Signed Message:
`;
function g0(n) {
  return typeof n == 'string' && (n = $t(n)), De(Ge([$t($T), $t(String(n.length)), n]));
}
var bM =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
const _t = new D(kT),
  UT = new Uint8Array(32);
UT.fill(0);
const gM = q.from(-1),
  jT = q.from(0),
  VT = q.from(1),
  vM = q.from('0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
function xM(n) {
  const e = H(n),
    t = e.length % 32;
  return t ? Cn([e, UT.slice(t)]) : K(e);
}
const TM = Le(VT.toHexString(), 32),
  wM = Le(jT.toHexString(), 32),
  n2 = {
    name: 'string',
    version: 'string',
    chainId: 'uint256',
    verifyingContract: 'address',
    salt: 'bytes32',
  },
  yf = ['name', 'version', 'chainId', 'verifyingContract', 'salt'];
function i2(n) {
  return function (e) {
    return typeof e != 'string' && _t.throwArgumentError(`invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, e), e;
  };
}
const AM = {
  name: i2('name'),
  version: i2('version'),
  chainId: function (n) {
    try {
      return q.from(n).toString();
    } catch {}
    return _t.throwArgumentError('invalid domain value for "chainId"', 'domain.chainId', n);
  },
  verifyingContract: function (n) {
    try {
      return Fe(n).toLowerCase();
    } catch {}
    return _t.throwArgumentError('invalid domain value "verifyingContract"', 'domain.verifyingContract', n);
  },
  salt: function (n) {
    try {
      const e = H(n);
      if (e.length !== 32) throw new Error('bad length');
      return K(e);
    } catch {}
    return _t.throwArgumentError('invalid domain value "salt"', 'domain.salt', n);
  },
};
function hf(n) {
  {
    const e = n.match(/^(u?)int(\d*)$/);
    if (e) {
      const t = e[1] === '',
        i = parseInt(e[2] || '256');
      (i % 8 !== 0 || i > 256 || (e[2] && e[2] !== String(i))) && _t.throwArgumentError('invalid numeric width', 'type', n);
      const r = vM.mask(t ? i - 1 : i),
        s = t ? r.add(VT).mul(gM) : jT;
      return function (a) {
        const o = q.from(a);
        return (o.lt(s) || o.gt(r)) && _t.throwArgumentError(`value out-of-bounds for ${n}`, 'value', a), Le(o.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const e = n.match(/^bytes(\d+)$/);
    if (e) {
      const t = parseInt(e[1]);
      return (
        (t === 0 || t > 32 || e[1] !== String(t)) && _t.throwArgumentError('invalid bytes width', 'type', n),
        function (i) {
          return H(i).length !== t && _t.throwArgumentError(`invalid length for ${n}`, 'value', i), xM(i);
        }
      );
    }
  }
  switch (n) {
    case 'address':
      return function (e) {
        return Le(Fe(e), 32);
      };
    case 'bool':
      return function (e) {
        return e ? TM : wM;
      };
    case 'bytes':
      return function (e) {
        return De(e);
      };
    case 'string':
      return function (e) {
        return cs(e);
      };
  }
  return null;
}
function r2(n, e) {
  return `${n}(${e.map(({ name: t, type: i }) => i + ' ' + t).join(',')})`;
}
class an {
  constructor(e) {
    j(this, 'types', Object.freeze(xs(e))), j(this, '_encoderCache', {}), j(this, '_types', {});
    const t = {},
      i = {},
      r = {};
    Object.keys(e).forEach((o) => {
      (t[o] = {}), (i[o] = []), (r[o] = {});
    });
    for (const o in e) {
      const u = {};
      e[o].forEach((l) => {
        u[l.name] && _t.throwArgumentError(`duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(o)}`, 'types', e), (u[l.name] = !0);
        const c = l.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        c === o && _t.throwArgumentError(`circular type reference to ${JSON.stringify(c)}`, 'types', e),
          !hf(c) && (i[c] || _t.throwArgumentError(`unknown type ${JSON.stringify(c)}`, 'types', e), i[c].push(o), (t[o][c] = !0));
      });
    }
    const s = Object.keys(i).filter((o) => i[o].length === 0);
    s.length === 0
      ? _t.throwArgumentError('missing primary type', 'types', e)
      : s.length > 1 && _t.throwArgumentError(`ambiguous primary types or unused types: ${s.map((o) => JSON.stringify(o)).join(', ')}`, 'types', e),
      j(this, 'primaryType', s[0]);
    function a(o, u) {
      u[o] && _t.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`, 'types', e),
        (u[o] = !0),
        Object.keys(t[o]).forEach((l) => {
          i[l] &&
            (a(l, u),
            Object.keys(u).forEach((c) => {
              r[c][l] = !0;
            }));
        }),
        delete u[o];
    }
    a(this.primaryType, {});
    for (const o in r) {
      const u = Object.keys(r[o]);
      u.sort(), (this._types[o] = r2(o, e[o]) + u.map((l) => r2(l, e[l])).join(''));
    }
  }
  getEncoder(e) {
    let t = this._encoderCache[e];
    return t || (t = this._encoderCache[e] = this._getEncoder(e)), t;
  }
  _getEncoder(e) {
    {
      const r = hf(e);
      if (r) return r;
    }
    const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (t) {
      const r = t[1],
        s = this.getEncoder(r),
        a = parseInt(t[3]);
      return (o) => {
        a >= 0 && o.length !== a && _t.throwArgumentError('array length mismatch; expected length ${ arrayLength }', 'value', o);
        let u = o.map(s);
        return this._types[r] && (u = u.map(De)), De(Cn(u));
      };
    }
    const i = this.types[e];
    if (i) {
      const r = cs(this._types[e]);
      return (s) => {
        const a = i.map(({ name: o, type: u }) => {
          const l = this.getEncoder(u)(s[o]);
          return this._types[u] ? De(l) : l;
        });
        return a.unshift(r), Cn(a);
      };
    }
    return _t.throwArgumentError(`unknown type: ${e}`, 'type', e);
  }
  encodeType(e) {
    const t = this._types[e];
    return t || _t.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, 'name', e), t;
  }
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  hashStruct(e, t) {
    return De(this.encodeData(e, t));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, t, i) {
    if (hf(e)) return i(e, t);
    const r = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (r) {
      const a = r[1],
        o = parseInt(r[3]);
      return o >= 0 && t.length !== o && _t.throwArgumentError('array length mismatch; expected length ${ arrayLength }', 'value', t), t.map((u) => this._visit(a, u, i));
    }
    const s = this.types[e];
    return s ? s.reduce((a, { name: o, type: u }) => ((a[o] = this._visit(u, t[o], i)), a), {}) : _t.throwArgumentError(`unknown type: ${e}`, 'type', e);
  }
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  static from(e) {
    return new an(e);
  }
  static getPrimaryType(e) {
    return an.from(e).primaryType;
  }
  static hashStruct(e, t, i) {
    return an.from(t).hashStruct(e, i);
  }
  static hashDomain(e) {
    const t = [];
    for (const i in e) {
      const r = n2[i];
      r || _t.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(i)}`, 'domain', e), t.push({ name: i, type: r });
    }
    return t.sort((i, r) => yf.indexOf(i.name) - yf.indexOf(r.name)), an.hashStruct('EIP712Domain', { EIP712Domain: t }, e);
  }
  static encode(e, t, i) {
    return Cn(['0x1901', an.hashDomain(e), an.from(t).hash(i)]);
  }
  static hash(e, t, i) {
    return De(an.encode(e, t, i));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(e, t, i, r) {
    return bM(this, void 0, void 0, function* () {
      e = Gt(e);
      const s = {};
      e.verifyingContract && !Me(e.verifyingContract, 20) && (s[e.verifyingContract] = '0x');
      const a = an.from(t);
      a.visit(i, (o, u) => (o === 'address' && !Me(u, 20) && (s[u] = '0x'), u));
      for (const o in s) s[o] = yield r(o);
      return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), (i = a.visit(i, (o, u) => (o === 'address' && s[u] ? s[u] : u))), { domain: e, value: i };
    });
  }
  static getPayload(e, t, i) {
    an.hashDomain(e);
    const r = {},
      s = [];
    yf.forEach((u) => {
      const l = e[u];
      l != null && ((r[u] = AM[u](l)), s.push({ name: u, type: n2[u] }));
    });
    const a = an.from(t),
      o = Gt(t);
    return (
      o.EIP712Domain ? _t.throwArgumentError('types must not contain EIP712Domain type', 'types.EIP712Domain', t) : (o.EIP712Domain = s),
      a.encode(i),
      {
        types: o,
        domain: r,
        primaryType: a.primaryType,
        message: a.visit(i, (u, l) => {
          if (u.match(/^bytes(\d*)/)) return K(H(l));
          if (u.match(/^u?int/)) return q.from(l).toString();
          switch (u) {
            case 'address':
              return l.toLowerCase();
            case 'bool':
              return !!l;
            case 'string':
              return typeof l != 'string' && _t.throwArgumentError('invalid string', 'value', l), l;
          }
          return _t.throwArgumentError('unsupported type', 'type', u);
        }),
      }
    );
  }
}
const EM = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        _TypedDataEncoder: an,
        dnsEncode: LT,
        ensNormalize: hM,
        hashMessage: g0,
        id: cs,
        isValidName: mM,
        messagePrefix: $T,
        namehash: Cu,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Mt = new D(Nl);
class zT extends _s {}
class GT extends _s {}
class SM extends _s {}
class fc extends _s {
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const CM = {
  '0x08c379a0': { signature: 'Error(string)', name: 'Error', inputs: ['string'], reason: !0 },
  '0x4e487b71': { signature: 'Panic(uint256)', name: 'Panic', inputs: ['uint256'] },
};
function s2(n, e) {
  const t = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
  return (t.error = e), t;
}
class Ey {
  constructor(e) {
    let t = [];
    typeof e == 'string' ? (t = JSON.parse(e)) : (t = e),
      j(
        this,
        'fragments',
        t.map((i) => Ki.from(i)).filter((i) => i != null),
      ),
      j(this, '_abiCoder', Oi(new.target, 'getAbiCoder')()),
      j(this, 'functions', {}),
      j(this, 'errors', {}),
      j(this, 'events', {}),
      j(this, 'structs', {}),
      this.fragments.forEach((i) => {
        let r = null;
        switch (i.type) {
          case 'constructor':
            if (this.deploy) {
              Mt.warn('duplicate definition - constructor');
              return;
            }
            j(this, 'deploy', i);
            return;
          case 'function':
            r = this.functions;
            break;
          case 'event':
            r = this.events;
            break;
          case 'error':
            r = this.errors;
            break;
          default:
            return;
        }
        let s = i.format();
        if (r[s]) {
          Mt.warn('duplicate definition - ' + s);
          return;
        }
        r[s] = i;
      }),
      this.deploy ||
        j(
          this,
          'deploy',
          Mi.from({
            payable: !1,
            type: 'constructor',
          }),
        ),
      j(this, '_isInterface', !0);
  }
  format(e) {
    e || (e = Oe.full), e === Oe.sighash && Mt.throwArgumentError('interface does not support formatting sighash', 'format', e);
    const t = this.fragments.map((i) => i.format(e));
    return e === Oe.json ? JSON.stringify(t.map((i) => JSON.parse(i))) : t;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return OT;
  }
  static getAddress(e) {
    return Fe(e);
  }
  static getSighash(e) {
    return Lt(cs(e.format()), 0, 4);
  }
  static getEventTopic(e) {
    return cs(e.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(e) {
    if (Me(e)) {
      for (const i in this.functions) if (e === this.getSighash(i)) return this.functions[i];
      Mt.throwArgumentError('no matching function', 'sighash', e);
    }
    if (e.indexOf('(') === -1) {
      const i = e.trim(),
        r = Object.keys(this.functions).filter(
          (s) =>
            s.split(
              '(',
              /* fix:) */
            )[0] === i,
        );
      return r.length === 0 ? Mt.throwArgumentError('no matching function', 'name', i) : r.length > 1 && Mt.throwArgumentError('multiple matching functions', 'name', i), this.functions[r[0]];
    }
    const t = this.functions[_i.fromString(e).format()];
    return t || Mt.throwArgumentError('no matching function', 'signature', e), t;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(e) {
    if (Me(e)) {
      const i = e.toLowerCase();
      for (const r in this.events) if (i === this.getEventTopic(r)) return this.events[r];
      Mt.throwArgumentError('no matching event', 'topichash', i);
    }
    if (e.indexOf('(') === -1) {
      const i = e.trim(),
        r = Object.keys(this.events).filter(
          (s) =>
            s.split(
              '(',
              /* fix:) */
            )[0] === i,
        );
      return r.length === 0 ? Mt.throwArgumentError('no matching event', 'name', i) : r.length > 1 && Mt.throwArgumentError('multiple matching events', 'name', i), this.events[r[0]];
    }
    const t = this.events[Hi.fromString(e).format()];
    return t || Mt.throwArgumentError('no matching event', 'signature', e), t;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(e) {
    if (Me(e)) {
      const i = Oi(this.constructor, 'getSighash');
      for (const r in this.errors) {
        const s = this.errors[r];
        if (e === i(s)) return this.errors[r];
      }
      Mt.throwArgumentError('no matching error', 'sighash', e);
    }
    if (e.indexOf('(') === -1) {
      const i = e.trim(),
        r = Object.keys(this.errors).filter(
          (s) =>
            s.split(
              '(',
              /* fix:) */
            )[0] === i,
        );
      return r.length === 0 ? Mt.throwArgumentError('no matching error', 'name', i) : r.length > 1 && Mt.throwArgumentError('multiple matching errors', 'name', i), this.errors[r[0]];
    }
    const t = this.errors[_i.fromString(e).format()];
    return t || Mt.throwArgumentError('no matching error', 'signature', e), t;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(e) {
    if (typeof e == 'string')
      try {
        e = this.getFunction(e);
      } catch (t) {
        try {
          e = this.getError(e);
        } catch {
          throw t;
        }
      }
    return Oi(this.constructor, 'getSighash')(e);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(e) {
    return typeof e == 'string' && (e = this.getEvent(e)), Oi(this.constructor, 'getEventTopic')(e);
  }
  _decodeParams(e, t) {
    return this._abiCoder.decode(e, t);
  }
  _encodeParams(e, t) {
    return this._abiCoder.encode(e, t);
  }
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  decodeErrorResult(e, t) {
    typeof e == 'string' && (e = this.getError(e));
    const i = H(t);
    return K(i.slice(0, 4)) !== this.getSighash(e) && Mt.throwArgumentError(`data signature does not match error ${e.name}.`, 'data', K(i)), this._decodeParams(e.inputs, i.slice(4));
  }
  encodeErrorResult(e, t) {
    return typeof e == 'string' && (e = this.getError(e)), K(Ge([this.getSighash(e), this._encodeParams(e.inputs, t || [])]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(e, t) {
    typeof e == 'string' && (e = this.getFunction(e));
    const i = H(t);
    return K(i.slice(0, 4)) !== this.getSighash(e) && Mt.throwArgumentError(`data signature does not match function ${e.name}.`, 'data', K(i)), this._decodeParams(e.inputs, i.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(e, t) {
    return typeof e == 'string' && (e = this.getFunction(e)), K(Ge([this.getSighash(e), this._encodeParams(e.inputs, t || [])]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(e, t) {
    typeof e == 'string' && (e = this.getFunction(e));
    let i = H(t),
      r = null,
      s = '',
      a = null,
      o = null,
      u = null;
    switch (i.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(e.outputs, i);
        } catch {}
        break;
      case 4: {
        const l = K(i.slice(0, 4)),
          c = CM[l];
        if (c)
          (a = this._abiCoder.decode(c.inputs, i.slice(4))),
            (o = c.name),
            (u = c.signature),
            c.reason && (r = a[0]),
            o === 'Error'
              ? (s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(a[0])}`)
              : o === 'Panic' && (s = `; VM Exception while processing transaction: reverted with panic code ${a[0]}`);
        else
          try {
            const f = this.getError(l);
            (a = this._abiCoder.decode(f.inputs, i.slice(4))), (o = f.name), (u = f.format());
          } catch {}
        break;
      }
    }
    return Mt.throwError('call revert exception' + s, D.errors.CALL_EXCEPTION, {
      method: e.format(),
      data: K(t),
      errorArgs: a,
      errorName: o,
      errorSignature: u,
      reason: r,
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(e, t) {
    return typeof e == 'string' && (e = this.getFunction(e)), K(this._abiCoder.encode(e.outputs, t || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, t) {
    typeof e == 'string' && (e = this.getEvent(e)),
      t.length > e.inputs.length &&
        Mt.throwError('too many arguments for ' + e.format(), D.errors.UNEXPECTED_ARGUMENT, {
          argument: 'values',
          value: t,
        });
    let i = [];
    e.anonymous || i.push(this.getEventTopic(e));
    const r = (s, a) =>
      s.type === 'string'
        ? cs(a)
        : s.type === 'bytes'
        ? De(K(a))
        : (s.type === 'bool' && typeof a == 'boolean' && (a = a ? '0x01' : '0x00'),
          s.type.match(/^u?int/) && (a = q.from(a).toHexString()),
          s.type === 'address' && this._abiCoder.encode(['address'], [a]),
          Le(K(a), 32));
    for (
      t.forEach((s, a) => {
        let o = e.inputs[a];
        if (!o.indexed) {
          s != null && Mt.throwArgumentError('cannot filter non-indexed parameters; must be null', 'contract.' + o.name, s);
          return;
        }
        s == null
          ? i.push(null)
          : o.baseType === 'array' || o.baseType === 'tuple'
          ? Mt.throwArgumentError('filtering with tuples or arrays not supported', 'contract.' + o.name, s)
          : Array.isArray(s)
          ? i.push(s.map((u) => r(o, u)))
          : i.push(r(o, s));
      });
      i.length && i[i.length - 1] === null;

    )
      i.pop();
    return i;
  }
  encodeEventLog(e, t) {
    typeof e == 'string' && (e = this.getEvent(e));
    const i = [],
      r = [],
      s = [];
    return (
      e.anonymous || i.push(this.getEventTopic(e)),
      t.length !== e.inputs.length && Mt.throwArgumentError('event arguments/values mismatch', 'values', t),
      e.inputs.forEach((a, o) => {
        const u = t[o];
        if (a.indexed)
          if (a.type === 'string') i.push(cs(u));
          else if (a.type === 'bytes') i.push(De(u));
          else {
            if (a.baseType === 'tuple' || a.baseType === 'array') throw new Error('not implemented');
            i.push(this._abiCoder.encode([a.type], [u]));
          }
        else r.push(a), s.push(u);
      }),
      {
        data: this._abiCoder.encode(r, s),
        topics: i,
      }
    );
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, t, i) {
    if ((typeof e == 'string' && (e = this.getEvent(e)), i != null && !e.anonymous)) {
      let m = this.getEventTopic(e);
      (!Me(i[0], 32) || i[0].toLowerCase() !== m) && Mt.throwError('fragment/topic mismatch', D.errors.INVALID_ARGUMENT, { argument: 'topics[0]', expected: m, value: i[0] }), (i = i.slice(1));
    }
    let r = [],
      s = [],
      a = [];
    e.inputs.forEach((m, w) => {
      m.indexed
        ? m.type === 'string' || m.type === 'bytes' || m.baseType === 'tuple' || m.baseType === 'array'
          ? (r.push(Wt.fromObject({ type: 'bytes32', name: m.name })), a.push(!0))
          : (r.push(m), a.push(!1))
        : (s.push(m), a.push(!1));
    });
    let o = i != null ? this._abiCoder.decode(r, Ge(i)) : null,
      u = this._abiCoder.decode(s, t, !0),
      l = [],
      c = 0,
      f = 0;
    e.inputs.forEach((m, w) => {
      if (m.indexed)
        if (o == null) l[w] = new fc({ _isIndexed: !0, hash: null });
        else if (a[w]) l[w] = new fc({ _isIndexed: !0, hash: o[f++] });
        else
          try {
            l[w] = o[f++];
          } catch (v) {
            l[w] = v;
          }
      else
        try {
          l[w] = u[c++];
        } catch (v) {
          l[w] = v;
        }
      if (m.name && l[m.name] == null) {
        const v = l[w];
        v instanceof Error
          ? Object.defineProperty(l, m.name, {
              enumerable: !0,
              get: () => {
                throw s2(`property ${JSON.stringify(m.name)}`, v);
              },
            })
          : (l[m.name] = v);
      }
    });
    for (let m = 0; m < l.length; m++) {
      const w = l[m];
      w instanceof Error &&
        Object.defineProperty(l, m, {
          enumerable: !0,
          get: () => {
            throw s2(`index ${m}`, w);
          },
        });
    }
    return Object.freeze(l);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(e) {
    let t = this.getFunction(e.data.substring(0, 10).toLowerCase());
    return t
      ? new GT({
          args: this._abiCoder.decode(t.inputs, '0x' + e.data.substring(10)),
          functionFragment: t,
          name: t.name,
          signature: t.format(),
          sighash: this.getSighash(t),
          value: q.from(e.value || '0'),
        })
      : null;
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(e) {
    let t = this.getEvent(e.topics[0]);
    return !t || t.anonymous
      ? null
      : new zT({
          eventFragment: t,
          name: t.name,
          signature: t.format(),
          topic: this.getEventTopic(t),
          args: this.decodeEventLog(t, e.data, e.topics),
        });
  }
  parseError(e) {
    const t = K(e);
    let i = this.getError(t.substring(0, 10).toLowerCase());
    return i
      ? new SM({
          args: this._abiCoder.decode(i.inputs, '0x' + t.substring(10)),
          errorFragment: i,
          name: i.name,
          signature: i.format(),
          sighash: this.getSighash(i),
        })
      : null;
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(e) {
    return !!(e && e._isInterface);
  }
}
const MM = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        AbiCoder: IT,
        ConstructorFragment: Mi,
        ErrorFragment: wr,
        EventFragment: Hi,
        FormatTypes: Oe,
        Fragment: Ki,
        FunctionFragment: _i,
        Indexed: fc,
        Interface: Ey,
        LogDescription: zT,
        ParamType: Wt,
        TransactionDescription: GT,
        checkResultErrors: fT,
        defaultAbiCoder: OT,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  _M = 'abstract-provider/5.7.0';
var RM =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
const IM = new D(_M);
class OM extends _s {
  static isForkEvent(e) {
    return !!(e && e._isForkEvent);
  }
}
let v0 = class qT {
  constructor() {
    IM.checkAbstract(new.target, qT), j(this, '_isProvider', !0);
  }
  getFeeData() {
    return RM(this, void 0, void 0, function* () {
      const { block: e, gasPrice: t } = yield Ot({
        block: this.getBlock('latest'),
        gasPrice: this.getGasPrice().catch((a) => null),
      });
      let i = null,
        r = null,
        s = null;
      return (
        e && e.baseFeePerGas && ((i = e.baseFeePerGas), (s = q.from('1500000000')), (r = e.baseFeePerGas.mul(2).add(s))),
        { lastBaseFeePerGas: i, maxFeePerGas: r, maxPriorityFeePerGas: s, gasPrice: t }
      );
    });
  }
  // Alias for "on"
  addListener(e, t) {
    return this.on(e, t);
  }
  // Alias for "off"
  removeListener(e, t) {
    return this.off(e, t);
  }
  static isProvider(e) {
    return !!(e && e._isProvider);
  }
};
const kM = 'abstract-signer/5.7.0';
var Ti =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
const oi = new D(kM),
  PM = ['accessList', 'ccipReadEnabled', 'chainId', 'customData', 'data', 'from', 'gasLimit', 'gasPrice', 'maxFeePerGas', 'maxPriorityFeePerGas', 'nonce', 'to', 'type', 'value'],
  NM = [D.errors.INSUFFICIENT_FUNDS, D.errors.NONCE_EXPIRED, D.errors.REPLACEMENT_UNDERPRICED];
class Fa {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    oi.checkAbstract(new.target, Fa), j(this, '_isSigner', !0);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(e) {
    return Ti(this, void 0, void 0, function* () {
      return this._checkProvider('getBalance'), yield this.provider.getBalance(this.getAddress(), e);
    });
  }
  getTransactionCount(e) {
    return Ti(this, void 0, void 0, function* () {
      return this._checkProvider('getTransactionCount'), yield this.provider.getTransactionCount(this.getAddress(), e);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(e) {
    return Ti(this, void 0, void 0, function* () {
      this._checkProvider('estimateGas');
      const t = yield Ot(this.checkTransaction(e));
      return yield this.provider.estimateGas(t);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(e, t) {
    return Ti(this, void 0, void 0, function* () {
      this._checkProvider('call');
      const i = yield Ot(this.checkTransaction(e));
      return yield this.provider.call(i, t);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(e) {
    return Ti(this, void 0, void 0, function* () {
      this._checkProvider('sendTransaction');
      const t = yield this.populateTransaction(e),
        i = yield this.signTransaction(t);
      return yield this.provider.sendTransaction(i);
    });
  }
  getChainId() {
    return Ti(this, void 0, void 0, function* () {
      return this._checkProvider('getChainId'), (yield this.provider.getNetwork()).chainId;
    });
  }
  getGasPrice() {
    return Ti(this, void 0, void 0, function* () {
      return this._checkProvider('getGasPrice'), yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return Ti(this, void 0, void 0, function* () {
      return this._checkProvider('getFeeData'), yield this.provider.getFeeData();
    });
  }
  resolveName(e) {
    return Ti(this, void 0, void 0, function* () {
      return this._checkProvider('resolveName'), yield this.provider.resolveName(e);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(e) {
    for (const i in e) PM.indexOf(i) === -1 && oi.throwArgumentError('invalid transaction key: ' + i, 'transaction', e);
    const t = Gt(e);
    return (
      t.from == null
        ? (t.from = this.getAddress())
        : (t.from = Promise.all([Promise.resolve(t.from), this.getAddress()]).then(
            (i) => (i[0].toLowerCase() !== i[1].toLowerCase() && oi.throwArgumentError('from address mismatch', 'transaction', e), i[0]),
          )),
      t
    );
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(e) {
    return Ti(this, void 0, void 0, function* () {
      const t = yield Ot(this.checkTransaction(e));
      t.to != null &&
        ((t.to = Promise.resolve(t.to).then((r) =>
          Ti(this, void 0, void 0, function* () {
            if (r == null) return null;
            const s = yield this.resolveName(r);
            return s == null && oi.throwArgumentError('provided ENS name resolves to null', 'tx.to', r), s;
          }),
        )),
        t.to.catch((r) => {}));
      const i = t.maxFeePerGas != null || t.maxPriorityFeePerGas != null;
      if (
        (t.gasPrice != null && (t.type === 2 || i)
          ? oi.throwArgumentError('eip-1559 transaction do not support gasPrice', 'transaction', e)
          : (t.type === 0 || t.type === 1) && i && oi.throwArgumentError('pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas', 'transaction', e),
        (t.type === 2 || t.type == null) && t.maxFeePerGas != null && t.maxPriorityFeePerGas != null)
      )
        t.type = 2;
      else if (t.type === 0 || t.type === 1) t.gasPrice == null && (t.gasPrice = this.getGasPrice());
      else {
        const r = yield this.getFeeData();
        if (t.type == null)
          if (r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
            if (((t.type = 2), t.gasPrice != null)) {
              const s = t.gasPrice;
              delete t.gasPrice, (t.maxFeePerGas = s), (t.maxPriorityFeePerGas = s);
            } else t.maxFeePerGas == null && (t.maxFeePerGas = r.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = r.maxPriorityFeePerGas);
          else
            r.gasPrice != null
              ? (i &&
                  oi.throwError('network does not support EIP-1559', D.errors.UNSUPPORTED_OPERATION, {
                    operation: 'populateTransaction',
                  }),
                t.gasPrice == null && (t.gasPrice = r.gasPrice),
                (t.type = 0))
              : oi.throwError('failed to get consistent fee data', D.errors.UNSUPPORTED_OPERATION, {
                  operation: 'signer.getFeeData',
                });
        else t.type === 2 && (t.maxFeePerGas == null && (t.maxFeePerGas = r.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = r.maxPriorityFeePerGas));
      }
      return (
        t.nonce == null && (t.nonce = this.getTransactionCount('pending')),
        t.gasLimit == null &&
          (t.gasLimit = this.estimateGas(t).catch((r) => {
            if (NM.indexOf(r.code) >= 0) throw r;
            return oi.throwError('cannot estimate gas; transaction may fail or may require manual gas limit', D.errors.UNPREDICTABLE_GAS_LIMIT, {
              error: r,
              tx: t,
            });
          })),
        t.chainId == null
          ? (t.chainId = this.getChainId())
          : (t.chainId = Promise.all([Promise.resolve(t.chainId), this.getChainId()]).then(
              (r) => (r[1] !== 0 && r[0] !== r[1] && oi.throwArgumentError('chainId address mismatch', 'transaction', e), r[0]),
            )),
        yield Ot(t)
      );
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(e) {
    this.provider ||
      oi.throwError('missing provider', D.errors.UNSUPPORTED_OPERATION, {
        operation: e || '_checkProvider',
      });
  }
  static isSigner(e) {
    return !!(e && e._isSigner);
  }
}
class x0 extends Fa {
  constructor(e, t) {
    super(), j(this, 'address', e), j(this, 'provider', t || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(e, t) {
    return Promise.resolve().then(() => {
      oi.throwError(e, D.errors.UNSUPPORTED_OPERATION, { operation: t });
    });
  }
  signMessage(e) {
    return this._fail('VoidSigner cannot sign messages', 'signMessage');
  }
  signTransaction(e) {
    return this._fail('VoidSigner cannot sign transactions', 'signTransaction');
  }
  _signTypedData(e, t, i) {
    return this._fail('VoidSigner cannot sign typed data', 'signTypedData');
  }
  connect(e) {
    return new x0(this.address, e);
  }
}
var Sn = {},
  Ee = {},
  Bl = HT;
function HT(n, e) {
  if (!n) throw new Error(e || 'Assertion failed');
}
HT.equal = function (e, t, i) {
  if (e != t) throw new Error(i || 'Assertion failed: ' + e + ' != ' + t);
};
var Sy = {},
  a2 = {
    get exports() {
      return Sy;
    },
    set exports(n) {
      Sy = n;
    },
  };
typeof Object.create == 'function'
  ? (a2.exports = function (e, t) {
      t &&
        ((e.super_ = t),
        (e.prototype = Object.create(t.prototype, {
          constructor: {
            value: e,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })));
    })
  : (a2.exports = function (e, t) {
      if (t) {
        e.super_ = t;
        var i = function () {};
        (i.prototype = t.prototype), (e.prototype = new i()), (e.prototype.constructor = e);
      }
    });
var DM = Bl,
  BM = Sy;
Ee.inherits = BM;
function FM(n, e) {
  return (n.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= n.length ? !1 : (n.charCodeAt(e + 1) & 64512) === 56320;
}
function LM(n, e) {
  if (Array.isArray(n)) return n.slice();
  if (!n) return [];
  var t = [];
  if (typeof n == 'string')
    if (e) {
      if (e === 'hex') for (n = n.replace(/[^a-z0-9]+/gi, ''), n.length % 2 !== 0 && (n = '0' + n), r = 0; r < n.length; r += 2) t.push(parseInt(n[r] + n[r + 1], 16));
    } else
      for (var i = 0, r = 0; r < n.length; r++) {
        var s = n.charCodeAt(r);
        s < 128
          ? (t[i++] = s)
          : s < 2048
          ? ((t[i++] = (s >> 6) | 192), (t[i++] = (s & 63) | 128))
          : FM(n, r)
          ? ((s = 65536 + ((s & 1023) << 10) + (n.charCodeAt(++r) & 1023)), (t[i++] = (s >> 18) | 240), (t[i++] = ((s >> 12) & 63) | 128), (t[i++] = ((s >> 6) & 63) | 128), (t[i++] = (s & 63) | 128))
          : ((t[i++] = (s >> 12) | 224), (t[i++] = ((s >> 6) & 63) | 128), (t[i++] = (s & 63) | 128));
      }
  else for (r = 0; r < n.length; r++) t[r] = n[r] | 0;
  return t;
}
Ee.toArray = LM;
function $M(n) {
  for (var e = '', t = 0; t < n.length; t++) e += WT(n[t].toString(16));
  return e;
}
Ee.toHex = $M;
function KT(n) {
  var e = (n >>> 24) | ((n >>> 8) & 65280) | ((n << 8) & 16711680) | ((n & 255) << 24);
  return e >>> 0;
}
Ee.htonl = KT;
function UM(n, e) {
  for (var t = '', i = 0; i < n.length; i++) {
    var r = n[i];
    e === 'little' && (r = KT(r)), (t += JT(r.toString(16)));
  }
  return t;
}
Ee.toHex32 = UM;
function WT(n) {
  return n.length === 1 ? '0' + n : n;
}
Ee.zero2 = WT;
function JT(n) {
  return n.length === 7
    ? '0' + n
    : n.length === 6
    ? '00' + n
    : n.length === 5
    ? '000' + n
    : n.length === 4
    ? '0000' + n
    : n.length === 3
    ? '00000' + n
    : n.length === 2
    ? '000000' + n
    : n.length === 1
    ? '0000000' + n
    : n;
}
Ee.zero8 = JT;
function jM(n, e, t, i) {
  var r = t - e;
  DM(r % 4 === 0);
  for (var s = new Array(r / 4), a = 0, o = e; a < s.length; a++, o += 4) {
    var u;
    i === 'big' ? (u = (n[o] << 24) | (n[o + 1] << 16) | (n[o + 2] << 8) | n[o + 3]) : (u = (n[o + 3] << 24) | (n[o + 2] << 16) | (n[o + 1] << 8) | n[o]), (s[a] = u >>> 0);
  }
  return s;
}
Ee.join32 = jM;
function VM(n, e) {
  for (var t = new Array(n.length * 4), i = 0, r = 0; i < n.length; i++, r += 4) {
    var s = n[i];
    e === 'big'
      ? ((t[r] = s >>> 24), (t[r + 1] = (s >>> 16) & 255), (t[r + 2] = (s >>> 8) & 255), (t[r + 3] = s & 255))
      : ((t[r + 3] = s >>> 24), (t[r + 2] = (s >>> 16) & 255), (t[r + 1] = (s >>> 8) & 255), (t[r] = s & 255));
  }
  return t;
}
Ee.split32 = VM;
function zM(n, e) {
  return (n >>> e) | (n << (32 - e));
}
Ee.rotr32 = zM;
function GM(n, e) {
  return (n << e) | (n >>> (32 - e));
}
Ee.rotl32 = GM;
function qM(n, e) {
  return (n + e) >>> 0;
}
Ee.sum32 = qM;
function HM(n, e, t) {
  return (n + e + t) >>> 0;
}
Ee.sum32_3 = HM;
function KM(n, e, t, i) {
  return (n + e + t + i) >>> 0;
}
Ee.sum32_4 = KM;
function WM(n, e, t, i, r) {
  return (n + e + t + i + r) >>> 0;
}
Ee.sum32_5 = WM;
function JM(n, e, t, i) {
  var r = n[e],
    s = n[e + 1],
    a = (i + s) >>> 0,
    o = (a < i ? 1 : 0) + t + r;
  (n[e] = o >>> 0), (n[e + 1] = a);
}
Ee.sum64 = JM;
function QM(n, e, t, i) {
  var r = (e + i) >>> 0,
    s = (r < e ? 1 : 0) + n + t;
  return s >>> 0;
}
Ee.sum64_hi = QM;
function YM(n, e, t, i) {
  var r = e + i;
  return r >>> 0;
}
Ee.sum64_lo = YM;
function XM(n, e, t, i, r, s, a, o) {
  var u = 0,
    l = e;
  (l = (l + i) >>> 0), (u += l < e ? 1 : 0), (l = (l + s) >>> 0), (u += l < s ? 1 : 0), (l = (l + o) >>> 0), (u += l < o ? 1 : 0);
  var c = n + t + r + a + u;
  return c >>> 0;
}
Ee.sum64_4_hi = XM;
function ZM(n, e, t, i, r, s, a, o) {
  var u = e + i + s + o;
  return u >>> 0;
}
Ee.sum64_4_lo = ZM;
function e_(n, e, t, i, r, s, a, o, u, l) {
  var c = 0,
    f = e;
  (f = (f + i) >>> 0), (c += f < e ? 1 : 0), (f = (f + s) >>> 0), (c += f < s ? 1 : 0), (f = (f + o) >>> 0), (c += f < o ? 1 : 0), (f = (f + l) >>> 0), (c += f < l ? 1 : 0);
  var m = n + t + r + a + u + c;
  return m >>> 0;
}
Ee.sum64_5_hi = e_;
function t_(n, e, t, i, r, s, a, o, u, l) {
  var c = e + i + s + o + l;
  return c >>> 0;
}
Ee.sum64_5_lo = t_;
function n_(n, e, t) {
  var i = (e << (32 - t)) | (n >>> t);
  return i >>> 0;
}
Ee.rotr64_hi = n_;
function i_(n, e, t) {
  var i = (n << (32 - t)) | (e >>> t);
  return i >>> 0;
}
Ee.rotr64_lo = i_;
function r_(n, e, t) {
  return n >>> t;
}
Ee.shr64_hi = r_;
function s_(n, e, t) {
  var i = (n << (32 - t)) | (e >>> t);
  return i >>> 0;
}
Ee.shr64_lo = s_;
var Vo = {},
  o2 = Ee,
  a_ = Bl;
function tp() {
  (this.pending = null),
    (this.pendingTotal = 0),
    (this.blockSize = this.constructor.blockSize),
    (this.outSize = this.constructor.outSize),
    (this.hmacStrength = this.constructor.hmacStrength),
    (this.padLength = this.constructor.padLength / 8),
    (this.endian = 'big'),
    (this._delta8 = this.blockSize / 8),
    (this._delta32 = this.blockSize / 32);
}
Vo.BlockHash = tp;
tp.prototype.update = function (e, t) {
  if (((e = o2.toArray(e, t)), this.pending ? (this.pending = this.pending.concat(e)) : (this.pending = e), (this.pendingTotal += e.length), this.pending.length >= this._delta8)) {
    e = this.pending;
    var i = e.length % this._delta8;
    (this.pending = e.slice(e.length - i, e.length)), this.pending.length === 0 && (this.pending = null), (e = o2.join32(e, 0, e.length - i, this.endian));
    for (var r = 0; r < e.length; r += this._delta32) this._update(e, r, r + this._delta32);
  }
  return this;
};
tp.prototype.digest = function (e) {
  return this.update(this._pad()), a_(this.pending === null), this._digest(e);
};
tp.prototype._pad = function () {
  var e = this.pendingTotal,
    t = this._delta8,
    i = t - ((e + this.padLength) % t),
    r = new Array(i + this.padLength);
  r[0] = 128;
  for (var s = 1; s < i; s++) r[s] = 0;
  if (((e <<= 3), this.endian === 'big')) {
    for (var a = 8; a < this.padLength; a++) r[s++] = 0;
    (r[s++] = 0), (r[s++] = 0), (r[s++] = 0), (r[s++] = 0), (r[s++] = (e >>> 24) & 255), (r[s++] = (e >>> 16) & 255), (r[s++] = (e >>> 8) & 255), (r[s++] = e & 255);
  } else
    for (r[s++] = e & 255, r[s++] = (e >>> 8) & 255, r[s++] = (e >>> 16) & 255, r[s++] = (e >>> 24) & 255, r[s++] = 0, r[s++] = 0, r[s++] = 0, r[s++] = 0, a = 8; a < this.padLength; a++) r[s++] = 0;
  return r;
};
var zo = {},
  dr = {},
  o_ = Ee,
  Yi = o_.rotr32;
function u_(n, e, t, i) {
  if (n === 0) return QT(e, t, i);
  if (n === 1 || n === 3) return XT(e, t, i);
  if (n === 2) return YT(e, t, i);
}
dr.ft_1 = u_;
function QT(n, e, t) {
  return (n & e) ^ (~n & t);
}
dr.ch32 = QT;
function YT(n, e, t) {
  return (n & e) ^ (n & t) ^ (e & t);
}
dr.maj32 = YT;
function XT(n, e, t) {
  return n ^ e ^ t;
}
dr.p32 = XT;
function l_(n) {
  return Yi(n, 2) ^ Yi(n, 13) ^ Yi(n, 22);
}
dr.s0_256 = l_;
function d_(n) {
  return Yi(n, 6) ^ Yi(n, 11) ^ Yi(n, 25);
}
dr.s1_256 = d_;
function c_(n) {
  return Yi(n, 7) ^ Yi(n, 18) ^ (n >>> 3);
}
dr.g0_256 = c_;
function p_(n) {
  return Yi(n, 17) ^ Yi(n, 19) ^ (n >>> 10);
}
dr.g1_256 = p_;
var xo = Ee,
  f_ = Vo,
  y_ = dr,
  mf = xo.rotl32,
  Zo = xo.sum32,
  h_ = xo.sum32_5,
  m_ = y_.ft_1,
  ZT = f_.BlockHash,
  b_ = [1518500249, 1859775393, 2400959708, 3395469782];
function rr() {
  if (!(this instanceof rr)) return new rr();
  ZT.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.W = new Array(80));
}
xo.inherits(rr, ZT);
var g_ = rr;
rr.blockSize = 512;
rr.outSize = 160;
rr.hmacStrength = 80;
rr.padLength = 64;
rr.prototype._update = function (e, t) {
  for (var i = this.W, r = 0; r < 16; r++) i[r] = e[t + r];
  for (; r < i.length; r++) i[r] = mf(i[r - 3] ^ i[r - 8] ^ i[r - 14] ^ i[r - 16], 1);
  var s = this.h[0],
    a = this.h[1],
    o = this.h[2],
    u = this.h[3],
    l = this.h[4];
  for (r = 0; r < i.length; r++) {
    var c = ~~(r / 20),
      f = h_(mf(s, 5), m_(c, a, o, u), l, i[r], b_[c]);
    (l = u), (u = o), (o = mf(a, 30)), (a = s), (s = f);
  }
  (this.h[0] = Zo(this.h[0], s)), (this.h[1] = Zo(this.h[1], a)), (this.h[2] = Zo(this.h[2], o)), (this.h[3] = Zo(this.h[3], u)), (this.h[4] = Zo(this.h[4], l));
};
rr.prototype._digest = function (e) {
  return e === 'hex' ? xo.toHex32(this.h, 'big') : xo.split32(this.h, 'big');
};
var To = Ee,
  v_ = Vo,
  Go = dr,
  x_ = Bl,
  wi = To.sum32,
  T_ = To.sum32_4,
  w_ = To.sum32_5,
  A_ = Go.ch32,
  E_ = Go.maj32,
  S_ = Go.s0_256,
  C_ = Go.s1_256,
  M_ = Go.g0_256,
  __ = Go.g1_256,
  e6 = v_.BlockHash,
  R_ = [
    1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
    3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
    666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
    430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
  ];
function sr() {
  if (!(this instanceof sr)) return new sr();
  e6.call(this), (this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]), (this.k = R_), (this.W = new Array(64));
}
To.inherits(sr, e6);
var t6 = sr;
sr.blockSize = 512;
sr.outSize = 256;
sr.hmacStrength = 192;
sr.padLength = 64;
sr.prototype._update = function (e, t) {
  for (var i = this.W, r = 0; r < 16; r++) i[r] = e[t + r];
  for (; r < i.length; r++) i[r] = T_(__(i[r - 2]), i[r - 7], M_(i[r - 15]), i[r - 16]);
  var s = this.h[0],
    a = this.h[1],
    o = this.h[2],
    u = this.h[3],
    l = this.h[4],
    c = this.h[5],
    f = this.h[6],
    m = this.h[7];
  for (x_(this.k.length === i.length), r = 0; r < i.length; r++) {
    var w = w_(m, C_(l), A_(l, c, f), this.k[r], i[r]),
      v = wi(S_(s), E_(s, a, o));
    (m = f), (f = c), (c = l), (l = wi(u, w)), (u = o), (o = a), (a = s), (s = wi(w, v));
  }
  (this.h[0] = wi(this.h[0], s)),
    (this.h[1] = wi(this.h[1], a)),
    (this.h[2] = wi(this.h[2], o)),
    (this.h[3] = wi(this.h[3], u)),
    (this.h[4] = wi(this.h[4], l)),
    (this.h[5] = wi(this.h[5], c)),
    (this.h[6] = wi(this.h[6], f)),
    (this.h[7] = wi(this.h[7], m));
};
sr.prototype._digest = function (e) {
  return e === 'hex' ? To.toHex32(this.h, 'big') : To.split32(this.h, 'big');
};
var Cy = Ee,
  n6 = t6;
function Dr() {
  if (!(this instanceof Dr)) return new Dr();
  n6.call(this), (this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]);
}
Cy.inherits(Dr, n6);
var I_ = Dr;
Dr.blockSize = 512;
Dr.outSize = 224;
Dr.hmacStrength = 192;
Dr.padLength = 64;
Dr.prototype._digest = function (e) {
  return e === 'hex' ? Cy.toHex32(this.h.slice(0, 7), 'big') : Cy.split32(this.h.slice(0, 7), 'big');
};
var zn = Ee,
  O_ = Vo,
  k_ = Bl,
  Xi = zn.rotr64_hi,
  Zi = zn.rotr64_lo,
  i6 = zn.shr64_hi,
  r6 = zn.shr64_lo,
  ns = zn.sum64,
  bf = zn.sum64_hi,
  gf = zn.sum64_lo,
  P_ = zn.sum64_4_hi,
  N_ = zn.sum64_4_lo,
  D_ = zn.sum64_5_hi,
  B_ = zn.sum64_5_lo,
  s6 = O_.BlockHash,
  F_ = [
    1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560,
    3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868,
    3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837,
    2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936,
    666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627,
    2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720,
    430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899,
    1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427,
    3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733,
    587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591,
  ];
function Bi() {
  if (!(this instanceof Bi)) return new Bi();
  s6.call(this),
    (this.h = [
      1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209,
    ]),
    (this.k = F_),
    (this.W = new Array(160));
}
zn.inherits(Bi, s6);
var a6 = Bi;
Bi.blockSize = 1024;
Bi.outSize = 512;
Bi.hmacStrength = 192;
Bi.padLength = 128;
Bi.prototype._prepareBlock = function (e, t) {
  for (var i = this.W, r = 0; r < 32; r++) i[r] = e[t + r];
  for (; r < i.length; r += 2) {
    var s = W_(i[r - 4], i[r - 3]),
      a = J_(i[r - 4], i[r - 3]),
      o = i[r - 14],
      u = i[r - 13],
      l = H_(i[r - 30], i[r - 29]),
      c = K_(i[r - 30], i[r - 29]),
      f = i[r - 32],
      m = i[r - 31];
    (i[r] = P_(s, a, o, u, l, c, f, m)), (i[r + 1] = N_(s, a, o, u, l, c, f, m));
  }
};
Bi.prototype._update = function (e, t) {
  this._prepareBlock(e, t);
  var i = this.W,
    r = this.h[0],
    s = this.h[1],
    a = this.h[2],
    o = this.h[3],
    u = this.h[4],
    l = this.h[5],
    c = this.h[6],
    f = this.h[7],
    m = this.h[8],
    w = this.h[9],
    v = this.h[10],
    T = this.h[11],
    A = this.h[12],
    _ = this.h[13],
    O = this.h[14],
    B = this.h[15];
  k_(this.k.length === i.length);
  for (var P = 0; P < i.length; P += 2) {
    var N = O,
      U = B,
      W = G_(m, w),
      z = q_(m, w),
      Y = L_(m, w, v, T, A),
      ue = $_(m, w, v, T, A, _),
      J = this.k[P],
      le = this.k[P + 1],
      C = i[P],
      d = i[P + 1],
      y = D_(N, U, W, z, Y, ue, J, le, C, d),
      g = B_(N, U, W, z, Y, ue, J, le, C, d);
    (N = V_(r, s)), (U = z_(r, s)), (W = U_(r, s, a, o, u)), (z = j_(r, s, a, o, u, l));
    var S = bf(N, U, W, z),
      E = gf(N, U, W, z);
    (O = A), (B = _), (A = v), (_ = T), (v = m), (T = w), (m = bf(c, f, y, g)), (w = gf(f, f, y, g)), (c = u), (f = l), (u = a), (l = o), (a = r), (o = s), (r = bf(y, g, S, E)), (s = gf(y, g, S, E));
  }
  ns(this.h, 0, r, s), ns(this.h, 2, a, o), ns(this.h, 4, u, l), ns(this.h, 6, c, f), ns(this.h, 8, m, w), ns(this.h, 10, v, T), ns(this.h, 12, A, _), ns(this.h, 14, O, B);
};
Bi.prototype._digest = function (e) {
  return e === 'hex' ? zn.toHex32(this.h, 'big') : zn.split32(this.h, 'big');
};
function L_(n, e, t, i, r) {
  var s = (n & t) ^ (~n & r);
  return s < 0 && (s += 4294967296), s;
}
function $_(n, e, t, i, r, s) {
  var a = (e & i) ^ (~e & s);
  return a < 0 && (a += 4294967296), a;
}
function U_(n, e, t, i, r) {
  var s = (n & t) ^ (n & r) ^ (t & r);
  return s < 0 && (s += 4294967296), s;
}
function j_(n, e, t, i, r, s) {
  var a = (e & i) ^ (e & s) ^ (i & s);
  return a < 0 && (a += 4294967296), a;
}
function V_(n, e) {
  var t = Xi(n, e, 28),
    i = Xi(e, n, 2),
    r = Xi(e, n, 7),
    s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function z_(n, e) {
  var t = Zi(n, e, 28),
    i = Zi(e, n, 2),
    r = Zi(e, n, 7),
    s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function G_(n, e) {
  var t = Xi(n, e, 14),
    i = Xi(n, e, 18),
    r = Xi(e, n, 9),
    s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function q_(n, e) {
  var t = Zi(n, e, 14),
    i = Zi(n, e, 18),
    r = Zi(e, n, 9),
    s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function H_(n, e) {
  var t = Xi(n, e, 1),
    i = Xi(n, e, 8),
    r = i6(n, e, 7),
    s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function K_(n, e) {
  var t = Zi(n, e, 1),
    i = Zi(n, e, 8),
    r = r6(n, e, 7),
    s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function W_(n, e) {
  var t = Xi(n, e, 19),
    i = Xi(e, n, 29),
    r = i6(n, e, 6),
    s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function J_(n, e) {
  var t = Zi(n, e, 19),
    i = Zi(e, n, 29),
    r = r6(n, e, 6),
    s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
var My = Ee,
  o6 = a6;
function Br() {
  if (!(this instanceof Br)) return new Br();
  o6.call(this),
    (this.h = [
      3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428,
    ]);
}
My.inherits(Br, o6);
var Q_ = Br;
Br.blockSize = 1024;
Br.outSize = 384;
Br.hmacStrength = 192;
Br.padLength = 128;
Br.prototype._digest = function (e) {
  return e === 'hex' ? My.toHex32(this.h.slice(0, 12), 'big') : My.split32(this.h.slice(0, 12), 'big');
};
zo.sha1 = g_;
zo.sha224 = I_;
zo.sha256 = t6;
zo.sha384 = Q_;
zo.sha512 = a6;
var u6 = {},
  ma = Ee,
  Y_ = Vo,
  ud = ma.rotl32,
  u2 = ma.sum32,
  eu = ma.sum32_3,
  l2 = ma.sum32_4,
  l6 = Y_.BlockHash;
function ar() {
  if (!(this instanceof ar)) return new ar();
  l6.call(this), (this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520]), (this.endian = 'little');
}
ma.inherits(ar, l6);
u6.ripemd160 = ar;
ar.blockSize = 512;
ar.outSize = 160;
ar.hmacStrength = 192;
ar.padLength = 64;
ar.prototype._update = function (e, t) {
  for (var i = this.h[0], r = this.h[1], s = this.h[2], a = this.h[3], o = this.h[4], u = i, l = r, c = s, f = a, m = o, w = 0; w < 80; w++) {
    var v = u2(ud(l2(i, d2(w, r, s, a), e[e7[w] + t], X_(w)), n7[w]), o);
    (i = o), (o = a), (a = ud(s, 10)), (s = r), (r = v), (v = u2(ud(l2(u, d2(79 - w, l, c, f), e[t7[w] + t], Z_(w)), i7[w]), m)), (u = m), (m = f), (f = ud(c, 10)), (c = l), (l = v);
  }
  (v = eu(this.h[1], s, f)), (this.h[1] = eu(this.h[2], a, m)), (this.h[2] = eu(this.h[3], o, u)), (this.h[3] = eu(this.h[4], i, l)), (this.h[4] = eu(this.h[0], r, c)), (this.h[0] = v);
};
ar.prototype._digest = function (e) {
  return e === 'hex' ? ma.toHex32(this.h, 'little') : ma.split32(this.h, 'little');
};
function d2(n, e, t, i) {
  return n <= 15 ? e ^ t ^ i : n <= 31 ? (e & t) | (~e & i) : n <= 47 ? (e | ~t) ^ i : n <= 63 ? (e & i) | (t & ~i) : e ^ (t | ~i);
}
function X_(n) {
  return n <= 15 ? 0 : n <= 31 ? 1518500249 : n <= 47 ? 1859775393 : n <= 63 ? 2400959708 : 2840853838;
}
function Z_(n) {
  return n <= 15 ? 1352829926 : n <= 31 ? 1548603684 : n <= 47 ? 1836072691 : n <= 63 ? 2053994217 : 0;
}
var e7 = [
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3,
    7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
  ],
  t7 = [
    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12,
    2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11,
  ],
  n7 = [
    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9,
    8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
  ],
  i7 = [
    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14,
    6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11,
  ],
  r7 = Ee,
  s7 = Bl;
function wo(n, e, t) {
  if (!(this instanceof wo)) return new wo(n, e, t);
  (this.Hash = n), (this.blockSize = n.blockSize / 8), (this.outSize = n.outSize / 8), (this.inner = null), (this.outer = null), this._init(r7.toArray(e, t));
}
var a7 = wo;
wo.prototype._init = function (e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), s7(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++) e.push(0);
  for (t = 0; t < e.length; t++) e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++) e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
wo.prototype.update = function (e, t) {
  return this.inner.update(e, t), this;
};
wo.prototype.digest = function (e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function (n) {
  var e = n;
  (e.utils = Ee),
    (e.common = Vo),
    (e.sha = zo),
    (e.ripemd = u6),
    (e.hmac = a7),
    (e.sha1 = e.sha.sha1),
    (e.sha256 = e.sha.sha256),
    (e.sha224 = e.sha.sha224),
    (e.sha384 = e.sha.sha384),
    (e.sha512 = e.sha.sha512),
    (e.ripemd160 = e.ripemd.ripemd160);
})(Sn);
function qo(n, e, t) {
  return (
    (t = {
      path: e,
      exports: {},
      require: function (i, r) {
        return o7(i, r ?? t.path);
      },
    }),
    n(t, t.exports),
    t.exports
  );
}
function o7() {
  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}
var T0 = d6;
function d6(n, e) {
  if (!n) throw new Error(e || 'Assertion failed');
}
d6.equal = function (e, t, i) {
  if (e != t) throw new Error(i || 'Assertion failed: ' + e + ' != ' + t);
};
var ki = qo(function (n, e) {
    var t = e;
    function i(a, o) {
      if (Array.isArray(a)) return a.slice();
      if (!a) return [];
      var u = [];
      if (typeof a != 'string') {
        for (var l = 0; l < a.length; l++) u[l] = a[l] | 0;
        return u;
      }
      if (o === 'hex') {
        (a = a.replace(/[^a-z0-9]+/gi, '')), a.length % 2 !== 0 && (a = '0' + a);
        for (var l = 0; l < a.length; l += 2) u.push(parseInt(a[l] + a[l + 1], 16));
      } else
        for (var l = 0; l < a.length; l++) {
          var c = a.charCodeAt(l),
            f = c >> 8,
            m = c & 255;
          f ? u.push(f, m) : u.push(m);
        }
      return u;
    }
    t.toArray = i;
    function r(a) {
      return a.length === 1 ? '0' + a : a;
    }
    t.zero2 = r;
    function s(a) {
      for (var o = '', u = 0; u < a.length; u++) o += r(a[u].toString(16));
      return o;
    }
    (t.toHex = s),
      (t.encode = function (o, u) {
        return u === 'hex' ? s(o) : o;
      });
  }),
  ii = qo(function (n, e) {
    var t = e;
    (t.assert = T0), (t.toArray = ki.toArray), (t.zero2 = ki.zero2), (t.toHex = ki.toHex), (t.encode = ki.encode);
    function i(u, l, c) {
      var f = new Array(Math.max(u.bitLength(), c) + 1);
      f.fill(0);
      for (var m = 1 << (l + 1), w = u.clone(), v = 0; v < f.length; v++) {
        var T,
          A = w.andln(m - 1);
        w.isOdd() ? (A > (m >> 1) - 1 ? (T = (m >> 1) - A) : (T = A), w.isubn(T)) : (T = 0), (f[v] = T), w.iushrn(1);
      }
      return f;
    }
    t.getNAF = i;
    function r(u, l) {
      var c = [[], []];
      (u = u.clone()), (l = l.clone());
      for (var f = 0, m = 0, w; u.cmpn(-f) > 0 || l.cmpn(-m) > 0; ) {
        var v = (u.andln(3) + f) & 3,
          T = (l.andln(3) + m) & 3;
        v === 3 && (v = -1), T === 3 && (T = -1);
        var A;
        v & 1 ? ((w = (u.andln(7) + f) & 7), (w === 3 || w === 5) && T === 2 ? (A = -v) : (A = v)) : (A = 0), c[0].push(A);
        var _;
        T & 1 ? ((w = (l.andln(7) + m) & 7), (w === 3 || w === 5) && v === 2 ? (_ = -T) : (_ = T)) : (_ = 0),
          c[1].push(_),
          2 * f === A + 1 && (f = 1 - f),
          2 * m === _ + 1 && (m = 1 - m),
          u.iushrn(1),
          l.iushrn(1);
      }
      return c;
    }
    t.getJSF = r;
    function s(u, l, c) {
      var f = '_' + l;
      u.prototype[l] = function () {
        return this[f] !== void 0 ? this[f] : (this[f] = c.call(this));
      };
    }
    t.cachedProperty = s;
    function a(u) {
      return typeof u == 'string' ? t.toArray(u, 'hex') : u;
    }
    t.parseBytes = a;
    function o(u) {
      return new he(u, 'hex', 'le');
    }
    t.intFromLE = o;
  }),
  yc = ii.getNAF,
  u7 = ii.getJSF,
  hc = ii.assert;
function Is(n, e) {
  (this.type = n),
    (this.p = new he(e.p, 16)),
    (this.red = e.prime ? he.red(e.prime) : he.mont(this.p)),
    (this.zero = new he(0).toRed(this.red)),
    (this.one = new he(1).toRed(this.red)),
    (this.two = new he(2).toRed(this.red)),
    (this.n = e.n && new he(e.n, 16)),
    (this.g = e.g && this.pointFromJSON(e.g, e.gRed)),
    (this._wnafT1 = new Array(4)),
    (this._wnafT2 = new Array(4)),
    (this._wnafT3 = new Array(4)),
    (this._wnafT4 = new Array(4)),
    (this._bitLength = this.n ? this.n.bitLength() : 0);
  var t = this.n && this.p.div(this.n);
  !t || t.cmpn(100) > 0 ? (this.redN = null) : ((this._maxwellTrick = !0), (this.redN = this.n.toRed(this.red)));
}
var La = Is;
Is.prototype.point = function () {
  throw new Error('Not implemented');
};
Is.prototype.validate = function () {
  throw new Error('Not implemented');
};
Is.prototype._fixedNafMul = function (e, t) {
  hc(e.precomputed);
  var i = e._getDoubles(),
    r = yc(t, 1, this._bitLength),
    s = (1 << (i.step + 1)) - (i.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var a = [],
    o,
    u;
  for (o = 0; o < r.length; o += i.step) {
    u = 0;
    for (var l = o + i.step - 1; l >= o; l--) u = (u << 1) + r[l];
    a.push(u);
  }
  for (var c = this.jpoint(null, null, null), f = this.jpoint(null, null, null), m = s; m > 0; m--) {
    for (o = 0; o < a.length; o++) (u = a[o]), u === m ? (f = f.mixedAdd(i.points[o])) : u === -m && (f = f.mixedAdd(i.points[o].neg()));
    c = c.add(f);
  }
  return c.toP();
};
Is.prototype._wnafMul = function (e, t) {
  var i = 4,
    r = e._getNAFPoints(i);
  i = r.wnd;
  for (var s = r.points, a = yc(t, i, this._bitLength), o = this.jpoint(null, null, null), u = a.length - 1; u >= 0; u--) {
    for (var l = 0; u >= 0 && a[u] === 0; u--) l++;
    if ((u >= 0 && l++, (o = o.dblp(l)), u < 0)) break;
    var c = a[u];
    hc(c !== 0),
      e.type === 'affine' ? (c > 0 ? (o = o.mixedAdd(s[(c - 1) >> 1])) : (o = o.mixedAdd(s[(-c - 1) >> 1].neg()))) : c > 0 ? (o = o.add(s[(c - 1) >> 1])) : (o = o.add(s[(-c - 1) >> 1].neg()));
  }
  return e.type === 'affine' ? o.toP() : o;
};
Is.prototype._wnafMulAdd = function (e, t, i, r, s) {
  var a = this._wnafT1,
    o = this._wnafT2,
    u = this._wnafT3,
    l = 0,
    c,
    f,
    m;
  for (c = 0; c < r; c++) {
    m = t[c];
    var w = m._getNAFPoints(e);
    (a[c] = w.wnd), (o[c] = w.points);
  }
  for (c = r - 1; c >= 1; c -= 2) {
    var v = c - 1,
      T = c;
    if (a[v] !== 1 || a[T] !== 1) {
      (u[v] = yc(i[v], a[v], this._bitLength)), (u[T] = yc(i[T], a[T], this._bitLength)), (l = Math.max(u[v].length, l)), (l = Math.max(u[T].length, l));
      continue;
    }
    var A = [
      t[v],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      t[T],
      /* 7 */
    ];
    t[v].y.cmp(t[T].y) === 0
      ? ((A[1] = t[v].add(t[T])), (A[2] = t[v].toJ().mixedAdd(t[T].neg())))
      : t[v].y.cmp(t[T].y.redNeg()) === 0
      ? ((A[1] = t[v].toJ().mixedAdd(t[T])), (A[2] = t[v].add(t[T].neg())))
      : ((A[1] = t[v].toJ().mixedAdd(t[T])), (A[2] = t[v].toJ().mixedAdd(t[T].neg())));
    var _ = [
        -3, /* -1 -1 */
        -1, /* -1 0 */
        -5, /* -1 1 */
        -7, /* 0 -1 */
        0, /* 0 0 */
        7, /* 0 1 */
        5, /* 1 -1 */
        1, /* 1 0 */
        3,
        /* 1 1 */
      ],
      O = u7(i[v], i[T]);
    for (l = Math.max(O[0].length, l), u[v] = new Array(l), u[T] = new Array(l), f = 0; f < l; f++) {
      var B = O[0][f] | 0,
        P = O[1][f] | 0;
      (u[v][f] = _[(B + 1) * 3 + (P + 1)]), (u[T][f] = 0), (o[v] = A);
    }
  }
  var N = this.jpoint(null, null, null),
    U = this._wnafT4;
  for (c = l; c >= 0; c--) {
    for (var W = 0; c >= 0; ) {
      var z = !0;
      for (f = 0; f < r; f++) (U[f] = u[f][c] | 0), U[f] !== 0 && (z = !1);
      if (!z) break;
      W++, c--;
    }
    if ((c >= 0 && W++, (N = N.dblp(W)), c < 0)) break;
    for (f = 0; f < r; f++) {
      var Y = U[f];
      Y !== 0 && (Y > 0 ? (m = o[f][(Y - 1) >> 1]) : Y < 0 && (m = o[f][(-Y - 1) >> 1].neg()), m.type === 'affine' ? (N = N.mixedAdd(m)) : (N = N.add(m)));
    }
  }
  for (c = 0; c < r; c++) o[c] = null;
  return s ? N : N.toP();
};
function gi(n, e) {
  (this.curve = n), (this.type = e), (this.precomputed = null);
}
Is.BasePoint = gi;
gi.prototype.eq = function () {
  throw new Error('Not implemented');
};
gi.prototype.validate = function () {
  return this.curve.validate(this);
};
Is.prototype.decodePoint = function (e, t) {
  e = ii.toArray(e, t);
  var i = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * i) {
    e[0] === 6 ? hc(e[e.length - 1] % 2 === 0) : e[0] === 7 && hc(e[e.length - 1] % 2 === 1);
    var r = this.point(e.slice(1, 1 + i), e.slice(1 + i, 1 + 2 * i));
    return r;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === i) return this.pointFromX(e.slice(1, 1 + i), e[0] === 3);
  throw new Error('Unknown point format');
};
gi.prototype.encodeCompressed = function (e) {
  return this.encode(e, !0);
};
gi.prototype._encode = function (e) {
  var t = this.curve.p.byteLength(),
    i = this.getX().toArray('be', t);
  return e ? [this.getY().isEven() ? 2 : 3].concat(i) : [4].concat(i, this.getY().toArray('be', t));
};
gi.prototype.encode = function (e, t) {
  return ii.encode(this._encode(t), e);
};
gi.prototype.precompute = function (e) {
  if (this.precomputed) return this;
  var t = {
    doubles: null,
    naf: null,
    beta: null,
  };
  return (t.naf = this._getNAFPoints(8)), (t.doubles = this._getDoubles(4, e)), (t.beta = this._getBeta()), (this.precomputed = t), this;
};
gi.prototype._hasDoubles = function (e) {
  if (!this.precomputed) return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
gi.prototype._getDoubles = function (e, t) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  for (var i = [this], r = this, s = 0; s < t; s += e) {
    for (var a = 0; a < e; a++) r = r.dbl();
    i.push(r);
  }
  return {
    step: e,
    points: i,
  };
};
gi.prototype._getNAFPoints = function (e) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  for (var t = [this], i = (1 << e) - 1, r = i === 1 ? null : this.dbl(), s = 1; s < i; s++) t[s] = t[s - 1].add(r);
  return {
    wnd: e,
    points: t,
  };
};
gi.prototype._getBeta = function () {
  return null;
};
gi.prototype.dblp = function (e) {
  for (var t = this, i = 0; i < e; i++) t = t.dbl();
  return t;
};
var w0 = qo(function (n) {
    typeof Object.create == 'function'
      ? (n.exports = function (t, i) {
          i &&
            ((t.super_ = i),
            (t.prototype = Object.create(i.prototype, {
              constructor: {
                value: t,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })));
        })
      : (n.exports = function (t, i) {
          if (i) {
            t.super_ = i;
            var r = function () {};
            (r.prototype = i.prototype), (t.prototype = new r()), (t.prototype.constructor = t);
          }
        });
  }),
  l7 = ii.assert;
function vi(n) {
  La.call(this, 'short', n),
    (this.a = new he(n.a, 16).toRed(this.red)),
    (this.b = new he(n.b, 16).toRed(this.red)),
    (this.tinv = this.two.redInvm()),
    (this.zeroA = this.a.fromRed().cmpn(0) === 0),
    (this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0),
    (this.endo = this._getEndomorphism(n)),
    (this._endoWnafT1 = new Array(4)),
    (this._endoWnafT2 = new Array(4));
}
w0(vi, La);
var d7 = vi;
vi.prototype._getEndomorphism = function (e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, i;
    if (e.beta) t = new he(e.beta, 16).toRed(this.red);
    else {
      var r = this._getEndoRoots(this.p);
      (t = r[0].cmp(r[1]) < 0 ? r[0] : r[1]), (t = t.toRed(this.red));
    }
    if (e.lambda) i = new he(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(t)) === 0 ? (i = s[0]) : ((i = s[1]), l7(this.g.mul(i).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var a;
    return (
      e.basis
        ? (a = e.basis.map(function (o) {
            return {
              a: new he(o.a, 16),
              b: new he(o.b, 16),
            };
          }))
        : (a = this._getEndoBasis(i)),
      {
        beta: t,
        lambda: i,
        basis: a,
      }
    );
  }
};
vi.prototype._getEndoRoots = function (e) {
  var t = e === this.p ? this.red : he.mont(e),
    i = new he(2).toRed(t).redInvm(),
    r = i.redNeg(),
    s = new he(3).toRed(t).redNeg().redSqrt().redMul(i),
    a = r.redAdd(s).fromRed(),
    o = r.redSub(s).fromRed();
  return [a, o];
};
vi.prototype._getEndoBasis = function (e) {
  for (
    var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i = e, r = this.n.clone(), s = new he(1), a = new he(0), o = new he(0), u = new he(1), l, c, f, m, w, v, T, A = 0, _, O;
    i.cmpn(0) !== 0;

  ) {
    var B = r.div(i);
    (_ = r.sub(B.mul(i))), (O = o.sub(B.mul(s)));
    var P = u.sub(B.mul(a));
    if (!f && _.cmp(t) < 0) (l = T.neg()), (c = s), (f = _.neg()), (m = O);
    else if (f && ++A === 2) break;
    (T = _), (r = i), (i = _), (o = s), (s = O), (u = a), (a = P);
  }
  (w = _.neg()), (v = O);
  var N = f.sqr().add(m.sqr()),
    U = w.sqr().add(v.sqr());
  return (
    U.cmp(N) >= 0 && ((w = l), (v = c)),
    f.negative && ((f = f.neg()), (m = m.neg())),
    w.negative && ((w = w.neg()), (v = v.neg())),
    [
      { a: f, b: m },
      { a: w, b: v },
    ]
  );
};
vi.prototype._endoSplit = function (e) {
  var t = this.endo.basis,
    i = t[0],
    r = t[1],
    s = r.b.mul(e).divRound(this.n),
    a = i.b.neg().mul(e).divRound(this.n),
    o = s.mul(i.a),
    u = a.mul(r.a),
    l = s.mul(i.b),
    c = a.mul(r.b),
    f = e.sub(o).sub(u),
    m = l.add(c).neg();
  return { k1: f, k2: m };
};
vi.prototype.pointFromX = function (e, t) {
  (e = new he(e, 16)), e.red || (e = e.toRed(this.red));
  var i = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b),
    r = i.redSqrt();
  if (r.redSqr().redSub(i).cmp(this.zero) !== 0) throw new Error('invalid point');
  var s = r.fromRed().isOdd();
  return ((t && !s) || (!t && s)) && (r = r.redNeg()), this.point(e, r);
};
vi.prototype.validate = function (e) {
  if (e.inf) return !0;
  var t = e.x,
    i = e.y,
    r = this.a.redMul(t),
    s = t.redSqr().redMul(t).redIAdd(r).redIAdd(this.b);
  return i.redSqr().redISub(s).cmpn(0) === 0;
};
vi.prototype._endoWnafMulAdd = function (e, t, i) {
  for (var r = this._endoWnafT1, s = this._endoWnafT2, a = 0; a < e.length; a++) {
    var o = this._endoSplit(t[a]),
      u = e[a],
      l = u._getBeta();
    o.k1.negative && (o.k1.ineg(), (u = u.neg(!0))), o.k2.negative && (o.k2.ineg(), (l = l.neg(!0))), (r[a * 2] = u), (r[a * 2 + 1] = l), (s[a * 2] = o.k1), (s[a * 2 + 1] = o.k2);
  }
  for (var c = this._wnafMulAdd(1, r, s, a * 2, i), f = 0; f < a * 2; f++) (r[f] = null), (s[f] = null);
  return c;
};
function nn(n, e, t, i) {
  La.BasePoint.call(this, n, 'affine'),
    e === null && t === null
      ? ((this.x = null), (this.y = null), (this.inf = !0))
      : ((this.x = new he(e, 16)),
        (this.y = new he(t, 16)),
        i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)),
        this.x.red || (this.x = this.x.toRed(this.curve.red)),
        this.y.red || (this.y = this.y.toRed(this.curve.red)),
        (this.inf = !1));
}
w0(nn, La.BasePoint);
vi.prototype.point = function (e, t, i) {
  return new nn(this, e, t, i);
};
vi.prototype.pointFromJSON = function (e, t) {
  return nn.fromJSON(this, e, t);
};
nn.prototype._getBeta = function () {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta) return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var i = this.curve,
        r = function (s) {
          return i.point(s.x.redMul(i.endo.beta), s.y);
        };
      (e.beta = t),
        (t.precomputed = {
          beta: null,
          naf: e.naf && {
            wnd: e.naf.wnd,
            points: e.naf.points.map(r),
          },
          doubles: e.doubles && {
            step: e.doubles.step,
            points: e.doubles.points.map(r),
          },
        });
    }
    return t;
  }
};
nn.prototype.toJSON = function () {
  return this.precomputed
    ? [
        this.x,
        this.y,
        this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1),
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1),
          },
        },
      ]
    : [this.x, this.y];
};
nn.fromJSON = function (e, t, i) {
  typeof t == 'string' && (t = JSON.parse(t));
  var r = e.point(t[0], t[1], i);
  if (!t[2]) return r;
  function s(o) {
    return e.point(o[0], o[1], i);
  }
  var a = t[2];
  return (
    (r.precomputed = {
      beta: null,
      doubles: a.doubles && {
        step: a.doubles.step,
        points: [r].concat(a.doubles.points.map(s)),
      },
      naf: a.naf && {
        wnd: a.naf.wnd,
        points: [r].concat(a.naf.points.map(s)),
      },
    }),
    r
  );
};
nn.prototype.inspect = function () {
  return this.isInfinity() ? '<EC Point Infinity>' : '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};
nn.prototype.isInfinity = function () {
  return this.inf;
};
nn.prototype.add = function (e) {
  if (this.inf) return e;
  if (e.inf) return this;
  if (this.eq(e)) return this.dbl();
  if (this.neg().eq(e)) return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0) return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var i = t.redSqr().redISub(this.x).redISub(e.x),
    r = t.redMul(this.x.redSub(i)).redISub(this.y);
  return this.curve.point(i, r);
};
nn.prototype.dbl = function () {
  if (this.inf) return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0) return this.curve.point(null, null);
  var t = this.curve.a,
    i = this.x.redSqr(),
    r = e.redInvm(),
    s = i.redAdd(i).redIAdd(i).redIAdd(t).redMul(r),
    a = s.redSqr().redISub(this.x.redAdd(this.x)),
    o = s.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, o);
};
nn.prototype.getX = function () {
  return this.x.fromRed();
};
nn.prototype.getY = function () {
  return this.y.fromRed();
};
nn.prototype.mul = function (e) {
  return (
    (e = new he(e, 16)), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e)
  );
};
nn.prototype.mulAdd = function (e, t, i) {
  var r = [this, t],
    s = [e, i];
  return this.curve.endo ? this.curve._endoWnafMulAdd(r, s) : this.curve._wnafMulAdd(1, r, s, 2);
};
nn.prototype.jmulAdd = function (e, t, i) {
  var r = [this, t],
    s = [e, i];
  return this.curve.endo ? this.curve._endoWnafMulAdd(r, s, !0) : this.curve._wnafMulAdd(1, r, s, 2, !0);
};
nn.prototype.eq = function (e) {
  return this === e || (this.inf === e.inf && (this.inf || (this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0)));
};
nn.prototype.neg = function (e) {
  if (this.inf) return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var i = this.precomputed,
      r = function (s) {
        return s.neg();
      };
    t.precomputed = {
      naf: i.naf && {
        wnd: i.naf.wnd,
        points: i.naf.points.map(r),
      },
      doubles: i.doubles && {
        step: i.doubles.step,
        points: i.doubles.points.map(r),
      },
    };
  }
  return t;
};
nn.prototype.toJ = function () {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function fn(n, e, t, i) {
  La.BasePoint.call(this, n, 'jacobian'),
    e === null && t === null && i === null
      ? ((this.x = this.curve.one), (this.y = this.curve.one), (this.z = new he(0)))
      : ((this.x = new he(e, 16)), (this.y = new he(t, 16)), (this.z = new he(i, 16))),
    this.x.red || (this.x = this.x.toRed(this.curve.red)),
    this.y.red || (this.y = this.y.toRed(this.curve.red)),
    this.z.red || (this.z = this.z.toRed(this.curve.red)),
    (this.zOne = this.z === this.curve.one);
}
w0(fn, La.BasePoint);
vi.prototype.jpoint = function (e, t, i) {
  return new fn(this, e, t, i);
};
fn.prototype.toP = function () {
  if (this.isInfinity()) return this.curve.point(null, null);
  var e = this.z.redInvm(),
    t = e.redSqr(),
    i = this.x.redMul(t),
    r = this.y.redMul(t).redMul(e);
  return this.curve.point(i, r);
};
fn.prototype.neg = function () {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
fn.prototype.add = function (e) {
  if (this.isInfinity()) return e;
  if (e.isInfinity()) return this;
  var t = e.z.redSqr(),
    i = this.z.redSqr(),
    r = this.x.redMul(t),
    s = e.x.redMul(i),
    a = this.y.redMul(t.redMul(e.z)),
    o = e.y.redMul(i.redMul(this.z)),
    u = r.redSub(s),
    l = a.redSub(o);
  if (u.cmpn(0) === 0) return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var c = u.redSqr(),
    f = c.redMul(u),
    m = r.redMul(c),
    w = l.redSqr().redIAdd(f).redISub(m).redISub(m),
    v = l.redMul(m.redISub(w)).redISub(a.redMul(f)),
    T = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(w, v, T);
};
fn.prototype.mixedAdd = function (e) {
  if (this.isInfinity()) return e.toJ();
  if (e.isInfinity()) return this;
  var t = this.z.redSqr(),
    i = this.x,
    r = e.x.redMul(t),
    s = this.y,
    a = e.y.redMul(t).redMul(this.z),
    o = i.redSub(r),
    u = s.redSub(a);
  if (o.cmpn(0) === 0) return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = o.redSqr(),
    c = l.redMul(o),
    f = i.redMul(l),
    m = u.redSqr().redIAdd(c).redISub(f).redISub(f),
    w = u.redMul(f.redISub(m)).redISub(s.redMul(c)),
    v = this.z.redMul(o);
  return this.curve.jpoint(m, w, v);
};
fn.prototype.dblp = function (e) {
  if (e === 0) return this;
  if (this.isInfinity()) return this;
  if (!e) return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var i = this;
    for (t = 0; t < e; t++) i = i.dbl();
    return i;
  }
  var r = this.curve.a,
    s = this.curve.tinv,
    a = this.x,
    o = this.y,
    u = this.z,
    l = u.redSqr().redSqr(),
    c = o.redAdd(o);
  for (t = 0; t < e; t++) {
    var f = a.redSqr(),
      m = c.redSqr(),
      w = m.redSqr(),
      v = f.redAdd(f).redIAdd(f).redIAdd(r.redMul(l)),
      T = a.redMul(m),
      A = v.redSqr().redISub(T.redAdd(T)),
      _ = T.redISub(A),
      O = v.redMul(_);
    O = O.redIAdd(O).redISub(w);
    var B = c.redMul(u);
    t + 1 < e && (l = l.redMul(w)), (a = A), (u = B), (c = O);
  }
  return this.curve.jpoint(a, c.redMul(s), u);
};
fn.prototype.dbl = function () {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
fn.prototype._zeroDbl = function () {
  var e, t, i;
  if (this.zOne) {
    var r = this.x.redSqr(),
      s = this.y.redSqr(),
      a = s.redSqr(),
      o = this.x.redAdd(s).redSqr().redISub(r).redISub(a);
    o = o.redIAdd(o);
    var u = r.redAdd(r).redIAdd(r),
      l = u.redSqr().redISub(o).redISub(o),
      c = a.redIAdd(a);
    (c = c.redIAdd(c)), (c = c.redIAdd(c)), (e = l), (t = u.redMul(o.redISub(l)).redISub(c)), (i = this.y.redAdd(this.y));
  } else {
    var f = this.x.redSqr(),
      m = this.y.redSqr(),
      w = m.redSqr(),
      v = this.x.redAdd(m).redSqr().redISub(f).redISub(w);
    v = v.redIAdd(v);
    var T = f.redAdd(f).redIAdd(f),
      A = T.redSqr(),
      _ = w.redIAdd(w);
    (_ = _.redIAdd(_)), (_ = _.redIAdd(_)), (e = A.redISub(v).redISub(v)), (t = T.redMul(v.redISub(e)).redISub(_)), (i = this.y.redMul(this.z)), (i = i.redIAdd(i));
  }
  return this.curve.jpoint(e, t, i);
};
fn.prototype._threeDbl = function () {
  var e, t, i;
  if (this.zOne) {
    var r = this.x.redSqr(),
      s = this.y.redSqr(),
      a = s.redSqr(),
      o = this.x.redAdd(s).redSqr().redISub(r).redISub(a);
    o = o.redIAdd(o);
    var u = r.redAdd(r).redIAdd(r).redIAdd(this.curve.a),
      l = u.redSqr().redISub(o).redISub(o);
    e = l;
    var c = a.redIAdd(a);
    (c = c.redIAdd(c)), (c = c.redIAdd(c)), (t = u.redMul(o.redISub(l)).redISub(c)), (i = this.y.redAdd(this.y));
  } else {
    var f = this.z.redSqr(),
      m = this.y.redSqr(),
      w = this.x.redMul(m),
      v = this.x.redSub(f).redMul(this.x.redAdd(f));
    v = v.redAdd(v).redIAdd(v);
    var T = w.redIAdd(w);
    T = T.redIAdd(T);
    var A = T.redAdd(T);
    (e = v.redSqr().redISub(A)), (i = this.y.redAdd(this.z).redSqr().redISub(m).redISub(f));
    var _ = m.redSqr();
    (_ = _.redIAdd(_)), (_ = _.redIAdd(_)), (_ = _.redIAdd(_)), (t = v.redMul(T.redISub(e)).redISub(_));
  }
  return this.curve.jpoint(e, t, i);
};
fn.prototype._dbl = function () {
  var e = this.curve.a,
    t = this.x,
    i = this.y,
    r = this.z,
    s = r.redSqr().redSqr(),
    a = t.redSqr(),
    o = i.redSqr(),
    u = a.redAdd(a).redIAdd(a).redIAdd(e.redMul(s)),
    l = t.redAdd(t);
  l = l.redIAdd(l);
  var c = l.redMul(o),
    f = u.redSqr().redISub(c.redAdd(c)),
    m = c.redISub(f),
    w = o.redSqr();
  (w = w.redIAdd(w)), (w = w.redIAdd(w)), (w = w.redIAdd(w));
  var v = u.redMul(m).redISub(w),
    T = i.redAdd(i).redMul(r);
  return this.curve.jpoint(f, v, T);
};
fn.prototype.trpl = function () {
  if (!this.curve.zeroA) return this.dbl().add(this);
  var e = this.x.redSqr(),
    t = this.y.redSqr(),
    i = this.z.redSqr(),
    r = t.redSqr(),
    s = e.redAdd(e).redIAdd(e),
    a = s.redSqr(),
    o = this.x.redAdd(t).redSqr().redISub(e).redISub(r);
  (o = o.redIAdd(o)), (o = o.redAdd(o).redIAdd(o)), (o = o.redISub(a));
  var u = o.redSqr(),
    l = r.redIAdd(r);
  (l = l.redIAdd(l)), (l = l.redIAdd(l)), (l = l.redIAdd(l));
  var c = s.redIAdd(o).redSqr().redISub(a).redISub(u).redISub(l),
    f = t.redMul(c);
  (f = f.redIAdd(f)), (f = f.redIAdd(f));
  var m = this.x.redMul(u).redISub(f);
  (m = m.redIAdd(m)), (m = m.redIAdd(m));
  var w = this.y.redMul(c.redMul(l.redISub(c)).redISub(o.redMul(u)));
  (w = w.redIAdd(w)), (w = w.redIAdd(w)), (w = w.redIAdd(w));
  var v = this.z.redAdd(o).redSqr().redISub(i).redISub(u);
  return this.curve.jpoint(m, w, v);
};
fn.prototype.mul = function (e, t) {
  return (e = new he(e, t)), this.curve._wnafMul(this, e);
};
fn.prototype.eq = function (e) {
  if (e.type === 'affine') return this.eq(e.toJ());
  if (this === e) return !0;
  var t = this.z.redSqr(),
    i = e.z.redSqr();
  if (this.x.redMul(i).redISub(e.x.redMul(t)).cmpn(0) !== 0) return !1;
  var r = t.redMul(this.z),
    s = i.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(r)).cmpn(0) === 0;
};
fn.prototype.eqXToP = function (e) {
  var t = this.z.redSqr(),
    i = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(i) === 0) return !0;
  for (var r = e.clone(), s = this.curve.redN.redMul(t); ; ) {
    if ((r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0)) return !1;
    if ((i.redIAdd(s), this.x.cmp(i) === 0)) return !0;
  }
};
fn.prototype.inspect = function () {
  return this.isInfinity() ? '<EC JPoint Infinity>' : '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
};
fn.prototype.isInfinity = function () {
  return this.z.cmpn(0) === 0;
};
var kd = qo(function (n, e) {
    var t = e;
    (t.base = La), (t.short = d7), (t.mont = /*RicMoo:ethers:require(./mont)*/ null), (t.edwards = /*RicMoo:ethers:require(./edwards)*/ null);
  }),
  Pd = qo(function (n, e) {
    var t = e,
      i = ii.assert;
    function r(o) {
      o.type === 'short' ? (this.curve = new kd.short(o)) : o.type === 'edwards' ? (this.curve = new kd.edwards(o)) : (this.curve = new kd.mont(o)),
        (this.g = this.curve.g),
        (this.n = this.curve.n),
        (this.hash = o.hash),
        i(this.g.validate(), 'Invalid curve'),
        i(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
    }
    t.PresetCurve = r;
    function s(o, u) {
      Object.defineProperty(t, o, {
        configurable: !0,
        enumerable: !0,
        get: function () {
          var l = new r(u);
          return (
            Object.defineProperty(t, o, {
              configurable: !0,
              enumerable: !0,
              value: l,
            }),
            l
          );
        },
      });
    }
    s('p192', {
      type: 'short',
      prime: 'p192',
      p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
      a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
      b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
      n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
      hash: Sn.sha256,
      gRed: !1,
      g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'],
    }),
      s('p224', {
        type: 'short',
        prime: 'p224',
        p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
        a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
        b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
        n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
        hash: Sn.sha256,
        gRed: !1,
        g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'],
      }),
      s('p256', {
        type: 'short',
        prime: null,
        p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
        a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
        b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
        n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
        hash: Sn.sha256,
        gRed: !1,
        g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'],
      }),
      s('p384', {
        type: 'short',
        prime: null,
        p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff',
        a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc',
        b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
        n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
        hash: Sn.sha384,
        gRed: !1,
        g: [
          'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7',
          '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
        ],
      }),
      s('p521', {
        type: 'short',
        prime: null,
        p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff',
        a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc',
        b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
        n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
        hash: Sn.sha512,
        gRed: !1,
        g: [
          '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
          '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650',
        ],
      }),
      s('curve25519', {
        type: 'mont',
        prime: 'p25519',
        p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
        a: '76d06',
        b: '1',
        n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
        hash: Sn.sha256,
        gRed: !1,
        g: ['9'],
      }),
      s('ed25519', {
        type: 'edwards',
        prime: 'p25519',
        p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
        a: '-1',
        c: '1',
        // -121665 * (121666^(-1)) (mod P)
        d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
        n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
        hash: Sn.sha256,
        gRed: !1,
        g: [
          '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',
          // 4/5
          '6666666666666666666666666666666666666666666666666666666666666658',
        ],
      });
    var a;
    try {
      a = /*RicMoo:ethers:require(./precomputed/secp256k1)*/ null.crash();
    } catch {
      a = void 0;
    }
    s('secp256k1', {
      type: 'short',
      prime: 'k256',
      p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
      a: '0',
      b: '7',
      n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
      h: '1',
      hash: Sn.sha256,
      // Precomputed endomorphism
      beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
      lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
      basis: [
        {
          a: '3086d221a7d46bcde86c90e49284eb15',
          b: '-e4437ed6010e88286f547fa90abfe4c3',
        },
        {
          a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
          b: '3086d221a7d46bcde86c90e49284eb15',
        },
      ],
      gRed: !1,
      g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', a],
    });
  });
function ws(n) {
  if (!(this instanceof ws)) return new ws(n);
  (this.hash = n.hash),
    (this.predResist = !!n.predResist),
    (this.outLen = this.hash.outSize),
    (this.minEntropy = n.minEntropy || this.hash.hmacStrength),
    (this._reseed = null),
    (this.reseedInterval = null),
    (this.K = null),
    (this.V = null);
  var e = ki.toArray(n.entropy, n.entropyEnc || 'hex'),
    t = ki.toArray(n.nonce, n.nonceEnc || 'hex'),
    i = ki.toArray(n.pers, n.persEnc || 'hex');
  T0(e.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'), this._init(e, t, i);
}
var c6 = ws;
ws.prototype._init = function (e, t, i) {
  var r = e.concat(t).concat(i);
  (this.K = new Array(this.outLen / 8)), (this.V = new Array(this.outLen / 8));
  for (var s = 0; s < this.V.length; s++) (this.K[s] = 0), (this.V[s] = 1);
  this._update(r), (this._reseed = 1), (this.reseedInterval = 281474976710656);
};
ws.prototype._hmac = function () {
  return new Sn.hmac(this.hash, this.K);
};
ws.prototype._update = function (e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)),
    (this.K = t.digest()),
    (this.V = this._hmac().update(this.V).digest()),
    e && ((this.K = this._hmac().update(this.V).update([1]).update(e).digest()), (this.V = this._hmac().update(this.V).digest()));
};
ws.prototype.reseed = function (e, t, i, r) {
  typeof t != 'string' && ((r = i), (i = t), (t = null)),
    (e = ki.toArray(e, t)),
    (i = ki.toArray(i, r)),
    T0(e.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits'),
    this._update(e.concat(i || [])),
    (this._reseed = 1);
};
ws.prototype.generate = function (e, t, i, r) {
  if (this._reseed > this.reseedInterval) throw new Error('Reseed is required');
  typeof t != 'string' && ((r = i), (i = t), (t = null)), i && ((i = ki.toArray(i, r || 'hex')), this._update(i));
  for (var s = []; s.length < e; ) (this.V = this._hmac().update(this.V).digest()), (s = s.concat(this.V));
  var a = s.slice(0, e);
  return this._update(i), this._reseed++, ki.encode(a, t);
};
var _y = ii.assert;
function wn(n, e) {
  (this.ec = n), (this.priv = null), (this.pub = null), e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var A0 = wn;
wn.fromPublic = function (e, t, i) {
  return t instanceof wn
    ? t
    : new wn(e, {
        pub: t,
        pubEnc: i,
      });
};
wn.fromPrivate = function (e, t, i) {
  return t instanceof wn
    ? t
    : new wn(e, {
        priv: t,
        privEnc: i,
      });
};
wn.prototype.validate = function () {
  var e = this.getPublic();
  return e.isInfinity()
    ? { result: !1, reason: 'Invalid public key' }
    : e.validate()
    ? e.mul(this.ec.curve.n).isInfinity()
      ? { result: !0, reason: null }
      : { result: !1, reason: 'Public key * N != O' }
    : { result: !1, reason: 'Public key is not a point' };
};
wn.prototype.getPublic = function (e, t) {
  return typeof e == 'string' && ((t = e), (e = null)), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;
};
wn.prototype.getPrivate = function (e) {
  return e === 'hex' ? this.priv.toString(16, 2) : this.priv;
};
wn.prototype._importPrivate = function (e, t) {
  (this.priv = new he(e, t || 16)), (this.priv = this.priv.umod(this.ec.curve.n));
};
wn.prototype._importPublic = function (e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === 'mont' ? _y(e.x, 'Need x coordinate') : (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') && _y(e.x && e.y, 'Need both x and y coordinate'),
      (this.pub = this.ec.curve.point(e.x, e.y));
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
wn.prototype.derive = function (e) {
  return e.validate() || _y(e.validate(), 'public point not validated'), e.mul(this.priv).getX();
};
wn.prototype.sign = function (e, t, i) {
  return this.ec.sign(e, this, t, i);
};
wn.prototype.verify = function (e, t) {
  return this.ec.verify(e, t, this);
};
wn.prototype.inspect = function () {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};
var c7 = ii.assert;
function np(n, e) {
  if (n instanceof np) return n;
  this._importDER(n, e) ||
    (c7(n.r && n.s, 'Signature without r or s'),
    (this.r = new he(n.r, 16)),
    (this.s = new he(n.s, 16)),
    n.recoveryParam === void 0 ? (this.recoveryParam = null) : (this.recoveryParam = n.recoveryParam));
}
var ip = np;
function p7() {
  this.place = 0;
}
function vf(n, e) {
  var t = n[e.place++];
  if (!(t & 128)) return t;
  var i = t & 15;
  if (i === 0 || i > 4) return !1;
  for (var r = 0, s = 0, a = e.place; s < i; s++, a++) (r <<= 8), (r |= n[a]), (r >>>= 0);
  return r <= 127 ? !1 : ((e.place = a), r);
}
function c2(n) {
  for (var e = 0, t = n.length - 1; !n[e] && !(n[e + 1] & 128) && e < t; ) e++;
  return e === 0 ? n : n.slice(e);
}
np.prototype._importDER = function (e, t) {
  e = ii.toArray(e, t);
  var i = new p7();
  if (e[i.place++] !== 48) return !1;
  var r = vf(e, i);
  if (r === !1 || r + i.place !== e.length || e[i.place++] !== 2) return !1;
  var s = vf(e, i);
  if (s === !1) return !1;
  var a = e.slice(i.place, s + i.place);
  if (((i.place += s), e[i.place++] !== 2)) return !1;
  var o = vf(e, i);
  if (o === !1 || e.length !== o + i.place) return !1;
  var u = e.slice(i.place, o + i.place);
  if (a[0] === 0)
    if (a[1] & 128) a = a.slice(1);
    else return !1;
  if (u[0] === 0)
    if (u[1] & 128) u = u.slice(1);
    else return !1;
  return (this.r = new he(a)), (this.s = new he(u)), (this.recoveryParam = null), !0;
};
function xf(n, e) {
  if (e < 128) {
    n.push(e);
    return;
  }
  var t = 1 + ((Math.log(e) / Math.LN2) >>> 3);
  for (n.push(t | 128); --t; ) n.push((e >>> (t << 3)) & 255);
  n.push(e);
}
np.prototype.toDER = function (e) {
  var t = this.r.toArray(),
    i = this.s.toArray();
  for (t[0] & 128 && (t = [0].concat(t)), i[0] & 128 && (i = [0].concat(i)), t = c2(t), i = c2(i); !i[0] && !(i[1] & 128); ) i = i.slice(1);
  var r = [2];
  xf(r, t.length), (r = r.concat(t)), r.push(2), xf(r, i.length);
  var s = r.concat(i),
    a = [48];
  return xf(a, s.length), (a = a.concat(s)), ii.encode(a, e);
};
var f7 =
    /*RicMoo:ethers:require(brorand)*/
    function () {
      throw new Error('unsupported');
    },
  p6 = ii.assert;
function mi(n) {
  if (!(this instanceof mi)) return new mi(n);
  typeof n == 'string' && (p6(Object.prototype.hasOwnProperty.call(Pd, n), 'Unknown curve ' + n), (n = Pd[n])),
    n instanceof Pd.PresetCurve && (n = { curve: n }),
    (this.curve = n.curve.curve),
    (this.n = this.curve.n),
    (this.nh = this.n.ushrn(1)),
    (this.g = this.curve.g),
    (this.g = n.curve.g),
    this.g.precompute(n.curve.n.bitLength() + 1),
    (this.hash = n.hash || n.curve.hash);
}
var y7 = mi;
mi.prototype.keyPair = function (e) {
  return new A0(this, e);
};
mi.prototype.keyFromPrivate = function (e, t) {
  return A0.fromPrivate(this, e, t);
};
mi.prototype.keyFromPublic = function (e, t) {
  return A0.fromPublic(this, e, t);
};
mi.prototype.genKeyPair = function (e) {
  e || (e = {});
  for (
    var t = new c6({
        hash: this.hash,
        pers: e.pers,
        persEnc: e.persEnc || 'utf8',
        entropy: e.entropy || f7(this.hash.hmacStrength),
        entropyEnc: (e.entropy && e.entropyEnc) || 'utf8',
        nonce: this.n.toArray(),
      }),
      i = this.n.byteLength(),
      r = this.n.sub(new he(2));
    ;

  ) {
    var s = new he(t.generate(i));
    if (!(s.cmp(r) > 0)) return s.iaddn(1), this.keyFromPrivate(s);
  }
};
mi.prototype._truncateToN = function (e, t) {
  var i = e.byteLength() * 8 - this.n.bitLength();
  return i > 0 && (e = e.ushrn(i)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
mi.prototype.sign = function (e, t, i, r) {
  typeof i == 'object' && ((r = i), (i = null)), r || (r = {}), (t = this.keyFromPrivate(t, i)), (e = this._truncateToN(new he(e, 16)));
  for (
    var s = this.n.byteLength(),
      a = t.getPrivate().toArray('be', s),
      o = e.toArray('be', s),
      u = new c6({
        hash: this.hash,
        entropy: a,
        nonce: o,
        pers: r.pers,
        persEnc: r.persEnc || 'utf8',
      }),
      l = this.n.sub(new he(1)),
      c = 0;
    ;
    c++
  ) {
    var f = r.k ? r.k(c) : new he(u.generate(this.n.byteLength()));
    if (((f = this._truncateToN(f, !0)), !(f.cmpn(1) <= 0 || f.cmp(l) >= 0))) {
      var m = this.g.mul(f);
      if (!m.isInfinity()) {
        var w = m.getX(),
          v = w.umod(this.n);
        if (v.cmpn(0) !== 0) {
          var T = f.invm(this.n).mul(v.mul(t.getPrivate()).iadd(e));
          if (((T = T.umod(this.n)), T.cmpn(0) !== 0)) {
            var A = (m.getY().isOdd() ? 1 : 0) | (w.cmp(v) !== 0 ? 2 : 0);
            return r.canonical && T.cmp(this.nh) > 0 && ((T = this.n.sub(T)), (A ^= 1)), new ip({ r: v, s: T, recoveryParam: A });
          }
        }
      }
    }
  }
};
mi.prototype.verify = function (e, t, i, r) {
  (e = this._truncateToN(new he(e, 16))), (i = this.keyFromPublic(i, r)), (t = new ip(t, 'hex'));
  var s = t.r,
    a = t.s;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0) return !1;
  var o = a.invm(this.n),
    u = o.mul(e).umod(this.n),
    l = o.mul(s).umod(this.n),
    c;
  return this.curve._maxwellTrick
    ? ((c = this.g.jmulAdd(u, i.getPublic(), l)), c.isInfinity() ? !1 : c.eqXToP(s))
    : ((c = this.g.mulAdd(u, i.getPublic(), l)), c.isInfinity() ? !1 : c.getX().umod(this.n).cmp(s) === 0);
};
mi.prototype.recoverPubKey = function (n, e, t, i) {
  p6((3 & t) === t, 'The recovery param is more than two bits'), (e = new ip(e, i));
  var r = this.n,
    s = new he(n),
    a = e.r,
    o = e.s,
    u = t & 1,
    l = t >> 1;
  if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l) throw new Error('Unable to find sencond key candinate');
  l ? (a = this.curve.pointFromX(a.add(this.curve.n), u)) : (a = this.curve.pointFromX(a, u));
  var c = e.r.invm(r),
    f = r.sub(s).mul(c).umod(r),
    m = o.mul(c).umod(r);
  return this.g.mulAdd(f, a, m);
};
mi.prototype.getKeyRecoveryParam = function (n, e, t, i) {
  if (((e = new ip(e, i)), e.recoveryParam !== null)) return e.recoveryParam;
  for (var r = 0; r < 4; r++) {
    var s;
    try {
      s = this.recoverPubKey(n, e, r);
    } catch {
      continue;
    }
    if (s.eq(t)) return r;
  }
  throw new Error('Unable to find valid recovery factor');
};
var h7 = qo(function (n, e) {
    var t = e;
    (t.version = '6.5.4'),
      (t.utils = ii),
      (t.rand =
        /*RicMoo:ethers:require(brorand)*/
        function () {
          throw new Error('unsupported');
        }),
      (t.curve = kd),
      (t.curves = Pd),
      (t.ec = y7),
      (t.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/ null);
  }),
  m7 = h7.ec;
const b7 = 'signing-key/5.7.0',
  Ry = new D(b7);
let Tf = null;
function zi() {
  return Tf || (Tf = new m7('secp256k1')), Tf;
}
class ua {
  constructor(e) {
    j(this, 'curve', 'secp256k1'), j(this, 'privateKey', K(e)), nr(this.privateKey) !== 32 && Ry.throwArgumentError('invalid private key', 'privateKey', '[[ REDACTED ]]');
    const t = zi().keyFromPrivate(H(this.privateKey));
    j(this, 'publicKey', '0x' + t.getPublic(!1, 'hex')), j(this, 'compressedPublicKey', '0x' + t.getPublic(!0, 'hex')), j(this, '_isSigningKey', !0);
  }
  _addPoint(e) {
    const t = zi().keyFromPublic(H(this.publicKey)),
      i = zi().keyFromPublic(H(e));
    return '0x' + t.pub.add(i.pub).encodeCompressed('hex');
  }
  signDigest(e) {
    const t = zi().keyFromPrivate(H(this.privateKey)),
      i = H(e);
    i.length !== 32 && Ry.throwArgumentError('bad digest length', 'digest', e);
    const r = t.sign(i, { canonical: !0 });
    return Da({
      recoveryParam: r.recoveryParam,
      r: Le('0x' + r.r.toString(16), 32),
      s: Le('0x' + r.s.toString(16), 32),
    });
  }
  computeSharedSecret(e) {
    const t = zi().keyFromPrivate(H(this.privateKey)),
      i = zi().keyFromPublic(H(E0(e)));
    return Le('0x' + t.derive(i.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function f6(n, e) {
  const t = Da(e),
    i = { r: H(t.r), s: H(t.s) };
  return '0x' + zi().recoverPubKey(H(n), i, t.recoveryParam).encode('hex', !1);
}
function E0(n, e) {
  const t = H(n);
  if (t.length === 32) {
    const i = new ua(t);
    return e ? '0x' + zi().keyFromPrivate(t).getPublic(!0, 'hex') : i.publicKey;
  } else {
    if (t.length === 33) return e ? K(t) : '0x' + zi().keyFromPublic(t).getPublic(!1, 'hex');
    if (t.length === 65) return e ? '0x' + zi().keyFromPublic(t).getPublic(!0, 'hex') : K(t);
  }
  return Ry.throwArgumentError('invalid public or private key', 'key', '[REDACTED]');
}
const g7 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        SigningKey: ua,
        computePublicKey: E0,
        recoverPublicKey: f6,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  v7 = 'transactions/5.7.0',
  xn = new D(v7);
var Iy;
(function (n) {
  (n[(n.legacy = 0)] = 'legacy'), (n[(n.eip2930 = 1)] = 'eip2930'), (n[(n.eip1559 = 2)] = 'eip1559');
})(Iy || (Iy = {}));
function S0(n) {
  return n === '0x' ? null : Fe(n);
}
function gn(n) {
  return n === '0x' ? p0 : q.from(n);
}
const x7 = [
    { name: 'nonce', maxLength: 32, numeric: !0 },
    { name: 'gasPrice', maxLength: 32, numeric: !0 },
    { name: 'gasLimit', maxLength: 32, numeric: !0 },
    { name: 'to', length: 20 },
    { name: 'value', maxLength: 32, numeric: !0 },
    { name: 'data' },
  ],
  T7 = {
    chainId: !0,
    data: !0,
    gasLimit: !0,
    gasPrice: !0,
    nonce: !0,
    to: !0,
    type: !0,
    value: !0,
  };
function hs(n) {
  const e = E0(n);
  return Fe(Lt(De(Lt(e, 1)), 12));
}
function Ho(n, e) {
  return hs(f6(H(n), e));
}
function Qn(n, e) {
  const t = Qi(q.from(n).toHexString());
  return t.length > 32 && xn.throwArgumentError('invalid length for ' + e, 'transaction:' + e, n), t;
}
function wf(n, e) {
  return {
    address: Fe(n),
    storageKeys: (e || []).map((t, i) => (nr(t) !== 32 && xn.throwArgumentError('invalid access list storageKey', `accessList[${n}:${i}]`, t), t.toLowerCase())),
  };
}
function $a(n) {
  if (Array.isArray(n))
    return n.map((t, i) =>
      Array.isArray(t) ? (t.length > 2 && xn.throwArgumentError('access list expected to be [ address, storageKeys[] ]', `value[${i}]`, t), wf(t[0], t[1])) : wf(t.address, t.storageKeys),
    );
  const e = Object.keys(n).map((t) => {
    const i = n[t].reduce((r, s) => ((r[s] = !0), r), {});
    return wf(t, Object.keys(i).sort());
  });
  return e.sort((t, i) => t.address.localeCompare(i.address)), e;
}
function y6(n) {
  return $a(n).map((e) => [e.address, e.storageKeys]);
}
function h6(n, e) {
  if (n.gasPrice != null) {
    const i = q.from(n.gasPrice),
      r = q.from(n.maxFeePerGas || 0);
    i.eq(r) ||
      xn.throwArgumentError('mismatch EIP-1559 gasPrice != maxFeePerGas', 'tx', {
        gasPrice: i,
        maxFeePerGas: r,
      });
  }
  const t = [
    Qn(n.chainId || 0, 'chainId'),
    Qn(n.nonce || 0, 'nonce'),
    Qn(n.maxPriorityFeePerGas || 0, 'maxPriorityFeePerGas'),
    Qn(n.maxFeePerGas || 0, 'maxFeePerGas'),
    Qn(n.gasLimit || 0, 'gasLimit'),
    n.to != null ? Fe(n.to) : '0x',
    Qn(n.value || 0, 'value'),
    n.data || '0x',
    y6(n.accessList || []),
  ];
  if (e) {
    const i = Da(e);
    t.push(Qn(i.recoveryParam, 'recoveryParam')), t.push(Qi(i.r)), t.push(Qi(i.s));
  }
  return Cn(['0x02', Ts(t)]);
}
function m6(n, e) {
  const t = [
    Qn(n.chainId || 0, 'chainId'),
    Qn(n.nonce || 0, 'nonce'),
    Qn(n.gasPrice || 0, 'gasPrice'),
    Qn(n.gasLimit || 0, 'gasLimit'),
    n.to != null ? Fe(n.to) : '0x',
    Qn(n.value || 0, 'value'),
    n.data || '0x',
    y6(n.accessList || []),
  ];
  if (e) {
    const i = Da(e);
    t.push(Qn(i.recoveryParam, 'recoveryParam')), t.push(Qi(i.r)), t.push(Qi(i.s));
  }
  return Cn(['0x01', Ts(t)]);
}
function w7(n, e) {
  u0(n, T7);
  const t = [];
  x7.forEach(function (a) {
    let o = n[a.name] || [];
    const u = {};
    a.numeric && (u.hexPad = 'left'),
      (o = H(K(o, u))),
      a.length && o.length !== a.length && o.length > 0 && xn.throwArgumentError('invalid length for ' + a.name, 'transaction:' + a.name, o),
      a.maxLength && ((o = Qi(o)), o.length > a.maxLength && xn.throwArgumentError('invalid length for ' + a.name, 'transaction:' + a.name, o)),
      t.push(K(o));
  });
  let i = 0;
  if (
    (n.chainId != null
      ? ((i = n.chainId), typeof i != 'number' && xn.throwArgumentError('invalid transaction.chainId', 'transaction', n))
      : e && !Pl(e) && e.v > 28 && (i = Math.floor((e.v - 35) / 2)),
    i !== 0 && (t.push(K(i)), t.push('0x'), t.push('0x')),
    !e)
  )
    return Ts(t);
  const r = Da(e);
  let s = 27 + r.recoveryParam;
  return (
    i !== 0
      ? (t.pop(), t.pop(), t.pop(), (s += i * 2 + 8), r.v > 28 && r.v !== s && xn.throwArgumentError('transaction.chainId/signature.v mismatch', 'signature', e))
      : r.v !== s && xn.throwArgumentError('transaction.chainId/signature.v mismatch', 'signature', e),
    t.push(K(s)),
    t.push(Qi(H(r.r))),
    t.push(Qi(H(r.s))),
    Ts(t)
  );
}
function Oy(n, e) {
  if (n.type == null || n.type === 0) return n.accessList != null && xn.throwArgumentError('untyped transactions do not support accessList; include type: 1', 'transaction', n), w7(n, e);
  switch (n.type) {
    case 1:
      return m6(n, e);
    case 2:
      return h6(n, e);
  }
  return xn.throwError(`unsupported transaction type: ${n.type}`, D.errors.UNSUPPORTED_OPERATION, {
    operation: 'serializeTransaction',
    transactionType: n.type,
  });
}
function b6(n, e, t) {
  try {
    const i = gn(e[0]).toNumber();
    if (i !== 0 && i !== 1) throw new Error('bad recid');
    n.v = i;
  } catch {
    xn.throwArgumentError('invalid v for transaction type: 1', 'v', e[0]);
  }
  (n.r = Le(e[1], 32)), (n.s = Le(e[2], 32));
  try {
    const i = De(t(n));
    n.from = Ho(i, { r: n.r, s: n.s, recoveryParam: n.v });
  } catch {}
}
function A7(n) {
  const e = Dl(n.slice(1));
  e.length !== 9 && e.length !== 12 && xn.throwArgumentError('invalid component count for transaction type: 2', 'payload', K(n));
  const t = gn(e[2]),
    i = gn(e[3]),
    r = {
      type: 2,
      chainId: gn(e[0]).toNumber(),
      nonce: gn(e[1]).toNumber(),
      maxPriorityFeePerGas: t,
      maxFeePerGas: i,
      gasPrice: null,
      gasLimit: gn(e[4]),
      to: S0(e[5]),
      value: gn(e[6]),
      data: e[7],
      accessList: $a(e[8]),
    };
  return e.length === 9 || ((r.hash = De(n)), b6(r, e.slice(9), h6)), r;
}
function E7(n) {
  const e = Dl(n.slice(1));
  e.length !== 8 && e.length !== 11 && xn.throwArgumentError('invalid component count for transaction type: 1', 'payload', K(n));
  const t = {
    type: 1,
    chainId: gn(e[0]).toNumber(),
    nonce: gn(e[1]).toNumber(),
    gasPrice: gn(e[2]),
    gasLimit: gn(e[3]),
    to: S0(e[4]),
    value: gn(e[5]),
    data: e[6],
    accessList: $a(e[7]),
  };
  return e.length === 8 || ((t.hash = De(n)), b6(t, e.slice(8), m6)), t;
}
function S7(n) {
  const e = Dl(n);
  e.length !== 9 && e.length !== 6 && xn.throwArgumentError('invalid raw transaction', 'rawTransaction', n);
  const t = {
    nonce: gn(e[0]).toNumber(),
    gasPrice: gn(e[1]),
    gasLimit: gn(e[2]),
    to: S0(e[3]),
    value: gn(e[4]),
    data: e[5],
    chainId: 0,
  };
  if (e.length === 6) return t;
  try {
    t.v = q.from(e[6]).toNumber();
  } catch {
    return t;
  }
  if (((t.r = Le(e[7], 32)), (t.s = Le(e[8], 32)), q.from(t.r).isZero() && q.from(t.s).isZero())) (t.chainId = t.v), (t.v = 0);
  else {
    (t.chainId = Math.floor((t.v - 35) / 2)), t.chainId < 0 && (t.chainId = 0);
    let i = t.v - 27;
    const r = e.slice(0, 6);
    t.chainId !== 0 && (r.push(K(t.chainId)), r.push('0x'), r.push('0x'), (i -= t.chainId * 2 + 8));
    const s = De(Ts(r));
    try {
      t.from = Ho(s, { r: K(t.r), s: K(t.s), recoveryParam: i });
    } catch {}
    t.hash = De(n);
  }
  return (t.type = null), t;
}
function g6(n) {
  const e = H(n);
  if (e[0] > 127) return S7(e);
  switch (e[0]) {
    case 1:
      return E7(e);
    case 2:
      return A7(e);
  }
  return xn.throwError(`unsupported transaction type: ${e[0]}`, D.errors.UNSUPPORTED_OPERATION, {
    operation: 'parseTransaction',
    transactionType: e[0],
  });
}
const C7 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        get TransactionTypes() {
          return Iy;
        },
        accessListify: $a,
        computeAddress: hs,
        parse: g6,
        recoverAddress: Ho,
        serialize: Oy,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  M7 = 'contracts/5.7.0';
var ba =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
const Bt = new D(M7);
function mc(n, e) {
  return ba(this, void 0, void 0, function* () {
    const t = yield e;
    typeof t != 'string' && Bt.throwArgumentError('invalid address or ENS name', 'name', t);
    try {
      return Fe(t);
    } catch {}
    n ||
      Bt.throwError('a provider or signer is needed to resolve ENS names', D.errors.UNSUPPORTED_OPERATION, {
        operation: 'resolveName',
      });
    const i = yield n.resolveName(t);
    return i == null && Bt.throwArgumentError('resolver or addr is not configured for ENS name', 'name', t), i;
  });
}
function Nd(n, e, t) {
  return ba(this, void 0, void 0, function* () {
    return Array.isArray(t)
      ? yield Promise.all(t.map((i, r) => Nd(n, Array.isArray(e) ? e[r] : e[i.name], i)))
      : t.type === 'address'
      ? yield mc(n, e)
      : t.type === 'tuple'
      ? yield Nd(n, e, t.components)
      : t.baseType === 'array'
      ? Array.isArray(e)
        ? yield Promise.all(e.map((i) => Nd(n, i, t.arrayChildren)))
        : Promise.reject(
            Bt.makeError('invalid value for array', D.errors.INVALID_ARGUMENT, {
              argument: 'value',
              value: e,
            }),
          )
      : e;
  });
}
function rp(n, e, t) {
  return ba(this, void 0, void 0, function* () {
    let i = {};
    t.length === e.inputs.length + 1 && typeof t[t.length - 1] == 'object' && (i = Gt(t.pop())),
      Bt.checkArgumentCount(t.length, e.inputs.length, 'passed to contract'),
      n.signer
        ? i.from
          ? (i.from = Ot({
              override: mc(n.signer, i.from),
              signer: n.signer.getAddress(),
            }).then((l) =>
              ba(this, void 0, void 0, function* () {
                return (
                  Fe(l.signer) !== l.override &&
                    Bt.throwError('Contract with a Signer cannot override from', D.errors.UNSUPPORTED_OPERATION, {
                      operation: 'overrides.from',
                    }),
                  l.override
                );
              }),
            ))
          : (i.from = n.signer.getAddress())
        : i.from && (i.from = mc(n.provider, i.from));
    const r = yield Ot({
        args: Nd(n.signer || n.provider, t, e.inputs),
        address: n.resolvedAddress,
        overrides: Ot(i) || {},
      }),
      s = n.interface.encodeFunctionData(e, r.args),
      a = {
        data: s,
        to: r.address,
      },
      o = r.overrides;
    if (
      (o.nonce != null && (a.nonce = q.from(o.nonce).toNumber()),
      o.gasLimit != null && (a.gasLimit = q.from(o.gasLimit)),
      o.gasPrice != null && (a.gasPrice = q.from(o.gasPrice)),
      o.maxFeePerGas != null && (a.maxFeePerGas = q.from(o.maxFeePerGas)),
      o.maxPriorityFeePerGas != null && (a.maxPriorityFeePerGas = q.from(o.maxPriorityFeePerGas)),
      o.from != null && (a.from = o.from),
      o.type != null && (a.type = o.type),
      o.accessList != null && (a.accessList = $a(o.accessList)),
      a.gasLimit == null && e.gas != null)
    ) {
      let l = 21e3;
      const c = H(s);
      for (let f = 0; f < c.length; f++) (l += 4), c[f] && (l += 64);
      a.gasLimit = q.from(e.gas).add(l);
    }
    if (o.value) {
      const l = q.from(o.value);
      !l.isZero() &&
        !e.payable &&
        Bt.throwError('non-payable method cannot override value', D.errors.UNSUPPORTED_OPERATION, {
          operation: 'overrides.value',
          value: i.value,
        }),
        (a.value = l);
    }
    o.customData && (a.customData = Gt(o.customData)),
      o.ccipReadEnabled && (a.ccipReadEnabled = !!o.ccipReadEnabled),
      delete i.nonce,
      delete i.gasLimit,
      delete i.gasPrice,
      delete i.from,
      delete i.value,
      delete i.type,
      delete i.accessList,
      delete i.maxFeePerGas,
      delete i.maxPriorityFeePerGas,
      delete i.customData,
      delete i.ccipReadEnabled;
    const u = Object.keys(i).filter((l) => i[l] != null);
    return (
      u.length &&
        Bt.throwError(`cannot override ${u.map((l) => JSON.stringify(l)).join(',')}`, D.errors.UNSUPPORTED_OPERATION, {
          operation: 'overrides',
          overrides: u,
        }),
      a
    );
  });
}
function _7(n, e) {
  return function (...t) {
    return rp(n, e, t);
  };
}
function R7(n, e) {
  const t = n.signer || n.provider;
  return function (...i) {
    return ba(this, void 0, void 0, function* () {
      t ||
        Bt.throwError('estimate require a provider or signer', D.errors.UNSUPPORTED_OPERATION, {
          operation: 'estimateGas',
        });
      const r = yield rp(n, e, i);
      return yield t.estimateGas(r);
    });
  };
}
function I7(n, e) {
  const t = e.wait.bind(e);
  e.wait = (i) =>
    t(i).then(
      (r) => (
        (r.events = r.logs.map((s) => {
          let a = xs(s),
            o = null;
          try {
            o = n.interface.parseLog(s);
          } catch {}
          return (
            o && ((a.args = o.args), (a.decode = (u, l) => n.interface.decodeEventLog(o.eventFragment, u, l)), (a.event = o.name), (a.eventSignature = o.signature)),
            (a.removeListener = () => n.provider),
            (a.getBlock = () => n.provider.getBlock(r.blockHash)),
            (a.getTransaction = () => n.provider.getTransaction(r.transactionHash)),
            (a.getTransactionReceipt = () => Promise.resolve(r)),
            a
          );
        })),
        r
      ),
    );
}
function v6(n, e, t) {
  const i = n.signer || n.provider;
  return function (...r) {
    return ba(this, void 0, void 0, function* () {
      let s;
      if (r.length === e.inputs.length + 1 && typeof r[r.length - 1] == 'object') {
        const u = Gt(r.pop());
        u.blockTag != null && (s = yield u.blockTag), delete u.blockTag, r.push(u);
      }
      n.deployTransaction != null && (yield n._deployed(s));
      const a = yield rp(n, e, r),
        o = yield i.call(a, s);
      try {
        let u = n.interface.decodeFunctionResult(e, o);
        return t && e.outputs.length === 1 && (u = u[0]), u;
      } catch (u) {
        throw (u.code === D.errors.CALL_EXCEPTION && ((u.address = n.address), (u.args = r), (u.transaction = a)), u);
      }
    });
  };
}
function O7(n, e) {
  return function (...t) {
    return ba(this, void 0, void 0, function* () {
      n.signer ||
        Bt.throwError('sending a transaction requires a signer', D.errors.UNSUPPORTED_OPERATION, {
          operation: 'sendTransaction',
        }),
        n.deployTransaction != null && (yield n._deployed());
      const i = yield rp(n, e, t),
        r = yield n.signer.sendTransaction(i);
      return I7(n, r), r;
    });
  };
}
function p2(n, e, t) {
  return e.constant ? v6(n, e, t) : O7(n, e);
}
function x6(n) {
  return n.address && (n.topics == null || n.topics.length === 0) ? '*' : (n.address || '*') + '@' + (n.topics ? n.topics.map((e) => (Array.isArray(e) ? e.join('|') : e)).join(':') : '');
}
class Yu {
  constructor(e, t) {
    j(this, 'tag', e), j(this, 'filter', t), (this._listeners = []);
  }
  addListener(e, t) {
    this._listeners.push({ listener: e, once: t });
  }
  removeListener(e) {
    let t = !1;
    this._listeners = this._listeners.filter((i) => (t || i.listener !== e ? !0 : ((t = !0), !1)));
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((e) => e.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(e) {
    const t = this.listenerCount();
    return (
      (this._listeners = this._listeners.filter((i) => {
        const r = e.slice();
        return (
          setTimeout(() => {
            i.listener.apply(this, r);
          }, 0),
          !i.once
        );
      })),
      t
    );
  }
  prepareEvent(e) {}
  // Returns the array that will be applied to an emit
  getEmit(e) {
    return [e];
  }
}
class k7 extends Yu {
  constructor() {
    super('error', null);
  }
}
class f2 extends Yu {
  constructor(e, t, i, r) {
    const s = {
      address: e,
    };
    let a = t.getEventTopic(i);
    r ? (a !== r[0] && Bt.throwArgumentError('topic mismatch', 'topics', r), (s.topics = r.slice())) : (s.topics = [a]),
      super(x6(s), s),
      j(this, 'address', e),
      j(this, 'interface', t),
      j(this, 'fragment', i);
  }
  prepareEvent(e) {
    super.prepareEvent(e), (e.event = this.fragment.name), (e.eventSignature = this.fragment.format()), (e.decode = (t, i) => this.interface.decodeEventLog(this.fragment, t, i));
    try {
      e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics);
    } catch (t) {
      (e.args = null), (e.decodeError = t);
    }
  }
  getEmit(e) {
    const t = fT(e.args);
    if (t.length) throw t[0].error;
    const i = (e.args || []).slice();
    return i.push(e), i;
  }
}
class y2 extends Yu {
  constructor(e, t) {
    super('*', { address: e }), j(this, 'address', e), j(this, 'interface', t);
  }
  prepareEvent(e) {
    super.prepareEvent(e);
    try {
      const t = this.interface.parseLog(e);
      (e.event = t.name), (e.eventSignature = t.signature), (e.decode = (i, r) => this.interface.decodeEventLog(t.eventFragment, i, r)), (e.args = t.args);
    } catch {}
  }
}
class P7 {
  constructor(e, t, i) {
    j(this, 'interface', Oi(new.target, 'getInterface')(t)),
      i == null
        ? (j(this, 'provider', null), j(this, 'signer', null))
        : Fa.isSigner(i)
        ? (j(this, 'provider', i.provider || null), j(this, 'signer', i))
        : v0.isProvider(i)
        ? (j(this, 'provider', i), j(this, 'signer', null))
        : Bt.throwArgumentError('invalid signer or provider', 'signerOrProvider', i),
      j(this, 'callStatic', {}),
      j(this, 'estimateGas', {}),
      j(this, 'functions', {}),
      j(this, 'populateTransaction', {}),
      j(this, 'filters', {});
    {
      const a = {};
      Object.keys(this.interface.events).forEach((o) => {
        const u = this.interface.events[o];
        j(this.filters, o, (...l) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(u, l),
        })),
          a[u.name] || (a[u.name] = []),
          a[u.name].push(o);
      }),
        Object.keys(a).forEach((o) => {
          const u = a[o];
          u.length === 1 ? j(this.filters, o, this.filters[u[0]]) : Bt.warn(`Duplicate definition of ${o} (${u.join(', ')})`);
        });
    }
    if (
      (j(this, '_runningEvents', {}),
      j(this, '_wrappedEmits', {}),
      e == null && Bt.throwArgumentError('invalid contract address or ENS name', 'addressOrName', e),
      j(this, 'address', e),
      this.provider)
    )
      j(this, 'resolvedAddress', mc(this.provider, e));
    else
      try {
        j(this, 'resolvedAddress', Promise.resolve(Fe(e)));
      } catch {
        Bt.throwError('provider is required to use ENS name as contract address', D.errors.UNSUPPORTED_OPERATION, {
          operation: 'new Contract',
        });
      }
    this.resolvedAddress.catch((a) => {});
    const r = {},
      s = {};
    Object.keys(this.interface.functions).forEach((a) => {
      const o = this.interface.functions[a];
      if (s[a]) {
        Bt.warn(`Duplicate ABI entry for ${JSON.stringify(a)}`);
        return;
      }
      s[a] = !0;
      {
        const u = o.name;
        r[`%${u}`] || (r[`%${u}`] = []), r[`%${u}`].push(a);
      }
      this[a] == null && j(this, a, p2(this, o, !0)),
        this.functions[a] == null && j(this.functions, a, p2(this, o, !1)),
        this.callStatic[a] == null && j(this.callStatic, a, v6(this, o, !0)),
        this.populateTransaction[a] == null && j(this.populateTransaction, a, _7(this, o)),
        this.estimateGas[a] == null && j(this.estimateGas, a, R7(this, o));
    }),
      Object.keys(r).forEach((a) => {
        const o = r[a];
        if (o.length > 1) return;
        a = a.substring(1);
        const u = o[0];
        try {
          this[a] == null && j(this, a, this[u]);
        } catch {}
        this.functions[a] == null && j(this.functions, a, this.functions[u]),
          this.callStatic[a] == null && j(this.callStatic, a, this.callStatic[u]),
          this.populateTransaction[a] == null && j(this.populateTransaction, a, this.populateTransaction[u]),
          this.estimateGas[a] == null && j(this.estimateGas, a, this.estimateGas[u]);
      });
  }
  static getContractAddress(e) {
    return c0(e);
  }
  static getInterface(e) {
    return Ey.isInterface(e) ? e : new Ey(e);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(e) {
    return (
      this._deployedPromise ||
        (this.deployTransaction
          ? (this._deployedPromise = this.deployTransaction.wait().then(() => this))
          : (this._deployedPromise = this.provider.getCode(this.address, e).then(
              (t) => (
                t === '0x' &&
                  Bt.throwError('contract not deployed', D.errors.UNSUPPORTED_OPERATION, {
                    contractAddress: this.address,
                    operation: 'getDeployed',
                  }),
                this
              ),
            ))),
      this._deployedPromise
    );
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(e) {
    this.signer || Bt.throwError('sending a transactions require a signer', D.errors.UNSUPPORTED_OPERATION, { operation: 'sendTransaction(fallback)' });
    const t = Gt(e || {});
    return (
      ['from', 'to'].forEach(function (i) {
        t[i] != null && Bt.throwError('cannot override ' + i, D.errors.UNSUPPORTED_OPERATION, { operation: i });
      }),
      (t.to = this.resolvedAddress),
      this.deployed().then(() => this.signer.sendTransaction(t))
    );
  }
  // Reconnect to a different signer or provider
  connect(e) {
    typeof e == 'string' && (e = new x0(e, this.provider));
    const t = new this.constructor(this.address, this.interface, e);
    return this.deployTransaction && j(t, 'deployTransaction', this.deployTransaction), t;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(e) {
    return new this.constructor(e, this.interface, this.signer || this.provider);
  }
  static isIndexed(e) {
    return fc.isIndexed(e);
  }
  _normalizeRunningEvent(e) {
    return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e;
  }
  _getRunningEvent(e) {
    if (typeof e == 'string') {
      if (e === 'error') return this._normalizeRunningEvent(new k7());
      if (e === 'event') return this._normalizeRunningEvent(new Yu('event', null));
      if (e === '*') return this._normalizeRunningEvent(new y2(this.address, this.interface));
      const t = this.interface.getEvent(e);
      return this._normalizeRunningEvent(new f2(this.address, this.interface, t));
    }
    if (e.topics && e.topics.length > 0) {
      try {
        const i = e.topics[0];
        if (typeof i != 'string') throw new Error('invalid topic');
        const r = this.interface.getEvent(i);
        return this._normalizeRunningEvent(new f2(this.address, this.interface, r, e.topics));
      } catch {}
      const t = {
        address: this.address,
        topics: e.topics,
      };
      return this._normalizeRunningEvent(new Yu(x6(t), t));
    }
    return this._normalizeRunningEvent(new y2(this.address, this.interface));
  }
  _checkRunningEvents(e) {
    if (e.listenerCount() === 0) {
      delete this._runningEvents[e.tag];
      const t = this._wrappedEmits[e.tag];
      t && e.filter && (this.provider.off(e.filter, t), delete this._wrappedEmits[e.tag]);
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(e, t, i) {
    const r = xs(t);
    return (
      (r.removeListener = () => {
        i && (e.removeListener(i), this._checkRunningEvents(e));
      }),
      (r.getBlock = () => this.provider.getBlock(t.blockHash)),
      (r.getTransaction = () => this.provider.getTransaction(t.transactionHash)),
      (r.getTransactionReceipt = () => this.provider.getTransactionReceipt(t.transactionHash)),
      e.prepareEvent(r),
      r
    );
  }
  _addEventListener(e, t, i) {
    if (
      (this.provider || Bt.throwError('events require a provider or a signer with a provider', D.errors.UNSUPPORTED_OPERATION, { operation: 'once' }),
      e.addListener(t, i),
      (this._runningEvents[e.tag] = e),
      !this._wrappedEmits[e.tag])
    ) {
      const r = (s) => {
        let a = this._wrapEvent(e, s, t);
        if (a.decodeError == null)
          try {
            const o = e.getEmit(a);
            this.emit(e.filter, ...o);
          } catch (o) {
            a.decodeError = o.error;
          }
        e.filter != null && this.emit('event', a), a.decodeError != null && this.emit('error', a.decodeError, a);
      };
      (this._wrappedEmits[e.tag] = r), e.filter != null && this.provider.on(e.filter, r);
    }
  }
  queryFilter(e, t, i) {
    const r = this._getRunningEvent(e),
      s = Gt(r.filter);
    return (
      typeof t == 'string' && Me(t, 32)
        ? (i != null && Bt.throwArgumentError('cannot specify toBlock with blockhash', 'toBlock', i), (s.blockHash = t))
        : ((s.fromBlock = t ?? 0), (s.toBlock = i ?? 'latest')),
      this.provider.getLogs(s).then((a) => a.map((o) => this._wrapEvent(r, o, null)))
    );
  }
  on(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !1), this;
  }
  once(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !0), this;
  }
  emit(e, ...t) {
    if (!this.provider) return !1;
    const i = this._getRunningEvent(e),
      r = i.run(t) > 0;
    return this._checkRunningEvents(i), r;
  }
  listenerCount(e) {
    return this.provider ? (e == null ? Object.keys(this._runningEvents).reduce((t, i) => t + this._runningEvents[i].listenerCount(), 0) : this._getRunningEvent(e).listenerCount()) : 0;
  }
  listeners(e) {
    if (!this.provider) return [];
    if (e == null) {
      const t = [];
      for (let i in this._runningEvents)
        this._runningEvents[i].listeners().forEach((r) => {
          t.push(r);
        });
      return t;
    }
    return this._getRunningEvent(e).listeners();
  }
  removeAllListeners(e) {
    if (!this.provider) return this;
    if (e == null) {
      for (const i in this._runningEvents) {
        const r = this._runningEvents[i];
        r.removeAllListeners(), this._checkRunningEvents(r);
      }
      return this;
    }
    const t = this._getRunningEvent(e);
    return t.removeAllListeners(), this._checkRunningEvents(t), this;
  }
  off(e, t) {
    if (!this.provider) return this;
    const i = this._getRunningEvent(e);
    return i.removeListener(t), this._checkRunningEvents(i), this;
  }
  removeListener(e, t) {
    return this.off(e, t);
  }
}
class T6 extends P7 {}
class C0 {
  constructor(e) {
    j(this, 'alphabet', e), j(this, 'base', e.length), j(this, '_alphabetMap', {}), j(this, '_leader', e.charAt(0));
    for (let t = 0; t < e.length; t++) this._alphabetMap[e.charAt(t)] = t;
  }
  encode(e) {
    let t = H(e);
    if (t.length === 0) return '';
    let i = [0];
    for (let s = 0; s < t.length; ++s) {
      let a = t[s];
      for (let o = 0; o < i.length; ++o) (a += i[o] << 8), (i[o] = a % this.base), (a = (a / this.base) | 0);
      for (; a > 0; ) i.push(a % this.base), (a = (a / this.base) | 0);
    }
    let r = '';
    for (let s = 0; t[s] === 0 && s < t.length - 1; ++s) r += this._leader;
    for (let s = i.length - 1; s >= 0; --s) r += this.alphabet[i[s]];
    return r;
  }
  decode(e) {
    if (typeof e != 'string') throw new TypeError('Expected String');
    let t = [];
    if (e.length === 0) return new Uint8Array(t);
    t.push(0);
    for (let i = 0; i < e.length; i++) {
      let r = this._alphabetMap[e[i]];
      if (r === void 0) throw new Error('Non-base' + this.base + ' character');
      let s = r;
      for (let a = 0; a < t.length; ++a) (s += t[a] * this.base), (t[a] = s & 255), (s >>= 8);
      for (; s > 0; ) t.push(s & 255), (s >>= 8);
    }
    for (let i = 0; e[i] === this._leader && i < e.length - 1; ++i) t.push(0);
    return H(new Uint8Array(t.reverse()));
  }
}
const N7 = new C0('abcdefghijklmnopqrstuvwxyz234567'),
  Ao = new C0('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'),
  D7 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        Base32: N7,
        Base58: Ao,
        BaseX: C0,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  );
var Eo;
(function (n) {
  (n.sha256 = 'sha256'), (n.sha512 = 'sha512');
})(Eo || (Eo = {}));
const B7 = 'sha2/5.7.0',
  F7 = new D(B7);
function w6(n) {
  return '0x' + Sn.ripemd160().update(H(n)).digest('hex');
}
function Fr(n) {
  return '0x' + Sn.sha256().update(H(n)).digest('hex');
}
function L7(n) {
  return '0x' + Sn.sha512().update(H(n)).digest('hex');
}
function Xu(n, e, t) {
  return (
    Eo[n] ||
      F7.throwError('unsupported algorithm ' + n, D.errors.UNSUPPORTED_OPERATION, {
        operation: 'hmac',
        algorithm: n,
      }),
    '0x' + Sn.hmac(Sn[n], H(e)).update(H(t)).digest('hex')
  );
}
const $7 = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      get SupportedAlgorithm() {
        return Eo;
      },
      computeHmac: Xu,
      ripemd160: w6,
      sha256: Fr,
      sha512: L7,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
function M0(n, e, t, i, r) {
  (n = H(n)), (e = H(e));
  let s,
    a = 1;
  const o = new Uint8Array(i),
    u = new Uint8Array(e.length + 4);
  u.set(e);
  let l, c;
  for (let f = 1; f <= a; f++) {
    (u[e.length] = (f >> 24) & 255), (u[e.length + 1] = (f >> 16) & 255), (u[e.length + 2] = (f >> 8) & 255), (u[e.length + 3] = f & 255);
    let m = H(Xu(r, n, u));
    s || ((s = m.length), (c = new Uint8Array(s)), (a = Math.ceil(i / s)), (l = i - (a - 1) * s)), c.set(m);
    for (let T = 1; T < t; T++) {
      m = H(Xu(r, n, m));
      for (let A = 0; A < s; A++) c[A] ^= m[A];
    }
    const w = (f - 1) * s,
      v = f === a ? l : s;
    o.set(H(c).slice(0, v), w);
  }
  return K(o);
}
const U7 = 'wordlists/5.7.0',
  j7 = new D(U7);
class Fl {
  constructor(e) {
    j7.checkAbstract(new.target, Fl), j(this, 'locale', e);
  }
  // Subclasses may override this
  split(e) {
    return e.toLowerCase().split(/ +/g);
  }
  // Subclasses may override this
  join(e) {
    return e.join(' ');
  }
  static check(e) {
    const t = [];
    for (let i = 0; i < 2048; i++) {
      const r = e.getWord(i);
      if (i !== e.getWordIndex(r)) return '0x';
      t.push(r);
    }
    return cs(
      t.join(`
`) +
        `
`,
    );
  }
  static register(e, t) {
    t || (t = e.locale);
  }
}
const V7 =
  'AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo';
let Mu = null;
function h2(n) {
  if (
    Mu == null &&
    ((Mu = V7.replace(/([A-Z])/g, ' $1')
      .toLowerCase()
      .substring(1)
      .split(' ')),
    Fl.check(n) !== '0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60')
  )
    throw ((Mu = null), new Error('BIP39 Wordlist for en (English) FAILED'));
}
class z7 extends Fl {
  constructor() {
    super('en');
  }
  getWord(e) {
    return h2(this), Mu[e];
  }
  getWordIndex(e) {
    return h2(this), Mu.indexOf(e);
  }
}
const A6 = new z7();
Fl.register(A6);
const m2 = {
    en: A6,
  },
  G7 = 'hdnode/5.7.0',
  Zu = new D(G7),
  q7 = q.from('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
  H7 = $t('Bitcoin seed'),
  Xa = 2147483648;
function E6(n) {
  return ((1 << n) - 1) << (8 - n);
}
function K7(n) {
  return (1 << n) - 1;
}
function ld(n) {
  return Le(K(n), 32);
}
function b2(n) {
  return Ao.encode(Ge([n, Lt(Fr(Fr(n)), 0, 4)]));
}
function _0(n) {
  if (n == null) return m2.en;
  if (typeof n == 'string') {
    const e = m2[n];
    return e == null && Zu.throwArgumentError('unknown locale', 'wordlist', n), e;
  }
  return n;
}
const Va = {},
  So = "m/44'/60'/0'/0/0";
class Yn {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(e, t, i, r, s, a, o, u) {
    if (e !== Va) throw new Error('HDNode constructor cannot be called directly');
    if (t) {
      const l = new ua(t);
      j(this, 'privateKey', l.privateKey), j(this, 'publicKey', l.compressedPublicKey);
    } else j(this, 'privateKey', null), j(this, 'publicKey', K(i));
    j(this, 'parentFingerprint', r),
      j(this, 'fingerprint', Lt(w6(Fr(this.publicKey)), 0, 4)),
      j(this, 'address', hs(this.publicKey)),
      j(this, 'chainCode', s),
      j(this, 'index', a),
      j(this, 'depth', o),
      u == null ? (j(this, 'mnemonic', null), j(this, 'path', null)) : typeof u == 'string' ? (j(this, 'mnemonic', null), j(this, 'path', u)) : (j(this, 'mnemonic', u), j(this, 'path', u.path));
  }
  get extendedKey() {
    if (this.depth >= 256) throw new Error('Depth too large!');
    return b2(
      Ge([
        this.privateKey != null ? '0x0488ADE4' : '0x0488B21E',
        K(this.depth),
        this.parentFingerprint,
        Le(K(this.index), 4),
        this.chainCode,
        this.privateKey != null ? Ge(['0x00', this.privateKey]) : this.publicKey,
      ]),
    );
  }
  neuter() {
    return new Yn(Va, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(e) {
    if (e > 4294967295) throw new Error('invalid index - ' + String(e));
    let t = this.path;
    t && (t += '/' + (e & ~Xa));
    const i = new Uint8Array(37);
    if (e & Xa) {
      if (!this.privateKey) throw new Error('cannot derive child of neutered node');
      i.set(H(this.privateKey), 1), t && (t += "'");
    } else i.set(H(this.publicKey));
    for (let f = 24; f >= 0; f -= 8) i[33 + (f >> 3)] = (e >> (24 - f)) & 255;
    const r = H(Xu(Eo.sha512, this.chainCode, i)),
      s = r.slice(0, 32),
      a = r.slice(32);
    let o = null,
      u = null;
    this.privateKey ? (o = ld(q.from(s).add(this.privateKey).mod(q7))) : (u = new ua(K(s))._addPoint(this.publicKey));
    let l = t;
    const c = this.mnemonic;
    return (
      c &&
        (l = Object.freeze({
          phrase: c.phrase,
          path: t,
          locale: c.locale || 'en',
        })),
      new Yn(Va, o, u, this.fingerprint, ld(a), e, this.depth + 1, l)
    );
  }
  derivePath(e) {
    const t = e.split('/');
    if (t.length === 0 || (t[0] === 'm' && this.depth !== 0)) throw new Error('invalid path - ' + e);
    t[0] === 'm' && t.shift();
    let i = this;
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      if (s.match(/^[0-9]+'$/)) {
        const a = parseInt(s.substring(0, s.length - 1));
        if (a >= Xa) throw new Error('invalid path index - ' + s);
        i = i._derive(Xa + a);
      } else if (s.match(/^[0-9]+$/)) {
        const a = parseInt(s);
        if (a >= Xa) throw new Error('invalid path index - ' + s);
        i = i._derive(a);
      } else throw new Error('invalid path component - ' + s);
    }
    return i;
  }
  static _fromSeed(e, t) {
    const i = H(e);
    if (i.length < 16 || i.length > 64) throw new Error('invalid seed');
    const r = H(Xu(Eo.sha512, H7, i));
    return new Yn(Va, ld(r.slice(0, 32)), null, '0x00000000', ld(r.slice(32)), 0, 0, t);
  }
  static fromMnemonic(e, t, i) {
    return (
      (i = _0(i)),
      (e = ap(sp(e, i), i)),
      Yn._fromSeed(S6(e, t), {
        phrase: e,
        path: 'm',
        locale: i.locale,
      })
    );
  }
  static fromSeed(e) {
    return Yn._fromSeed(e, null);
  }
  static fromExtendedKey(e) {
    const t = Ao.decode(e);
    (t.length !== 82 || b2(t.slice(0, 78)) !== e) && Zu.throwArgumentError('invalid extended key', 'extendedKey', '[REDACTED]');
    const i = t[4],
      r = K(t.slice(5, 9)),
      s = parseInt(K(t.slice(9, 13)).substring(2), 16),
      a = K(t.slice(13, 45)),
      o = t.slice(45, 78);
    switch (K(t.slice(0, 4))) {
      case '0x0488b21e':
      case '0x043587cf':
        return new Yn(Va, null, K(o), r, a, s, i, null);
      case '0x0488ade4':
      case '0x04358394 ':
        if (o[0] !== 0) break;
        return new Yn(Va, K(o.slice(1)), null, r, a, s, i, null);
    }
    return Zu.throwArgumentError('invalid extended key', 'extendedKey', '[REDACTED]');
  }
}
function S6(n, e) {
  e || (e = '');
  const t = $t('mnemonic' + e, ir.NFKD);
  return M0($t(n, ir.NFKD), t, 2048, 64, 'sha512');
}
function sp(n, e) {
  (e = _0(e)), Zu.checkNormalize();
  const t = e.split(n);
  if (t.length % 3 !== 0) throw new Error('invalid mnemonic');
  const i = H(new Uint8Array(Math.ceil((11 * t.length) / 8)));
  let r = 0;
  for (let l = 0; l < t.length; l++) {
    let c = e.getWordIndex(t[l].normalize('NFKD'));
    if (c === -1) throw new Error('invalid mnemonic');
    for (let f = 0; f < 11; f++) c & (1 << (10 - f)) && (i[r >> 3] |= 1 << (7 - (r % 8))), r++;
  }
  const s = (32 * t.length) / 3,
    a = t.length / 3,
    o = E6(a);
  if ((H(Fr(i.slice(0, s / 8)))[0] & o) !== (i[i.length - 1] & o)) throw new Error('invalid checksum');
  return K(i.slice(0, s / 8));
}
function ap(n, e) {
  if (((e = _0(e)), (n = H(n)), n.length % 4 !== 0 || n.length < 16 || n.length > 32)) throw new Error('invalid entropy');
  const t = [0];
  let i = 11;
  for (let a = 0; a < n.length; a++)
    i > 8 ? ((t[t.length - 1] <<= 8), (t[t.length - 1] |= n[a]), (i -= 8)) : ((t[t.length - 1] <<= i), (t[t.length - 1] |= n[a] >> (8 - i)), t.push(n[a] & K7(8 - i)), (i += 3));
  const r = n.length / 4,
    s = H(Fr(n))[0] & E6(r);
  return (t[t.length - 1] <<= r), (t[t.length - 1] |= s >> (8 - r)), e.join(t.map((a) => e.getWord(a)));
}
function W7(n, e) {
  try {
    return sp(n, e), !0;
  } catch {}
  return !1;
}
function J7(n) {
  return (typeof n != 'number' || n < 0 || n >= Xa || n % 1) && Zu.throwArgumentError('invalid account index', 'index', n), `m/44'/60'/${n}'/0/0`;
}
const Q7 = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        HDNode: Yn,
        defaultPath: So,
        entropyToMnemonic: ap,
        getAccountPath: J7,
        isValidMnemonic: W7,
        mnemonicToEntropy: sp,
        mnemonicToSeed: S6,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  Y7 = 'random/5.7.0',
  ky = new D(Y7);
function X7() {
  if (typeof self < 'u') return self;
  if (typeof window < 'u') return window;
  if (typeof ha < 'u') return ha;
  throw new Error('unable to locate global object');
}
const g2 = X7();
let Dd = g2.crypto || g2.msCrypto;
(!Dd || !Dd.getRandomValues) &&
  (ky.warn('WARNING: Missing strong random number source'),
  (Dd = {
    getRandomValues: function (n) {
      return ky.throwError('no secure random source avaialble', D.errors.UNSUPPORTED_OPERATION, {
        operation: 'crypto.getRandomValues',
      });
    },
  }));
function so(n) {
  (n <= 0 || n > 1024 || n % 1 || n != n) && ky.throwArgumentError('invalid length', 'length', n);
  const e = new Uint8Array(n);
  return Dd.getRandomValues(e), H(e);
}
function Z7(n) {
  n = n.slice();
  for (let e = n.length - 1; e > 0; e--) {
    const t = Math.floor(Math.random() * (e + 1)),
      i = n[e];
    (n[e] = n[t]), (n[t] = i);
  }
  return n;
}
const eR = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      randomBytes: so,
      shuffled: Z7,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
var Py = {},
  tR = {
    get exports() {
      return Py;
    },
    set exports(n) {
      Py = n;
    },
  };
(function (n, e) {
  (function (t) {
    function i(b) {
      return parseInt(b) === b;
    }
    function r(b) {
      if (!i(b.length)) return !1;
      for (var p = 0; p < b.length; p++) if (!i(b[p]) || b[p] < 0 || b[p] > 255) return !1;
      return !0;
    }
    function s(b, p) {
      if (b.buffer && ArrayBuffer.isView(b) && b.name === 'Uint8Array') return p && (b.slice ? (b = b.slice()) : (b = Array.prototype.slice.call(b))), b;
      if (Array.isArray(b)) {
        if (!r(b)) throw new Error('Array contains invalid value: ' + b);
        return new Uint8Array(b);
      }
      if (i(b.length) && r(b)) return new Uint8Array(b);
      throw new Error('unsupported array-like object');
    }
    function a(b) {
      return new Uint8Array(b);
    }
    function o(b, p, x, k, h) {
      (k != null || h != null) && (b.slice ? (b = b.slice(k, h)) : (b = Array.prototype.slice.call(b, k, h))), p.set(b, x);
    }
    var u = (function () {
        function b(x) {
          var k = [],
            h = 0;
          for (x = encodeURI(x); h < x.length; ) {
            var R = x.charCodeAt(h++);
            R === 37 ? (k.push(parseInt(x.substr(h, 2), 16)), (h += 2)) : k.push(R);
          }
          return s(k);
        }
        function p(x) {
          for (var k = [], h = 0; h < x.length; ) {
            var R = x[h];
            R < 128
              ? (k.push(String.fromCharCode(R)), h++)
              : R > 191 && R < 224
              ? (k.push(String.fromCharCode(((R & 31) << 6) | (x[h + 1] & 63))), (h += 2))
              : (k.push(String.fromCharCode(((R & 15) << 12) | ((x[h + 1] & 63) << 6) | (x[h + 2] & 63))), (h += 3));
          }
          return k.join('');
        }
        return {
          toBytes: b,
          fromBytes: p,
        };
      })(),
      l = (function () {
        function b(k) {
          for (var h = [], R = 0; R < k.length; R += 2) h.push(parseInt(k.substr(R, 2), 16));
          return h;
        }
        var p = '0123456789abcdef';
        function x(k) {
          for (var h = [], R = 0; R < k.length; R++) {
            var L = k[R];
            h.push(p[(L & 240) >> 4] + p[L & 15]);
          }
          return h.join('');
        }
        return {
          toBytes: b,
          fromBytes: x,
        };
      })(),
      c = { 16: 10, 24: 12, 32: 14 },
      f = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145],
      m = [
        99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204,
        52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0,
        237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16,
        255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92,
        194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138,
        112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65,
        153, 45, 15, 176, 84, 187, 22,
      ],
      w = [
        82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76,
        149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72,
        80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19,
        138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197,
        137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96,
        81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20,
        99, 85, 33, 12, 125,
      ],
      v = [
        3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586,
        2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635,
        1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767,
        134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367,
        302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799,
        2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746,
        3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483,
        2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685,
        2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909,
        3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934,
        3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243,
        3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816,
        1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669,
        3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745,
        3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378,
        59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986,
      ],
      T = [
        2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086,
        1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080,
        3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517,
        201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837,
        454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724,
        4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800,
        717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137,
        4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245,
        337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144,
        2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696,
        1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335,
        1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306,
        2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952,
        1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233,
        334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476,
        4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766,
      ],
      A = [
        1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566,
        3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120,
        3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077,
        67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517,
        152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444,
        1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360,
        4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297,
        2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245,
        202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744,
        2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296,
        844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455,
        3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946,
        2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832,
        1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393,
        4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796,
        2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126,
      ],
      _ = [
        1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396,
        3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835,
        3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962,
        67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922,
        151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939,
        1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995,
        4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282,
        2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745,
        202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344,
        2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771,
        842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725,
        3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511,
        2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312,
        1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753,
        4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891,
        2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436,
      ],
      O = [
        1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495,
        3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676,
        1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228,
        1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356,
        2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961,
        1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483,
        2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497,
        2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501,
        2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733,
        3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455,
        3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150,
        1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889,
        1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685,
        1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476,
        933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769,
        3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890,
      ],
      B = [
        1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155,
        1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456,
        1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523,
        1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666,
        730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976,
        4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598,
        1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327,
        261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081,
        1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268,
        4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110,
        3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200,
        2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859,
        3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630,
        1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921,
        2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179,
        1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935,
      ],
      P = [
        2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290,
        1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201,
        2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368,
        1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086,
        472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366,
        2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968,
        172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202,
        3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201,
        122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898,
        1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145,
        3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285,
        2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639,
        919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085,
        2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631,
        209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519,
        3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600,
      ],
      N = [
        4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325,
        2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166,
        3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913,
        1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221,
        3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261,
        562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953,
        2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692,
        1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591,
        1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413,
        3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655,
        953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495,
        3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714,
        1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550,
        4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426,
        2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274,
        1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480,
      ],
      U = [
        0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992,
        4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923,
        3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995,
        899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766,
        2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366,
        1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685,
        2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453,
        2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591,
        1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871,
        2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476,
        2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780,
        1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369,
        3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497,
        33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370,
        967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226,
        3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795,
      ],
      W = [
        0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152,
        3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243,
        1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355,
        3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181,
        4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461,
        1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630,
        2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158,
        915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826,
        4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386,
        1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921,
        2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705,
        930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319,
        182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327,
        3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060,
        1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636,
        3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855,
      ],
      z = [
        0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752,
        3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443,
        3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195,
        1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806,
        1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286,
        2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085,
        3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613,
        188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356,
        3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556,
        122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631,
        1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695,
        3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634,
        3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202,
        1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544,
        376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200,
        3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150,
      ],
      Y = [
        0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872,
        2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683,
        850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315,
        2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061,
        2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981,
        4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550,
        1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718,
        3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121,
        3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481,
        1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426,
        3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690,
        1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844,
        2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692,
        57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495,
        2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431,
        953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925,
      ];
    function ue(b) {
      for (var p = [], x = 0; x < b.length; x += 4) p.push((b[x] << 24) | (b[x + 1] << 16) | (b[x + 2] << 8) | b[x + 3]);
      return p;
    }
    var J = function (b) {
      if (!(this instanceof J)) throw Error('AES must be instanitated with `new`');
      Object.defineProperty(this, 'key', {
        value: s(b, !0),
      }),
        this._prepare();
    };
    (J.prototype._prepare = function () {
      var b = c[this.key.length];
      if (b == null) throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
      (this._Ke = []), (this._Kd = []);
      for (var p = 0; p <= b; p++) this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (var x = (b + 1) * 4, k = this.key.length / 4, h = ue(this.key), R, p = 0; p < k; p++) (R = p >> 2), (this._Ke[R][p % 4] = h[p]), (this._Kd[b - R][p % 4] = h[p]);
      for (var L = 0, F = k, $; F < x; ) {
        if ((($ = h[k - 1]), (h[0] ^= (m[($ >> 16) & 255] << 24) ^ (m[($ >> 8) & 255] << 16) ^ (m[$ & 255] << 8) ^ m[($ >> 24) & 255] ^ (f[L] << 24)), (L += 1), k != 8))
          for (var p = 1; p < k; p++) h[p] ^= h[p - 1];
        else {
          for (var p = 1; p < k / 2; p++) h[p] ^= h[p - 1];
          ($ = h[k / 2 - 1]), (h[k / 2] ^= m[$ & 255] ^ (m[($ >> 8) & 255] << 8) ^ (m[($ >> 16) & 255] << 16) ^ (m[($ >> 24) & 255] << 24));
          for (var p = k / 2 + 1; p < k; p++) h[p] ^= h[p - 1];
        }
        for (var p = 0, te, Q; p < k && F < x; ) (te = F >> 2), (Q = F % 4), (this._Ke[te][Q] = h[p]), (this._Kd[b - te][Q] = h[p++]), F++;
      }
      for (var te = 1; te < b; te++) for (var Q = 0; Q < 4; Q++) ($ = this._Kd[te][Q]), (this._Kd[te][Q] = U[($ >> 24) & 255] ^ W[($ >> 16) & 255] ^ z[($ >> 8) & 255] ^ Y[$ & 255]);
    }),
      (J.prototype.encrypt = function (b) {
        if (b.length != 16) throw new Error('invalid plaintext size (must be 16 bytes)');
        for (var p = this._Ke.length - 1, x = [0, 0, 0, 0], k = ue(b), h = 0; h < 4; h++) k[h] ^= this._Ke[0][h];
        for (var R = 1; R < p; R++) {
          for (var h = 0; h < 4; h++) x[h] = v[(k[h] >> 24) & 255] ^ T[(k[(h + 1) % 4] >> 16) & 255] ^ A[(k[(h + 2) % 4] >> 8) & 255] ^ _[k[(h + 3) % 4] & 255] ^ this._Ke[R][h];
          k = x.slice();
        }
        for (var L = a(16), F, h = 0; h < 4; h++)
          (F = this._Ke[p][h]),
            (L[4 * h] = (m[(k[h] >> 24) & 255] ^ (F >> 24)) & 255),
            (L[4 * h + 1] = (m[(k[(h + 1) % 4] >> 16) & 255] ^ (F >> 16)) & 255),
            (L[4 * h + 2] = (m[(k[(h + 2) % 4] >> 8) & 255] ^ (F >> 8)) & 255),
            (L[4 * h + 3] = (m[k[(h + 3) % 4] & 255] ^ F) & 255);
        return L;
      }),
      (J.prototype.decrypt = function (b) {
        if (b.length != 16) throw new Error('invalid ciphertext size (must be 16 bytes)');
        for (var p = this._Kd.length - 1, x = [0, 0, 0, 0], k = ue(b), h = 0; h < 4; h++) k[h] ^= this._Kd[0][h];
        for (var R = 1; R < p; R++) {
          for (var h = 0; h < 4; h++) x[h] = O[(k[h] >> 24) & 255] ^ B[(k[(h + 3) % 4] >> 16) & 255] ^ P[(k[(h + 2) % 4] >> 8) & 255] ^ N[k[(h + 1) % 4] & 255] ^ this._Kd[R][h];
          k = x.slice();
        }
        for (var L = a(16), F, h = 0; h < 4; h++)
          (F = this._Kd[p][h]),
            (L[4 * h] = (w[(k[h] >> 24) & 255] ^ (F >> 24)) & 255),
            (L[4 * h + 1] = (w[(k[(h + 3) % 4] >> 16) & 255] ^ (F >> 16)) & 255),
            (L[4 * h + 2] = (w[(k[(h + 2) % 4] >> 8) & 255] ^ (F >> 8)) & 255),
            (L[4 * h + 3] = (w[k[(h + 1) % 4] & 255] ^ F) & 255);
        return L;
      });
    var le = function (b) {
      if (!(this instanceof le)) throw Error('AES must be instanitated with `new`');
      (this.description = 'Electronic Code Block'), (this.name = 'ecb'), (this._aes = new J(b));
    };
    (le.prototype.encrypt = function (b) {
      if (((b = s(b)), b.length % 16 !== 0)) throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
      for (var p = a(b.length), x = a(16), k = 0; k < b.length; k += 16) o(b, x, 0, k, k + 16), (x = this._aes.encrypt(x)), o(x, p, k);
      return p;
    }),
      (le.prototype.decrypt = function (b) {
        if (((b = s(b)), b.length % 16 !== 0)) throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        for (var p = a(b.length), x = a(16), k = 0; k < b.length; k += 16) o(b, x, 0, k, k + 16), (x = this._aes.decrypt(x)), o(x, p, k);
        return p;
      });
    var C = function (b, p) {
      if (!(this instanceof C)) throw Error('AES must be instanitated with `new`');
      if (((this.description = 'Cipher Block Chaining'), (this.name = 'cbc'), !p)) p = a(16);
      else if (p.length != 16) throw new Error('invalid initialation vector size (must be 16 bytes)');
      (this._lastCipherblock = s(p, !0)), (this._aes = new J(b));
    };
    (C.prototype.encrypt = function (b) {
      if (((b = s(b)), b.length % 16 !== 0)) throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
      for (var p = a(b.length), x = a(16), k = 0; k < b.length; k += 16) {
        o(b, x, 0, k, k + 16);
        for (var h = 0; h < 16; h++) x[h] ^= this._lastCipherblock[h];
        (this._lastCipherblock = this._aes.encrypt(x)), o(this._lastCipherblock, p, k);
      }
      return p;
    }),
      (C.prototype.decrypt = function (b) {
        if (((b = s(b)), b.length % 16 !== 0)) throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        for (var p = a(b.length), x = a(16), k = 0; k < b.length; k += 16) {
          o(b, x, 0, k, k + 16), (x = this._aes.decrypt(x));
          for (var h = 0; h < 16; h++) p[k + h] = x[h] ^ this._lastCipherblock[h];
          o(b, this._lastCipherblock, 0, k, k + 16);
        }
        return p;
      });
    var d = function (b, p, x) {
      if (!(this instanceof d)) throw Error('AES must be instanitated with `new`');
      if (((this.description = 'Cipher Feedback'), (this.name = 'cfb'), !p)) p = a(16);
      else if (p.length != 16) throw new Error('invalid initialation vector size (must be 16 size)');
      x || (x = 1), (this.segmentSize = x), (this._shiftRegister = s(p, !0)), (this._aes = new J(b));
    };
    (d.prototype.encrypt = function (b) {
      if (b.length % this.segmentSize != 0) throw new Error('invalid plaintext size (must be segmentSize bytes)');
      for (var p = s(b, !0), x, k = 0; k < p.length; k += this.segmentSize) {
        x = this._aes.encrypt(this._shiftRegister);
        for (var h = 0; h < this.segmentSize; h++) p[k + h] ^= x[h];
        o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(p, this._shiftRegister, 16 - this.segmentSize, k, k + this.segmentSize);
      }
      return p;
    }),
      (d.prototype.decrypt = function (b) {
        if (b.length % this.segmentSize != 0) throw new Error('invalid ciphertext size (must be segmentSize bytes)');
        for (var p = s(b, !0), x, k = 0; k < p.length; k += this.segmentSize) {
          x = this._aes.encrypt(this._shiftRegister);
          for (var h = 0; h < this.segmentSize; h++) p[k + h] ^= x[h];
          o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(b, this._shiftRegister, 16 - this.segmentSize, k, k + this.segmentSize);
        }
        return p;
      });
    var y = function (b, p) {
      if (!(this instanceof y)) throw Error('AES must be instanitated with `new`');
      if (((this.description = 'Output Feedback'), (this.name = 'ofb'), !p)) p = a(16);
      else if (p.length != 16) throw new Error('invalid initialation vector size (must be 16 bytes)');
      (this._lastPrecipher = s(p, !0)), (this._lastPrecipherIndex = 16), (this._aes = new J(b));
    };
    (y.prototype.encrypt = function (b) {
      for (var p = s(b, !0), x = 0; x < p.length; x++)
        this._lastPrecipherIndex === 16 && ((this._lastPrecipher = this._aes.encrypt(this._lastPrecipher)), (this._lastPrecipherIndex = 0)), (p[x] ^= this._lastPrecipher[this._lastPrecipherIndex++]);
      return p;
    }),
      (y.prototype.decrypt = y.prototype.encrypt);
    var g = function (b) {
      if (!(this instanceof g)) throw Error('Counter must be instanitated with `new`');
      b !== 0 && !b && (b = 1), typeof b == 'number' ? ((this._counter = a(16)), this.setValue(b)) : this.setBytes(b);
    };
    (g.prototype.setValue = function (b) {
      if (typeof b != 'number' || parseInt(b) != b) throw new Error('invalid counter value (must be an integer)');
      for (var p = 15; p >= 0; --p) (this._counter[p] = b % 256), (b = b >> 8);
    }),
      (g.prototype.setBytes = function (b) {
        if (((b = s(b, !0)), b.length != 16)) throw new Error('invalid counter bytes size (must be 16 bytes)');
        this._counter = b;
      }),
      (g.prototype.increment = function () {
        for (var b = 15; b >= 0; b--)
          if (this._counter[b] === 255) this._counter[b] = 0;
          else {
            this._counter[b]++;
            break;
          }
      });
    var S = function (b, p) {
      if (!(this instanceof S)) throw Error('AES must be instanitated with `new`');
      (this.description = 'Counter'),
        (this.name = 'ctr'),
        p instanceof g || (p = new g(p)),
        (this._counter = p),
        (this._remainingCounter = null),
        (this._remainingCounterIndex = 16),
        (this._aes = new J(b));
    };
    (S.prototype.encrypt = function (b) {
      for (var p = s(b, !0), x = 0; x < p.length; x++)
        this._remainingCounterIndex === 16 && ((this._remainingCounter = this._aes.encrypt(this._counter._counter)), (this._remainingCounterIndex = 0), this._counter.increment()),
          (p[x] ^= this._remainingCounter[this._remainingCounterIndex++]);
      return p;
    }),
      (S.prototype.decrypt = S.prototype.encrypt);
    function E(b) {
      b = s(b, !0);
      var p = 16 - (b.length % 16),
        x = a(b.length + p);
      o(b, x);
      for (var k = b.length; k < x.length; k++) x[k] = p;
      return x;
    }
    function M(b) {
      if (((b = s(b, !0)), b.length < 16)) throw new Error('PKCS#7 invalid length');
      var p = b[b.length - 1];
      if (p > 16) throw new Error('PKCS#7 padding byte out of range');
      for (var x = b.length - p, k = 0; k < p; k++) if (b[x + k] !== p) throw new Error('PKCS#7 invalid padding byte');
      var h = a(x);
      return o(b, h, 0, 0, x), h;
    }
    var I = {
      AES: J,
      Counter: g,
      ModeOfOperation: {
        ecb: le,
        cbc: C,
        cfb: d,
        ofb: y,
        ctr: S,
      },
      utils: {
        hex: l,
        utf8: u,
      },
      padding: {
        pkcs7: {
          pad: E,
          strip: M,
        },
      },
      _arrayTest: {
        coerceArray: s,
        createArray: a,
        copyArray: o,
      },
    };
    n.exports = I;
  })();
})(tR);
const Wi = Py,
  C6 = 'json-wallets/5.7.0';
function la(n) {
  return typeof n == 'string' && n.substring(0, 2) !== '0x' && (n = '0x' + n), H(n);
}
function tu(n, e) {
  for (n = String(n); n.length < e; ) n = '0' + n;
  return n;
}
function R0(n) {
  return typeof n == 'string' ? $t(n, ir.NFKC) : H(n);
}
function Ft(n, e) {
  let t = n;
  const i = e.toLowerCase().split('/');
  for (let r = 0; r < i.length; r++) {
    let s = null;
    for (const a in t)
      if (a.toLowerCase() === i[r]) {
        s = t[a];
        break;
      }
    if (s === null) return null;
    t = s;
  }
  return t;
}
function nR(n) {
  const e = H(n);
  (e[6] = (e[6] & 15) | 64), (e[8] = (e[8] & 63) | 128);
  const t = K(e);
  return [t.substring(2, 10), t.substring(10, 14), t.substring(14, 18), t.substring(18, 22), t.substring(22, 34)].join('-');
}
const iR = new D(C6);
class rR extends _s {
  isCrowdsaleAccount(e) {
    return !!(e && e._isCrowdsaleAccount);
  }
}
function I0(n, e) {
  const t = JSON.parse(n);
  e = R0(e);
  const i = Fe(Ft(t, 'ethaddr')),
    r = la(Ft(t, 'encseed'));
  (!r || r.length % 16 !== 0) && iR.throwArgumentError('invalid encseed', 'json', n);
  const s = H(M0(e, e, 2e3, 32, 'sha256')).slice(0, 16),
    a = r.slice(0, 16),
    o = r.slice(16),
    u = new Wi.ModeOfOperation.cbc(s, a),
    l = Wi.padding.pkcs7.strip(H(u.decrypt(o)));
  let c = '';
  for (let w = 0; w < l.length; w++) c += String.fromCharCode(l[w]);
  const f = $t(c),
    m = De(f);
  return new rR({
    _isCrowdsaleAccount: !0,
    address: i,
    privateKey: m,
  });
}
function op(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return e.encseed && e.ethaddr;
}
function up(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return !(!e.version || parseInt(e.version) !== e.version || parseInt(e.version) !== 3);
}
function sR(n) {
  if (op(n))
    try {
      return Fe(JSON.parse(n).ethaddr);
    } catch {
      return null;
    }
  if (up(n))
    try {
      return Fe(JSON.parse(n).address);
    } catch {
      return null;
    }
  return null;
}
var Ny = {},
  aR = {
    get exports() {
      return Ny;
    },
    set exports(n) {
      Ny = n;
    },
  };
(function (n, e) {
  (function (t) {
    function r(T) {
      const A = new Uint32Array([
        1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580,
        3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895,
        666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298,
      ]);
      let _ = 1779033703,
        O = 3144134277,
        B = 1013904242,
        P = 2773480762,
        N = 1359893119,
        U = 2600822924,
        W = 528734635,
        z = 1541459225;
      const Y = new Uint32Array(64);
      function ue(S) {
        let E = 0,
          M = S.length;
        for (; M >= 64; ) {
          let I = _,
            b = O,
            p = B,
            x = P,
            k = N,
            h = U,
            R = W,
            L = z,
            F,
            $,
            te,
            Q,
            X;
          for ($ = 0; $ < 16; $++) (te = E + $ * 4), (Y[$] = ((S[te] & 255) << 24) | ((S[te + 1] & 255) << 16) | ((S[te + 2] & 255) << 8) | (S[te + 3] & 255));
          for ($ = 16; $ < 64; $++)
            (F = Y[$ - 2]),
              (Q = ((F >>> 17) | (F << (32 - 17))) ^ ((F >>> 19) | (F << (32 - 19))) ^ (F >>> 10)),
              (F = Y[$ - 15]),
              (X = ((F >>> 7) | (F << (32 - 7))) ^ ((F >>> 18) | (F << (32 - 18))) ^ (F >>> 3)),
              (Y[$] = (((Q + Y[$ - 7]) | 0) + ((X + Y[$ - 16]) | 0)) | 0);
          for ($ = 0; $ < 64; $++)
            (Q = ((((((k >>> 6) | (k << (32 - 6))) ^ ((k >>> 11) | (k << (32 - 11))) ^ ((k >>> 25) | (k << (32 - 25)))) + ((k & h) ^ (~k & R))) | 0) + ((L + ((A[$] + Y[$]) | 0)) | 0)) | 0),
              (X = ((((I >>> 2) | (I << (32 - 2))) ^ ((I >>> 13) | (I << (32 - 13))) ^ ((I >>> 22) | (I << (32 - 22)))) + ((I & b) ^ (I & p) ^ (b & p))) | 0),
              (L = R),
              (R = h),
              (h = k),
              (k = (x + Q) | 0),
              (x = p),
              (p = b),
              (b = I),
              (I = (Q + X) | 0);
          (_ = (_ + I) | 0), (O = (O + b) | 0), (B = (B + p) | 0), (P = (P + x) | 0), (N = (N + k) | 0), (U = (U + h) | 0), (W = (W + R) | 0), (z = (z + L) | 0), (E += 64), (M -= 64);
        }
      }
      ue(T);
      let J,
        le = T.length % 64,
        C = (T.length / 536870912) | 0,
        d = T.length << 3,
        y = le < 56 ? 56 : 120,
        g = T.slice(T.length - le, T.length);
      for (g.push(128), J = le + 1; J < y; J++) g.push(0);
      return (
        g.push((C >>> 24) & 255),
        g.push((C >>> 16) & 255),
        g.push((C >>> 8) & 255),
        g.push((C >>> 0) & 255),
        g.push((d >>> 24) & 255),
        g.push((d >>> 16) & 255),
        g.push((d >>> 8) & 255),
        g.push((d >>> 0) & 255),
        ue(g),
        [
          (_ >>> 24) & 255,
          (_ >>> 16) & 255,
          (_ >>> 8) & 255,
          (_ >>> 0) & 255,
          (O >>> 24) & 255,
          (O >>> 16) & 255,
          (O >>> 8) & 255,
          (O >>> 0) & 255,
          (B >>> 24) & 255,
          (B >>> 16) & 255,
          (B >>> 8) & 255,
          (B >>> 0) & 255,
          (P >>> 24) & 255,
          (P >>> 16) & 255,
          (P >>> 8) & 255,
          (P >>> 0) & 255,
          (N >>> 24) & 255,
          (N >>> 16) & 255,
          (N >>> 8) & 255,
          (N >>> 0) & 255,
          (U >>> 24) & 255,
          (U >>> 16) & 255,
          (U >>> 8) & 255,
          (U >>> 0) & 255,
          (W >>> 24) & 255,
          (W >>> 16) & 255,
          (W >>> 8) & 255,
          (W >>> 0) & 255,
          (z >>> 24) & 255,
          (z >>> 16) & 255,
          (z >>> 8) & 255,
          (z >>> 0) & 255,
        ]
      );
    }
    function s(T, A, _) {
      T = T.length <= 64 ? T : r(T);
      const O = 64 + A.length + 4,
        B = new Array(O),
        P = new Array(64);
      let N,
        U = [];
      for (N = 0; N < 64; N++) B[N] = 54;
      for (N = 0; N < T.length; N++) B[N] ^= T[N];
      for (N = 0; N < A.length; N++) B[64 + N] = A[N];
      for (N = O - 4; N < O; N++) B[N] = 0;
      for (N = 0; N < 64; N++) P[N] = 92;
      for (N = 0; N < T.length; N++) P[N] ^= T[N];
      function W() {
        for (let z = O - 1; z >= O - 4; z--) {
          if ((B[z]++, B[z] <= 255)) return;
          B[z] = 0;
        }
      }
      for (; _ >= 32; ) W(), (U = U.concat(r(P.concat(r(B))))), (_ -= 32);
      return _ > 0 && (W(), (U = U.concat(r(P.concat(r(B))).slice(0, _)))), U;
    }
    function a(T, A, _, O, B) {
      let P;
      for (c(T, (2 * _ - 1) * 16, B, 0, 16), P = 0; P < 2 * _; P++) l(T, P * 16, B, 16), u(B, O), c(B, 0, T, A + P * 16, 16);
      for (P = 0; P < _; P++) c(T, A + P * 2 * 16, T, P * 16, 16);
      for (P = 0; P < _; P++) c(T, A + (P * 2 + 1) * 16, T, (P + _) * 16, 16);
    }
    function o(T, A) {
      return (T << A) | (T >>> (32 - A));
    }
    function u(T, A) {
      c(T, 0, A, 0, 16);
      for (let _ = 8; _ > 0; _ -= 2)
        (A[4] ^= o(A[0] + A[12], 7)),
          (A[8] ^= o(A[4] + A[0], 9)),
          (A[12] ^= o(A[8] + A[4], 13)),
          (A[0] ^= o(A[12] + A[8], 18)),
          (A[9] ^= o(A[5] + A[1], 7)),
          (A[13] ^= o(A[9] + A[5], 9)),
          (A[1] ^= o(A[13] + A[9], 13)),
          (A[5] ^= o(A[1] + A[13], 18)),
          (A[14] ^= o(A[10] + A[6], 7)),
          (A[2] ^= o(A[14] + A[10], 9)),
          (A[6] ^= o(A[2] + A[14], 13)),
          (A[10] ^= o(A[6] + A[2], 18)),
          (A[3] ^= o(A[15] + A[11], 7)),
          (A[7] ^= o(A[3] + A[15], 9)),
          (A[11] ^= o(A[7] + A[3], 13)),
          (A[15] ^= o(A[11] + A[7], 18)),
          (A[1] ^= o(A[0] + A[3], 7)),
          (A[2] ^= o(A[1] + A[0], 9)),
          (A[3] ^= o(A[2] + A[1], 13)),
          (A[0] ^= o(A[3] + A[2], 18)),
          (A[6] ^= o(A[5] + A[4], 7)),
          (A[7] ^= o(A[6] + A[5], 9)),
          (A[4] ^= o(A[7] + A[6], 13)),
          (A[5] ^= o(A[4] + A[7], 18)),
          (A[11] ^= o(A[10] + A[9], 7)),
          (A[8] ^= o(A[11] + A[10], 9)),
          (A[9] ^= o(A[8] + A[11], 13)),
          (A[10] ^= o(A[9] + A[8], 18)),
          (A[12] ^= o(A[15] + A[14], 7)),
          (A[13] ^= o(A[12] + A[15], 9)),
          (A[14] ^= o(A[13] + A[12], 13)),
          (A[15] ^= o(A[14] + A[13], 18));
      for (let _ = 0; _ < 16; ++_) T[_] += A[_];
    }
    function l(T, A, _, O) {
      for (let B = 0; B < O; B++) _[B] ^= T[A + B];
    }
    function c(T, A, _, O, B) {
      for (; B--; ) _[O++] = T[A++];
    }
    function f(T) {
      if (!T || typeof T.length != 'number') return !1;
      for (let A = 0; A < T.length; A++) {
        const _ = T[A];
        if (typeof _ != 'number' || _ % 1 || _ < 0 || _ >= 256) return !1;
      }
      return !0;
    }
    function m(T, A) {
      if (typeof T != 'number' || T % 1) throw new Error('invalid ' + A);
      return T;
    }
    function w(T, A, _, O, B, P, N) {
      if (((_ = m(_, 'N')), (O = m(O, 'r')), (B = m(B, 'p')), (P = m(P, 'dkLen')), _ === 0 || _ & (_ - 1))) throw new Error('N must be power of 2');
      if (_ > 2147483647 / 128 / O) throw new Error('N too large');
      if (O > 2147483647 / 128 / B) throw new Error('r too large');
      if (!f(T)) throw new Error('password must be an array or buffer');
      if (((T = Array.prototype.slice.call(T)), !f(A))) throw new Error('salt must be an array or buffer');
      A = Array.prototype.slice.call(A);
      let U = s(T, A, B * 128 * O);
      const W = new Uint32Array(B * 32 * O);
      for (let k = 0; k < W.length; k++) {
        const h = k * 4;
        W[k] = ((U[h + 3] & 255) << 24) | ((U[h + 2] & 255) << 16) | ((U[h + 1] & 255) << 8) | ((U[h + 0] & 255) << 0);
      }
      const z = new Uint32Array(64 * O),
        Y = new Uint32Array(32 * O * _),
        ue = 32 * O,
        J = new Uint32Array(16),
        le = new Uint32Array(16),
        C = B * _ * 2;
      let d = 0,
        y = null,
        g = !1,
        S = 0,
        E = 0,
        M,
        I;
      const b = N ? parseInt(1e3 / O) : 4294967295,
        p = typeof setImmediate < 'u' ? setImmediate : setTimeout,
        x = function () {
          if (g) return N(new Error('cancelled'), d / C);
          let k;
          switch (S) {
            case 0:
              (I = E * 32 * O), c(W, I, z, 0, ue), (S = 1), (M = 0);
            case 1:
              (k = _ - M), k > b && (k = b);
              for (let R = 0; R < k; R++) c(z, 0, Y, (M + R) * ue, ue), a(z, ue, O, J, le);
              if (((M += k), (d += k), N)) {
                const R = parseInt((1e3 * d) / C);
                if (R !== y) {
                  if (((g = N(null, d / C)), g)) break;
                  y = R;
                }
              }
              if (M < _) break;
              (M = 0), (S = 2);
            case 2:
              (k = _ - M), k > b && (k = b);
              for (let R = 0; R < k; R++) {
                const L = (2 * O - 1) * 16,
                  F = z[L] & (_ - 1);
                l(Y, F * ue, z, ue), a(z, ue, O, J, le);
              }
              if (((M += k), (d += k), N)) {
                const R = parseInt((1e3 * d) / C);
                if (R !== y) {
                  if (((g = N(null, d / C)), g)) break;
                  y = R;
                }
              }
              if (M < _) break;
              if ((c(z, 0, W, I, ue), E++, E < B)) {
                S = 0;
                break;
              }
              U = [];
              for (let R = 0; R < W.length; R++) U.push((W[R] >> 0) & 255), U.push((W[R] >> 8) & 255), U.push((W[R] >> 16) & 255), U.push((W[R] >> 24) & 255);
              const h = s(T, U, P);
              return N && N(null, 1, h), h;
          }
          N && p(x);
        };
      if (!N)
        for (;;) {
          const k = x();
          if (k != null) return k;
        }
      x();
    }
    const v = {
      scrypt: function (T, A, _, O, B, P, N) {
        return new Promise(function (U, W) {
          let z = 0;
          N && N(0),
            w(T, A, _, O, B, P, function (Y, ue, J) {
              if (Y) W(Y);
              else if (J) N && z !== 1 && N(1), U(new Uint8Array(J));
              else if (N && ue !== z) return (z = ue), N(ue);
            });
        });
      },
      syncScrypt: function (T, A, _, O, B, P) {
        return new Uint8Array(w(T, A, _, O, B, P));
      },
    };
    n.exports = v;
  })();
})(aR);
const O0 = Ny;
var oR =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
const Dy = new D(C6);
function v2(n) {
  return n != null && n.mnemonic && n.mnemonic.phrase;
}
class uR extends _s {
  isKeystoreAccount(e) {
    return !!(e && e._isKeystoreAccount);
  }
}
function lR(n, e, t) {
  if (Ft(n, 'crypto/cipher') === 'aes-128-ctr') {
    const r = la(Ft(n, 'crypto/cipherparams/iv')),
      s = new Wi.Counter(r),
      a = new Wi.ModeOfOperation.ctr(e, s);
    return H(a.decrypt(t));
  }
  return null;
}
function M6(n, e) {
  const t = la(Ft(n, 'crypto/ciphertext'));
  if (K(De(Ge([e.slice(16, 32), t]))).substring(2) !== Ft(n, 'crypto/mac').toLowerCase()) throw new Error('invalid password');
  const r = lR(n, e.slice(0, 16), t);
  r ||
    Dy.throwError('unsupported cipher', D.errors.UNSUPPORTED_OPERATION, {
      operation: 'decrypt',
    });
  const s = e.slice(32, 64),
    a = hs(r);
  if (n.address) {
    let u = n.address.toLowerCase();
    if ((u.substring(0, 2) !== '0x' && (u = '0x' + u), Fe(u) !== a)) throw new Error('address mismatch');
  }
  const o = {
    _isKeystoreAccount: !0,
    address: a,
    privateKey: K(r),
  };
  if (Ft(n, 'x-ethers/version') === '0.1') {
    const u = la(Ft(n, 'x-ethers/mnemonicCiphertext')),
      l = la(Ft(n, 'x-ethers/mnemonicCounter')),
      c = new Wi.Counter(l),
      f = new Wi.ModeOfOperation.ctr(s, c),
      m = Ft(n, 'x-ethers/path') || So,
      w = Ft(n, 'x-ethers/locale') || 'en',
      v = H(f.decrypt(u));
    try {
      const T = ap(v, w),
        A = Yn.fromMnemonic(T, null, w).derivePath(m);
      if (A.privateKey != o.privateKey) throw new Error('mnemonic mismatch');
      o.mnemonic = A.mnemonic;
    } catch (T) {
      if (T.code !== D.errors.INVALID_ARGUMENT || T.argument !== 'wordlist') throw T;
    }
  }
  return new uR(o);
}
function _6(n, e, t, i, r) {
  return H(M0(n, e, t, i, r));
}
function dR(n, e, t, i, r) {
  return Promise.resolve(_6(n, e, t, i, r));
}
function R6(n, e, t, i, r) {
  const s = R0(e),
    a = Ft(n, 'crypto/kdf');
  if (a && typeof a == 'string') {
    const o = function (u, l) {
      return Dy.throwArgumentError('invalid key-derivation function parameters', u, l);
    };
    if (a.toLowerCase() === 'scrypt') {
      const u = la(Ft(n, 'crypto/kdfparams/salt')),
        l = parseInt(Ft(n, 'crypto/kdfparams/n')),
        c = parseInt(Ft(n, 'crypto/kdfparams/r')),
        f = parseInt(Ft(n, 'crypto/kdfparams/p'));
      (!l || !c || !f) && o('kdf', a), l & (l - 1) && o('N', l);
      const m = parseInt(Ft(n, 'crypto/kdfparams/dklen'));
      return m !== 32 && o('dklen', m), i(s, u, l, c, f, 64, r);
    } else if (a.toLowerCase() === 'pbkdf2') {
      const u = la(Ft(n, 'crypto/kdfparams/salt'));
      let l = null;
      const c = Ft(n, 'crypto/kdfparams/prf');
      c === 'hmac-sha256' ? (l = 'sha256') : c === 'hmac-sha512' ? (l = 'sha512') : o('prf', c);
      const f = parseInt(Ft(n, 'crypto/kdfparams/c')),
        m = parseInt(Ft(n, 'crypto/kdfparams/dklen'));
      return m !== 32 && o('dklen', m), t(s, u, f, m, l);
    }
  }
  return Dy.throwArgumentError('unsupported key-derivation function', 'kdf', a);
}
function I6(n, e) {
  const t = JSON.parse(n),
    i = R6(t, e, _6, O0.syncScrypt);
  return M6(t, i);
}
function O6(n, e, t) {
  return oR(this, void 0, void 0, function* () {
    const i = JSON.parse(n),
      r = yield R6(i, e, dR, O0.scrypt, t);
    return M6(i, r);
  });
}
function k6(n, e, t, i) {
  try {
    if (Fe(n.address) !== hs(n.privateKey)) throw new Error('address/privateKey mismatch');
    if (v2(n)) {
      const A = n.mnemonic;
      if (Yn.fromMnemonic(A.phrase, null, A.locale).derivePath(A.path || So).privateKey != n.privateKey) throw new Error('mnemonic mismatch');
    }
  } catch (A) {
    return Promise.reject(A);
  }
  typeof t == 'function' && !i && ((i = t), (t = {})), t || (t = {});
  const r = H(n.privateKey),
    s = R0(e);
  let a = null,
    o = null,
    u = null;
  if (v2(n)) {
    const A = n.mnemonic;
    (a = H(sp(A.phrase, A.locale || 'en'))), (o = A.path || So), (u = A.locale || 'en');
  }
  let l = t.client;
  l || (l = 'ethers.js');
  let c = null;
  t.salt ? (c = H(t.salt)) : (c = so(32));
  let f = null;
  if (t.iv) {
    if (((f = H(t.iv)), f.length !== 16)) throw new Error('invalid iv');
  } else f = so(16);
  let m = null;
  if (t.uuid) {
    if (((m = H(t.uuid)), m.length !== 16)) throw new Error('invalid uuid');
  } else m = so(16);
  let w = 1 << 17,
    v = 8,
    T = 1;
  return (
    t.scrypt && (t.scrypt.N && (w = t.scrypt.N), t.scrypt.r && (v = t.scrypt.r), t.scrypt.p && (T = t.scrypt.p)),
    O0.scrypt(s, c, w, v, T, 64, i).then((A) => {
      A = H(A);
      const _ = A.slice(0, 16),
        O = A.slice(16, 32),
        B = A.slice(32, 64),
        P = new Wi.Counter(f),
        N = new Wi.ModeOfOperation.ctr(_, P),
        U = H(N.encrypt(r)),
        W = De(Ge([O, U])),
        z = {
          address: n.address.substring(2).toLowerCase(),
          id: nR(m),
          version: 3,
          crypto: {
            cipher: 'aes-128-ctr',
            cipherparams: {
              iv: K(f).substring(2),
            },
            ciphertext: K(U).substring(2),
            kdf: 'scrypt',
            kdfparams: {
              salt: K(c).substring(2),
              n: w,
              dklen: 32,
              p: T,
              r: v,
            },
            mac: W.substring(2),
          },
        };
      if (a) {
        const Y = so(16),
          ue = new Wi.Counter(Y),
          J = new Wi.ModeOfOperation.ctr(B, ue),
          le = H(J.encrypt(a)),
          C = /* @__PURE__ */ new Date(),
          d =
            C.getUTCFullYear() +
            '-' +
            tu(C.getUTCMonth() + 1, 2) +
            '-' +
            tu(C.getUTCDate(), 2) +
            'T' +
            tu(C.getUTCHours(), 2) +
            '-' +
            tu(C.getUTCMinutes(), 2) +
            '-' +
            tu(C.getUTCSeconds(), 2) +
            '.0Z';
        z['x-ethers'] = {
          client: l,
          gethFilename: 'UTC--' + d + '--' + z.address,
          mnemonicCounter: K(Y).substring(2),
          mnemonicCiphertext: K(le).substring(2),
          path: o,
          locale: u,
          version: '0.1',
        };
      }
      return JSON.stringify(z);
    })
  );
}
function P6(n, e, t) {
  if (op(n)) {
    t && t(0);
    const i = I0(n, e);
    return t && t(1), Promise.resolve(i);
  }
  return up(n) ? O6(n, e, t) : Promise.reject(new Error('invalid JSON wallet'));
}
function N6(n, e) {
  if (op(n)) return I0(n, e);
  if (up(n)) return I6(n, e);
  throw new Error('invalid JSON wallet');
}
const cR = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        decryptCrowdsale: I0,
        decryptJsonWallet: P6,
        decryptJsonWalletSync: N6,
        decryptKeystore: O6,
        decryptKeystoreSync: I6,
        encryptKeystore: k6,
        getJsonWalletAddress: sR,
        isCrowdsaleWallet: op,
        isKeystoreWallet: up,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  pR = 'wallet/5.7.0';
var x2 =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
const za = new D(pR);
function fR(n) {
  return n != null && Me(n.privateKey, 32) && n.address != null;
}
function yR(n) {
  const e = n.mnemonic;
  return e && e.phrase;
}
class ia extends Fa {
  constructor(e, t) {
    if ((super(), fR(e))) {
      const i = new ua(e.privateKey);
      if (
        (j(this, '_signingKey', () => i),
        j(this, 'address', hs(this.publicKey)),
        this.address !== Fe(e.address) && za.throwArgumentError('privateKey/address mismatch', 'privateKey', '[REDACTED]'),
        yR(e))
      ) {
        const r = e.mnemonic;
        j(this, '_mnemonic', () => ({
          phrase: r.phrase,
          path: r.path || So,
          locale: r.locale || 'en',
        }));
        const s = this.mnemonic,
          a = Yn.fromMnemonic(s.phrase, null, s.locale).derivePath(s.path);
        hs(a.privateKey) !== this.address && za.throwArgumentError('mnemonic/address mismatch', 'privateKey', '[REDACTED]');
      } else j(this, '_mnemonic', () => null);
    } else {
      if (ua.isSigningKey(e)) e.curve !== 'secp256k1' && za.throwArgumentError('unsupported curve; must be secp256k1', 'privateKey', '[REDACTED]'), j(this, '_signingKey', () => e);
      else {
        typeof e == 'string' && e.match(/^[0-9a-f]*$/i) && e.length === 64 && (e = '0x' + e);
        const i = new ua(e);
        j(this, '_signingKey', () => i);
      }
      j(this, '_mnemonic', () => null), j(this, 'address', hs(this.publicKey));
    }
    t && !v0.isProvider(t) && za.throwArgumentError('invalid provider', 'provider', t), j(this, 'provider', t || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(e) {
    return new ia(this, e);
  }
  signTransaction(e) {
    return Ot(e).then((t) => {
      t.from != null && (Fe(t.from) !== this.address && za.throwArgumentError('transaction from address mismatch', 'transaction.from', e.from), delete t.from);
      const i = this._signingKey().signDigest(De(Oy(t)));
      return Oy(t, i);
    });
  }
  signMessage(e) {
    return x2(this, void 0, void 0, function* () {
      return xy(this._signingKey().signDigest(g0(e)));
    });
  }
  _signTypedData(e, t, i) {
    return x2(this, void 0, void 0, function* () {
      const r = yield an.resolveNames(
        e,
        t,
        i,
        (s) => (
          this.provider == null &&
            za.throwError('cannot resolve ENS names without a provider', D.errors.UNSUPPORTED_OPERATION, {
              operation: 'resolveName',
              value: s,
            }),
          this.provider.resolveName(s)
        ),
      );
      return xy(this._signingKey().signDigest(an.hash(r.domain, t, r.value)));
    });
  }
  encrypt(e, t, i) {
    if ((typeof t == 'function' && !i && ((i = t), (t = {})), i && typeof i != 'function')) throw new Error('invalid callback');
    return t || (t = {}), k6(this, e, t, i);
  }
  /**
   *  Static methods to create Wallet instances.
   */
  static createRandom(e) {
    let t = so(16);
    e || (e = {}), e.extraEntropy && (t = H(Lt(De(Ge([t, e.extraEntropy])), 0, 16)));
    const i = ap(t, e.locale);
    return ia.fromMnemonic(i, e.path, e.locale);
  }
  static fromEncryptedJson(e, t, i) {
    return P6(e, t, i).then((r) => new ia(r));
  }
  static fromEncryptedJsonSync(e, t) {
    return new ia(N6(e, t));
  }
  static fromMnemonic(e, t, i) {
    return t || (t = So), new ia(Yn.fromMnemonic(e, null, i).derivePath(t));
  }
}
function hR(n, e) {
  return Ho(g0(n), e);
}
function mR(n, e, t, i) {
  return Ho(an.hash(n, e, t), i);
}
const bR = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        Wallet: ia,
        verifyMessage: hR,
        verifyTypedData: mR,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  gR = 'networks/5.7.1',
  T2 = new D(gR);
function vR(n) {
  return n && typeof n.renetwork == 'function';
}
function gr(n) {
  const e = function (t, i) {
    i == null && (i = {});
    const r = [];
    if (t.InfuraProvider && i.infura !== '-')
      try {
        r.push(new t.InfuraProvider(n, i.infura));
      } catch {}
    if (t.EtherscanProvider && i.etherscan !== '-')
      try {
        r.push(new t.EtherscanProvider(n, i.etherscan));
      } catch {}
    if (t.AlchemyProvider && i.alchemy !== '-')
      try {
        r.push(new t.AlchemyProvider(n, i.alchemy));
      } catch {}
    if (t.PocketProvider && i.pocket !== '-') {
      const s = ['goerli', 'ropsten', 'rinkeby', 'sepolia'];
      try {
        const a = new t.PocketProvider(n, i.pocket);
        a.network && s.indexOf(a.network.name) === -1 && r.push(a);
      } catch {}
    }
    if (t.CloudflareProvider && i.cloudflare !== '-')
      try {
        r.push(new t.CloudflareProvider(n));
      } catch {}
    if (t.AnkrProvider && i.ankr !== '-')
      try {
        const s = ['ropsten'],
          a = new t.AnkrProvider(n, i.ankr);
        a.network && s.indexOf(a.network.name) === -1 && r.push(a);
      } catch {}
    if (r.length === 0) return null;
    if (t.FallbackProvider) {
      let s = 1;
      return i.quorum != null ? (s = i.quorum) : n === 'homestead' && (s = 2), new t.FallbackProvider(r, s);
    }
    return r[0];
  };
  return (
    (e.renetwork = function (t) {
      return gr(t);
    }),
    e
  );
}
function bc(n, e) {
  const t = function (i, r) {
    return i.JsonRpcProvider ? new i.JsonRpcProvider(n, e) : null;
  };
  return (
    (t.renetwork = function (i) {
      return bc(n, i);
    }),
    t
  );
}
const w2 = {
    chainId: 1,
    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
    name: 'homestead',
    _defaultProvider: gr('homestead'),
  },
  A2 = {
    chainId: 3,
    ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
    name: 'ropsten',
    _defaultProvider: gr('ropsten'),
  },
  E2 = {
    chainId: 63,
    name: 'classicMordor',
    _defaultProvider: bc('https://www.ethercluster.com/mordor', 'classicMordor'),
  },
  dd = {
    unspecified: { chainId: 0, name: 'unspecified' },
    homestead: w2,
    mainnet: w2,
    morden: { chainId: 2, name: 'morden' },
    ropsten: A2,
    testnet: A2,
    rinkeby: {
      chainId: 4,
      ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
      name: 'rinkeby',
      _defaultProvider: gr('rinkeby'),
    },
    kovan: {
      chainId: 42,
      name: 'kovan',
      _defaultProvider: gr('kovan'),
    },
    goerli: {
      chainId: 5,
      ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',
      name: 'goerli',
      _defaultProvider: gr('goerli'),
    },
    kintsugi: { chainId: 1337702, name: 'kintsugi' },
    sepolia: {
      chainId: 11155111,
      name: 'sepolia',
      _defaultProvider: gr('sepolia'),
    },
    // ETC (See: #351)
    classic: {
      chainId: 61,
      name: 'classic',
      _defaultProvider: bc('https://www.ethercluster.com/etc', 'classic'),
    },
    classicMorden: { chainId: 62, name: 'classicMorden' },
    classicMordor: E2,
    classicTestnet: E2,
    classicKotti: {
      chainId: 6,
      name: 'classicKotti',
      _defaultProvider: bc('https://www.ethercluster.com/kotti', 'classicKotti'),
    },
    xdai: { chainId: 100, name: 'xdai' },
    matic: {
      chainId: 137,
      name: 'matic',
      _defaultProvider: gr('matic'),
    },
    maticmum: { chainId: 80001, name: 'maticmum' },
    optimism: {
      chainId: 10,
      name: 'optimism',
      _defaultProvider: gr('optimism'),
    },
    'optimism-kovan': { chainId: 69, name: 'optimism-kovan' },
    'optimism-goerli': { chainId: 420, name: 'optimism-goerli' },
    arbitrum: { chainId: 42161, name: 'arbitrum' },
    'arbitrum-rinkeby': { chainId: 421611, name: 'arbitrum-rinkeby' },
    'arbitrum-goerli': { chainId: 421613, name: 'arbitrum-goerli' },
    bnb: { chainId: 56, name: 'bnb' },
    bnbt: { chainId: 97, name: 'bnbt' },
  };
function xR(n) {
  if (n == null) return null;
  if (typeof n == 'number') {
    for (const i in dd) {
      const r = dd[i];
      if (r.chainId === n)
        return {
          name: r.name,
          chainId: r.chainId,
          ensAddress: r.ensAddress || null,
          _defaultProvider: r._defaultProvider || null,
        };
    }
    return {
      chainId: n,
      name: 'unknown',
    };
  }
  if (typeof n == 'string') {
    const i = dd[n];
    return i == null
      ? null
      : {
          name: i.name,
          chainId: i.chainId,
          ensAddress: i.ensAddress,
          _defaultProvider: i._defaultProvider || null,
        };
  }
  const e = dd[n.name];
  if (!e) return typeof n.chainId != 'number' && T2.throwArgumentError('invalid network chainId', 'network', n), n;
  n.chainId !== 0 && n.chainId !== e.chainId && T2.throwArgumentError('network chainId mismatch', 'network', n);
  let t = n._defaultProvider || null;
  return (
    t == null && e._defaultProvider && (vR(e._defaultProvider) ? (t = e._defaultProvider.renetwork(n)) : (t = e._defaultProvider)),
    {
      name: n.name,
      chainId: e.chainId,
      ensAddress: n.ensAddress || e.ensAddress || null,
      _defaultProvider: t,
    }
  );
}
const TR = 'web/5.7.1';
var wR =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
function AR(n, e) {
  return wR(this, void 0, void 0, function* () {
    e == null && (e = {});
    const t = {
      method: e.method || 'GET',
      headers: e.headers || {},
      body: e.body || void 0,
    };
    if ((e.skipFetchSetup !== !0 && ((t.mode = 'cors'), (t.cache = 'no-cache'), (t.credentials = 'same-origin'), (t.redirect = 'follow'), (t.referrer = 'client')), e.fetchOptions != null)) {
      const a = e.fetchOptions;
      a.mode && (t.mode = a.mode), a.cache && (t.cache = a.cache), a.credentials && (t.credentials = a.credentials), a.redirect && (t.redirect = a.redirect), a.referrer && (t.referrer = a.referrer);
    }
    const i = yield fetch(n, t),
      r = yield i.arrayBuffer(),
      s = {};
    return (
      i.headers.forEach
        ? i.headers.forEach((a, o) => {
            s[o.toLowerCase()] = a;
          })
        : i.headers.keys().forEach((a) => {
            s[a.toLowerCase()] = i.headers.get(a);
          }),
      {
        headers: s,
        statusCode: i.status,
        statusMessage: i.statusText,
        body: H(new Uint8Array(r)),
      }
    );
  });
}
var ER =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
const Si = new D(TR);
function S2(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function is(n, e) {
  if (n == null) return null;
  if (typeof n == 'string') return n;
  if (Pl(n)) {
    if (e && (e.split('/')[0] === 'text' || e.split(';')[0].trim() === 'application/json'))
      try {
        return Rs(n);
      } catch {}
    return K(n);
  }
  return n;
}
function SR(n) {
  return $t(n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))));
}
function D6(n, e, t) {
  const i = typeof n == 'object' && n.throttleLimit != null ? n.throttleLimit : 12;
  Si.assertArgument(i > 0 && i % 1 === 0, 'invalid connection throttle limit', 'connection.throttleLimit', i);
  const r = typeof n == 'object' ? n.throttleCallback : null,
    s = typeof n == 'object' && typeof n.throttleSlotInterval == 'number' ? n.throttleSlotInterval : 100;
  Si.assertArgument(s > 0 && s % 1 === 0, 'invalid connection throttle slot interval', 'connection.throttleSlotInterval', s);
  const a = typeof n == 'object' ? !!n.errorPassThrough : !1,
    o = {};
  let u = null;
  const l = {
    method: 'GET',
  };
  let c = !1,
    f = 2 * 60 * 1e3;
  if (typeof n == 'string') u = n;
  else if (typeof n == 'object') {
    if (((n == null || n.url == null) && Si.throwArgumentError('missing URL', 'connection.url', n), (u = n.url), typeof n.timeout == 'number' && n.timeout > 0 && (f = n.timeout), n.headers))
      for (const _ in n.headers) (o[_.toLowerCase()] = { key: _, value: String(n.headers[_]) }), ['if-none-match', 'if-modified-since'].indexOf(_.toLowerCase()) >= 0 && (c = !0);
    if (((l.allowGzip = !!n.allowGzip), n.user != null && n.password != null)) {
      u.substring(0, 6) !== 'https:' &&
        n.allowInsecureAuthentication !== !0 &&
        Si.throwError('basic authentication requires a secure https url', D.errors.INVALID_ARGUMENT, { argument: 'url', url: u, user: n.user, password: '[REDACTED]' });
      const _ = n.user + ':' + n.password;
      o.authorization = {
        key: 'Authorization',
        value: 'Basic ' + b0($t(_)),
      };
    }
    n.skipFetchSetup != null && (l.skipFetchSetup = !!n.skipFetchSetup), n.fetchOptions != null && (l.fetchOptions = Gt(n.fetchOptions));
  }
  const m = new RegExp('^data:([^;:]*)?(;base64)?,(.*)$', 'i'),
    w = u ? u.match(m) : null;
  if (w)
    try {
      const _ = {
        statusCode: 200,
        statusMessage: 'OK',
        headers: { 'content-type': w[1] || 'text/plain' },
        body: w[2] ? m0(w[3]) : SR(w[3]),
      };
      let O = _.body;
      return t && (O = t(_.body, _)), Promise.resolve(O);
    } catch (_) {
      Si.throwError('processing response error', D.errors.SERVER_ERROR, {
        body: is(w[1], w[2]),
        error: _,
        requestBody: null,
        requestMethod: 'GET',
        url: u,
      });
    }
  e &&
    ((l.method = 'POST'),
    (l.body = e),
    o['content-type'] == null && (o['content-type'] = { key: 'Content-Type', value: 'application/octet-stream' }),
    o['content-length'] == null && (o['content-length'] = { key: 'Content-Length', value: String(e.length) }));
  const v = {};
  Object.keys(o).forEach((_) => {
    const O = o[_];
    v[O.key] = O.value;
  }),
    (l.headers = v);
  const T = (function () {
      let _ = null;
      return {
        promise: new Promise(function (P, N) {
          f &&
            (_ = setTimeout(() => {
              _ != null &&
                ((_ = null),
                N(
                  Si.makeError('timeout', D.errors.TIMEOUT, {
                    requestBody: is(l.body, v['content-type']),
                    requestMethod: l.method,
                    timeout: f,
                    url: u,
                  }),
                ));
            }, f));
        }),
        cancel: function () {
          _ != null && (clearTimeout(_), (_ = null));
        },
      };
    })(),
    A = (function () {
      return ER(this, void 0, void 0, function* () {
        for (let _ = 0; _ < i; _++) {
          let O = null;
          try {
            if (((O = yield AR(u, l)), _ < i)) {
              if (O.statusCode === 301 || O.statusCode === 302) {
                const P = O.headers.location || '';
                if (l.method === 'GET' && P.match(/^https:/)) {
                  u = O.headers.location;
                  continue;
                }
              } else if (O.statusCode === 429) {
                let P = !0;
                if ((r && (P = yield r(_, u)), P)) {
                  let N = 0;
                  const U = O.headers['retry-after'];
                  typeof U == 'string' && U.match(/^[1-9][0-9]*$/) ? (N = parseInt(U) * 1e3) : (N = s * parseInt(String(Math.random() * Math.pow(2, _)))), yield S2(N);
                  continue;
                }
              }
            }
          } catch (P) {
            (O = P.response),
              O == null &&
                (T.cancel(),
                Si.throwError('missing response', D.errors.SERVER_ERROR, {
                  requestBody: is(l.body, v['content-type']),
                  requestMethod: l.method,
                  serverError: P,
                  url: u,
                }));
          }
          let B = O.body;
          if (
            (c && O.statusCode === 304
              ? (B = null)
              : !a &&
                (O.statusCode < 200 || O.statusCode >= 300) &&
                (T.cancel(),
                Si.throwError('bad response', D.errors.SERVER_ERROR, {
                  status: O.statusCode,
                  headers: O.headers,
                  body: is(B, O.headers ? O.headers['content-type'] : null),
                  requestBody: is(l.body, v['content-type']),
                  requestMethod: l.method,
                  url: u,
                })),
            t)
          )
            try {
              const P = yield t(B, O);
              return T.cancel(), P;
            } catch (P) {
              if (P.throttleRetry && _ < i) {
                let N = !0;
                if ((r && (N = yield r(_, u)), N)) {
                  const U = s * parseInt(String(Math.random() * Math.pow(2, _)));
                  yield S2(U);
                  continue;
                }
              }
              T.cancel(),
                Si.throwError('processing response error', D.errors.SERVER_ERROR, {
                  body: is(B, O.headers ? O.headers['content-type'] : null),
                  error: P,
                  requestBody: is(l.body, v['content-type']),
                  requestMethod: l.method,
                  url: u,
                });
            }
          return T.cancel(), B;
        }
        return Si.throwError('failed response', D.errors.SERVER_ERROR, {
          requestBody: is(l.body, v['content-type']),
          requestMethod: l.method,
          url: u,
        });
      });
    })();
  return Promise.race([T.promise, A]);
}
function lp(n, e, t) {
  let i = (s, a) => {
      let o = null;
      if (s != null)
        try {
          o = JSON.parse(Rs(s));
        } catch (u) {
          Si.throwError('invalid JSON', D.errors.SERVER_ERROR, {
            body: s,
            error: u,
          });
        }
      return t && (o = t(o, a)), o;
    },
    r = null;
  if (e != null) {
    r = $t(e);
    const s = typeof n == 'string' ? { url: n } : Gt(n);
    s.headers
      ? Object.keys(s.headers).filter((o) => o.toLowerCase() === 'content-type').length !== 0 || ((s.headers = Gt(s.headers)), (s.headers['content-type'] = 'application/json'))
      : (s.headers = { 'content-type': 'application/json' }),
      (n = s);
  }
  return D6(n, r, i);
}
function ao(n, e) {
  return (
    e || (e = {}),
    (e = Gt(e)),
    e.floor == null && (e.floor = 0),
    e.ceiling == null && (e.ceiling = 1e4),
    e.interval == null && (e.interval = 250),
    new Promise(function (t, i) {
      let r = null,
        s = !1;
      const a = () => (s ? !1 : ((s = !0), r && clearTimeout(r), !0));
      e.timeout &&
        (r = setTimeout(() => {
          a() && i(new Error('timeout'));
        }, e.timeout));
      const o = e.retryLimit;
      let u = 0;
      function l() {
        return n().then(
          function (c) {
            if (c !== void 0) a() && t(c);
            else if (e.oncePoll) e.oncePoll.once('poll', l);
            else if (e.onceBlock) e.onceBlock.once('block', l);
            else if (!s) {
              if ((u++, u > o)) {
                a() && i(new Error('retry limit reached'));
                return;
              }
              let f = e.interval * parseInt(String(Math.random() * Math.pow(2, u)));
              f < e.floor && (f = e.floor), f > e.ceiling && (f = e.ceiling), setTimeout(l, f);
            }
            return null;
          },
          function (c) {
            a() && i(c);
          },
        );
      }
      l();
    })
  );
}
const CR = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      _fetchData: D6,
      fetchJson: lp,
      poll: ao,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
var gc = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l',
  By = {};
for (var cd = 0; cd < gc.length; cd++) {
  var Af = gc.charAt(cd);
  if (By[Af] !== void 0) throw new TypeError(Af + ' is ambiguous');
  By[Af] = cd;
}
function yo(n) {
  var e = n >> 25;
  return ((n & 33554431) << 5) ^ (-((e >> 0) & 1) & 996825010) ^ (-((e >> 1) & 1) & 642813549) ^ (-((e >> 2) & 1) & 513874426) ^ (-((e >> 3) & 1) & 1027748829) ^ (-((e >> 4) & 1) & 705979059);
}
function B6(n) {
  for (var e = 1, t = 0; t < n.length; ++t) {
    var i = n.charCodeAt(t);
    if (i < 33 || i > 126) return 'Invalid prefix (' + n + ')';
    e = yo(e) ^ (i >> 5);
  }
  for (e = yo(e), t = 0; t < n.length; ++t) {
    var r = n.charCodeAt(t);
    e = yo(e) ^ (r & 31);
  }
  return e;
}
function MR(n, e, t) {
  if (((t = t || 90), n.length + 7 + e.length > t)) throw new TypeError('Exceeds length limit');
  n = n.toLowerCase();
  var i = B6(n);
  if (typeof i == 'string') throw new Error(i);
  for (var r = n + '1', s = 0; s < e.length; ++s) {
    var a = e[s];
    if (a >> 5) throw new Error('Non 5-bit word');
    (i = yo(i) ^ a), (r += gc.charAt(a));
  }
  for (s = 0; s < 6; ++s) i = yo(i);
  for (i ^= 1, s = 0; s < 6; ++s) {
    var o = (i >> ((5 - s) * 5)) & 31;
    r += gc.charAt(o);
  }
  return r;
}
function F6(n, e) {
  if (((e = e || 90), n.length < 8)) return n + ' too short';
  if (n.length > e) return 'Exceeds length limit';
  var t = n.toLowerCase(),
    i = n.toUpperCase();
  if (n !== t && n !== i) return 'Mixed-case string ' + n;
  n = t;
  var r = n.lastIndexOf('1');
  if (r === -1) return 'No separator character for ' + n;
  if (r === 0) return 'Missing prefix for ' + n;
  var s = n.slice(0, r),
    a = n.slice(r + 1);
  if (a.length < 6) return 'Data too short';
  var o = B6(s);
  if (typeof o == 'string') return o;
  for (var u = [], l = 0; l < a.length; ++l) {
    var c = a.charAt(l),
      f = By[c];
    if (f === void 0) return 'Unknown character ' + c;
    (o = yo(o) ^ f), !(l + 6 >= a.length) && u.push(f);
  }
  return o !== 1 ? 'Invalid checksum for ' + n : { prefix: s, words: u };
}
function _R() {
  var n = F6.apply(null, arguments);
  if (typeof n == 'object') return n;
}
function RR(n) {
  var e = F6.apply(null, arguments);
  if (typeof e == 'object') return e;
  throw new Error(e);
}
function dp(n, e, t, i) {
  for (var r = 0, s = 0, a = (1 << t) - 1, o = [], u = 0; u < n.length; ++u) for (r = (r << e) | n[u], s += e; s >= t; ) (s -= t), o.push((r >> s) & a);
  if (i) s > 0 && o.push((r << (t - s)) & a);
  else {
    if (s >= e) return 'Excess padding';
    if ((r << (t - s)) & a) return 'Non-zero padding';
  }
  return o;
}
function IR(n) {
  var e = dp(n, 8, 5, !0);
  if (Array.isArray(e)) return e;
}
function OR(n) {
  var e = dp(n, 8, 5, !0);
  if (Array.isArray(e)) return e;
  throw new Error(e);
}
function kR(n) {
  var e = dp(n, 5, 8, !1);
  if (Array.isArray(e)) return e;
}
function PR(n) {
  var e = dp(n, 5, 8, !1);
  if (Array.isArray(e)) return e;
  throw new Error(e);
}
var C2 = {
  decodeUnsafe: _R,
  decode: RR,
  encode: MR,
  toWordsUnsafe: IR,
  toWords: OR,
  fromWordsUnsafe: kR,
  fromWords: PR,
};
const k0 = 'providers/5.7.2',
  nu = new D(k0);
class re {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const e = {},
      t = this.address.bind(this),
      i = this.bigNumber.bind(this),
      r = this.blockTag.bind(this),
      s = this.data.bind(this),
      a = this.hash.bind(this),
      o = this.hex.bind(this),
      u = this.number.bind(this),
      l = this.type.bind(this),
      c = (f) => this.data(f, !0);
    return (
      (e.transaction = {
        hash: a,
        type: l,
        accessList: re.allowNull(this.accessList.bind(this), null),
        blockHash: re.allowNull(a, null),
        blockNumber: re.allowNull(u, null),
        transactionIndex: re.allowNull(u, null),
        confirmations: re.allowNull(u, null),
        from: t,
        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
        // must be set
        gasPrice: re.allowNull(i),
        maxPriorityFeePerGas: re.allowNull(i),
        maxFeePerGas: re.allowNull(i),
        gasLimit: i,
        to: re.allowNull(t, null),
        value: i,
        nonce: u,
        data: s,
        r: re.allowNull(this.uint256),
        s: re.allowNull(this.uint256),
        v: re.allowNull(u),
        creates: re.allowNull(t, null),
        raw: re.allowNull(s),
      }),
      (e.transactionRequest = {
        from: re.allowNull(t),
        nonce: re.allowNull(u),
        gasLimit: re.allowNull(i),
        gasPrice: re.allowNull(i),
        maxPriorityFeePerGas: re.allowNull(i),
        maxFeePerGas: re.allowNull(i),
        to: re.allowNull(t),
        value: re.allowNull(i),
        data: re.allowNull(c),
        type: re.allowNull(u),
        accessList: re.allowNull(this.accessList.bind(this), null),
      }),
      (e.receiptLog = {
        transactionIndex: u,
        blockNumber: u,
        transactionHash: a,
        address: t,
        topics: re.arrayOf(a),
        data: s,
        logIndex: u,
        blockHash: a,
      }),
      (e.receipt = {
        to: re.allowNull(this.address, null),
        from: re.allowNull(this.address, null),
        contractAddress: re.allowNull(t, null),
        transactionIndex: u,
        // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
        root: re.allowNull(o),
        gasUsed: i,
        logsBloom: re.allowNull(s),
        blockHash: a,
        transactionHash: a,
        logs: re.arrayOf(this.receiptLog.bind(this)),
        blockNumber: u,
        confirmations: re.allowNull(u, null),
        cumulativeGasUsed: i,
        effectiveGasPrice: re.allowNull(i),
        status: re.allowNull(u),
        type: l,
      }),
      (e.block = {
        hash: re.allowNull(a),
        parentHash: a,
        number: u,
        timestamp: u,
        nonce: re.allowNull(o),
        difficulty: this.difficulty.bind(this),
        gasLimit: i,
        gasUsed: i,
        miner: re.allowNull(t),
        extraData: s,
        transactions: re.allowNull(re.arrayOf(a)),
        baseFeePerGas: re.allowNull(i),
      }),
      (e.blockWithTransactions = Gt(e.block)),
      (e.blockWithTransactions.transactions = re.allowNull(re.arrayOf(this.transactionResponse.bind(this)))),
      (e.filter = {
        fromBlock: re.allowNull(r, void 0),
        toBlock: re.allowNull(r, void 0),
        blockHash: re.allowNull(a, void 0),
        address: re.allowNull(t, void 0),
        topics: re.allowNull(this.topics.bind(this), void 0),
      }),
      (e.filterLog = {
        blockNumber: re.allowNull(u),
        blockHash: re.allowNull(a),
        transactionIndex: u,
        removed: re.allowNull(this.boolean.bind(this)),
        address: t,
        data: re.allowFalsish(s, '0x'),
        topics: re.arrayOf(a),
        transactionHash: a,
        logIndex: u,
      }),
      e
    );
  }
  accessList(e) {
    return $a(e || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(e) {
    return e === '0x' ? 0 : q.from(e).toNumber();
  }
  type(e) {
    return e === '0x' || e == null ? 0 : q.from(e).toNumber();
  }
  // Strict! Used on input.
  bigNumber(e) {
    return q.from(e);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(e) {
    if (typeof e == 'boolean') return e;
    if (typeof e == 'string') {
      if (((e = e.toLowerCase()), e === 'true')) return !0;
      if (e === 'false') return !1;
    }
    throw new Error('invalid boolean - ' + e);
  }
  hex(e, t) {
    return typeof e == 'string' && (!t && e.substring(0, 2) !== '0x' && (e = '0x' + e), Me(e)) ? e.toLowerCase() : nu.throwArgumentError('invalid hash', 'value', e);
  }
  data(e, t) {
    const i = this.hex(e, t);
    if (i.length % 2 !== 0) throw new Error('invalid data; odd-length - ' + e);
    return i;
  }
  // Requires an address
  // Strict! Used on input.
  address(e) {
    return Fe(e);
  }
  callAddress(e) {
    if (!Me(e, 32)) return null;
    const t = Fe(Lt(e, 12));
    return t === bC ? null : t;
  }
  contractAddress(e) {
    return c0(e);
  }
  // Strict! Used on input.
  blockTag(e) {
    if (e == null) return 'latest';
    if (e === 'earliest') return '0x0';
    switch (e) {
      case 'earliest':
        return '0x0';
      case 'latest':
      case 'pending':
      case 'safe':
      case 'finalized':
        return e;
    }
    if (typeof e == 'number' || Me(e)) return Xc(e);
    throw new Error('invalid blockTag');
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(e, t) {
    const i = this.hex(e, t);
    return nr(i) !== 32 ? nu.throwArgumentError('invalid hash', 'value', e) : i;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(e) {
    if (e == null) return null;
    const t = q.from(e);
    try {
      return t.toNumber();
    } catch {}
    return null;
  }
  uint256(e) {
    if (!Me(e)) throw new Error('invalid uint256');
    return Le(e, 32);
  }
  _block(e, t) {
    e.author != null && e.miner == null && (e.miner = e.author);
    const i = e._difficulty != null ? e._difficulty : e.difficulty,
      r = re.check(t, e);
    return (r._difficulty = i == null ? null : q.from(i)), r;
  }
  block(e) {
    return this._block(e, this.formats.block);
  }
  blockWithTransactions(e) {
    return this._block(e, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(e) {
    return re.check(this.formats.transactionRequest, e);
  }
  transactionResponse(e) {
    e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas),
      e.to && q.from(e.to).isZero() && (e.to = '0x0000000000000000000000000000000000000000'),
      e.input != null && e.data == null && (e.data = e.input),
      e.to == null && e.creates == null && (e.creates = this.contractAddress(e)),
      (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = []);
    const t = re.check(this.formats.transaction, e);
    if (e.chainId != null) {
      let i = e.chainId;
      Me(i) && (i = q.from(i).toNumber()), (t.chainId = i);
    } else {
      let i = e.networkId;
      i == null && t.v == null && (i = e.chainId),
        Me(i) && (i = q.from(i).toNumber()),
        typeof i != 'number' && t.v != null && ((i = (t.v - 35) / 2), i < 0 && (i = 0), (i = parseInt(i))),
        typeof i != 'number' && (i = 0),
        (t.chainId = i);
    }
    return t.blockHash && t.blockHash.replace(/0/g, '') === 'x' && (t.blockHash = null), t;
  }
  transaction(e) {
    return g6(e);
  }
  receiptLog(e) {
    return re.check(this.formats.receiptLog, e);
  }
  receipt(e) {
    const t = re.check(this.formats.receipt, e);
    if (t.root != null)
      if (t.root.length <= 4) {
        const i = q.from(t.root).toNumber();
        i === 0 || i === 1
          ? (t.status != null && t.status !== i && nu.throwArgumentError('alt-root-status/status mismatch', 'value', { root: t.root, status: t.status }), (t.status = i), delete t.root)
          : nu.throwArgumentError('invalid alt-root-status', 'value.root', t.root);
      } else t.root.length !== 66 && nu.throwArgumentError('invalid root hash', 'value.root', t.root);
    return t.status != null && (t.byzantium = !0), t;
  }
  topics(e) {
    return Array.isArray(e) ? e.map((t) => this.topics(t)) : e != null ? this.hash(e, !0) : null;
  }
  filter(e) {
    return re.check(this.formats.filter, e);
  }
  filterLog(e) {
    return re.check(this.formats.filterLog, e);
  }
  static check(e, t) {
    const i = {};
    for (const r in e)
      try {
        const s = e[r](t[r]);
        s !== void 0 && (i[r] = s);
      } catch (s) {
        throw ((s.checkKey = r), (s.checkValue = t[r]), s);
      }
    return i;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(e, t) {
    return function (i) {
      return i == null ? t : e(i);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(e, t) {
    return function (i) {
      return i ? e(i) : t;
    };
  }
  // Requires an Array satisfying check
  static arrayOf(e) {
    return function (t) {
      if (!Array.isArray(t)) throw new Error('not an array');
      const i = [];
      return (
        t.forEach(function (r) {
          i.push(e(r));
        }),
        i
      );
    };
  }
}
var fe =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
const ge = new D(k0),
  NR = 10;
function M2(n) {
  return n == null ? 'null' : (nr(n) !== 32 && ge.throwArgumentError('invalid topic', 'topic', n), n.toLowerCase());
}
function _2(n) {
  for (n = n.slice(); n.length > 0 && n[n.length - 1] == null; ) n.pop();
  return n
    .map((e) => {
      if (Array.isArray(e)) {
        const t = {};
        e.forEach((r) => {
          t[M2(r)] = !0;
        });
        const i = Object.keys(t);
        return i.sort(), i.join('|');
      } else return M2(e);
    })
    .join('&');
}
function DR(n) {
  return n === ''
    ? []
    : n.split(/&/g).map((e) => {
        if (e === '') return [];
        const t = e.split('|').map((i) => (i === 'null' ? null : i));
        return t.length === 1 ? t[0] : t;
      });
}
function Ga(n) {
  if (typeof n == 'string') {
    if (((n = n.toLowerCase()), nr(n) === 32)) return 'tx:' + n;
    if (n.indexOf(':') === -1) return n;
  } else {
    if (Array.isArray(n)) return 'filter:*:' + _2(n);
    if (OM.isForkEvent(n)) throw (ge.warn('not implemented'), new Error('not implemented'));
    if (n && typeof n == 'object') return 'filter:' + (n.address || '*') + ':' + _2(n.topics || []);
  }
  throw new Error('invalid event - ' + n);
}
function iu() {
  return /* @__PURE__ */ new Date().getTime();
}
function R2(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
const BR = ['block', 'network', 'pending', 'poll'];
class FR {
  constructor(e, t, i) {
    j(this, 'tag', e), j(this, 'listener', t), j(this, 'once', i), (this._lastBlockNumber = -2), (this._inflight = !1);
  }
  get event() {
    switch (this.type) {
      case 'tx':
        return this.hash;
      case 'filter':
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(':')[0];
  }
  get hash() {
    const e = this.tag.split(':');
    return e[0] !== 'tx' ? null : e[1];
  }
  get filter() {
    const e = this.tag.split(':');
    if (e[0] !== 'filter') return null;
    const t = e[1],
      i = DR(e[2]),
      r = {};
    return i.length > 0 && (r.topics = i), t && t !== '*' && (r.address = t), r;
  }
  pollable() {
    return this.tag.indexOf(':') >= 0 || BR.indexOf(this.tag) >= 0;
  }
}
const LR = {
  0: { symbol: 'btc', p2pkh: 0, p2sh: 5, prefix: 'bc' },
  2: { symbol: 'ltc', p2pkh: 48, p2sh: 50, prefix: 'ltc' },
  3: { symbol: 'doge', p2pkh: 30, p2sh: 22 },
  60: { symbol: 'eth', ilk: 'eth' },
  61: { symbol: 'etc', ilk: 'eth' },
  700: { symbol: 'xdai', ilk: 'eth' },
};
function Ef(n) {
  return Le(q.from(n).toHexString(), 32);
}
function I2(n) {
  return Ao.encode(Ge([n, Lt(Fr(Fr(n)), 0, 4)]));
}
const L6 = new RegExp('^(ipfs)://(.*)$', 'i'),
  O2 = [new RegExp('^(https)://(.*)$', 'i'), new RegExp('^(data):(.*)$', 'i'), L6, new RegExp('^eip155:[0-9]+/(erc[0-9]+):(.*)$', 'i')];
function Bd(n, e) {
  try {
    return Rs(el(n, e));
  } catch {}
  return null;
}
function el(n, e) {
  if (n === '0x') return null;
  const t = q.from(Lt(n, e, e + 32)).toNumber(),
    i = q.from(Lt(n, t, t + 32)).toNumber();
  return Lt(n, t + 32, t + 32 + i);
}
function Sf(n) {
  return (
    n.match(/^ipfs:\/\/ipfs\//i) ? (n = n.substring(12)) : n.match(/^ipfs:\/\//i) ? (n = n.substring(7)) : ge.throwArgumentError('unsupported IPFS format', 'link', n),
    `https://gateway.ipfs.io/ipfs/${n}`
  );
}
function k2(n) {
  const e = H(n);
  if (e.length > 32) throw new Error('internal; should not happen');
  const t = new Uint8Array(32);
  return t.set(e, 32 - e.length), t;
}
function $R(n) {
  if (n.length % 32 === 0) return n;
  const e = new Uint8Array(Math.ceil(n.length / 32) * 32);
  return e.set(n), e;
}
function $6(n) {
  const e = [];
  let t = 0;
  for (let i = 0; i < n.length; i++) e.push(null), (t += 32);
  for (let i = 0; i < n.length; i++) {
    const r = H(n[i]);
    (e[i] = k2(t)), e.push(k2(r.length)), e.push($R(r)), (t += 32 + Math.ceil(r.length / 32) * 32);
  }
  return Cn(e);
}
class P2 {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(e, t, i, r) {
    j(this, 'provider', e), j(this, 'name', i), j(this, 'address', e.formatter.address(t)), j(this, '_resolvedAddress', r);
  }
  supportsWildcard() {
    return (
      this._supportsEip2544 ||
        (this._supportsEip2544 = this.provider
          .call({
            to: this.address,
            data: '0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000',
          })
          .then((e) => q.from(e).eq(1))
          .catch((e) => {
            if (e.code === D.errors.CALL_EXCEPTION) return !1;
            throw ((this._supportsEip2544 = null), e);
          })),
      this._supportsEip2544
    );
  }
  _fetch(e, t) {
    return fe(this, void 0, void 0, function* () {
      const i = {
        to: this.address,
        ccipReadEnabled: !0,
        data: Cn([e, Cu(this.name), t || '0x']),
      };
      let r = !1;
      (yield this.supportsWildcard()) && ((r = !0), (i.data = Cn(['0x9061b923', $6([LT(this.name), i.data])])));
      try {
        let s = yield this.provider.call(i);
        return (
          H(s).length % 32 === 4 &&
            ge.throwError('resolver threw error', D.errors.CALL_EXCEPTION, {
              transaction: i,
              data: s,
            }),
          r && (s = el(s, 0)),
          s
        );
      } catch (s) {
        if (s.code === D.errors.CALL_EXCEPTION) return null;
        throw s;
      }
    });
  }
  _fetchBytes(e, t) {
    return fe(this, void 0, void 0, function* () {
      const i = yield this._fetch(e, t);
      return i != null ? el(i, 0) : null;
    });
  }
  _getAddress(e, t) {
    const i = LR[String(e)];
    if (
      (i == null &&
        ge.throwError(`unsupported coin type: ${e}`, D.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${e})`,
        }),
      i.ilk === 'eth')
    )
      return this.provider.formatter.address(t);
    const r = H(t);
    if (i.p2pkh != null) {
      const s = t.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75) return I2(Ge([[i.p2pkh], '0x' + s[2]]));
      }
    }
    if (i.p2sh != null) {
      const s = t.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75) return I2(Ge([[i.p2sh], '0x' + s[2]]));
      }
    }
    if (i.prefix != null) {
      const s = r[1];
      let a = r[0];
      if ((a === 0 ? s !== 20 && s !== 32 && (a = -1) : (a = -1), a >= 0 && r.length === 2 + s && s >= 1 && s <= 75)) {
        const o = C2.toWords(r.slice(2));
        return o.unshift(a), C2.encode(i.prefix, o);
      }
    }
    return null;
  }
  getAddress(e) {
    return fe(this, void 0, void 0, function* () {
      if ((e == null && (e = 60), e === 60))
        try {
          const r = yield this._fetch('0x3b3b57de');
          return r === '0x' || r === ST ? null : this.provider.formatter.callAddress(r);
        } catch (r) {
          if (r.code === D.errors.CALL_EXCEPTION) return null;
          throw r;
        }
      const t = yield this._fetchBytes('0xf1cb7e06', Ef(e));
      if (t == null || t === '0x') return null;
      const i = this._getAddress(e, t);
      return (
        i == null &&
          ge.throwError('invalid or unsupported coin data', D.errors.UNSUPPORTED_OPERATION, {
            operation: `getAddress(${e})`,
            coinType: e,
            data: t,
          }),
        i
      );
    });
  }
  getAvatar() {
    return fe(this, void 0, void 0, function* () {
      const e = [{ type: 'name', content: this.name }];
      try {
        const t = yield this.getText('avatar');
        if (t == null) return null;
        for (let i = 0; i < O2.length; i++) {
          const r = t.match(O2[i]);
          if (r == null) continue;
          const s = r[1].toLowerCase();
          switch (s) {
            case 'https':
              return e.push({ type: 'url', content: t }), { linkage: e, url: t };
            case 'data':
              return e.push({ type: 'data', content: t }), { linkage: e, url: t };
            case 'ipfs':
              return e.push({ type: 'ipfs', content: t }), { linkage: e, url: Sf(t) };
            case 'erc721':
            case 'erc1155': {
              const a = s === 'erc721' ? '0xc87b56dd' : '0x0e89341c';
              e.push({ type: s, content: t });
              const o = this._resolvedAddress || (yield this.getAddress()),
                u = (r[2] || '').split('/');
              if (u.length !== 2) return null;
              const l = yield this.provider.formatter.address(u[0]),
                c = Le(q.from(u[1]).toHexString(), 32);
              if (s === 'erc721') {
                const T = this.provider.formatter.callAddress(
                  yield this.provider.call({
                    to: l,
                    data: Cn(['0x6352211e', c]),
                  }),
                );
                if (o !== T) return null;
                e.push({ type: 'owner', content: T });
              } else if (s === 'erc1155') {
                const T = q.from(
                  yield this.provider.call({
                    to: l,
                    data: Cn(['0x00fdd58e', Le(o, 32), c]),
                  }),
                );
                if (T.isZero()) return null;
                e.push({ type: 'balance', content: T.toString() });
              }
              const f = {
                to: this.provider.formatter.address(u[0]),
                data: Cn([a, c]),
              };
              let m = Bd(yield this.provider.call(f), 0);
              if (m == null) return null;
              e.push({ type: 'metadata-url-base', content: m }),
                s === 'erc1155' && ((m = m.replace('{id}', c.substring(2))), e.push({ type: 'metadata-url-expanded', content: m })),
                m.match(/^ipfs:/i) && (m = Sf(m)),
                e.push({ type: 'metadata-url', content: m });
              const w = yield lp(m);
              if (!w) return null;
              e.push({ type: 'metadata', content: JSON.stringify(w) });
              let v = w.image;
              if (typeof v != 'string') return null;
              if (!v.match(/^(https:\/\/|data:)/i)) {
                if (v.match(L6) == null) return null;
                e.push({ type: 'url-ipfs', content: v }), (v = Sf(v));
              }
              return e.push({ type: 'url', content: v }), { linkage: e, url: v };
            }
          }
        }
      } catch {}
      return null;
    });
  }
  getContentHash() {
    return fe(this, void 0, void 0, function* () {
      const e = yield this._fetchBytes('0xbc1c58d1');
      if (e == null || e === '0x') return null;
      const t = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (t) {
        const a = parseInt(t[3], 16);
        if (t[4].length === a * 2) return 'ipfs://' + Ao.encode('0x' + t[1]);
      }
      const i = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (i) {
        const a = parseInt(i[3], 16);
        if (i[4].length === a * 2) return 'ipns://' + Ao.encode('0x' + i[1]);
      }
      const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (r && r[1].length === 32 * 2) return 'bzz://' + r[1];
      const s = e.match(/^0x90b2c605([0-9a-f]*)$/);
      if (s && s[1].length === 34 * 2) {
        const a = { '=': '', '+': '-', '/': '_' };
        return 'sia://' + b0('0x' + s[1]).replace(/[=+\/]/g, (u) => a[u]);
      }
      return ge.throwError('invalid or unsupported content hash data', D.errors.UNSUPPORTED_OPERATION, {
        operation: 'getContentHash()',
        data: e,
      });
    });
  }
  getText(e) {
    return fe(this, void 0, void 0, function* () {
      let t = $t(e);
      (t = Ge([Ef(64), Ef(t.length), t])), t.length % 32 !== 0 && (t = Ge([t, Le('0x', 32 - (e.length % 32))]));
      const i = yield this._fetchBytes('0x59d1d43c', K(t));
      return i == null || i === '0x' ? null : Rs(i);
    });
  }
}
let Cf = null,
  UR = 1;
class jR extends v0 {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(e) {
    if (
      (super(),
      (this._events = []),
      (this._emitted = { block: -2 }),
      (this.disableCcipRead = !1),
      (this.formatter = new.target.getFormatter()),
      j(this, 'anyNetwork', e === 'any'),
      this.anyNetwork && (e = this.detectNetwork()),
      e instanceof Promise)
    )
      (this._networkPromise = e), e.catch((t) => {}), this._ready().catch((t) => {});
    else {
      const t = Oi(new.target, 'getNetwork')(e);
      t ? (j(this, '_network', t), this.emit('network', t, null)) : ge.throwArgumentError('invalid network', 'network', e);
    }
    (this._maxInternalBlockNumber = -1024), (this._lastBlockNumber = -2), (this._maxFilterBlockRange = 10), (this._pollingInterval = 4e3), (this._fastQueryDate = 0);
  }
  _ready() {
    return fe(this, void 0, void 0, function* () {
      if (this._network == null) {
        let e = null;
        if (this._networkPromise)
          try {
            e = yield this._networkPromise;
          } catch {}
        e == null && (e = yield this.detectNetwork()),
          e || ge.throwError('no network detected', D.errors.UNKNOWN_ERROR, {}),
          this._network == null && (this.anyNetwork ? (this._network = e) : j(this, '_network', e), this.emit('network', e, null));
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return ao(() =>
      this._ready().then(
        (e) => e,
        (e) => {
          if (!(e.code === D.errors.NETWORK_ERROR && e.event === 'noNetwork')) throw e;
        },
      ),
    );
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    return Cf == null && (Cf = new re()), Cf;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(e) {
    return xR(e ?? 'homestead');
  }
  ccipReadFetch(e, t, i) {
    return fe(this, void 0, void 0, function* () {
      if (this.disableCcipRead || i.length === 0) return null;
      const r = e.to.toLowerCase(),
        s = t.toLowerCase(),
        a = [];
      for (let o = 0; o < i.length; o++) {
        const u = i[o],
          l = u.replace('{sender}', r).replace('{data}', s),
          c = u.indexOf('{data}') >= 0 ? null : JSON.stringify({ data: s, sender: r }),
          f = yield lp({ url: l, errorPassThrough: !0 }, c, (w, v) => ((w.status = v.statusCode), w));
        if (f.data) return f.data;
        const m = f.message || 'unknown error';
        if (f.status >= 400 && f.status < 500) return ge.throwError(`response not found during CCIP fetch: ${m}`, D.errors.SERVER_ERROR, { url: u, errorMessage: m });
        a.push(m);
      }
      return ge.throwError(`error encountered during CCIP fetch: ${a.map((o) => JSON.stringify(o)).join(', ')}`, D.errors.SERVER_ERROR, {
        urls: i,
        errorMessages: a,
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(e) {
    return fe(this, void 0, void 0, function* () {
      if ((yield this._ready(), e > 0))
        for (; this._internalBlockNumber; ) {
          const r = this._internalBlockNumber;
          try {
            const s = yield r;
            if (iu() - s.respTime <= e) return s.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === r) break;
          }
        }
      const t = iu(),
        i = Ot({
          blockNumber: this.perform('getBlockNumber', {}),
          networkError: this.getNetwork().then(
            (r) => null,
            (r) => r,
          ),
        }).then(({ blockNumber: r, networkError: s }) => {
          if (s) throw (this._internalBlockNumber === i && (this._internalBlockNumber = null), s);
          const a = iu();
          return (
            (r = q.from(r).toNumber()),
            r < this._maxInternalBlockNumber && (r = this._maxInternalBlockNumber),
            (this._maxInternalBlockNumber = r),
            this._setFastBlockNumber(r),
            { blockNumber: r, reqTime: t, respTime: a }
          );
        });
      return (
        (this._internalBlockNumber = i),
        i.catch((r) => {
          this._internalBlockNumber === i && (this._internalBlockNumber = null);
        }),
        (yield i).blockNumber
      );
    });
  }
  poll() {
    return fe(this, void 0, void 0, function* () {
      const e = UR++,
        t = [];
      let i = null;
      try {
        i = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (r) {
        this.emit('error', r);
        return;
      }
      if ((this._setFastBlockNumber(i), this.emit('poll', e, i), i === this._lastBlockNumber)) {
        this.emit('didPoll', e);
        return;
      }
      if ((this._emitted.block === -2 && (this._emitted.block = i - 1), Math.abs(this._emitted.block - i) > 1e3))
        ge.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${i})`),
          this.emit(
            'error',
            ge.makeError('network block skew detected', D.errors.NETWORK_ERROR, {
              blockNumber: i,
              event: 'blockSkew',
              previousBlockNumber: this._emitted.block,
            }),
          ),
          this.emit('block', i);
      else for (let r = this._emitted.block + 1; r <= i; r++) this.emit('block', r);
      this._emitted.block !== i &&
        ((this._emitted.block = i),
        Object.keys(this._emitted).forEach((r) => {
          if (r === 'block') return;
          const s = this._emitted[r];
          s !== 'pending' && i - s > 12 && delete this._emitted[r];
        })),
        this._lastBlockNumber === -2 && (this._lastBlockNumber = i - 1),
        this._events.forEach((r) => {
          switch (r.type) {
            case 'tx': {
              const s = r.hash;
              let a = this.getTransactionReceipt(s)
                .then((o) => (!o || o.blockNumber == null || ((this._emitted['t:' + s] = o.blockNumber), this.emit(s, o)), null))
                .catch((o) => {
                  this.emit('error', o);
                });
              t.push(a);
              break;
            }
            case 'filter': {
              if (!r._inflight) {
                (r._inflight = !0), r._lastBlockNumber === -2 && (r._lastBlockNumber = i - 1);
                const s = r.filter;
                (s.fromBlock = r._lastBlockNumber + 1), (s.toBlock = i);
                const a = s.toBlock - this._maxFilterBlockRange;
                a > s.fromBlock && (s.fromBlock = a), s.fromBlock < 0 && (s.fromBlock = 0);
                const o = this.getLogs(s)
                  .then((u) => {
                    (r._inflight = !1),
                      u.length !== 0 &&
                        u.forEach((l) => {
                          l.blockNumber > r._lastBlockNumber && (r._lastBlockNumber = l.blockNumber),
                            (this._emitted['b:' + l.blockHash] = l.blockNumber),
                            (this._emitted['t:' + l.transactionHash] = l.blockNumber),
                            this.emit(s, l);
                        });
                  })
                  .catch((u) => {
                    this.emit('error', u), (r._inflight = !1);
                  });
                t.push(o);
              }
              break;
            }
          }
        }),
        (this._lastBlockNumber = i),
        Promise.all(t)
          .then(() => {
            this.emit('didPoll', e);
          })
          .catch((r) => {
            this.emit('error', r);
          });
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(e) {
    (this._lastBlockNumber = e - 1), this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return fe(this, void 0, void 0, function* () {
      return ge.throwError('provider does not support network detection', D.errors.UNSUPPORTED_OPERATION, {
        operation: 'provider.detectNetwork',
      });
    });
  }
  getNetwork() {
    return fe(this, void 0, void 0, function* () {
      const e = yield this._ready(),
        t = yield this.detectNetwork();
      if (e.chainId !== t.chainId) {
        if (this.anyNetwork)
          return (
            (this._network = t),
            (this._lastBlockNumber = -2),
            (this._fastBlockNumber = null),
            (this._fastBlockNumberPromise = null),
            (this._fastQueryDate = 0),
            (this._emitted.block = -2),
            (this._maxInternalBlockNumber = -1024),
            (this._internalBlockNumber = null),
            this.emit('network', t, e),
            yield R2(0),
            this._network
          );
        const i = ge.makeError('underlying network changed', D.errors.NETWORK_ERROR, {
          event: 'changed',
          network: e,
          detectedNetwork: t,
        });
        throw (this.emit('error', i), i);
      }
      return e;
    });
  }
  get blockNumber() {
    return (
      this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(
        (e) => {
          this._setFastBlockNumber(e);
        },
        (e) => {},
      ),
      this._fastBlockNumber != null ? this._fastBlockNumber : -1
    );
  }
  get polling() {
    return this._poller != null;
  }
  set polling(e) {
    e && !this._poller
      ? ((this._poller = setInterval(() => {
          this.poll();
        }, this.pollingInterval)),
        this._bootstrapPoll ||
          (this._bootstrapPoll = setTimeout(() => {
            this.poll(),
              (this._bootstrapPoll = setTimeout(() => {
                this._poller || this.poll(), (this._bootstrapPoll = null);
              }, this.pollingInterval));
          }, 0)))
      : !e && this._poller && (clearInterval(this._poller), (this._poller = null));
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(e) {
    if (typeof e != 'number' || e <= 0 || parseInt(String(e)) != e) throw new Error('invalid polling interval');
    (this._pollingInterval = e),
      this._poller &&
        (clearInterval(this._poller),
        (this._poller = setInterval(() => {
          this.poll();
        }, this._pollingInterval)));
  }
  _getFastBlockNumber() {
    const e = iu();
    return (
      e - this._fastQueryDate > 2 * this._pollingInterval &&
        ((this._fastQueryDate = e),
        (this._fastBlockNumberPromise = this.getBlockNumber().then((t) => ((this._fastBlockNumber == null || t > this._fastBlockNumber) && (this._fastBlockNumber = t), this._fastBlockNumber)))),
      this._fastBlockNumberPromise
    );
  }
  _setFastBlockNumber(e) {
    (this._fastBlockNumber != null && e < this._fastBlockNumber) ||
      ((this._fastQueryDate = iu()), (this._fastBlockNumber == null || e > this._fastBlockNumber) && ((this._fastBlockNumber = e), (this._fastBlockNumberPromise = Promise.resolve(e))));
  }
  waitForTransaction(e, t, i) {
    return fe(this, void 0, void 0, function* () {
      return this._waitForTransaction(e, t ?? 1, i || 0, null);
    });
  }
  _waitForTransaction(e, t, i, r) {
    return fe(this, void 0, void 0, function* () {
      const s = yield this.getTransactionReceipt(e);
      return (s ? s.confirmations : 0) >= t
        ? s
        : new Promise((a, o) => {
            const u = [];
            let l = !1;
            const c = function () {
                return l
                  ? !0
                  : ((l = !0),
                    u.forEach((m) => {
                      m();
                    }),
                    !1);
              },
              f = (m) => {
                m.confirmations < t || c() || a(m);
              };
            if (
              (this.on(e, f),
              u.push(() => {
                this.removeListener(e, f);
              }),
              r)
            ) {
              let m = r.startBlock,
                w = null;
              const v = (T) =>
                fe(this, void 0, void 0, function* () {
                  l ||
                    (yield R2(1e3),
                    this.getTransactionCount(r.from).then(
                      (A) =>
                        fe(this, void 0, void 0, function* () {
                          if (!l) {
                            if (A <= r.nonce) m = T;
                            else {
                              {
                                const _ = yield this.getTransaction(e);
                                if (_ && _.blockNumber != null) return;
                              }
                              for (w == null && ((w = m - 3), w < r.startBlock && (w = r.startBlock)); w <= T; ) {
                                if (l) return;
                                const _ = yield this.getBlockWithTransactions(w);
                                for (let O = 0; O < _.transactions.length; O++) {
                                  const B = _.transactions[O];
                                  if (B.hash === e) return;
                                  if (B.from === r.from && B.nonce === r.nonce) {
                                    if (l) return;
                                    const P = yield this.waitForTransaction(B.hash, t);
                                    if (c()) return;
                                    let N = 'replaced';
                                    B.data === r.data && B.to === r.to && B.value.eq(r.value) ? (N = 'repriced') : B.data === '0x' && B.from === B.to && B.value.isZero() && (N = 'cancelled'),
                                      o(
                                        ge.makeError('transaction was replaced', D.errors.TRANSACTION_REPLACED, {
                                          cancelled: N === 'replaced' || N === 'cancelled',
                                          reason: N,
                                          replacement: this._wrapTransaction(B),
                                          hash: e,
                                          receipt: P,
                                        }),
                                      );
                                    return;
                                  }
                                }
                                w++;
                              }
                            }
                            l || this.once('block', v);
                          }
                        }),
                      (A) => {
                        l || this.once('block', v);
                      },
                    ));
                });
              if (l) return;
              this.once('block', v),
                u.push(() => {
                  this.removeListener('block', v);
                });
            }
            if (typeof i == 'number' && i > 0) {
              const m = setTimeout(() => {
                c() || o(ge.makeError('timeout exceeded', D.errors.TIMEOUT, { timeout: i }));
              }, i);
              m.unref && m.unref(),
                u.push(() => {
                  clearTimeout(m);
                });
            }
          });
    });
  }
  getBlockNumber() {
    return fe(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const e = yield this.perform('getGasPrice', {});
      try {
        return q.from(e);
      } catch (t) {
        return ge.throwError('bad result from backend', D.errors.SERVER_ERROR, {
          method: 'getGasPrice',
          result: e,
          error: t,
        });
      }
    });
  }
  getBalance(e, t) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield Ot({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(t),
        }),
        r = yield this.perform('getBalance', i);
      try {
        return q.from(r);
      } catch (s) {
        return ge.throwError('bad result from backend', D.errors.SERVER_ERROR, {
          method: 'getBalance',
          params: i,
          result: r,
          error: s,
        });
      }
    });
  }
  getTransactionCount(e, t) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield Ot({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(t),
        }),
        r = yield this.perform('getTransactionCount', i);
      try {
        return q.from(r).toNumber();
      } catch (s) {
        return ge.throwError('bad result from backend', D.errors.SERVER_ERROR, {
          method: 'getTransactionCount',
          params: i,
          result: r,
          error: s,
        });
      }
    });
  }
  getCode(e, t) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield Ot({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(t),
        }),
        r = yield this.perform('getCode', i);
      try {
        return K(r);
      } catch (s) {
        return ge.throwError('bad result from backend', D.errors.SERVER_ERROR, {
          method: 'getCode',
          params: i,
          result: r,
          error: s,
        });
      }
    });
  }
  getStorageAt(e, t, i) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield Ot({
          address: this._getAddress(e),
          blockTag: this._getBlockTag(i),
          position: Promise.resolve(t).then((a) => Xc(a)),
        }),
        s = yield this.perform('getStorageAt', r);
      try {
        return K(s);
      } catch (a) {
        return ge.throwError('bad result from backend', D.errors.SERVER_ERROR, {
          method: 'getStorageAt',
          params: r,
          result: s,
          error: a,
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(e, t, i) {
    if (t != null && nr(t) !== 32) throw new Error('invalid response - sendTransaction');
    const r = e;
    return (
      t != null && e.hash !== t && ge.throwError('Transaction hash mismatch from Provider.sendTransaction.', D.errors.UNKNOWN_ERROR, { expectedHash: e.hash, returnedHash: t }),
      (r.wait = (s, a) =>
        fe(this, void 0, void 0, function* () {
          s == null && (s = 1), a == null && (a = 0);
          let o;
          s !== 0 &&
            i != null &&
            (o = {
              data: e.data,
              from: e.from,
              nonce: e.nonce,
              to: e.to,
              value: e.value,
              startBlock: i,
            });
          const u = yield this._waitForTransaction(e.hash, s, a, o);
          return u == null && s === 0
            ? null
            : ((this._emitted['t:' + e.hash] = u.blockNumber),
              u.status === 0 &&
                ge.throwError('transaction failed', D.errors.CALL_EXCEPTION, {
                  transactionHash: e.hash,
                  transaction: e,
                  receipt: u,
                }),
              u);
        })),
      r
    );
  }
  sendTransaction(e) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Promise.resolve(e).then((s) => K(s)),
        i = this.formatter.transaction(e);
      i.confirmations == null && (i.confirmations = 0);
      const r = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const s = yield this.perform('sendTransaction', { signedTransaction: t });
        return this._wrapTransaction(i, s, r);
      } catch (s) {
        throw ((s.transaction = i), (s.transactionHash = i.hash), s);
      }
    });
  }
  _getTransactionRequest(e) {
    return fe(this, void 0, void 0, function* () {
      const t = yield e,
        i = {};
      return (
        ['from', 'to'].forEach((r) => {
          t[r] != null && (i[r] = Promise.resolve(t[r]).then((s) => (s ? this._getAddress(s) : null)));
        }),
        ['gasLimit', 'gasPrice', 'maxFeePerGas', 'maxPriorityFeePerGas', 'value'].forEach((r) => {
          t[r] != null && (i[r] = Promise.resolve(t[r]).then((s) => (s ? q.from(s) : null)));
        }),
        ['type'].forEach((r) => {
          t[r] != null && (i[r] = Promise.resolve(t[r]).then((s) => s ?? null));
        }),
        t.accessList && (i.accessList = this.formatter.accessList(t.accessList)),
        ['data'].forEach((r) => {
          t[r] != null && (i[r] = Promise.resolve(t[r]).then((s) => (s ? K(s) : null)));
        }),
        this.formatter.transactionRequest(yield Ot(i))
      );
    });
  }
  _getFilter(e) {
    return fe(this, void 0, void 0, function* () {
      e = yield e;
      const t = {};
      return (
        e.address != null && (t.address = this._getAddress(e.address)),
        ['blockHash', 'topics'].forEach((i) => {
          e[i] != null && (t[i] = e[i]);
        }),
        ['fromBlock', 'toBlock'].forEach((i) => {
          e[i] != null && (t[i] = this._getBlockTag(e[i]));
        }),
        this.formatter.filter(yield Ot(t))
      );
    });
  }
  _call(e, t, i) {
    return fe(this, void 0, void 0, function* () {
      i >= NR &&
        ge.throwError('CCIP read exceeded maximum redirections', D.errors.SERVER_ERROR, {
          redirects: i,
          transaction: e,
        });
      const r = e.to,
        s = yield this.perform('call', { transaction: e, blockTag: t });
      if (i >= 0 && t === 'latest' && r != null && s.substring(0, 10) === '0x556f1830' && nr(s) % 32 === 4)
        try {
          const a = Lt(s, 4),
            o = Lt(a, 0, 32);
          q.from(o).eq(r) ||
            ge.throwError('CCIP Read sender did not match', D.errors.CALL_EXCEPTION, {
              name: 'OffchainLookup',
              signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
              transaction: e,
              data: s,
            });
          const u = [],
            l = q.from(Lt(a, 32, 64)).toNumber(),
            c = q.from(Lt(a, l, l + 32)).toNumber(),
            f = Lt(a, l + 32);
          for (let _ = 0; _ < c; _++) {
            const O = Bd(f, _ * 32);
            O == null &&
              ge.throwError('CCIP Read contained corrupt URL string', D.errors.CALL_EXCEPTION, {
                name: 'OffchainLookup',
                signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
                transaction: e,
                data: s,
              }),
              u.push(O);
          }
          const m = el(a, 64);
          q.from(Lt(a, 100, 128)).isZero() ||
            ge.throwError('CCIP Read callback selector included junk', D.errors.CALL_EXCEPTION, {
              name: 'OffchainLookup',
              signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
              transaction: e,
              data: s,
            });
          const w = Lt(a, 96, 100),
            v = el(a, 128),
            T = yield this.ccipReadFetch(e, m, u);
          T == null &&
            ge.throwError('CCIP Read disabled or provided no URLs', D.errors.CALL_EXCEPTION, {
              name: 'OffchainLookup',
              signature: 'OffchainLookup(address,string[],bytes,bytes4,bytes)',
              transaction: e,
              data: s,
            });
          const A = {
            to: r,
            data: Cn([w, $6([T, v])]),
          };
          return this._call(A, t, i + 1);
        } catch (a) {
          if (a.code === D.errors.SERVER_ERROR) throw a;
        }
      try {
        return K(s);
      } catch (a) {
        return ge.throwError('bad result from backend', D.errors.SERVER_ERROR, {
          method: 'call',
          params: { transaction: e, blockTag: t },
          result: s,
          error: a,
        });
      }
    });
  }
  call(e, t) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield Ot({
        transaction: this._getTransactionRequest(e),
        blockTag: this._getBlockTag(t),
        ccipReadEnabled: Promise.resolve(e.ccipReadEnabled),
      });
      return this._call(i.transaction, i.blockTag, i.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(e) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Ot({
          transaction: this._getTransactionRequest(e),
        }),
        i = yield this.perform('estimateGas', t);
      try {
        return q.from(i);
      } catch (r) {
        return ge.throwError('bad result from backend', D.errors.SERVER_ERROR, {
          method: 'estimateGas',
          params: t,
          result: i,
          error: r,
        });
      }
    });
  }
  _getAddress(e) {
    return fe(this, void 0, void 0, function* () {
      (e = yield e), typeof e != 'string' && ge.throwArgumentError('invalid address or ENS name', 'name', e);
      const t = yield this.resolveName(e);
      return (
        t == null &&
          ge.throwError('ENS name not configured', D.errors.UNSUPPORTED_OPERATION, {
            operation: `resolveName(${JSON.stringify(e)})`,
          }),
        t
      );
    });
  }
  _getBlock(e, t) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      let i = -128;
      const r = {
        includeTransactions: !!t,
      };
      if (Me(e, 32)) r.blockHash = e;
      else
        try {
          (r.blockTag = yield this._getBlockTag(e)), Me(r.blockTag) && (i = parseInt(r.blockTag.substring(2), 16));
        } catch {
          ge.throwArgumentError('invalid block hash or block tag', 'blockHashOrBlockTag', e);
        }
      return ao(
        () =>
          fe(this, void 0, void 0, function* () {
            const s = yield this.perform('getBlock', r);
            if (s == null) return (r.blockHash != null && this._emitted['b:' + r.blockHash] == null) || (r.blockTag != null && i > this._emitted.block) ? null : void 0;
            if (t) {
              let a = null;
              for (let u = 0; u < s.transactions.length; u++) {
                const l = s.transactions[u];
                if (l.blockNumber == null) l.confirmations = 0;
                else if (l.confirmations == null) {
                  a == null && (a = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
                  let c = a - l.blockNumber + 1;
                  c <= 0 && (c = 1), (l.confirmations = c);
                }
              }
              const o = this.formatter.blockWithTransactions(s);
              return (o.transactions = o.transactions.map((u) => this._wrapTransaction(u))), o;
            }
            return this.formatter.block(s);
          }),
        { oncePoll: this },
      );
    });
  }
  getBlock(e) {
    return this._getBlock(e, !1);
  }
  getBlockWithTransactions(e) {
    return this._getBlock(e, !0);
  }
  getTransaction(e) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return ao(
        () =>
          fe(this, void 0, void 0, function* () {
            const i = yield this.perform('getTransaction', t);
            if (i == null) return this._emitted['t:' + e] == null ? null : void 0;
            const r = this.formatter.transactionResponse(i);
            if (r.blockNumber == null) r.confirmations = 0;
            else if (r.confirmations == null) {
              let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - r.blockNumber + 1;
              a <= 0 && (a = 1), (r.confirmations = a);
            }
            return this._wrapTransaction(r);
          }),
        { oncePoll: this },
      );
    });
  }
  getTransactionReceipt(e) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork(), (e = yield e);
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return ao(
        () =>
          fe(this, void 0, void 0, function* () {
            const i = yield this.perform('getTransactionReceipt', t);
            if (i == null) return this._emitted['t:' + e] == null ? null : void 0;
            if (i.blockHash == null) return;
            const r = this.formatter.receipt(i);
            if (r.blockNumber == null) r.confirmations = 0;
            else if (r.confirmations == null) {
              let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - r.blockNumber + 1;
              a <= 0 && (a = 1), (r.confirmations = a);
            }
            return r;
          }),
        { oncePoll: this },
      );
    });
  }
  getLogs(e) {
    return fe(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Ot({ filter: this._getFilter(e) }),
        i = yield this.perform('getLogs', t);
      return (
        i.forEach((r) => {
          r.removed == null && (r.removed = !1);
        }),
        re.arrayOf(this.formatter.filterLog.bind(this.formatter))(i)
      );
    });
  }
  getEtherPrice() {
    return fe(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform('getEtherPrice', {});
    });
  }
  _getBlockTag(e) {
    return fe(this, void 0, void 0, function* () {
      if (((e = yield e), typeof e == 'number' && e < 0)) {
        e % 1 && ge.throwArgumentError('invalid BlockTag', 'blockTag', e);
        let t = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        return (t += e), t < 0 && (t = 0), this.formatter.blockTag(t);
      }
      return this.formatter.blockTag(e);
    });
  }
  getResolver(e) {
    return fe(this, void 0, void 0, function* () {
      let t = e;
      for (;;) {
        if (t === '' || t === '.' || (e !== 'eth' && t === 'eth')) return null;
        const i = yield this._getResolver(t, 'getResolver');
        if (i != null) {
          const r = new P2(this, i, e);
          return t !== e && !(yield r.supportsWildcard()) ? null : r;
        }
        t = t.split('.').slice(1).join('.');
      }
    });
  }
  _getResolver(e, t) {
    return fe(this, void 0, void 0, function* () {
      t == null && (t = 'ENS');
      const i = yield this.getNetwork();
      i.ensAddress || ge.throwError('network does not support ENS', D.errors.UNSUPPORTED_OPERATION, { operation: t, network: i.name });
      try {
        const r = yield this.call({
          to: i.ensAddress,
          data: '0x0178b8bf' + Cu(e).substring(2),
        });
        return this.formatter.callAddress(r);
      } catch {}
      return null;
    });
  }
  resolveName(e) {
    return fe(this, void 0, void 0, function* () {
      e = yield e;
      try {
        return Promise.resolve(this.formatter.address(e));
      } catch (i) {
        if (Me(e)) throw i;
      }
      typeof e != 'string' && ge.throwArgumentError('invalid ENS name', 'name', e);
      const t = yield this.getResolver(e);
      return t ? yield t.getAddress() : null;
    });
  }
  lookupAddress(e) {
    return fe(this, void 0, void 0, function* () {
      (e = yield e), (e = this.formatter.address(e));
      const t = e.substring(2).toLowerCase() + '.addr.reverse',
        i = yield this._getResolver(t, 'lookupAddress');
      if (i == null) return null;
      const r = Bd(
        yield this.call({
          to: i,
          data: '0x691f3431' + Cu(t).substring(2),
        }),
        0,
      );
      return (yield this.resolveName(r)) != e ? null : r;
    });
  }
  getAvatar(e) {
    return fe(this, void 0, void 0, function* () {
      let t = null;
      if (Me(e)) {
        const s = this.formatter.address(e).substring(2).toLowerCase() + '.addr.reverse',
          a = yield this._getResolver(s, 'getAvatar');
        if (!a) return null;
        t = new P2(this, a, s);
        try {
          const o = yield t.getAvatar();
          if (o) return o.url;
        } catch (o) {
          if (o.code !== D.errors.CALL_EXCEPTION) throw o;
        }
        try {
          const o = Bd(
            yield this.call({
              to: a,
              data: '0x691f3431' + Cu(s).substring(2),
            }),
            0,
          );
          t = yield this.getResolver(o);
        } catch (o) {
          if (o.code !== D.errors.CALL_EXCEPTION) throw o;
          return null;
        }
      } else if (((t = yield this.getResolver(e)), !t)) return null;
      const i = yield t.getAvatar();
      return i == null ? null : i.url;
    });
  }
  perform(e, t) {
    return ge.throwError(e + ' not implemented', D.errors.NOT_IMPLEMENTED, { operation: e });
  }
  _startEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _stopEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _addEventListener(e, t, i) {
    const r = new FR(Ga(e), t, i);
    return this._events.push(r), this._startEvent(r), this;
  }
  on(e, t) {
    return this._addEventListener(e, t, !1);
  }
  once(e, t) {
    return this._addEventListener(e, t, !0);
  }
  emit(e, ...t) {
    let i = !1,
      r = [],
      s = Ga(e);
    return (
      (this._events = this._events.filter((a) =>
        a.tag !== s
          ? !0
          : (setTimeout(() => {
              a.listener.apply(this, t);
            }, 0),
            (i = !0),
            a.once ? (r.push(a), !1) : !0),
      )),
      r.forEach((a) => {
        this._stopEvent(a);
      }),
      i
    );
  }
  listenerCount(e) {
    if (!e) return this._events.length;
    let t = Ga(e);
    return this._events.filter((i) => i.tag === t).length;
  }
  listeners(e) {
    if (e == null) return this._events.map((i) => i.listener);
    let t = Ga(e);
    return this._events.filter((i) => i.tag === t).map((i) => i.listener);
  }
  off(e, t) {
    if (t == null) return this.removeAllListeners(e);
    const i = [];
    let r = !1,
      s = Ga(e);
    return (
      (this._events = this._events.filter((a) => (a.tag !== s || a.listener != t || r ? !0 : ((r = !0), i.push(a), !1)))),
      i.forEach((a) => {
        this._stopEvent(a);
      }),
      this
    );
  }
  removeAllListeners(e) {
    let t = [];
    if (e == null) (t = this._events), (this._events = []);
    else {
      const i = Ga(e);
      this._events = this._events.filter((r) => (r.tag !== i ? !0 : (t.push(r), !1)));
    }
    return (
      t.forEach((i) => {
        this._stopEvent(i);
      }),
      this
    );
  }
}
var mr =
  (globalThis && globalThis.__awaiter) ||
  function (n, e, t, i) {
    function r(s) {
      return s instanceof t
        ? s
        : new t(function (a) {
            a(s);
          });
    }
    return new (t || (t = Promise))(function (s, a) {
      function o(c) {
        try {
          l(i.next(c));
        } catch (f) {
          a(f);
        }
      }
      function u(c) {
        try {
          l(i.throw(c));
        } catch (f) {
          a(f);
        }
      }
      function l(c) {
        c.done ? s(c.value) : r(c.value).then(o, u);
      }
      l((i = i.apply(n, e || [])).next());
    });
  };
const zt = new D(k0),
  VR = ['call', 'estimateGas'];
function _u(n, e) {
  if (n == null) return null;
  if (typeof n.message == 'string' && n.message.match('reverted')) {
    const t = Me(n.data) ? n.data : null;
    if (!e || t) return { message: n.message, data: t };
  }
  if (typeof n == 'object') {
    for (const t in n) {
      const i = _u(n[t], e);
      if (i) return i;
    }
    return null;
  }
  if (typeof n == 'string')
    try {
      return _u(JSON.parse(n), e);
    } catch {}
  return null;
}
function U6(n, e, t) {
  const i = t.transaction || t.signedTransaction;
  if (n === 'call') {
    const s = _u(e, !0);
    if (s) return s.data;
    zt.throwError('missing revert data in call exception; Transaction reverted without a reason string', D.errors.CALL_EXCEPTION, {
      data: '0x',
      transaction: i,
      error: e,
    });
  }
  if (n === 'estimateGas') {
    let s = _u(e.body, !1);
    s == null && (s = _u(e, !1)),
      s &&
        zt.throwError('cannot estimate gas; transaction may fail or may require manual gas limit', D.errors.UNPREDICTABLE_GAS_LIMIT, {
          reason: s.message,
          method: n,
          transaction: i,
          error: e,
        });
  }
  let r = e.message;
  throw (
    (e.code === D.errors.SERVER_ERROR && e.error && typeof e.error.message == 'string'
      ? (r = e.error.message)
      : typeof e.body == 'string'
      ? (r = e.body)
      : typeof e.responseText == 'string' && (r = e.responseText),
    (r = (r || '').toLowerCase()),
    r.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) &&
      zt.throwError('insufficient funds for intrinsic transaction cost', D.errors.INSUFFICIENT_FUNDS, {
        error: e,
        method: n,
        transaction: i,
      }),
    r.match(/nonce (is )?too low/i) &&
      zt.throwError('nonce has already been used', D.errors.NONCE_EXPIRED, {
        error: e,
        method: n,
        transaction: i,
      }),
    r.match(/replacement transaction underpriced|transaction gas price.*too low/i) &&
      zt.throwError('replacement fee too low', D.errors.REPLACEMENT_UNDERPRICED, {
        error: e,
        method: n,
        transaction: i,
      }),
    r.match(/only replay-protected/i) &&
      zt.throwError('legacy pre-eip-155 transactions not supported', D.errors.UNSUPPORTED_OPERATION, {
        error: e,
        method: n,
        transaction: i,
      }),
    VR.indexOf(n) >= 0 &&
      r.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) &&
      zt.throwError('cannot estimate gas; transaction may fail or may require manual gas limit', D.errors.UNPREDICTABLE_GAS_LIMIT, {
        error: e,
        method: n,
        transaction: i,
      }),
    e)
  );
}
function N2(n) {
  return new Promise(function (e) {
    setTimeout(e, n);
  });
}
function zR(n) {
  if (n.error) {
    const e = new Error(n.error.message);
    throw ((e.code = n.error.code), (e.data = n.error.data), e);
  }
  return n.result;
}
function ru(n) {
  return n && n.toLowerCase();
}
const Fy = {};
class j6 extends Fa {
  constructor(e, t, i) {
    if ((super(), e !== Fy)) throw new Error('do not call the JsonRpcSigner constructor directly; use provider.getSigner');
    j(this, 'provider', t),
      i == null && (i = 0),
      typeof i == 'string'
        ? (j(this, '_address', this.provider.formatter.address(i)), j(this, '_index', null))
        : typeof i == 'number'
        ? (j(this, '_index', i), j(this, '_address', null))
        : zt.throwArgumentError('invalid address or index', 'addressOrIndex', i);
  }
  connect(e) {
    return zt.throwError('cannot alter JSON-RPC Signer connection', D.errors.UNSUPPORTED_OPERATION, {
      operation: 'connect',
    });
  }
  connectUnchecked() {
    return new GR(Fy, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address
      ? Promise.resolve(this._address)
      : this.provider.send('eth_accounts', []).then(
          (e) => (
            e.length <= this._index &&
              zt.throwError('unknown account #' + this._index, D.errors.UNSUPPORTED_OPERATION, {
                operation: 'getAddress',
              }),
            this.provider.formatter.address(e[this._index])
          ),
        );
  }
  sendUncheckedTransaction(e) {
    e = Gt(e);
    const t = this.getAddress().then((i) => (i && (i = i.toLowerCase()), i));
    if (e.gasLimit == null) {
      const i = Gt(e);
      (i.from = t), (e.gasLimit = this.provider.estimateGas(i));
    }
    return (
      e.to != null &&
        (e.to = Promise.resolve(e.to).then((i) =>
          mr(this, void 0, void 0, function* () {
            if (i == null) return null;
            const r = yield this.provider.resolveName(i);
            return r == null && zt.throwArgumentError('provided ENS name resolves to null', 'tx.to', i), r;
          }),
        )),
      Ot({
        tx: Ot(e),
        sender: t,
      }).then(({ tx: i, sender: r }) => {
        i.from != null ? i.from.toLowerCase() !== r && zt.throwArgumentError('from address mismatch', 'transaction', e) : (i.from = r);
        const s = this.provider.constructor.hexlifyTransaction(i, { from: !0 });
        return this.provider.send('eth_sendTransaction', [s]).then(
          (a) => a,
          (a) => (
            typeof a.message == 'string' &&
              a.message.match(/user denied/i) &&
              zt.throwError('user rejected transaction', D.errors.ACTION_REJECTED, {
                action: 'sendTransaction',
                transaction: i,
              }),
            U6('sendTransaction', a, s)
          ),
        );
      })
    );
  }
  signTransaction(e) {
    return zt.throwError('signing transactions is unsupported', D.errors.UNSUPPORTED_OPERATION, {
      operation: 'signTransaction',
    });
  }
  sendTransaction(e) {
    return mr(this, void 0, void 0, function* () {
      const t = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval),
        i = yield this.sendUncheckedTransaction(e);
      try {
        return yield ao(
          () =>
            mr(this, void 0, void 0, function* () {
              const r = yield this.provider.getTransaction(i);
              if (r !== null) return this.provider._wrapTransaction(r, i, t);
            }),
          { oncePoll: this.provider },
        );
      } catch (r) {
        throw ((r.transactionHash = i), r);
      }
    });
  }
  signMessage(e) {
    return mr(this, void 0, void 0, function* () {
      const t = typeof e == 'string' ? $t(e) : e,
        i = yield this.getAddress();
      try {
        return yield this.provider.send('personal_sign', [K(t), i.toLowerCase()]);
      } catch (r) {
        throw (
          (typeof r.message == 'string' &&
            r.message.match(/user denied/i) &&
            zt.throwError('user rejected signing', D.errors.ACTION_REJECTED, {
              action: 'signMessage',
              from: i,
              messageData: e,
            }),
          r)
        );
      }
    });
  }
  _legacySignMessage(e) {
    return mr(this, void 0, void 0, function* () {
      const t = typeof e == 'string' ? $t(e) : e,
        i = yield this.getAddress();
      try {
        return yield this.provider.send('eth_sign', [i.toLowerCase(), K(t)]);
      } catch (r) {
        throw (
          (typeof r.message == 'string' &&
            r.message.match(/user denied/i) &&
            zt.throwError('user rejected signing', D.errors.ACTION_REJECTED, {
              action: '_legacySignMessage',
              from: i,
              messageData: e,
            }),
          r)
        );
      }
    });
  }
  _signTypedData(e, t, i) {
    return mr(this, void 0, void 0, function* () {
      const r = yield an.resolveNames(e, t, i, (a) => this.provider.resolveName(a)),
        s = yield this.getAddress();
      try {
        return yield this.provider.send('eth_signTypedData_v4', [s.toLowerCase(), JSON.stringify(an.getPayload(r.domain, t, r.value))]);
      } catch (a) {
        throw (
          (typeof a.message == 'string' &&
            a.message.match(/user denied/i) &&
            zt.throwError('user rejected signing', D.errors.ACTION_REJECTED, {
              action: '_signTypedData',
              from: s,
              messageData: { domain: r.domain, types: t, value: r.value },
            }),
          a)
        );
      }
    });
  }
  unlock(e) {
    return mr(this, void 0, void 0, function* () {
      const t = this.provider,
        i = yield this.getAddress();
      return t.send('personal_unlockAccount', [i.toLowerCase(), e, null]);
    });
  }
}
class GR extends j6 {
  sendTransaction(e) {
    return this.sendUncheckedTransaction(e).then((t) => ({
      hash: t,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (i) => this.provider.waitForTransaction(t, i),
    }));
  }
}
const qR = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0,
};
class HR extends jR {
  constructor(e, t) {
    let i = t;
    i == null &&
      (i = new Promise((r, s) => {
        setTimeout(() => {
          this.detectNetwork().then(
            (a) => {
              r(a);
            },
            (a) => {
              s(a);
            },
          );
        }, 0);
      })),
      super(i),
      e || (e = Oi(this.constructor, 'defaultUrl')()),
      typeof e == 'string'
        ? j(
            this,
            'connection',
            Object.freeze({
              url: e,
            }),
          )
        : j(this, 'connection', Object.freeze(Gt(e))),
      (this._nextId = 42);
  }
  get _cache() {
    return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache;
  }
  static defaultUrl() {
    return 'http://localhost:8545';
  }
  detectNetwork() {
    return (
      this._cache.detectNetwork ||
        ((this._cache.detectNetwork = this._uncachedDetectNetwork()),
        setTimeout(() => {
          this._cache.detectNetwork = null;
        }, 0)),
      this._cache.detectNetwork
    );
  }
  _uncachedDetectNetwork() {
    return mr(this, void 0, void 0, function* () {
      yield N2(0);
      let e = null;
      try {
        e = yield this.send('eth_chainId', []);
      } catch {
        try {
          e = yield this.send('net_version', []);
        } catch {}
      }
      if (e != null) {
        const t = Oi(this.constructor, 'getNetwork');
        try {
          return t(q.from(e).toNumber());
        } catch (i) {
          return zt.throwError('could not detect network', D.errors.NETWORK_ERROR, {
            chainId: e,
            event: 'invalidNetwork',
            serverError: i,
          });
        }
      }
      return zt.throwError('could not detect network', D.errors.NETWORK_ERROR, {
        event: 'noNetwork',
      });
    });
  }
  getSigner(e) {
    return new j6(Fy, this, e);
  }
  getUncheckedSigner(e) {
    return this.getSigner(e).connectUnchecked();
  }
  listAccounts() {
    return this.send('eth_accounts', []).then((e) => e.map((t) => this.formatter.address(t)));
  }
  send(e, t) {
    const i = {
      method: e,
      params: t,
      id: this._nextId++,
      jsonrpc: '2.0',
    };
    this.emit('debug', {
      action: 'request',
      request: xs(i),
      provider: this,
    });
    const r = ['eth_chainId', 'eth_blockNumber'].indexOf(e) >= 0;
    if (r && this._cache[e]) return this._cache[e];
    const s = lp(this.connection, JSON.stringify(i), zR).then(
      (a) => (
        this.emit('debug', {
          action: 'response',
          request: i,
          response: a,
          provider: this,
        }),
        a
      ),
      (a) => {
        throw (
          (this.emit('debug', {
            action: 'response',
            error: a,
            request: i,
            provider: this,
          }),
          a)
        );
      },
    );
    return (
      r &&
        ((this._cache[e] = s),
        setTimeout(() => {
          this._cache[e] = null;
        }, 0)),
      s
    );
  }
  prepareRequest(e, t) {
    switch (e) {
      case 'getBlockNumber':
        return ['eth_blockNumber', []];
      case 'getGasPrice':
        return ['eth_gasPrice', []];
      case 'getBalance':
        return ['eth_getBalance', [ru(t.address), t.blockTag]];
      case 'getTransactionCount':
        return ['eth_getTransactionCount', [ru(t.address), t.blockTag]];
      case 'getCode':
        return ['eth_getCode', [ru(t.address), t.blockTag]];
      case 'getStorageAt':
        return ['eth_getStorageAt', [ru(t.address), Le(t.position, 32), t.blockTag]];
      case 'sendTransaction':
        return ['eth_sendRawTransaction', [t.signedTransaction]];
      case 'getBlock':
        return t.blockTag ? ['eth_getBlockByNumber', [t.blockTag, !!t.includeTransactions]] : t.blockHash ? ['eth_getBlockByHash', [t.blockHash, !!t.includeTransactions]] : null;
      case 'getTransaction':
        return ['eth_getTransactionByHash', [t.transactionHash]];
      case 'getTransactionReceipt':
        return ['eth_getTransactionReceipt', [t.transactionHash]];
      case 'call':
        return ['eth_call', [Oi(this.constructor, 'hexlifyTransaction')(t.transaction, { from: !0 }), t.blockTag]];
      case 'estimateGas':
        return ['eth_estimateGas', [Oi(this.constructor, 'hexlifyTransaction')(t.transaction, { from: !0 })]];
      case 'getLogs':
        return t.filter && t.filter.address != null && (t.filter.address = ru(t.filter.address)), ['eth_getLogs', [t.filter]];
    }
    return null;
  }
  perform(e, t) {
    return mr(this, void 0, void 0, function* () {
      if (e === 'call' || e === 'estimateGas') {
        const r = t.transaction;
        if (r && r.type != null && q.from(r.type).isZero() && r.maxFeePerGas == null && r.maxPriorityFeePerGas == null) {
          const s = yield this.getFeeData();
          s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && ((t = Gt(t)), (t.transaction = Gt(r)), delete t.transaction.type);
        }
      }
      const i = this.prepareRequest(e, t);
      i == null && zt.throwError(e + ' not implemented', D.errors.NOT_IMPLEMENTED, { operation: e });
      try {
        return yield this.send(i[0], i[1]);
      } catch (r) {
        return U6(e, r, t);
      }
    });
  }
  _startEvent(e) {
    e.tag === 'pending' && this._startPending(), super._startEvent(e);
  }
  _startPending() {
    if (this._pendingFilter != null) return;
    const e = this,
      t = this.send('eth_newPendingTransactionFilter', []);
    (this._pendingFilter = t),
      t
        .then(function (i) {
          function r() {
            e.send('eth_getFilterChanges', [i])
              .then(function (s) {
                if (e._pendingFilter != t) return null;
                let a = Promise.resolve();
                return (
                  s.forEach(function (o) {
                    (e._emitted['t:' + o.toLowerCase()] = 'pending'),
                      (a = a.then(function () {
                        return e.getTransaction(o).then(function (u) {
                          return e.emit('pending', u), null;
                        });
                      }));
                  }),
                  a.then(function () {
                    return N2(1e3);
                  })
                );
              })
              .then(function () {
                if (e._pendingFilter != t) {
                  e.send('eth_uninstallFilter', [i]);
                  return;
                }
                return (
                  setTimeout(function () {
                    r();
                  }, 0),
                  null
                );
              })
              .catch((s) => {});
          }
          return r(), i;
        })
        .catch((i) => {});
  }
  _stopEvent(e) {
    e.tag === 'pending' && this.listenerCount('pending') === 0 && (this._pendingFilter = null), super._stopEvent(e);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(e, t) {
    const i = Gt(qR);
    if (t) for (const s in t) t[s] && (i[s] = !0);
    u0(e, i);
    const r = {};
    return (
      ['chainId', 'gasLimit', 'gasPrice', 'type', 'maxFeePerGas', 'maxPriorityFeePerGas', 'nonce', 'value'].forEach(function (s) {
        if (e[s] == null) return;
        const a = Xc(q.from(e[s]));
        s === 'gasLimit' && (s = 'gas'), (r[s] = a);
      }),
      ['from', 'to', 'data'].forEach(function (s) {
        e[s] != null && (r[s] = K(e[s]));
      }),
      e.accessList && (r.accessList = $a(e.accessList)),
      r
    );
  }
}
const KR = 'solidity/5.7.0',
  WR = new RegExp('^bytes([0-9]+)$'),
  JR = new RegExp('^(u?int)([0-9]*)$'),
  QR = new RegExp('^(.*)\\[([0-9]*)\\]$'),
  YR = '0000000000000000000000000000000000000000000000000000000000000000',
  Za = new D(KR);
function V6(n, e, t) {
  switch (n) {
    case 'address':
      return t ? Au(e, 32) : H(e);
    case 'string':
      return $t(e);
    case 'bytes':
      return H(e);
    case 'bool':
      return (e = e ? '0x01' : '0x00'), t ? Au(e, 32) : H(e);
  }
  let i = n.match(JR);
  if (i) {
    let r = parseInt(i[2] || '256');
    return ((i[2] && String(r) !== i[2]) || r % 8 !== 0 || r === 0 || r > 256) && Za.throwArgumentError('invalid number type', 'type', n), t && (r = 256), (e = q.from(e).toTwos(r)), Au(e, r / 8);
  }
  if (((i = n.match(WR)), i)) {
    const r = parseInt(i[1]);
    return (
      (String(r) !== i[1] || r === 0 || r > 32) && Za.throwArgumentError('invalid bytes type', 'type', n),
      H(e).byteLength !== r && Za.throwArgumentError(`invalid value for ${n}`, 'value', e),
      t ? H((e + YR).substring(0, 66)) : e
    );
  }
  if (((i = n.match(QR)), i && Array.isArray(e))) {
    const r = i[1];
    parseInt(i[2] || String(e.length)) != e.length && Za.throwArgumentError(`invalid array length for ${n}`, 'value', e);
    const a = [];
    return (
      e.forEach(function (o) {
        a.push(V6(r, o, !0));
      }),
      Ge(a)
    );
  }
  return Za.throwArgumentError('invalid type', 'type', n);
}
function P0(n, e) {
  n.length != e.length && Za.throwArgumentError('wrong number of values; expected ${ types.length }', 'values', e);
  const t = [];
  return (
    n.forEach(function (i, r) {
      t.push(V6(i, e[r]));
    }),
    K(Ge(t))
  );
}
function XR(n, e) {
  return De(P0(n, e));
}
function ZR(n, e) {
  return Fr(P0(n, e));
}
const eI = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        keccak256: XR,
        pack: P0,
        sha256: ZR,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  tI = 'units/5.7.0',
  z6 = new D(tI),
  G6 = ['wei', 'kwei', 'mwei', 'gwei', 'szabo', 'finney', 'ether'];
function nI(n) {
  const e = String(n).split('.');
  (e.length > 2 || !e[0].match(/^-?[0-9]*$/) || (e[1] && !e[1].match(/^[0-9]*$/)) || n === '.' || n === '-.') && z6.throwArgumentError('invalid value', 'value', n);
  let t = e[0],
    i = '';
  for (t.substring(0, 1) === '-' && ((i = '-'), (t = t.substring(1))); t.substring(0, 1) === '0'; ) t = t.substring(1);
  t === '' && (t = '0');
  let r = '';
  for (e.length === 2 && (r = '.' + (e[1] || '0')); r.length > 2 && r[r.length - 1] === '0'; ) r = r.substring(0, r.length - 1);
  const s = [];
  for (; t.length; )
    if (t.length <= 3) {
      s.unshift(t);
      break;
    } else {
      const a = t.length - 3;
      s.unshift(t.substring(a)), (t = t.substring(0, a));
    }
  return i + s.join(',') + r;
}
function vc(n, e) {
  if (typeof e == 'string') {
    const t = G6.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return _d(n, e ?? 18);
}
function q6(n, e) {
  if ((typeof n != 'string' && z6.throwArgumentError('value must be a string', 'value', n), typeof e == 'string')) {
    const t = G6.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return Ui(n, e ?? 18);
}
function H6(n) {
  return vc(n, 18);
}
function ea(n) {
  return q6(n, 18);
}
const iI = /* @__PURE__ */ Object.freeze(
    /* @__PURE__ */ Object.defineProperty(
      {
        __proto__: null,
        commify: nI,
        formatEther: H6,
        formatUnits: vc,
        parseEther: ea,
        parseUnits: q6,
      },
      Symbol.toStringTag,
      { value: 'Module' },
    ),
  ),
  N0 = JSON,
  rI = (n) => n.toUpperCase(),
  sI = (n) => {
    const e = {};
    return (
      n.forEach((t, i) => {
        e[i] = t;
      }),
      e
    );
  },
  aI = (n, e, t) =>
    n.document
      ? n
      : {
          document: n,
          variables: e,
          requestHeaders: t,
          signal: void 0,
        },
  oI = (n, e, t) =>
    n.query
      ? n
      : {
          query: n,
          variables: e,
          requestHeaders: t,
          signal: void 0,
        },
  uI = (n, e) =>
    n.documents
      ? n
      : {
          documents: n,
          requestHeaders: e,
          signal: void 0,
        };
function Fd(n, e) {
  if (!!!n) throw new Error(e);
}
function lI(n) {
  return typeof n == 'object' && n !== null;
}
function dI(n, e) {
  if (!!!n) throw new Error(e ?? 'Unexpected invariant triggered.');
}
const cI = /\r\n|[\n\r]/g;
function Ly(n, e) {
  let t = 0,
    i = 1;
  for (const r of n.body.matchAll(cI)) {
    if ((typeof r.index == 'number' || dI(!1), r.index >= e)) break;
    (t = r.index + r[0].length), (i += 1);
  }
  return {
    line: i,
    column: e + 1 - t,
  };
}
function pI(n) {
  return K6(n.source, Ly(n.source, n.start));
}
function K6(n, e) {
  const t = n.locationOffset.column - 1,
    i = ''.padStart(t) + n.body,
    r = e.line - 1,
    s = n.locationOffset.line - 1,
    a = e.line + s,
    o = e.line === 1 ? t : 0,
    u = e.column + o,
    l = `${n.name}:${a}:${u}
`,
    c = i.split(/\r\n|[\n\r]/g),
    f = c[r];
  if (f.length > 120) {
    const m = Math.floor(u / 80),
      w = u % 80,
      v = [];
    for (let T = 0; T < f.length; T += 80) v.push(f.slice(T, T + 80));
    return l + D2([[`${a} |`, v[0]], ...v.slice(1, m + 1).map((T) => ['|', T]), ['|', '^'.padStart(w)], ['|', v[m + 1]]]);
  }
  return (
    l +
    D2([
      // Lines specified like this: ["prefix", "string"],
      [`${a - 1} |`, c[r - 1]],
      [`${a} |`, f],
      ['|', '^'.padStart(u)],
      [`${a + 1} |`, c[r + 1]],
    ])
  );
}
function D2(n) {
  const e = n.filter(([i, r]) => r !== void 0),
    t = Math.max(...e.map(([i]) => i.length));
  return e.map(([i, r]) => i.padStart(t) + (r ? ' ' + r : '')).join(`
`);
}
function fI(n) {
  const e = n[0];
  return e == null || 'kind' in e || 'length' in e
    ? {
        nodes: e,
        source: n[1],
        positions: n[2],
        path: n[3],
        originalError: n[4],
        extensions: n[5],
      }
    : e;
}
class D0 extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(e, ...t) {
    var i, r, s;
    const { nodes: a, source: o, positions: u, path: l, originalError: c, extensions: f } = fI(t);
    super(e), (this.name = 'GraphQLError'), (this.path = l ?? void 0), (this.originalError = c ?? void 0), (this.nodes = B2(Array.isArray(a) ? a : a ? [a] : void 0));
    const m = B2((i = this.nodes) === null || i === void 0 ? void 0 : i.map((v) => v.loc).filter((v) => v != null));
    (this.source = o ?? (m == null || (r = m[0]) === null || r === void 0 ? void 0 : r.source)),
      (this.positions = u ?? m?.map((v) => v.start)),
      (this.locations = u && o ? u.map((v) => Ly(o, v)) : m?.map((v) => Ly(v.source, v.start)));
    const w = lI(c?.extensions) ? c?.extensions : void 0;
    (this.extensions = (s = f ?? w) !== null && s !== void 0 ? s : /* @__PURE__ */ Object.create(null)),
      Object.defineProperties(this, {
        message: {
          writable: !0,
          enumerable: !0,
        },
        name: {
          enumerable: !1,
        },
        nodes: {
          enumerable: !1,
        },
        source: {
          enumerable: !1,
        },
        positions: {
          enumerable: !1,
        },
        originalError: {
          enumerable: !1,
        },
      }),
      c != null && c.stack
        ? Object.defineProperty(this, 'stack', {
            value: c.stack,
            writable: !0,
            configurable: !0,
          })
        : Error.captureStackTrace
        ? Error.captureStackTrace(this, D0)
        : Object.defineProperty(this, 'stack', {
            value: Error().stack,
            writable: !0,
            configurable: !0,
          });
  }
  get [Symbol.toStringTag]() {
    return 'GraphQLError';
  }
  toString() {
    let e = this.message;
    if (this.nodes)
      for (const t of this.nodes)
        t.loc &&
          (e +=
            `

` + pI(t.loc));
    else if (this.source && this.locations)
      for (const t of this.locations)
        e +=
          `

` + K6(this.source, t);
    return e;
  }
  toJSON() {
    const e = {
      message: this.message,
    };
    return (
      this.locations != null && (e.locations = this.locations),
      this.path != null && (e.path = this.path),
      this.extensions != null && Object.keys(this.extensions).length > 0 && (e.extensions = this.extensions),
      e
    );
  }
}
function B2(n) {
  return n === void 0 || n.length === 0 ? void 0 : n;
}
function Zt(n, e, t) {
  return new D0(`Syntax Error: ${t}`, {
    source: n,
    positions: [e],
  });
}
class yI {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(e, t, i) {
    (this.start = e.start), (this.end = t.end), (this.startToken = e), (this.endToken = t), (this.source = i);
  }
  get [Symbol.toStringTag]() {
    return 'Location';
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end,
    };
  }
}
class W6 {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(e, t, i, r, s, a) {
    (this.kind = e), (this.start = t), (this.end = i), (this.line = r), (this.column = s), (this.value = a), (this.prev = null), (this.next = null);
  }
  get [Symbol.toStringTag]() {
    return 'Token';
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column,
    };
  }
}
const J6 = {
    Name: [],
    Document: ['definitions'],
    OperationDefinition: ['name', 'variableDefinitions', 'directives', 'selectionSet'],
    VariableDefinition: ['variable', 'type', 'defaultValue', 'directives'],
    Variable: ['name'],
    SelectionSet: ['selections'],
    Field: ['alias', 'name', 'arguments', 'directives', 'selectionSet'],
    Argument: ['name', 'value'],
    FragmentSpread: ['name', 'directives'],
    InlineFragment: ['typeCondition', 'directives', 'selectionSet'],
    FragmentDefinition: [
      'name',
      // Note: fragment variable definitions are deprecated and will removed in v17.0.0
      'variableDefinitions',
      'typeCondition',
      'directives',
      'selectionSet',
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ['values'],
    ObjectValue: ['fields'],
    ObjectField: ['name', 'value'],
    Directive: ['name', 'arguments'],
    NamedType: ['name'],
    ListType: ['type'],
    NonNullType: ['type'],
    SchemaDefinition: ['description', 'directives', 'operationTypes'],
    OperationTypeDefinition: ['type'],
    ScalarTypeDefinition: ['description', 'name', 'directives'],
    ObjectTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
    FieldDefinition: ['description', 'name', 'arguments', 'type', 'directives'],
    InputValueDefinition: ['description', 'name', 'type', 'defaultValue', 'directives'],
    InterfaceTypeDefinition: ['description', 'name', 'interfaces', 'directives', 'fields'],
    UnionTypeDefinition: ['description', 'name', 'directives', 'types'],
    EnumTypeDefinition: ['description', 'name', 'directives', 'values'],
    EnumValueDefinition: ['description', 'name', 'directives'],
    InputObjectTypeDefinition: ['description', 'name', 'directives', 'fields'],
    DirectiveDefinition: ['description', 'name', 'arguments', 'locations'],
    SchemaExtension: ['directives', 'operationTypes'],
    ScalarTypeExtension: ['name', 'directives'],
    ObjectTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
    InterfaceTypeExtension: ['name', 'interfaces', 'directives', 'fields'],
    UnionTypeExtension: ['name', 'directives', 'types'],
    EnumTypeExtension: ['name', 'directives', 'values'],
    InputObjectTypeExtension: ['name', 'directives', 'fields'],
  },
  hI = new Set(Object.keys(J6));
function F2(n) {
  const e = n?.kind;
  return typeof e == 'string' && hI.has(e);
}
var oo;
(function (n) {
  (n.QUERY = 'query'), (n.MUTATION = 'mutation'), (n.SUBSCRIPTION = 'subscription');
})(oo || (oo = {}));
var $y;
(function (n) {
  (n.QUERY = 'QUERY'),
    (n.MUTATION = 'MUTATION'),
    (n.SUBSCRIPTION = 'SUBSCRIPTION'),
    (n.FIELD = 'FIELD'),
    (n.FRAGMENT_DEFINITION = 'FRAGMENT_DEFINITION'),
    (n.FRAGMENT_SPREAD = 'FRAGMENT_SPREAD'),
    (n.INLINE_FRAGMENT = 'INLINE_FRAGMENT'),
    (n.VARIABLE_DEFINITION = 'VARIABLE_DEFINITION'),
    (n.SCHEMA = 'SCHEMA'),
    (n.SCALAR = 'SCALAR'),
    (n.OBJECT = 'OBJECT'),
    (n.FIELD_DEFINITION = 'FIELD_DEFINITION'),
    (n.ARGUMENT_DEFINITION = 'ARGUMENT_DEFINITION'),
    (n.INTERFACE = 'INTERFACE'),
    (n.UNION = 'UNION'),
    (n.ENUM = 'ENUM'),
    (n.ENUM_VALUE = 'ENUM_VALUE'),
    (n.INPUT_OBJECT = 'INPUT_OBJECT'),
    (n.INPUT_FIELD_DEFINITION = 'INPUT_FIELD_DEFINITION');
})($y || ($y = {}));
var de;
(function (n) {
  (n.NAME = 'Name'),
    (n.DOCUMENT = 'Document'),
    (n.OPERATION_DEFINITION = 'OperationDefinition'),
    (n.VARIABLE_DEFINITION = 'VariableDefinition'),
    (n.SELECTION_SET = 'SelectionSet'),
    (n.FIELD = 'Field'),
    (n.ARGUMENT = 'Argument'),
    (n.FRAGMENT_SPREAD = 'FragmentSpread'),
    (n.INLINE_FRAGMENT = 'InlineFragment'),
    (n.FRAGMENT_DEFINITION = 'FragmentDefinition'),
    (n.VARIABLE = 'Variable'),
    (n.INT = 'IntValue'),
    (n.FLOAT = 'FloatValue'),
    (n.STRING = 'StringValue'),
    (n.BOOLEAN = 'BooleanValue'),
    (n.NULL = 'NullValue'),
    (n.ENUM = 'EnumValue'),
    (n.LIST = 'ListValue'),
    (n.OBJECT = 'ObjectValue'),
    (n.OBJECT_FIELD = 'ObjectField'),
    (n.DIRECTIVE = 'Directive'),
    (n.NAMED_TYPE = 'NamedType'),
    (n.LIST_TYPE = 'ListType'),
    (n.NON_NULL_TYPE = 'NonNullType'),
    (n.SCHEMA_DEFINITION = 'SchemaDefinition'),
    (n.OPERATION_TYPE_DEFINITION = 'OperationTypeDefinition'),
    (n.SCALAR_TYPE_DEFINITION = 'ScalarTypeDefinition'),
    (n.OBJECT_TYPE_DEFINITION = 'ObjectTypeDefinition'),
    (n.FIELD_DEFINITION = 'FieldDefinition'),
    (n.INPUT_VALUE_DEFINITION = 'InputValueDefinition'),
    (n.INTERFACE_TYPE_DEFINITION = 'InterfaceTypeDefinition'),
    (n.UNION_TYPE_DEFINITION = 'UnionTypeDefinition'),
    (n.ENUM_TYPE_DEFINITION = 'EnumTypeDefinition'),
    (n.ENUM_VALUE_DEFINITION = 'EnumValueDefinition'),
    (n.INPUT_OBJECT_TYPE_DEFINITION = 'InputObjectTypeDefinition'),
    (n.DIRECTIVE_DEFINITION = 'DirectiveDefinition'),
    (n.SCHEMA_EXTENSION = 'SchemaExtension'),
    (n.SCALAR_TYPE_EXTENSION = 'ScalarTypeExtension'),
    (n.OBJECT_TYPE_EXTENSION = 'ObjectTypeExtension'),
    (n.INTERFACE_TYPE_EXTENSION = 'InterfaceTypeExtension'),
    (n.UNION_TYPE_EXTENSION = 'UnionTypeExtension'),
    (n.ENUM_TYPE_EXTENSION = 'EnumTypeExtension'),
    (n.INPUT_OBJECT_TYPE_EXTENSION = 'InputObjectTypeExtension');
})(de || (de = {}));
function Uy(n) {
  return n === 9 || n === 32;
}
function tl(n) {
  return n >= 48 && n <= 57;
}
function Q6(n) {
  return (
    (n >= 97 && n <= 122) || // A-Z
    (n >= 65 && n <= 90)
  );
}
function Y6(n) {
  return Q6(n) || n === 95;
}
function mI(n) {
  return Q6(n) || tl(n) || n === 95;
}
function bI(n) {
  var e;
  let t = Number.MAX_SAFE_INTEGER,
    i = null,
    r = -1;
  for (let a = 0; a < n.length; ++a) {
    var s;
    const o = n[a],
      u = gI(o);
    u !== o.length && ((i = (s = i) !== null && s !== void 0 ? s : a), (r = a), a !== 0 && u < t && (t = u));
  }
  return n.map((a, o) => (o === 0 ? a : a.slice(t))).slice((e = i) !== null && e !== void 0 ? e : 0, r + 1);
}
function gI(n) {
  let e = 0;
  for (; e < n.length && Uy(n.charCodeAt(e)); ) ++e;
  return e;
}
function vI(n, e) {
  const t = n.replace(/"""/g, '\\"""'),
    i = t.split(/\r\n|[\n\r]/g),
    r = i.length === 1,
    s = i.length > 1 && i.slice(1).every((w) => w.length === 0 || Uy(w.charCodeAt(0))),
    a = t.endsWith('\\"""'),
    o = n.endsWith('"') && !a,
    u = n.endsWith('\\'),
    l = o || u,
    c =
      !(e != null && e.minimize) && // add leading and trailing new lines only if it improves readability
      (!r || n.length > 70 || l || s || a);
  let f = '';
  const m = r && Uy(n.charCodeAt(0));
  return (
    ((c && !m) || s) &&
      (f += `
`),
    (f += t),
    (c || l) &&
      (f += `
`),
    '"""' + f + '"""'
  );
}
var V;
(function (n) {
  (n.SOF = '<SOF>'),
    (n.EOF = '<EOF>'),
    (n.BANG = '!'),
    (n.DOLLAR = '$'),
    (n.AMP = '&'),
    (n.PAREN_L = '('),
    (n.PAREN_R = ')'),
    (n.SPREAD = '...'),
    (n.COLON = ':'),
    (n.EQUALS = '='),
    (n.AT = '@'),
    (n.BRACKET_L = '['),
    (n.BRACKET_R = ']'),
    (n.BRACE_L = '{'),
    (n.PIPE = '|'),
    (n.BRACE_R = '}'),
    (n.NAME = 'Name'),
    (n.INT = 'Int'),
    (n.FLOAT = 'Float'),
    (n.STRING = 'String'),
    (n.BLOCK_STRING = 'BlockString'),
    (n.COMMENT = 'Comment');
})(V || (V = {}));
class xI {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(e) {
    const t = new W6(V.SOF, 0, 0, 0, 0);
    (this.source = e), (this.lastToken = t), (this.token = t), (this.line = 1), (this.lineStart = 0);
  }
  get [Symbol.toStringTag]() {
    return 'Lexer';
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    return (this.lastToken = this.token), (this.token = this.lookahead());
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let e = this.token;
    if (e.kind !== V.EOF)
      do
        if (e.next) e = e.next;
        else {
          const t = wI(this, e.end);
          (e.next = t), (t.prev = e), (e = t);
        }
      while (e.kind === V.COMMENT);
    return e;
  }
}
function TI(n) {
  return (
    n === V.BANG ||
    n === V.DOLLAR ||
    n === V.AMP ||
    n === V.PAREN_L ||
    n === V.PAREN_R ||
    n === V.SPREAD ||
    n === V.COLON ||
    n === V.EQUALS ||
    n === V.AT ||
    n === V.BRACKET_L ||
    n === V.BRACKET_R ||
    n === V.BRACE_L ||
    n === V.PIPE ||
    n === V.BRACE_R
  );
}
function Ko(n) {
  return (n >= 0 && n <= 55295) || (n >= 57344 && n <= 1114111);
}
function cp(n, e) {
  return X6(n.charCodeAt(e)) && Z6(n.charCodeAt(e + 1));
}
function X6(n) {
  return n >= 55296 && n <= 56319;
}
function Z6(n) {
  return n >= 56320 && n <= 57343;
}
function ga(n, e) {
  const t = n.source.body.codePointAt(e);
  if (t === void 0) return V.EOF;
  if (t >= 32 && t <= 126) {
    const i = String.fromCodePoint(t);
    return i === '"' ? `'"'` : `"${i}"`;
  }
  return 'U+' + t.toString(16).toUpperCase().padStart(4, '0');
}
function jt(n, e, t, i, r) {
  const s = n.line,
    a = 1 + t - n.lineStart;
  return new W6(e, t, i, s, a, r);
}
function wI(n, e) {
  const t = n.source.body,
    i = t.length;
  let r = e;
  for (; r < i; ) {
    const s = t.charCodeAt(r);
    switch (s) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++r;
        continue;
      case 10:
        ++r, ++n.line, (n.lineStart = r);
        continue;
      case 13:
        t.charCodeAt(r + 1) === 10 ? (r += 2) : ++r, ++n.line, (n.lineStart = r);
        continue;
      case 35:
        return AI(n, r);
      case 33:
        return jt(n, V.BANG, r, r + 1);
      case 36:
        return jt(n, V.DOLLAR, r, r + 1);
      case 38:
        return jt(n, V.AMP, r, r + 1);
      case 40:
        return jt(n, V.PAREN_L, r, r + 1);
      case 41:
        return jt(n, V.PAREN_R, r, r + 1);
      case 46:
        if (t.charCodeAt(r + 1) === 46 && t.charCodeAt(r + 2) === 46) return jt(n, V.SPREAD, r, r + 3);
        break;
      case 58:
        return jt(n, V.COLON, r, r + 1);
      case 61:
        return jt(n, V.EQUALS, r, r + 1);
      case 64:
        return jt(n, V.AT, r, r + 1);
      case 91:
        return jt(n, V.BRACKET_L, r, r + 1);
      case 93:
        return jt(n, V.BRACKET_R, r, r + 1);
      case 123:
        return jt(n, V.BRACE_L, r, r + 1);
      case 124:
        return jt(n, V.PIPE, r, r + 1);
      case 125:
        return jt(n, V.BRACE_R, r, r + 1);
      case 34:
        return t.charCodeAt(r + 1) === 34 && t.charCodeAt(r + 2) === 34 ? RI(n, r) : SI(n, r);
    }
    if (tl(s) || s === 45) return EI(n, r, s);
    if (Y6(s)) return II(n, r);
    throw Zt(
      n.source,
      r,
      s === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : Ko(s) || cp(t, r) ? `Unexpected character: ${ga(n, r)}.` : `Invalid character: ${ga(n, r)}.`,
    );
  }
  return jt(n, V.EOF, i, i);
}
function AI(n, e) {
  const t = n.source.body,
    i = t.length;
  let r = e + 1;
  for (; r < i; ) {
    const s = t.charCodeAt(r);
    if (s === 10 || s === 13) break;
    if (Ko(s)) ++r;
    else if (cp(t, r)) r += 2;
    else break;
  }
  return jt(n, V.COMMENT, e, r, t.slice(e + 1, r));
}
function EI(n, e, t) {
  const i = n.source.body;
  let r = e,
    s = t,
    a = !1;
  if ((s === 45 && (s = i.charCodeAt(++r)), s === 48)) {
    if (((s = i.charCodeAt(++r)), tl(s))) throw Zt(n.source, r, `Invalid number, unexpected digit after 0: ${ga(n, r)}.`);
  } else (r = Mf(n, r, s)), (s = i.charCodeAt(r));
  if (
    (s === 46 && ((a = !0), (s = i.charCodeAt(++r)), (r = Mf(n, r, s)), (s = i.charCodeAt(r))),
    (s === 69 || s === 101) && ((a = !0), (s = i.charCodeAt(++r)), (s === 43 || s === 45) && (s = i.charCodeAt(++r)), (r = Mf(n, r, s)), (s = i.charCodeAt(r))),
    s === 46 || Y6(s))
  )
    throw Zt(n.source, r, `Invalid number, expected digit but got: ${ga(n, r)}.`);
  return jt(n, a ? V.FLOAT : V.INT, e, r, i.slice(e, r));
}
function Mf(n, e, t) {
  if (!tl(t)) throw Zt(n.source, e, `Invalid number, expected digit but got: ${ga(n, e)}.`);
  const i = n.source.body;
  let r = e + 1;
  for (; tl(i.charCodeAt(r)); ) ++r;
  return r;
}
function SI(n, e) {
  const t = n.source.body,
    i = t.length;
  let r = e + 1,
    s = r,
    a = '';
  for (; r < i; ) {
    const o = t.charCodeAt(r);
    if (o === 34) return (a += t.slice(s, r)), jt(n, V.STRING, e, r + 1, a);
    if (o === 92) {
      a += t.slice(s, r);
      const u = t.charCodeAt(r + 1) === 117 ? (t.charCodeAt(r + 2) === 123 ? CI(n, r) : MI(n, r)) : _I(n, r);
      (a += u.value), (r += u.size), (s = r);
      continue;
    }
    if (o === 10 || o === 13) break;
    if (Ko(o)) ++r;
    else if (cp(t, r)) r += 2;
    else throw Zt(n.source, r, `Invalid character within String: ${ga(n, r)}.`);
  }
  throw Zt(n.source, r, 'Unterminated string.');
}
function CI(n, e) {
  const t = n.source.body;
  let i = 0,
    r = 3;
  for (; r < 12; ) {
    const s = t.charCodeAt(e + r++);
    if (s === 125) {
      if (r < 5 || !Ko(i)) break;
      return {
        value: String.fromCodePoint(i),
        size: r,
      };
    }
    if (((i = (i << 4) | fu(s)), i < 0)) break;
  }
  throw Zt(n.source, e, `Invalid Unicode escape sequence: "${t.slice(e, e + r)}".`);
}
function MI(n, e) {
  const t = n.source.body,
    i = L2(t, e + 2);
  if (Ko(i))
    return {
      value: String.fromCodePoint(i),
      size: 6,
    };
  if (X6(i) && t.charCodeAt(e + 6) === 92 && t.charCodeAt(e + 7) === 117) {
    const r = L2(t, e + 8);
    if (Z6(r))
      return {
        value: String.fromCodePoint(i, r),
        size: 12,
      };
  }
  throw Zt(n.source, e, `Invalid Unicode escape sequence: "${t.slice(e, e + 6)}".`);
}
function L2(n, e) {
  return (fu(n.charCodeAt(e)) << 12) | (fu(n.charCodeAt(e + 1)) << 8) | (fu(n.charCodeAt(e + 2)) << 4) | fu(n.charCodeAt(e + 3));
}
function fu(n) {
  return n >= 48 && n <= 57 ? n - 48 : n >= 65 && n <= 70 ? n - 55 : n >= 97 && n <= 102 ? n - 87 : -1;
}
function _I(n, e) {
  const t = n.source.body;
  switch (t.charCodeAt(e + 1)) {
    case 34:
      return {
        value: '"',
        size: 2,
      };
    case 92:
      return {
        value: '\\',
        size: 2,
      };
    case 47:
      return {
        value: '/',
        size: 2,
      };
    case 98:
      return {
        value: '\b',
        size: 2,
      };
    case 102:
      return {
        value: '\f',
        size: 2,
      };
    case 110:
      return {
        value: `
`,
        size: 2,
      };
    case 114:
      return {
        value: '\r',
        size: 2,
      };
    case 116:
      return {
        value: '	',
        size: 2,
      };
  }
  throw Zt(n.source, e, `Invalid character escape sequence: "${t.slice(e, e + 2)}".`);
}
function RI(n, e) {
  const t = n.source.body,
    i = t.length;
  let r = n.lineStart,
    s = e + 3,
    a = s,
    o = '';
  const u = [];
  for (; s < i; ) {
    const l = t.charCodeAt(s);
    if (l === 34 && t.charCodeAt(s + 1) === 34 && t.charCodeAt(s + 2) === 34) {
      (o += t.slice(a, s)), u.push(o);
      const c = jt(
        n,
        V.BLOCK_STRING,
        e,
        s + 3,
        // Return a string of the lines joined with U+000A.
        bI(u).join(`
`),
      );
      return (n.line += u.length - 1), (n.lineStart = r), c;
    }
    if (l === 92 && t.charCodeAt(s + 1) === 34 && t.charCodeAt(s + 2) === 34 && t.charCodeAt(s + 3) === 34) {
      (o += t.slice(a, s)), (a = s + 1), (s += 4);
      continue;
    }
    if (l === 10 || l === 13) {
      (o += t.slice(a, s)), u.push(o), l === 13 && t.charCodeAt(s + 1) === 10 ? (s += 2) : ++s, (o = ''), (a = s), (r = s);
      continue;
    }
    if (Ko(l)) ++s;
    else if (cp(t, s)) s += 2;
    else throw Zt(n.source, s, `Invalid character within String: ${ga(n, s)}.`);
  }
  throw Zt(n.source, s, 'Unterminated string.');
}
function II(n, e) {
  const t = n.source.body,
    i = t.length;
  let r = e + 1;
  for (; r < i; ) {
    const s = t.charCodeAt(r);
    if (mI(s)) ++r;
    else break;
  }
  return jt(n, V.NAME, e, r, t.slice(e, r));
}
const OI = 10,
  ew = 2;
function tw(n) {
  return pp(n, []);
}
function pp(n, e) {
  switch (typeof n) {
    case 'string':
      return JSON.stringify(n);
    case 'function':
      return n.name ? `[function ${n.name}]` : '[function]';
    case 'object':
      return kI(n, e);
    default:
      return String(n);
  }
}
function kI(n, e) {
  if (n === null) return 'null';
  if (e.includes(n)) return '[Circular]';
  const t = [...e, n];
  if (PI(n)) {
    const i = n.toJSON();
    if (i !== n) return typeof i == 'string' ? i : pp(i, t);
  } else if (Array.isArray(n)) return DI(n, t);
  return NI(n, t);
}
function PI(n) {
  return typeof n.toJSON == 'function';
}
function NI(n, e) {
  const t = Object.entries(n);
  return t.length === 0 ? '{}' : e.length > ew ? '[' + BI(n) + ']' : '{ ' + t.map(([r, s]) => r + ': ' + pp(s, e)).join(', ') + ' }';
}
function DI(n, e) {
  if (n.length === 0) return '[]';
  if (e.length > ew) return '[Array]';
  const t = Math.min(OI, n.length),
    i = n.length - t,
    r = [];
  for (let s = 0; s < t; ++s) r.push(pp(n[s], e));
  return i === 1 ? r.push('... 1 more item') : i > 1 && r.push(`... ${i} more items`), '[' + r.join(', ') + ']';
}
function BI(n) {
  const e = Object.prototype.toString
    .call(n)
    .replace(/^\[object /, '')
    .replace(/]$/, '');
  if (e === 'Object' && typeof n.constructor == 'function') {
    const t = n.constructor.name;
    if (typeof t == 'string' && t !== '') return t;
  }
  return e;
}
const FI =
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  // eslint-disable-next-line no-undef
  function (e, t) {
    return e instanceof t;
  };
class nw {
  constructor(
    e,
    t = 'GraphQL request',
    i = {
      line: 1,
      column: 1,
    },
  ) {
    typeof e == 'string' || Fd(!1, `Body must be a string. Received: ${tw(e)}.`),
      (this.body = e),
      (this.name = t),
      (this.locationOffset = i),
      this.locationOffset.line > 0 || Fd(!1, 'line in locationOffset is 1-indexed and must be positive.'),
      this.locationOffset.column > 0 || Fd(!1, 'column in locationOffset is 1-indexed and must be positive.');
  }
  get [Symbol.toStringTag]() {
    return 'Source';
  }
}
function LI(n) {
  return FI(n, nw);
}
function $I(n, e) {
  return new UI(n, e).parseDocument();
}
class UI {
  constructor(e, t = {}) {
    const i = LI(e) ? e : new nw(e);
    (this._lexer = new xI(i)), (this._options = t), (this._tokenCounter = 0);
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const e = this.expectToken(V.NAME);
    return this.node(e, {
      kind: de.NAME,
      value: e.value,
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: de.DOCUMENT,
      definitions: this.many(V.SOF, this.parseDefinition, V.EOF),
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(V.BRACE_L)) return this.parseOperationDefinition();
    const e = this.peekDescription(),
      t = e ? this._lexer.lookahead() : this._lexer.token;
    if (t.kind === V.NAME) {
      switch (t.value) {
        case 'schema':
          return this.parseSchemaDefinition();
        case 'scalar':
          return this.parseScalarTypeDefinition();
        case 'type':
          return this.parseObjectTypeDefinition();
        case 'interface':
          return this.parseInterfaceTypeDefinition();
        case 'union':
          return this.parseUnionTypeDefinition();
        case 'enum':
          return this.parseEnumTypeDefinition();
        case 'input':
          return this.parseInputObjectTypeDefinition();
        case 'directive':
          return this.parseDirectiveDefinition();
      }
      if (e) throw Zt(this._lexer.source, this._lexer.token.start, 'Unexpected description, descriptions are supported only on type definitions.');
      switch (t.value) {
        case 'query':
        case 'mutation':
        case 'subscription':
          return this.parseOperationDefinition();
        case 'fragment':
          return this.parseFragmentDefinition();
        case 'extend':
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(t);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const e = this._lexer.token;
    if (this.peek(V.BRACE_L))
      return this.node(e, {
        kind: de.OPERATION_DEFINITION,
        operation: oo.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
      });
    const t = this.parseOperationType();
    let i;
    return (
      this.peek(V.NAME) && (i = this.parseName()),
      this.node(e, {
        kind: de.OPERATION_DEFINITION,
        operation: t,
        name: i,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet(),
      })
    );
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const e = this.expectToken(V.NAME);
    switch (e.value) {
      case 'query':
        return oo.QUERY;
      case 'mutation':
        return oo.MUTATION;
      case 'subscription':
        return oo.SUBSCRIPTION;
    }
    throw this.unexpected(e);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(V.PAREN_L, this.parseVariableDefinition, V.PAREN_R);
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: de.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(V.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(V.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives(),
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const e = this._lexer.token;
    return (
      this.expectToken(V.DOLLAR),
      this.node(e, {
        kind: de.VARIABLE,
        name: this.parseName(),
      })
    );
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: de.SELECTION_SET,
      selections: this.many(V.BRACE_L, this.parseSelection, V.BRACE_R),
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(V.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const e = this._lexer.token,
      t = this.parseName();
    let i, r;
    return (
      this.expectOptionalToken(V.COLON) ? ((i = t), (r = this.parseName())) : (r = t),
      this.node(e, {
        kind: de.FIELD,
        alias: i,
        name: r,
        arguments: this.parseArguments(!1),
        directives: this.parseDirectives(!1),
        selectionSet: this.peek(V.BRACE_L) ? this.parseSelectionSet() : void 0,
      })
    );
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(e) {
    const t = e ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(V.PAREN_L, t, V.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(e = !1) {
    const t = this._lexer.token,
      i = this.parseName();
    return (
      this.expectToken(V.COLON),
      this.node(t, {
        kind: de.ARGUMENT,
        name: i,
        value: this.parseValueLiteral(e),
      })
    );
  }
  parseConstArgument() {
    return this.parseArgument(!0);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const e = this._lexer.token;
    this.expectToken(V.SPREAD);
    const t = this.expectOptionalKeyword('on');
    return !t && this.peek(V.NAME)
      ? this.node(e, {
          kind: de.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(!1),
        })
      : this.node(e, {
          kind: de.INLINE_FRAGMENT,
          typeCondition: t ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(!1),
          selectionSet: this.parseSelectionSet(),
        });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const e = this._lexer.token;
    return (
      this.expectKeyword('fragment'),
      this._options.allowLegacyFragmentVariables === !0
        ? this.node(e, {
            kind: de.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
            directives: this.parseDirectives(!1),
            selectionSet: this.parseSelectionSet(),
          })
        : this.node(e, {
            kind: de.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            typeCondition: (this.expectKeyword('on'), this.parseNamedType()),
            directives: this.parseDirectives(!1),
            selectionSet: this.parseSelectionSet(),
          })
    );
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === 'on') throw this.unexpected();
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(e) {
    const t = this._lexer.token;
    switch (t.kind) {
      case V.BRACKET_L:
        return this.parseList(e);
      case V.BRACE_L:
        return this.parseObject(e);
      case V.INT:
        return (
          this.advanceLexer(),
          this.node(t, {
            kind: de.INT,
            value: t.value,
          })
        );
      case V.FLOAT:
        return (
          this.advanceLexer(),
          this.node(t, {
            kind: de.FLOAT,
            value: t.value,
          })
        );
      case V.STRING:
      case V.BLOCK_STRING:
        return this.parseStringLiteral();
      case V.NAME:
        switch ((this.advanceLexer(), t.value)) {
          case 'true':
            return this.node(t, {
              kind: de.BOOLEAN,
              value: !0,
            });
          case 'false':
            return this.node(t, {
              kind: de.BOOLEAN,
              value: !1,
            });
          case 'null':
            return this.node(t, {
              kind: de.NULL,
            });
          default:
            return this.node(t, {
              kind: de.ENUM,
              value: t.value,
            });
        }
      case V.DOLLAR:
        if (e)
          if ((this.expectToken(V.DOLLAR), this._lexer.token.kind === V.NAME)) {
            const i = this._lexer.token.value;
            throw Zt(this._lexer.source, t.start, `Unexpected variable "$${i}" in constant value.`);
          } else throw this.unexpected(t);
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(!0);
  }
  parseStringLiteral() {
    const e = this._lexer.token;
    return (
      this.advanceLexer(),
      this.node(e, {
        kind: de.STRING,
        value: e.value,
        block: e.kind === V.BLOCK_STRING,
      })
    );
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(e) {
    const t = () => this.parseValueLiteral(e);
    return this.node(this._lexer.token, {
      kind: de.LIST,
      values: this.any(V.BRACKET_L, t, V.BRACKET_R),
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(e) {
    const t = () => this.parseObjectField(e);
    return this.node(this._lexer.token, {
      kind: de.OBJECT,
      fields: this.any(V.BRACE_L, t, V.BRACE_R),
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(e) {
    const t = this._lexer.token,
      i = this.parseName();
    return (
      this.expectToken(V.COLON),
      this.node(t, {
        kind: de.OBJECT_FIELD,
        name: i,
        value: this.parseValueLiteral(e),
      })
    );
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(e) {
    const t = [];
    for (; this.peek(V.AT); ) t.push(this.parseDirective(e));
    return t;
  }
  parseConstDirectives() {
    return this.parseDirectives(!0);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(e) {
    const t = this._lexer.token;
    return (
      this.expectToken(V.AT),
      this.node(t, {
        kind: de.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(e),
      })
    );
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const e = this._lexer.token;
    let t;
    if (this.expectOptionalToken(V.BRACKET_L)) {
      const i = this.parseTypeReference();
      this.expectToken(V.BRACKET_R),
        (t = this.node(e, {
          kind: de.LIST_TYPE,
          type: i,
        }));
    } else t = this.parseNamedType();
    return this.expectOptionalToken(V.BANG)
      ? this.node(e, {
          kind: de.NON_NULL_TYPE,
          type: t,
        })
      : t;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: de.NAMED_TYPE,
      name: this.parseName(),
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(V.STRING) || this.peek(V.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) return this.parseStringLiteral();
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const e = this._lexer.token,
      t = this.parseDescription();
    this.expectKeyword('schema');
    const i = this.parseConstDirectives(),
      r = this.many(V.BRACE_L, this.parseOperationTypeDefinition, V.BRACE_R);
    return this.node(e, {
      kind: de.SCHEMA_DEFINITION,
      description: t,
      directives: i,
      operationTypes: r,
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const e = this._lexer.token,
      t = this.parseOperationType();
    this.expectToken(V.COLON);
    const i = this.parseNamedType();
    return this.node(e, {
      kind: de.OPERATION_TYPE_DEFINITION,
      operation: t,
      type: i,
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const e = this._lexer.token,
      t = this.parseDescription();
    this.expectKeyword('scalar');
    const i = this.parseName(),
      r = this.parseConstDirectives();
    return this.node(e, {
      kind: de.SCALAR_TYPE_DEFINITION,
      description: t,
      name: i,
      directives: r,
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const e = this._lexer.token,
      t = this.parseDescription();
    this.expectKeyword('type');
    const i = this.parseName(),
      r = this.parseImplementsInterfaces(),
      s = this.parseConstDirectives(),
      a = this.parseFieldsDefinition();
    return this.node(e, {
      kind: de.OBJECT_TYPE_DEFINITION,
      description: t,
      name: i,
      interfaces: r,
      directives: s,
      fields: a,
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword('implements') ? this.delimitedMany(V.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(V.BRACE_L, this.parseFieldDefinition, V.BRACE_R);
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const e = this._lexer.token,
      t = this.parseDescription(),
      i = this.parseName(),
      r = this.parseArgumentDefs();
    this.expectToken(V.COLON);
    const s = this.parseTypeReference(),
      a = this.parseConstDirectives();
    return this.node(e, {
      kind: de.FIELD_DEFINITION,
      description: t,
      name: i,
      arguments: r,
      type: s,
      directives: a,
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(V.PAREN_L, this.parseInputValueDef, V.PAREN_R);
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const e = this._lexer.token,
      t = this.parseDescription(),
      i = this.parseName();
    this.expectToken(V.COLON);
    const r = this.parseTypeReference();
    let s;
    this.expectOptionalToken(V.EQUALS) && (s = this.parseConstValueLiteral());
    const a = this.parseConstDirectives();
    return this.node(e, {
      kind: de.INPUT_VALUE_DEFINITION,
      description: t,
      name: i,
      type: r,
      defaultValue: s,
      directives: a,
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const e = this._lexer.token,
      t = this.parseDescription();
    this.expectKeyword('interface');
    const i = this.parseName(),
      r = this.parseImplementsInterfaces(),
      s = this.parseConstDirectives(),
      a = this.parseFieldsDefinition();
    return this.node(e, {
      kind: de.INTERFACE_TYPE_DEFINITION,
      description: t,
      name: i,
      interfaces: r,
      directives: s,
      fields: a,
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const e = this._lexer.token,
      t = this.parseDescription();
    this.expectKeyword('union');
    const i = this.parseName(),
      r = this.parseConstDirectives(),
      s = this.parseUnionMemberTypes();
    return this.node(e, {
      kind: de.UNION_TYPE_DEFINITION,
      description: t,
      name: i,
      directives: r,
      types: s,
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(V.EQUALS) ? this.delimitedMany(V.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const e = this._lexer.token,
      t = this.parseDescription();
    this.expectKeyword('enum');
    const i = this.parseName(),
      r = this.parseConstDirectives(),
      s = this.parseEnumValuesDefinition();
    return this.node(e, {
      kind: de.ENUM_TYPE_DEFINITION,
      description: t,
      name: i,
      directives: r,
      values: s,
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(V.BRACE_L, this.parseEnumValueDefinition, V.BRACE_R);
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const e = this._lexer.token,
      t = this.parseDescription(),
      i = this.parseEnumValueName(),
      r = this.parseConstDirectives();
    return this.node(e, {
      kind: de.ENUM_VALUE_DEFINITION,
      description: t,
      name: i,
      directives: r,
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === 'true' || this._lexer.token.value === 'false' || this._lexer.token.value === 'null')
      throw Zt(this._lexer.source, this._lexer.token.start, `${pd(this._lexer.token)} is reserved and cannot be used for an enum value.`);
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const e = this._lexer.token,
      t = this.parseDescription();
    this.expectKeyword('input');
    const i = this.parseName(),
      r = this.parseConstDirectives(),
      s = this.parseInputFieldsDefinition();
    return this.node(e, {
      kind: de.INPUT_OBJECT_TYPE_DEFINITION,
      description: t,
      name: i,
      directives: r,
      fields: s,
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(V.BRACE_L, this.parseInputValueDef, V.BRACE_R);
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const e = this._lexer.lookahead();
    if (e.kind === V.NAME)
      switch (e.value) {
        case 'schema':
          return this.parseSchemaExtension();
        case 'scalar':
          return this.parseScalarTypeExtension();
        case 'type':
          return this.parseObjectTypeExtension();
        case 'interface':
          return this.parseInterfaceTypeExtension();
        case 'union':
          return this.parseUnionTypeExtension();
        case 'enum':
          return this.parseEnumTypeExtension();
        case 'input':
          return this.parseInputObjectTypeExtension();
      }
    throw this.unexpected(e);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const e = this._lexer.token;
    this.expectKeyword('extend'), this.expectKeyword('schema');
    const t = this.parseConstDirectives(),
      i = this.optionalMany(V.BRACE_L, this.parseOperationTypeDefinition, V.BRACE_R);
    if (t.length === 0 && i.length === 0) throw this.unexpected();
    return this.node(e, {
      kind: de.SCHEMA_EXTENSION,
      directives: t,
      operationTypes: i,
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword('extend'), this.expectKeyword('scalar');
    const t = this.parseName(),
      i = this.parseConstDirectives();
    if (i.length === 0) throw this.unexpected();
    return this.node(e, {
      kind: de.SCALAR_TYPE_EXTENSION,
      name: t,
      directives: i,
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword('extend'), this.expectKeyword('type');
    const t = this.parseName(),
      i = this.parseImplementsInterfaces(),
      r = this.parseConstDirectives(),
      s = this.parseFieldsDefinition();
    if (i.length === 0 && r.length === 0 && s.length === 0) throw this.unexpected();
    return this.node(e, {
      kind: de.OBJECT_TYPE_EXTENSION,
      name: t,
      interfaces: i,
      directives: r,
      fields: s,
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword('extend'), this.expectKeyword('interface');
    const t = this.parseName(),
      i = this.parseImplementsInterfaces(),
      r = this.parseConstDirectives(),
      s = this.parseFieldsDefinition();
    if (i.length === 0 && r.length === 0 && s.length === 0) throw this.unexpected();
    return this.node(e, {
      kind: de.INTERFACE_TYPE_EXTENSION,
      name: t,
      interfaces: i,
      directives: r,
      fields: s,
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword('extend'), this.expectKeyword('union');
    const t = this.parseName(),
      i = this.parseConstDirectives(),
      r = this.parseUnionMemberTypes();
    if (i.length === 0 && r.length === 0) throw this.unexpected();
    return this.node(e, {
      kind: de.UNION_TYPE_EXTENSION,
      name: t,
      directives: i,
      types: r,
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword('extend'), this.expectKeyword('enum');
    const t = this.parseName(),
      i = this.parseConstDirectives(),
      r = this.parseEnumValuesDefinition();
    if (i.length === 0 && r.length === 0) throw this.unexpected();
    return this.node(e, {
      kind: de.ENUM_TYPE_EXTENSION,
      name: t,
      directives: i,
      values: r,
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const e = this._lexer.token;
    this.expectKeyword('extend'), this.expectKeyword('input');
    const t = this.parseName(),
      i = this.parseConstDirectives(),
      r = this.parseInputFieldsDefinition();
    if (i.length === 0 && r.length === 0) throw this.unexpected();
    return this.node(e, {
      kind: de.INPUT_OBJECT_TYPE_EXTENSION,
      name: t,
      directives: i,
      fields: r,
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const e = this._lexer.token,
      t = this.parseDescription();
    this.expectKeyword('directive'), this.expectToken(V.AT);
    const i = this.parseName(),
      r = this.parseArgumentDefs(),
      s = this.expectOptionalKeyword('repeatable');
    this.expectKeyword('on');
    const a = this.parseDirectiveLocations();
    return this.node(e, {
      kind: de.DIRECTIVE_DEFINITION,
      description: t,
      name: i,
      arguments: r,
      repeatable: s,
      locations: a,
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(V.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const e = this._lexer.token,
      t = this.parseName();
    if (Object.prototype.hasOwnProperty.call($y, t.value)) return t;
    throw this.unexpected(e);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(e, t) {
    return this._options.noLocation !== !0 && (t.loc = new yI(e, this._lexer.lastToken, this._lexer.source)), t;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(e) {
    return this._lexer.token.kind === e;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(e) {
    const t = this._lexer.token;
    if (t.kind === e) return this.advanceLexer(), t;
    throw Zt(this._lexer.source, t.start, `Expected ${iw(e)}, found ${pd(t)}.`);
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(e) {
    return this._lexer.token.kind === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(e) {
    const t = this._lexer.token;
    if (t.kind === V.NAME && t.value === e) this.advanceLexer();
    else throw Zt(this._lexer.source, t.start, `Expected "${e}", found ${pd(t)}.`);
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(e) {
    const t = this._lexer.token;
    return t.kind === V.NAME && t.value === e ? (this.advanceLexer(), !0) : !1;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(e) {
    const t = e ?? this._lexer.token;
    return Zt(this._lexer.source, t.start, `Unexpected ${pd(t)}.`);
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(e, t, i) {
    this.expectToken(e);
    const r = [];
    for (; !this.expectOptionalToken(i); ) r.push(t.call(this));
    return r;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(e, t, i) {
    if (this.expectOptionalToken(e)) {
      const r = [];
      do r.push(t.call(this));
      while (!this.expectOptionalToken(i));
      return r;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(e, t, i) {
    this.expectToken(e);
    const r = [];
    do r.push(t.call(this));
    while (!this.expectOptionalToken(i));
    return r;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(e, t) {
    this.expectOptionalToken(e);
    const i = [];
    do i.push(t.call(this));
    while (this.expectOptionalToken(e));
    return i;
  }
  advanceLexer() {
    const { maxTokens: e } = this._options,
      t = this._lexer.advance();
    if (e !== void 0 && t.kind !== V.EOF && (++this._tokenCounter, this._tokenCounter > e)) throw Zt(this._lexer.source, t.start, `Document contains more that ${e} tokens. Parsing aborted.`);
  }
}
function pd(n) {
  const e = n.value;
  return iw(n.kind) + (e != null ? ` "${e}"` : '');
}
function iw(n) {
  return TI(n) ? `"${n}"` : n;
}
function jI(n) {
  return `"${n.replace(VI, zI)}"`;
}
const VI = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function zI(n) {
  return GI[n.charCodeAt(0)];
}
const GI = [
    '\\u0000',
    '\\u0001',
    '\\u0002',
    '\\u0003',
    '\\u0004',
    '\\u0005',
    '\\u0006',
    '\\u0007',
    '\\b',
    '\\t',
    '\\n',
    '\\u000B',
    '\\f',
    '\\r',
    '\\u000E',
    '\\u000F',
    '\\u0010',
    '\\u0011',
    '\\u0012',
    '\\u0013',
    '\\u0014',
    '\\u0015',
    '\\u0016',
    '\\u0017',
    '\\u0018',
    '\\u0019',
    '\\u001A',
    '\\u001B',
    '\\u001C',
    '\\u001D',
    '\\u001E',
    '\\u001F',
    '',
    '',
    '\\"',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    // 2F
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    // 3F
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    // 4F
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\\\',
    '',
    '',
    '',
    // 5F
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    // 6F
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '\\u007F',
    '\\u0080',
    '\\u0081',
    '\\u0082',
    '\\u0083',
    '\\u0084',
    '\\u0085',
    '\\u0086',
    '\\u0087',
    '\\u0088',
    '\\u0089',
    '\\u008A',
    '\\u008B',
    '\\u008C',
    '\\u008D',
    '\\u008E',
    '\\u008F',
    '\\u0090',
    '\\u0091',
    '\\u0092',
    '\\u0093',
    '\\u0094',
    '\\u0095',
    '\\u0096',
    '\\u0097',
    '\\u0098',
    '\\u0099',
    '\\u009A',
    '\\u009B',
    '\\u009C',
    '\\u009D',
    '\\u009E',
    '\\u009F',
  ],
  qI = Object.freeze({});
function HI(n, e, t = J6) {
  const i = /* @__PURE__ */ new Map();
  for (const _ of Object.values(de)) i.set(_, KI(e, _));
  let r,
    s = Array.isArray(n),
    a = [n],
    o = -1,
    u = [],
    l = n,
    c,
    f;
  const m = [],
    w = [];
  do {
    o++;
    const _ = o === a.length,
      O = _ && u.length !== 0;
    if (_) {
      if (((c = w.length === 0 ? void 0 : m[m.length - 1]), (l = f), (f = w.pop()), O))
        if (s) {
          l = l.slice();
          let P = 0;
          for (const [N, U] of u) {
            const W = N - P;
            U === null ? (l.splice(W, 1), P++) : (l[W] = U);
          }
        } else {
          l = Object.defineProperties({}, Object.getOwnPropertyDescriptors(l));
          for (const [P, N] of u) l[P] = N;
        }
      (o = r.index), (a = r.keys), (u = r.edits), (s = r.inArray), (r = r.prev);
    } else if (f) {
      if (((c = s ? o : a[o]), (l = f[c]), l == null)) continue;
      m.push(c);
    }
    let B;
    if (!Array.isArray(l)) {
      var v, T;
      F2(l) || Fd(!1, `Invalid AST Node: ${tw(l)}.`);
      const P = _ ? ((v = i.get(l.kind)) === null || v === void 0 ? void 0 : v.leave) : (T = i.get(l.kind)) === null || T === void 0 ? void 0 : T.enter;
      if (((B = P?.call(e, l, c, f, m, w)), B === qI)) break;
      if (B === !1) {
        if (!_) {
          m.pop();
          continue;
        }
      } else if (B !== void 0 && (u.push([c, B]), !_))
        if (F2(B)) l = B;
        else {
          m.pop();
          continue;
        }
    }
    if ((B === void 0 && O && u.push([c, l]), _)) m.pop();
    else {
      var A;
      (r = {
        inArray: s,
        index: o,
        keys: a,
        edits: u,
        prev: r,
      }),
        (s = Array.isArray(l)),
        (a = s ? l : (A = t[l.kind]) !== null && A !== void 0 ? A : []),
        (o = -1),
        (u = []),
        f && w.push(f),
        (f = l);
    }
  } while (r !== void 0);
  return u.length !== 0 ? u[u.length - 1][1] : n;
}
function KI(n, e) {
  const t = n[e];
  return typeof t == 'object'
    ? t
    : typeof t == 'function'
    ? {
        enter: t,
        leave: void 0,
      }
    : {
        enter: n.enter,
        leave: n.leave,
      };
}
function WI(n) {
  return HI(n, QI);
}
const JI = 80,
  QI = {
    Name: {
      leave: (n) => n.value,
    },
    Variable: {
      leave: (n) => '$' + n.name,
    },
    // Document
    Document: {
      leave: (n) =>
        ie(
          n.definitions,
          `

`,
        ),
    },
    OperationDefinition: {
      leave(n) {
        const e = we('(', ie(n.variableDefinitions, ', '), ')'),
          t = ie([n.operation, ie([n.name, e]), ie(n.directives, ' ')], ' ');
        return (t === 'query' ? '' : t + ' ') + n.selectionSet;
      },
    },
    VariableDefinition: {
      leave: ({ variable: n, type: e, defaultValue: t, directives: i }) => n + ': ' + e + we(' = ', t) + we(' ', ie(i, ' ')),
    },
    SelectionSet: {
      leave: ({ selections: n }) => Ai(n),
    },
    Field: {
      leave({ alias: n, name: e, arguments: t, directives: i, selectionSet: r }) {
        const s = we('', n, ': ') + e;
        let a = s + we('(', ie(t, ', '), ')');
        return (
          a.length > JI &&
            (a =
              s +
              we(
                `(
`,
                Ld(
                  ie(
                    t,
                    `
`,
                  ),
                ),
                `
)`,
              )),
          ie([a, ie(i, ' '), r], ' ')
        );
      },
    },
    Argument: {
      leave: ({ name: n, value: e }) => n + ': ' + e,
    },
    // Fragments
    FragmentSpread: {
      leave: ({ name: n, directives: e }) => '...' + n + we(' ', ie(e, ' ')),
    },
    InlineFragment: {
      leave: ({ typeCondition: n, directives: e, selectionSet: t }) => ie(['...', we('on ', n), ie(e, ' '), t], ' '),
    },
    FragmentDefinition: {
      leave: ({ name: n, typeCondition: e, variableDefinitions: t, directives: i, selectionSet: r }) =>
        // or removed in the future.
        `fragment ${n}${we('(', ie(t, ', '), ')')} on ${e} ${we('', ie(i, ' '), ' ')}` + r,
    },
    // Value
    IntValue: {
      leave: ({ value: n }) => n,
    },
    FloatValue: {
      leave: ({ value: n }) => n,
    },
    StringValue: {
      leave: ({ value: n, block: e }) => (e ? vI(n) : jI(n)),
    },
    BooleanValue: {
      leave: ({ value: n }) => (n ? 'true' : 'false'),
    },
    NullValue: {
      leave: () => 'null',
    },
    EnumValue: {
      leave: ({ value: n }) => n,
    },
    ListValue: {
      leave: ({ values: n }) => '[' + ie(n, ', ') + ']',
    },
    ObjectValue: {
      leave: ({ fields: n }) => '{' + ie(n, ', ') + '}',
    },
    ObjectField: {
      leave: ({ name: n, value: e }) => n + ': ' + e,
    },
    // Directive
    Directive: {
      leave: ({ name: n, arguments: e }) => '@' + n + we('(', ie(e, ', '), ')'),
    },
    // Type
    NamedType: {
      leave: ({ name: n }) => n,
    },
    ListType: {
      leave: ({ type: n }) => '[' + n + ']',
    },
    NonNullType: {
      leave: ({ type: n }) => n + '!',
    },
    // Type System Definitions
    SchemaDefinition: {
      leave: ({ description: n, directives: e, operationTypes: t }) =>
        we(
          '',
          n,
          `
`,
        ) + ie(['schema', ie(e, ' '), Ai(t)], ' '),
    },
    OperationTypeDefinition: {
      leave: ({ operation: n, type: e }) => n + ': ' + e,
    },
    ScalarTypeDefinition: {
      leave: ({ description: n, name: e, directives: t }) =>
        we(
          '',
          n,
          `
`,
        ) + ie(['scalar', e, ie(t, ' ')], ' '),
    },
    ObjectTypeDefinition: {
      leave: ({ description: n, name: e, interfaces: t, directives: i, fields: r }) =>
        we(
          '',
          n,
          `
`,
        ) + ie(['type', e, we('implements ', ie(t, ' & ')), ie(i, ' '), Ai(r)], ' '),
    },
    FieldDefinition: {
      leave: ({ description: n, name: e, arguments: t, type: i, directives: r }) =>
        we(
          '',
          n,
          `
`,
        ) +
        e +
        ($2(t)
          ? we(
              `(
`,
              Ld(
                ie(
                  t,
                  `
`,
                ),
              ),
              `
)`,
            )
          : we('(', ie(t, ', '), ')')) +
        ': ' +
        i +
        we(' ', ie(r, ' ')),
    },
    InputValueDefinition: {
      leave: ({ description: n, name: e, type: t, defaultValue: i, directives: r }) =>
        we(
          '',
          n,
          `
`,
        ) + ie([e + ': ' + t, we('= ', i), ie(r, ' ')], ' '),
    },
    InterfaceTypeDefinition: {
      leave: ({ description: n, name: e, interfaces: t, directives: i, fields: r }) =>
        we(
          '',
          n,
          `
`,
        ) + ie(['interface', e, we('implements ', ie(t, ' & ')), ie(i, ' '), Ai(r)], ' '),
    },
    UnionTypeDefinition: {
      leave: ({ description: n, name: e, directives: t, types: i }) =>
        we(
          '',
          n,
          `
`,
        ) + ie(['union', e, ie(t, ' '), we('= ', ie(i, ' | '))], ' '),
    },
    EnumTypeDefinition: {
      leave: ({ description: n, name: e, directives: t, values: i }) =>
        we(
          '',
          n,
          `
`,
        ) + ie(['enum', e, ie(t, ' '), Ai(i)], ' '),
    },
    EnumValueDefinition: {
      leave: ({ description: n, name: e, directives: t }) =>
        we(
          '',
          n,
          `
`,
        ) + ie([e, ie(t, ' ')], ' '),
    },
    InputObjectTypeDefinition: {
      leave: ({ description: n, name: e, directives: t, fields: i }) =>
        we(
          '',
          n,
          `
`,
        ) + ie(['input', e, ie(t, ' '), Ai(i)], ' '),
    },
    DirectiveDefinition: {
      leave: ({ description: n, name: e, arguments: t, repeatable: i, locations: r }) =>
        we(
          '',
          n,
          `
`,
        ) +
        'directive @' +
        e +
        ($2(t)
          ? we(
              `(
`,
              Ld(
                ie(
                  t,
                  `
`,
                ),
              ),
              `
)`,
            )
          : we('(', ie(t, ', '), ')')) +
        (i ? ' repeatable' : '') +
        ' on ' +
        ie(r, ' | '),
    },
    SchemaExtension: {
      leave: ({ directives: n, operationTypes: e }) => ie(['extend schema', ie(n, ' '), Ai(e)], ' '),
    },
    ScalarTypeExtension: {
      leave: ({ name: n, directives: e }) => ie(['extend scalar', n, ie(e, ' ')], ' '),
    },
    ObjectTypeExtension: {
      leave: ({ name: n, interfaces: e, directives: t, fields: i }) => ie(['extend type', n, we('implements ', ie(e, ' & ')), ie(t, ' '), Ai(i)], ' '),
    },
    InterfaceTypeExtension: {
      leave: ({ name: n, interfaces: e, directives: t, fields: i }) => ie(['extend interface', n, we('implements ', ie(e, ' & ')), ie(t, ' '), Ai(i)], ' '),
    },
    UnionTypeExtension: {
      leave: ({ name: n, directives: e, types: t }) => ie(['extend union', n, ie(e, ' '), we('= ', ie(t, ' | '))], ' '),
    },
    EnumTypeExtension: {
      leave: ({ name: n, directives: e, values: t }) => ie(['extend enum', n, ie(e, ' '), Ai(t)], ' '),
    },
    InputObjectTypeExtension: {
      leave: ({ name: n, directives: e, fields: t }) => ie(['extend input', n, ie(e, ' '), Ai(t)], ' '),
    },
  };
function ie(n, e = '') {
  var t;
  return (t = n?.filter((i) => i).join(e)) !== null && t !== void 0 ? t : '';
}
function Ai(n) {
  return we(
    `{
`,
    Ld(
      ie(
        n,
        `
`,
      ),
    ),
    `
}`,
  );
}
function we(n, e, t = '') {
  return e != null && e !== '' ? n + e + t : '';
}
function Ld(n) {
  return we(
    '  ',
    n.replace(
      /\n/g,
      `
  `,
    ),
  );
}
function $2(n) {
  var e;
  return (e = n?.some((t) =>
    t.includes(`
`),
  )) !== null && e !== void 0
    ? e
    : !1;
}
const U2 = (n) => {
    let e;
    const t = n.definitions.filter((i) => i.kind === 'OperationDefinition');
    return t.length === 1 && (e = t[0]?.name?.value), e;
  },
  _f = (n) => {
    if (typeof n == 'string') {
      let t;
      try {
        const i = $I(n);
        t = U2(i);
      } catch {}
      return { query: n, operationName: t };
    }
    const e = U2(n);
    return { query: WI(n), operationName: e };
  };
class Ru extends Error {
  constructor(e, t) {
    const i = `${Ru.extractMessage(e)}: ${JSON.stringify({
      response: e,
      request: t,
    })}`;
    super(i), Object.setPrototypeOf(this, Ru.prototype), (this.response = e), (this.request = t), typeof Error.captureStackTrace == 'function' && Error.captureStackTrace(this, Ru);
  }
  static extractMessage(e) {
    return e.errors?.[0]?.message ?? `GraphQL Error (Code: ${e.status})`;
  }
}
var va = {},
  YI = {
    get exports() {
      return va;
    },
    set exports(n) {
      va = n;
    },
  };
(function (n, e) {
  var t = typeof self < 'u' ? self : br,
    i = (function () {
      function s() {
        (this.fetch = !1), (this.DOMException = t.DOMException);
      }
      return (s.prototype = t), new s();
    })();
  (function (s) {
    (function (a) {
      var o = {
        searchParams: 'URLSearchParams' in s,
        iterable: 'Symbol' in s && 'iterator' in Symbol,
        blob:
          'FileReader' in s &&
          'Blob' in s &&
          (function () {
            try {
              return new Blob(), !0;
            } catch {
              return !1;
            }
          })(),
        formData: 'FormData' in s,
        arrayBuffer: 'ArrayBuffer' in s,
      };
      function u(d) {
        return d && DataView.prototype.isPrototypeOf(d);
      }
      if (o.arrayBuffer)
        var l = [
            '[object Int8Array]',
            '[object Uint8Array]',
            '[object Uint8ClampedArray]',
            '[object Int16Array]',
            '[object Uint16Array]',
            '[object Int32Array]',
            '[object Uint32Array]',
            '[object Float32Array]',
            '[object Float64Array]',
          ],
          c =
            ArrayBuffer.isView ||
            function (d) {
              return d && l.indexOf(Object.prototype.toString.call(d)) > -1;
            };
      function f(d) {
        if ((typeof d != 'string' && (d = String(d)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(d))) throw new TypeError('Invalid character in header field name');
        return d.toLowerCase();
      }
      function m(d) {
        return typeof d != 'string' && (d = String(d)), d;
      }
      function w(d) {
        var y = {
          next: function () {
            var g = d.shift();
            return { done: g === void 0, value: g };
          },
        };
        return (
          o.iterable &&
            (y[Symbol.iterator] = function () {
              return y;
            }),
          y
        );
      }
      function v(d) {
        (this.map = {}),
          d instanceof v
            ? d.forEach(function (y, g) {
                this.append(g, y);
              }, this)
            : Array.isArray(d)
            ? d.forEach(function (y) {
                this.append(y[0], y[1]);
              }, this)
            : d &&
              Object.getOwnPropertyNames(d).forEach(function (y) {
                this.append(y, d[y]);
              }, this);
      }
      (v.prototype.append = function (d, y) {
        (d = f(d)), (y = m(y));
        var g = this.map[d];
        this.map[d] = g ? g + ', ' + y : y;
      }),
        (v.prototype.delete = function (d) {
          delete this.map[f(d)];
        }),
        (v.prototype.get = function (d) {
          return (d = f(d)), this.has(d) ? this.map[d] : null;
        }),
        (v.prototype.has = function (d) {
          return this.map.hasOwnProperty(f(d));
        }),
        (v.prototype.set = function (d, y) {
          this.map[f(d)] = m(y);
        }),
        (v.prototype.forEach = function (d, y) {
          for (var g in this.map) this.map.hasOwnProperty(g) && d.call(y, this.map[g], g, this);
        }),
        (v.prototype.keys = function () {
          var d = [];
          return (
            this.forEach(function (y, g) {
              d.push(g);
            }),
            w(d)
          );
        }),
        (v.prototype.values = function () {
          var d = [];
          return (
            this.forEach(function (y) {
              d.push(y);
            }),
            w(d)
          );
        }),
        (v.prototype.entries = function () {
          var d = [];
          return (
            this.forEach(function (y, g) {
              d.push([g, y]);
            }),
            w(d)
          );
        }),
        o.iterable && (v.prototype[Symbol.iterator] = v.prototype.entries);
      function T(d) {
        if (d.bodyUsed) return Promise.reject(new TypeError('Already read'));
        d.bodyUsed = !0;
      }
      function A(d) {
        return new Promise(function (y, g) {
          (d.onload = function () {
            y(d.result);
          }),
            (d.onerror = function () {
              g(d.error);
            });
        });
      }
      function _(d) {
        var y = new FileReader(),
          g = A(y);
        return y.readAsArrayBuffer(d), g;
      }
      function O(d) {
        var y = new FileReader(),
          g = A(y);
        return y.readAsText(d), g;
      }
      function B(d) {
        for (var y = new Uint8Array(d), g = new Array(y.length), S = 0; S < y.length; S++) g[S] = String.fromCharCode(y[S]);
        return g.join('');
      }
      function P(d) {
        if (d.slice) return d.slice(0);
        var y = new Uint8Array(d.byteLength);
        return y.set(new Uint8Array(d)), y.buffer;
      }
      function N() {
        return (
          (this.bodyUsed = !1),
          (this._initBody = function (d) {
            (this._bodyInit = d),
              d
                ? typeof d == 'string'
                  ? (this._bodyText = d)
                  : o.blob && Blob.prototype.isPrototypeOf(d)
                  ? (this._bodyBlob = d)
                  : o.formData && FormData.prototype.isPrototypeOf(d)
                  ? (this._bodyFormData = d)
                  : o.searchParams && URLSearchParams.prototype.isPrototypeOf(d)
                  ? (this._bodyText = d.toString())
                  : o.arrayBuffer && o.blob && u(d)
                  ? ((this._bodyArrayBuffer = P(d.buffer)), (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                  : o.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(d) || c(d))
                  ? (this._bodyArrayBuffer = P(d))
                  : (this._bodyText = d = Object.prototype.toString.call(d))
                : (this._bodyText = ''),
              this.headers.get('content-type') ||
                (typeof d == 'string'
                  ? this.headers.set('content-type', 'text/plain;charset=UTF-8')
                  : this._bodyBlob && this._bodyBlob.type
                  ? this.headers.set('content-type', this._bodyBlob.type)
                  : o.searchParams && URLSearchParams.prototype.isPrototypeOf(d) && this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8'));
          }),
          o.blob &&
            ((this.blob = function () {
              var d = T(this);
              if (d) return d;
              if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
              if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
              if (this._bodyFormData) throw new Error('could not read FormData body as blob');
              return Promise.resolve(new Blob([this._bodyText]));
            }),
            (this.arrayBuffer = function () {
              return this._bodyArrayBuffer ? T(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(_);
            })),
          (this.text = function () {
            var d = T(this);
            if (d) return d;
            if (this._bodyBlob) return O(this._bodyBlob);
            if (this._bodyArrayBuffer) return Promise.resolve(B(this._bodyArrayBuffer));
            if (this._bodyFormData) throw new Error('could not read FormData body as text');
            return Promise.resolve(this._bodyText);
          }),
          o.formData &&
            (this.formData = function () {
              return this.text().then(Y);
            }),
          (this.json = function () {
            return this.text().then(JSON.parse);
          }),
          this
        );
      }
      var U = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
      function W(d) {
        var y = d.toUpperCase();
        return U.indexOf(y) > -1 ? y : d;
      }
      function z(d, y) {
        y = y || {};
        var g = y.body;
        if (d instanceof z) {
          if (d.bodyUsed) throw new TypeError('Already read');
          (this.url = d.url),
            (this.credentials = d.credentials),
            y.headers || (this.headers = new v(d.headers)),
            (this.method = d.method),
            (this.mode = d.mode),
            (this.signal = d.signal),
            !g && d._bodyInit != null && ((g = d._bodyInit), (d.bodyUsed = !0));
        } else this.url = String(d);
        if (
          ((this.credentials = y.credentials || this.credentials || 'same-origin'),
          (y.headers || !this.headers) && (this.headers = new v(y.headers)),
          (this.method = W(y.method || this.method || 'GET')),
          (this.mode = y.mode || this.mode || null),
          (this.signal = y.signal || this.signal),
          (this.referrer = null),
          (this.method === 'GET' || this.method === 'HEAD') && g)
        )
          throw new TypeError('Body not allowed for GET or HEAD requests');
        this._initBody(g);
      }
      z.prototype.clone = function () {
        return new z(this, { body: this._bodyInit });
      };
      function Y(d) {
        var y = new FormData();
        return (
          d
            .trim()
            .split('&')
            .forEach(function (g) {
              if (g) {
                var S = g.split('='),
                  E = S.shift().replace(/\+/g, ' '),
                  M = S.join('=').replace(/\+/g, ' ');
                y.append(decodeURIComponent(E), decodeURIComponent(M));
              }
            }),
          y
        );
      }
      function ue(d) {
        var y = new v(),
          g = d.replace(/\r?\n[\t ]+/g, ' ');
        return (
          g.split(/\r?\n/).forEach(function (S) {
            var E = S.split(':'),
              M = E.shift().trim();
            if (M) {
              var I = E.join(':').trim();
              y.append(M, I);
            }
          }),
          y
        );
      }
      N.call(z.prototype);
      function J(d, y) {
        y || (y = {}),
          (this.type = 'default'),
          (this.status = y.status === void 0 ? 200 : y.status),
          (this.ok = this.status >= 200 && this.status < 300),
          (this.statusText = 'statusText' in y ? y.statusText : 'OK'),
          (this.headers = new v(y.headers)),
          (this.url = y.url || ''),
          this._initBody(d);
      }
      N.call(J.prototype),
        (J.prototype.clone = function () {
          return new J(this._bodyInit, {
            status: this.status,
            statusText: this.statusText,
            headers: new v(this.headers),
            url: this.url,
          });
        }),
        (J.error = function () {
          var d = new J(null, { status: 0, statusText: '' });
          return (d.type = 'error'), d;
        });
      var le = [301, 302, 303, 307, 308];
      (J.redirect = function (d, y) {
        if (le.indexOf(y) === -1) throw new RangeError('Invalid status code');
        return new J(null, { status: y, headers: { location: d } });
      }),
        (a.DOMException = s.DOMException);
      try {
        new a.DOMException();
      } catch {
        (a.DOMException = function (y, g) {
          (this.message = y), (this.name = g);
          var S = Error(y);
          this.stack = S.stack;
        }),
          (a.DOMException.prototype = Object.create(Error.prototype)),
          (a.DOMException.prototype.constructor = a.DOMException);
      }
      function C(d, y) {
        return new Promise(function (g, S) {
          var E = new z(d, y);
          if (E.signal && E.signal.aborted) return S(new a.DOMException('Aborted', 'AbortError'));
          var M = new XMLHttpRequest();
          function I() {
            M.abort();
          }
          (M.onload = function () {
            var b = {
              status: M.status,
              statusText: M.statusText,
              headers: ue(M.getAllResponseHeaders() || ''),
            };
            b.url = 'responseURL' in M ? M.responseURL : b.headers.get('X-Request-URL');
            var p = 'response' in M ? M.response : M.responseText;
            g(new J(p, b));
          }),
            (M.onerror = function () {
              S(new TypeError('Network request failed'));
            }),
            (M.ontimeout = function () {
              S(new TypeError('Network request failed'));
            }),
            (M.onabort = function () {
              S(new a.DOMException('Aborted', 'AbortError'));
            }),
            M.open(E.method, E.url, !0),
            E.credentials === 'include' ? (M.withCredentials = !0) : E.credentials === 'omit' && (M.withCredentials = !1),
            'responseType' in M && o.blob && (M.responseType = 'blob'),
            E.headers.forEach(function (b, p) {
              M.setRequestHeader(p, b);
            }),
            E.signal &&
              (E.signal.addEventListener('abort', I),
              (M.onreadystatechange = function () {
                M.readyState === 4 && E.signal.removeEventListener('abort', I);
              })),
            M.send(typeof E._bodyInit > 'u' ? null : E._bodyInit);
        });
      }
      return (
        (C.polyfill = !0),
        s.fetch || ((s.fetch = C), (s.Headers = v), (s.Request = z), (s.Response = J)),
        (a.Headers = v),
        (a.Request = z),
        (a.Response = J),
        (a.fetch = C),
        Object.defineProperty(a, '__esModule', { value: !0 }),
        a
      );
    })({});
  })(i),
    (i.fetch.ponyfill = !0),
    delete i.fetch.polyfill;
  var r = i;
  (e = r.fetch), (e.default = r.fetch), (e.fetch = r.fetch), (e.Headers = r.Headers), (e.Request = r.Request), (e.Response = r.Response), (n.exports = e);
})(YI, va);
const $d = /* @__PURE__ */ tS(va),
  XI = /* @__PURE__ */ L5(
    {
      __proto__: null,
      default: $d,
    },
    [va],
  ),
  qa = (n) => {
    let e = {};
    return (
      n &&
        ((typeof Headers < 'u' && n instanceof Headers) || (XI && va.Headers && n instanceof va.Headers)
          ? (e = sI(n))
          : Array.isArray(n)
          ? n.forEach(([t, i]) => {
              t && i !== void 0 && (e[t] = i);
            })
          : (e = n)),
      e
    );
  },
  j2 = (n) => n.replace(/([\s,]|#[^\n\r]+)+/g, ' ').trim(),
  ZI = (n) => {
    if (!Array.isArray(n.query)) {
      const i = n,
        r = [`query=${encodeURIComponent(j2(i.query))}`];
      return (
        n.variables && r.push(`variables=${encodeURIComponent(i.jsonSerializer.stringify(i.variables))}`),
        i.operationName && r.push(`operationName=${encodeURIComponent(i.operationName)}`),
        r.join('&')
      );
    }
    if (typeof n.variables < 'u' && !Array.isArray(n.variables)) throw new Error('Cannot create query with given variable type, array expected');
    const e = n,
      t = n.query.reduce(
        (i, r, s) => (
          i.push({
            query: j2(r),
            variables: e.variables ? e.jsonSerializer.stringify(e.variables[s]) : void 0,
          }),
          i
        ),
        [],
      );
    return `query=${encodeURIComponent(e.jsonSerializer.stringify(t))}`;
  },
  e9 = (n) => async (e) => {
    const { url: t, query: i, variables: r, operationName: s, fetch: a, fetchOptions: o, middleware: u } = e,
      l = { ...e.headers };
    let c = '',
      f;
    n === 'POST'
      ? ((f = n9(i, r, s, o.jsonSerializer)), typeof f == 'string' && (l['Content-Type'] = 'application/json'))
      : (c = ZI({
          query: i,
          variables: r,
          operationName: s,
          jsonSerializer: o.jsonSerializer ?? N0,
        }));
    const m = {
      method: n,
      headers: l,
      body: f,
      ...o,
    };
    let w = t,
      v = m;
    if (u) {
      const T = await Promise.resolve(u({ ...m, url: t, operationName: s, variables: r })),
        { url: A, ..._ } = T;
      (w = A), (v = _);
    }
    return c && (w = `${w}?${c}`), await a(w, v);
  };
class t9 {
  constructor(e, t = {}) {
    (this.url = e),
      (this.requestConfig = t),
      (this.rawRequest = async (...i) => {
        const [r, s, a] = i,
          o = oI(r, s, a),
          { headers: u, fetch: l = $d, method: c = 'POST', requestMiddleware: f, responseMiddleware: m, ...w } = this.requestConfig,
          { url: v } = this;
        o.signal !== void 0 && (w.signal = o.signal);
        const { operationName: T } = _f(o.query);
        return Rf({
          url: v,
          query: o.query,
          variables: o.variables,
          headers: {
            ...qa(If(u)),
            ...qa(o.requestHeaders),
          },
          operationName: T,
          fetch: l,
          method: c,
          fetchOptions: w,
          middleware: f,
        })
          .then((A) => (m && m(A), A))
          .catch((A) => {
            throw (m && m(A), A);
          });
      });
  }
  async request(e, ...t) {
    const [i, r] = t,
      s = aI(e, i, r),
      { headers: a, fetch: o = $d, method: u = 'POST', requestMiddleware: l, responseMiddleware: c, ...f } = this.requestConfig,
      { url: m } = this;
    s.signal !== void 0 && (f.signal = s.signal);
    const { query: w, operationName: v } = _f(s.document);
    return Rf({
      url: m,
      query: w,
      variables: s.variables,
      headers: {
        ...qa(If(a)),
        ...qa(s.requestHeaders),
      },
      operationName: v,
      fetch: o,
      method: u,
      fetchOptions: f,
      middleware: l,
    })
      .then((T) => (c && c(T), T.data))
      .catch((T) => {
        throw (c && c(T), T);
      });
  }
  // prettier-ignore
  batchRequests(e, t) {
    const i = uI(e, t), { headers: r, ...s } = this.requestConfig;
    i.signal !== void 0 && (s.signal = i.signal);
    const a = i.documents.map(({ document: u }) => _f(u).query), o = i.documents.map(({ variables: u }) => u);
    return Rf({
      url: this.url,
      query: a,
      // @ts-expect-error TODO reconcile batch variables into system.
      variables: o,
      headers: {
        ...qa(If(r)),
        ...qa(i.requestHeaders)
      },
      operationName: void 0,
      fetch: this.requestConfig.fetch ?? $d,
      method: this.requestConfig.method || "POST",
      fetchOptions: s,
      middleware: this.requestConfig.requestMiddleware
    }).then((u) => (this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(u), u.data)).catch((u) => {
      throw this.requestConfig.responseMiddleware && this.requestConfig.responseMiddleware(u), u;
    });
  }
  setHeaders(e) {
    return (this.requestConfig.headers = e), this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(e, t) {
    const { headers: i } = this.requestConfig;
    return i ? (i[e] = t) : (this.requestConfig.headers = { [e]: t }), this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(e) {
    return (this.url = e), this;
  }
}
const Rf = async (n) => {
    const { query: e, variables: t, fetchOptions: i } = n,
      r = e9(rI(n.method ?? 'post')),
      s = Array.isArray(n.query),
      a = await r(n),
      o = await i9(a, i.jsonSerializer ?? N0),
      u = Array.isArray(o) ? !o.some(({ data: c }) => !c) : !!o.data,
      l = Array.isArray(o) || !o.errors || (Array.isArray(o.errors) && !o.errors.length) || i.errorPolicy === 'all' || i.errorPolicy === 'ignore';
    if (a.ok && l && u) {
      const { errors: c, ...f } = (Array.isArray(o), o),
        m = i.errorPolicy === 'ignore' ? f : o;
      return {
        ...(s ? { data: m } : m),
        headers: a.headers,
        status: a.status,
      };
    } else {
      const c =
        typeof o == 'string'
          ? {
              error: o,
            }
          : o;
      throw new Ru(
        // @ts-expect-error TODO
        { ...c, status: a.status, headers: a.headers },
        { query: e, variables: t },
      );
    }
  },
  n9 = (n, e, t, i) => {
    const r = i ?? N0;
    if (!Array.isArray(n)) return r.stringify({ query: n, variables: e, operationName: t });
    if (typeof e < 'u' && !Array.isArray(e)) throw new Error('Cannot create request body with given variable type, array expected');
    const s = n.reduce((a, o, u) => (a.push({ query: o, variables: e ? e[u] : void 0 }), a), []);
    return r.stringify(s);
  },
  i9 = async (n, e) => {
    let t;
    return (
      n.headers.forEach((i, r) => {
        r.toLowerCase() === 'content-type' && (t = i);
      }),
      t && (t.toLowerCase().startsWith('application/json') || t.toLowerCase().startsWith('application/graphql+json') || t.toLowerCase().startsWith('application/graphql-response+json'))
        ? e.parse(await n.text())
        : n.text()
    );
  },
  If = (n) => (typeof n == 'function' ? n() : n),
  Of = (n, ...e) => n.reduce((t, i, r) => `${t}${i}${r in e ? String(e[r]) : ''}`, '');
var r9 = Object.defineProperty,
  s9 = Object.getOwnPropertyDescriptor,
  a9 = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? s9(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && r9(e, t, r), r;
  },
  o9 = (n, e) => (t, i) => e(t, i, n);
const B0 = be.createInterface('SymmetricService'),
  u9 = '0x765de816845861e75a25fca122bb6898b8b1282a';
let nl = class {
  constructor(n) {
    this.configuration = n;
  }
  static register(n) {
    me.singleton(B0, nl).register(n);
  }
  // _poolId: poolid is constant and will be provided by backend.
  // ethers: just pass directly imported ethers
  indexVolumeAndFees = async () => {
    const n = 'https://api.thegraph.com/subgraphs/name/centfinance/symmetric-v2-celo',
      e = new t9(n),
      t = Math.floor(Number(new Date(/* @__PURE__ */ new Date().getTime() - 24 * 60 * 60 * 1e3)) / 1e3),
      i = Of`
      query getSwaps($poolId: String!, $startTime: Int!) {
        swaps(where: { and: [{ poolId: $poolId }, { timestamp_gte: $startTime }] }) {
          tokenOut
          tokenAmountOut
          timestamp
        }
      }
    `,
      r = {
        poolId: this.configuration.kGcUSD,
        startTime: t,
      },
      s = Of`
      query getPoolData($poolId: String!) {
        pool(id: $poolId) {
          swapFee
          totalSwapFee
          totalLiquidity
          totalSwapVolume
        }
      }
    `,
      a = {
        poolId: this.configuration.kGcUSD,
      },
      o = Of`
      query getPrice($tokenAddress: String!) {
        token(id: $tokenAddress) {
          latestPrice {
            price
            pricingAsset
          }
        }
      }
    `,
      { swaps: u } = await e.request(i, r),
      { pool: l } = await e.request(s, a),
      c = {},
      f = {};
    u.forEach((O) => {
      const B = c[O.tokenOut] ?? '0',
        P = ea(B),
        N = ea(O.tokenAmountOut);
      c[O.tokenOut] = H6(q.from(N).add(P));
    });
    const m = Object.keys(c);
    await Promise.all(
      m.map(async (O) => {
        const B = {
          tokenAddress: O,
        };
        if (O === u9) {
          f[O] = '1';
          return;
        }
        const N = (await e.request(o, B)).token.latestPrice.price;
        f[O] = N;
      }),
    );
    const w = m.reduce(
        (O, B) =>
          ea(c[B] ?? '0')
            .mul(ea(f[B]?.toString().slice(0, 20) ?? '0'))
            .add(O),
        q.from(0),
      ),
      v = w.mul(ea(l.swapFee.toString())).div(ea('1')),
      T = vc(w, '36'),
      A = vc(v, '36'),
      _ = l.totalLiquidity;
    return { volumeParsed: T, swapFeeParsed: A, tvl: _ };
  };
};
nl = a9([o9(0, Ms)], nl);
function Di(n) {
  return (
    (Di =
      typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol'
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e && typeof Symbol == 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e;
          }),
    Di(n)
  );
}
function l9(n, e) {
  if (Di(n) !== 'object' || n === null) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e || 'default');
    if (Di(i) !== 'object') return i;
    throw new TypeError('@@toPrimitive must return a primitive value.');
  }
  return (e === 'string' ? String : Number)(n);
}
function rw(n) {
  var e = l9(n, 'string');
  return Di(e) === 'symbol' ? e : String(e);
}
function d9(n, e, t) {
  return (
    (e = rw(e)),
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function $n(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {},
      i = Object.keys(t);
    typeof Object.getOwnPropertySymbols == 'function' &&
      i.push.apply(
        i,
        Object.getOwnPropertySymbols(t).filter(function (r) {
          return Object.getOwnPropertyDescriptor(t, r).enumerable;
        }),
      ),
      i.forEach(function (r) {
        d9(n, r, t[r]);
      });
  }
  return n;
}
function Wr(n, e) {
  if (!(n instanceof e)) throw new TypeError('Cannot call a class as a function');
}
function V2(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    (i.enumerable = i.enumerable || !1), (i.configurable = !0), 'value' in i && (i.writable = !0), Object.defineProperty(n, rw(i.key), i);
  }
}
function Jr(n, e, t) {
  return (
    e && V2(n.prototype, e),
    t && V2(n, t),
    Object.defineProperty(n, 'prototype', {
      writable: !1,
    }),
    n
  );
}
function xa(n) {
  if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function il(n, e) {
  if (e && (Di(e) === 'object' || typeof e == 'function')) return e;
  if (e !== void 0) throw new TypeError('Derived constructors may only return object or undefined');
  return xa(n);
}
function Co(n) {
  return (
    (Co = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        }),
    Co(n)
  );
}
function jy(n, e) {
  return (
    (jy = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (i, r) {
          return (i.__proto__ = r), i;
        }),
    jy(n, e)
  );
}
function fp(n, e) {
  if (typeof e != 'function' && e !== null) throw new TypeError('Super expression must either be null or a function');
  (n.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: n,
      writable: !0,
      configurable: !0,
    },
  })),
    Object.defineProperty(n, 'prototype', {
      writable: !1,
    }),
    e && jy(n, e);
}
function Vy(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, i = new Array(e); t < e; t++) i[t] = n[t];
  return i;
}
function c9(n) {
  if (Array.isArray(n)) return Vy(n);
}
function p9(n) {
  if ((typeof Symbol < 'u' && n[Symbol.iterator] != null) || n['@@iterator'] != null) return Array.from(n);
}
function sw(n, e) {
  if (n) {
    if (typeof n == 'string') return Vy(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if ((t === 'Object' && n.constructor && (t = n.constructor.name), t === 'Map' || t === 'Set')) return Array.from(n);
    if (t === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return Vy(n, e);
  }
}
function f9() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function y9(n) {
  return c9(n) || p9(n) || sw(n) || f9();
}
function h9(n) {
  if (Array.isArray(n)) return n;
}
function m9(n, e) {
  var t = n == null ? null : (typeof Symbol < 'u' && n[Symbol.iterator]) || n['@@iterator'];
  if (t != null) {
    var i,
      r,
      s,
      a,
      o = [],
      u = !0,
      l = !1;
    try {
      if (((s = (t = t.call(n)).next), e === 0)) {
        if (Object(t) !== t) return;
        u = !1;
      } else for (; !(u = (i = s.call(t)).done) && (o.push(i.value), o.length !== e); u = !0);
    } catch (c) {
      (l = !0), (r = c);
    } finally {
      try {
        if (!u && t.return != null && ((a = t.return()), Object(a) !== a)) return;
      } finally {
        if (l) throw r;
      }
    }
    return o;
  }
}
function b9() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function z2(n, e) {
  return h9(n) || m9(n, e) || sw(n, e) || b9();
}
var g9 = {
    type: 'logger',
    log: function (e) {
      this.output('log', e);
    },
    warn: function (e) {
      this.output('warn', e);
    },
    error: function (e) {
      this.output('error', e);
    },
    output: function (e, t) {
      var i;
      console && console[e] && (i = console)[e].apply(i, y9(t));
    },
  },
  v9 = /* @__PURE__ */ (function () {
    function n(e) {
      var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Wr(this, n), this.init(e, t);
    }
    return (
      Jr(n, [
        {
          key: 'init',
          value: function (t) {
            var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            (this.prefix = i.prefix || 'i18next:'), (this.logger = t || g9), (this.options = i), (this.debug = i.debug);
          },
        },
        {
          key: 'setDebug',
          value: function (t) {
            this.debug = t;
          },
        },
        {
          key: 'log',
          value: function () {
            for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
            return this.forward(i, 'log', '', !0);
          },
        },
        {
          key: 'warn',
          value: function () {
            for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
            return this.forward(i, 'warn', '', !0);
          },
        },
        {
          key: 'error',
          value: function () {
            for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
            return this.forward(i, 'error', '');
          },
        },
        {
          key: 'deprecate',
          value: function () {
            for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++) i[r] = arguments[r];
            return this.forward(i, 'warn', 'WARNING DEPRECATED: ', !0);
          },
        },
        {
          key: 'forward',
          value: function (t, i, r, s) {
            return s && !this.debug ? null : (typeof t[0] == 'string' && (t[0] = ''.concat(r).concat(this.prefix, ' ').concat(t[0])), this.logger[i](t));
          },
        },
        {
          key: 'create',
          value: function (t) {
            return new n(
              this.logger,
              $n(
                {},
                {
                  prefix: ''.concat(this.prefix, ':').concat(t, ':'),
                },
                this.options,
              ),
            );
          },
        },
      ]),
      n
    );
  })(),
  Er = new v9(),
  As = /* @__PURE__ */ (function () {
    function n() {
      Wr(this, n), (this.observers = {});
    }
    return (
      Jr(n, [
        {
          key: 'on',
          value: function (t, i) {
            var r = this;
            return (
              t.split(' ').forEach(function (s) {
                (r.observers[s] = r.observers[s] || []), r.observers[s].push(i);
              }),
              this
            );
          },
        },
        {
          key: 'off',
          value: function (t, i) {
            if (this.observers[t]) {
              if (!i) {
                delete this.observers[t];
                return;
              }
              this.observers[t] = this.observers[t].filter(function (r) {
                return r !== i;
              });
            }
          },
        },
        {
          key: 'emit',
          value: function (t) {
            for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++) r[s - 1] = arguments[s];
            if (this.observers[t]) {
              var a = [].concat(this.observers[t]);
              a.forEach(function (u) {
                u.apply(void 0, r);
              });
            }
            if (this.observers['*']) {
              var o = [].concat(this.observers['*']);
              o.forEach(function (u) {
                u.apply(u, [t].concat(r));
              });
            }
          },
        },
      ]),
      n
    );
  })();
function su() {
  var n,
    e,
    t = new Promise(function (i, r) {
      (n = i), (e = r);
    });
  return (t.resolve = n), (t.reject = e), t;
}
function kf(n) {
  return n == null ? '' : '' + n;
}
function x9(n, e, t) {
  n.forEach(function (i) {
    e[i] && (t[i] = e[i]);
  });
}
function F0(n, e, t) {
  function i(o) {
    return o && o.indexOf('###') > -1 ? o.replace(/###/g, '.') : o;
  }
  function r() {
    return !n || typeof n == 'string';
  }
  for (var s = typeof e != 'string' ? [].concat(e) : e.split('.'); s.length > 1; ) {
    if (r()) return {};
    var a = i(s.shift());
    !n[a] && t && (n[a] = new t()), (n = n[a]);
  }
  return r()
    ? {}
    : {
        obj: n,
        k: i(s.shift()),
      };
}
function G2(n, e, t) {
  var i = F0(n, e, Object),
    r = i.obj,
    s = i.k;
  r[s] = t;
}
function T9(n, e, t, i) {
  var r = F0(n, e, Object),
    s = r.obj,
    a = r.k;
  (s[a] = s[a] || []), i && (s[a] = s[a].concat(t)), i || s[a].push(t);
}
function xc(n, e) {
  var t = F0(n, e),
    i = t.obj,
    r = t.k;
  if (i) return i[r];
}
function q2(n, e, t) {
  var i = xc(n, t);
  return i !== void 0 ? i : xc(e, t);
}
function aw(n, e, t) {
  for (var i in e) i in n ? (typeof n[i] == 'string' || n[i] instanceof String || typeof e[i] == 'string' || e[i] instanceof String ? t && (n[i] = e[i]) : aw(n[i], e[i], t)) : (n[i] = e[i]);
  return n;
}
function Ha(n) {
  return n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
}
var w9 = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  "'": '&#39;',
  '/': '&#x2F;',
};
function A9(n) {
  return typeof n == 'string'
    ? n.replace(/[&<>"'\/]/g, function (e) {
        return w9[e];
      })
    : n;
}
var E9 = /* @__PURE__ */ (function (n) {
    fp(e, n);
    function e(t) {
      var i,
        r =
          arguments.length > 1 && arguments[1] !== void 0
            ? arguments[1]
            : {
                ns: ['translation'],
                defaultNS: 'translation',
              };
      return Wr(this, e), (i = il(this, Co(e).call(this))), As.call(xa(i)), (i.data = t || {}), (i.options = r), i.options.keySeparator === void 0 && (i.options.keySeparator = '.'), i;
    }
    return (
      Jr(e, [
        {
          key: 'addNamespaces',
          value: function (i) {
            this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
          },
        },
        {
          key: 'removeNamespaces',
          value: function (i) {
            var r = this.options.ns.indexOf(i);
            r > -1 && this.options.ns.splice(r, 1);
          },
        },
        {
          key: 'getResource',
          value: function (i, r, s) {
            var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {},
              o = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator,
              u = [i, r];
            return s && typeof s != 'string' && (u = u.concat(s)), s && typeof s == 'string' && (u = u.concat(o ? s.split(o) : s)), i.indexOf('.') > -1 && (u = i.split('.')), xc(this.data, u);
          },
        },
        {
          key: 'addResource',
          value: function (i, r, s, a) {
            var o =
                arguments.length > 4 && arguments[4] !== void 0
                  ? arguments[4]
                  : {
                      silent: !1,
                    },
              u = this.options.keySeparator;
            u === void 0 && (u = '.');
            var l = [i, r];
            s && (l = l.concat(u ? s.split(u) : s)),
              i.indexOf('.') > -1 && ((l = i.split('.')), (a = r), (r = l[1])),
              this.addNamespaces(r),
              G2(this.data, l, a),
              o.silent || this.emit('added', i, r, s, a);
          },
        },
        {
          key: 'addResources',
          value: function (i, r, s) {
            var a =
              arguments.length > 3 && arguments[3] !== void 0
                ? arguments[3]
                : {
                    silent: !1,
                  };
            for (var o in s)
              (typeof s[o] == 'string' || Object.prototype.toString.apply(s[o]) === '[object Array]') &&
                this.addResource(i, r, o, s[o], {
                  silent: !0,
                });
            a.silent || this.emit('added', i, r, s);
          },
        },
        {
          key: 'addResourceBundle',
          value: function (i, r, s, a, o) {
            var u =
                arguments.length > 5 && arguments[5] !== void 0
                  ? arguments[5]
                  : {
                      silent: !1,
                    },
              l = [i, r];
            i.indexOf('.') > -1 && ((l = i.split('.')), (a = s), (s = r), (r = l[1])), this.addNamespaces(r);
            var c = xc(this.data, l) || {};
            a ? aw(c, s, o) : (c = $n({}, c, s)), G2(this.data, l, c), u.silent || this.emit('added', i, r, s);
          },
        },
        {
          key: 'removeResourceBundle',
          value: function (i, r) {
            this.hasResourceBundle(i, r) && delete this.data[i][r], this.removeNamespaces(r), this.emit('removed', i, r);
          },
        },
        {
          key: 'hasResourceBundle',
          value: function (i, r) {
            return this.getResource(i, r) !== void 0;
          },
        },
        {
          key: 'getResourceBundle',
          value: function (i, r) {
            return r || (r = this.options.defaultNS), this.options.compatibilityAPI === 'v1' ? $n({}, {}, this.getResource(i, r)) : this.getResource(i, r);
          },
        },
        {
          key: 'getDataByLanguage',
          value: function (i) {
            return this.data[i];
          },
        },
        {
          key: 'toJSON',
          value: function () {
            return this.data;
          },
        },
      ]),
      e
    );
  })(As),
  ow = {
    processors: {},
    addPostProcessor: function (e) {
      this.processors[e.name] = e;
    },
    handle: function (e, t, i, r, s) {
      var a = this;
      return (
        e.forEach(function (o) {
          a.processors[o] && (t = a.processors[o].process(t, i, r, s));
        }),
        t
      );
    },
  },
  H2 = /* @__PURE__ */ (function (n) {
    fp(e, n);
    function e(t) {
      var i,
        r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return (
        Wr(this, e),
        (i = il(this, Co(e).call(this))),
        As.call(xa(i)),
        x9(['resourceStore', 'languageUtils', 'pluralResolver', 'interpolator', 'backendConnector', 'i18nFormat', 'utils'], t, xa(i)),
        (i.options = r),
        i.options.keySeparator === void 0 && (i.options.keySeparator = '.'),
        (i.logger = Er.create('translator')),
        i
      );
    }
    return (
      Jr(e, [
        {
          key: 'changeLanguage',
          value: function (i) {
            i && (this.language = i);
          },
        },
        {
          key: 'exists',
          value: function (i) {
            var r =
                arguments.length > 1 && arguments[1] !== void 0
                  ? arguments[1]
                  : {
                      interpolation: {},
                    },
              s = this.resolve(i, r);
            return s && s.res !== void 0;
          },
        },
        {
          key: 'extractFromKey',
          value: function (i, r) {
            var s = r.nsSeparator || this.options.nsSeparator;
            s === void 0 && (s = ':');
            var a = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator,
              o = r.ns || this.options.defaultNS;
            if (s && i.indexOf(s) > -1) {
              var u = i.split(s);
              (s !== a || (s === a && this.options.ns.indexOf(u[0]) > -1)) && (o = u.shift()), (i = u.join(a));
            }
            return (
              typeof o == 'string' && (o = [o]),
              {
                key: i,
                namespaces: o,
              }
            );
          },
        },
        {
          key: 'translate',
          value: function (i, r) {
            var s = this;
            if ((Di(r) !== 'object' && this.options.overloadTranslationOptionHandler && (r = this.options.overloadTranslationOptionHandler(arguments)), r || (r = {}), i == null)) return '';
            Array.isArray(i) || (i = [String(i)]);
            var a = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator,
              o = this.extractFromKey(i[i.length - 1], r),
              u = o.key,
              l = o.namespaces,
              c = l[l.length - 1],
              f = r.lng || this.language,
              m = r.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
            if (f && f.toLowerCase() === 'cimode') {
              if (m) {
                var w = r.nsSeparator || this.options.nsSeparator;
                return c + w + u;
              }
              return u;
            }
            var v = this.resolve(i, r),
              T = v && v.res,
              A = (v && v.usedKey) || u,
              _ = (v && v.exactUsedKey) || u,
              O = Object.prototype.toString.apply(T),
              B = ['[object Number]', '[object Function]', '[object RegExp]'],
              P = r.joinArrays !== void 0 ? r.joinArrays : this.options.joinArrays,
              N = !this.i18nFormat || this.i18nFormat.handleAsObject,
              U = typeof T != 'string' && typeof T != 'boolean' && typeof T != 'number';
            if (N && T && U && B.indexOf(O) < 0 && !(typeof P == 'string' && O === '[object Array]')) {
              if (!r.returnObjects && !this.options.returnObjects)
                return (
                  this.logger.warn('accessing an object - but returnObjects options is not enabled!'),
                  this.options.returnedObjectHandler ? this.options.returnedObjectHandler(A, T, r) : "key '".concat(u, ' (').concat(this.language, ")' returned an object instead of string.")
                );
              if (a) {
                var W = O === '[object Array]',
                  z = W ? [] : {},
                  Y = W ? _ : A;
                for (var ue in T)
                  if (Object.prototype.hasOwnProperty.call(T, ue)) {
                    var J = ''.concat(Y).concat(a).concat(ue);
                    (z[ue] = this.translate(
                      J,
                      $n({}, r, {
                        joinArrays: !1,
                        ns: l,
                      }),
                    )),
                      z[ue] === J && (z[ue] = T[ue]);
                  }
                T = z;
              }
            } else if (N && typeof P == 'string' && O === '[object Array]') (T = T.join(P)), T && (T = this.extendTranslation(T, i, r));
            else {
              var le = !1,
                C = !1;
              if (!this.isValidLookup(T) && r.defaultValue !== void 0) {
                if (((le = !0), r.count !== void 0)) {
                  var d = this.pluralResolver.getSuffix(f, r.count);
                  T = r['defaultValue'.concat(d)];
                }
                T || (T = r.defaultValue);
              }
              this.isValidLookup(T) || ((C = !0), (T = u));
              var y = r.defaultValue && r.defaultValue !== T && this.options.updateMissing;
              if (C || le || y) {
                this.logger.log(y ? 'updateKey' : 'missingKey', f, c, u, y ? r.defaultValue : T);
                var g = [],
                  S = this.languageUtils.getFallbackCodes(this.options.fallbackLng, r.lng || this.language);
                if (this.options.saveMissingTo === 'fallback' && S && S[0]) for (var E = 0; E < S.length; E++) g.push(S[E]);
                else this.options.saveMissingTo === 'all' ? (g = this.languageUtils.toResolveHierarchy(r.lng || this.language)) : g.push(r.lng || this.language);
                var M = function (p, x) {
                  s.options.missingKeyHandler
                    ? s.options.missingKeyHandler(p, c, x, y ? r.defaultValue : T, y, r)
                    : s.backendConnector && s.backendConnector.saveMissing && s.backendConnector.saveMissing(p, c, x, y ? r.defaultValue : T, y, r),
                    s.emit('missingKey', p, c, x, T);
                };
                if (this.options.saveMissing) {
                  var I = r.count !== void 0 && typeof r.count != 'string';
                  this.options.saveMissingPlurals && I
                    ? g.forEach(function (b) {
                        var p = s.pluralResolver.getPluralFormsOfKey(b, u);
                        p.forEach(function (x) {
                          return M([b], x);
                        });
                      })
                    : M(g, u);
                }
              }
              (T = this.extendTranslation(T, i, r, v)),
                C && T === u && this.options.appendNamespaceToMissingKey && (T = ''.concat(c, ':').concat(u)),
                C && this.options.parseMissingKeyHandler && (T = this.options.parseMissingKeyHandler(T));
            }
            return T;
          },
        },
        {
          key: 'extendTranslation',
          value: function (i, r, s, a) {
            var o = this;
            if (this.i18nFormat && this.i18nFormat.parse)
              i = this.i18nFormat.parse(i, s, a.usedLng, a.usedNS, a.usedKey, {
                resolved: a,
              });
            else if (!s.skipInterpolation) {
              s.interpolation &&
                this.interpolator.init(
                  $n({}, s, {
                    interpolation: $n({}, this.options.interpolation, s.interpolation),
                  }),
                );
              var u = s.replace && typeof s.replace != 'string' ? s.replace : s;
              this.options.interpolation.defaultVariables && (u = $n({}, this.options.interpolation.defaultVariables, u)),
                (i = this.interpolator.interpolate(i, u, s.lng || this.language, s)),
                s.nest !== !1 &&
                  (i = this.interpolator.nest(
                    i,
                    function () {
                      return o.translate.apply(o, arguments);
                    },
                    s,
                  )),
                s.interpolation && this.interpolator.reset();
            }
            var l = s.postProcess || this.options.postProcess,
              c = typeof l == 'string' ? [l] : l;
            return (
              i != null &&
                c &&
                c.length &&
                s.applyPostProcessor !== !1 &&
                (i = ow.handle(
                  c,
                  i,
                  r,
                  this.options && this.options.postProcessPassResolved
                    ? $n(
                        {
                          i18nResolved: a,
                        },
                        s,
                      )
                    : s,
                  this,
                )),
              i
            );
          },
        },
        {
          key: 'resolve',
          value: function (i) {
            var r = this,
              s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
              a,
              o,
              u,
              l,
              c;
            return (
              typeof i == 'string' && (i = [i]),
              i.forEach(function (f) {
                if (!r.isValidLookup(a)) {
                  var m = r.extractFromKey(f, s),
                    w = m.key;
                  o = w;
                  var v = m.namespaces;
                  r.options.fallbackNS && (v = v.concat(r.options.fallbackNS));
                  var T = s.count !== void 0 && typeof s.count != 'string',
                    A = s.context !== void 0 && typeof s.context == 'string' && s.context !== '',
                    _ = s.lngs ? s.lngs : r.languageUtils.toResolveHierarchy(s.lng || r.language, s.fallbackLng);
                  v.forEach(function (O) {
                    r.isValidLookup(a) ||
                      ((c = O),
                      r.utils &&
                        r.utils.hasLoadedNamespace &&
                        !r.utils.hasLoadedNamespace(c) &&
                        r.logger.warn(
                          'key "'.concat(o, '" for namespace "').concat(c, `" won't get resolved as namespace was not yet loaded`),
                          'This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!',
                        ),
                      _.forEach(function (B) {
                        if (!r.isValidLookup(a)) {
                          l = B;
                          var P = w,
                            N = [P];
                          if (r.i18nFormat && r.i18nFormat.addLookupKeys) r.i18nFormat.addLookupKeys(N, w, B, O, s);
                          else {
                            var U;
                            T && (U = r.pluralResolver.getSuffix(B, s.count)),
                              T && A && N.push(P + U),
                              A && N.push((P += ''.concat(r.options.contextSeparator).concat(s.context))),
                              T && N.push((P += U));
                          }
                          for (var W; (W = N.pop()); ) r.isValidLookup(a) || ((u = W), (a = r.getResource(B, O, W, s)));
                        }
                      }));
                  });
                }
              }),
              {
                res: a,
                usedKey: o,
                exactUsedKey: u,
                usedLng: l,
                usedNS: c,
              }
            );
          },
        },
        {
          key: 'isValidLookup',
          value: function (i) {
            return i !== void 0 && !(!this.options.returnNull && i === null) && !(!this.options.returnEmptyString && i === '');
          },
        },
        {
          key: 'getResource',
          value: function (i, r, s) {
            var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(i, r, s, a) : this.resourceStore.getResource(i, r, s, a);
          },
        },
      ]),
      e
    );
  })(As);
function Pf(n) {
  return n.charAt(0).toUpperCase() + n.slice(1);
}
var S9 = /* @__PURE__ */ (function () {
    function n(e) {
      Wr(this, n), (this.options = e), (this.whitelist = this.options.whitelist || !1), (this.logger = Er.create('languageUtils'));
    }
    return (
      Jr(n, [
        {
          key: 'getScriptPartFromCode',
          value: function (t) {
            if (!t || t.indexOf('-') < 0) return null;
            var i = t.split('-');
            return i.length === 2 ? null : (i.pop(), this.formatLanguageCode(i.join('-')));
          },
        },
        {
          key: 'getLanguagePartFromCode',
          value: function (t) {
            if (!t || t.indexOf('-') < 0) return t;
            var i = t.split('-');
            return this.formatLanguageCode(i[0]);
          },
        },
        {
          key: 'formatLanguageCode',
          value: function (t) {
            if (typeof t == 'string' && t.indexOf('-') > -1) {
              var i = ['hans', 'hant', 'latn', 'cyrl', 'cans', 'mong', 'arab'],
                r = t.split('-');
              return (
                this.options.lowerCaseLng
                  ? (r = r.map(function (s) {
                      return s.toLowerCase();
                    }))
                  : r.length === 2
                  ? ((r[0] = r[0].toLowerCase()), (r[1] = r[1].toUpperCase()), i.indexOf(r[1].toLowerCase()) > -1 && (r[1] = Pf(r[1].toLowerCase())))
                  : r.length === 3 &&
                    ((r[0] = r[0].toLowerCase()),
                    r[1].length === 2 && (r[1] = r[1].toUpperCase()),
                    r[0] !== 'sgn' && r[2].length === 2 && (r[2] = r[2].toUpperCase()),
                    i.indexOf(r[1].toLowerCase()) > -1 && (r[1] = Pf(r[1].toLowerCase())),
                    i.indexOf(r[2].toLowerCase()) > -1 && (r[2] = Pf(r[2].toLowerCase()))),
                r.join('-')
              );
            }
            return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
          },
        },
        {
          key: 'isWhitelisted',
          value: function (t) {
            return (
              (this.options.load === 'languageOnly' || this.options.nonExplicitWhitelist) && (t = this.getLanguagePartFromCode(t)),
              !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(t) > -1
            );
          },
        },
        {
          key: 'getFallbackCodes',
          value: function (t, i) {
            if (!t) return [];
            if ((typeof t == 'string' && (t = [t]), Object.prototype.toString.apply(t) === '[object Array]')) return t;
            if (!i) return t.default || [];
            var r = t[i];
            return r || (r = t[this.getScriptPartFromCode(i)]), r || (r = t[this.formatLanguageCode(i)]), r || (r = t.default), r || [];
          },
        },
        {
          key: 'toResolveHierarchy',
          value: function (t, i) {
            var r = this,
              s = this.getFallbackCodes(i || this.options.fallbackLng || [], t),
              a = [],
              o = function (l) {
                l && (r.isWhitelisted(l) ? a.push(l) : r.logger.warn('rejecting non-whitelisted language code: '.concat(l)));
              };
            return (
              typeof t == 'string' && t.indexOf('-') > -1
                ? (this.options.load !== 'languageOnly' && o(this.formatLanguageCode(t)),
                  this.options.load !== 'languageOnly' && this.options.load !== 'currentOnly' && o(this.getScriptPartFromCode(t)),
                  this.options.load !== 'currentOnly' && o(this.getLanguagePartFromCode(t)))
                : typeof t == 'string' && o(this.formatLanguageCode(t)),
              s.forEach(function (u) {
                a.indexOf(u) < 0 && o(r.formatLanguageCode(u));
              }),
              a
            );
          },
        },
      ]),
      n
    );
  })(),
  C9 = [
    {
      lngs: ['ach', 'ak', 'am', 'arn', 'br', 'fil', 'gun', 'ln', 'mfe', 'mg', 'mi', 'oc', 'pt', 'pt-BR', 'tg', 'ti', 'tr', 'uz', 'wa'],
      nr: [1, 2],
      fc: 1,
    },
    {
      lngs: [
        'af',
        'an',
        'ast',
        'az',
        'bg',
        'bn',
        'ca',
        'da',
        'de',
        'dev',
        'el',
        'en',
        'eo',
        'es',
        'et',
        'eu',
        'fi',
        'fo',
        'fur',
        'fy',
        'gl',
        'gu',
        'ha',
        'hi',
        'hu',
        'hy',
        'ia',
        'it',
        'kn',
        'ku',
        'lb',
        'mai',
        'ml',
        'mn',
        'mr',
        'nah',
        'nap',
        'nb',
        'ne',
        'nl',
        'nn',
        'no',
        'nso',
        'pa',
        'pap',
        'pms',
        'ps',
        'pt-PT',
        'rm',
        'sco',
        'se',
        'si',
        'so',
        'son',
        'sq',
        'sv',
        'sw',
        'ta',
        'te',
        'tk',
        'ur',
        'yo',
      ],
      nr: [1, 2],
      fc: 2,
    },
    {
      lngs: ['ay', 'bo', 'cgg', 'fa', 'id', 'ja', 'jbo', 'ka', 'kk', 'km', 'ko', 'ky', 'lo', 'ms', 'sah', 'su', 'th', 'tt', 'ug', 'vi', 'wo', 'zh'],
      nr: [1],
      fc: 3,
    },
    {
      lngs: ['be', 'bs', 'cnr', 'dz', 'hr', 'ru', 'sr', 'uk'],
      nr: [1, 2, 5],
      fc: 4,
    },
    {
      lngs: ['ar'],
      nr: [0, 1, 2, 3, 11, 100],
      fc: 5,
    },
    {
      lngs: ['cs', 'sk'],
      nr: [1, 2, 5],
      fc: 6,
    },
    {
      lngs: ['csb', 'pl'],
      nr: [1, 2, 5],
      fc: 7,
    },
    {
      lngs: ['cy'],
      nr: [1, 2, 3, 8],
      fc: 8,
    },
    {
      lngs: ['fr'],
      nr: [1, 2],
      fc: 9,
    },
    {
      lngs: ['ga'],
      nr: [1, 2, 3, 7, 11],
      fc: 10,
    },
    {
      lngs: ['gd'],
      nr: [1, 2, 3, 20],
      fc: 11,
    },
    {
      lngs: ['is'],
      nr: [1, 2],
      fc: 12,
    },
    {
      lngs: ['jv'],
      nr: [0, 1],
      fc: 13,
    },
    {
      lngs: ['kw'],
      nr: [1, 2, 3, 4],
      fc: 14,
    },
    {
      lngs: ['lt'],
      nr: [1, 2, 10],
      fc: 15,
    },
    {
      lngs: ['lv'],
      nr: [1, 2, 0],
      fc: 16,
    },
    {
      lngs: ['mk'],
      nr: [1, 2],
      fc: 17,
    },
    {
      lngs: ['mnk'],
      nr: [0, 1, 2],
      fc: 18,
    },
    {
      lngs: ['mt'],
      nr: [1, 2, 11, 20],
      fc: 19,
    },
    {
      lngs: ['or'],
      nr: [2, 1],
      fc: 2,
    },
    {
      lngs: ['ro'],
      nr: [1, 2, 20],
      fc: 20,
    },
    {
      lngs: ['sl'],
      nr: [5, 1, 2, 3],
      fc: 21,
    },
    {
      lngs: ['he'],
      nr: [1, 2, 20, 21],
      fc: 22,
    },
  ],
  M9 = {
    1: function (e) {
      return +(e > 1);
    },
    2: function (e) {
      return +(e != 1);
    },
    3: function (e) {
      return 0;
    },
    4: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
    },
    5: function (e) {
      return e === 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5;
    },
    6: function (e) {
      return e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2;
    },
    7: function (e) {
      return e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
    },
    8: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3;
    },
    9: function (e) {
      return +(e >= 2);
    },
    10: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4;
    },
    11: function (e) {
      return e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3;
    },
    12: function (e) {
      return +(e % 10 != 1 || e % 100 == 11);
    },
    13: function (e) {
      return +(e !== 0);
    },
    14: function (e) {
      return e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3;
    },
    15: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
    },
    16: function (e) {
      return e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2;
    },
    17: function (e) {
      return e == 1 || e % 10 == 1 ? 0 : 1;
    },
    18: function (e) {
      return e == 0 ? 0 : e == 1 ? 1 : 2;
    },
    19: function (e) {
      return e == 1 ? 0 : e === 0 || (e % 100 > 1 && e % 100 < 11) ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3;
    },
    20: function (e) {
      return e == 1 ? 0 : e === 0 || (e % 100 > 0 && e % 100 < 20) ? 1 : 2;
    },
    21: function (e) {
      return e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0;
    },
    22: function (e) {
      return e === 1 ? 0 : e === 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3;
    },
  };
function _9() {
  var n = {};
  return (
    C9.forEach(function (e) {
      e.lngs.forEach(function (t) {
        n[t] = {
          numbers: e.nr,
          plurals: M9[e.fc],
        };
      });
    }),
    n
  );
}
var R9 = /* @__PURE__ */ (function () {
    function n(e) {
      var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Wr(this, n), (this.languageUtils = e), (this.options = t), (this.logger = Er.create('pluralResolver')), (this.rules = _9());
    }
    return (
      Jr(n, [
        {
          key: 'addRule',
          value: function (t, i) {
            this.rules[t] = i;
          },
        },
        {
          key: 'getRule',
          value: function (t) {
            return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)];
          },
        },
        {
          key: 'needsPlural',
          value: function (t) {
            var i = this.getRule(t);
            return i && i.numbers.length > 1;
          },
        },
        {
          key: 'getPluralFormsOfKey',
          value: function (t, i) {
            var r = this,
              s = [],
              a = this.getRule(t);
            return (
              a &&
                a.numbers.forEach(function (o) {
                  var u = r.getSuffix(t, o);
                  s.push(''.concat(i).concat(u));
                }),
              s
            );
          },
        },
        {
          key: 'getSuffix',
          value: function (t, i) {
            var r = this,
              s = this.getRule(t);
            if (s) {
              var a = s.noAbs ? s.plurals(i) : s.plurals(Math.abs(i)),
                o = s.numbers[a];
              this.options.simplifyPluralSuffix && s.numbers.length === 2 && s.numbers[0] === 1 && (o === 2 ? (o = 'plural') : o === 1 && (o = ''));
              var u = function () {
                return r.options.prepend && o.toString() ? r.options.prepend + o.toString() : o.toString();
              };
              return this.options.compatibilityJSON === 'v1'
                ? o === 1
                  ? ''
                  : typeof o == 'number'
                  ? '_plural_'.concat(o.toString())
                  : u()
                : /* v2 */
                this.options.compatibilityJSON === 'v2' /* v3 - gettext index */ || (this.options.simplifyPluralSuffix && s.numbers.length === 2 && s.numbers[0] === 1)
                ? u()
                : this.options.prepend && a.toString()
                ? this.options.prepend + a.toString()
                : a.toString();
            }
            return this.logger.warn('no plural rule found for: '.concat(t)), '';
          },
        },
      ]),
      n
    );
  })(),
  I9 = /* @__PURE__ */ (function () {
    function n() {
      var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Wr(this, n),
        (this.logger = Er.create('interpolator')),
        (this.options = e),
        (this.format =
          (e.interpolation && e.interpolation.format) ||
          function (t) {
            return t;
          }),
        this.init(e);
    }
    return (
      Jr(n, [
        {
          key: 'init',
          value: function () {
            var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            t.interpolation ||
              (t.interpolation = {
                escapeValue: !0,
              });
            var i = t.interpolation;
            (this.escape = i.escape !== void 0 ? i.escape : A9),
              (this.escapeValue = i.escapeValue !== void 0 ? i.escapeValue : !0),
              (this.useRawValueToEscape = i.useRawValueToEscape !== void 0 ? i.useRawValueToEscape : !1),
              (this.prefix = i.prefix ? Ha(i.prefix) : i.prefixEscaped || '{{'),
              (this.suffix = i.suffix ? Ha(i.suffix) : i.suffixEscaped || '}}'),
              (this.formatSeparator = i.formatSeparator ? i.formatSeparator : i.formatSeparator || ','),
              (this.unescapePrefix = i.unescapeSuffix ? '' : i.unescapePrefix || '-'),
              (this.unescapeSuffix = this.unescapePrefix ? '' : i.unescapeSuffix || ''),
              (this.nestingPrefix = i.nestingPrefix ? Ha(i.nestingPrefix) : i.nestingPrefixEscaped || Ha('$t(')),
              (this.nestingSuffix = i.nestingSuffix ? Ha(i.nestingSuffix) : i.nestingSuffixEscaped || Ha(')')),
              (this.maxReplaces = i.maxReplaces ? i.maxReplaces : 1e3),
              this.resetRegExp();
          },
        },
        {
          key: 'reset',
          value: function () {
            this.options && this.init(this.options);
          },
        },
        {
          key: 'resetRegExp',
          value: function () {
            var t = ''.concat(this.prefix, '(.+?)').concat(this.suffix);
            this.regexp = new RegExp(t, 'g');
            var i = ''.concat(this.prefix).concat(this.unescapePrefix, '(.+?)').concat(this.unescapeSuffix).concat(this.suffix);
            this.regexpUnescape = new RegExp(i, 'g');
            var r = ''.concat(this.nestingPrefix, '(.+?)').concat(this.nestingSuffix);
            this.nestingRegexp = new RegExp(r, 'g');
          },
        },
        {
          key: 'interpolate',
          value: function (t, i, r, s) {
            var a = this,
              o,
              u,
              l,
              c = (this.options && this.options.interpolation && this.options.interpolation.defaultVariables) || {};
            function f(A) {
              return A.replace(/\$/g, '$$$$');
            }
            var m = function (_) {
              if (_.indexOf(a.formatSeparator) < 0) return q2(i, c, _);
              var O = _.split(a.formatSeparator),
                B = O.shift().trim(),
                P = O.join(a.formatSeparator).trim();
              return a.format(q2(i, c, B), P, r);
            };
            this.resetRegExp();
            var w = (s && s.missingInterpolationHandler) || this.options.missingInterpolationHandler;
            for (l = 0; (o = this.regexpUnescape.exec(t)); ) {
              if (((u = m(o[1].trim())), u === void 0))
                if (typeof w == 'function') {
                  var v = w(t, o, s);
                  u = typeof v == 'string' ? v : '';
                } else this.logger.warn('missed to pass in variable '.concat(o[1], ' for interpolating ').concat(t)), (u = '');
              else typeof u != 'string' && !this.useRawValueToEscape && (u = kf(u));
              if (((t = t.replace(o[0], f(u))), (this.regexpUnescape.lastIndex = 0), l++, l >= this.maxReplaces)) break;
            }
            for (l = 0; (o = this.regexp.exec(t)); ) {
              if (((u = m(o[1].trim())), u === void 0))
                if (typeof w == 'function') {
                  var T = w(t, o, s);
                  u = typeof T == 'string' ? T : '';
                } else this.logger.warn('missed to pass in variable '.concat(o[1], ' for interpolating ').concat(t)), (u = '');
              else typeof u != 'string' && !this.useRawValueToEscape && (u = kf(u));
              if (((u = this.escapeValue ? f(this.escape(u)) : f(u)), (t = t.replace(o[0], u)), (this.regexp.lastIndex = 0), l++, l >= this.maxReplaces)) break;
            }
            return t;
          },
        },
        {
          key: 'nest',
          value: function (t, i) {
            var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
              s,
              a,
              o = $n({}, r);
            (o.applyPostProcessor = !1), delete o.defaultValue;
            function u(l, c) {
              if (l.indexOf(',') < 0) return l;
              var f = l.split(',');
              l = f.shift();
              var m = f.join(',');
              (m = this.interpolate(m, o)), (m = m.replace(/'/g, '"'));
              try {
                (o = JSON.parse(m)), c && (o = $n({}, c, o));
              } catch (w) {
                this.logger.error('failed parsing options string in nesting for key '.concat(l), w);
              }
              return delete o.defaultValue, l;
            }
            for (; (s = this.nestingRegexp.exec(t)); ) {
              if (((a = i(u.call(this, s[1].trim(), o), o)), a && s[0] === t && typeof a != 'string')) return a;
              typeof a != 'string' && (a = kf(a)),
                a || (this.logger.warn('missed to resolve '.concat(s[1], ' for nesting ').concat(t)), (a = '')),
                (t = t.replace(s[0], a)),
                (this.regexp.lastIndex = 0);
            }
            return t;
          },
        },
      ]),
      n
    );
  })();
function O9(n, e) {
  for (var t = n.indexOf(e); t !== -1; ) n.splice(t, 1), (t = n.indexOf(e));
}
var k9 = /* @__PURE__ */ (function (n) {
  fp(e, n);
  function e(t, i, r) {
    var s,
      a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return (
      Wr(this, e),
      (s = il(this, Co(e).call(this))),
      As.call(xa(s)),
      (s.backend = t),
      (s.store = i),
      (s.services = r),
      (s.languageUtils = r.languageUtils),
      (s.options = a),
      (s.logger = Er.create('backendConnector')),
      (s.state = {}),
      (s.queue = []),
      s.backend && s.backend.init && s.backend.init(r, a.backend, a),
      s
    );
  }
  return (
    Jr(e, [
      {
        key: 'queueLoad',
        value: function (i, r, s, a) {
          var o = this,
            u = [],
            l = [],
            c = [],
            f = [];
          return (
            i.forEach(function (m) {
              var w = !0;
              r.forEach(function (v) {
                var T = ''.concat(m, '|').concat(v);
                !s.reload && o.store.hasResourceBundle(m, v)
                  ? (o.state[T] = 2)
                  : o.state[T] < 0 ||
                    (o.state[T] === 1 ? l.indexOf(T) < 0 && l.push(T) : ((o.state[T] = 1), (w = !1), l.indexOf(T) < 0 && l.push(T), u.indexOf(T) < 0 && u.push(T), f.indexOf(v) < 0 && f.push(v)));
              }),
                w || c.push(m);
            }),
            (u.length || l.length) &&
              this.queue.push({
                pending: l,
                loaded: {},
                errors: [],
                callback: a,
              }),
            {
              toLoad: u,
              pending: l,
              toLoadLanguages: c,
              toLoadNamespaces: f,
            }
          );
        },
      },
      {
        key: 'loaded',
        value: function (i, r, s) {
          var a = i.split('|'),
            o = z2(a, 2),
            u = o[0],
            l = o[1];
          r && this.emit('failedLoading', u, l, r), s && this.store.addResourceBundle(u, l, s), (this.state[i] = r ? -1 : 2);
          var c = {};
          this.queue.forEach(function (f) {
            T9(f.loaded, [u], l),
              O9(f.pending, i),
              r && f.errors.push(r),
              f.pending.length === 0 &&
                !f.done &&
                (Object.keys(f.loaded).forEach(function (m) {
                  c[m] || (c[m] = []),
                    f.loaded[m].length &&
                      f.loaded[m].forEach(function (w) {
                        c[m].indexOf(w) < 0 && c[m].push(w);
                      });
                }),
                (f.done = !0),
                f.errors.length ? f.callback(f.errors) : f.callback());
          }),
            this.emit('loaded', c),
            (this.queue = this.queue.filter(function (f) {
              return !f.done;
            }));
        },
      },
      {
        key: 'read',
        value: function (i, r, s) {
          var a = this,
            o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0,
            u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 250,
            l = arguments.length > 5 ? arguments[5] : void 0;
          return i.length
            ? this.backend[s](i, r, function (c, f) {
                if (c && f && o < 5) {
                  setTimeout(function () {
                    a.read.call(a, i, r, s, o + 1, u * 2, l);
                  }, u);
                  return;
                }
                l(c, f);
              })
            : l(null, {});
        },
        /* eslint consistent-return: 0 */
      },
      {
        key: 'prepareLoading',
        value: function (i, r) {
          var s = this,
            a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
            o = arguments.length > 3 ? arguments[3] : void 0;
          if (!this.backend) return this.logger.warn('No backend was added via i18next.use. Will not load resources.'), o && o();
          typeof i == 'string' && (i = this.languageUtils.toResolveHierarchy(i)), typeof r == 'string' && (r = [r]);
          var u = this.queueLoad(i, r, a, o);
          if (!u.toLoad.length) return u.pending.length || o(), null;
          u.toLoad.forEach(function (l) {
            s.loadOne(l);
          });
        },
      },
      {
        key: 'load',
        value: function (i, r, s) {
          this.prepareLoading(i, r, {}, s);
        },
      },
      {
        key: 'reload',
        value: function (i, r, s) {
          this.prepareLoading(
            i,
            r,
            {
              reload: !0,
            },
            s,
          );
        },
      },
      {
        key: 'loadOne',
        value: function (i) {
          var r = this,
            s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : '',
            a = i.split('|'),
            o = z2(a, 2),
            u = o[0],
            l = o[1];
          this.read(u, l, 'read', null, null, function (c, f) {
            c && r.logger.warn(''.concat(s, 'loading namespace ').concat(l, ' for language ').concat(u, ' failed'), c),
              !c && f && r.logger.log(''.concat(s, 'loaded namespace ').concat(l, ' for language ').concat(u), f),
              r.loaded(i, c, f);
          });
        },
      },
      {
        key: 'saveMissing',
        value: function (i, r, s, a, o) {
          var u = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
          if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(r)) {
            this.logger.warn(
              'did not save key "'.concat(s, '" for namespace "').concat(r, '" as the namespace was not yet loaded'),
              'This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!',
            );
            return;
          }
          this.backend &&
            this.backend.create &&
            this.backend.create(
              i,
              r,
              s,
              a,
              null,
              $n({}, u, {
                isUpdate: o,
              }),
            ),
            !(!i || !i[0]) && this.store.addResource(i[0], r, s, a);
        },
      },
    ]),
    e
  );
})(As);
function P9() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ['translation'],
    defaultNS: ['translation'],
    fallbackLng: ['dev'],
    fallbackNS: !1,
    // string or array of namespaces
    whitelist: !1,
    // array with whitelisted languages
    nonExplicitWhitelist: !1,
    load: 'all',
    // | currentOnly | languageOnly
    preload: !1,
    // array with preload languages
    simplifyPluralSuffix: !0,
    keySeparator: '.',
    nsSeparator: ':',
    pluralSeparator: '_',
    contextSeparator: '_',
    partialBundledLanguages: !1,
    // allow bundling certain languages that are not remotely fetched
    saveMissing: !1,
    // enable to send missing values
    updateMissing: !1,
    // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
    saveMissingTo: 'fallback',
    // 'current' || 'all'
    saveMissingPlurals: !0,
    // will save all forms not only singular key
    missingKeyHandler: !1,
    // function(lng, ns, key, fallbackValue) -> override if prefer on handling
    missingInterpolationHandler: !1,
    // function(str, match)
    postProcess: !1,
    // string or array of postProcessor names
    postProcessPassResolved: !1,
    // pass resolved object into 'options.i18nResolved' for postprocessor
    returnNull: !0,
    // allows null value as valid translation
    returnEmptyString: !0,
    // allows empty string value as valid translation
    returnObjects: !1,
    joinArrays: !1,
    // or string to join array
    returnedObjectHandler: !1,
    // function(key, value, options) triggered if key returns object but returnObjects is set to false
    parseMissingKeyHandler: !1,
    // function(key) parsed a key that was not found in t() before returning
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function (e) {
      var t = {};
      if (
        (Di(e[1]) === 'object' && (t = e[1]), typeof e[1] == 'string' && (t.defaultValue = e[1]), typeof e[2] == 'string' && (t.tDescription = e[2]), Di(e[2]) === 'object' || Di(e[3]) === 'object')
      ) {
        var i = e[3] || e[2];
        Object.keys(i).forEach(function (r) {
          t[r] = i[r];
        });
      }
      return t;
    },
    interpolation: {
      escapeValue: !0,
      format: function (e, t, i) {
        return e;
      },
      prefix: '{{',
      suffix: '}}',
      formatSeparator: ',',
      // prefixEscaped: '{{',
      // suffixEscaped: '}}',
      // unescapeSuffix: '',
      unescapePrefix: '-',
      nestingPrefix: '$t(',
      nestingSuffix: ')',
      // nestingPrefixEscaped: '$t(',
      // nestingSuffixEscaped: ')',
      // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
      maxReplaces: 1e3,
      // max replaces to prevent endless loop
    },
  };
}
function K2(n) {
  return (
    typeof n.ns == 'string' && (n.ns = [n.ns]),
    typeof n.fallbackLng == 'string' && (n.fallbackLng = [n.fallbackLng]),
    typeof n.fallbackNS == 'string' && (n.fallbackNS = [n.fallbackNS]),
    n.whitelist && n.whitelist.indexOf('cimode') < 0 && (n.whitelist = n.whitelist.concat(['cimode'])),
    n
  );
}
function fd() {}
var N9 = /* @__PURE__ */ (function (n) {
  fp(e, n);
  function e() {
    var t,
      i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
      r = arguments.length > 1 ? arguments[1] : void 0;
    if (
      (Wr(this, e),
      (t = il(this, Co(e).call(this))),
      As.call(xa(t)),
      (t.options = K2(i)),
      (t.services = {}),
      (t.logger = Er),
      (t.modules = {
        external: [],
      }),
      r && !t.isInitialized && !i.isClone)
    ) {
      if (!t.options.initImmediate) return t.init(i, r), il(t, xa(t));
      setTimeout(function () {
        t.init(i, r);
      }, 0);
    }
    return t;
  }
  return (
    Jr(e, [
      {
        key: 'init',
        value: function () {
          var i = this,
            r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            s = arguments.length > 1 ? arguments[1] : void 0;
          typeof r == 'function' && ((s = r), (r = {})), (this.options = $n({}, P9(), this.options, K2(r))), (this.format = this.options.interpolation.format), s || (s = fd);
          function a(m) {
            return m ? (typeof m == 'function' ? new m() : m) : null;
          }
          if (!this.options.isClone) {
            this.modules.logger ? Er.init(a(this.modules.logger), this.options) : Er.init(null, this.options);
            var o = new S9(this.options);
            this.store = new E9(this.options.resources, this.options);
            var u = this.services;
            (u.logger = Er),
              (u.resourceStore = this.store),
              (u.languageUtils = o),
              (u.pluralResolver = new R9(o, {
                prepend: this.options.pluralSeparator,
                compatibilityJSON: this.options.compatibilityJSON,
                simplifyPluralSuffix: this.options.simplifyPluralSuffix,
              })),
              (u.interpolator = new I9(this.options)),
              (u.utils = {
                hasLoadedNamespace: this.hasLoadedNamespace.bind(this),
              }),
              (u.backendConnector = new k9(a(this.modules.backend), u.resourceStore, u, this.options)),
              u.backendConnector.on('*', function (m) {
                for (var w = arguments.length, v = new Array(w > 1 ? w - 1 : 0), T = 1; T < w; T++) v[T - 1] = arguments[T];
                i.emit.apply(i, [m].concat(v));
              }),
              this.modules.languageDetector && ((u.languageDetector = a(this.modules.languageDetector)), u.languageDetector.init(u, this.options.detection, this.options)),
              this.modules.i18nFormat && ((u.i18nFormat = a(this.modules.i18nFormat)), u.i18nFormat.init && u.i18nFormat.init(this)),
              (this.translator = new H2(this.services, this.options)),
              this.translator.on('*', function (m) {
                for (var w = arguments.length, v = new Array(w > 1 ? w - 1 : 0), T = 1; T < w; T++) v[T - 1] = arguments[T];
                i.emit.apply(i, [m].concat(v));
              }),
              this.modules.external.forEach(function (m) {
                m.init && m.init(i);
              });
          }
          var l = ['getResource', 'addResource', 'addResources', 'addResourceBundle', 'removeResourceBundle', 'hasResourceBundle', 'getResourceBundle', 'getDataByLanguage'];
          l.forEach(function (m) {
            i[m] = function () {
              var w;
              return (w = i.store)[m].apply(w, arguments);
            };
          });
          var c = su(),
            f = function () {
              i.changeLanguage(i.options.lng, function (w, v) {
                (i.isInitialized = !0), i.logger.log('initialized', i.options), i.emit('initialized', i.options), c.resolve(v), s(w, v);
              });
            };
          return this.options.resources || !this.options.initImmediate ? f() : setTimeout(f, 0), c;
        },
        /* eslint consistent-return: 0 */
      },
      {
        key: 'loadResources',
        value: function () {
          var i = this,
            r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : fd;
          if (!this.options.resources || this.options.partialBundledLanguages) {
            if (this.language && this.language.toLowerCase() === 'cimode') return r();
            var s = [],
              a = function (l) {
                if (l) {
                  var c = i.services.languageUtils.toResolveHierarchy(l);
                  c.forEach(function (f) {
                    s.indexOf(f) < 0 && s.push(f);
                  });
                }
              };
            if (this.language) a(this.language);
            else {
              var o = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
              o.forEach(function (u) {
                return a(u);
              });
            }
            this.options.preload &&
              this.options.preload.forEach(function (u) {
                return a(u);
              }),
              this.services.backendConnector.load(s, this.options.ns, r);
          } else r(null);
        },
      },
      {
        key: 'reloadResources',
        value: function (i, r, s) {
          var a = su();
          return (
            i || (i = this.languages),
            r || (r = this.options.ns),
            s || (s = fd),
            this.services.backendConnector.reload(i, r, function (o) {
              a.resolve(), s(o);
            }),
            a
          );
        },
      },
      {
        key: 'use',
        value: function (i) {
          return (
            i.type === 'backend' && (this.modules.backend = i),
            (i.type === 'logger' || (i.log && i.warn && i.error)) && (this.modules.logger = i),
            i.type === 'languageDetector' && (this.modules.languageDetector = i),
            i.type === 'i18nFormat' && (this.modules.i18nFormat = i),
            i.type === 'postProcessor' && ow.addPostProcessor(i),
            i.type === '3rdParty' && this.modules.external.push(i),
            this
          );
        },
      },
      {
        key: 'changeLanguage',
        value: function (i, r) {
          var s = this,
            a = su();
          this.emit('languageChanging', i);
          var o = function (c, f) {
              s.translator.changeLanguage(f),
                f && (s.emit('languageChanged', f), s.logger.log('languageChanged', f)),
                a.resolve(function () {
                  return s.t.apply(s, arguments);
                }),
                r &&
                  r(c, function () {
                    return s.t.apply(s, arguments);
                  });
            },
            u = function (c) {
              c &&
                ((s.language = c),
                (s.languages = s.services.languageUtils.toResolveHierarchy(c)),
                s.translator.language || s.translator.changeLanguage(c),
                s.services.languageDetector && s.services.languageDetector.cacheUserLanguage(c)),
                s.loadResources(function (f) {
                  o(f, c);
                });
            };
          return (
            !i && this.services.languageDetector && !this.services.languageDetector.async
              ? u(this.services.languageDetector.detect())
              : !i && this.services.languageDetector && this.services.languageDetector.async
              ? this.services.languageDetector.detect(u)
              : u(i),
            a
          );
        },
      },
      {
        key: 'getFixedT',
        value: function (i, r) {
          var s = this,
            a = function o(u, l) {
              var c;
              if (Di(l) !== 'object') {
                for (var f = arguments.length, m = new Array(f > 2 ? f - 2 : 0), w = 2; w < f; w++) m[w - 2] = arguments[w];
                c = s.options.overloadTranslationOptionHandler([u, l].concat(m));
              } else c = $n({}, l);
              return (c.lng = c.lng || o.lng), (c.lngs = c.lngs || o.lngs), (c.ns = c.ns || o.ns), s.t(u, c);
            };
          return typeof i == 'string' ? (a.lng = i) : (a.lngs = i), (a.ns = r), a;
        },
      },
      {
        key: 't',
        value: function () {
          var i;
          return this.translator && (i = this.translator).translate.apply(i, arguments);
        },
      },
      {
        key: 'exists',
        value: function () {
          var i;
          return this.translator && (i = this.translator).exists.apply(i, arguments);
        },
      },
      {
        key: 'setDefaultNamespace',
        value: function (i) {
          this.options.defaultNS = i;
        },
      },
      {
        key: 'hasLoadedNamespace',
        value: function (i) {
          var r = this;
          if (!this.isInitialized) return this.logger.warn('hasLoadedNamespace: i18next was not initialized', this.languages), !1;
          if (!this.languages || !this.languages.length) return this.logger.warn('hasLoadedNamespace: i18n.languages were undefined or empty', this.languages), !1;
          var s = this.languages[0],
            a = this.options ? this.options.fallbackLng : !1,
            o = this.languages[this.languages.length - 1];
          if (s.toLowerCase() === 'cimode') return !0;
          var u = function (c, f) {
            var m = r.services.backendConnector.state[''.concat(c, '|').concat(f)];
            return m === -1 || m === 2;
          };
          return !!(this.hasResourceBundle(s, i) || !this.services.backendConnector.backend || (u(s, i) && (!a || u(o, i))));
        },
      },
      {
        key: 'loadNamespaces',
        value: function (i, r) {
          var s = this,
            a = su();
          return this.options.ns
            ? (typeof i == 'string' && (i = [i]),
              i.forEach(function (o) {
                s.options.ns.indexOf(o) < 0 && s.options.ns.push(o);
              }),
              this.loadResources(function (o) {
                a.resolve(), r && r(o);
              }),
              a)
            : (r && r(), Promise.resolve());
        },
      },
      {
        key: 'loadLanguages',
        value: function (i, r) {
          var s = su();
          typeof i == 'string' && (i = [i]);
          var a = this.options.preload || [],
            o = i.filter(function (u) {
              return a.indexOf(u) < 0;
            });
          return o.length
            ? ((this.options.preload = a.concat(o)),
              this.loadResources(function (u) {
                s.resolve(), r && r(u);
              }),
              s)
            : (r && r(), Promise.resolve());
        },
      },
      {
        key: 'dir',
        value: function (i) {
          if ((i || (i = this.languages && this.languages.length > 0 ? this.languages[0] : this.language), !i)) return 'rtl';
          var r = [
            'ar',
            'shu',
            'sqr',
            'ssh',
            'xaa',
            'yhd',
            'yud',
            'aao',
            'abh',
            'abv',
            'acm',
            'acq',
            'acw',
            'acx',
            'acy',
            'adf',
            'ads',
            'aeb',
            'aec',
            'afb',
            'ajp',
            'apc',
            'apd',
            'arb',
            'arq',
            'ars',
            'ary',
            'arz',
            'auz',
            'avl',
            'ayh',
            'ayl',
            'ayn',
            'ayp',
            'bbz',
            'pga',
            'he',
            'iw',
            'ps',
            'pbt',
            'pbu',
            'pst',
            'prp',
            'prd',
            'ur',
            'ydd',
            'yds',
            'yih',
            'ji',
            'yi',
            'hbo',
            'men',
            'xmn',
            'fa',
            'jpr',
            'peo',
            'pes',
            'prs',
            'dv',
            'sam',
          ];
          return r.indexOf(this.services.languageUtils.getLanguagePartFromCode(i)) >= 0 ? 'rtl' : 'ltr';
        },
        /* eslint class-methods-use-this: 0 */
      },
      {
        key: 'createInstance',
        value: function () {
          var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            r = arguments.length > 1 ? arguments[1] : void 0;
          return new e(i, r);
        },
      },
      {
        key: 'cloneInstance',
        value: function () {
          var i = this,
            r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},
            s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : fd,
            a = $n({}, this.options, r, {
              isClone: !0,
            }),
            o = new e(a),
            u = ['store', 'services', 'language'];
          return (
            u.forEach(function (l) {
              o[l] = i[l];
            }),
            (o.translator = new H2(o.services, o.options)),
            o.translator.on('*', function (l) {
              for (var c = arguments.length, f = new Array(c > 1 ? c - 1 : 0), m = 1; m < c; m++) f[m - 1] = arguments[m];
              o.emit.apply(o, [l].concat(f));
            }),
            o.init(a, s),
            (o.translator.options = o.options),
            o
          );
        },
      },
    ]),
    e
  );
})(As);
new N9();
function Pn(n, e, t, i) {
  var r = arguments.length,
    s = r < 3 ? e : i === null ? (i = Object.getOwnPropertyDescriptor(e, t)) : i,
    a;
  if (typeof Reflect == 'object' && typeof Reflect.decorate == 'function') s = Reflect.decorate(n, e, t, i);
  else for (var o = n.length - 1; o >= 0; o--) (a = n[o]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}
function ps(n, e) {
  return function (t, i) {
    e(t, i, n);
  };
}
var W2;
(function (n) {
  (n.I18N_EA_CHANNEL = 'i18n:locale:changed'), (n.I18N_SIGNAL = 'aurelia-translation-signal'), (n.RT_SIGNAL = 'aurelia-relativetime-signal');
})(W2 || (W2 = {}));
var J2;
(function (n) {
  (n.translationValueConverterName = 't'), (n.dateFormatValueConverterName = 'df'), (n.numberFormatValueConverterName = 'nf'), (n.relativeTimeValueConverterName = 'rt');
})(J2 || (J2 = {}));
function L0(n, e) {
  const t = e.ast.expression;
  if (!(t instanceof $u)) {
    const i = new $u(t, n, e.ast.args);
    e.ast.expression = i;
  }
}
let Q2 = class {
  bind(e, t) {
    L0('df', t);
  }
};
Q2 = Pn([Hn('df')], Q2);
const D9 = /* @__PURE__ */ be.createInterface('I18nInitOptions'),
  B9 = /* @__PURE__ */ be.createInterface('I18nextWrapper');
var Y2;
(function (n) {
  (n[(n.Second = 1e3)] = 'Second'),
    (n[(n.Minute = 6e4)] = 'Minute'),
    (n[(n.Hour = 36e5)] = 'Hour'),
    (n[(n.Day = 864e5)] = 'Day'),
    (n[(n.Week = 6048e5)] = 'Week'),
    (n[(n.Month = 2592e6)] = 'Month'),
    (n[(n.Year = 31536e6)] = 'Year');
})(Y2 || (Y2 = {}));
class F9 {
  constructor(e) {
    this.value = void 0;
    const t = /\[([a-z\-, ]*)\]/gi;
    this.attributes = [];
    const i = t.exec(e);
    i && ((e = e.replace(i[0], '')), (this.attributes = i[1].split(','))), (this.key = e);
  }
}
const Ua = /* @__PURE__ */ be.createInterface('I18N');
let zy = class {
  constructor(e, t, i, r) {
    (this.ea = i), (this.i = /* @__PURE__ */ new Set()), (this.i18next = e.i18next), (this.initPromise = this.h(t)), (this.u = r);
  }
  evaluate(e, t) {
    const i = e.split(';'),
      r = [];
    for (const s of i) {
      const a = new F9(s),
        o = a.key,
        u = this.tr(o, t);
      this.options.skipTranslationOnMissingKey && u === o ? console.warn(`Couldn't find translation for key: ${o}`) : ((a.value = u), r.push(a));
    }
    return r;
  }
  tr(e, t) {
    return this.i18next.t(e, t);
  }
  getLocale() {
    return this.i18next.language;
  }
  async setLocale(e) {
    const i = {
      oldLocale: this.getLocale(),
      newLocale: e,
    };
    await this.i18next.changeLanguage(e), this.ea.publish('i18n:locale:changed', i), this.i.forEach((r) => r.handleLocaleChange(i)), this.u.dispatchSignal('aurelia-translation-signal');
  }
  createNumberFormat(e, t) {
    return Intl.NumberFormat(t || this.getLocale(), e);
  }
  nf(e, t, i) {
    return this.createNumberFormat(t, i).format(e);
  }
  createDateTimeFormat(e, t) {
    return Intl.DateTimeFormat(t || this.getLocale(), e);
  }
  df(e, t, i) {
    return this.createDateTimeFormat(t, i).format(e);
  }
  uf(e, t) {
    const i = this.nf(3333.3333333333335, void 0, t);
    let r = i[1];
    const s = i[5];
    r === '.' && (r = '\\.');
    const a = e
      .replace(new RegExp(r, 'g'), '')
      .replace(/[^\d.,-]/g, '')
      .replace(s, '.');
    return Number(a);
  }
  createRelativeTimeFormat(e, t) {
    return new Intl.RelativeTimeFormat(t || this.getLocale(), e);
  }
  rt(e, t, i) {
    let r = e.getTime() - this.now();
    const s = this.options.rtEpsilon * (r > 0 ? 1 : 0),
      a = this.createRelativeTimeFormat(t, i);
    let o = r / 31536e6;
    return Math.abs(o + s) >= 1
      ? a.format(Math.round(o), 'year')
      : ((o = r / 2592e6),
        Math.abs(o + s) >= 1
          ? a.format(Math.round(o), 'month')
          : ((o = r / 6048e5),
            Math.abs(o + s) >= 1
              ? a.format(Math.round(o), 'week')
              : ((o = r / 864e5),
                Math.abs(o + s) >= 1
                  ? a.format(Math.round(o), 'day')
                  : ((o = r / 36e5),
                    Math.abs(o + s) >= 1
                      ? a.format(Math.round(o), 'hour')
                      : ((o = r / 6e4), Math.abs(o + s) >= 1 ? a.format(Math.round(o), 'minute') : ((r = Math.abs(r) < 1e3 ? 1e3 : r), (o = r / 1e3), a.format(Math.round(o), 'second')))))));
  }
  subscribeLocaleChange(e) {
    this.i.add(e);
  }
  now() {
    return /* @__PURE__ */ new Date().getTime();
  }
  async h(e) {
    const t = {
      lng: 'en',
      fallbackLng: ['en'],
      debug: !1,
      plugins: [],
      rtEpsilon: 0.01,
      skipTranslationOnMissingKey: !1,
    };
    this.options = {
      ...t,
      ...e,
    };
    for (const i of this.options.plugins) this.i18next.use(i);
    await this.i18next.init(this.options);
  }
};
Pn([ZE], zy.prototype, 'i18next', void 0);
zy = Pn([ps(0, B9), ps(1, D9), ps(2, zc), ps(3, Hc)], zy);
let X2 = class {
  constructor(e) {
    (this.i18n = e), (this.signals = ['aurelia-translation-signal']);
  }
  toView(e, t, i) {
    if ((!e && e !== 0) || (typeof e == 'string' && e.trim() === '')) return e;
    if (typeof e == 'string') {
      const r = Number(e),
        s = new Date(Number.isInteger(r) ? r : e);
      if (isNaN(s.getTime())) return e;
      e = s;
    }
    return this.i18n.df(e, t, i);
  }
};
X2 = Pn([Sl('df'), ps(0, Ua)], X2);
let Z2 = class {
  bind(e, t) {
    L0('nf', t);
  }
};
Z2 = Pn([Hn('nf')], Z2);
let ev = class {
  constructor(e) {
    (this.i18n = e), (this.signals = ['aurelia-translation-signal']);
  }
  toView(e, t, i) {
    return typeof e != 'number' ? e : this.i18n.nf(e, t, i);
  }
};
ev = Pn([Sl('nf'), ps(0, Ua)], ev);
let tv = class {
  bind(e, t) {
    L0('rt', t);
  }
};
tv = Pn([Hn('rt')], tv);
let nv = class {
  constructor(e) {
    (this.i18n = e), (this.signals = ['aurelia-translation-signal', 'aurelia-relativetime-signal']);
  }
  toView(e, t, i) {
    return e instanceof Date ? this.i18n.rt(e, t, i) : e;
  }
};
nv = Pn([Sl('rt'), ps(0, Ua)], nv);
let iv = class {
  bind(e, t) {
    const i = t.ast.expression;
    if (!(i instanceof $u)) {
      const r = new $u(i, 't', t.ast.args);
      t.ast.expression = r;
    }
  }
};
iv = Pn([Hn('t')], iv);
const L9 = ['textContent', 'innerHTML', 'prepend', 'append'],
  $9 = /* @__PURE__ */ new Map([
    ['text', 'textContent'],
    ['html', 'innerHTML'],
  ]),
  U9 = {
    optional: !0,
  },
  j9 = {
    reusable: !1,
    preempt: !0,
  };
class Lr {
  constructor(e, t, i, r, s) {
    (this.isBound = !1),
      (this._ = L9),
      (this.T = null),
      (this.parameter = null),
      (this.boundFn = !1),
      (this.l = t),
      (this.B = e),
      (this.target = s),
      (this.i18n = t.get(Ua)),
      (this.p = r),
      (this.C = /* @__PURE__ */ new Set()),
      (this.oL = i),
      this.i18n.subscribeLocaleChange(this),
      (this.I = r.domWriteQueue);
  }
  static create({ parser: e, observerLocator: t, context: i, controller: r, target: s, instruction: a, platform: o, isParameterContext: u }) {
    const l = this.P({
        observerLocator: t,
        context: i,
        controller: r,
        target: s,
        platform: o,
      }),
      c = typeof a.from == 'string' ? e.parse(a.from, 16) : a.from;
    if (u) l.useParameter(c);
    else {
      const f = c instanceof wh ? e.parse(c.value, 1) : void 0;
      l.ast = f || c;
    }
  }
  static P({ observerLocator: e, context: t, controller: i, target: r, platform: s }) {
    let a = i.bindings && i.bindings.find((o) => o instanceof Lr && o.target === r);
    return a || ((a = new Lr(i, t, e, s, r)), i.addBinding(a)), a;
  }
  bind(e) {
    if (!this.isBound) {
      if (!this.ast) throw new Error('key expression is missing');
      (this.s = e), (this.M = this.ast instanceof kx), (this.A = G(this.ast, e, this, this)), this.L(), this.parameter?.bind(e), this.updateTranslations(), (this.isBound = !0);
    }
  }
  unbind() {
    this.isBound && (pi(this.ast, this.s, this), this.parameter?.unbind(), this.C.clear(), this.T !== null && (this.T.cancel(), (this.T = null)), (this.s = void 0), this.obs.clearAll());
  }
  handleChange(e, t) {
    this.obs.version++, (this.A = this.M ? G(this.ast, this.s, this, this) : e), this.obs.clear(), this.L(), this.updateTranslations();
  }
  handleLocaleChange() {
    this.updateTranslations();
  }
  useParameter(e) {
    if (this.parameter != null) throw new Error('This translation parameter has already been specified.');
    this.parameter = new $0(this, e, () => this.updateTranslations());
  }
  updateTranslations() {
    const e = this.i18n.evaluate(this.A, this.parameter?.value),
      t = /* @__PURE__ */ Object.create(null),
      i = [],
      r = this.T;
    this.C.clear();
    for (const a of e) {
      const o = a.value,
        u = this.R(a.attributes);
      for (const l of u)
        if (this.V(l)) t[l] = o;
        else {
          const c = lo.for(this.target, U9),
            f = c?.viewModel ? this.oL.getAccessor(c.viewModel, l) : this.oL.getAccessor(this.target, l);
          this.B.state !== 1 && (f.type & 4) > 0 ? i.push(new V9(f, o, this.target, l)) : f.setValue(o, this.target, l), this.C.add(f);
        }
    }
    let s = !1;
    Object.keys(t).length > 0 && ((s = this.B.state !== 1), s || this.F(t)),
      (i.length > 0 || s) &&
        (this.T = this.I.queueTask(() => {
          this.T = null;
          for (const a of i) a.run();
          s && this.F(t);
        }, j9)),
      r?.cancel();
  }
  R(e) {
    e.length === 0 && (e = this.target.tagName === 'IMG' ? ['src'] : ['textContent']);
    for (const [t, i] of $9) {
      const r = e.findIndex((s) => s === t);
      r > -1 && e.splice(r, 1, i);
    }
    return e;
  }
  V(e) {
    return this._.includes(e);
  }
  F(e) {
    const t = Gp(this.target.childNodes),
      i = [],
      r = 'au-i18n';
    for (const a of t) Reflect.get(a, r) || i.push(a);
    const s = this.N(e, r, i);
    this.target.innerHTML = '';
    for (const a of Gp(s.content.childNodes)) this.target.appendChild(a);
  }
  N(e, t, i) {
    const r = this.p.document.createElement('template');
    if ((this.O(r, e.prepend, t), !this.O(r, e.innerHTML ?? e.textContent, t))) for (const s of i) r.content.append(s);
    return this.O(r, e.append, t), r;
  }
  O(e, t, i) {
    if (t != null) {
      const r = this.p.document.createElement('div');
      r.innerHTML = t;
      for (const s of Gp(r.childNodes)) Reflect.set(s, i, !0), e.content.append(s);
      return !0;
    }
    return !1;
  }
  L() {
    const e = this.A ?? (this.A = ''),
      t = typeof e;
    if (t !== 'string') throw new Error(`Expected the i18n key to be a string, but got ${e} of type ${t}`);
  }
}
Fi(Lr);
lr(!0)(Lr);
ka(Lr, () => 'updateTranslations');
class V9 {
  constructor(e, t, i, r) {
    (this.accessor = e), (this.v = t), (this.el = i), (this.attr = r);
  }
  run() {
    this.accessor.setValue(this.v, this.el, this.attr);
  }
}
class $0 {
  constructor(e, t, i) {
    (this.owner = e), (this.ast = t), (this.updater = i), (this.isBound = !1), (this.boundFn = !1), (this.oL = e.oL), (this.l = e.l);
  }
  handleChange(e, t) {
    this.isBound && (this.obs.version++, (this.value = G(this.ast, this.s, this, this)), this.obs.clear(), this.updater());
  }
  bind(e) {
    this.isBound || ((this.s = e), Pi(this.ast, e, this), (this.value = G(this.ast, e, this, this)), (this.isBound = !0));
  }
  unbind() {
    this.isBound && (pi(this.ast, this.s, this), (this.s = void 0), this.obs.clearAll());
  }
}
Fi($0);
lr(!0)($0);
const uw = 'tpt',
  rl = 't-params.bind';
let rv = class {
  [rl](e, t, i) {
    return new hi(e, t, '', rl);
  }
};
rv = Pn(
  [
    Hr({
      pattern: rl,
      symbols: '',
    }),
  ],
  rv,
);
class z9 {
  constructor(e, t) {
    (this.from = e), (this.to = t), (this.type = uw), (this.mode = 2);
  }
}
let sv = class {
  constructor() {
    this.type = 0;
  }
  get name() {
    return rl;
  }
  build(e, t, i) {
    const r = e.attr;
    let s = r.target;
    return e.bindable == null ? (s = i.map(e.node, s) ?? ti(s)) : (s = e.bindable.property), new z9(t.parse(r.rawValue, 16), s);
  }
};
sv = Pn([Kn(rl)], sv);
let av = class {
  render(e, t, i, r, s, a) {
    Lr.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: i,
      isParameterContext: !0,
      platform: r,
    });
  }
};
av = Pn([qt(uw)], av);
const G9 = 'tt';
let ov = class {
  render(e, t, i, r, s, a) {
    Lr.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: i,
      platform: r,
    });
  }
};
ov = Pn([qt(G9)], ov);
const q9 = 'tbt';
let uv = class {
  render(e, t, i, r, s, a) {
    Lr.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: i,
      platform: r,
    });
  }
};
uv = Pn([qt(q9)], uv);
let lv = class {
  constructor(e) {
    (this.i18n = e), (this.signals = ['aurelia-translation-signal']);
  }
  toView(e, t) {
    return this.i18n.tr(e, t);
  }
};
lv = Pn([Sl('t'), ps(0, Ua)], lv);
Array.prototype.sum = function () {
  return this.reduce((n, e) => n + e, 0);
};
const H9 = {
    authDomain: 'kolektivo-36b63.firebaseapp.com',
    projectId: 'kolektivo-36b63',
    storageBucket: 'kolektivo-36b63.appspot.com',
    messagingSenderId: '324595180464',
    appId: '1:324595180464:web:69e6b83cdba3bf2d30ac75',
    measurementId: 'G-7BSHV1Y6VS',
  },
  Ll = be.createInterface('CacheService');
class yp {
  cache = /* @__PURE__ */ new Map();
  setItem(e, t) {
    this.cache.set(e, t);
  }
  getItem(e) {
    return this.cache.get(e);
  }
  static register(e) {
    me.singleton(Ll, yp).register(e);
  }
}
const Nf = (n, e) => {
  const t = n[e];
  return t
    ? typeof t == 'function'
      ? t()
      : Promise.resolve(t)
    : new Promise((i, r) => {
        (typeof queueMicrotask == 'function' ? queueMicrotask : setTimeout)(r.bind(null, new Error('Unknown variable dynamic import: ' + e)));
      });
};
function lw(n) {
  return function (e, t, i) {
    const r = `${e.constructor.name}_${t}`,
      s = i.value;
    return (
      (i.value = function (...a) {
        const { storage: o } = n.call(this),
          u = `${r}_${JSON.stringify(a)}`;
        let l = o.getItem(u);
        return l || ((l = s?.apply(this, a)), o.setItem(u, l), l);
      }),
      i
    );
  };
}
const hp = be.createInterface(),
  K9 = 'https://primedao.mypinata.cloud//',
  dv = Number({}.KOL_CHAIN_ID ?? 42220),
  cv = {}.KOL_CHAIN_URL ?? 'https://forno.celo.org',
  pv = {}.KOL_CHAIN ?? 'Celo',
  W9 = {}.KOL_SCAN_LINK ?? 'https://explorer.celo.org/{type}/{address}',
  J9 = !!({}.KOL_TESTING ?? !0),
  eo = 'testData';
var Q9 = Object.defineProperty,
  Y9 = Object.getOwnPropertyDescriptor,
  dw = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? Y9(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && Q9(e, t, r), r;
  },
  fv = (n, e) => (t, i) => e(t, i, n);
const Wo = be.createInterface();
let Mo = class {
  constructor(n, e) {
    (this.cacheService = n), (this.readOnlyProvider = e);
  }
  static register(n) {
    me.singleton(Wo, Mo).register(n);
  }
  /**
   * get a Promise of a PopulatedTransaction that can be used to sign
   * and manually send transactions.
   * Uses the `populateTransaction` method supplied by ethers.js.
   *
   * @param contract
   * @param subFunctionName the name of the contract function
   * @param params
   * @returns
   */
  callPopulateTransaction(n, e, ...t) {
    return n.populateTransaction[e].call(t);
  }
  async getContract(n, e, t, i) {
    const a = (
      J9
        ? await Nf(
            /* @__PURE__ */ Object.assign({
              '../../contracts/governance/celo-test.json': () => Promise.resolve().then(() => UD),
              '../../contracts/monetary/celo-test.json': () => Promise.resolve().then(() => VD),
            }),
            `../../contracts/${n}/celo-test.json`,
          )
        : await Nf(
            /* @__PURE__ */ Object.assign({
              '../../contracts/governance/celo.json': () => Promise.resolve().then(() => GD),
              '../../contracts/map/celo.json': () => Promise.resolve().then(() => HD),
              '../../contracts/monetary/celo.json': () => Promise.resolve().then(() => WD),
            }),
            `../../contracts/${n}/celo.json`,
          )
    ).contracts[e];
    let o = a.abi;
    if ((o || (o = 'ERC20'), typeof o == 'string')) {
      const u = o;
      o = await this.getSharedAbi(n, u);
    }
    if (((t = t ?? a.address), !t)) throw new Error(`ContractService: requested contract has no address: ${e}`);
    return new T6(t, o, i ?? this.readOnlyProvider);
  }
  async getSharedAbi(n, e) {
    return (
      await Nf(
        /* @__PURE__ */ Object.assign({
          '../../contracts/governance/sharedAbis.json': () => Promise.resolve().then(() => QD),
          '../../contracts/map/sharedAbis.json': () => Promise.resolve().then(() => XD),
          '../../contracts/monetary/sharedAbis.json': () => Promise.resolve().then(() => eB),
        }),
        `../../contracts/${n}/sharedAbis.json`,
      )
    )[e];
  }
};
dw(
  [
    lw(function () {
      return { storage: this.cacheService };
    }),
  ],
  Mo.prototype,
  'getContract',
  1,
);
Mo = dw([fv(0, Ll), fv(1, hp)], Mo);
const cw = be.createInterface(),
  X9 = 'https://raw.githubusercontent.com/Kolektivo/tokenlists/main/tokenlist.json',
  Z9 =
    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    globalThis.fetch !== void 0
      ? await fetch(X9, {
          method: 'GET',
          headers: { accept: 'application/json' },
        })
          .then(async (n) => await n.json())
          .then((n) => n.tokens)
      : [];
var eO = Object.defineProperty,
  tO = Object.getOwnPropertyDescriptor,
  nO = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? tO(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && eO(e, t, r), r;
  },
  iO = (n, e) => (t, i) => e(t, i, n);
const pw = be.createInterface(),
  U0 = be.createInterface();
let sl = class {
  constructor(n) {
    this.container = n;
  }
  static register(n) {
    n.register(me.singleton(U0, sl));
  }
  fireStore;
  async connect() {
    const { getFirestore: n } = await Promise.resolve().then(() => Jv);
    return (this.fireStore ??= n(await this.container.get(pw))), this.fireStore;
  }
  async getDocs(n, e, t, i) {
    const { getDocs: r, query: s, collection: a, where: o, orderBy: u } = await Promise.resolve().then(() => Jv);
    return (await r(s(a(await this.connect(), n), o(i.fieldPath, i.opStr, i.value), u(e, t)))).docs.map((c) => c.data());
  }
};
sl = nO([iO(0, Po)], sl);
var rO = Object.defineProperty,
  sO = Object.getOwnPropertyDescriptor,
  aO = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? sO(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && rO(e, t, r), r;
  },
  oO = (n, e) => (t, i) => e(t, i, n);
const $l = be.createInterface('NumberService');
let al = class {
  constructor(n) {
    this.i18n = n;
  }
  static register(n) {
    n.register(me.singleton($l, al));
  }
  /**
   * Returns a string from a number or BigNumber.
   * @param value
   * @param format
   */
  toString(n, e) {
    if (n === null || typeof n > 'u' || typeof n == 'string') return n;
    if ((q.isBigNumber(n) && (n = n.toNumber()), Number.isNaN(n))) return 'NaN';
    const t = e?.useGrouping ?? !0,
      i = e?.isPercentage ?? !1,
      r = e?.isCurrency ?? !1;
    let s = this.fromString(e?.fractionDigits);
    isNaN(s) && (s = 2);
    const a = r ? { style: 'currency', currency: 'USD' } : i ? { style: 'percent' } : { style: 'decimal' };
    return this.i18n.nf(
      n,
      Object.assign(a, {
        useGrouping: t,
        minimumFractionDigits: s,
        maximumFractionDigits: s,
      }),
    );
  }
  /**
   * returns number from string.
   * @param value the value
   */
  fromString(n) {
    return n === null || typeof n > 'u' ? NaN : typeof n == 'number' ? n : this.i18n.uf(n);
  }
};
al = aO([oO(0, Ua)], al);
var uO = Object.defineProperty,
  lO = Object.getOwnPropertyDescriptor,
  fw = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? lO(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && uO(e, t, r), r;
  },
  Df = (n, e) => (t, i) => e(t, i, n);
const j0 = be.createInterface();
let _o = class {
  constructor(n, e, t) {
    (this.cacheService = n), (this.contractService = e), (this.readonlyProvider = t);
  }
  static register(n) {
    me.singleton(j0, _o).register(n);
  }
  async getTokenContract(n, e, t) {
    const i = e ? await this.contractService.getSharedAbi('monetary', 'ERC721') : await this.contractService.getSharedAbi('monetary', 'ERC20');
    return new T6(n, i, t ?? this.readonlyProvider);
  }
};
fw(
  [
    lw(function () {
      return { storage: this.cacheService };
    }),
  ],
  _o.prototype,
  'getTokenContract',
  1,
);
_o = fw([Df(0, Ll), Df(1, Wo), Df(2, hp)], _o);
var Iu = /* @__PURE__ */ ((n) => ((n[(n.Low = 0)] = 'Low'), (n[(n.Medium = 1)] = 'Medium'), (n[(n.High = 2)] = 'High'), n))(Iu || {});
const dO = be.createInterface();
var cO = Object.defineProperty,
  pO = Object.getOwnPropertyDescriptor,
  fO = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? pO(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && cO(e, t, r), r;
  },
  yO = (n, e) => (t, i) => e(t, i, n);
const V0 = be.createInterface();
let Tc = class {
  constructor(n) {
    this.client = n;
  }
  static register(n) {
    n.register(me.singleton(V0, Tc));
  }
  async all(n) {
    const e = [];
    for await (const t of n) e.push(t);
    return e;
  }
  save(n, e = !0) {
    return typeof n == 'string'
      ? this.client
          .add(
            { content: n },
            {
              pin: e,
            },
          )
          .then((t) => t.cid)
      : this.client.dag.put(n, {
          pin: e,
        });
  }
  async get(n, e = !1, t) {
    const i = (await Promise.resolve().then(() => JB)).CID.asCID(n);
    if (i) {
      if (!e) {
        const r = this.client.cat(n),
          s = (await Promise.resolve().then(() => YB)).concat(await this.all(r));
        return (await Promise.resolve().then(() => SF)).toString(s);
      }
      return JSON.stringify((await this.client.dag.get(i, { path: t })).value);
    }
  }
};
Tc = fO([yO(0, dO)], Tc);
const hO = '@kolektivo/dapp',
  mO = 'A collection of institutional technologies that open up new opportunities for local communities to govern and finance their own regenerative economies.',
  bO = '1.0.0',
  gO = {
    type: 'git',
    url: 'https://github.com/Kolektivo/dapp',
  },
  vO = 'CL Cybernetix GmbH',
  xO = './',
  TO = 'MIT',
  wO = {
    node: '>=16.0.0',
  },
  AO = {
    http: !1,
  },
  EO = {
    'lint:js': 'eslint src --ext .js,.ts',
    'lint:fix': 'eslint src  --fix',
    'lint:scss:fix': 'stylelint "src/**/*.scss" --fix',
    'lint:scss': 'stylelint "src/**/*.scss"',
    'lint:html': 'htmlhint -c .htmlhintrc src design-system ',
    lint: 'npm run lint:js && npm run lint:html',
    clean: 'npx -y rimraf node_modules package-lock.json && npm i',
    dev: 'vite',
    start: 'vite',
    typecheck: 'tsc',
    build: 'tsc && vite build',
    'build:chart-data-script': 'vite build --config vite.config-lib.ts',
    'build:dev:chart-data-script': 'vite build --config vite.config-lib.ts --mode development',
    'build:dev': 'vite build --mode development',
    'preview-build': 'vite preview --open',
    postinstall: 'node build/postinstall/index.mjs',
    test: 'exit 0',
    'test:ui': 'vitest --ui',
    coverage: 'vitest run --coverage',
    e2e: 'playwright test',
    'e2e:watch': 'playwright test --watch',
    'e2e:ci': 'URL=$npm_config_url playwright test',
    'vercel:deploy': 'vercel --token $npm_config_token',
    'vercel:deploy:production': 'vercel --prod --token $npm_config_token',
    'vercel:alias': 'vercel alias set $npm_config_deployment $npm_config_branch --token $npm_config_token --scope $npm_config_scope',
  },
  SO = {
    '@aurelia/i18n': 'dev',
    '@aurelia/router-lite': 'dev',
    '@aurelia/validation-html': 'dev',
    '@celo-tools/celo-ethers-wrapper': '^0.4.0',
    '@dethcrypto/eth-sdk': '^0.3.3',
    '@dethcrypto/eth-sdk-client': '^0.1.6',
    '@lottiefiles/lottie-player': '^1.7.1',
    '@material-design-icons/svg': '^0.14.3',
    '@metamask/detect-provider': '^2.0.0',
    '@metamask/providers': '^10.2.1',
    '@walletconnect/web3-provider': '^1.8.0',
    aurelia: 'dev',
    'browserify-zlib': '^0.2.0',
    buffer: '^6.0.3',
    'chart.js': '^4.2.1',
    cids: '^1.1.9',
    ethers: '^5',
    events: '^3.3.0',
    firebase: '^9.17.2',
    'graphql-request': '^6.0.0',
    'i18next-chained-backend': '^4.2.0',
    'i18next-http-backend': '^2.2.0',
    'i18next-intervalplural-postprocessor': '^3.0.0',
    'i18next-localstorage-backend': '^4.1.0',
    'ipfs-core': '^0.18.0',
    'ipfs-http-client': '^60.0.0',
    'lit-js-sdk': '^1.2.17',
    process: '^0.11.10',
    'stream-browserify': '^3.0.0',
    uint8arrays: '^4.0.3',
    util: '^0.12.5',
    web3modal: '^1.9.12',
  },
  CO = {
    '@aurelia/plugin-conventions': 'dev',
    '@aurelia/testing': 'dev',
    '@esbuild-plugins/node-globals-polyfill': '^0.2.3',
    '@playwright/test': '^1.31.2',
    '@rollup/plugin-inject': '^5.0.3',
    '@typechain/ethers-v5': '^10.2.0',
    '@types/node': '^18.15.3',
    '@typescript-eslint/eslint-plugin': '^5.55.0',
    '@typescript-eslint/parser': '^5.55.0',
    '@vitest/ui': '^0.29.3',
    'cross-env': '^7.0.3',
    eslint: '^8.36.0',
    'eslint-config-prettier': '^8.7.0',
    'eslint-import-resolver-typescript': '^3.5.3',
    'eslint-plugin-cypress': '^2.12.1',
    'eslint-plugin-import': '^2.27.5',
    'eslint-plugin-prettier': '^4.2.1',
    'eslint-plugin-simple-import-sort': '^10.0.0',
    'eslint-plugin-unused-imports': '^2.0.0',
    'fs-extra': '^11.1.0',
    glob: '^9.3.0',
    'happy-dom': '^8.9.0',
    'html-loader': '^4.2.0',
    htmlhint: '^1.1.4',
    'http-browserify': '1.7.0',
    'https-browserify': '^1.0.0',
    postcss: '^8.4.21',
    'postcss-loader': '^7.1.0',
    'rollup-plugin-html': '^0.2.1',
    'rollup-plugin-polyfill-node': '^0.12.0',
    'rollup-plugin-swc': '^0.2.1',
    'rollup-plugin-visualizer': '^5.9.0',
    'rollup-pluginutils': '^2.8.2',
    sass: '^1.59.3',
    stylelint: '^15.2.0',
    'stylelint-config-standard': '^30.0.1',
    'stylelint-config-standard-scss': '^7.0.1',
    'stylelint-prettier': '^3.0.0',
    tslib: '^2.5.0',
    typescript: '~4.9.5',
    vercel: 'latest',
    vite: '^4.2.0',
    vitest: '^0.29.3',
    'vitest-mock-extended': '^1.1.0',
  },
  MO = {
    terser: 'npm:@swc/core',
  },
  _O = {
    name: hO,
    description: mO,
    version: bO,
    repository: gO,
    author: vO,
    homepage: xO,
    license: TO,
    engines: wO,
    browser: AO,
    scripts: EO,
    dependencies: SO,
    devDependencies: CO,
    resolutions: MO,
  },
  z0 = be.createInterface('BrowserStorageService');
class G0 {
  addVersion(e, t) {
    return {
      data: e,
      _version: t,
    };
  }
  getKey(e) {
    return `${_O.name}.${e}`;
  }
  set(e, t, i, r) {
    const s = typeof r == 'string' ? this.addVersion(i, r) : i;
    e.setItem(this.getKey(t), JSON.stringify(s));
  }
  get(e, t, i, r) {
    const s = e.getItem(this.getKey(t));
    if (typeof s == 'string')
      try {
        const a = JSON.parse(s);
        if (typeof r == 'string') {
          const o = a;
          return o._version === r ? o.data : i;
        } else return a;
      } catch {
        return i;
      }
    return i;
  }
  remove(e, t) {
    e.removeItem(this.getKey(t));
  }
  lsSet(e, t, i) {
    this.set(localStorage, e, t, i);
  }
  lsGet(e, t, i) {
    return this.get(localStorage, e, t, i);
  }
  lsRemove(e) {
    this.remove(localStorage, e);
  }
  ssSet(e, t, i) {
    this.set(sessionStorage, e, t, i);
  }
  ssGet(e, t, i) {
    return this.get(sessionStorage, e, t, i);
  }
  ssRemove(e) {
    this.remove(sessionStorage, e);
  }
  static register(e) {
    me.singleton(z0, G0).register(e);
  }
}
var Gy = /* @__PURE__ */ ((n) => (
  (n[(n.MONETARY_CONTROLLER = 1)] = 'MONETARY_CONTROLLER'),
  (n[(n.RESERVE_DELEGATE = 2)] = 'RESERVE_DELEGATE'),
  (n[(n.RESERVE_VETO_DELEGATE = 3)] = 'RESERVE_VETO_DELEGATE'),
  (n[(n.TOPOLOGY_DELEGATE = 4)] = 'TOPOLOGY_DELEGATE'),
  (n[(n.ECOLOGY_DELEGATE = 5)] = 'ECOLOGY_DELEGATE'),
  (n[(n.ECOLOGY_DELEGATE_PROPOSER = 6)] = 'ECOLOGY_DELEGATE_PROPOSER'),
  (n[(n.RESERVE_ARBITRAGEUR = 7)] = 'RESERVE_ARBITRAGEUR'),
  (n[(n.LOCAL_MULTI_SIG_MEMBER = 8)] = 'LOCAL_MULTI_SIG_MEMBER'),
  (n[(n.TREASURY_DELEGATE = 101)] = 'TREASURY_DELEGATE'),
  (n[(n.TREASURY_VETO_DELEGATE = 102)] = 'TREASURY_VETO_DELEGATE'),
  (n[(n.TREASURY_ARBITRAGEUR = 103)] = 'TREASURY_ARBITRAGEUR'),
  (n[(n.KOLEKTIVO_MULTI_SIG_MEMBER = 104)] = 'KOLEKTIVO_MULTI_SIG_MEMBER'),
  n
))(Gy || {});
const RO = be.createInterface();
var IO = Object.defineProperty,
  OO = Object.getOwnPropertyDescriptor,
  kO = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? OO(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && IO(e, t, r), r;
  },
  Bf = (n, e) => (t, i) => e(t, i, n);
const yw = be.createInterface('EncryptionService');
let wc = class {
  constructor(n, e, t) {
    (this.logger = n), (this.container = e), (this.config = t), this.logger.scopeTo('EncryptionService');
  }
  client;
  static register(n) {
    me.singleton(yw, wc).register(n);
  }
  authSig;
  encryptedSymmetricKey;
  get chain() {
    return this.config.chain.toLowerCase();
  }
  getAccessControlConditions(n) {
    return [
      {
        contractAddress: n,
        standardContractType: 'ERC1155',
        chain: this.chain,
        method: 'balanceOfBatch',
        parameters: [':userAddress,:userAddress', `${Gy.RESERVE_DELEGATE},${Gy.ECOLOGY_DELEGATE_PROPOSER}`],
        returnValueTest: {
          comparator: '>',
          value: '0',
        },
      },
    ];
  }
  async connect() {
    if (this.client) return;
    const n = await this.container.get(RO);
    return (this.client = n), await this.client.connect();
  }
  async encrypt(n, e, t, i) {
    if ((await this.connect(), !this.client)) return;
    const r = {
      web3: e,
      account: t.toLowerCase(),
      chainId: this.config.chainId,
      expiration: new Date(Date.now() + 3e5),
      // 5 minutes
    };
    this.authSig = await this.client.getAuthSig(r);
    const { encryptedString: s, symmetricKey: a } = await this.client.encryptString(n);
    return (
      (this.encryptedSymmetricKey = this.client.uint8arrayToString(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
        await this.client.saveEncryptionKey({
          accessControlConditions: this.getAccessControlConditions(i),
          symmetricKey: a,
          authSig: this.authSig,
          chain: this.chain,
        }),
        'base16',
      )),
      { encryptedString: s, symmetricKey: a }
    );
  }
  async decryptAs(n, e) {
    if ((await this.connect(), !this.client)) throw new Error('No encryption client connected');
    const t = await this.client.getEncryptionKey({
        accessControlConditions: this.getAccessControlConditions(e),
        toDecrypt: this.encryptedSymmetricKey,
        chain: this.chain,
        authSig: this.authSig,
      }),
      i = await this.client.decryptString(n, t);
    try {
      return JSON.parse(i);
    } catch {
      this.logger.info('Failed to parse data from LIT');
    }
    return i;
  }
};
wc = kO([Bf(0, _a), Bf(1, Po), Bf(2, Ms)], wc);
var Ri = /* @__PURE__ */ ((n) => ((n[(n['1h'] = 0)] = '1h'), (n[(n['1d'] = 1)] = '1d'), (n[(n['1w'] = 2)] = '1w'), (n[(n['1m'] = 3)] = '1m'), (n[(n['1y'] = 4)] = '1y'), n))(Ri || {}),
  q0 = {};
const PO = /* @__PURE__ */ Dt(MM),
  NO = /* @__PURE__ */ Dt(lC),
  DO = /* @__PURE__ */ Dt(qC),
  BO = /* @__PURE__ */ Dt(D7),
  FO = /* @__PURE__ */ Dt(dS),
  LO = /* @__PURE__ */ Dt(EM),
  $O = /* @__PURE__ */ Dt(Q7),
  UO = /* @__PURE__ */ Dt(cR),
  jO = /* @__PURE__ */ Dt(eC),
  VO = /* @__PURE__ */ Dt(uS),
  yv = /* @__PURE__ */ Dt($7),
  zO = /* @__PURE__ */ Dt(eI),
  GO = /* @__PURE__ */ Dt(eR),
  qO = /* @__PURE__ */ Dt(vS),
  HO = /* @__PURE__ */ Dt(nC),
  KO = /* @__PURE__ */ Dt(g7),
  hv = /* @__PURE__ */ Dt(jC),
  WO = /* @__PURE__ */ Dt(C7),
  JO = /* @__PURE__ */ Dt(iI),
  QO = /* @__PURE__ */ Dt(bR),
  YO = /* @__PURE__ */ Dt(CR);
(function (n) {
  var e =
      (br && br.__createBinding) ||
      (Object.create
        ? function (J, le, C, d) {
            d === void 0 && (d = C),
              Object.defineProperty(J, d, {
                enumerable: !0,
                get: function () {
                  return le[C];
                },
              });
          }
        : function (J, le, C, d) {
            d === void 0 && (d = C), (J[d] = le[C]);
          }),
    t =
      (br && br.__setModuleDefault) ||
      (Object.create
        ? function (J, le) {
            Object.defineProperty(J, 'default', { enumerable: !0, value: le });
          }
        : function (J, le) {
            J.default = le;
          }),
    i =
      (br && br.__importStar) ||
      function (J) {
        if (J && J.__esModule) return J;
        var le = {};
        if (J != null) for (var C in J) C !== 'default' && Object.prototype.hasOwnProperty.call(J, C) && e(le, J, C);
        return t(le, J), le;
      };
  Object.defineProperty(n, '__esModule', { value: !0 }),
    (n.formatBytes32String =
      n.Utf8ErrorFuncs =
      n.toUtf8String =
      n.toUtf8CodePoints =
      n.toUtf8Bytes =
      n._toEscapedUtf8String =
      n.nameprep =
      n.hexDataSlice =
      n.hexDataLength =
      n.hexZeroPad =
      n.hexValue =
      n.hexStripZeros =
      n.hexConcat =
      n.isHexString =
      n.hexlify =
      n.base64 =
      n.base58 =
      n.TransactionDescription =
      n.LogDescription =
      n.Interface =
      n.SigningKey =
      n.HDNode =
      n.defaultPath =
      n.isBytesLike =
      n.isBytes =
      n.zeroPad =
      n.stripZeros =
      n.concat =
      n.arrayify =
      n.shallowCopy =
      n.resolveProperties =
      n.getStatic =
      n.defineReadOnly =
      n.deepCopy =
      n.checkProperties =
      n.poll =
      n.fetchJson =
      n._fetchData =
      n.RLP =
      n.Logger =
      n.checkResultErrors =
      n.FormatTypes =
      n.ParamType =
      n.FunctionFragment =
      n.EventFragment =
      n.ErrorFragment =
      n.ConstructorFragment =
      n.Fragment =
      n.defaultAbiCoder =
      n.AbiCoder =
        void 0),
    (n.Indexed =
      n.Utf8ErrorReason =
      n.UnicodeNormalizationForm =
      n.SupportedAlgorithm =
      n.mnemonicToSeed =
      n.isValidMnemonic =
      n.entropyToMnemonic =
      n.mnemonicToEntropy =
      n.getAccountPath =
      n.verifyTypedData =
      n.verifyMessage =
      n.recoverPublicKey =
      n.computePublicKey =
      n.recoverAddress =
      n.computeAddress =
      n.getJsonWalletAddress =
      n.TransactionTypes =
      n.serializeTransaction =
      n.parseTransaction =
      n.accessListify =
      n.joinSignature =
      n.splitSignature =
      n.soliditySha256 =
      n.solidityKeccak256 =
      n.solidityPack =
      n.shuffled =
      n.randomBytes =
      n.sha512 =
      n.sha256 =
      n.ripemd160 =
      n.keccak256 =
      n.computeHmac =
      n.commify =
      n.parseUnits =
      n.formatUnits =
      n.parseEther =
      n.formatEther =
      n.isAddress =
      n.getCreate2Address =
      n.getContractAddress =
      n.getIcapAddress =
      n.getAddress =
      n._TypedDataEncoder =
      n.id =
      n.isValidName =
      n.namehash =
      n.hashMessage =
      n.dnsEncode =
      n.parseBytes32String =
        void 0);
  var r = PO;
  Object.defineProperty(n, 'AbiCoder', {
    enumerable: !0,
    get: function () {
      return r.AbiCoder;
    },
  }),
    Object.defineProperty(n, 'checkResultErrors', {
      enumerable: !0,
      get: function () {
        return r.checkResultErrors;
      },
    }),
    Object.defineProperty(n, 'ConstructorFragment', {
      enumerable: !0,
      get: function () {
        return r.ConstructorFragment;
      },
    }),
    Object.defineProperty(n, 'defaultAbiCoder', {
      enumerable: !0,
      get: function () {
        return r.defaultAbiCoder;
      },
    }),
    Object.defineProperty(n, 'ErrorFragment', {
      enumerable: !0,
      get: function () {
        return r.ErrorFragment;
      },
    }),
    Object.defineProperty(n, 'EventFragment', {
      enumerable: !0,
      get: function () {
        return r.EventFragment;
      },
    }),
    Object.defineProperty(n, 'FormatTypes', {
      enumerable: !0,
      get: function () {
        return r.FormatTypes;
      },
    }),
    Object.defineProperty(n, 'Fragment', {
      enumerable: !0,
      get: function () {
        return r.Fragment;
      },
    }),
    Object.defineProperty(n, 'FunctionFragment', {
      enumerable: !0,
      get: function () {
        return r.FunctionFragment;
      },
    }),
    Object.defineProperty(n, 'Indexed', {
      enumerable: !0,
      get: function () {
        return r.Indexed;
      },
    }),
    Object.defineProperty(n, 'Interface', {
      enumerable: !0,
      get: function () {
        return r.Interface;
      },
    }),
    Object.defineProperty(n, 'LogDescription', {
      enumerable: !0,
      get: function () {
        return r.LogDescription;
      },
    }),
    Object.defineProperty(n, 'ParamType', {
      enumerable: !0,
      get: function () {
        return r.ParamType;
      },
    }),
    Object.defineProperty(n, 'TransactionDescription', {
      enumerable: !0,
      get: function () {
        return r.TransactionDescription;
      },
    });
  var s = NO;
  Object.defineProperty(n, 'getAddress', {
    enumerable: !0,
    get: function () {
      return s.getAddress;
    },
  }),
    Object.defineProperty(n, 'getCreate2Address', {
      enumerable: !0,
      get: function () {
        return s.getCreate2Address;
      },
    }),
    Object.defineProperty(n, 'getContractAddress', {
      enumerable: !0,
      get: function () {
        return s.getContractAddress;
      },
    }),
    Object.defineProperty(n, 'getIcapAddress', {
      enumerable: !0,
      get: function () {
        return s.getIcapAddress;
      },
    }),
    Object.defineProperty(n, 'isAddress', {
      enumerable: !0,
      get: function () {
        return s.isAddress;
      },
    });
  var a = i(DO);
  n.base64 = a;
  var o = BO;
  Object.defineProperty(n, 'base58', {
    enumerable: !0,
    get: function () {
      return o.Base58;
    },
  });
  var u = FO;
  Object.defineProperty(n, 'arrayify', {
    enumerable: !0,
    get: function () {
      return u.arrayify;
    },
  }),
    Object.defineProperty(n, 'concat', {
      enumerable: !0,
      get: function () {
        return u.concat;
      },
    }),
    Object.defineProperty(n, 'hexConcat', {
      enumerable: !0,
      get: function () {
        return u.hexConcat;
      },
    }),
    Object.defineProperty(n, 'hexDataSlice', {
      enumerable: !0,
      get: function () {
        return u.hexDataSlice;
      },
    }),
    Object.defineProperty(n, 'hexDataLength', {
      enumerable: !0,
      get: function () {
        return u.hexDataLength;
      },
    }),
    Object.defineProperty(n, 'hexlify', {
      enumerable: !0,
      get: function () {
        return u.hexlify;
      },
    }),
    Object.defineProperty(n, 'hexStripZeros', {
      enumerable: !0,
      get: function () {
        return u.hexStripZeros;
      },
    }),
    Object.defineProperty(n, 'hexValue', {
      enumerable: !0,
      get: function () {
        return u.hexValue;
      },
    }),
    Object.defineProperty(n, 'hexZeroPad', {
      enumerable: !0,
      get: function () {
        return u.hexZeroPad;
      },
    }),
    Object.defineProperty(n, 'isBytes', {
      enumerable: !0,
      get: function () {
        return u.isBytes;
      },
    }),
    Object.defineProperty(n, 'isBytesLike', {
      enumerable: !0,
      get: function () {
        return u.isBytesLike;
      },
    }),
    Object.defineProperty(n, 'isHexString', {
      enumerable: !0,
      get: function () {
        return u.isHexString;
      },
    }),
    Object.defineProperty(n, 'joinSignature', {
      enumerable: !0,
      get: function () {
        return u.joinSignature;
      },
    }),
    Object.defineProperty(n, 'zeroPad', {
      enumerable: !0,
      get: function () {
        return u.zeroPad;
      },
    }),
    Object.defineProperty(n, 'splitSignature', {
      enumerable: !0,
      get: function () {
        return u.splitSignature;
      },
    }),
    Object.defineProperty(n, 'stripZeros', {
      enumerable: !0,
      get: function () {
        return u.stripZeros;
      },
    });
  var l = LO;
  Object.defineProperty(n, '_TypedDataEncoder', {
    enumerable: !0,
    get: function () {
      return l._TypedDataEncoder;
    },
  }),
    Object.defineProperty(n, 'dnsEncode', {
      enumerable: !0,
      get: function () {
        return l.dnsEncode;
      },
    }),
    Object.defineProperty(n, 'hashMessage', {
      enumerable: !0,
      get: function () {
        return l.hashMessage;
      },
    }),
    Object.defineProperty(n, 'id', {
      enumerable: !0,
      get: function () {
        return l.id;
      },
    }),
    Object.defineProperty(n, 'isValidName', {
      enumerable: !0,
      get: function () {
        return l.isValidName;
      },
    }),
    Object.defineProperty(n, 'namehash', {
      enumerable: !0,
      get: function () {
        return l.namehash;
      },
    });
  var c = $O;
  Object.defineProperty(n, 'defaultPath', {
    enumerable: !0,
    get: function () {
      return c.defaultPath;
    },
  }),
    Object.defineProperty(n, 'entropyToMnemonic', {
      enumerable: !0,
      get: function () {
        return c.entropyToMnemonic;
      },
    }),
    Object.defineProperty(n, 'getAccountPath', {
      enumerable: !0,
      get: function () {
        return c.getAccountPath;
      },
    }),
    Object.defineProperty(n, 'HDNode', {
      enumerable: !0,
      get: function () {
        return c.HDNode;
      },
    }),
    Object.defineProperty(n, 'isValidMnemonic', {
      enumerable: !0,
      get: function () {
        return c.isValidMnemonic;
      },
    }),
    Object.defineProperty(n, 'mnemonicToEntropy', {
      enumerable: !0,
      get: function () {
        return c.mnemonicToEntropy;
      },
    }),
    Object.defineProperty(n, 'mnemonicToSeed', {
      enumerable: !0,
      get: function () {
        return c.mnemonicToSeed;
      },
    });
  var f = UO;
  Object.defineProperty(n, 'getJsonWalletAddress', {
    enumerable: !0,
    get: function () {
      return f.getJsonWalletAddress;
    },
  });
  var m = jO;
  Object.defineProperty(n, 'keccak256', {
    enumerable: !0,
    get: function () {
      return m.keccak256;
    },
  });
  var w = VO;
  Object.defineProperty(n, 'Logger', {
    enumerable: !0,
    get: function () {
      return w.Logger;
    },
  });
  var v = yv;
  Object.defineProperty(n, 'computeHmac', {
    enumerable: !0,
    get: function () {
      return v.computeHmac;
    },
  }),
    Object.defineProperty(n, 'ripemd160', {
      enumerable: !0,
      get: function () {
        return v.ripemd160;
      },
    }),
    Object.defineProperty(n, 'sha256', {
      enumerable: !0,
      get: function () {
        return v.sha256;
      },
    }),
    Object.defineProperty(n, 'sha512', {
      enumerable: !0,
      get: function () {
        return v.sha512;
      },
    });
  var T = zO;
  Object.defineProperty(n, 'solidityKeccak256', {
    enumerable: !0,
    get: function () {
      return T.keccak256;
    },
  }),
    Object.defineProperty(n, 'solidityPack', {
      enumerable: !0,
      get: function () {
        return T.pack;
      },
    }),
    Object.defineProperty(n, 'soliditySha256', {
      enumerable: !0,
      get: function () {
        return T.sha256;
      },
    });
  var A = GO;
  Object.defineProperty(n, 'randomBytes', {
    enumerable: !0,
    get: function () {
      return A.randomBytes;
    },
  }),
    Object.defineProperty(n, 'shuffled', {
      enumerable: !0,
      get: function () {
        return A.shuffled;
      },
    });
  var _ = qO;
  Object.defineProperty(n, 'checkProperties', {
    enumerable: !0,
    get: function () {
      return _.checkProperties;
    },
  }),
    Object.defineProperty(n, 'deepCopy', {
      enumerable: !0,
      get: function () {
        return _.deepCopy;
      },
    }),
    Object.defineProperty(n, 'defineReadOnly', {
      enumerable: !0,
      get: function () {
        return _.defineReadOnly;
      },
    }),
    Object.defineProperty(n, 'getStatic', {
      enumerable: !0,
      get: function () {
        return _.getStatic;
      },
    }),
    Object.defineProperty(n, 'resolveProperties', {
      enumerable: !0,
      get: function () {
        return _.resolveProperties;
      },
    }),
    Object.defineProperty(n, 'shallowCopy', {
      enumerable: !0,
      get: function () {
        return _.shallowCopy;
      },
    });
  var O = i(HO);
  n.RLP = O;
  var B = KO;
  Object.defineProperty(n, 'computePublicKey', {
    enumerable: !0,
    get: function () {
      return B.computePublicKey;
    },
  }),
    Object.defineProperty(n, 'recoverPublicKey', {
      enumerable: !0,
      get: function () {
        return B.recoverPublicKey;
      },
    }),
    Object.defineProperty(n, 'SigningKey', {
      enumerable: !0,
      get: function () {
        return B.SigningKey;
      },
    });
  var P = hv;
  Object.defineProperty(n, 'formatBytes32String', {
    enumerable: !0,
    get: function () {
      return P.formatBytes32String;
    },
  }),
    Object.defineProperty(n, 'nameprep', {
      enumerable: !0,
      get: function () {
        return P.nameprep;
      },
    }),
    Object.defineProperty(n, 'parseBytes32String', {
      enumerable: !0,
      get: function () {
        return P.parseBytes32String;
      },
    }),
    Object.defineProperty(n, '_toEscapedUtf8String', {
      enumerable: !0,
      get: function () {
        return P._toEscapedUtf8String;
      },
    }),
    Object.defineProperty(n, 'toUtf8Bytes', {
      enumerable: !0,
      get: function () {
        return P.toUtf8Bytes;
      },
    }),
    Object.defineProperty(n, 'toUtf8CodePoints', {
      enumerable: !0,
      get: function () {
        return P.toUtf8CodePoints;
      },
    }),
    Object.defineProperty(n, 'toUtf8String', {
      enumerable: !0,
      get: function () {
        return P.toUtf8String;
      },
    }),
    Object.defineProperty(n, 'Utf8ErrorFuncs', {
      enumerable: !0,
      get: function () {
        return P.Utf8ErrorFuncs;
      },
    });
  var N = WO;
  Object.defineProperty(n, 'accessListify', {
    enumerable: !0,
    get: function () {
      return N.accessListify;
    },
  }),
    Object.defineProperty(n, 'computeAddress', {
      enumerable: !0,
      get: function () {
        return N.computeAddress;
      },
    }),
    Object.defineProperty(n, 'parseTransaction', {
      enumerable: !0,
      get: function () {
        return N.parse;
      },
    }),
    Object.defineProperty(n, 'recoverAddress', {
      enumerable: !0,
      get: function () {
        return N.recoverAddress;
      },
    }),
    Object.defineProperty(n, 'serializeTransaction', {
      enumerable: !0,
      get: function () {
        return N.serialize;
      },
    }),
    Object.defineProperty(n, 'TransactionTypes', {
      enumerable: !0,
      get: function () {
        return N.TransactionTypes;
      },
    });
  var U = JO;
  Object.defineProperty(n, 'commify', {
    enumerable: !0,
    get: function () {
      return U.commify;
    },
  }),
    Object.defineProperty(n, 'formatEther', {
      enumerable: !0,
      get: function () {
        return U.formatEther;
      },
    }),
    Object.defineProperty(n, 'parseEther', {
      enumerable: !0,
      get: function () {
        return U.parseEther;
      },
    }),
    Object.defineProperty(n, 'formatUnits', {
      enumerable: !0,
      get: function () {
        return U.formatUnits;
      },
    }),
    Object.defineProperty(n, 'parseUnits', {
      enumerable: !0,
      get: function () {
        return U.parseUnits;
      },
    });
  var W = QO;
  Object.defineProperty(n, 'verifyMessage', {
    enumerable: !0,
    get: function () {
      return W.verifyMessage;
    },
  }),
    Object.defineProperty(n, 'verifyTypedData', {
      enumerable: !0,
      get: function () {
        return W.verifyTypedData;
      },
    });
  var z = YO;
  Object.defineProperty(n, '_fetchData', {
    enumerable: !0,
    get: function () {
      return z._fetchData;
    },
  }),
    Object.defineProperty(n, 'fetchJson', {
      enumerable: !0,
      get: function () {
        return z.fetchJson;
      },
    }),
    Object.defineProperty(n, 'poll', {
      enumerable: !0,
      get: function () {
        return z.poll;
      },
    });
  var Y = yv;
  Object.defineProperty(n, 'SupportedAlgorithm', {
    enumerable: !0,
    get: function () {
      return Y.SupportedAlgorithm;
    },
  });
  var ue = hv;
  Object.defineProperty(n, 'UnicodeNormalizationForm', {
    enumerable: !0,
    get: function () {
      return ue.UnicodeNormalizationForm;
    },
  }),
    Object.defineProperty(n, 'Utf8ErrorReason', {
      enumerable: !0,
      get: function () {
        return ue.Utf8ErrorReason;
      },
    });
})(q0);
function XO(n, e) {
  if (typeof n != 'number' || Number.isInteger(n) || isNaN(n)) return n;
  const t = n.toString().split('.');
  return +`${t[0]}.${t[1].slice(0, e)}`;
}
function hw(n) {
  switch (n) {
    case Ri['1d']:
      return 'hour';
    case Ri['1h']:
      return 'minute';
    case Ri['1m']:
    case Ri['1w']:
    case Ri['1y']:
      return 'day';
  }
}
function mw(n) {
  const e = /* @__PURE__ */ new Date();
  switch (n) {
    case Ri['1h']:
      e.setMinutes(e.getMinutes() - 60);
      break;
    case Ri['1d']:
      e.setHours(e.getHours() - 24);
      break;
    case Ri['1w']:
      e.setDate(e.getDate() - 7);
      break;
    case Ri['1m']:
      e.setMonth(e.getMonth() - 1);
      break;
    case Ri['1y']:
      e.setFullYear(e.getFullYear() - 1);
      break;
  }
  return e.getTime();
}
const ZO = (n, e) => {
    for (const t in e) {
      const i = new RegExp('{' + t + '}', 'gm');
      n = n.replace(i, e[t]);
    }
    return n;
  },
  mv = (n, e) => {
    const t = typeof n;
    return (t === 'string' || t === 'number') && (n = XO(Number(n), Number(e))), q0.parseUnits(n.toString(), e);
  },
  Ve = (n, e) => q0.formatUnits(n.toString(), e),
  H0 = be.createInterface();
function ek({ mustBeMetaMask: n = !1, silent: e = !1, timeout: t = 3e3 } = {}) {
  r();
  let i = !1;
  return new Promise((s) => {
    window.ethereum
      ? a()
      : (window.addEventListener('ethereum#initialized', a, { once: !0 }),
        setTimeout(() => {
          a();
        }, t));
    function a() {
      if (i) return;
      (i = !0), window.removeEventListener('ethereum#initialized', a);
      const { ethereum: o } = window;
      o && (!n || o.isMetaMask) ? s(o) : (!e && console.error('@metamask/detect-provider:', n && o ? 'Non-MetaMask window.ethereum detected.' : 'Unable to detect window.ethereum.'), s(null));
    }
  });
  function r() {
    if (typeof n != 'boolean') throw new Error("@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.");
    if (typeof e != 'boolean') throw new Error("@metamask/detect-provider: Expected option 'silent' to be a boolean.");
    if (typeof t != 'number') throw new Error("@metamask/detect-provider: Expected option 'timeout' to be a number.");
  }
}
var tk = ek,
  nk = Object.defineProperty,
  ik = Object.getOwnPropertyDescriptor,
  rk = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? ik(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && nk(e, t, r), r;
  },
  au = (n, e) => (t, i) => e(t, i, n);
const bw = be.createInterface('EthereumService');
let ol = class {
  constructor(n, e, t, i, r) {
    (this.eventAggregator = n), (this.logger = e), (this.configuration = t), (this.readOnlyProvider = i), (this.walletConnector = r), (this.logger = e.scopeTo('EthereumService'));
  }
  static register(n) {
    me.singleton(bw, ol).register(n);
  }
  get targetedChainId() {
    return this.configuration.chainId;
  }
  lastBlock;
  async connect(n) {
    return n ? await this.walletConnector.connectTo(n) : await this.walletConnector.connect();
  }
  async getMetaMaskProvider() {
    const n = await tk({ mustBeMetaMask: !0 });
    if (!n) return null;
    if ((await n._metamask.isUnlocked()) && (await n.request({ method: 'eth_accounts' })).length) return n;
  }
  async getAccountsForProvider(n) {
    return Fa.isSigner(n) ? [await n.getAddress()] : await n.listAccounts();
  }
  /**
   *
   * @param web3ModalProvider should be a Web3Provider
   * @returns
   */
  async switchToTargetedNetwork(n) {
    try {
      return (
        await n.provider.request?.({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: `0x${this.targetedChainId.toString(16)}` }],
        }),
        n.provider
      );
    } catch (e) {
      if (e.code !== 4902) return;
      throw new Error(`The ${this.configuration.chain} network is not installed in your Metamask configuration`);
    }
  }
  async addTokenToMetamask(n, e, t, i, r) {
    try {
      await n.request({
        method: 'wallet_watchAsset',
        params: {
          type: 'ERC20',
          // Initially only supports ERC20, but eventually more!
          options: {
            address: e,
            // The address that the token is at.
            symbol: t,
            // A ticker symbol or shorthand, up to 5 chars.
            decimals: i,
            // The number of decimals in the token
            image: r,
            // A string url of the token logo
          },
        },
      });
    } catch (s) {
      this.logger.error(s);
    }
  }
  async getBlock(n) {
    const e = await this.readOnlyProvider.getBlock(n);
    return (e.blockDate = new Date(e.timestamp * 1e3)), e;
  }
  getEtherscanLink(n, e = !1) {
    return ZO(this.configuration.scanLink, { type: e ? 'tx' : 'address', address: n });
  }
};
ol = rk([au(0, zc), au(1, _a), au(2, Ms), au(3, hp), au(4, H0)], ol);
var sk = Object.defineProperty,
  ak = Object.getOwnPropertyDescriptor,
  ok = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? ak(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && sk(e, t, r), r;
  },
  uk = (n, e) => (t, i) => e(t, i, n);
const gw = be.createInterface('HttpService'),
  vw = { accept: 'application/json' },
  lk = { 'content-type': 'application/json', ...vw };
let Ac = class {
  constructor(n) {
    (this.logger = n), (this.logger = n.scopeTo('HttpService'));
  }
  static register(n) {
    n.register(me.singleton(gw, Ac));
  }
  async call(n, e, t) {
    const i = await fetch(n, {
      body: e,
      method: e ? 'POST' : 'GET',
      headers: e ? lk : vw,
      ...t,
    });
    if (i.ok) return await i.json();
    const r = new Error(await i.text());
    return this.logger.error({ response: i, error: r }), Promise.reject(r);
  }
};
Ac = ok([uk(0, _a)], Ac);
var dk = Object.defineProperty,
  ck = Object.getOwnPropertyDescriptor,
  pk = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? ck(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && dk(e, t, r), r;
  },
  bv = (n, e) => (t, i) => e(t, i, n);
const xw = be.createInterface('ObserverService');
let Ec = class {
  constructor(n, e) {
    (this.locator = n), (this.cacheService = e);
  }
  static register(n) {
    n.register(me.singleton(xw, Ec));
  }
  /**
   * Make a object property observable and subscribe to changes in its value.
   * Viewmodels should use @watch.
   * @param obj object having the property to observe
   * @param property property to observe
   * @param method ISubscriber, handles changes in the property's values
   * @returns method to unsubscribe.  Singletons, such as services, don't need to call this.
   */
  // @cache<ObserverService>(function () {
  //   return { storage: this.cacheService };
  // })
  listen(n, e, t) {
    const i = this.locator.getObserver(n, e),
      r = {
        handleChange: t,
      };
    return i.subscribe(r), () => i.unsubscribe(r);
  }
};
Ec = pk([bv(0, Ra), bv(1, Ll)], Ec);
var fk = Object.defineProperty,
  yk = Object.getOwnPropertyDescriptor,
  hk = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? yk(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && fk(e, t, r), r;
  },
  mk = (n, e) => (t, i) => e(t, i, n);
const Tw = be.createInterface('TimingService');
let Sc = class {
  constructor(n) {
    this.config = n;
  }
  static register(n) {
    me.singleton(Tw, Sc).register(n);
  }
  startTimer(n) {
    this.config.isDevelopment && console.time(n);
  }
  endTimer(n) {
    this.config.isDevelopment && console.timeEnd(n);
  }
};
Sc = hk([mk(0, Ms)], Sc);
var bk = Object.defineProperty,
  gk = Object.getOwnPropertyDescriptor,
  vk = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? gk(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && bk(e, t, r), r;
  },
  Wn = (n, e) => (t, i) => e(t, i, n);
const xk = be.createInterface();
let qy = class {
  constructor(n, e, t, i, r, s, a, o, u, l, c, f, m) {
    (this.httpService = n),
      (this.numberService = e),
      (this.ethereumService = t),
      (this.browserStorageService = i),
      (this.timingService = r),
      (this.cacheService = s),
      (this.observerService = a),
      (this.encryptionService = o),
      (this.contractService = u),
      (this.tokenService = l),
      (this.ipfsService = c),
      (this.symmetricService = f),
      (this.configuration = m);
  }
  static register(n) {
    n.register(me.singleton(xk, qy))
      .register(Ec)
      .register(Sc)
      .register(yp)
      .register(sl)
      .register(Ac)
      .register(al)
      .register(ol)
      .register(wc)
      .register(G0)
      .register(Tc)
      .register(Mo)
      .register(nl)
      .register(_o);
  }
};
qy = vk([Wn(0, gw), Wn(1, $l), Wn(2, bw), Wn(3, z0), Wn(4, Tw), Wn(5, Ll), Wn(6, xw), Wn(7, yw), Wn(8, Wo), Wn(9, j0), Wn(10, V0), Wn(11, B0), Wn(12, Ms)], qy);
be.createInterface('DateServiceIntl');
var Tk = Object.defineProperty,
  wk = Object.getOwnPropertyDescriptor,
  Ak = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? wk(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && Tk(e, t, r), r;
  };
let gv = class {
  disposables;
  constructor() {
    this.disposables = new Array();
  }
  push(n) {
    return this.disposables.push(n);
  }
  dispose(n) {
    if (n) this._dispose(n);
    else {
      for (n of this.disposables) n.dispose();
      this.disposables.length = 0;
    }
  }
  _dispose(n) {
    n.dispose(), this.disposables.splice(this.disposables.indexOf(n), 1);
  }
};
gv = Ak([wx()], gv);
var Ek = Object.defineProperty,
  Sk = Object.getOwnPropertyDescriptor,
  Ck = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? Sk(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && Ek(e, t, r), r;
  },
  Mk = (n, e) => (t, i) => e(t, i, n);
const _k = be.createInterface('TransactionsService');
let Cc = class {
  constructor(n) {
    this.eventAggregator = n;
  }
  static blocksToConfirm = 1;
  static register(n) {
    me.singleton(_k, Cc).register(n);
  }
  async send(n) {
    let e;
    try {
      this.eventAggregator.publish('transaction.sending');
      const t = await n();
      return (
        this.eventAggregator.publish('transaction.sent', t),
        (e = await t.wait(1)),
        this.eventAggregator.publish('transaction.mined', { message: 'Transaction was mined', receipt: e }),
        (e = await t.wait(Cc.blocksToConfirm)),
        this.eventAggregator.publish('transaction.confirmed', { message: 'Transaction was confirmed', receipt: e }),
        e
      );
    } catch (t) {
      return this.eventAggregator.publish('transaction.failed', t), null;
    }
  }
};
Cc = Ck([Mk(0, zc)], Cc);
var Rk = Object.defineProperty,
  Ik = Object.getOwnPropertyDescriptor,
  Ok = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? Ik(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && Rk(e, t, r), r;
  },
  ou = (n, e) => (t, i) => e(t, i, n);
const K0 = be.createInterface('IContractStore');
let Mc = class {
  constructor(n, e, t, i, r) {
    (this.contractService = n), (this.tokenService = e), (this.logger = t), (this.numberService = i), (this.tokenInfo = r);
  }
  static register(n) {
    n.register(me.singleton(K0, Mc));
  }
  async getAsset(n, e, t, i, r, s) {
    let a;
    e && (a = Number(e));
    const u = (await this.tokenInfo.tokens).find((A) => A.address === n && A.id == a);
    if (!u) {
      this.logger.error(`No token info was found for ${n}`);
      return;
    }
    const l = await this.tokenService.getTokenContract(n, u.id);
    if ((s || (u.id ? (s = await t.oraclePerERC721Id(n, u.id)) : (s = await t.oraclePerERC20(n))), !s || q.from(s).isZero())) return;
    const f = await (await this.contractService.getContract('monetary', 'Oracle', s)).getData();
    if (!f[1]) return;
    u.price = this.numberService.fromString(Ve(f[0], 18));
    let m = mv(1, 18),
      w;
    u.id || ((w = await l.totalSupply()), (m = await l.balanceOf(i)));
    let v;
    u.id ? (v = Iu.Low) : (v = await t.assetTypeOfERC20(n)), r && this.populateTransactionsForAsset(r, l, i, u);
    const T = {
      quantity: m,
      token: u,
      total: 0,
      type: v,
      totalSupply: w,
    };
    return (T.total = u.id ? u.price : this.numberService.fromString(Ve(T.quantity, 18)) * u.price), T;
  }
  async populateTransactionsForAsset(n, e, t, i) {
    const r = await e.queryFilter(e.filters.Transfer(void 0, t)),
      s = await this.mapTransactions(r, 'deposit', i);
    n.push(...s);
    const a = await e.queryFilter(e.filters.Transfer(t)),
      o = await this.mapTransactions(a, 'withdrawl', i);
    n.push(...o);
  }
  async mapTransactions(n, e, t) {
    return await Promise.all(
      n.map(async (i) => {
        const r = await i.getBlock();
        return {
          address: e === 'deposit' ? i.args.from : i.args.to,
          amount: 'amount' in i.args ? i.args.amount : mv(1, 18),
          date: r.timestamp,
          id: i.transactionHash,
          token: t,
          type: e,
        };
      }),
    );
  }
};
Mc = Ok([ou(0, Wo), ou(1, j0), ou(2, _a), ou(3, $l), ou(4, cw)], Mc);
var kk = Object.defineProperty,
  Pk = Object.getOwnPropertyDescriptor,
  Nk = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? Pk(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && kk(e, t, r), r;
  },
  Dk = (n, e) => (t, i) => e(t, i, n);
const W0 = be.createInterface('DataStore');
let _c = class {
  constructor(n) {
    this.firebaseService = n;
  }
  static register(n) {
    n.register(me.singleton(W0, _c));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async getDocs(...n) {
    return this.firebaseService.getDocs(...n);
  }
};
_c = Nk([Dk(0, U0)], _c);
function mp(n = '') {
  const e = /* @__PURE__ */ new WeakMap();
  return function (t, i, r) {
    const s = t[i];
    if (typeof s != 'function') throw new Error(`ER: @callOnce: > ${String(i)}`);
    r.value = function (...a) {
      if (e.has(this)) return e.get(this);
      const o = s.apply(this, a);
      return e.set(this, o), o;
    };
  };
}
var Bk = Object.defineProperty,
  Fk = Object.getOwnPropertyDescriptor,
  bp = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? Fk(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && Bk(e, t, r), r;
  },
  Ka = (n, e) => (t, i) => e(t, i, n);
const ww = be.createInterface('ReserveStore');
let Ta = class {
  constructor(n, e, t, i, r, s) {
    (this.contractStore = n), (this.contractService = e), (this.numberService = t), (this.symmetricService = i), (this.configuration = r), (this.dataStore = s);
  }
  reserveValue;
  kCurMarketCap;
  backing;
  kCurPrice;
  kCurSupply;
  transactions = [];
  reserveAssets = [];
  kCurReserveDistribution;
  kCurMentoDistribution;
  kCurPrimaryPoolDistribution;
  kCurPriceCeiling;
  minBacking;
  kGuilderCurrentPrice;
  kGuilderTotalSupply;
  kGuilderSpread;
  kGuilderInflationRate;
  kGuilderTobinTax;
  kGuilderPriceParity;
  kGuilderValueRatio;
  primaryPoolData;
  static register(n) {
    n.register(me.singleton(ww, Ta));
  }
  get kCurCirculatingDistribution() {
    return 1 - ((this.kCurReserveDistribution ?? 0) + (this.kCurMentoDistribution ?? 0) + (this.kCurPrimaryPoolDistribution ?? 0));
  }
  get currentCollateralizationRatio() {
    return this.numberService.fromString(Ve(this.backing ?? 0, 2));
  }
  get currentLeverageRatio() {
    return this.backing ? this.calculateLeverage(this.backing) : 0;
  }
  get maxLeverageRatio() {
    return (1 / this.numberService.fromString(Ve(this.minBacking ?? 0, 4))) * 100;
  }
  get minCollateralizationRatio() {
    return this.numberService.fromString(Ve(this.minBacking ?? 0, 4));
  }
  get minCollateralizationValue() {
    return this.kCurMarketCap ? this.minCollateralizationRatio * this.numberService.fromString(Ve(this.kCurMarketCap, 18)) : 0;
  }
  get maxLeverageMultiplier() {
    return `${Math.round((this.maxLeverageRatio / 100) * 100) / 100}x`;
  }
  get kCurTotalValue() {
    return this.numberService.fromString(Ve(this.kCurMarketCap ?? 0, 18));
  }
  get kGuilderMarketCap() {
    return this.kGuilderCurrentPrice ? this.kGuilderCurrentPrice * this.numberService.fromString(Ve(this.kGuilderTotalSupply ?? 0, 18)) : 0;
  }
  get kCurPriceFloor() {
    return !this.reserveValue || !this.kCurSupply ? 0 : this.numberService.fromString(Ve(this.reserveValue, 18)) / this.numberService.fromString(Ve(this.kCurSupply, 18));
  }
  async loadAssets() {
    const n = await this.getReserveContract(),
      e = n.address;
    if (!e) return;
    const t = (
      await Promise.all([
        n.allRegisteredERC20s().then((r) => r.map((s) => ({ tokenId: void 0, address: s }))),
        n.allRegisteredERC721Ids().then((r) => r.map((s) => ({ tokenId: s.id, address: s.erc721 }))),
      ])
    ).flatMap((r) => r);
    (this.reserveAssets = (await Promise.all(t.map((r) => this.contractStore.getAsset(r.address, r.tokenId, n, e, this.transactions).catch()))).filter(Boolean)),
      (this.reserveAssets = await Promise.all(this.reserveAssets.map(async (r) => ({ ...r, type: await n.riskLevelOfERC20(r.token.address) })))),
      this.loadkCurData();
    const i = await n.reserveStatus();
    (this.reserveValue = i[0]), (this.kCurMarketCap = i[1]), (this.backing = i[2]), (this.minBacking = await n.minBacking());
  }
  async loadkCur() {
    if ((await this.loadAssets(), !this.kCurSupply)) return;
    const n = this.numberService.fromString(Ve(this.kCurSupply, 18)),
      e = await this.contractService.getContract('monetary', 'CuracaoReserveToken'),
      t = await this.contractService.getContract('monetary', 'KolektivoMultiSig'),
      i = await e.balanceOf(t.address);
    this.kCurReserveDistribution = this.numberService.fromString(Ve(i, 18)) / n;
    const r = await this.contractService.getContract('monetary', 'ProxyPool'),
      s = this.numberService.fromString(Ve(await r.ceilingMultiplier(), 4));
    this.kCurPriceCeiling = this.kCurPriceFloor * s;
    const a = await this.contractService.getContract('monetary', 'MentoReserve'),
      o = await e.balanceOf(a.address);
    (this.kCurMentoDistribution = this.numberService.fromString(Ve(o, 18)) / n), (this.kCurPrimaryPoolDistribution = 0);
  }
  async loadkGuilder() {
    if ((await this.loadkCurData(), (this.kGuilderCurrentPrice = 0.558), !(await this.getReserveContract()).address)) return;
    const t = await this.contractService.getContract('monetary', 'KolektivoGuilder'),
      i = await t.totalSupply(),
      r = await this.contractService.getContract('monetary', 'Exchange'),
      s = await r.spread(),
      o = await (await this.contractService.getContract('monetary', 'MentoReserve')).tobinTax(),
      [u, l] = await r.getBuyAndSellBuckets(!0),
      c = ((this.kCurPrice ?? 0) * this.numberService.fromString(Ve(l, 18))) / (this.kGuilderCurrentPrice * this.numberService.fromString(Ve(u, 18))),
      [f] = await t.getInflationParameters();
    (this.kGuilderValueRatio = c),
      (this.kGuilderTotalSupply = i),
      (this.kGuilderSpread = this.numberService.fromString(Ve(s, 25))),
      (this.kGuilderInflationRate = this.numberService.fromString(Ve(f, 25))),
      (this.kGuilderTobinTax = this.numberService.fromString(Ve(o, 18))),
      (this.kGuilderPriceParity = 0);
  }
  async loadkCurData() {
    if (this.kCurPrice || this.kCurSupply) return;
    const n = await this.getReserveContract(),
      e = await n.token();
    if (!e) return;
    const t = n.address;
    if (!t) return;
    const i = await n.tokenOracle();
    if (!i) return;
    const r = await this.contractStore.getAsset(e, void 0, n, t, void 0, i);
    (this.kCurPrice = r?.token.price), (this.kCurSupply = r?.totalSupply);
  }
  getReserveContract() {
    return this.contractService.getContract('monetary', 'Reserve');
  }
  async getReserveValueOverTime(n) {
    const [e, t] = await Promise.all([this.getData('reserve', n), this.getReserveContract().then((i) => i.reserveStatus())]);
    return (
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        value: t[0],
      }),
      e
    );
  }
  async getkGuilderValueRatioOverTime(n) {
    const [e] = await Promise.all([this.getData('kGuilder', n), this.loadkCurData(), this.loadkGuilder()]);
    return (
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        value: this.kGuilderValueRatio,
      }),
      e
    );
  }
  async getLeverageRatioValueOverTime(n) {
    const [e, [t, i]] = await Promise.all([this.getData('kCurRatio', n), this.getReserveContract().then((r) => Promise.all([r.reserveStatus(), r.minBacking()]))]);
    return (
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        currentLeverageRatio: this.calculateLeverage(t[2]),
        maxLeverageRatio: (1 / (this.numberService.fromString(Ve(i, 2)) / 100)) * 100,
      }),
      e
    );
  }
  async getkCurSupplyData(n) {
    const [e] = await Promise.all([this.getData('kCurSupply', n), this.loadkCur()]);
    return (
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        kCurCirculatingDistribution: this.kCurCirculatingDistribution,
        kCurMentoDistribution: this.kCurMentoDistribution,
        kCurPrimaryPoolDistribution: this.kCurPrimaryPoolDistribution,
        kCurReserveDistribution: this.kCurReserveDistribution,
      }),
      e
    );
  }
  async loadPrimaryPoolData() {
    const n = await this.symmetricService.indexVolumeAndFees();
    this.primaryPoolData = [
      {
        tokens: [
          { symbol: 'kCUR', icon: 'https://assets.website-files.com/5fcaa3a6fcb269f7778d1f87/60a957ee7011916564689917_LOGO_MARK_color.svg' },
          { symbol: 'cUSD', icon: 'https://assets.coingecko.com/coins/images/6319/thumb/USD_Coin_icon.png?1547042389' },
        ],
        fees: Number(n.swapFeeParsed),
        tvl: Number(n.tvl),
        volume: Number(n.volumeParsed),
      },
    ];
  }
  async getkCurPriceOverTime(n) {
    const [e] = await Promise.all([this.getData('kCurPrice', n), this.loadkCurData(), this.loadAssets(), this.loadkCur()]);
    return (
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        kCurPrice: this.kCurPrice,
        kCurPriceCeiling: this.kCurPriceCeiling,
        kCurPriceFloor: this.kCurPriceFloor,
      }),
      e
    );
  }
  get lowRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === Iu.Low) ?? [];
  }
  get moderateRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === Iu.Medium) ?? [];
  }
  get highRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === Iu.High) ?? [];
  }
  async getRiskOverTime(n) {
    const [e, [t, i]] = await Promise.all([this.getData('risk', n), this.getReserveContract().then((r) => Promise.all([r.reserveStatus(), r.minBacking()])), this.loadAssets()]);
    return (
      (this.kCurMarketCap = t[1]),
      (this.minBacking = i),
      e.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        minCollateralValue: this.minCollateralizationValue,
        marketCap: (this.kCurPrice ?? 0) * this.numberService.fromString(Ve(this.kCurSupply ?? 0, 18)),
        lowRisk: this.lowRiskAssets.map((r) => r.total).sum(),
        moderateRisk: this.moderateRiskAssets.map((r) => r.total).sum(),
        highRisk: this.highRiskAssets.map((r) => r.total).sum(),
      }),
      e
    );
  }
  async getData(n, e) {
    const t = mw(e),
      i = await this.dataStore.getDocs(`${this.configuration.firebaseCollection}/${n}/${hw(e)}`, 'createdAt', 'desc', {
        fieldPath: 'createdAt',
        opStr: '>=',
        value: t,
      });
    return i.sort((r, s) => new Date(r.createdAt).getTime() - new Date(s.createdAt).getTime()), i;
  }
  calculateLeverage(n) {
    return (1 / this.numberService.fromString(Ve(n, 4))) * 100;
  }
};
bp([mp()], Ta.prototype, 'loadAssets', 1);
bp([mp()], Ta.prototype, 'loadkCur', 1);
bp([mp()], Ta.prototype, 'loadkGuilder', 1);
Ta = bp([Ka(0, K0), Ka(1, Wo), Ka(2, $l), Ka(3, B0), Ka(4, Ms), Ka(5, W0)], Ta);
var Lk = Object.defineProperty,
  $k = Object.getOwnPropertyDescriptor,
  Aw = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? $k(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && Lk(e, t, r), r;
  },
  uu = (n, e) => (t, i) => e(t, i, n);
const Ew = be.createInterface('TreasuryStore');
let ul = class {
  constructor(n, e, t, i, r) {
    (this.numberService = n), (this.contractStore = e), (this.contractService = t), (this.configuration = i), (this.dataStore = r);
  }
  totalSupply;
  totalValuation;
  treasuryDistribution;
  reservesDistribution;
  treasuryContract;
  lastRebaseTime;
  treasuryAssets = [];
  transactions = [];
  static register(n) {
    n.register(me.singleton(Ew, ul));
  }
  get treasuryValue() {
    return this.treasuryAssets?.length === 0 ? 0 : this.treasuryAssets?.map((n) => n?.total ?? 0).sum() ?? 0;
  }
  async loadTokenData() {
    if (this.totalValuation && this.totalSupply) return;
    const n = await this.getTreasuryContract();
    (this.totalValuation = await n.totalValuation()),
      (this.totalSupply = await n.totalSupply()),
      (this.treasuryDistribution = (await this.getDistributionPercentage('Treasury')).toNumber()),
      (this.reservesDistribution = (await this.getDistributionPercentage('Reserve')).toNumber());
  }
  async loadAssets() {
    const n = await this.getTreasuryContract(),
      e = n.address;
    if (!e) return;
    const t = (
      await Promise.all([
        n.allRegisteredERC20s().then((i) => i.map((r) => ({ tokenId: void 0, address: r }))),
        n.allRegisteredERC721Ids().then((i) => i.map((r) => ({ tokenId: r.id, address: r.erc721 }))),
      ])
    ).flatMap((i) => i);
    this.treasuryAssets = (await Promise.all(t.map((i) => this.contractStore.getAsset(i.address, i.tokenId, n, e, this.transactions).catch()))).filter(Boolean);
  }
  async getValueOverTime(n) {
    const e = mw(n),
      i = (
        await this.dataStore.getDocs(`${this.configuration.firebaseCollection}/ktt/${hw(n)}`, 'createdAt', 'desc', {
          fieldPath: 'createdAt',
          opStr: '>=',
          value: e,
        })
      ).map((a) => ({
        createdAt: Number(new Date(a.createdAt)),
        value: this.numberService.fromString(Ve(a.value, 18)),
      }));
    i.sort((a, o) => new Date(a.createdAt).getTime() - new Date(o.createdAt).getTime());
    const s = await (await this.getTreasuryContract()).totalValuation();
    return (
      i.push({
        createdAt: Number(/* @__PURE__ */ new Date()),
        value: this.numberService.fromString(Ve(s, 18)),
      }),
      i
    );
  }
  async getLastRebaseTime() {
    const n = await this.getTreasuryContract(),
      e = await n.queryFilter(n.filters.Rebase());
    e.sort((t, i) => i.blockNumber - t.blockNumber), (this.lastRebaseTime = e[0] && new Date((await e[0].getBlock()).timestamp * 1e3));
  }
  get circulatingDistribution() {
    return this.treasuryDistribution == null || this.reservesDistribution == null ? 0 : 1 - (this.treasuryDistribution + this.reservesDistribution);
  }
  get currentPrice() {
    return !this.totalSupply || !this.totalValuation ? 0 : Number(Ve(this.totalSupply, 18)) / Number(Ve(this.totalValuation, 18));
  }
  async getTreasuryContract() {
    return this.treasuryContract ? this.treasuryContract : ((this.treasuryContract = await this.contractService.getContract('monetary', 'Treasury')), this.treasuryContract);
  }
  async getDistributionPercentage(n) {
    const e = (await this.contractService.getContract('monetary', n)).address;
    return !e || !this.totalSupply ? q.from(0) : (await (await this.getTreasuryContract()).balanceOf(e)).div(this.totalSupply);
  }
};
Aw([mp()], ul.prototype, 'loadAssets', 1);
ul = Aw([uu(0, $l), uu(1, K0), uu(2, Wo), uu(3, Ms), uu(4, W0)], ul);
var Uk = Object.defineProperty,
  jk = Object.getOwnPropertyDescriptor,
  Vk = (n, e, t, i) => {
    for (var r = i > 1 ? void 0 : i ? jk(e, t) : e, s = n.length - 1, a; s >= 0; s--) (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
    return i && r && Uk(e, t, r), r;
  },
  zk = (n, e) => (t, i) => e(t, i, n);
const Gk = be.createInterface();
let vv = class {
  constructor(n) {
    this.walletConnector = n;
  }
  provider;
  async connect(n) {
    this.provider = n ? await this.walletConnector.connectTo(n) : await this.walletConnector.connect();
  }
};
vv = Vk([zk(0, H0)], vv);
const qk = new D('CeloNetworks'),
  xv = [
    {
      name: 'celo',
      chainId: 42220,
    },
    {
      name: 'alfajores',
      chainId: 44787,
    },
    {
      name: 'baklava',
      chainId: 62320,
    },
  ];
function Hy(n) {
  {
    if (n == null) return null;
    if (typeof n == 'number') {
      const e = xv.filter((t) => t.chainId === n);
      return e.length
        ? { name: e[0].name, chainId: e[0].chainId }
        : {
            name: 'unknown',
            chainId: n,
          };
    }
    if (typeof n == 'string') {
      const e = xv.filter((t) => t.name === n);
      return e.length ? { name: e[0].name, chainId: e[0].chainId } : null;
    }
    if (typeof n.name == 'string' && typeof n.chainId == 'number') {
      const e = Hy(n.name),
        t = Hy(n.chainId);
      if (e == null && t == null)
        return {
          name: n.name,
          chainId: n.chainId,
        };
      if (e && t && e.name === t.name && e.chainId === t.chainId) return e;
    }
    return qk.throwArgumentError('network chainId mismatch', 'network', n);
  }
}
const Hk = new D('celo/transactions');
function Kk(n) {
  const e = Dl(n);
  e.length !== 12 && e.length !== 9 && Hk.throwArgumentError('invalid raw transaction', 'rawTransaction', n);
  const t = {
    nonce: lu(e[0]).toNumber(),
    gasPrice: lu(e[1]),
    gasLimit: lu(e[2]),
    feeCurrency: Ff(e[3]),
    gatewayFeeRecipient: Ff(e[4]),
    gatewayFee: lu(e[5]),
    to: Ff(e[6]),
    value: lu(e[7]),
    data: e[8],
    chainId: 0,
  };
  if (e.length === 9) return t;
  try {
    t.v = q.from(e[9]).toNumber();
  } catch (i) {
    return console.log(i), t;
  }
  if (((t.r = Le(e[10], 32)), (t.s = Le(e[11], 32)), q.from(t.r).isZero() && q.from(t.s).isZero())) (t.chainId = t.v), (t.v = 0);
  else {
    (t.chainId = Math.floor((t.v - 35) / 2)), t.chainId < 0 && (t.chainId = 0);
    let i = t.v - 27;
    const r = e.slice(0, 6);
    t.chainId !== 0 && (r.push(K(t.chainId)), r.push('0x'), r.push('0x'), (i -= t.chainId * 2 + 8));
    const s = De(Ts(r));
    try {
      t.from = Ho(s, {
        r: K(t.r),
        s: K(t.s),
        recoveryParam: i,
      });
    } catch (a) {
      console.log(a);
    }
    t.hash = De(n);
  }
  return t;
}
function Ff(n) {
  if (n !== '0x')
    try {
      return Fe(n);
    } catch {
      return n;
    }
}
function lu(n) {
  return n === '0x' ? p0 : q.from(n);
}
const Wk = new D('CeloProvider');
class Jk extends HR {
  constructor(e, t) {
    super(e, t);
    const i = this.formatter.formats.block;
    (i.gasLimit = () => q.from(0)), (i.nonce = () => ''), (i.difficulty = () => 0);
    const r = this.formatter.formats.blockWithTransactions;
    (r.gasLimit = () => q.from(0)), (r.nonce = () => ''), (r.difficulty = () => 0);
  }
  /**
   * Override to parse transaction correctly
   * https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/base-provider.ts
   */
  async sendTransaction(e) {
    await this.getNetwork();
    const t = await Promise.resolve(e),
      i = K(t),
      r = Kk(t);
    try {
      const s = await this.perform('sendTransaction', {
        signedTransaction: i,
      });
      return this._wrapTransaction(r, s);
    } catch (s) {
      throw ((s.transaction = r), (s.transactionHash = r.hash), s);
    }
  }
  /**
   * Override to handle alternative gas currencies
   * getGasPrice in https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/base-provider.ts
   */
  async getGasPrice(e) {
    await this.getNetwork();
    const t = e ? { feeCurrencyAddress: e } : {};
    return q.from(await this.perform('getGasPrice', t));
  }
  /**
   * Override to handle alternative gas currencies
   * prepareRequest in https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts
   */
  prepareRequest(e, t) {
    return e === 'getGasPrice' ? ['eth_gasPrice', t.feeCurrencyAddress ? [t.feeCurrencyAddress] : []] : super.prepareRequest(e, t);
  }
  static getNetwork(e) {
    const t = Hy(e ?? 'celo');
    return (
      t ??
      Wk.throwError(`unknown network: ${JSON.stringify(t)}`, D.errors.UNSUPPORTED_OPERATION, {
        operation: 'getNetwork',
        value: e,
      })
    );
  }
}
D.errors.INSUFFICIENT_FUNDS, D.errors.NONCE_EXPIRED, D.errors.REPLACEMENT_UNDERPRICED;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Sw = function (n) {
    const e = [];
    let t = 0;
    for (let i = 0; i < n.length; i++) {
      let r = n.charCodeAt(i);
      r < 128
        ? (e[t++] = r)
        : r < 2048
        ? ((e[t++] = (r >> 6) | 192), (e[t++] = (r & 63) | 128))
        : (r & 64512) === 55296 && i + 1 < n.length && (n.charCodeAt(i + 1) & 64512) === 56320
        ? ((r = 65536 + ((r & 1023) << 10) + (n.charCodeAt(++i) & 1023)), (e[t++] = (r >> 18) | 240), (e[t++] = ((r >> 12) & 63) | 128), (e[t++] = ((r >> 6) & 63) | 128), (e[t++] = (r & 63) | 128))
        : ((e[t++] = (r >> 12) | 224), (e[t++] = ((r >> 6) & 63) | 128), (e[t++] = (r & 63) | 128));
    }
    return e;
  },
  Qk = function (n) {
    const e = [];
    let t = 0,
      i = 0;
    for (; t < n.length; ) {
      const r = n[t++];
      if (r < 128) e[i++] = String.fromCharCode(r);
      else if (r > 191 && r < 224) {
        const s = n[t++];
        e[i++] = String.fromCharCode(((r & 31) << 6) | (s & 63));
      } else if (r > 239 && r < 365) {
        const s = n[t++],
          a = n[t++],
          o = n[t++],
          u = (((r & 7) << 18) | ((s & 63) << 12) | ((a & 63) << 6) | (o & 63)) - 65536;
        (e[i++] = String.fromCharCode(55296 + (u >> 10))), (e[i++] = String.fromCharCode(56320 + (u & 1023)));
      } else {
        const s = n[t++],
          a = n[t++];
        e[i++] = String.fromCharCode(((r & 15) << 12) | ((s & 63) << 6) | (a & 63));
      }
    }
    return e.join('');
  },
  Cw = {
    /**
     * Maps bytes to characters.
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     */
    get ENCODED_VALS() {
      return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     */
    get ENCODED_VALS_WEBSAFE() {
      return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     */
    HAS_NATIVE_SUPPORT: typeof atob == 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeByteArray(n, e) {
      if (!Array.isArray(n)) throw Error('encodeByteArray takes an array as a parameter');
      this.init_();
      const t = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_,
        i = [];
      for (let r = 0; r < n.length; r += 3) {
        const s = n[r],
          a = r + 1 < n.length,
          o = a ? n[r + 1] : 0,
          u = r + 2 < n.length,
          l = u ? n[r + 2] : 0,
          c = s >> 2,
          f = ((s & 3) << 4) | (o >> 4);
        let m = ((o & 15) << 2) | (l >> 6),
          w = l & 63;
        u || ((w = 64), a || (m = 64)), i.push(t[c], t[f], t[m], t[w]);
      }
      return i.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param input A string to encode.
     * @param webSafe If true, we should use the
     *     alternative alphabet.
     * @return The base64 encoded string.
     */
    encodeString(n, e) {
      return this.HAS_NATIVE_SUPPORT && !e ? btoa(n) : this.encodeByteArray(Sw(n), e);
    },
    /**
     * Base64-decode a string.
     *
     * @param input to decode.
     * @param webSafe True if we should use the
     *     alternative alphabet.
     * @return string representing the decoded value.
     */
    decodeString(n, e) {
      return this.HAS_NATIVE_SUPPORT && !e ? atob(n) : Qk(this.decodeStringToByteArray(n, e));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param input Input to decode.
     * @param webSafe True if we should use the web-safe alphabet.
     * @return bytes representing the decoded value.
     */
    decodeStringToByteArray(n, e) {
      this.init_();
      const t = e ? this.charToByteMapWebSafe_ : this.charToByteMap_,
        i = [];
      for (let r = 0; r < n.length; ) {
        const s = t[n.charAt(r++)],
          o = r < n.length ? t[n.charAt(r)] : 0;
        ++r;
        const l = r < n.length ? t[n.charAt(r)] : 64;
        ++r;
        const f = r < n.length ? t[n.charAt(r)] : 64;
        if ((++r, s == null || o == null || l == null || f == null)) throw new Yk();
        const m = (s << 2) | (o >> 4);
        if ((i.push(m), l !== 64)) {
          const w = ((o << 4) & 240) | (l >> 2);
          if ((i.push(w), f !== 64)) {
            const v = ((l << 6) & 192) | f;
            i.push(v);
          }
        }
      }
      return i;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_() {
      if (!this.byteToCharMap_) {
        (this.byteToCharMap_ = {}), (this.charToByteMap_ = {}), (this.byteToCharMapWebSafe_ = {}), (this.charToByteMapWebSafe_ = {});
        for (let n = 0; n < this.ENCODED_VALS.length; n++)
          (this.byteToCharMap_[n] = this.ENCODED_VALS.charAt(n)),
            (this.charToByteMap_[this.byteToCharMap_[n]] = n),
            (this.byteToCharMapWebSafe_[n] = this.ENCODED_VALS_WEBSAFE.charAt(n)),
            (this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[n]] = n),
            n >= this.ENCODED_VALS_BASE.length && ((this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(n)] = n), (this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(n)] = n));
      }
    },
  };
class Yk extends Error {
  constructor() {
    super(...arguments), (this.name = 'DecodeBase64StringError');
  }
}
const Xk = function (n) {
    const e = Sw(n);
    return Cw.encodeByteArray(e, !0);
  },
  Rc = function (n) {
    return Xk(n).replace(/\./g, '');
  },
  Zk = function (n) {
    try {
      return Cw.decodeString(n, !0);
    } catch (e) {
      console.error('base64Decode failed: ', e);
    }
    return null;
  };
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function eP() {
  if (typeof self < 'u') return self;
  if (typeof window < 'u') return window;
  if (typeof ha < 'u') return ha;
  throw new Error('Unable to locate global object.');
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const tP = () => eP().__FIREBASE_DEFAULTS__,
  nP = () => {
    if (
      typeof Od > 'u' ||
      typeof {
        ALLUSERSPROFILE: 'C:\\ProgramData',
        APPDATA: 'C:\\Users\\viper\\AppData\\Roaming',
        CHROME_CRASHPAD_PIPE_NAME: '\\\\.\\pipe\\crashpad_64264_CNKSGFURSPPXYQGD',
        COLOR: '1',
        COLORTERM: 'truecolor',
        CommonProgramFiles: 'C:\\Program Files\\Common Files',
        'CommonProgramFiles(x86)': 'C:\\Program Files (x86)\\Common Files',
        CommonProgramW6432: 'C:\\Program Files\\Common Files',
        COMPUTERNAME: 'ULTIMATEPC',
        ComSpec: 'C:\\WINDOWS\\system32\\cmd.exe',
        DriverData: 'C:\\Windows\\System32\\Drivers\\DriverData',
        EDITOR: 'C:\\WINDOWS\\notepad.exe',
        EFC_10140: '1',
        GIT_ASKPASS: 'c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh',
        HOME: 'C:\\Users\\viper',
        HOMEDRIVE: 'C:',
        HOMEPATH: '\\Users\\viper',
        INIT_CWD: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp',
        LANG: 'en_US.UTF-8',
        LOCALAPPDATA: 'C:\\Users\\viper\\AppData\\Local',
        LOGONSERVER: '\\\\ULTIMATEPC',
        NODE: 'C:\\Program Files\\nodejs\\node.exe',
        NODE_ENV: 'production',
        NODE_EXE: 'C:\\Program Files\\nodejs\\\\node.exe',
        NPM_CLI_JS: 'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
        npm_command: 'run-script',
        npm_config_cache: 'C:\\Users\\viper\\AppData\\Local\\npm-cache',
        npm_config_globalconfig: 'C:\\Program Files\\nodejs\\etc\\npmrc',
        npm_config_global_prefix: 'C:\\Program Files\\nodejs',
        npm_config_init_module: 'C:\\Users\\viper\\.npm-init.js',
        npm_config_local_prefix: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp',
        npm_config_metrics_registry: 'https://registry.npmjs.org/',
        npm_config_node_gyp: 'C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js',
        npm_config_noproxy: '',
        npm_config_prefix: 'C:\\Program Files\\nodejs',
        npm_config_shamefully_hoist: 'true',
        npm_config_userconfig: 'C:\\Users\\viper\\.npmrc',
        npm_config_user_agent: 'npm/9.5.1 node/v19.8.1 win32 x64 workspaces/false',
        npm_execpath: 'C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\bin\\npm-cli.js',
        npm_lifecycle_event: 'build:dev:chart-data-script',
        npm_lifecycle_script: 'vite build --config vite.config-lib.ts --mode development',
        npm_node_execpath: 'C:\\Program Files\\nodejs\\node.exe',
        npm_package_engines_node: '>=16.0.0',
        npm_package_json: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\package.json',
        npm_package_name: '@kolektivo/dapp',
        npm_package_version: '1.0.0',
        NPM_PREFIX_NPM_CLI_JS: 'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
        NUMBER_OF_PROCESSORS: '24',
        NVM_HOME: 'C:\\Users\\viper\\AppData\\Roaming\\nvm',
        NVM_SYMLINK: 'C:\\Program Files\\nodejs',
        OculusBase: 'C:\\Program Files\\Oculus\\',
        OneDrive: 'C:\\Users\\viper\\OneDrive',
        OneDriveConsumer: 'C:\\Users\\viper\\OneDrive',
        ORIGINAL_XDG_CURRENT_DESKTOP: 'undefined',
        OS: 'Windows_NT',
        Path: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\node_modules\\.bin;C:\\Users\\viper\\source\\node_modules\\.bin;C:\\Users\\viper\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Oculus\\Support\\oculus-runtime;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Users\\viper\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Git\\cmd;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\DTS\\Binn\\;C:\\Program Files (x86)\\Microsoft SQL Server\\160\\DTS\\Binn\\;C:\\Program Files\\Azure Data Studio\\bin;C:\\Program Files (x86)\\GnuWin32\\bin;C:\\Program Files\\dotnet\\;%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem;%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0\\;%SYSTEMROOT%\\System32\\OpenSSH\\;C:\\Users\\viper\\.cargo\\bin;C:\\Users\\viper\\AppData\\Local\\Microsoft\\PowerAppsCLI\\;C:\\Users\\viper\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\viper\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\viper\\.dotnet\\tools;C:\\Users\\viper\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\Azure Data Studio\\bin;C:\\Users\\viper\\.dotnet\\tools;C:\\Program Files (x86)\\GnuWin32\\bin;;C:\\Users\\viper\\AppData\\Local\\Microsoft\\WindowsApps',
        PATHEXT: '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL',
        PROCESSOR_ARCHITECTURE: 'AMD64',
        PROCESSOR_IDENTIFIER: 'Intel64 Family 6 Model 151 Stepping 2, GenuineIntel',
        PROCESSOR_LEVEL: '6',
        PROCESSOR_REVISION: '9702',
        ProgramData: 'C:\\ProgramData',
        ProgramFiles: 'C:\\Program Files',
        'ProgramFiles(x86)': 'C:\\Program Files (x86)',
        ProgramW6432: 'C:\\Program Files',
        PROMPT: '$P$G',
        PSModulePath:
          'C:\\Users\\viper\\OneDrive\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\PowerShell\\Modules\\',
        PUBLIC: 'C:\\Users\\Public',
        SESSIONNAME: 'Console',
        SystemDrive: 'C:',
        SystemRoot: 'C:\\WINDOWS',
        TEMP: 'C:\\Users\\viper\\AppData\\Local\\Temp',
        TERM_PROGRAM: 'vscode',
        TERM_PROGRAM_VERSION: '1.71.2',
        TMP: 'C:\\Users\\viper\\AppData\\Local\\Temp',
        USERDOMAIN: 'ULTIMATEPC',
        USERDOMAIN_ROAMINGPROFILE: 'ULTIMATEPC',
        USERNAME: 'viper',
        USERPROFILE: 'C:\\Users\\viper',
        VSCODE_GIT_ASKPASS_EXTRA_ARGS: '--ms-enable-electron-run-as-node',
        VSCODE_GIT_ASKPASS_MAIN: 'c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js',
        VSCODE_GIT_ASKPASS_NODE: 'C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe',
        VSCODE_GIT_IPC_HANDLE: '\\\\.\\pipe\\vscode-git-860c0d3dad-sock',
        windir: 'C:\\WINDOWS',
      } > 'u'
    )
      return;
    const n = {
      ALLUSERSPROFILE: 'C:\\ProgramData',
      APPDATA: 'C:\\Users\\viper\\AppData\\Roaming',
      CHROME_CRASHPAD_PIPE_NAME: '\\\\.\\pipe\\crashpad_64264_CNKSGFURSPPXYQGD',
      COLOR: '1',
      COLORTERM: 'truecolor',
      CommonProgramFiles: 'C:\\Program Files\\Common Files',
      'CommonProgramFiles(x86)': 'C:\\Program Files (x86)\\Common Files',
      CommonProgramW6432: 'C:\\Program Files\\Common Files',
      COMPUTERNAME: 'ULTIMATEPC',
      ComSpec: 'C:\\WINDOWS\\system32\\cmd.exe',
      DriverData: 'C:\\Windows\\System32\\Drivers\\DriverData',
      EDITOR: 'C:\\WINDOWS\\notepad.exe',
      EFC_10140: '1',
      GIT_ASKPASS: 'c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh',
      HOME: 'C:\\Users\\viper',
      HOMEDRIVE: 'C:',
      HOMEPATH: '\\Users\\viper',
      INIT_CWD: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp',
      LANG: 'en_US.UTF-8',
      LOCALAPPDATA: 'C:\\Users\\viper\\AppData\\Local',
      LOGONSERVER: '\\\\ULTIMATEPC',
      NODE: 'C:\\Program Files\\nodejs\\node.exe',
      NODE_ENV: 'production',
      NODE_EXE: 'C:\\Program Files\\nodejs\\\\node.exe',
      NPM_CLI_JS: 'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
      npm_command: 'run-script',
      npm_config_cache: 'C:\\Users\\viper\\AppData\\Local\\npm-cache',
      npm_config_globalconfig: 'C:\\Program Files\\nodejs\\etc\\npmrc',
      npm_config_global_prefix: 'C:\\Program Files\\nodejs',
      npm_config_init_module: 'C:\\Users\\viper\\.npm-init.js',
      npm_config_local_prefix: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp',
      npm_config_metrics_registry: 'https://registry.npmjs.org/',
      npm_config_node_gyp: 'C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js',
      npm_config_noproxy: '',
      npm_config_prefix: 'C:\\Program Files\\nodejs',
      npm_config_shamefully_hoist: 'true',
      npm_config_userconfig: 'C:\\Users\\viper\\.npmrc',
      npm_config_user_agent: 'npm/9.5.1 node/v19.8.1 win32 x64 workspaces/false',
      npm_execpath: 'C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\bin\\npm-cli.js',
      npm_lifecycle_event: 'build:dev:chart-data-script',
      npm_lifecycle_script: 'vite build --config vite.config-lib.ts --mode development',
      npm_node_execpath: 'C:\\Program Files\\nodejs\\node.exe',
      npm_package_engines_node: '>=16.0.0',
      npm_package_json: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\package.json',
      npm_package_name: '@kolektivo/dapp',
      npm_package_version: '1.0.0',
      NPM_PREFIX_NPM_CLI_JS: 'C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js',
      NUMBER_OF_PROCESSORS: '24',
      NVM_HOME: 'C:\\Users\\viper\\AppData\\Roaming\\nvm',
      NVM_SYMLINK: 'C:\\Program Files\\nodejs',
      OculusBase: 'C:\\Program Files\\Oculus\\',
      OneDrive: 'C:\\Users\\viper\\OneDrive',
      OneDriveConsumer: 'C:\\Users\\viper\\OneDrive',
      ORIGINAL_XDG_CURRENT_DESKTOP: 'undefined',
      OS: 'Windows_NT',
      Path: 'C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\node_modules\\.bin;C:\\Users\\viper\\source\\node_modules\\.bin;C:\\Users\\viper\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Oculus\\Support\\oculus-runtime;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Users\\viper\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Git\\cmd;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\DTS\\Binn\\;C:\\Program Files (x86)\\Microsoft SQL Server\\160\\DTS\\Binn\\;C:\\Program Files\\Azure Data Studio\\bin;C:\\Program Files (x86)\\GnuWin32\\bin;C:\\Program Files\\dotnet\\;%SystemRoot%\\system32;%SystemRoot%;%SystemRoot%\\System32\\Wbem;%SYSTEMROOT%\\System32\\WindowsPowerShell\\v1.0\\;%SYSTEMROOT%\\System32\\OpenSSH\\;C:\\Users\\viper\\.cargo\\bin;C:\\Users\\viper\\AppData\\Local\\Microsoft\\PowerAppsCLI\\;C:\\Users\\viper\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\viper\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\viper\\.dotnet\\tools;C:\\Users\\viper\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\Azure Data Studio\\bin;C:\\Users\\viper\\.dotnet\\tools;C:\\Program Files (x86)\\GnuWin32\\bin;;C:\\Users\\viper\\AppData\\Local\\Microsoft\\WindowsApps',
      PATHEXT: '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL',
      PROCESSOR_ARCHITECTURE: 'AMD64',
      PROCESSOR_IDENTIFIER: 'Intel64 Family 6 Model 151 Stepping 2, GenuineIntel',
      PROCESSOR_LEVEL: '6',
      PROCESSOR_REVISION: '9702',
      ProgramData: 'C:\\ProgramData',
      ProgramFiles: 'C:\\Program Files',
      'ProgramFiles(x86)': 'C:\\Program Files (x86)',
      ProgramW6432: 'C:\\Program Files',
      PROMPT: '$P$G',
      PSModulePath:
        'C:\\Users\\viper\\OneDrive\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\PowerShell\\Modules\\',
      PUBLIC: 'C:\\Users\\Public',
      SESSIONNAME: 'Console',
      SystemDrive: 'C:',
      SystemRoot: 'C:\\WINDOWS',
      TEMP: 'C:\\Users\\viper\\AppData\\Local\\Temp',
      TERM_PROGRAM: 'vscode',
      TERM_PROGRAM_VERSION: '1.71.2',
      TMP: 'C:\\Users\\viper\\AppData\\Local\\Temp',
      USERDOMAIN: 'ULTIMATEPC',
      USERDOMAIN_ROAMINGPROFILE: 'ULTIMATEPC',
      USERNAME: 'viper',
      USERPROFILE: 'C:\\Users\\viper',
      VSCODE_GIT_ASKPASS_EXTRA_ARGS: '--ms-enable-electron-run-as-node',
      VSCODE_GIT_ASKPASS_MAIN: 'c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js',
      VSCODE_GIT_ASKPASS_NODE: 'C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe',
      VSCODE_GIT_IPC_HANDLE: '\\\\.\\pipe\\vscode-git-860c0d3dad-sock',
      windir: 'C:\\WINDOWS',
    }.__FIREBASE_DEFAULTS__;
    if (n) return JSON.parse(n);
  },
  iP = () => {
    if (typeof document > 'u') return;
    let n;
    try {
      n = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
    } catch {
      return;
    }
    const e = n && Zk(n[1]);
    return e && JSON.parse(e);
  },
  Mw = () => {
    try {
      return tP() || nP() || iP();
    } catch (n) {
      console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${n}`);
      return;
    }
  },
  rP = (n) => {
    var e, t;
    return (t = (e = Mw()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || t === void 0 ? void 0 : t[n];
  },
  sP = (n) => {
    const e = rP(n);
    if (!e) return;
    const t = e.lastIndexOf(':');
    if (t <= 0 || t + 1 === e.length) throw new Error(`Invalid host ${e} with no separate hostname and port!`);
    const i = parseInt(e.substring(t + 1), 10);
    return e[0] === '[' ? [e.substring(1, t - 1), i] : [e.substring(0, t), i];
  },
  aP = () => {
    var n;
    return (n = Mw()) === null || n === void 0 ? void 0 : n.config;
  };
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oP {
  constructor() {
    (this.reject = () => {}),
      (this.resolve = () => {}),
      (this.promise = new Promise((e, t) => {
        (this.resolve = e), (this.reject = t);
      }));
  }
  /**
   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(e) {
    return (t, i) => {
      t ? this.reject(t) : this.resolve(i), typeof e == 'function' && (this.promise.catch(() => {}), e.length === 1 ? e(t) : e(t, i));
    };
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function uP(n, e) {
  if (n.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  const t = {
      alg: 'none',
      type: 'JWT',
    },
    i = e || 'demo-project',
    r = n.iat || 0,
    s = n.sub || n.user_id;
  if (!s) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  const a = Object.assign(
      {
        // Set all required fields to decent defaults
        iss: `https://securetoken.google.com/${i}`,
        aud: i,
        iat: r,
        exp: r + 3600,
        auth_time: r,
        sub: s,
        user_id: s,
        firebase: {
          sign_in_provider: 'custom',
          identities: {},
        },
      },
      n,
    ),
    o = '';
  return [Rc(JSON.stringify(t)), Rc(JSON.stringify(a)), o].join('.');
}
function lP() {
  try {
    return typeof indexedDB == 'object';
  } catch {
    return !1;
  }
}
function dP() {
  return new Promise((n, e) => {
    try {
      let t = !0;
      const i = 'validate-browser-context-for-indexeddb-analytics-module',
        r = self.indexedDB.open(i);
      (r.onsuccess = () => {
        r.result.close(), t || self.indexedDB.deleteDatabase(i), n(!0);
      }),
        (r.onupgradeneeded = () => {
          t = !1;
        }),
        (r.onerror = () => {
          var s;
          e(((s = r.error) === null || s === void 0 ? void 0 : s.message) || '');
        });
    } catch (t) {
      e(t);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cP = 'FirebaseError';
class Jo extends Error {
  constructor(e, t, i) {
    super(t), (this.code = e), (this.customData = i), (this.name = cP), Object.setPrototypeOf(this, Jo.prototype), Error.captureStackTrace && Error.captureStackTrace(this, _w.prototype.create);
  }
}
class _w {
  constructor(e, t, i) {
    (this.service = e), (this.serviceName = t), (this.errors = i);
  }
  create(e, ...t) {
    const i = t[0] || {},
      r = `${this.service}/${e}`,
      s = this.errors[e],
      a = s ? pP(s, i) : 'Error',
      o = `${this.serviceName}: ${a} (${r}).`;
    return new Jo(r, o, i);
  }
}
function pP(n, e) {
  return n.replace(fP, (t, i) => {
    const r = e[i];
    return r != null ? String(r) : `<${i}?>`;
  });
}
const fP = /\{\$([^}]+)}/g;
function Ky(n, e) {
  if (n === e) return !0;
  const t = Object.keys(n),
    i = Object.keys(e);
  for (const r of t) {
    if (!i.includes(r)) return !1;
    const s = n[r],
      a = e[r];
    if (Tv(s) && Tv(a)) {
      if (!Ky(s, a)) return !1;
    } else if (s !== a) return !1;
  }
  for (const r of i) if (!t.includes(r)) return !1;
  return !0;
}
function Tv(n) {
  return n !== null && typeof n == 'object';
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function or(n) {
  return n && n._delegate ? n._delegate : n;
}
class ll {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(e, t, i) {
    (this.name = e), (this.instanceFactory = t), (this.type = i), (this.multipleInstances = !1), (this.serviceProps = {}), (this.instantiationMode = 'LAZY'), (this.onInstanceCreated = null);
  }
  setInstantiationMode(e) {
    return (this.instantiationMode = e), this;
  }
  setMultipleInstances(e) {
    return (this.multipleInstances = e), this;
  }
  setServiceProps(e) {
    return (this.serviceProps = e), this;
  }
  setInstanceCreatedCallback(e) {
    return (this.onInstanceCreated = e), this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ta = '[DEFAULT]';
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yP {
  constructor(e, t) {
    (this.name = e),
      (this.container = t),
      (this.component = null),
      (this.instances = /* @__PURE__ */ new Map()),
      (this.instancesDeferred = /* @__PURE__ */ new Map()),
      (this.instancesOptions = /* @__PURE__ */ new Map()),
      (this.onInitCallbacks = /* @__PURE__ */ new Map());
  }
  /**
   * @param identifier A provider can provide mulitple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(e) {
    const t = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(t)) {
      const i = new oP();
      if ((this.instancesDeferred.set(t, i), this.isInitialized(t) || this.shouldAutoInitialize()))
        try {
          const r = this.getOrInitializeService({
            instanceIdentifier: t,
          });
          r && i.resolve(r);
        } catch {}
    }
    return this.instancesDeferred.get(t).promise;
  }
  getImmediate(e) {
    var t;
    const i = this.normalizeInstanceIdentifier(e?.identifier),
      r = (t = e?.optional) !== null && t !== void 0 ? t : !1;
    if (this.isInitialized(i) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: i,
        });
      } catch (s) {
        if (r) return null;
        throw s;
      }
    else {
      if (r) return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name) throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component) throw Error(`Component for ${this.name} has already been provided`);
    if (((this.component = e), !!this.shouldAutoInitialize())) {
      if (mP(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: ta });
        } catch {}
      for (const [t, i] of this.instancesDeferred.entries()) {
        const r = this.normalizeInstanceIdentifier(t);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: r,
          });
          i.resolve(s);
        } catch {}
      }
    }
  }
  clearInstance(e = ta) {
    this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const e = Array.from(this.instances.values());
    await Promise.all([...e.filter((t) => 'INTERNAL' in t).map((t) => t.INTERNAL.delete()), ...e.filter((t) => '_delete' in t).map((t) => t._delete())]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(e = ta) {
    return this.instances.has(e);
  }
  getOptions(e = ta) {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    const { options: t = {} } = e,
      i = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(i)) throw Error(`${this.name}(${i}) has already been initialized`);
    if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`);
    const r = this.getOrInitializeService({
      instanceIdentifier: i,
      options: t,
    });
    for (const [s, a] of this.instancesDeferred.entries()) {
      const o = this.normalizeInstanceIdentifier(s);
      i === o && a.resolve(r);
    }
    return r;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(e, t) {
    var i;
    const r = this.normalizeInstanceIdentifier(t),
      s = (i = this.onInitCallbacks.get(r)) !== null && i !== void 0 ? i : /* @__PURE__ */ new Set();
    s.add(e), this.onInitCallbacks.set(r, s);
    const a = this.instances.get(r);
    return (
      a && e(a, r),
      () => {
        s.delete(e);
      }
    );
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(e, t) {
    const i = this.onInitCallbacks.get(t);
    if (i)
      for (const r of i)
        try {
          r(e, t);
        } catch {}
  }
  getOrInitializeService({ instanceIdentifier: e, options: t = {} }) {
    let i = this.instances.get(e);
    if (
      !i &&
      this.component &&
      ((i = this.component.instanceFactory(this.container, {
        instanceIdentifier: hP(e),
        options: t,
      })),
      this.instances.set(e, i),
      this.instancesOptions.set(e, t),
      this.invokeOnInitCallbacks(i, e),
      this.component.onInstanceCreated)
    )
      try {
        this.component.onInstanceCreated(this.container, e, i);
      } catch {}
    return i || null;
  }
  normalizeInstanceIdentifier(e = ta) {
    return this.component ? (this.component.multipleInstances ? e : ta) : e;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== 'EXPLICIT';
  }
}
function hP(n) {
  return n === ta ? void 0 : n;
}
function mP(n) {
  return n.instantiationMode === 'EAGER';
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class bP {
  constructor(e) {
    (this.name = e), (this.providers = /* @__PURE__ */ new Map());
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(e) {
    const t = this.getProvider(e.name);
    if (t.isComponentSet()) throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
    t.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(e) {
    if (this.providers.has(e)) return this.providers.get(e);
    const t = new yP(e, this);
    return this.providers.set(e, t), t;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var $e;
(function (n) {
  (n[(n.DEBUG = 0)] = 'DEBUG'), (n[(n.VERBOSE = 1)] = 'VERBOSE'), (n[(n.INFO = 2)] = 'INFO'), (n[(n.WARN = 3)] = 'WARN'), (n[(n.ERROR = 4)] = 'ERROR'), (n[(n.SILENT = 5)] = 'SILENT');
})($e || ($e = {}));
const gP = {
    debug: $e.DEBUG,
    verbose: $e.VERBOSE,
    info: $e.INFO,
    warn: $e.WARN,
    error: $e.ERROR,
    silent: $e.SILENT,
  },
  vP = $e.INFO,
  xP = {
    [$e.DEBUG]: 'log',
    [$e.VERBOSE]: 'log',
    [$e.INFO]: 'info',
    [$e.WARN]: 'warn',
    [$e.ERROR]: 'error',
  },
  TP = (n, e, ...t) => {
    if (e < n.logLevel) return;
    const i = /* @__PURE__ */ new Date().toISOString(),
      r = xP[e];
    if (r) console[r](`[${i}]  ${n.name}:`, ...t);
    else throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
  };
class Rw {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(e) {
    (this.name = e), (this._logLevel = vP), (this._logHandler = TP), (this._userLogHandler = null);
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(e) {
    if (!(e in $e)) throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
    this._logLevel = e;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(e) {
    this._logLevel = typeof e == 'string' ? gP[e] : e;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(e) {
    if (typeof e != 'function') throw new TypeError('Value assigned to `logHandler` must be a function');
    this._logHandler = e;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(e) {
    this._userLogHandler = e;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.DEBUG, ...e), this._logHandler(this, $e.DEBUG, ...e);
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.VERBOSE, ...e), this._logHandler(this, $e.VERBOSE, ...e);
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.INFO, ...e), this._logHandler(this, $e.INFO, ...e);
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.WARN, ...e), this._logHandler(this, $e.WARN, ...e);
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.ERROR, ...e), this._logHandler(this, $e.ERROR, ...e);
  }
}
const wP = (n, e) => e.some((t) => n instanceof t);
let wv, Av;
function AP() {
  return wv || (wv = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);
}
function EP() {
  return Av || (Av = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]);
}
const Iw = /* @__PURE__ */ new WeakMap(),
  Wy = /* @__PURE__ */ new WeakMap(),
  Ow = /* @__PURE__ */ new WeakMap(),
  Lf = /* @__PURE__ */ new WeakMap(),
  J0 = /* @__PURE__ */ new WeakMap();
function SP(n) {
  const e = new Promise((t, i) => {
    const r = () => {
        n.removeEventListener('success', s), n.removeEventListener('error', a);
      },
      s = () => {
        t(ms(n.result)), r();
      },
      a = () => {
        i(n.error), r();
      };
    n.addEventListener('success', s), n.addEventListener('error', a);
  });
  return (
    e
      .then((t) => {
        t instanceof IDBCursor && Iw.set(t, n);
      })
      .catch(() => {}),
    J0.set(e, n),
    e
  );
}
function CP(n) {
  if (Wy.has(n)) return;
  const e = new Promise((t, i) => {
    const r = () => {
        n.removeEventListener('complete', s), n.removeEventListener('error', a), n.removeEventListener('abort', a);
      },
      s = () => {
        t(), r();
      },
      a = () => {
        i(n.error || new DOMException('AbortError', 'AbortError')), r();
      };
    n.addEventListener('complete', s), n.addEventListener('error', a), n.addEventListener('abort', a);
  });
  Wy.set(n, e);
}
let Jy = {
  get(n, e, t) {
    if (n instanceof IDBTransaction) {
      if (e === 'done') return Wy.get(n);
      if (e === 'objectStoreNames') return n.objectStoreNames || Ow.get(n);
      if (e === 'store') return t.objectStoreNames[1] ? void 0 : t.objectStore(t.objectStoreNames[0]);
    }
    return ms(n[e]);
  },
  set(n, e, t) {
    return (n[e] = t), !0;
  },
  has(n, e) {
    return n instanceof IDBTransaction && (e === 'done' || e === 'store') ? !0 : e in n;
  },
};
function MP(n) {
  Jy = n(Jy);
}
function _P(n) {
  return n === IDBDatabase.prototype.transaction && !('objectStoreNames' in IDBTransaction.prototype)
    ? function (e, ...t) {
        const i = n.call($f(this), e, ...t);
        return Ow.set(i, e.sort ? e.sort() : [e]), ms(i);
      }
    : EP().includes(n)
    ? function (...e) {
        return n.apply($f(this), e), ms(Iw.get(this));
      }
    : function (...e) {
        return ms(n.apply($f(this), e));
      };
}
function RP(n) {
  return typeof n == 'function' ? _P(n) : (n instanceof IDBTransaction && CP(n), wP(n, AP()) ? new Proxy(n, Jy) : n);
}
function ms(n) {
  if (n instanceof IDBRequest) return SP(n);
  if (Lf.has(n)) return Lf.get(n);
  const e = RP(n);
  return e !== n && (Lf.set(n, e), J0.set(e, n)), e;
}
const $f = (n) => J0.get(n);
function IP(n, e, { blocked: t, upgrade: i, blocking: r, terminated: s } = {}) {
  const a = indexedDB.open(n, e),
    o = ms(a);
  return (
    i &&
      a.addEventListener('upgradeneeded', (u) => {
        i(ms(a.result), u.oldVersion, u.newVersion, ms(a.transaction));
      }),
    t && a.addEventListener('blocked', () => t()),
    o
      .then((u) => {
        s && u.addEventListener('close', () => s()), r && u.addEventListener('versionchange', () => r());
      })
      .catch(() => {}),
    o
  );
}
const OP = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'],
  kP = ['put', 'add', 'delete', 'clear'],
  Uf = /* @__PURE__ */ new Map();
function Ev(n, e) {
  if (!(n instanceof IDBDatabase && !(e in n) && typeof e == 'string')) return;
  if (Uf.get(e)) return Uf.get(e);
  const t = e.replace(/FromIndex$/, ''),
    i = e !== t,
    r = kP.includes(t);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(t in (i ? IDBIndex : IDBObjectStore).prototype) ||
    !(r || OP.includes(t))
  )
    return;
  const s = async function (a, ...o) {
    const u = this.transaction(a, r ? 'readwrite' : 'readonly');
    let l = u.store;
    return i && (l = l.index(o.shift())), (await Promise.all([l[t](...o), r && u.done]))[0];
  };
  return Uf.set(e, s), s;
}
MP((n) => ({
  ...n,
  get: (e, t, i) => Ev(e, t) || n.get(e, t, i),
  has: (e, t) => !!Ev(e, t) || n.has(e, t),
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PP {
  constructor(e) {
    this.container = e;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container
      .getProviders()
      .map((t) => {
        if (NP(t)) {
          const i = t.getImmediate();
          return `${i.library}/${i.version}`;
        } else return null;
      })
      .filter((t) => t)
      .join(' ');
  }
}
function NP(n) {
  const e = n.getComponent();
  return e?.type === 'VERSION';
}
const Qy = '@firebase/app',
  Sv = '0.9.8';
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wa = new Rw('@firebase/app'),
  DP = '@firebase/app-compat',
  BP = '@firebase/analytics-compat',
  FP = '@firebase/analytics',
  LP = '@firebase/app-check-compat',
  $P = '@firebase/app-check',
  UP = '@firebase/auth',
  jP = '@firebase/auth-compat',
  VP = '@firebase/database',
  zP = '@firebase/database-compat',
  GP = '@firebase/functions',
  qP = '@firebase/functions-compat',
  HP = '@firebase/installations',
  KP = '@firebase/installations-compat',
  WP = '@firebase/messaging',
  JP = '@firebase/messaging-compat',
  QP = '@firebase/performance',
  YP = '@firebase/performance-compat',
  XP = '@firebase/remote-config',
  ZP = '@firebase/remote-config-compat',
  eN = '@firebase/storage',
  tN = '@firebase/storage-compat',
  nN = '@firebase/firestore',
  iN = '@firebase/firestore-compat',
  rN = 'firebase',
  sN = '9.20.0';
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Yy = '[DEFAULT]',
  aN = {
    [Qy]: 'fire-core',
    [DP]: 'fire-core-compat',
    [FP]: 'fire-analytics',
    [BP]: 'fire-analytics-compat',
    [$P]: 'fire-app-check',
    [LP]: 'fire-app-check-compat',
    [UP]: 'fire-auth',
    [jP]: 'fire-auth-compat',
    [VP]: 'fire-rtdb',
    [zP]: 'fire-rtdb-compat',
    [GP]: 'fire-fn',
    [qP]: 'fire-fn-compat',
    [HP]: 'fire-iid',
    [KP]: 'fire-iid-compat',
    [WP]: 'fire-fcm',
    [JP]: 'fire-fcm-compat',
    [QP]: 'fire-perf',
    [YP]: 'fire-perf-compat',
    [XP]: 'fire-rc',
    [ZP]: 'fire-rc-compat',
    [eN]: 'fire-gcs',
    [tN]: 'fire-gcs-compat',
    [nN]: 'fire-fst',
    [iN]: 'fire-fst-compat',
    'fire-js': 'fire-js',
    [rN]: 'fire-js-all',
  };
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ic = /* @__PURE__ */ new Map(),
  Xy = /* @__PURE__ */ new Map();
function oN(n, e) {
  try {
    n.container.addComponent(e);
  } catch (t) {
    wa.debug(`Component ${e.name} failed to register with FirebaseApp ${n.name}`, t);
  }
}
function Oc(n) {
  const e = n.name;
  if (Xy.has(e)) return wa.debug(`There were multiple attempts to register component ${e}.`), !1;
  Xy.set(e, n);
  for (const t of Ic.values()) oN(t, n);
  return !0;
}
function uN(n, e) {
  const t = n.container.getProvider('heartbeat').getImmediate({ optional: !0 });
  return t && t.triggerHeartbeat(), n.container.getProvider(e);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const lN = {
    ['no-app']:
      /* AppError.NO_APP */
      "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
    ['bad-app-name']:
      /* AppError.BAD_APP_NAME */
      "Illegal App name: '{$appName}",
    ['duplicate-app']:
      /* AppError.DUPLICATE_APP */
      "Firebase App named '{$appName}' already exists with different options or config",
    ['app-deleted']:
      /* AppError.APP_DELETED */
      "Firebase App named '{$appName}' already deleted",
    ['no-options']:
      /* AppError.NO_OPTIONS */
      'Need to provide options, when not being deployed to hosting via source.',
    ['invalid-app-argument']:
      /* AppError.INVALID_APP_ARGUMENT */
      'firebase.{$appName}() takes either no argument or a Firebase App instance.',
    ['invalid-log-argument']:
      /* AppError.INVALID_LOG_ARGUMENT */
      'First argument to `onLog` must be null or a function.',
    ['idb-open']:
      /* AppError.IDB_OPEN */
      'Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.',
    ['idb-get']:
      /* AppError.IDB_GET */
      'Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.',
    ['idb-set']:
      /* AppError.IDB_WRITE */
      'Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.',
    ['idb-delete']:
      /* AppError.IDB_DELETE */
      'Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}.',
  },
  bs = new _w('app', 'Firebase', lN);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dN {
  constructor(e, t, i) {
    (this._isDeleted = !1),
      (this._options = Object.assign({}, e)),
      (this._config = Object.assign({}, t)),
      (this._name = t.name),
      (this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled),
      (this._container = i),
      this.container.addComponent(
        new ll(
          'app',
          () => this,
          'PUBLIC',
          /* ComponentType.PUBLIC */
        ),
      );
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), (this._automaticDataCollectionEnabled = e);
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted) throw bs.create('app-deleted', { appName: this._name });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const cN = sN;
function kw(n, e = {}) {
  let t = n;
  typeof e != 'object' && (e = { name: e });
  const i = Object.assign({ name: Yy, automaticDataCollectionEnabled: !1 }, e),
    r = i.name;
  if (typeof r != 'string' || !r)
    throw bs.create('bad-app-name', {
      appName: String(r),
    });
  if ((t || (t = aP()), !t))
    throw bs.create(
      'no-options',
      /* AppError.NO_OPTIONS */
    );
  const s = Ic.get(r);
  if (s) {
    if (Ky(t, s.options) && Ky(i, s.config)) return s;
    throw bs.create('duplicate-app', { appName: r });
  }
  const a = new bP(r);
  for (const u of Xy.values()) a.addComponent(u);
  const o = new dN(t, i, a);
  return Ic.set(r, o), o;
}
function pN(n = Yy) {
  const e = Ic.get(n);
  if (!e && n === Yy) return kw();
  if (!e) throw bs.create('no-app', { appName: n });
  return e;
}
function ho(n, e, t) {
  var i;
  let r = (i = aN[n]) !== null && i !== void 0 ? i : n;
  t && (r += `-${t}`);
  const s = r.match(/\s|\//),
    a = e.match(/\s|\//);
  if (s || a) {
    const o = [`Unable to register library "${r}" with version "${e}":`];
    s && o.push(`library name "${r}" contains illegal characters (whitespace or "/")`),
      s && a && o.push('and'),
      a && o.push(`version name "${e}" contains illegal characters (whitespace or "/")`),
      wa.warn(o.join(' '));
    return;
  }
  Oc(
    new ll(
      `${r}-version`,
      () => ({ library: r, version: e }),
      'VERSION',
      /* ComponentType.VERSION */
    ),
  );
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fN = 'firebase-heartbeat-database',
  yN = 1,
  dl = 'firebase-heartbeat-store';
let jf = null;
function Pw() {
  return (
    jf ||
      (jf = IP(fN, yN, {
        upgrade: (n, e) => {
          switch (e) {
            case 0:
              n.createObjectStore(dl);
          }
        },
      }).catch((n) => {
        throw bs.create('idb-open', {
          originalErrorMessage: n.message,
        });
      })),
    jf
  );
}
async function hN(n) {
  try {
    return (await Pw()).transaction(dl).objectStore(dl).get(Nw(n));
  } catch (e) {
    if (e instanceof Jo) wa.warn(e.message);
    else {
      const t = bs.create('idb-get', {
        originalErrorMessage: e?.message,
      });
      wa.warn(t.message);
    }
  }
}
async function Cv(n, e) {
  try {
    const i = (await Pw()).transaction(dl, 'readwrite');
    return await i.objectStore(dl).put(e, Nw(n)), i.done;
  } catch (t) {
    if (t instanceof Jo) wa.warn(t.message);
    else {
      const i = bs.create('idb-set', {
        originalErrorMessage: t?.message,
      });
      wa.warn(i.message);
    }
  }
}
function Nw(n) {
  return `${n.name}!${n.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mN = 1024,
  bN = 30 * 24 * 60 * 60 * 1e3;
class gN {
  constructor(e) {
    (this.container = e), (this._heartbeatsCache = null);
    const t = this.container.getProvider('app').getImmediate();
    (this._storage = new xN(t)), (this._heartbeatsCachePromise = this._storage.read().then((i) => ((this._heartbeatsCache = i), i)));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    const t = this.container.getProvider('platform-logger').getImmediate().getPlatformInfoString(),
      i = Mv();
    if (
      (this._heartbeatsCache === null && (this._heartbeatsCache = await this._heartbeatsCachePromise),
      !(this._heartbeatsCache.lastSentHeartbeatDate === i || this._heartbeatsCache.heartbeats.some((r) => r.date === i)))
    )
      return (
        this._heartbeatsCache.heartbeats.push({ date: i, agent: t }),
        (this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((r) => {
          const s = new Date(r.date).valueOf();
          return Date.now() - s <= bN;
        })),
        this._storage.overwrite(this._heartbeatsCache)
      );
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    if ((this._heartbeatsCache === null && (await this._heartbeatsCachePromise), this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0)) return '';
    const e = Mv(),
      { heartbeatsToSend: t, unsentEntries: i } = vN(this._heartbeatsCache.heartbeats),
      r = Rc(JSON.stringify({ version: 2, heartbeats: t }));
    return (
      (this._heartbeatsCache.lastSentHeartbeatDate = e),
      i.length > 0
        ? ((this._heartbeatsCache.heartbeats = i), await this._storage.overwrite(this._heartbeatsCache))
        : ((this._heartbeatsCache.heartbeats = []), this._storage.overwrite(this._heartbeatsCache)),
      r
    );
  }
}
function Mv() {
  return /* @__PURE__ */ new Date().toISOString().substring(0, 10);
}
function vN(n, e = mN) {
  const t = [];
  let i = n.slice();
  for (const r of n) {
    const s = t.find((a) => a.agent === r.agent);
    if (s) {
      if ((s.dates.push(r.date), _v(t) > e)) {
        s.dates.pop();
        break;
      }
    } else if (
      (t.push({
        agent: r.agent,
        dates: [r.date],
      }),
      _v(t) > e)
    ) {
      t.pop();
      break;
    }
    i = i.slice(1);
  }
  return {
    heartbeatsToSend: t,
    unsentEntries: i,
  };
}
class xN {
  constructor(e) {
    (this.app = e), (this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck());
  }
  async runIndexedDBEnvironmentCheck() {
    return lP()
      ? dP()
          .then(() => !0)
          .catch(() => !1)
      : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    return (await this._canUseIndexedDBPromise) ? (await hN(this.app)) || { heartbeats: [] } : { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return Cv(this.app, {
        lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : r.lastSentHeartbeatDate,
        heartbeats: e.heartbeats,
      });
    } else return;
  }
  // add heartbeats
  async add(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return Cv(this.app, {
        lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : r.lastSentHeartbeatDate,
        heartbeats: [...r.heartbeats, ...e.heartbeats],
      });
    } else return;
  }
}
function _v(n) {
  return Rc(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: n }),
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function TN(n) {
  Oc(
    new ll(
      'platform-logger',
      (e) => new PP(e),
      'PRIVATE',
      /* ComponentType.PRIVATE */
    ),
  ),
    Oc(
      new ll(
        'heartbeat',
        (e) => new gN(e),
        'PRIVATE',
        /* ComponentType.PRIVATE */
      ),
    ),
    ho(Qy, Sv, n),
    ho(Qy, Sv, 'esm2017'),
    ho('fire-js', '');
}
TN('');
var wN = 'firebase',
  AN = '9.20.0';
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
ho(wN, AN, 'app');
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bn {
  constructor(e) {
    this.uid = e;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    return this.isAuthenticated() ? 'uid:' + this.uid : 'anonymous-user';
  }
  isEqual(e) {
    return e.uid === this.uid;
  }
}
(Bn.UNAUTHENTICATED = new Bn(null)), // TODO(mikelehen): Look into getting a proper uid-equivalent for
  // non-FirebaseAuth providers.
  (Bn.GOOGLE_CREDENTIALS = new Bn('google-credentials-uid')),
  (Bn.FIRST_PARTY = new Bn('first-party-uid')),
  (Bn.MOCK_USER = new Bn('mock-user'));
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Qo = '9.20.0';
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ro = new Rw('@firebase/firestore');
function kc(n, ...e) {
  if (Ro.logLevel <= $e.DEBUG) {
    const t = e.map(Y0);
    Ro.debug(`Firestore (${Qo}): ${n}`, ...t);
  }
}
function Q0(n, ...e) {
  if (Ro.logLevel <= $e.ERROR) {
    const t = e.map(Y0);
    Ro.error(`Firestore (${Qo}): ${n}`, ...t);
  }
}
function Dw(n, ...e) {
  if (Ro.logLevel <= $e.WARN) {
    const t = e.map(Y0);
    Ro.warn(`Firestore (${Qo}): ${n}`, ...t);
  }
}
function Y0(n) {
  if (typeof n == 'string') return n;
  try {
    return (e = n), JSON.stringify(e);
  } catch {
    return n;
  }
  /**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var e;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Pt(n = 'Unexpected state') {
  const e = `FIRESTORE (${Qo}) INTERNAL ASSERTION FAILED: ` + n;
  throw (Q0(e), new Error(e));
}
function Es(n, e) {
  n || Pt();
}
function gp(n, e) {
  return n;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Rv = 'ok',
  EN = 'cancelled',
  Ou = 'unknown',
  pe = 'invalid-argument',
  SN = 'deadline-exceeded',
  CN = 'not-found',
  MN = 'permission-denied',
  Zy = 'unauthenticated',
  _N = 'resource-exhausted',
  Aa = 'failed-precondition',
  RN = 'aborted',
  IN = 'out-of-range',
  Bw = 'unimplemented',
  ON = 'internal',
  kN = 'unavailable';
class oe extends Jo {
  /** @hideconstructor */
  constructor(e, t) {
    super(e, t),
      (this.code = e),
      (this.message = t), // HACK: We write a toString property directly because Error is not a real
      // class and so inheritance does not work correctly. We could alternatively
      // do the same "back-door inheritance" trick that FirebaseError does.
      (this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fw {
  constructor(e, t) {
    (this.user = t), (this.type = 'OAuth'), (this.headers = /* @__PURE__ */ new Map()), this.headers.set('Authorization', `Bearer ${e}`);
  }
}
class PN {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {}
  start(e, t) {
    e.enqueueRetryable(() => t(Bn.UNAUTHENTICATED));
  }
  shutdown() {}
}
class NN {
  constructor(e) {
    (this.token = e)
    /**
     * Stores the listener registered with setChangeListener()
     * This isn't actually necessary since the UID never changes, but we use this
     * to verify the listen contract is adhered to in tests.
     */,
      (this.changeListener = null);
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {}
  start(e, t) {
    (this.changeListener = t), // Fire with initial user.
      e.enqueueRetryable(() => t(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class DN {
  constructor(e) {
    (this.auth = null),
      e.onInit((t) => {
        this.auth = t;
      });
  }
  getToken() {
    return this.auth ? this.auth.getToken().then((e) => (e ? (Es(typeof e.accessToken == 'string'), new Fw(e.accessToken, new Bn(this.auth.getUid()))) : null)) : Promise.resolve(null);
  }
  invalidateToken() {}
  start(e, t) {}
  shutdown() {}
}
class BN {
  constructor(e, t, i) {
    (this.t = e), (this.i = t), (this.o = i), (this.type = 'FirstParty'), (this.user = Bn.FIRST_PARTY), (this.u = /* @__PURE__ */ new Map());
  }
  /**
   * Gets an authorization token, using a provided factory function, or return
   * null.
   */
  h() {
    return this.o ? this.o() : null;
  }
  get headers() {
    this.u.set('X-Goog-AuthUser', this.t);
    const e = this.h();
    return e && this.u.set('Authorization', e), this.i && this.u.set('X-Goog-Iam-Authorization-Token', this.i), this.u;
  }
}
class FN {
  constructor(e, t, i) {
    (this.t = e), (this.i = t), (this.o = i);
  }
  getToken() {
    return Promise.resolve(new BN(this.t, this.i, this.o));
  }
  start(e, t) {
    e.enqueueRetryable(() => t(Bn.FIRST_PARTY));
  }
  shutdown() {}
  invalidateToken() {}
}
class LN {
  constructor(e) {
    (this.value = e), (this.type = 'AppCheck'), (this.headers = /* @__PURE__ */ new Map()), e && e.length > 0 && this.headers.set('x-firebase-appcheck', this.value);
  }
}
class $N {
  constructor(e) {
    (this.l = e),
      (this.appCheck = null),
      e.onInit((t) => {
        this.appCheck = t;
      });
  }
  getToken() {
    return this.appCheck ? this.appCheck.getToken().then((e) => (e ? (Es(typeof e.token == 'string'), new LN(e.token)) : null)) : Promise.resolve(null);
  }
  invalidateToken() {}
  start(e, t) {}
  shutdown() {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UN {
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(e, t, i, r, s, a, o, u) {
    (this.databaseId = e), (this.appId = t), (this.persistenceKey = i), (this.host = r), (this.ssl = s), (this.forceLongPolling = a), (this.autoDetectLongPolling = o), (this.useFetchStreams = u);
  }
}
class cl {
  constructor(e, t) {
    (this.projectId = e), (this.database = t || '(default)');
  }
  static empty() {
    return new cl('', '');
  }
  get isDefaultDatabase() {
    return this.database === '(default)';
  }
  isEqual(e) {
    return e instanceof cl && e.projectId === this.projectId && e.database === this.database;
  }
}
class pl {
  constructor(e, t, i) {
    t === void 0 ? (t = 0) : t > e.length && Pt(), i === void 0 ? (i = e.length - t) : i > e.length - t && Pt(), (this.segments = e), (this.offset = t), (this.len = i);
  }
  get length() {
    return this.len;
  }
  isEqual(e) {
    return pl.comparator(this, e) === 0;
  }
  child(e) {
    const t = this.segments.slice(this.offset, this.limit());
    return (
      e instanceof pl
        ? e.forEach((i) => {
            t.push(i);
          })
        : t.push(e),
      this.construct(t)
    );
  }
  /** The index of one past the last segment of the path. */
  limit() {
    return this.offset + this.length;
  }
  popFirst(e) {
    return (e = e === void 0 ? 1 : e), this.construct(this.segments, this.offset + e, this.length - e);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(e) {
    return this.segments[this.offset + e];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(e) {
    if (e.length < this.length) return !1;
    for (let t = 0; t < this.length; t++) if (this.get(t) !== e.get(t)) return !1;
    return !0;
  }
  isImmediateParentOf(e) {
    if (this.length + 1 !== e.length) return !1;
    for (let t = 0; t < this.length; t++) if (this.get(t) !== e.get(t)) return !1;
    return !0;
  }
  forEach(e) {
    for (let t = this.offset, i = this.limit(); t < i; t++) e(this.segments[t]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(e, t) {
    const i = Math.min(e.length, t.length);
    for (let r = 0; r < i; r++) {
      const s = e.get(r),
        a = t.get(r);
      if (s < a) return -1;
      if (s > a) return 1;
    }
    return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
  }
}
class Jt extends pl {
  construct(e, t, i) {
    return new Jt(e, t, i);
  }
  canonicalString() {
    return this.toArray().join('/');
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Creates a resource path from the given slash-delimited string. If multiple
   * arguments are provided, all components are combined. Leading and trailing
   * slashes from all components are ignored.
   */
  static fromString(...e) {
    const t = [];
    for (const i of e) {
      if (i.indexOf('//') >= 0) throw new oe(pe, `Invalid segment (${i}). Paths must not contain // in them.`);
      t.push(...i.split('/').filter((r) => r.length > 0));
    }
    return new Jt(t);
  }
  static emptyPath() {
    return new Jt([]);
  }
}
const jN = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class Zn extends pl {
  construct(e, t, i) {
    return new Zn(e, t, i);
  }
  /**
   * Returns true if the string could be used as a segment in a field path
   * without escaping.
   */
  static isValidIdentifier(e) {
    return jN.test(e);
  }
  canonicalString() {
    return this.toArray()
      .map((e) => ((e = e.replace(/\\/g, '\\\\').replace(/`/g, '\\`')), Zn.isValidIdentifier(e) || (e = '`' + e + '`'), e))
      .join('.');
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns true if this field references the key of a document.
   */
  isKeyField() {
    return this.length === 1 && this.get(0) === '__name__';
  }
  /**
   * The field designating the key of a document.
   */
  static keyField() {
    return new Zn(['__name__']);
  }
  /**
   * Parses a field string from the given server-formatted string.
   *
   * - Splitting the empty string is not allowed (for now at least).
   * - Empty segments within the string (e.g. if there are two consecutive
   *   separators) are not allowed.
   *
   * TODO(b/37244157): we should make this more strict. Right now, it allows
   * non-identifier path components, even if they aren't escaped.
   */
  static fromServerFormat(e) {
    const t = [];
    let i = '',
      r = 0;
    const s = () => {
      if (i.length === 0) throw new oe(pe, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      t.push(i), (i = '');
    };
    let a = !1;
    for (; r < e.length; ) {
      const o = e[r];
      if (o === '\\') {
        if (r + 1 === e.length) throw new oe(pe, 'Path has trailing escape character: ' + e);
        const u = e[r + 1];
        if (u !== '\\' && u !== '.' && u !== '`') throw new oe(pe, 'Path has invalid escape sequence: ' + e);
        (i += u), (r += 2);
      } else o === '`' ? ((a = !a), r++) : o !== '.' || a ? ((i += o), r++) : (s(), r++);
    }
    if ((s(), a)) throw new oe(pe, 'Unterminated ` in path: ' + e);
    return new Zn(t);
  }
  static emptyPath() {
    return new Zn([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dn {
  constructor(e) {
    this.path = e;
  }
  static fromPath(e) {
    return new dn(Jt.fromString(e));
  }
  static fromName(e) {
    return new dn(Jt.fromString(e).popFirst(5));
  }
  static empty() {
    return new dn(Jt.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  /** Returns true if the document is in the specified collectionId. */
  hasCollectionId(e) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === e;
  }
  /** Returns the collection group (i.e. the name of the parent collection) for this key. */
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  /** Returns the fully qualified path to the parent collection. */
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(e) {
    return e !== null && Jt.comparator(this.path, e.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(e, t) {
    return Jt.comparator(e.path, t.path);
  }
  static isDocumentKey(e) {
    return e.length % 2 == 0;
  }
  /**
   * Creates and returns a new document key with the given segments.
   *
   * @param segments - The segments of the path to the document
   * @returns A new instance of DocumentKey
   */
  static fromSegments(e) {
    return new dn(new Jt(e.slice()));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Lw(n, e, t) {
  if (!t) throw new oe(pe, `Function ${n}() cannot be called with an empty ${e}.`);
}
function Iv(n) {
  if (!dn.isDocumentKey(n)) throw new oe(pe, `Invalid document reference. Document references must have an even number of segments, but ${n} has ${n.length}.`);
}
function Ov(n) {
  if (dn.isDocumentKey(n)) throw new oe(pe, `Invalid collection reference. Collection references must have an odd number of segments, but ${n} has ${n.length}.`);
}
function vp(n) {
  if (n === void 0) return 'undefined';
  if (n === null) return 'null';
  if (typeof n == 'string') return n.length > 20 && (n = `${n.substring(0, 20)}...`), JSON.stringify(n);
  if (typeof n == 'number' || typeof n == 'boolean') return '' + n;
  if (typeof n == 'object') {
    if (n instanceof Array) return 'an array';
    {
      const e =
        /** try to get the constructor name for an object. */
        (function (t) {
          return t.constructor ? t.constructor.name : null;
        })(n);
      return e ? `a custom ${e} object` : 'an object';
    }
  }
  return typeof n == 'function' ? 'a function' : Pt();
}
function Ul(n, e) {
  if (
    ('_delegate' in n && // Unwrap Compat types
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      (n = n._delegate),
    !(n instanceof e))
  ) {
    if (e.name === n.constructor.name) throw new oe(pe, 'Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?');
    {
      const t = vp(n);
      throw new oe(pe, `Expected type '${e.name}', but it was: ${t}`);
    }
  }
  return n;
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let yd = null;
function VN() {
  return yd === null ? (yd = 268435456 + Math.round(2147483648 * Math.random())) : yd++, '0x' + yd.toString(16);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function zN(n) {
  return n == null;
}
function Pc(n) {
  return n === 0 && 1 / n == -1 / 0;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const GN = {
  BatchGetDocuments: 'batchGet',
  Commit: 'commit',
  RunQuery: 'runQuery',
  RunAggregationQuery: 'runAggregationQuery',
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var kv, Ce;
function Pv(n) {
  if (n === void 0) return Q0('RPC_ERROR', 'HTTP error has no status'), Ou;
  switch (n) {
    case 200:
      return Rv;
    case 400:
      return Aa;
    case 401:
      return Zy;
    case 403:
      return MN;
    case 404:
      return CN;
    case 409:
      return RN;
    case 416:
      return IN;
    case 429:
      return _N;
    case 499:
      return EN;
    case 500:
      return Ou;
    case 501:
      return Bw;
    case 503:
      return kN;
    case 504:
      return SN;
    default:
      return n >= 200 && n < 300 ? Rv : n >= 400 && n < 500 ? Aa : n >= 500 && n < 600 ? ON : Ou;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
((Ce = kv || (kv = {}))[(Ce.OK = 0)] = 'OK'),
  (Ce[(Ce.CANCELLED = 1)] = 'CANCELLED'),
  (Ce[(Ce.UNKNOWN = 2)] = 'UNKNOWN'),
  (Ce[(Ce.INVALID_ARGUMENT = 3)] = 'INVALID_ARGUMENT'),
  (Ce[(Ce.DEADLINE_EXCEEDED = 4)] = 'DEADLINE_EXCEEDED'),
  (Ce[(Ce.NOT_FOUND = 5)] = 'NOT_FOUND'),
  (Ce[(Ce.ALREADY_EXISTS = 6)] = 'ALREADY_EXISTS'),
  (Ce[(Ce.PERMISSION_DENIED = 7)] = 'PERMISSION_DENIED'),
  (Ce[(Ce.UNAUTHENTICATED = 16)] = 'UNAUTHENTICATED'),
  (Ce[(Ce.RESOURCE_EXHAUSTED = 8)] = 'RESOURCE_EXHAUSTED'),
  (Ce[(Ce.FAILED_PRECONDITION = 9)] = 'FAILED_PRECONDITION'),
  (Ce[(Ce.ABORTED = 10)] = 'ABORTED'),
  (Ce[(Ce.OUT_OF_RANGE = 11)] = 'OUT_OF_RANGE'),
  (Ce[(Ce.UNIMPLEMENTED = 12)] = 'UNIMPLEMENTED'),
  (Ce[(Ce.INTERNAL = 13)] = 'INTERNAL'),
  (Ce[(Ce.UNAVAILABLE = 14)] = 'UNAVAILABLE'),
  (Ce[(Ce.DATA_LOSS = 15)] = 'DATA_LOSS');
class qN
  /**
   * Base class for all Rest-based connections to the backend (WebChannel and
   * HTTP).
   */
  extends class {
    constructor(e) {
      (this.databaseInfo = e), (this.databaseId = e.databaseId);
      const t = e.ssl ? 'https' : 'http';
      (this.m = t + '://' + e.host), (this.p = 'projects/' + this.databaseId.projectId + '/databases/' + this.databaseId.database + '/documents');
    }
    get g() {
      return !1;
    }
    v(e, t, i, r, s) {
      const a = VN(),
        o = this.A(e, t);
      kc('RestConnection', `Sending RPC '${e}' ${a}:`, o, i);
      const u = {};
      return (
        this.I(u, r, s),
        this.T(e, o, u, i).then(
          (l) => (kc('RestConnection', `Received RPC '${e}' ${a}: `, l), l),
          (l) => {
            throw (Dw('RestConnection', `RPC '${e}' ${a} failed with error: `, l, 'url: ', o, 'request:', i), l);
          },
        )
      );
    }
    R(e, t, i, r, s, a) {
      return this.v(e, t, i, r, s);
    }
    /**
     * Modifies the headers for a request, adding any authorization token if
     * present and any additional headers for the request.
     */
    I(e, t, i) {
      (e['X-Goog-Api-Client'] = 'gl-js/ fire/' + Qo), // Content-Type: text/plain will avoid preflight requests which might
        // mess with CORS and redirects by proxies. If we add custom headers
        // we will need to change this code to potentially use the $httpOverwrite
        // parameter supported by ESF to avoid triggering preflight requests.
        (e['Content-Type'] = 'text/plain'),
        this.databaseInfo.appId && (e['X-Firebase-GMPID'] = this.databaseInfo.appId),
        t && t.headers.forEach((r, s) => (e[s] = r)),
        i && i.headers.forEach((r, s) => (e[s] = r));
    }
    A(e, t) {
      const i = GN[e];
      return `${this.m}/v1/${t}:${i}`;
    }
  }
{
  /**
   * @param databaseInfo - The connection info.
   * @param fetchImpl - `fetch` or a Polyfill that implements the fetch API.
   */
  constructor(e, t) {
    super(e), (this.P = t);
  }
  V(e, t) {
    throw new Error('Not supported by FetchConnection');
  }
  async T(e, t, i, r) {
    var s;
    const a = JSON.stringify(r);
    let o;
    try {
      o = await this.P(t, {
        method: 'POST',
        headers: i,
        body: a,
      });
    } catch (u) {
      const l = u;
      throw new oe(Pv(l.status), 'Request failed with error: ' + l.statusText);
    }
    if (!o.ok) {
      let u = await o.json();
      Array.isArray(u) && (u = u[0]);
      const l = (s = u?.error) === null || s === void 0 ? void 0 : s.message;
      throw new oe(Pv(o.status), `Request failed with error: ${l ?? o.statusText}`);
    }
    return o.json();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function HN(n) {
  const e =
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      typeof self < 'u' && (self.crypto || self.msCrypto),
    t = new Uint8Array(n);
  if (e && typeof e.getRandomValues == 'function') e.getRandomValues(t);
  else for (let i = 0; i < n; i++) t[i] = Math.floor(256 * Math.random());
  return t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class KN {
  static N() {
    const e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',
      t = Math.floor(256 / e.length) * e.length;
    let i = '';
    for (; i.length < 20; ) {
      const r = HN(40);
      for (let s = 0; s < r.length; ++s) i.length < 20 && r[s] < t && (i += e.charAt(r[s] % e.length));
    }
    return i;
  }
}
function Xt(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
function $w(n, e, t) {
  return n.length === e.length && n.every((i, r) => t(i, e[r]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Nv(n) {
  let e = 0;
  for (const t in n) Object.prototype.hasOwnProperty.call(n, t) && e++;
  return e;
}
function jl(n, e) {
  for (const t in n) Object.prototype.hasOwnProperty.call(n, t) && e(t, n[t]);
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WN extends Error {
  constructor() {
    super(...arguments), (this.name = 'Base64DecodeError');
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $r {
  constructor(e) {
    this.binaryString = e;
  }
  static fromBase64String(e) {
    const t = (function (i) {
      try {
        return atob(i);
      } catch (r) {
        throw typeof DOMException < 'u' && r instanceof DOMException ? new WN('Invalid base64 string: ' + r) : r;
      }
    })(e);
    return new $r(t);
  }
  static fromUint8Array(e) {
    const t =
      /**
       * Helper function to convert an Uint8array to a binary string.
       */
      (function (i) {
        let r = '';
        for (let s = 0; s < i.length; ++s) r += String.fromCharCode(i[s]);
        return r;
      })(e);
    return new $r(t);
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () =>
        e < this.binaryString.length
          ? {
              value: this.binaryString.charCodeAt(e++),
              done: !1,
            }
          : {
              value: void 0,
              done: !0,
            },
    };
  }
  toBase64() {
    return (e = this.binaryString), btoa(e);
    var e;
  }
  toUint8Array() {
    return (function (e) {
      const t = new Uint8Array(e.length);
      for (let i = 0; i < e.length; i++) t[i] = e.charCodeAt(i);
      return t;
    })(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(e) {
    return Xt(this.binaryString, e.binaryString);
  }
  isEqual(e) {
    return this.binaryString === e.binaryString;
  }
}
$r.EMPTY_BYTE_STRING = new $r('');
const JN = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Ea(n) {
  if ((Es(!!n), typeof n == 'string')) {
    let e = 0;
    const t = JN.exec(n);
    if ((Es(!!t), t[1])) {
      let r = t[1];
      (r = (r + '000000000').substr(0, 9)), (e = Number(r));
    }
    const i = new Date(n);
    return {
      seconds: Math.floor(i.getTime() / 1e3),
      nanos: e,
    };
  }
  return {
    seconds: Kt(n.seconds),
    nanos: Kt(n.nanos),
  };
}
function Kt(n) {
  return typeof n == 'number' ? n : typeof n == 'string' ? Number(n) : 0;
}
function fl(n) {
  return typeof n == 'string' ? $r.fromBase64String(n) : $r.fromUint8Array(n);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Un {
  /**
   * Creates a new timestamp.
   *
   * @param seconds - The number of seconds of UTC time since Unix epoch
   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   *     9999-12-31T23:59:59Z inclusive.
   * @param nanoseconds - The non-negative fractions of a second at nanosecond
   *     resolution. Negative second values with fractions must still have
   *     non-negative nanoseconds values that count forward in time. Must be
   *     from 0 to 999,999,999 inclusive.
   */
  constructor(e, t) {
    if (((this.seconds = e), (this.nanoseconds = t), t < 0)) throw new oe(pe, 'Timestamp nanoseconds out of range: ' + t);
    if (t >= 1e9) throw new oe(pe, 'Timestamp nanoseconds out of range: ' + t);
    if (e < -62135596800) throw new oe(pe, 'Timestamp seconds out of range: ' + e);
    if (e >= 253402300800) throw new oe(pe, 'Timestamp seconds out of range: ' + e);
  }
  /**
   * Creates a new timestamp with the current date, with millisecond precision.
   *
   * @returns a new timestamp representing the current date.
   */
  static now() {
    return Un.fromMillis(Date.now());
  }
  /**
   * Creates a new timestamp from the given date.
   *
   * @param date - The date to initialize the `Timestamp` from.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     date.
   */
  static fromDate(e) {
    return Un.fromMillis(e.getTime());
  }
  /**
   * Creates a new timestamp from the given number of milliseconds.
   *
   * @param milliseconds - Number of milliseconds since Unix epoch
   *     1970-01-01T00:00:00Z.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     number of milliseconds.
   */
  static fromMillis(e) {
    const t = Math.floor(e / 1e3),
      i = Math.floor(1e6 * (e - 1e3 * t));
    return new Un(t, i);
  }
  /**
   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
   * causes a loss of precision since `Date` objects only support millisecond
   * precision.
   *
   * @returns JavaScript `Date` object representing the same point in time as
   *     this `Timestamp`, with millisecond precision.
   */
  toDate() {
    return new Date(this.toMillis());
  }
  /**
   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
   * epoch). This operation causes a loss of precision.
   *
   * @returns The point in time corresponding to this timestamp, represented as
   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
   */
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(e) {
    return this.seconds === e.seconds ? Xt(this.nanoseconds, e.nanoseconds) : Xt(this.seconds, e.seconds);
  }
  /**
   * Returns true if this `Timestamp` is equal to the provided one.
   *
   * @param other - The `Timestamp` to compare against.
   * @returns true if this `Timestamp` is equal to the provided one.
   */
  isEqual(e) {
    return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
  }
  /** Returns a textual representation of this `Timestamp`. */
  toString() {
    return 'Timestamp(seconds=' + this.seconds + ', nanoseconds=' + this.nanoseconds + ')';
  }
  /** Returns a JSON-serializable representation of this `Timestamp`. */
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds,
    };
  }
  /**
   * Converts this object to a primitive string, which allows `Timestamp` objects
   * to be compared using the `>`, `<=`, `>=` and `>` operators.
   */
  valueOf() {
    const e = this.seconds - -62135596800;
    return String(e).padStart(12, '0') + '.' + String(this.nanoseconds).padStart(9, '0');
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Uw(n) {
  var e, t;
  return ((t = (((e = n?.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || t === void 0 ? void 0 : t.stringValue) === 'server_timestamp';
}
function jw(n) {
  const e = n.mapValue.fields.__previous_value__;
  return Uw(e) ? jw(e) : e;
}
function yl(n) {
  const e = Ea(n.mapValue.fields.__local_write_time__.timestampValue);
  return new Un(e.seconds, e.nanos);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const hd = {
  fields: {
    __type__: {
      stringValue: '__max__',
    },
  },
};
function Sa(n) {
  return 'nullValue' in n
    ? 0
    : 'booleanValue' in n
    ? 1
    : 'integerValue' in n || 'doubleValue' in n
    ? 2
    : 'timestampValue' in n
    ? 3
    : 'stringValue' in n
    ? 5
    : 'bytesValue' in n
    ? 6
    : 'referenceValue' in n
    ? 7
    : 'geoPointValue' in n
    ? 8
    : 'arrayValue' in n
    ? 9
    : 'mapValue' in n
    ? Uw(n)
      ? 4
      : /** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */
      (function (e) {
          return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === '__max__';
        })(n)
      ? 9007199254740991
      : 10
    : Pt();
}
function Nc(n, e) {
  if (n === e) return !0;
  const t = Sa(n);
  if (t !== Sa(e)) return !1;
  switch (t) {
    case 0:
    case 9007199254740991:
      return !0;
    case 1:
      return n.booleanValue === e.booleanValue;
    case 4:
      return yl(n).isEqual(yl(e));
    case 3:
      return (function (i, r) {
        if (typeof i.timestampValue == 'string' && typeof r.timestampValue == 'string' && i.timestampValue.length === r.timestampValue.length) return i.timestampValue === r.timestampValue;
        const s = Ea(i.timestampValue),
          a = Ea(r.timestampValue);
        return s.seconds === a.seconds && s.nanos === a.nanos;
      })(n, e);
    case 5:
      return n.stringValue === e.stringValue;
    case 6:
      return (function (i, r) {
        return fl(i.bytesValue).isEqual(fl(r.bytesValue));
      })(n, e);
    case 7:
      return n.referenceValue === e.referenceValue;
    case 8:
      return (function (i, r) {
        return Kt(i.geoPointValue.latitude) === Kt(r.geoPointValue.latitude) && Kt(i.geoPointValue.longitude) === Kt(r.geoPointValue.longitude);
      })(n, e);
    case 2:
      return (function (i, r) {
        if ('integerValue' in i && 'integerValue' in r) return Kt(i.integerValue) === Kt(r.integerValue);
        if ('doubleValue' in i && 'doubleValue' in r) {
          const s = Kt(i.doubleValue),
            a = Kt(r.doubleValue);
          return s === a ? Pc(s) === Pc(a) : isNaN(s) && isNaN(a);
        }
        return !1;
      })(n, e);
    case 9:
      return $w(n.arrayValue.values || [], e.arrayValue.values || [], Nc);
    case 10:
      return (function (i, r) {
        const s = i.mapValue.fields || {},
          a = r.mapValue.fields || {};
        if (Nv(s) !== Nv(a)) return !1;
        for (const o in s) if (s.hasOwnProperty(o) && (a[o] === void 0 || !Nc(s[o], a[o]))) return !1;
        return !0;
      })(n, e);
    default:
      return Pt();
  }
}
function hl(n, e) {
  return (n.values || []).find((t) => Nc(t, e)) !== void 0;
}
function Dc(n, e) {
  if (n === e) return 0;
  const t = Sa(n),
    i = Sa(e);
  if (t !== i) return Xt(t, i);
  switch (t) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return Xt(n.booleanValue, e.booleanValue);
    case 2:
      return (function (r, s) {
        const a = Kt(r.integerValue || r.doubleValue),
          o = Kt(s.integerValue || s.doubleValue);
        return a < o
          ? -1
          : a > o
          ? 1
          : a === o
          ? 0
          : // one or both are NaN.
          isNaN(a)
          ? isNaN(o)
            ? 0
            : -1
          : 1;
      })(n, e);
    case 3:
      return Dv(n.timestampValue, e.timestampValue);
    case 4:
      return Dv(yl(n), yl(e));
    case 5:
      return Xt(n.stringValue, e.stringValue);
    case 6:
      return (function (r, s) {
        const a = fl(r),
          o = fl(s);
        return a.compareTo(o);
      })(n.bytesValue, e.bytesValue);
    case 7:
      return (function (r, s) {
        const a = r.split('/'),
          o = s.split('/');
        for (let u = 0; u < a.length && u < o.length; u++) {
          const l = Xt(a[u], o[u]);
          if (l !== 0) return l;
        }
        return Xt(a.length, o.length);
      })(n.referenceValue, e.referenceValue);
    case 8:
      return (function (r, s) {
        const a = Xt(Kt(r.latitude), Kt(s.latitude));
        return a !== 0 ? a : Xt(Kt(r.longitude), Kt(s.longitude));
      })(n.geoPointValue, e.geoPointValue);
    case 9:
      return (function (r, s) {
        const a = r.values || [],
          o = s.values || [];
        for (let u = 0; u < a.length && u < o.length; ++u) {
          const l = Dc(a[u], o[u]);
          if (l) return l;
        }
        return Xt(a.length, o.length);
      })(n.arrayValue, e.arrayValue);
    case 10:
      return (function (r, s) {
        if (r === hd && s === hd) return 0;
        if (r === hd) return 1;
        if (s === hd) return -1;
        const a = r.fields || {},
          o = Object.keys(a),
          u = s.fields || {},
          l = Object.keys(u);
        o.sort(), l.sort();
        for (let c = 0; c < o.length && c < l.length; ++c) {
          const f = Xt(o[c], l[c]);
          if (f !== 0) return f;
          const m = Dc(a[o[c]], u[l[c]]);
          if (m !== 0) return m;
        }
        return Xt(o.length, l.length);
      })(n.mapValue, e.mapValue);
    default:
      throw Pt();
  }
}
function Dv(n, e) {
  if (typeof n == 'string' && typeof e == 'string' && n.length === e.length) return Xt(n, e);
  const t = Ea(n),
    i = Ea(e),
    r = Xt(t.seconds, i.seconds);
  return r !== 0 ? r : Xt(t.nanos, i.nanos);
}
function Bv(n, e) {
  return {
    referenceValue: `projects/${n.projectId}/databases/${n.database}/documents/${e.path.canonicalString()}`,
  };
}
function Vw(n) {
  return !!n && 'arrayValue' in n;
}
function Fv(n) {
  return !!n && 'nullValue' in n;
}
function Lv(n) {
  return !!n && 'doubleValue' in n && isNaN(Number(n.doubleValue));
}
function Vf(n) {
  return !!n && 'mapValue' in n;
}
function ku(n) {
  if (n.geoPointValue)
    return {
      geoPointValue: Object.assign({}, n.geoPointValue),
    };
  if (n.timestampValue && typeof n.timestampValue == 'object')
    return {
      timestampValue: Object.assign({}, n.timestampValue),
    };
  if (n.mapValue) {
    const e = {
      mapValue: {
        fields: {},
      },
    };
    return jl(n.mapValue.fields, (t, i) => (e.mapValue.fields[t] = ku(i))), e;
  }
  if (n.arrayValue) {
    const e = {
      arrayValue: {
        values: [],
      },
    };
    for (let t = 0; t < (n.arrayValue.values || []).length; ++t) e.arrayValue.values[t] = ku(n.arrayValue.values[t]);
    return e;
  }
  return Object.assign({}, n);
}
class $v {
  constructor(e, t) {
    (this.position = e), (this.inclusive = t);
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zw {}
class $i extends zw {
  constructor(e, t, i) {
    super(), (this.field = e), (this.op = t), (this.value = i);
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, t, i) {
    return e.isKeyField()
      ? t === 'in' || t === 'not-in'
        ? this.createKeyFieldInFilter(e, t, i)
        : new QN(e, t, i)
      : t === 'array-contains'
      ? new ZN(e, i)
      : t === 'in'
      ? new eD(e, i)
      : t === 'not-in'
      ? new tD(e, i)
      : t === 'array-contains-any'
      ? new nD(e, i)
      : new $i(e, t, i);
  }
  static createKeyFieldInFilter(e, t, i) {
    return t === 'in' ? new YN(e, i) : new XN(e, i);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return this.op === '!=' ? t !== null && this.matchesComparison(Dc(t, this.value)) : t !== null && Sa(this.value) === Sa(t) && this.matchesComparison(Dc(t, this.value));
  }
  matchesComparison(e) {
    switch (this.op) {
      case '<':
        return e < 0;
      case '<=':
        return e <= 0;
      case '==':
        return e === 0;
      case '!=':
        return e !== 0;
      case '>':
        return e > 0;
      case '>=':
        return e >= 0;
      default:
        return Pt();
    }
  }
  isInequality() {
    return (
      [
        '<',
        '<=',
        '>',
        '>=',
        '!=',
        'not-in',
        /* Operator.NOT_IN */
      ].indexOf(this.op) >= 0
    );
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
  getFirstInequalityField() {
    return this.isInequality() ? this.field : null;
  }
}
class Vl extends zw {
  constructor(e, t) {
    super(), (this.filters = e), (this.op = t), (this.F = null);
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, t) {
    return new Vl(e, t);
  }
  matches(e) {
    return this.op === 'and' ? this.filters.find((t) => !t.matches(e)) === void 0 : this.filters.find((t) => t.matches(e)) !== void 0;
  }
  getFlattenedFilters() {
    return this.F !== null || (this.F = this.filters.reduce((e, t) => e.concat(t.getFlattenedFilters()), [])), this.F;
  }
  // Returns a mutable copy of `this.filters`
  getFilters() {
    return Object.assign([], this.filters);
  }
  getFirstInequalityField() {
    const e = this.S((t) => t.isInequality());
    return e !== null ? e.field : null;
  }
  // Performs a depth-first search to find and return the first FieldFilter in the composite filter
  // that satisfies the predicate. Returns `null` if none of the FieldFilters satisfy the
  // predicate.
  S(e) {
    for (const t of this.getFlattenedFilters()) if (e(t)) return t;
    return null;
  }
}
class QN extends $i {
  constructor(e, t, i) {
    super(e, t, i), (this.key = dn.fromName(i.referenceValue));
  }
  matches(e) {
    const t = dn.comparator(e.key, this.key);
    return this.matchesComparison(t);
  }
}
class YN extends $i {
  constructor(e, t) {
    super(e, 'in', t), (this.keys = Gw('in', t));
  }
  matches(e) {
    return this.keys.some((t) => t.isEqual(e.key));
  }
}
class XN extends $i {
  constructor(e, t) {
    super(e, 'not-in', t), (this.keys = Gw('not-in', t));
  }
  matches(e) {
    return !this.keys.some((t) => t.isEqual(e.key));
  }
}
function Gw(n, e) {
  var t;
  return (((t = e.arrayValue) === null || t === void 0 ? void 0 : t.values) || []).map((i) => dn.fromName(i.referenceValue));
}
class ZN extends $i {
  constructor(e, t) {
    super(e, 'array-contains', t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return Vw(t) && hl(t.arrayValue, this.value);
  }
}
class eD extends $i {
  constructor(e, t) {
    super(e, 'in', t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return t !== null && hl(this.value.arrayValue, t);
  }
}
class tD extends $i {
  constructor(e, t) {
    super(e, 'not-in', t);
  }
  matches(e) {
    if (
      hl(this.value.arrayValue, {
        nullValue: 'NULL_VALUE',
      })
    )
      return !1;
    const t = e.data.field(this.field);
    return t !== null && !hl(this.value.arrayValue, t);
  }
}
class nD extends $i {
  constructor(e, t) {
    super(e, 'array-contains-any', t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return !(!Vw(t) || !t.arrayValue.values) && t.arrayValue.values.some((i) => hl(this.value.arrayValue, i));
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pu {
  constructor(e, t = 'asc') {
    (this.field = e), (this.dir = t);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class mn {
  constructor(e) {
    this.timestamp = e;
  }
  static fromTimestamp(e) {
    return new mn(e);
  }
  static min() {
    return new mn(new Un(0, 0));
  }
  static max() {
    return new mn(new Un(253402300799, 999999999));
  }
  compareTo(e) {
    return this.timestamp._compareTo(e.timestamp);
  }
  isEqual(e) {
    return this.timestamp.isEqual(e.timestamp);
  }
  /** Returns a number representation of the version for use in spec tests. */
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return 'SnapshotVersion(' + this.timestamp.toString() + ')';
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bc {
  constructor(e, t) {
    (this.comparator = e), (this.root = t || on.EMPTY);
  }
  // Returns a copy of the map, with the specified key/value added or replaced.
  insert(e, t) {
    return new Bc(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, on.BLACK, null, null));
  }
  // Returns a copy of the map, with the specified key removed.
  remove(e) {
    return new Bc(this.comparator, this.root.remove(e, this.comparator).copy(null, null, on.BLACK, null, null));
  }
  // Returns the value of the node with the given key, or null.
  get(e) {
    let t = this.root;
    for (; !t.isEmpty(); ) {
      const i = this.comparator(e, t.key);
      if (i === 0) return t.value;
      i < 0 ? (t = t.left) : i > 0 && (t = t.right);
    }
    return null;
  }
  // Returns the index of the element in this sorted map, or -1 if it doesn't
  // exist.
  indexOf(e) {
    let t = 0,
      i = this.root;
    for (; !i.isEmpty(); ) {
      const r = this.comparator(e, i.key);
      if (r === 0) return t + i.left.size;
      r < 0
        ? (i = i.left)
        : // Count all nodes left of the node plus the node itself
          ((t += i.left.size + 1), (i = i.right));
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  // Returns the total number of nodes in the map.
  get size() {
    return this.root.size;
  }
  // Returns the minimum key in the map.
  minKey() {
    return this.root.minKey();
  }
  // Returns the maximum key in the map.
  maxKey() {
    return this.root.maxKey();
  }
  // Traverses the map in key order and calls the specified action function
  // for each key/value pair. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.root.inorderTraversal(e);
  }
  forEach(e) {
    this.inorderTraversal((t, i) => (e(t, i), !1));
  }
  toString() {
    const e = [];
    return this.inorderTraversal((t, i) => (e.push(`${t}:${i}`), !1)), `{${e.join(', ')}}`;
  }
  // Traverses the map in reverse key order and calls the specified action
  // function for each key/value pair. If action returns true, traversal is
  // aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.root.reverseTraversal(e);
  }
  // Returns an iterator over the SortedMap.
  getIterator() {
    return new md(this.root, null, this.comparator, !1);
  }
  getIteratorFrom(e) {
    return new md(this.root, e, this.comparator, !1);
  }
  getReverseIterator() {
    return new md(this.root, null, this.comparator, !0);
  }
  getReverseIteratorFrom(e) {
    return new md(this.root, e, this.comparator, !0);
  }
}
class md {
  constructor(e, t, i, r) {
    (this.isReverse = r), (this.nodeStack = []);
    let s = 1;
    for (; !e.isEmpty(); )
      if (
        ((s = t ? i(e.key, t) : 1), // flip the comparison if we're going in reverse
        t && r && (s *= -1),
        s < 0)
      )
        e = this.isReverse ? e.left : e.right;
      else {
        if (s === 0) {
          this.nodeStack.push(e);
          break;
        }
        this.nodeStack.push(e), (e = this.isReverse ? e.right : e.left);
      }
  }
  getNext() {
    let e = this.nodeStack.pop();
    const t = {
      key: e.key,
      value: e.value,
    };
    if (this.isReverse) for (e = e.left; !e.isEmpty(); ) this.nodeStack.push(e), (e = e.right);
    else for (e = e.right; !e.isEmpty(); ) this.nodeStack.push(e), (e = e.left);
    return t;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0) return null;
    const e = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: e.key,
      value: e.value,
    };
  }
}
class on {
  constructor(e, t, i, r, s) {
    (this.key = e), (this.value = t), (this.color = i ?? on.RED), (this.left = r ?? on.EMPTY), (this.right = s ?? on.EMPTY), (this.size = this.left.size + 1 + this.right.size);
  }
  // Returns a copy of the current node, optionally replacing pieces of it.
  copy(e, t, i, r, s) {
    return new on(e ?? this.key, t ?? this.value, i ?? this.color, r ?? this.left, s ?? this.right);
  }
  isEmpty() {
    return !1;
  }
  // Traverses the tree in key order and calls the specified action function
  // for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e);
  }
  // Traverses the tree in reverse key order and calls the specified action
  // function for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
  }
  // Returns the minimum node in the tree.
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  // Returns the maximum key in the tree.
  minKey() {
    return this.min().key;
  }
  // Returns the maximum key in the tree.
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  // Returns new tree, with the key/value added.
  insert(e, t, i) {
    let r = this;
    const s = i(e, r.key);
    return (r = s < 0 ? r.copy(null, null, null, r.left.insert(e, t, i), null) : s === 0 ? r.copy(null, t, null, null, null) : r.copy(null, null, null, null, r.right.insert(e, t, i))), r.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty()) return on.EMPTY;
    let e = this;
    return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), (e = e.copy(null, null, null, e.left.removeMin(), null)), e.fixUp();
  }
  // Returns new tree, with the specified item removed.
  remove(e, t) {
    let i,
      r = this;
    if (t(e, r.key) < 0) r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), (r = r.copy(null, null, null, r.left.remove(e, t), null));
    else {
      if ((r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), t(e, r.key) === 0)) {
        if (r.right.isEmpty()) return on.EMPTY;
        (i = r.right.min()), (r = r.copy(i.key, i.value, null, null, r.right.removeMin()));
      }
      r = r.copy(null, null, null, null, r.right.remove(e, t));
    }
    return r.fixUp();
  }
  isRed() {
    return this.color;
  }
  // Returns new tree after performing any needed rotations.
  fixUp() {
    let e = this;
    return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e;
  }
  moveRedLeft() {
    let e = this.colorFlip();
    return e.right.left.isRed() && ((e = e.copy(null, null, null, null, e.right.rotateRight())), (e = e.rotateLeft()), (e = e.colorFlip())), e;
  }
  moveRedRight() {
    let e = this.colorFlip();
    return e.left.left.isRed() && ((e = e.rotateRight()), (e = e.colorFlip())), e;
  }
  rotateLeft() {
    const e = this.copy(null, null, on.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, e, null);
  }
  rotateRight() {
    const e = this.copy(null, null, on.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, e);
  }
  colorFlip() {
    const e = this.left.copy(null, null, !this.left.color, null, null),
      t = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, e, t);
  }
  // For testing.
  checkMaxDepth() {
    const e = this.check();
    return Math.pow(2, e) <= this.size + 1;
  }
  // In a balanced RB tree, the black-depth (number of black nodes) from root to
  // leaves is equal on both sides.  This function verifies that or asserts.
  check() {
    if ((this.isRed() && this.left.isRed()) || this.right.isRed()) throw Pt();
    const e = this.left.check();
    if (e !== this.right.check()) throw Pt();
    return e + (this.isRed() ? 0 : 1);
  }
}
(on.EMPTY = null), (on.RED = !0), (on.BLACK = !1);
on.EMPTY = new // Represents an empty node (a leaf node in the Red-Black Tree).
(class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw Pt();
  }
  get value() {
    throw Pt();
  }
  get color() {
    throw Pt();
  }
  get left() {
    throw Pt();
  }
  get right() {
    throw Pt();
  }
  // Returns a copy of the current node.
  copy(n, e, t, i, r) {
    return this;
  }
  // Returns a copy of the tree, with the specified key/value added.
  insert(n, e, t) {
    return new on(n, e);
  }
  // Returns a copy of the tree, with the specified key removed.
  remove(n, e) {
    return this;
  }
  isEmpty() {
    return !0;
  }
  inorderTraversal(n) {
    return !1;
  }
  reverseTraversal(n) {
    return !1;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return !1;
  }
  // For testing.
  checkMaxDepth() {
    return !0;
  }
  check() {
    return 0;
  }
})();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Fc {
  constructor(e) {
    (this.comparator = e), (this.data = new Bc(this.comparator));
  }
  has(e) {
    return this.data.get(e) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(e) {
    return this.data.indexOf(e);
  }
  /** Iterates elements in order defined by "comparator" */
  forEach(e) {
    this.data.inorderTraversal((t, i) => (e(t), !1));
  }
  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
  forEachInRange(e, t) {
    const i = this.data.getIteratorFrom(e[0]);
    for (; i.hasNext(); ) {
      const r = i.getNext();
      if (this.comparator(r.key, e[1]) >= 0) return;
      t(r.key);
    }
  }
  /**
   * Iterates over `elem`s such that: start &lt;= elem until false is returned.
   */
  forEachWhile(e, t) {
    let i;
    for (i = t !== void 0 ? this.data.getIteratorFrom(t) : this.data.getIterator(); i.hasNext(); ) if (!e(i.getNext().key)) return;
  }
  /** Finds the least element greater than or equal to `elem`. */
  firstAfterOrEqual(e) {
    const t = this.data.getIteratorFrom(e);
    return t.hasNext() ? t.getNext().key : null;
  }
  getIterator() {
    return new Uv(this.data.getIterator());
  }
  getIteratorFrom(e) {
    return new Uv(this.data.getIteratorFrom(e));
  }
  /** Inserts or updates an element */
  add(e) {
    return this.copy(this.data.remove(e).insert(e, !0));
  }
  /** Deletes an element */
  delete(e) {
    return this.has(e) ? this.copy(this.data.remove(e)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(e) {
    let t = this;
    return (
      t.size < e.size && ((t = e), (e = this)),
      e.forEach((i) => {
        t = t.add(i);
      }),
      t
    );
  }
  isEqual(e) {
    if (!(e instanceof Fc) || this.size !== e.size) return !1;
    const t = this.data.getIterator(),
      i = e.data.getIterator();
    for (; t.hasNext(); ) {
      const r = t.getNext().key,
        s = i.getNext().key;
      if (this.comparator(r, s) !== 0) return !1;
    }
    return !0;
  }
  toArray() {
    const e = [];
    return (
      this.forEach((t) => {
        e.push(t);
      }),
      e
    );
  }
  toString() {
    const e = [];
    return this.forEach((t) => e.push(t)), 'SortedSet(' + e.toString() + ')';
  }
  copy(e) {
    const t = new Fc(this.comparator);
    return (t.data = e), t;
  }
}
class Uv {
  constructor(e) {
    this.iter = e;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ca {
  constructor(e) {
    (this.fields = e), // TODO(dimond): validation of FieldMask
      // Sort the field mask to support `FieldMask.isEqual()` and assert below.
      e.sort(Zn.comparator);
  }
  static empty() {
    return new Ca([]);
  }
  /**
   * Returns a new FieldMask object that is the result of adding all the given
   * fields paths to this field mask.
   */
  unionWith(e) {
    let t = new Fc(Zn.comparator);
    for (const i of this.fields) t = t.add(i);
    for (const i of e) t = t.add(i);
    return new Ca(t.toArray());
  }
  /**
   * Verifies that `fieldPath` is included by at least one field in this field
   * mask.
   *
   * This is an O(n) operation, where `n` is the size of the field mask.
   */
  covers(e) {
    for (const t of this.fields) if (t.isPrefixOf(e)) return !0;
    return !1;
  }
  isEqual(e) {
    return $w(this.fields, e.fields, (t, i) => t.isEqual(i));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class di {
  constructor(e) {
    this.value = e;
  }
  static empty() {
    return new di({
      mapValue: {},
    });
  }
  /**
   * Returns the value at the given path or null.
   *
   * @param path - the path to search
   * @returns The value at the path or null if the path is not set.
   */
  field(e) {
    if (e.isEmpty()) return this.value;
    {
      let t = this.value;
      for (let i = 0; i < e.length - 1; ++i) if (((t = (t.mapValue.fields || {})[e.get(i)]), !Vf(t))) return null;
      return (t = (t.mapValue.fields || {})[e.lastSegment()]), t || null;
    }
  }
  /**
   * Sets the field to the provided value.
   *
   * @param path - The field path to set.
   * @param value - The value to set.
   */
  set(e, t) {
    this.getFieldsMap(e.popLast())[e.lastSegment()] = ku(t);
  }
  /**
   * Sets the provided fields to the provided values.
   *
   * @param data - A map of fields to values (or null for deletes).
   */
  setAll(e) {
    let t = Zn.emptyPath(),
      i = {},
      r = [];
    e.forEach((a, o) => {
      if (!t.isImmediateParentOf(o)) {
        const u = this.getFieldsMap(t);
        this.applyChanges(u, i, r), (i = {}), (r = []), (t = o.popLast());
      }
      a ? (i[o.lastSegment()] = ku(a)) : r.push(o.lastSegment());
    });
    const s = this.getFieldsMap(t);
    this.applyChanges(s, i, r);
  }
  /**
   * Removes the field at the specified path. If there is no field at the
   * specified path, nothing is changed.
   *
   * @param path - The field path to remove.
   */
  delete(e) {
    const t = this.field(e.popLast());
    Vf(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()];
  }
  isEqual(e) {
    return Nc(this.value, e.value);
  }
  /**
   * Returns the map that contains the leaf element of `path`. If the parent
   * entry does not yet exist, or if it is not a map, a new map will be created.
   */
  getFieldsMap(e) {
    let t = this.value;
    t.mapValue.fields ||
      (t.mapValue = {
        fields: {},
      });
    for (let i = 0; i < e.length; ++i) {
      let r = t.mapValue.fields[e.get(i)];
      (Vf(r) && r.mapValue.fields) ||
        ((r = {
          mapValue: {
            fields: {},
          },
        }),
        (t.mapValue.fields[e.get(i)] = r)),
        (t = r);
    }
    return t.mapValue.fields;
  }
  /**
   * Modifies `fieldsMap` by adding, replacing or deleting the specified
   * entries.
   */
  applyChanges(e, t, i) {
    jl(t, (r, s) => (e[r] = s));
    for (const r of i) delete e[r];
  }
  clone() {
    return new di(ku(this.value));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class us {
  constructor(e, t, i, r, s, a, o) {
    (this.key = e), (this.documentType = t), (this.version = i), (this.readTime = r), (this.createTime = s), (this.data = a), (this.documentState = o);
  }
  /**
   * Creates a document with no known version or data, but which can serve as
   * base document for mutations.
   */
  static newInvalidDocument(e) {
    return new us(
      e,
      0,
      /* version */
      mn.min(),
      /* readTime */
      mn.min(),
      /* createTime */
      mn.min(),
      di.empty(),
      0,
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist with the given data at the
   * given version.
   */
  static newFoundDocument(e, t, i, r) {
    return new us(
      e,
      1,
      /* version */
      t,
      /* readTime */
      mn.min(),
      /* createTime */
      i,
      r,
      0,
      /* DocumentState.SYNCED */
    );
  }
  /** Creates a new document that is known to not exist at the given version. */
  static newNoDocument(e, t) {
    return new us(
      e,
      2,
      /* version */
      t,
      /* readTime */
      mn.min(),
      /* createTime */
      mn.min(),
      di.empty(),
      0,
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist at the given version but
   * whose data is not known (e.g. a document that was updated without a known
   * base document).
   */
  static newUnknownDocument(e, t) {
    return new us(
      e,
      3,
      /* version */
      t,
      /* readTime */
      mn.min(),
      /* createTime */
      mn.min(),
      di.empty(),
      2,
      /* DocumentState.HAS_COMMITTED_MUTATIONS */
    );
  }
  /**
   * Changes the document type to indicate that it exists and that its version
   * and data are known.
   */
  convertToFoundDocument(e, t) {
    return (
      !this.createTime.isEqual(mn.min()) || (this.documentType !== 2 && this.documentType !== 0) || (this.createTime = e),
      (this.version = e),
      (this.documentType = 1),
      (this.data = t),
      (this.documentState = 0),
      this
    );
  }
  /**
   * Changes the document type to indicate that it doesn't exist at the given
   * version.
   */
  convertToNoDocument(e) {
    return (this.version = e), (this.documentType = 2), (this.data = di.empty()), (this.documentState = 0), this;
  }
  /**
   * Changes the document type to indicate that it exists at a given version but
   * that its data is not known (e.g. a document that was updated without a known
   * base document).
   */
  convertToUnknownDocument(e) {
    return (this.version = e), (this.documentType = 3), (this.data = di.empty()), (this.documentState = 2), this;
  }
  setHasCommittedMutations() {
    return (this.documentState = 2), this;
  }
  setHasLocalMutations() {
    return (this.documentState = 1), (this.version = mn.min()), this;
  }
  setReadTime(e) {
    return (this.readTime = e), this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(e) {
    return e instanceof us && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data);
  }
  mutableCopy() {
    return new us(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${
      this.documentState
    }})`;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class iD {
  constructor(e, t = null, i = [], r = [], s = null, a = null, o = null) {
    (this.path = e), (this.collectionGroup = t), (this.orderBy = i), (this.filters = r), (this.limit = s), (this.startAt = a), (this.endAt = o), (this.q = null);
  }
}
function jv(n, e = null, t = [], i = [], r = null, s = null, a = null) {
  return new iD(n, e, t, i, r, s, a);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class X0 {
  /**
   * Initializes a Query with a path and optional additional query constraints.
   * Path must currently be empty if this is a collection group query.
   */
  constructor(e, t = null, i = [], r = [], s = null, a = 'F', o = null, u = null) {
    (this.path = e),
      (this.collectionGroup = t),
      (this.explicitOrderBy = i),
      (this.filters = r),
      (this.limit = s),
      (this.limitType = a),
      (this.startAt = o),
      (this.endAt = u),
      (this.O = null), // The corresponding `Target` of this `Query` instance.
      (this.k = null),
      this.startAt,
      this.endAt;
  }
}
function Z0(n) {
  return n.explicitOrderBy.length > 0 ? n.explicitOrderBy[0].field : null;
}
function xp(n) {
  for (const e of n.filters) {
    const t = e.getFirstInequalityField();
    if (t !== null) return t;
  }
  return null;
}
function rD(n) {
  return n.collectionGroup !== null;
}
function Vv(n) {
  const e = gp(n);
  if (e.O === null) {
    e.O = [];
    const t = xp(e),
      i = Z0(e);
    if (t !== null && i === null)
      t.isKeyField() || e.O.push(new Pu(t)),
        e.O.push(
          new Pu(
            Zn.keyField(),
            'asc',
            /* Direction.ASCENDING */
          ),
        );
    else {
      let r = !1;
      for (const s of e.explicitOrderBy) e.O.push(s), s.field.isKeyField() && (r = !0);
      if (!r) {
        const s = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : 'asc';
        e.O.push(new Pu(Zn.keyField(), s));
      }
    }
  }
  return e.O;
}
function sD(n) {
  const e = gp(n);
  if (!e.k)
    if (e.limitType === 'F') e.k = jv(e.path, e.collectionGroup, Vv(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t = [];
      for (const s of Vv(e)) {
        const a = s.dir === 'desc' ? 'asc' : 'desc';
        t.push(new Pu(s.field, a));
      }
      const i = e.endAt ? new $v(e.endAt.position, e.endAt.inclusive) : null,
        r = e.startAt ? new $v(e.startAt.position, e.startAt.inclusive) : null;
      e.k = jv(e.path, e.collectionGroup, t, e.filters, e.limit, i, r);
    }
  return e.k;
}
function eh(n, e) {
  e.getFirstInequalityField(), xp(n);
  const t = n.filters.concat([e]);
  return new X0(n.path, n.collectionGroup, n.explicitOrderBy.slice(), t, n.limit, n.limitType, n.startAt, n.endAt);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function aD(n, e) {
  return (function (t) {
    return typeof t == 'number' && Number.isInteger(t) && !Pc(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER;
  })(e)
    ? /**
       * Returns an IntegerValue for `value`.
       */
      (function (t) {
        return {
          integerValue: '' + t,
        };
      })(e)
    : (function (t, i) {
        if (t.useProto3Json) {
          if (isNaN(i))
            return {
              doubleValue: 'NaN',
            };
          if (i === 1 / 0)
            return {
              doubleValue: 'Infinity',
            };
          if (i === -1 / 0)
            return {
              doubleValue: '-Infinity',
            };
        }
        return {
          doubleValue: Pc(i) ? '-0' : i,
        };
      })(n, e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Tp {
  constructor() {
    this._ = void 0;
  }
}
class oD extends Tp {}
class uD extends Tp {
  constructor(e) {
    super(), (this.elements = e);
  }
}
class lD extends Tp {
  constructor(e) {
    super(), (this.elements = e);
  }
}
class dD extends Tp {
  constructor(e, t) {
    super(), (this.serializer = e), (this.C = t);
  }
}
class Rr {
  constructor(e, t) {
    (this.updateTime = e), (this.exists = t);
  }
  /** Creates a new empty Precondition. */
  static none() {
    return new Rr();
  }
  /** Creates a new Precondition with an exists flag. */
  static exists(e) {
    return new Rr(void 0, e);
  }
  /** Creates a new Precondition based on a version a document exists at. */
  static updateTime(e) {
    return new Rr(e);
  }
  /** Returns whether this Precondition is empty. */
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(e) {
    return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime);
  }
}
class wp {}
class qw extends wp {
  constructor(e, t, i, r = []) {
    super(), (this.key = e), (this.value = t), (this.precondition = i), (this.fieldTransforms = r), (this.type = 0);
  }
  getFieldMask() {
    return null;
  }
}
class em extends wp {
  constructor(e, t, i, r, s = []) {
    super(), (this.key = e), (this.data = t), (this.fieldMask = i), (this.precondition = r), (this.fieldTransforms = s), (this.type = 1);
  }
  getFieldMask() {
    return this.fieldMask;
  }
}
class tm extends wp {
  constructor(e, t) {
    super(), (this.key = e), (this.precondition = t), (this.type = 2), (this.fieldTransforms = []);
  }
  getFieldMask() {
    return null;
  }
}
class cD extends wp {
  constructor(e, t) {
    super(), (this.key = e), (this.precondition = t), (this.type = 3), (this.fieldTransforms = []);
  }
  getFieldMask() {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pD = (() => ({
    asc: 'ASCENDING',
    desc: 'DESCENDING',
  }))(),
  fD = (() => ({
    '<': 'LESS_THAN',
    '<=': 'LESS_THAN_OR_EQUAL',
    '>': 'GREATER_THAN',
    '>=': 'GREATER_THAN_OR_EQUAL',
    '==': 'EQUAL',
    '!=': 'NOT_EQUAL',
    'array-contains': 'ARRAY_CONTAINS',
    in: 'IN',
    'not-in': 'NOT_IN',
    'array-contains-any': 'ARRAY_CONTAINS_ANY',
  }))(),
  yD = (() => ({
    and: 'AND',
    or: 'OR',
  }))();
class hD {
  constructor(e, t) {
    (this.databaseId = e), (this.useProto3Json = t);
  }
}
function th(n, e) {
  return n.useProto3Json
    ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, '').replace('Z', '')}.${('000000000' + e.nanoseconds).slice(-9)}Z`
    : {
        seconds: '' + e.seconds,
        nanos: e.nanoseconds,
      };
}
function mD(n, e) {
  return n.useProto3Json ? e.toBase64() : e.toUint8Array();
}
function bD(n, e) {
  return th(n, e.toTimestamp());
}
function zv(n) {
  return (
    Es(!!n),
    mn.fromTimestamp(
      (function (e) {
        const t = Ea(e);
        return new Un(t.seconds, t.nanos);
      })(n),
    )
  );
}
function nm(n, e) {
  return (function (t) {
    return new Jt(['projects', t.projectId, 'databases', t.database]);
  })(n)
    .child('documents')
    .child(e)
    .canonicalString();
}
function nh(n, e) {
  return nm(n.databaseId, e.path);
}
function gD(n, e) {
  const t = (function (r) {
    const s = Jt.fromString(r);
    return Es(Kw(s)), s;
  })(e);
  if (t.get(1) !== n.databaseId.projectId) throw new oe(pe, 'Tried to deserialize key from different project: ' + t.get(1) + ' vs ' + n.databaseId.projectId);
  if (t.get(3) !== n.databaseId.database) throw new oe(pe, 'Tried to deserialize key from different database: ' + t.get(3) + ' vs ' + n.databaseId.database);
  return new dn((Es((i = t).length > 4 && i.get(4) === 'documents'), i.popFirst(5)));
  var i;
}
function Gv(n, e) {
  return nm(n.databaseId, e);
}
function vD(n) {
  return new Jt(['projects', n.databaseId.projectId, 'databases', n.databaseId.database]).canonicalString();
}
function qv(n, e, t) {
  return {
    name: nh(n, e),
    fields: t.value.mapValue.fields,
  };
}
function xD(n, e) {
  let t;
  if (e instanceof qw)
    t = {
      update: qv(n, e.key, e.value),
    };
  else if (e instanceof tm)
    t = {
      delete: nh(n, e.key),
    };
  else if (e instanceof em)
    t = {
      update: qv(n, e.key, e.data),
      updateMask: SD(e.fieldMask),
    };
  else {
    if (!(e instanceof cD)) return Pt();
    t = {
      verify: nh(n, e.key),
    };
  }
  return (
    e.fieldTransforms.length > 0 &&
      (t.updateTransforms = e.fieldTransforms.map((i) =>
        (function (r, s) {
          const a = s.transform;
          if (a instanceof oD)
            return {
              fieldPath: s.field.canonicalString(),
              setToServerValue: 'REQUEST_TIME',
            };
          if (a instanceof uD)
            return {
              fieldPath: s.field.canonicalString(),
              appendMissingElements: {
                values: a.elements,
              },
            };
          if (a instanceof lD)
            return {
              fieldPath: s.field.canonicalString(),
              removeAllFromArray: {
                values: a.elements,
              },
            };
          if (a instanceof dD)
            return {
              fieldPath: s.field.canonicalString(),
              increment: a.C,
            };
          throw Pt();
        })(0, i),
      )),
    e.precondition.isNone ||
      (t.currentDocument = (function (i, r) {
        return r.updateTime !== void 0
          ? {
              updateTime: bD(i, r.updateTime),
            }
          : r.exists !== void 0
          ? {
              exists: r.exists,
            }
          : Pt();
      })(n, e.precondition)),
    t
  );
}
function TD(n, e) {
  const t = {
      structuredQuery: {},
    },
    i = e.path;
  e.collectionGroup !== null
    ? ((t.parent = Gv(n, i)),
      (t.structuredQuery.from = [
        {
          collectionId: e.collectionGroup,
          allDescendants: !0,
        },
      ]))
    : ((t.parent = Gv(n, i.popLast())),
      (t.structuredQuery.from = [
        {
          collectionId: i.lastSegment(),
        },
      ]));
  const r = (function (u) {
    if (u.length !== 0)
      return Hw(
        Vl.create(
          u,
          'and',
          /* CompositeOperator.AND */
        ),
      );
  })(e.filters);
  r && (t.structuredQuery.where = r);
  const s = (function (u) {
    if (u.length !== 0)
      return u.map((l) =>
        // visible for testing
        (function (c) {
          return {
            field: to(c.field),
            direction: wD(c.dir),
          };
        })(l),
      );
  })(e.orderBy);
  s && (t.structuredQuery.orderBy = s);
  const a = (function (u, l) {
    return u.useProto3Json || zN(l)
      ? l
      : {
          value: l,
        };
  })(n, e.limit);
  var o;
  return (
    a !== null && (t.structuredQuery.limit = a),
    e.startAt &&
      (t.structuredQuery.startAt = {
        before: (o = e.startAt).inclusive,
        values: o.position,
      }),
    e.endAt &&
      (t.structuredQuery.endAt = (function (u) {
        return {
          before: !u.inclusive,
          values: u.position,
        };
      })(e.endAt)),
    t
  );
}
function wD(n) {
  return pD[n];
}
function AD(n) {
  return fD[n];
}
function ED(n) {
  return yD[n];
}
function to(n) {
  return {
    fieldPath: n.canonicalString(),
  };
}
function Hw(n) {
  return n instanceof $i
    ? (function (e) {
        if (e.op === '==') {
          if (Lv(e.value))
            return {
              unaryFilter: {
                field: to(e.field),
                op: 'IS_NAN',
              },
            };
          if (Fv(e.value))
            return {
              unaryFilter: {
                field: to(e.field),
                op: 'IS_NULL',
              },
            };
        } else if (e.op === '!=') {
          if (Lv(e.value))
            return {
              unaryFilter: {
                field: to(e.field),
                op: 'IS_NOT_NAN',
              },
            };
          if (Fv(e.value))
            return {
              unaryFilter: {
                field: to(e.field),
                op: 'IS_NOT_NULL',
              },
            };
        }
        return {
          fieldFilter: {
            field: to(e.field),
            op: AD(e.op),
            value: e.value,
          },
        };
      })(n)
    : n instanceof Vl
    ? (function (e) {
        const t = e.getFilters().map((i) => Hw(i));
        return t.length === 1
          ? t[0]
          : {
              compositeFilter: {
                op: ED(e.op),
                filters: t,
              },
            };
      })(n)
    : Pt();
}
function SD(n) {
  const e = [];
  return (
    n.fields.forEach((t) => e.push(t.canonicalString())),
    {
      fieldPaths: e,
    }
  );
}
function Kw(n) {
  return n.length >= 4 && n.get(0) === 'projects' && n.get(2) === 'databases';
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function im(n) {
  return new hD(
    n,
    /* useProto3Json= */
    !0,
  );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CD extends class {} {
  constructor(e, t, i, r) {
    super(), (this.authCredentials = e), (this.appCheckCredentials = t), (this.connection = i), (this.serializer = r), (this.J = !1);
  }
  X() {
    if (this.J) throw new oe(Aa, 'The client has already been terminated.');
  }
  /** Invokes the provided RPC with auth and AppCheck tokens. */
  v(e, t, i) {
    return (
      this.X(),
      Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
        .then(([r, s]) => this.connection.v(e, t, i, r, s))
        .catch((r) => {
          throw r.name === 'FirebaseError' ? (r.code === Zy && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), r) : new oe(Ou, r.toString());
        })
    );
  }
  /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
  R(e, t, i, r) {
    return (
      this.X(),
      Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()])
        .then(([s, a]) => this.connection.R(e, t, i, s, a, r))
        .catch((s) => {
          throw s.name === 'FirebaseError' ? (s.code === Zy && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), s) : new oe(Ou, s.toString());
        })
    );
  }
  terminate() {
    this.J = !0;
  }
}
async function rm(n, e) {
  const t = gp(n),
    i = vD(t.serializer) + '/documents',
    r = {
      writes: e.map((s) => xD(t.serializer, s)),
    };
  await t.v('Commit', i, r);
}
async function MD(n, e) {
  const t = gp(n),
    i = TD(t.serializer, sD(e));
  return (
    await t.R('RunQuery', i.parent, {
      structuredQuery: i.structuredQuery,
    })
  )
    .filter((r) => !!r.document)
    .map((r) =>
      (function (s, a, o) {
        const u = gD(s, a.name),
          l = zv(a.updateTime),
          c = a.createTime ? zv(a.createTime) : mn.min(),
          f = new di({
            mapValue: {
              fields: a.fields,
            },
          }),
          m = us.newFoundDocument(u, l, c, f);
        return o && m.setHasCommittedMutations(), o ? m.setHasCommittedMutations() : m;
      })(t.serializer, r.document, void 0),
    );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Nu = /* @__PURE__ */ new Map();
function Ap(n) {
  if (n._terminated) throw new oe(Aa, 'The client has already been terminated.');
  if (!Nu.has(n)) {
    kc('ComponentProvider', 'Initializing Datastore');
    const s = (function (u) {
        return new qN(u, fetch.bind(null));
      })(
        ((e = n._databaseId),
        (t = n.app.options.appId || ''),
        (i = n._persistenceKey),
        (r = n._freezeSettings()),
        new UN(e, t, i, r.host, r.ssl, r.experimentalForceLongPolling, r.experimentalAutoDetectLongPolling, r.useFetchStreams)),
      ),
      a = im(n._databaseId),
      o = (function (u, l, c, f) {
        return new CD(u, l, c, f);
      })(n._authCredentials, n._appCheckCredentials, s, a);
    Nu.set(n, o);
  }
  var e, t, i, r;
  /**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  return Nu.get(n);
}
class Hv {
  constructor(e) {
    var t;
    if (e.host === void 0) {
      if (e.ssl !== void 0) throw new oe(pe, "Can't provide ssl option if host option is not set");
      (this.host = 'firestore.googleapis.com'), (this.ssl = !0);
    } else (this.host = e.host), (this.ssl = (t = e.ssl) === null || t === void 0 || t);
    if (((this.credentials = e.credentials), (this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties), (this.cache = e.localCache), e.cacheSizeBytes === void 0))
      this.cacheSizeBytes = 41943040;
    else {
      if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576) throw new oe(pe, 'cacheSizeBytes must be at least 1048576');
      this.cacheSizeBytes = e.cacheSizeBytes;
    }
    (this.experimentalForceLongPolling = !!e.experimentalForceLongPolling),
      (this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling),
      (this.useFetchStreams = !!e.useFetchStreams),
      (function (i, r, s, a) {
        if (r === !0 && a === !0) throw new oe(pe, `${i} and ${s} cannot be used together.`);
      })('experimentalForceLongPolling', e.experimentalForceLongPolling, 'experimentalAutoDetectLongPolling', e.experimentalAutoDetectLongPolling);
  }
  isEqual(e) {
    return (
      this.host === e.host &&
      this.ssl === e.ssl &&
      this.credentials === e.credentials &&
      this.cacheSizeBytes === e.cacheSizeBytes &&
      this.experimentalForceLongPolling === e.experimentalForceLongPolling &&
      this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling &&
      this.ignoreUndefinedProperties === e.ignoreUndefinedProperties &&
      this.useFetchStreams === e.useFetchStreams
    );
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Yo {
  /** @hideconstructor */
  constructor(e, t, i, r) {
    (this._authCredentials = e),
      (this._appCheckCredentials = t),
      (this._databaseId = i),
      (this._app = r)
      /**
       * Whether it's a Firestore or Firestore Lite instance.
       */,
      (this.type = 'firestore-lite'),
      (this._persistenceKey = '(lite)'),
      (this._settings = new Hv({})),
      (this._settingsFrozen = !1);
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app) throw new oe(Aa, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(e) {
    if (this._settingsFrozen)
      throw new oe(Aa, 'Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.');
    (this._settings = new Hv(e)),
      e.credentials !== void 0 &&
        (this._authCredentials = (function (t) {
          if (!t) return new PN();
          switch (t.type) {
            case 'firstParty':
              return new FN(t.sessionIndex || '0', t.iamToken || null, t.authTokenFactory || null);
            case 'provider':
              return t.client;
            default:
              throw new oe(pe, 'makeAuthCredentialsProvider failed due to invalid credential type');
          }
        })(e.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return (this._settingsFrozen = !0), this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings,
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    return (
      (function (e) {
        const t = Nu.get(e);
        t && (kc('ComponentProvider', 'Removing Datastore'), Nu.delete(e), t.terminate());
      })(this),
      Promise.resolve()
    );
  }
}
function _D(n, e) {
  const t = typeof n == 'object' ? n : pN(),
    i = typeof n == 'string' ? n : e || '(default)',
    r = uN(t, 'firestore/lite').getImmediate({
      identifier: i,
    });
  if (!r._initialized) {
    const s = sP('firestore');
    s && Ww(r, ...s);
  }
  return r;
}
function Ww(n, e, t, i = {}) {
  var r;
  const s = (n = Ul(n, Yo))._getSettings();
  if (
    (s.host !== 'firestore.googleapis.com' && s.host !== e && Dw('Host has been set in both settings() and useEmulator(), emulator host will be used'),
    n._setSettings(
      Object.assign(Object.assign({}, s), {
        host: `${e}:${t}`,
        ssl: !1,
      }),
    ),
    i.mockUserToken)
  ) {
    let a, o;
    if (typeof i.mockUserToken == 'string') (a = i.mockUserToken), (o = Bn.MOCK_USER);
    else {
      a = uP(i.mockUserToken, (r = n._app) === null || r === void 0 ? void 0 : r.options.projectId);
      const u = i.mockUserToken.sub || i.mockUserToken.user_id;
      if (!u) throw new oe(pe, "mockUserToken must contain 'sub' or 'user_id' field!");
      o = new Bn(u);
    }
    n._authCredentials = new NN(new Fw(a, o));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _n {
  /** @hideconstructor */
  constructor(e, t, i) {
    (this.converter = t), (this._key = i) /** The type of this Firestore reference. */, (this.type = 'document'), (this.firestore = e);
  }
  get _path() {
    return this._key.path;
  }
  /**
   * The document's identifier within its collection.
   */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  get path() {
    return this._key.path.canonicalString();
  }
  /**
   * The collection this `DocumentReference` belongs to.
   */
  get parent() {
    return new Ir(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(e) {
    return new _n(this.firestore, e, this._key);
  }
}
class Os {
  // This is the lite version of the Query class in the main SDK.
  /** @hideconstructor protected */
  constructor(e, t, i) {
    (this.converter = t), (this._query = i) /** The type of this Firestore reference. */, (this.type = 'query'), (this.firestore = e);
  }
  withConverter(e) {
    return new Os(this.firestore, e, this._query);
  }
}
class Ir extends Os {
  /** @hideconstructor */
  constructor(e, t, i) {
    super(e, t, new X0(i)), (this._path = i) /** The type of this Firestore reference. */, (this.type = 'collection');
  }
  /** The collection's identifier. */
  get id() {
    return this._query.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   */
  get path() {
    return this._query.path.canonicalString();
  }
  /**
   * A reference to the containing `DocumentReference` if this is a
   * subcollection. If this isn't a subcollection, the reference is null.
   */
  get parent() {
    const e = this._path.popLast();
    return e.isEmpty()
      ? null
      : new _n(
          this.firestore,
          /* converter= */
          null,
          new dn(e),
        );
  }
  withConverter(e) {
    return new Ir(this.firestore, e, this._path);
  }
}
function ih(n, e, ...t) {
  if (((n = or(n)), Lw('collection', 'path', e), n instanceof Yo)) {
    const i = Jt.fromString(e, ...t);
    return (
      Ov(i),
      new Ir(
        n,
        /* converter= */
        null,
        i,
      )
    );
  }
  {
    if (!(n instanceof _n || n instanceof Ir)) throw new oe(pe, 'Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore');
    const i = n._path.child(Jt.fromString(e, ...t));
    return (
      Ov(i),
      new Ir(
        n.firestore,
        /* converter= */
        null,
        i,
      )
    );
  }
}
function Ud(n, e, ...t) {
  if (
    ((n = or(n)), // We allow omission of 'pathString' but explicitly prohibit passing in both
    // 'undefined' and 'null'.
    arguments.length === 1 && (e = KN.N()),
    Lw('doc', 'path', e),
    n instanceof Yo)
  ) {
    const i = Jt.fromString(e, ...t);
    return (
      Iv(i),
      new _n(
        n,
        /* converter= */
        null,
        new dn(i),
      )
    );
  }
  {
    if (!(n instanceof _n || n instanceof Ir)) throw new oe(pe, 'Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore');
    const i = n._path.child(Jt.fromString(e, ...t));
    return Iv(i), new _n(n.firestore, n instanceof Ir ? n.converter : null, new dn(i));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ma {
  /** @hideconstructor */
  constructor(e) {
    this._byteString = e;
  }
  /**
   * Creates a new `Bytes` object from the given Base64 string, converting it to
   * bytes.
   *
   * @param base64 - The Base64 string used to create the `Bytes` object.
   */
  static fromBase64String(e) {
    try {
      return new Ma($r.fromBase64String(e));
    } catch (t) {
      throw new oe(pe, 'Failed to construct data from Base64 string: ' + t);
    }
  }
  /**
   * Creates a new `Bytes` object from the given Uint8Array.
   *
   * @param array - The Uint8Array used to create the `Bytes` object.
   */
  static fromUint8Array(e) {
    return new Ma($r.fromUint8Array(e));
  }
  /**
   * Returns the underlying bytes as a Base64-encoded string.
   *
   * @returns The Base64-encoded string created from the `Bytes` object.
   */
  toBase64() {
    return this._byteString.toBase64();
  }
  /**
   * Returns the underlying bytes in a new `Uint8Array`.
   *
   * @returns The Uint8Array created from the `Bytes` object.
   */
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  /**
   * Returns a string representation of the `Bytes` object.
   *
   * @returns A string representation of the `Bytes` object.
   */
  toString() {
    return 'Bytes(base64: ' + this.toBase64() + ')';
  }
  /**
   * Returns true if this `Bytes` object is equal to the provided one.
   *
   * @param other - The `Bytes` object to compare against.
   * @returns true if this `Bytes` object is equal to the provided one.
   */
  isEqual(e) {
    return this._byteString.isEqual(e._byteString);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class zl {
  /**
   * Creates a `FieldPath` from the provided field names. If more than one field
   * name is provided, the path will point to a nested field in a document.
   *
   * @param fieldNames - A list of field names.
   */
  constructor(...e) {
    for (let t = 0; t < e.length; ++t) if (e[t].length === 0) throw new oe(pe, 'Invalid field name at argument $(i + 1). Field names must not be empty.');
    this._internalPath = new Zn(e);
  }
  /**
   * Returns true if this `FieldPath` is equal to the provided one.
   *
   * @param other - The `FieldPath` to compare against.
   * @returns true if this `FieldPath` is equal to the provided one.
   */
  isEqual(e) {
    return this._internalPath.isEqual(e._internalPath);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ep {
  /**
   * @param _methodName - The public API endpoint that returns this class.
   * @hideconstructor
   */
  constructor(e) {
    this._methodName = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Sp {
  /**
   * Creates a new immutable `GeoPoint` object with the provided latitude and
   * longitude values.
   * @param latitude - The latitude as number between -90 and 90.
   * @param longitude - The longitude as number between -180 and 180.
   */
  constructor(e, t) {
    if (!isFinite(e) || e < -90 || e > 90) throw new oe(pe, 'Latitude must be a number between -90 and 90, but was: ' + e);
    if (!isFinite(t) || t < -180 || t > 180) throw new oe(pe, 'Longitude must be a number between -180 and 180, but was: ' + t);
    (this._lat = e), (this._long = t);
  }
  /**
   * The latitude of this `GeoPoint` instance.
   */
  get latitude() {
    return this._lat;
  }
  /**
   * The longitude of this `GeoPoint` instance.
   */
  get longitude() {
    return this._long;
  }
  /**
   * Returns true if this `GeoPoint` is equal to the provided one.
   *
   * @param other - The `GeoPoint` to compare against.
   * @returns true if this `GeoPoint` is equal to the provided one.
   */
  isEqual(e) {
    return this._lat === e._lat && this._long === e._long;
  }
  /** Returns a JSON-serializable representation of this GeoPoint. */
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long,
    };
  }
  /**
   * Actually private to JS consumers of our API, so this function is prefixed
   * with an underscore.
   */
  _compareTo(e) {
    return Xt(this._lat, e._lat) || Xt(this._long, e._long);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RD = /^__.*__$/;
class ID {
  constructor(e, t, i) {
    (this.data = e), (this.fieldMask = t), (this.fieldTransforms = i);
  }
  toMutation(e, t) {
    return this.fieldMask !== null ? new em(e, this.data, this.fieldMask, t, this.fieldTransforms) : new qw(e, this.data, t, this.fieldTransforms);
  }
}
class Jw {
  constructor(e, t, i) {
    (this.data = e), (this.fieldMask = t), (this.fieldTransforms = i);
  }
  toMutation(e, t) {
    return new em(e, this.data, this.fieldMask, t, this.fieldTransforms);
  }
}
function Qw(n) {
  switch (n) {
    case 0:
    case 2:
    case 1:
      return !0;
    case 3:
    case 4:
      return !1;
    default:
      throw Pt();
  }
}
class sm {
  /**
   * Initializes a ParseContext with the given source and path.
   *
   * @param settings - The settings for the parser.
   * @param databaseId - The database ID of the Firestore instance.
   * @param serializer - The serializer to use to generate the Value proto.
   * @param ignoreUndefinedProperties - Whether to ignore undefined properties
   * rather than throw.
   * @param fieldTransforms - A mutable list of field transforms encountered
   * while parsing the data.
   * @param fieldMask - A mutable list of field paths encountered while parsing
   * the data.
   *
   * TODO(b/34871131): We don't support array paths right now, so path can be
   * null to indicate the context represents any location within an array (in
   * which case certain features will not work and errors will be somewhat
   * compromised).
   */
  constructor(e, t, i, r, s, a) {
    (this.settings = e),
      (this.databaseId = t),
      (this.serializer = i),
      (this.ignoreUndefinedProperties = r), // Minor hack: If fieldTransforms is undefined, we assume this is an
      // external call and we need to validate the entire path.
      s === void 0 && this.tt(),
      (this.fieldTransforms = s || []),
      (this.fieldMask = a || []);
  }
  get path() {
    return this.settings.path;
  }
  get et() {
    return this.settings.et;
  }
  /** Returns a new context with the specified settings overwritten. */
  nt(e) {
    return new sm(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  rt(e) {
    var t;
    const i = (t = this.path) === null || t === void 0 ? void 0 : t.child(e),
      r = this.nt({
        path: i,
        st: !1,
      });
    return r.it(e), r;
  }
  ot(e) {
    var t;
    const i = (t = this.path) === null || t === void 0 ? void 0 : t.child(e),
      r = this.nt({
        path: i,
        st: !1,
      });
    return r.tt(), r;
  }
  ut(e) {
    return this.nt({
      path: void 0,
      st: !0,
    });
  }
  ct(e) {
    return Lc(e, this.settings.methodName, this.settings.at || !1, this.path, this.settings.ht);
  }
  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
  contains(e) {
    return this.fieldMask.find((t) => e.isPrefixOf(t)) !== void 0 || this.fieldTransforms.find((t) => e.isPrefixOf(t.field)) !== void 0;
  }
  tt() {
    if (this.path) for (let e = 0; e < this.path.length; e++) this.it(this.path.get(e));
  }
  it(e) {
    if (e.length === 0) throw this.ct('Document fields must not be empty');
    if (Qw(this.et) && RD.test(e)) throw this.ct('Document fields cannot begin and end with "__"');
  }
}
class OD {
  constructor(e, t, i) {
    (this.databaseId = e), (this.ignoreUndefinedProperties = t), (this.serializer = i || im(e));
  }
  /** Creates a new top-level parse context. */
  lt(e, t, i, r = !1) {
    return new sm(
      {
        et: e,
        methodName: t,
        ht: i,
        path: Zn.emptyPath(),
        st: !1,
        at: r,
      },
      this.databaseId,
      this.serializer,
      this.ignoreUndefinedProperties,
    );
  }
}
function am(n) {
  const e = n._freezeSettings(),
    t = im(n._databaseId);
  return new OD(n._databaseId, !!e.ignoreUndefinedProperties, t);
}
function Yw(n, e, t, i, r, s = {}) {
  const a = n.lt(s.merge || s.mergeFields ? 2 : 0, e, t, r);
  om('Data must be an object, but it was:', a, i);
  const o = Xw(i, a);
  let u, l;
  if (s.merge) (u = new Ca(a.fieldMask)), (l = a.fieldTransforms);
  else if (s.mergeFields) {
    const c = [];
    for (const f of s.mergeFields) {
      const m = rh(e, f, t);
      if (!a.contains(m)) throw new oe(pe, `Field '${m}' is specified in your field mask but missing from your input data.`);
      e5(c, m) || c.push(m);
    }
    (u = new Ca(c)), (l = a.fieldTransforms.filter((f) => u.covers(f.field)));
  } else (u = null), (l = a.fieldTransforms);
  return new ID(new di(o), u, l);
}
class Cp extends Ep {
  _toFieldTransform(e) {
    if (e.et !== 2)
      throw e.et === 1 ? e.ct(`${this._methodName}() can only appear at the top level of your update data`) : e.ct(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return e.fieldMask.push(e.path), null;
  }
  isEqual(e) {
    return e instanceof Cp;
  }
}
function kD(n, e, t, i) {
  const r = n.lt(1, e, t);
  om('Data must be an object, but it was:', r, i);
  const s = [],
    a = di.empty();
  jl(i, (u, l) => {
    const c = um(e, u, t);
    l = or(l);
    const f = r.ot(c);
    if (l instanceof Cp) s.push(c);
    else {
      const m = Gl(l, f);
      m != null && (s.push(c), a.set(c, m));
    }
  });
  const o = new Ca(s);
  return new Jw(a, o, r.fieldTransforms);
}
function PD(n, e, t, i, r, s) {
  const a = n.lt(1, e, t),
    o = [rh(e, i, t)],
    u = [r];
  if (s.length % 2 != 0) throw new oe(pe, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let m = 0; m < s.length; m += 2) o.push(rh(e, s[m])), u.push(s[m + 1]);
  const l = [],
    c = di.empty();
  for (let m = o.length - 1; m >= 0; --m)
    if (!e5(l, o[m])) {
      const w = o[m];
      let v = u[m];
      v = or(v);
      const T = a.ot(w);
      if (v instanceof Cp) l.push(w);
      else {
        const A = Gl(v, T);
        A != null && (l.push(w), c.set(w, A));
      }
    }
  const f = new Ca(l);
  return new Jw(c, f, a.fieldTransforms);
}
function ND(n, e, t, i = !1) {
  return Gl(t, n.lt(i ? 4 : 3, e));
}
function Gl(n, e) {
  if (
    Zw(
      // Unwrap the API type from the Compat SDK. This will return the API type
      // from firestore-exp.
      (n = or(n)),
    )
  )
    return om('Unsupported field value:', e, n), Xw(n, e);
  if (n instanceof Ep)
    return (
      (function (t, i) {
        if (!Qw(i.et)) throw i.ct(`${t._methodName}() can only be used with update() and set()`);
        if (!i.path) throw i.ct(`${t._methodName}() is not currently supported inside arrays`);
        const r = t._toFieldTransform(i);
        r && i.fieldTransforms.push(r);
      })(n, e),
      null
    );
  if (n === void 0 && e.ignoreUndefinedProperties) return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    (e.path && e.fieldMask.push(e.path), n instanceof Array)
  ) {
    if (e.settings.st && e.et !== 4) throw e.ct('Nested arrays are not supported');
    return (function (t, i) {
      const r = [];
      let s = 0;
      for (const a of t) {
        let o = Gl(a, i.ut(s));
        o == null && // Just include nulls in the array for fields being replaced with a
          // sentinel.
          (o = {
            nullValue: 'NULL_VALUE',
          }),
          r.push(o),
          s++;
      }
      return {
        arrayValue: {
          values: r,
        },
      };
    })(n, e);
  }
  return (function (t, i) {
    if ((t = or(t)) === null)
      return {
        nullValue: 'NULL_VALUE',
      };
    if (typeof t == 'number') return aD(i.serializer, t);
    if (typeof t == 'boolean')
      return {
        booleanValue: t,
      };
    if (typeof t == 'string')
      return {
        stringValue: t,
      };
    if (t instanceof Date) {
      const r = Un.fromDate(t);
      return {
        timestampValue: th(i.serializer, r),
      };
    }
    if (t instanceof Un) {
      const r = new Un(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3));
      return {
        timestampValue: th(i.serializer, r),
      };
    }
    if (t instanceof Sp)
      return {
        geoPointValue: {
          latitude: t.latitude,
          longitude: t.longitude,
        },
      };
    if (t instanceof Ma)
      return {
        bytesValue: mD(i.serializer, t._byteString),
      };
    if (t instanceof _n) {
      const r = i.databaseId,
        s = t.firestore._databaseId;
      if (!s.isEqual(r)) throw i.ct(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${r.projectId}/${r.database}`);
      return {
        referenceValue: nm(t.firestore._databaseId || i.databaseId, t._key.path),
      };
    }
    throw i.ct(`Unsupported field value: ${vp(t)}`);
  })(n, e);
}
function Xw(n, e) {
  const t = {};
  return (
    (function (i) {
      for (const r in i) if (Object.prototype.hasOwnProperty.call(i, r)) return !1;
      return !0;
    })(n)
      ? // If we encounter an empty object, we explicitly add it to the update
        // mask to ensure that the server creates a map entry.
        e.path && e.path.length > 0 && e.fieldMask.push(e.path)
      : jl(n, (i, r) => {
          const s = Gl(r, e.rt(i));
          s != null && (t[i] = s);
        }),
    {
      mapValue: {
        fields: t,
      },
    }
  );
}
function Zw(n) {
  return !(typeof n != 'object' || n === null || n instanceof Array || n instanceof Date || n instanceof Un || n instanceof Sp || n instanceof Ma || n instanceof _n || n instanceof Ep);
}
function om(n, e, t) {
  if (
    !Zw(t) ||
    !(function (i) {
      return typeof i == 'object' && i !== null && (Object.getPrototypeOf(i) === Object.prototype || Object.getPrototypeOf(i) === null);
    })(t)
  ) {
    const i = vp(t);
    throw i === 'an object' ? e.ct(n + ' a custom object') : e.ct(n + ' ' + i);
  }
}
function rh(n, e, t) {
  if (
    // If required, replace the FieldPath Compat class with with the firestore-exp
    // FieldPath.
    (e = or(e)) instanceof zl
  )
    return e._internalPath;
  if (typeof e == 'string') return um(n, e);
  throw Lc(
    'Field path arguments must be of type string or ',
    n,
    /* hasConverter= */
    !1,
    /* path= */
    void 0,
    t,
  );
}
const DD = new RegExp('[~\\*/\\[\\]]');
function um(n, e, t) {
  if (e.search(DD) >= 0)
    throw Lc(
      `Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,
      n,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      t,
    );
  try {
    return new zl(...e.split('.'))._internalPath;
  } catch {
    throw Lc(
      `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      n,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      t,
    );
  }
}
function Lc(n, e, t, i, r) {
  const s = i && !i.isEmpty(),
    a = r !== void 0;
  let o = `Function ${e}() called with invalid data`;
  t && (o += ' (via `toFirestore()`)'), (o += '. ');
  let u = '';
  return (s || a) && ((u += ' (found'), s && (u += ` in field ${i}`), a && (u += ` in document ${r}`), (u += ')')), new oe(pe, o + n + u);
}
function e5(n, e) {
  return n.some((t) => t.isEqual(e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class t5 {
  // Note: This class is stripped down version of the DocumentSnapshot in
  // the legacy SDK. The changes are:
  // - No support for SnapshotMetadata.
  // - No support for SnapshotOptions.
  /** @hideconstructor protected */
  constructor(e, t, i, r, s) {
    (this._firestore = e), (this._userDataWriter = t), (this._key = i), (this._document = r), (this._converter = s);
  }
  /** Property of the `DocumentSnapshot` that provides the document's ID. */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * The `DocumentReference` for the document included in the `DocumentSnapshot`.
   */
  get ref() {
    return new _n(this._firestore, this._converter, this._key);
  }
  /**
   * Signals whether or not the document at the snapshot's location exists.
   *
   * @returns true if the document exists.
   */
  exists() {
    return this._document !== null;
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * @returns An `Object` containing all fields in the document or `undefined`
   * if the document doesn't exist.
   */
  data() {
    if (this._document) {
      if (this._converter) {
        const e = new lm(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          /* converter= */
          null,
        );
        return this._converter.fromFirestore(e);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(e) {
    if (this._document) {
      const t = this._document.data.field(dm('DocumentSnapshot.get', e));
      if (t !== null) return this._userDataWriter.convertValue(t);
    }
  }
}
class lm extends t5 {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * @override
   * @returns An `Object` containing all fields in the document.
   */
  data() {
    return super.data();
  }
}
class n5 {
  /** @hideconstructor */
  constructor(e, t) {
    (this._docs = t), (this.query = e);
  }
  /** An array of all the documents in the `QuerySnapshot`. */
  get docs() {
    return [...this._docs];
  }
  /** The number of documents in the `QuerySnapshot`. */
  get size() {
    return this.docs.length;
  }
  /** True if there are no documents in the `QuerySnapshot`. */
  get empty() {
    return this.docs.length === 0;
  }
  /**
   * Enumerates all of the documents in the `QuerySnapshot`.
   *
   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
   * each document in the snapshot.
   * @param thisArg - The `this` binding for the callback.
   */
  forEach(e, t) {
    this._docs.forEach(e, t);
  }
}
function dm(n, e) {
  return typeof e == 'string' ? um(n, e) : e instanceof zl ? e._internalPath : e._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cm {}
class pm extends cm {}
function i5(n, e, ...t) {
  let i = [];
  e instanceof cm && i.push(e),
    (i = i.concat(t)),
    (function (r) {
      const s = r.filter((o) => o instanceof Mp).length,
        a = r.filter((o) => o instanceof ql).length;
      if (s > 1 || (s > 0 && a > 0))
        throw new oe(
          pe,
          'InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.',
        );
    })(i);
  for (const r of i) n = r._apply(n);
  return n;
}
class ql extends pm {
  /**
   * @internal
   */
  constructor(e, t, i) {
    super(), (this._field = e), (this._op = t), (this._value = i) /** The type of this query constraint */, (this.type = 'where');
  }
  static _create(e, t, i) {
    return new ql(e, t, i);
  }
  _apply(e) {
    const t = this._parse(e);
    return s5(e._query, t), new Os(e.firestore, e.converter, eh(e._query, t));
  }
  _parse(e) {
    const t = am(e.firestore);
    return (function (r, s, a, o, u, l, c) {
      let f;
      if (u.isKeyField()) {
        if (l === 'array-contains' || l === 'array-contains-any') throw new oe(pe, `Invalid Query. You can't perform '${l}' queries on documentId().`);
        if (l === 'in' || l === 'not-in') {
          Wv(c, l);
          const m = [];
          for (const w of c) m.push(Kv(o, r, w));
          f = {
            arrayValue: {
              values: m,
            },
          };
        } else f = Kv(o, r, c);
      } else
        (l !== 'in' && l !== 'not-in' && l !== 'array-contains-any') || Wv(c, l),
          (f = ND(
            a,
            s,
            c,
            /* allowArrays= */
            l === 'in' || l === 'not-in',
          ));
      return $i.create(u, l, f);
    })(e._query, 'where', t, e.firestore._databaseId, this._field, this._op, this._value);
  }
}
function r5(n, e, t) {
  const i = e,
    r = dm('where', n);
  return ql._create(r, i, t);
}
class Mp extends cm {
  /**
   * @internal
   */
  constructor(e, t) {
    super(), (this.type = e), (this._queryConstraints = t);
  }
  static _create(e, t) {
    return new Mp(e, t);
  }
  _parse(e) {
    const t = this._queryConstraints.map((i) => i._parse(e)).filter((i) => i.getFilters().length > 0);
    return t.length === 1 ? t[0] : Vl.create(t, this._getOperator());
  }
  _apply(e) {
    const t = this._parse(e);
    return t.getFilters().length === 0
      ? e
      : ((function (i, r) {
          let s = i;
          const a = r.getFlattenedFilters();
          for (const o of a) s5(s, o), (s = eh(s, o));
        })(e._query, t),
        new Os(e.firestore, e.converter, eh(e._query, t)));
  }
  _getQueryConstraints() {
    return this._queryConstraints;
  }
  _getOperator() {
    return this.type === 'and' ? 'and' : 'or';
  }
}
class _p extends pm {
  /**
   * @internal
   */
  constructor(e, t) {
    super(), (this._field = e), (this._direction = t) /** The type of this query constraint */, (this.type = 'orderBy');
  }
  static _create(e, t) {
    return new _p(e, t);
  }
  _apply(e) {
    const t = (function (i, r, s) {
      if (i.startAt !== null) throw new oe(pe, 'Invalid query. You must not call startAt() or startAfter() before calling orderBy().');
      if (i.endAt !== null) throw new oe(pe, 'Invalid query. You must not call endAt() or endBefore() before calling orderBy().');
      const a = new Pu(r, s);
      return (
        (function (o, u) {
          if (Z0(o) === null) {
            const l = xp(o);
            l !== null && a5(o, l, u.field);
          }
        })(i, a),
        a
      );
    })(e._query, this._field, this._direction);
    return new Os(
      e.firestore,
      e.converter,
      (function (i, r) {
        const s = i.explicitOrderBy.concat([r]);
        return new X0(i.path, i.collectionGroup, s, i.filters.slice(), i.limit, i.limitType, i.startAt, i.endAt);
      })(e._query, t),
    );
  }
}
function BD(n, e = 'asc') {
  const t = e,
    i = dm('orderBy', n);
  return _p._create(i, t);
}
function Kv(n, e, t) {
  if (typeof (t = or(t)) == 'string') {
    if (t === '') throw new oe(pe, 'Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.');
    if (!rD(e) && t.indexOf('/') !== -1) throw new oe(pe, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${t}' contains a '/' character.`);
    const i = e.path.child(Jt.fromString(t));
    if (!dn.isDocumentKey(i))
      throw new oe(
        pe,
        `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${i}' is not because it has an odd number of segments (${i.length}).`,
      );
    return Bv(n, new dn(i));
  }
  if (t instanceof _n) return Bv(n, t._key);
  throw new oe(pe, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${vp(t)}.`);
}
function Wv(n, e) {
  if (!Array.isArray(n) || n.length === 0) throw new oe(pe, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
}
function s5(n, e) {
  if (e.isInequality()) {
    const i = xp(n),
      r = e.field;
    if (i !== null && !i.isEqual(r))
      throw new oe(
        pe,
        `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${i.toString()}' and '${r.toString()}'`,
      );
    const s = Z0(n);
    s !== null && a5(n, r, s);
  }
  const t = (function (i, r) {
    for (const s of i) for (const a of s.getFlattenedFilters()) if (r.indexOf(a.op) >= 0) return a.op;
    return null;
  })(
    n.filters,
    (function (i) {
      switch (i) {
        case '!=':
          return [
            '!=',
            'not-in',
            /* Operator.NOT_IN */
          ];
        case 'array-contains-any':
        case 'in':
          return [
            'not-in',
            /* Operator.NOT_IN */
          ];
        case 'not-in':
          return [
            'array-contains-any',
            'in',
            'not-in',
            '!=',
            /* Operator.NOT_EQUAL */
          ];
        default:
          return [];
      }
    })(e.op),
  );
  if (t !== null)
    throw t === e.op
      ? new oe(pe, `Invalid query. You cannot use more than one '${e.op.toString()}' filter.`)
      : new oe(pe, `Invalid query. You cannot use '${e.op.toString()}' filters with '${t.toString()}' filters.`);
}
function a5(n, e, t) {
  if (!t.isEqual(e))
    throw new oe(
      pe,
      `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${t.toString()}' instead.`,
    );
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function o5(n, e, t) {
  let i;
  return (i = n ? (t && (t.merge || t.mergeFields) ? n.toFirestore(e, t) : n.toFirestore(e)) : e), i;
}
class FD extends class {
  convertValue(e, t = 'none') {
    switch (Sa(e)) {
      case 0:
        return null;
      case 1:
        return e.booleanValue;
      case 2:
        return Kt(e.integerValue || e.doubleValue);
      case 3:
        return this.convertTimestamp(e.timestampValue);
      case 4:
        return this.convertServerTimestamp(e, t);
      case 5:
        return e.stringValue;
      case 6:
        return this.convertBytes(fl(e.bytesValue));
      case 7:
        return this.convertReference(e.referenceValue);
      case 8:
        return this.convertGeoPoint(e.geoPointValue);
      case 9:
        return this.convertArray(e.arrayValue, t);
      case 10:
        return this.convertObject(e.mapValue, t);
      default:
        throw Pt();
    }
  }
  convertObject(e, t) {
    const i = {};
    return (
      jl(e.fields, (r, s) => {
        i[r] = this.convertValue(s, t);
      }),
      i
    );
  }
  convertGeoPoint(e) {
    return new Sp(Kt(e.latitude), Kt(e.longitude));
  }
  convertArray(e, t) {
    return (e.values || []).map((i) => this.convertValue(i, t));
  }
  convertServerTimestamp(e, t) {
    switch (t) {
      case 'previous':
        const i = jw(e);
        return i == null ? null : this.convertValue(i, t);
      case 'estimate':
        return this.convertTimestamp(yl(e));
      default:
        return null;
    }
  }
  convertTimestamp(e) {
    const t = Ea(e);
    return new Un(t.seconds, t.nanos);
  }
  convertDocumentKey(e, t) {
    const i = Jt.fromString(e);
    Es(Kw(i));
    const r = new cl(i.get(1), i.get(3)),
      s = new dn(i.popFirst(5));
    return (
      r.isEqual(t) || // TODO(b/64130202): Somehow support foreign references.
        Q0(
          `Document ${s} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`,
        ),
      s
    );
  }
} {
  constructor(e) {
    super(), (this.firestore = e);
  }
  convertBytes(e) {
    return new Ma(e);
  }
  convertReference(e) {
    const t = this.convertDocumentKey(e, this.firestore._databaseId);
    return new _n(
      this.firestore,
      /* converter= */
      null,
      t,
    );
  }
}
function sh(n) {
  (function (i) {
    if (i.limitType === 'L' && i.explicitOrderBy.length === 0) throw new oe(Bw, 'limitToLast() queries require specifying at least one orderBy() clause');
  })((n = Ul(n, Os))._query);
  const e = Ap(n.firestore),
    t = new FD(n.firestore);
  return MD(e, n._query).then((i) => {
    const r = i.map((s) => new lm(n.firestore, t, s.key, s, n.converter));
    return (
      n._query.limitType === 'L' && // Limit to last queries reverse the orderBy constraint that was
        // specified by the user. As such, we need to reverse the order of the
        // results to return the documents in the expected order.
        r.reverse(),
      new n5(n, r)
    );
  });
}
function ah(n, e, t) {
  const i = o5((n = Ul(n, _n)).converter, e, t),
    r = Yw(am(n.firestore), 'setDoc', n._key, i, n.converter !== null, t);
  return rm(Ap(n.firestore), [r.toMutation(n._key, Rr.none())]);
}
function u5(n) {
  return rm(Ap((n = Ul(n, _n)).firestore), [new tm(n._key, Rr.none())]);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class l5 {
  /** @hideconstructor */
  constructor(e, t) {
    (this._firestore = e), (this._commitHandler = t), (this._mutations = []), (this._committed = !1), (this._dataReader = am(e));
  }
  set(e, t, i) {
    this._verifyNotCommitted();
    const r = zf(e, this._firestore),
      s = o5(r.converter, t, i),
      a = Yw(this._dataReader, 'WriteBatch.set', r._key, s, r.converter !== null, i);
    return this._mutations.push(a.toMutation(r._key, Rr.none())), this;
  }
  update(e, t, i, ...r) {
    this._verifyNotCommitted();
    const s = zf(e, this._firestore);
    let a;
    return (
      (a = typeof (t = or(t)) == 'string' || t instanceof zl ? PD(this._dataReader, 'WriteBatch.update', s._key, t, i, r) : kD(this._dataReader, 'WriteBatch.update', s._key, t)),
      this._mutations.push(a.toMutation(s._key, Rr.exists(!0))),
      this
    );
  }
  /**
   * Deletes the document referred to by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be deleted.
   * @returns This `WriteBatch` instance. Used for chaining method calls.
   */
  delete(e) {
    this._verifyNotCommitted();
    const t = zf(e, this._firestore);
    return (this._mutations = this._mutations.concat(new tm(t._key, Rr.none()))), this;
  }
  /**
   * Commits all of the writes in this write batch as a single atomic unit.
   *
   * The result of these writes will only be reflected in document reads that
   * occur after the returned promise resolves. If the client is offline, the
   * write fails. If you would like to see local modifications or buffer writes
   * until the client is online, use the full Firestore SDK.
   *
   * @returns A `Promise` resolved once all of the writes in the batch have been
   * successfully written to the backend as an atomic unit (note that it won't
   * resolve while you're offline).
   */
  commit() {
    return this._verifyNotCommitted(), (this._committed = !0), this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed) throw new oe(Aa, 'A write batch can no longer be used after commit() has been called.');
  }
}
function zf(n, e) {
  if ((n = or(n)).firestore !== e) throw new oe(pe, 'Provided document reference is from a different Firestore instance.');
  return n;
}
function d5(n) {
  const e = Ap((n = Ul(n, Yo)));
  return new l5(n, (t) => rm(e, t));
}
(function (n) {
  Qo = n;
})(`${cN}_lite`),
  Oc(
    new ll(
      'firestore/lite',
      (n, { instanceIdentifier: e, options: t }) => {
        const i = n.getProvider('app').getImmediate(),
          r = new Yo(
            new DN(n.getProvider('auth-internal')),
            new $N(n.getProvider('app-check-internal')),
            (function (s, a) {
              if (!Object.prototype.hasOwnProperty.apply(s.options, ['projectId'])) throw new oe(pe, '"projectId" not provided in firebase.initializeApp.');
              return new cl(s.options.projectId, a);
            })(i, e),
            i,
          );
        return t && r._setSettings(t), r;
      },
      'PUBLIC',
    ).setMultipleInstances(!0),
  ), // RUNTIME_ENV and BUILD_TARGET are replaced by real values during the compilation
  ho('firestore-lite', '3.10.1', ''),
  ho('firestore-lite', '3.10.1', 'esm2017');
const Jv = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      Bytes: Ma,
      CollectionReference: Ir,
      DocumentReference: _n,
      DocumentSnapshot: t5,
      FieldPath: zl,
      FieldValue: Ep,
      Firestore: Yo,
      FirestoreError: oe,
      GeoPoint: Sp,
      Query: Os,
      QueryCompositeFilterConstraint: Mp,
      QueryConstraint: pm,
      QueryDocumentSnapshot: lm,
      QueryFieldFilterConstraint: ql,
      QueryOrderByConstraint: _p,
      QuerySnapshot: n5,
      Timestamp: Un,
      WriteBatch: l5,
      collection: ih,
      connectFirestoreEmulator: Ww,
      deleteDoc: u5,
      doc: Ud,
      getDocs: sh,
      getFirestore: _D,
      orderBy: BD,
      query: i5,
      setDoc: ah,
      where: r5,
      writeBatch: d5,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
);
var Qt = /* @__PURE__ */ ((n) => ((n[(n.minute = 0)] = 'minute'), (n[(n.hour = 1)] = 'hour'), (n[(n.day = 2)] = 'day'), n))(Qt || {});
const Gf = be
    .createContainer()
    .register(me.instance(pw, kw({ ...H9, apiKey: globalThis.process.env.FIREBASE_API_KEY })))
    .register(me.instance(V0, {}))
    .register(Mo)
    .register(ol)
    .register(nl)
    .register(me.instance(Gk, {}))
    .register(me.instance(H0, {}))
    .register(me.instance(z0, { lsGet: () => '', lsSet: () => '' }))
    .register(sl)
    .register(Mc)
    .register(_o)
    .register(_c)
    .register(
      me.instance(
        hp,
        new Jk(
          { url: cv, skipFetchSetup: !0 },
          {
            name: pv.toLowerCase(),
            chainId: dv,
          },
        ),
      ),
    )
    .register(
      me.instance(Ms, {
        chainId: dv,
        ipfsGateway: K9,
        chainUrl: cv,
        chain: pv,
        isDevelopment: !1,
        scanLink: W9,
        firebaseCollection: eo,
      }),
    )
    .register(yp)
    .register(ul)
    .register(Ta)
    .register(
      me.instance(cw, {
        tokens: Z9,
      }),
    )
    .register(al)
    .register(me.instance(Ua, { uf: (n) => Number(n) }))
    .register(
      me.instance(Ra, {}),
      me.instance(zc, {}),
      me.instance(_a, {
        scopeTo: () => {},
        error: () => {},
      }),
    ),
  LD = async () => {
    let n = !1;
    const e = 5,
      t = 1,
      i = 1;
    let r = '';
    const s = Gf.get(ww);
    let a = '',
      o = 0,
      u = 0,
      l = 0,
      c = 0,
      f = 0,
      m = 0,
      w = 0,
      v = 0,
      T = 0,
      A = 0,
      _,
      O = 0,
      B = 0,
      P = 0,
      N = 0,
      U = 0;
    const z = await Gf.get(U0).connect(),
      Y = Object.values(Qt)
        .filter((E) => typeof E == 'number')
        .map((E) => E),
      ue = async (E) => {
        const M = ih(z, `${eo}/lastSync/${E}`);
        return (await sh(M)).docs[0]?.id;
      },
      J = async (E, M, I) => {
        I && (await u5(Ud(z, `${eo}/lastSync/${E}/${I}`))), await ah(Ud(z, `${eo}/lastSync/${E}`, M.toString()), {});
      },
      le = async (E, M, I, b) => {
        let p = b;
        typeof p != 'object' && (p = { value: b }), (p.createdAt = I), await ah(Ud(z, `${eo}/${E}/${M}`, I.toString()), p);
      },
      C = async (E, M, I) => {
        const b = d5(z);
        (await sh(i5(ih(z, `${eo}/${E}/${M}`), r5('createdAt', '<', I)))).forEach((x) => b.delete(x.ref)), await b.commit();
      },
      d = async () => (await (await Gf.get(Ew).getTreasuryContract()).totalValuation()).toHexString(),
      y = async () => {
        await s.loadAssets(), await s.loadkCur();
      },
      g = (E) => {
        const M = /* @__PURE__ */ new Date();
        switch (E) {
          case 0:
            M.setMinutes(M.getMinutes() - 60, 0, 0);
            break;
          case 1:
            M.setHours(M.getHours() - 24, 0, 0, 0);
            break;
          case 2:
            return Number.MIN_VALUE;
        }
        return M.getTime();
      },
      S = async () => {
        (r = await d()),
          await y(),
          (a = s.reserveValue?.toHexString() ?? ''),
          (o = s.currentLeverageRatio),
          (u = s.maxLeverageRatio),
          (l = s.kCurPrice ?? 0),
          (c = s.kCurPriceCeiling ?? 0),
          (f = s.kCurPriceFloor),
          (m = s.kCurReserveDistribution ?? 0),
          (w = s.kCurMentoDistribution ?? 0),
          (v = s.kCurPrimaryPoolDistribution ?? 0),
          (T = s.kCurCirculatingDistribution),
          (O = s.minCollateralizationValue),
          (B = s.kCurTotalValue),
          (P = s.lowRiskAssets.map((E) => E.total).sum()),
          (N = s.moderateRiskAssets.map((E) => E.total).sum()),
          (U = s.highRiskAssets.map((E) => E.total).sum()),
          (A = s.kGuilderValueRatio);
      };
    await Promise.all(
      Y.map(async (E) => {
        const M = await ue(Qt[E]),
          I = /* @__PURE__ */ new Date();
        let b = /* @__PURE__ */ new Date();
        if (
          (M && (b = new Date(Number(M))),
          E === 0
            ? (b.setUTCMinutes(b.getUTCMinutes() + e), b.setUTCSeconds(0, 0))
            : E === 1
            ? (b.setUTCHours(b.getUTCHours() + t), b.setUTCMinutes(0, 0, 0))
            : (b.setUTCDate(b.getUTCDate() + i), b.setUTCHours(0, 0, 0, 0)),
          I >= b || !M)
        ) {
          let p = /* @__PURE__ */ new Date();
          if (E === 0) {
            const x = 6e4 * e;
            p = new Date(Math.floor(I.getTime() / x) * x);
          } else E === 1 ? p.setUTCMinutes(0, 0, 0) : p.setUTCHours(0, 0, 0, 0);
          n || ((n = !0), (_ = S())),
            _?.then(async () => {
              await le('kCurPrice', Qt[E], p.getTime(), { kCurPrice: l, kCurPriceCeiling: c, kCurPriceFloor: f }),
                await le('kCurRatio', Qt[E], p.getTime(), { currentLeverageRatio: o, maxLeverageRatio: u }),
                await le('kCurSupply', Qt[E], p.getTime(), {
                  kCurReserveDistribution: m,
                  kCurMentoDistribution: w,
                  kCurPrimaryPoolDistribution: v,
                  kCurCirculatingDistribution: T,
                }),
                await le('ktt', Qt[E], p.getTime(), r),
                await le('reserve', Qt[E], p.getTime(), a),
                await le('risk', Qt[E], p.getTime(), {
                  minCollateralValue: O,
                  marketCap: B,
                  lowRisk: P,
                  moderateRisk: N,
                  highRisk: U,
                }),
                await le('kGuilder', Qt[E], p.getTime(), A),
                await J(Qt[E], p.getTime(), M);
              const x = g(E);
              await C('kCurPrice', Qt[E], x),
                await C('kCurRatio', Qt[E], x),
                await C('kCurSupply', Qt[E], x),
                await C('ktt', Qt[E], x),
                await C('reserve', Qt[E], x),
                await C('risk', Qt[E], x),
                await C('kGuilder', Qt[E], x);
            });
        }
      }),
    );
  };
await LD();
