const V6 = "alfajores", j6 = 44787, G6 = {
  monetaryBadger: {
    abi: "Badger",
    address: "0x17ED8C6F5ABB958d31e5a9E6538FEe57B177a859"
  },
  kolektivoBadger: {
    abi: "Badger",
    address: "0x100638252400114f168f043e02F2BD7555d2c682"
  },
  bacMD: {
    abi: "BACRoles",
    address: "0x7428FA18E9B05903c7F1346eCFB63955BA5c4eE1"
  },
  bacFFD: {
    abi: "BACRoles",
    address: "0x9337386C570627F1dd65e86D1B197B58C5D28a21"
  },
  bacMC: {
    abi: "BACRoles",
    address: "0x351CF327Bd66880254FBA28221738E4f23caf4a8"
  },
  bacK: {
    abi: "BACRoles",
    address: "0x92F194D23b87770A2847067690A3A905A8E13760"
  },
  reserveDelegateScope: {
    abi: "ScopeGuard",
    address: "0x3A5fC6C9d99d33A9E38D94f3af18CC093a00A59f"
  },
  foodForestDelegateScope: {
    abi: "ScopeGuard",
    address: "0x005DbB9DCC558B1486ba16572Cc6DB199fE4736E"
  },
  monetaryMultisigScope: {
    abi: "ScopeGuard",
    address: "0x4991B0e921cD4b66A637ca9F7b978ee9316a6c16"
  },
  monetaryDelay: {
    abi: "SecretDelay",
    address: "0x7b0ecd6795437B8Ad1c7Ac20011ECFc39de6F1df"
  },
  foodForestDelay: {
    abi: "SecretDelay",
    address: "0x87A709785b0CEa865143711E9bcD82fAeC1A48D7"
  },
  kolektivoDelay: {
    abi: "SecretDelay",
    address: "0x26d8b50d241ba577cCC9Db383e2349499a796dc0"
  }
}, vI = {
  name: V6,
  chainId: j6,
  contracts: G6
}, wI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: V6,
  chainId: j6,
  contracts: G6,
  default: vI
}, Symbol.toStringTag, { value: "Module" })), W6 = "alfajores", H6 = "44787", z6 = {}, AI = {
  name: W6,
  chainId: H6,
  contracts: z6
}, TI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: W6,
  chainId: H6,
  contracts: z6,
  default: AI
}, Symbol.toStringTag, { value: "Module" })), K6 = "alfajores", q6 = "44787", Q6 = {
  GeoNFT: {
    address: "0x3d088f32d7d83FD7868620f76C80604106b74702",
    abi: [
      {
        inputs: [
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidIdentifier",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidLatitude",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidLongitude",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidTokenId",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "TokenModified",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "int32",
            name: "latitude",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "longitude",
            type: "int32"
          },
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "int32",
            name: "latitude",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "longitude",
            type: "int32"
          },
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "modify",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "tokenData",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "int32",
            name: "",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "",
            type: "int32"
          },
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Oracle: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "uint256",
            name: "reportExpirationTime_",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "reportDelay_",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumProviders_",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "invalidProvider",
            type: "address"
          }
        ],
        name: "Oracle__InvalidProvider",
        type: "error"
      },
      {
        inputs: [],
        name: "Oracle__NewReportTooSoonAfterPastReport",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldMinimumProviders",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newMinimumProviders",
            type: "uint256"
          }
        ],
        name: "MinimumProvidersChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [],
        name: "OracleMarkedAsInvalid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [],
        name: "OracleMarkedAsValid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          }
        ],
        name: "ProviderReportPushed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "purger",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderReportsPurged",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "addProvider",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getData",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "isValid",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "minimumProviders",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "providerReports",
        outputs: [
          {
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "providers",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "providersSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "purgeReports",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "purgeReportsFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          }
        ],
        name: "pushReport",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "removeProvider",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "reportDelay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "reportExpirationTime",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "isValid_",
            type: "bool"
          }
        ],
        name: "setIsValid",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "minimumProviders_",
            type: "uint256"
          }
        ],
        name: "setMinimumProviders",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Reserve: {
    address: "0x9f4995f6a797Dd932A5301f22cA88104e7e42366",
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "token_",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOracle_",
            type: "address"
          },
          {
            internalType: "address",
            name: "vestingVault_",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minBacking_",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20BalanceNotSufficient",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20BondingLimitExceeded",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotBondable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotRedeemable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotRegistered",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20RedeemLimitExceeded",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotBondable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotRedeemable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotRegistered",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidOracle",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__MinimumBackingLimitExceeded",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldBacking",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newBacking",
            type: "uint256"
          }
        ],
        name: "BackingUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sBonded",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensMinted",
            type: "uint256"
          }
        ],
        name: "BondedERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensMinted",
            type: "uint256"
          }
        ],
        name: "BondedERC721",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "DebtIncurred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "DebtPaid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20Deregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum IReserve.AssetType",
            name: "assetType",
            type: "uint8"
          }
        ],
        name: "ERC20Registered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDeregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sRedeemed",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensBurned",
            type: "uint256"
          }
        ],
        name: "RedeemedERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensBurned",
            type: "uint256"
          }
        ],
        name: "RedeemedERC721Id",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldDiscount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newDiscount",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingDiscount",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldVestingDuration",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newVestingDuration",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingVesting",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetERC20Oracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20RedeemLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldDiscount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newDiscount",
            type: "uint256"
          }
        ],
        name: "SetERC721IdBondingDiscount",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldVestingDuration",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newVestingDuration",
            type: "uint256"
          }
        ],
        name: "SetERC721IdBondingVesting",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetERC721IdOracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldMinBacking",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newMinBacking",
            type: "uint256"
          }
        ],
        name: "SetMinBacking",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetTokenOracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "oldVestingVault",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newVestingVault",
            type: "address"
          }
        ],
        name: "SetVestingVault",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sWithdrawn",
            type: "uint256"
          }
        ],
        name: "WithdrewERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "WithdrewERC721Id",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC20s",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC721Ids",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "erc721",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "id",
                type: "uint256"
              }
            ],
            internalType: "struct IReserve.ERC721Id[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "assetTypeOfERC20",
        outputs: [
          {
            internalType: "enum IReserve.AssetType",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "bondERC20All",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "bondERC20AllFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC20AllFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC20AllTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20From",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20FromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20To",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "bondERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "bondERC721IdFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC721IdFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC721IdTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingDiscountPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "bondingDiscountPerERC721Id",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingVestingDurationPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "bondingVestingDurationPerERC721Id",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "deregisterERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "deregisterERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "executeTx",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "incurDebt",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Bondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Redeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdBondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdRedeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "minBacking",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "oraclePerERC20",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "oraclePerERC721Id",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "payDebt",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "redeemERC20All",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "redeemERC20AllFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC20AllFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC20AllTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20From",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20FromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20To",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "redeemERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "redeemERC721IdFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC721IdFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC721IdTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "redeemLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "enum IReserve.AssetType",
            name: "assetType",
            type: "uint8"
          }
        ],
        name: "registerERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "registerERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC20s",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC721Ids",
        outputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "reserveStatus",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          }
        ],
        name: "setBondingDiscountForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          }
        ],
        name: "setBondingDiscountForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "vestingDuration",
            type: "uint256"
          }
        ],
        name: "setBondingVestingForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "vestingDuration",
            type: "uint256"
          }
        ],
        name: "setBondingVestingForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20BondingLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20RedeemLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "minBacking_",
            type: "uint256"
          }
        ],
        name: "setMinBacking",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "tokenOracle_",
            type: "address"
          }
        ],
        name: "setTokenOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "vestingVault_",
            type: "address"
          }
        ],
        name: "setVestingVault",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "vestingDuration",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Bond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Redemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "vestingDuration",
            type: "uint256"
          }
        ],
        name: "setupAndListERC721IdBond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "setupAndListERC721IdRedemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "token",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tokenOracle",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateOracleForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateOracleForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "vestingVault",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "withdrawERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Treasury: {
    address: "0xEAc68B2e33fA3dbde9bABf3edF17ed3437f3D992",
    abi: [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "MaxSupplyReached",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20BondingLimitExceeded",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotBondable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotRedeemable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotRegistered",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20RedeemLimitExceeded",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotBondable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotRedeemable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotRegistered",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "Treasury__StaleERC20PriceDeliveredByOracle",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "Treasury__StaleERC721IdPriceDeliveredByOracle",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "ERC20OracleUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldPrice",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newPrice",
            type: "uint256"
          }
        ],
        name: "ERC20PriceUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum Treasury.AssetType",
            name: "assetType",
            type: "uint8"
          }
        ],
        name: "ERC20Registered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20Unregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sWithdrawn",
            type: "uint256"
          }
        ],
        name: "ERC20Withdrawn",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsMinted",
            type: "uint256"
          }
        ],
        name: "ERC20sBonded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsBurned",
            type: "uint256"
          }
        ],
        name: "ERC20sRedeemed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "ERC721IdOracleUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldPrice",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newPrice",
            type: "uint256"
          }
        ],
        name: "ERC721IdPriceUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "ERC721IdRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdUnregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "ERC721IdWithdrawn",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsMinted",
            type: "uint256"
          }
        ],
        name: "ERC721IdsBonded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsBurned",
            type: "uint256"
          }
        ],
        name: "ERC721IdsRedeemed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "uint256",
            name: "epoch",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newScalar",
            type: "uint256"
          }
        ],
        name: "Rebase",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20RedeemLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "EIP712_DOMAIN",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "EIP712_REVISION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PERMIT_TYPEHASH",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC20s",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC721Ids",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "erc721",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "id",
                type: "uint256"
              }
            ],
            internalType: "struct Treasury.ERC721Id[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner_",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "assetTypeOfERC20",
        outputs: [
          {
            internalType: "enum Treasury.AssetType",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "bondERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "bondERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "executeTx",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Bondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Redeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdBondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdRedeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "oraclePerERC20",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "oraclePerERC721Id",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "rebase",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "kttWad",
            type: "uint256"
          }
        ],
        name: "redeemERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "redeemERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "redeemLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "enum Treasury.AssetType",
            name: "assetType",
            type: "uint8"
          }
        ],
        name: "registerERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "registerERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC20s",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC721Ids",
        outputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "scaledBalanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "scaledTotalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20BondingLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20RedeemLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Bond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Redemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalValuation",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "transferAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "transferAllFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "unregisterERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "unregisterERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateERC20Oracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateERC721IdOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "withdrawERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "Kolektivo Curacao Token": {
    address: "0x799aC807A4163899c09086A6C69490f6AecD65Cb",
    abi: "ERC20"
  },
  "Kolektivo Treasury Token": {
    address: "0xEAc68B2e33fA3dbde9bABf3edF17ed3437f3D992",
    abi: "ERC20"
  },
  "Test Token #1": {
    address: "0x8E7Af361418CDAb43333c6Bd0fA6906285C0E272",
    abi: "ERC20"
  },
  "Test Token #2": {
    address: "0x57f046C697B15D0933605F12152c5d96cB6f9cc5",
    abi: "ERC20"
  },
  "Test Token #3": {
    address: "0x32dB9295556D2B5193FD404253a4a3fD206B754b",
    abi: "ERC20"
  },
  "GeoNFT #1": {
    address: "0x3d088f32d7d83FD7868620f76C80604106b74702",
    id: 1,
    abi: "ERC721"
  },
  "GeoNFT #2": {
    address: "0x3d088f32d7d83FD7868620f76C80604106b74702",
    id: 2,
    abi: "ERC721"
  },
  VestingVault: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "claim",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "vestingDuration",
            type: "uint256"
          }
        ],
        name: "depositFor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "token",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "unvestedFor",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "vestedFor",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ]
  }
}, CI = {
  name: K6,
  chainId: q6,
  contracts: Q6
}, EI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: K6,
  chainId: q6,
  contracts: Q6,
  default: CI
}, Symbol.toStringTag, { value: "Module" })), J6 = [
  {
    inputs: [
      {
        internalType: "string",
        name: "_baseUri",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "TransferDisabled",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "TokenUriUpdated",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: !1,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      }
    ],
    name: "burnFromMultiple",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      }
    ],
    name: "mintToMultiple",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "baseUri",
        type: "string"
      }
    ],
    name: "setBaseUri",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "newUri",
        type: "string"
      }
    ],
    name: "setUri",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "tokenUris",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], Y6 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      },
      {
        internalType: "address",
        name: "_target",
        type: "address"
      },
      {
        internalType: "address",
        name: "_badger",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "ArraysDifferentLength",
    type: "error"
  },
  {
    inputs: [],
    name: "ModuleTransactionFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "NoMembership",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guard_",
        type: "address"
      }
    ],
    name: "NotIERC165Compliant",
    type: "error"
  },
  {
    inputs: [],
    name: "RedundantUpdateOfState",
    type: "error"
  },
  {
    inputs: [],
    name: "SetUpModulesAlreadyCalled",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousAvatar",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newAvatar",
        type: "address"
      }
    ],
    name: "AvatarSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "badgerAddress",
        type: "address"
      }
    ],
    name: "BadgerUpdated",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "guard",
        type: "address"
      }
    ],
    name: "ChangedGuard",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "avatar",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "RolesModSetup",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "multisendAddress",
        type: "address"
      }
    ],
    name: "SetMultisendAddress",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousTarget",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newTarget",
        type: "address"
      }
    ],
    name: "TargetSet",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "allowTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "avatar",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "badger",
    outputs: [
      {
        internalType: "contract IBadger",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      }
    ],
    name: "execTransactionFromModule",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      }
    ],
    name: "execTransactionFromModuleReturnData",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getGuard",
    outputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "guard",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "multisend",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      }
    ],
    name: "revokeTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "scopeAllowFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "bool[]",
        name: "isParamScoped",
        type: "bool[]"
      },
      {
        internalType: "enum ParameterType[]",
        name: "paramType",
        type: "uint8[]"
      },
      {
        internalType: "enum Comparison[]",
        name: "paramComp",
        type: "uint8[]"
      },
      {
        internalType: "bytes[]",
        name: "compValue",
        type: "bytes[]"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "scopeFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "scopeFunctionExecutionOptions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "uint256",
        name: "paramIndex",
        type: "uint256"
      },
      {
        internalType: "enum ParameterType",
        name: "paramType",
        type: "uint8"
      },
      {
        internalType: "enum Comparison",
        name: "paramComp",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "compValue",
        type: "bytes"
      }
    ],
    name: "scopeParameter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "uint256",
        name: "paramIndex",
        type: "uint256"
      },
      {
        internalType: "enum ParameterType",
        name: "paramType",
        type: "uint8"
      },
      {
        internalType: "bytes[]",
        name: "compValues",
        type: "bytes[]"
      }
    ],
    name: "scopeParameterAsOneOf",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      }
    ],
    name: "scopeRevokeFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      }
    ],
    name: "scopeTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      }
    ],
    name: "setAvatar",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    name: "setGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_multisend",
        type: "address"
      }
    ],
    name: "setMultisend",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_target",
        type: "address"
      }
    ],
    name: "setTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initParams",
        type: "bytes"
      }
    ],
    name: "setUp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "target",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "uint8",
        name: "paramIndex",
        type: "uint8"
      }
    ],
    name: "unscopeParameter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newBadger",
        type: "address"
      }
    ],
    name: "updateBadger",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], X6 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ScopeGuardSetup",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetDelegateCallAllowedOnTarget",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetFallbackAllowedOnTarget",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetFunctionAllowedOnTarget",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetTargetAllowed",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "scoped",
        type: "bool"
      }
    ],
    name: "SetTargetScoped",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetValueAllowedOnTarget",
    type: "event"
  },
  {
    stateMutability: "nonpayable",
    type: "fallback"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "allowedTargets",
    outputs: [
      {
        internalType: "bool",
        name: "allowed",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "scoped",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "delegateCallAllowed",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "fallbackAllowed",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "valueAllowed",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    name: "checkAfterExecution",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address payable",
        name: "",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "checkTransaction",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      }
    ],
    name: "isAllowedFunction",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isAllowedTarget",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isAllowedToDelegateCall",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isScoped",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isValueAllowed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isfallbackAllowed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setAllowedFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setDelegateCallAllowedOnTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setFallbackAllowedOnTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "scoped",
        type: "bool"
      }
    ],
    name: "setScoped",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setTargetAllowed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initializeParams",
        type: "bytes"
      }
    ],
    name: "setUp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setValueAllowedOnTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], Z6 = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      },
      {
        internalType: "address",
        name: "_target",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_cooldown",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_expiration",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "AlreadyDisabledModule",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "AlreadyEnabledModule",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "InvalidModule",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "NotAuthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guard_",
        type: "address"
      }
    ],
    name: "NotIERC165Compliant",
    type: "error"
  },
  {
    inputs: [],
    name: "RedundantUpdateOfState",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousAvatar",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newAvatar",
        type: "address"
      }
    ],
    name: "AvatarSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "guard",
        type: "address"
      }
    ],
    name: "ChangedGuard",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "avatar",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "DelaySetup",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "DisabledModule",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "EnabledModule",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "ExecutionFromModuleFailure",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "ExecutionFromModuleSuccess",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "queueIndex",
        type: "uint256"
      },
      {
        indexed: !0,
        internalType: "bytes32",
        name: "txHash",
        type: "bytes32"
      },
      {
        indexed: !1,
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "salt",
        type: "uint256"
      }
    ],
    name: "SecretTransactionAdded",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        indexed: !1,
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "_salt",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "txIndex",
        type: "uint256"
      }
    ],
    name: "SecretTransactionExecuted",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousTarget",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newTarget",
        type: "address"
      }
    ],
    name: "TargetSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "queueIndex",
        type: "uint256"
      },
      {
        indexed: !0,
        internalType: "bytes32",
        name: "txHash",
        type: "bytes32"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        indexed: !1,
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "TransactionAdded",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        indexed: !1,
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "txIndex",
        type: "uint256"
      }
    ],
    name: "TransactionExecuted",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "startingApprovedTrxNonce",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "numberOfTrxApproved",
        type: "uint256"
      }
    ],
    name: "TransactionsApproved",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "startingVetoedTrxNonce",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "numberOfTrxVetoed",
        type: "uint256"
      }
    ],
    name: "TransactionsVetoed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_transactions",
        type: "uint256"
      }
    ],
    name: "approveNext",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "approved",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "avatar",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "prevModule",
        type: "address"
      },
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "disableModule",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "enableModule",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "hashedTransaction",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "enqueueSecretTx",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "execTransactionFromModule",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "execTransactionFromModuleReturnData",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "returnData",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "_salt",
        type: "uint256"
      }
    ],
    name: "executeNextSecretTx",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "executeNextTx",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getGuard",
    outputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "start",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pageSize",
        type: "uint256"
      }
    ],
    name: "getModulesPaginated",
    outputs: [
      {
        internalType: "address[]",
        name: "array",
        type: "address[]"
      },
      {
        internalType: "address",
        name: "next",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "_salt",
        type: "uint256"
      }
    ],
    name: "getSecretTransactionHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "getTransactionHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_nonce",
        type: "uint256"
      }
    ],
    name: "getTxCreatedAt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_nonce",
        type: "uint256"
      }
    ],
    name: "getTxHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "guard",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_module",
        type: "address"
      }
    ],
    name: "isModuleEnabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "queuePointer",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "salt",
    outputs: [
      {
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      }
    ],
    name: "setAvatar",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    name: "setGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_target",
        type: "address"
      }
    ],
    name: "setTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "cooldown",
        type: "uint256"
      }
    ],
    name: "setTxCooldown",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "expiration",
        type: "uint256"
      }
    ],
    name: "setTxExpiration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initParams",
        type: "bytes"
      }
    ],
    name: "setUp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "skipExpired",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "target",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "txCooldown",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "txCreatedAt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "txExpiration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "txHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "txNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_newTxNonce",
        type: "uint256"
      }
    ],
    name: "vetoTransactionsTill",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_newTxNonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_transactions",
        type: "uint256"
      }
    ],
    name: "vetoTransactionsTillAndApprove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], SI = {
  Badger: J6,
  BACRoles: Y6,
  ScopeGuard: X6,
  SecretDelay: Z6
}, _I = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Badger: J6,
  BACRoles: Y6,
  ScopeGuard: X6,
  SecretDelay: Z6,
  default: SI
}, Symbol.toStringTag, { value: "Module" })), PI = {}, MI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: PI
}, Symbol.toStringTag, { value: "Module" })), e3 = [
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
], t3 = [
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], RI = {
  ERC20: e3,
  ERC721: t3
}, kI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ERC20: e3,
  ERC721: t3,
  default: RI
}, Symbol.toStringTag, { value: "Module" }));
var II = n3, Ix = 128, OI = 127, DI = ~OI, NI = Math.pow(2, 31);
function n3(n, e, t) {
  e = e || [], t = t || 0;
  for (var r = t; n >= NI; )
    e[t++] = n & 255 | Ix, n /= 128;
  for (; n & DI; )
    e[t++] = n & 255 | Ix, n >>>= 7;
  return e[t] = n | 0, n3.bytes = t - r + 1, e;
}
var BI = i0, $I = 128, Ox = 127;
function i0(n, r) {
  var t = 0, r = r || 0, i = 0, s = r, a, o = n.length;
  do {
    if (s >= o)
      throw i0.bytes = 0, new RangeError("Could not decode varint");
    a = n[s++], t += i < 28 ? (a & Ox) << i : (a & Ox) * Math.pow(2, i), i += 7;
  } while (a >= $I);
  return i0.bytes = s - r, t;
}
var LI = Math.pow(2, 7), FI = Math.pow(2, 14), UI = Math.pow(2, 21), VI = Math.pow(2, 28), jI = Math.pow(2, 35), GI = Math.pow(2, 42), WI = Math.pow(2, 49), HI = Math.pow(2, 56), zI = Math.pow(2, 63), KI = function(n) {
  return n < LI ? 1 : n < FI ? 2 : n < UI ? 3 : n < VI ? 4 : n < jI ? 5 : n < GI ? 6 : n < WI ? 7 : n < HI ? 8 : n < zI ? 9 : 10;
}, qI = {
  encode: II,
  decode: BI,
  encodingLength: KI
}, ad = qI;
const s0 = (n, e = 0) => [
  ad.decode(n, e),
  ad.decode.bytes
], od = (n, e, t = 0) => (ad.encode(n, e, t), e), cd = (n) => ad.encodingLength(n), QI = (n, e) => {
  if (n === e)
    return !0;
  if (n.byteLength !== e.byteLength)
    return !1;
  for (let t = 0; t < n.byteLength; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}, em = (n) => {
  if (n instanceof Uint8Array && n.constructor.name === "Uint8Array")
    return n;
  if (n instanceof ArrayBuffer)
    return new Uint8Array(n);
  if (ArrayBuffer.isView(n))
    return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
  throw new Error("Unknown type, must be binary type");
}, JI = (n, e) => {
  const t = e.byteLength, r = cd(n), i = r + cd(t), s = new Uint8Array(i + t);
  return od(n, s, 0), od(t, s, r), s.set(e, i), new tm(n, t, e, s);
}, YI = (n) => {
  const e = em(n), [t, r] = s0(e), [i, s] = s0(e.subarray(r)), a = e.subarray(r + s);
  if (a.byteLength !== i)
    throw new Error("Incorrect length");
  return new tm(t, i, a, e);
}, XI = (n, e) => n === e ? !0 : n.code === e.code && n.size === e.size && QI(n.bytes, e.bytes);
class tm {
  constructor(e, t, r, i) {
    this.code = e, this.size = t, this.digest = r, this.bytes = i;
  }
}
function ZI(n, e) {
  if (n.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
    t[r] = 255;
  for (var i = 0; i < n.length; i++) {
    var s = n.charAt(i), a = s.charCodeAt(0);
    if (t[a] !== 255)
      throw new TypeError(s + " is ambiguous");
    t[a] = i;
  }
  var o = n.length, c = n.charAt(0), l = Math.log(o) / Math.log(256), f = Math.log(256) / Math.log(o);
  function p(v) {
    if (v instanceof Uint8Array || (ArrayBuffer.isView(v) ? v = new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : Array.isArray(v) && (v = Uint8Array.from(v))), !(v instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (v.length === 0)
      return "";
    for (var w = 0, C = 0, _ = 0, I = v.length; _ !== I && v[_] === 0; )
      _++, w++;
    for (var B = (I - _) * f + 1 >>> 0, N = new Uint8Array(B); _ !== I; ) {
      for (var D = v[_], U = 0, W = B - 1; (D !== 0 || U < C) && W !== -1; W--, U++)
        D += 256 * N[W] >>> 0, N[W] = D % o >>> 0, D = D / o >>> 0;
      if (D !== 0)
        throw new Error("Non-zero carry");
      C = U, _++;
    }
    for (var j = B - C; j !== B && N[j] === 0; )
      j++;
    for (var q = c.repeat(w); j < B; ++j)
      q += n.charAt(N[j]);
    return q;
  }
  function g(v) {
    if (typeof v != "string")
      throw new TypeError("Expected String");
    if (v.length === 0)
      return new Uint8Array();
    var w = 0;
    if (v[w] !== " ") {
      for (var C = 0, _ = 0; v[w] === c; )
        C++, w++;
      for (var I = (v.length - w) * l + 1 >>> 0, B = new Uint8Array(I); v[w]; ) {
        var N = t[v.charCodeAt(w)];
        if (N === 255)
          return;
        for (var D = 0, U = I - 1; (N !== 0 || D < _) && U !== -1; U--, D++)
          N += o * B[U] >>> 0, B[U] = N % 256 >>> 0, N = N / 256 >>> 0;
        if (N !== 0)
          throw new Error("Non-zero carry");
        _ = D, w++;
      }
      if (v[w] !== " ") {
        for (var W = I - _; W !== I && B[W] === 0; )
          W++;
        for (var j = new Uint8Array(C + (I - W)), q = C; W !== I; )
          j[q++] = B[W++];
        return j;
      }
    }
  }
  function T(v) {
    var w = g(v);
    if (w)
      return w;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: p,
    decodeUnsafe: g,
    decode: T
  };
}
var eO = ZI, tO = eO;
class nO {
  constructor(e, t, r) {
    this.name = e, this.prefix = t, this.baseEncode = r;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class rO {
  constructor(e, t, r) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = r;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return r3(this, e);
  }
}
class iO {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return r3(this, e);
  }
  decode(e) {
    const t = e[0], r = this.decoders[t];
    if (r)
      return r.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const r3 = (n, e) => new iO({
  ...n.decoders || { [n.prefix]: n },
  ...e.decoders || { [e.prefix]: e }
});
class sO {
  constructor(e, t, r, i) {
    this.name = e, this.prefix = t, this.baseEncode = r, this.baseDecode = i, this.encoder = new nO(e, t, r), this.decoder = new rO(e, t, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const i3 = ({ name: n, prefix: e, encode: t, decode: r }) => new sO(n, e, t, r), s3 = ({ prefix: n, name: e, alphabet: t }) => {
  const { encode: r, decode: i } = tO(t, e);
  return i3({
    prefix: n,
    name: e,
    encode: r,
    decode: (s) => em(i(s))
  });
}, aO = (n, e, t, r) => {
  const i = {};
  for (let f = 0; f < e.length; ++f)
    i[e[f]] = f;
  let s = n.length;
  for (; n[s - 1] === "="; )
    --s;
  const a = new Uint8Array(s * t / 8 | 0);
  let o = 0, c = 0, l = 0;
  for (let f = 0; f < s; ++f) {
    const p = i[n[f]];
    if (p === void 0)
      throw new SyntaxError(`Non-${r} character`);
    c = c << t | p, o += t, o >= 8 && (o -= 8, a[l++] = 255 & c >> o);
  }
  if (o >= t || 255 & c << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a;
}, oO = (n, e, t) => {
  const r = e[e.length - 1] === "=", i = (1 << t) - 1;
  let s = "", a = 0, o = 0;
  for (let c = 0; c < n.length; ++c)
    for (o = o << 8 | n[c], a += 8; a > t; )
      a -= t, s += e[i & o >> a];
  if (a && (s += e[i & o << t - a]), r)
    for (; s.length * t & 7; )
      s += "=";
  return s;
}, Fi = ({ name: n, prefix: e, bitsPerChar: t, alphabet: r }) => i3({
  prefix: e,
  name: n,
  encode(i) {
    return oO(i, r, t);
  },
  decode(i) {
    return aO(i, r, t, n);
  }
}), es = s3({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
s3({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const su = Fi({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
Fi({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
Fi({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
Fi({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
Fi({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
Fi({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
Fi({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
Fi({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
Fi({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
class tn {
  constructor(e, t, r, i) {
    this.code = t, this.version = e, this.multihash = r, this.bytes = i, this.byteOffset = i.byteOffset, this.byteLength = i.byteLength, this.asCID = this, this._baseCache = /* @__PURE__ */ new Map(), Object.defineProperties(this, {
      byteOffset: $l,
      byteLength: $l,
      code: Bl,
      version: Bl,
      multihash: Bl,
      bytes: Bl,
      _baseCache: $l,
      asCID: $l
    });
  }
  toV0() {
    switch (this.version) {
      case 0:
        return this;
      default: {
        const { code: e, multihash: t } = this;
        if (e !== jo)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (t.code !== dO)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return tn.createV0(t);
      }
    }
  }
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: t } = this.multihash, r = JI(e, t);
        return tn.createV1(this.code, r);
      }
      case 1:
        return this;
      default:
        throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
    }
  }
  equals(e) {
    return e && this.code === e.code && this.version === e.version && XI(this.multihash, e.multihash);
  }
  toString(e) {
    const { bytes: t, version: r, _baseCache: i } = this;
    switch (r) {
      case 0:
        return lO(t, i, e || es.encoder);
      default:
        return uO(t, i, e || su.encoder);
    }
  }
  toJSON() {
    return {
      code: this.code,
      version: this.version,
      hash: this.multihash.bytes
    };
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return "CID(" + this.toString() + ")";
  }
  static isCID(e) {
    return hO(/^0\.0/, pO), !!(e && (e[Nx] || e.asCID === e));
  }
  get toBaseEncodedString() {
    throw new Error("Deprecated, use .toString()");
  }
  get codec() {
    throw new Error('"codec" property is deprecated, use integer "code" property instead');
  }
  get buffer() {
    throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
  }
  get multibaseName() {
    throw new Error('"multibaseName" property is deprecated');
  }
  get prefix() {
    throw new Error('"prefix" property is deprecated');
  }
  static asCID(e) {
    if (e instanceof tn)
      return e;
    if (e != null && e.asCID === e) {
      const { version: t, code: r, multihash: i, bytes: s } = e;
      return new tn(t, r, i, s || Dx(t, r, i.bytes));
    } else if (e != null && e[Nx] === !0) {
      const { version: t, multihash: r, code: i } = e, s = YI(r);
      return tn.create(t, i, s);
    } else
      return null;
  }
  static create(e, t, r) {
    if (typeof t != "number")
      throw new Error("String codecs are no longer supported");
    switch (e) {
      case 0: {
        if (t !== jo)
          throw new Error(`Version 0 CID must use dag-pb (code: ${jo}) block encoding`);
        return new tn(e, t, r, r.bytes);
      }
      case 1: {
        const i = Dx(e, t, r.bytes);
        return new tn(e, t, r, i);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  static createV0(e) {
    return tn.create(0, jo, e);
  }
  static createV1(e, t) {
    return tn.create(1, e, t);
  }
  static decode(e) {
    const [t, r] = tn.decodeFirst(e);
    if (r.length)
      throw new Error("Incorrect length");
    return t;
  }
  static decodeFirst(e) {
    const t = tn.inspectBytes(e), r = t.size - t.multihashSize, i = em(e.subarray(r, r + t.multihashSize));
    if (i.byteLength !== t.multihashSize)
      throw new Error("Incorrect length");
    const s = i.subarray(t.multihashSize - t.digestSize), a = new tm(t.multihashCode, t.digestSize, s, i);
    return [
      t.version === 0 ? tn.createV0(a) : tn.createV1(t.codec, a),
      e.subarray(t.size)
    ];
  }
  static inspectBytes(e) {
    let t = 0;
    const r = () => {
      const [p, g] = s0(e.subarray(t));
      return t += g, p;
    };
    let i = r(), s = jo;
    if (i === 18 ? (i = 0, t = 0) : i === 1 && (s = r()), i !== 0 && i !== 1)
      throw new RangeError(`Invalid CID version ${i}`);
    const a = t, o = r(), c = r(), l = t + c, f = l - a;
    return {
      version: i,
      codec: s,
      multihashCode: o,
      digestSize: c,
      multihashSize: f,
      size: l
    };
  }
  static parse(e, t) {
    const [r, i] = cO(e, t), s = tn.decode(i);
    return s._baseCache.set(r, e), s;
  }
}
const cO = (n, e) => {
  switch (n[0]) {
    case "Q": {
      const t = e || es;
      return [
        es.prefix,
        t.decode(`${es.prefix}${n}`)
      ];
    }
    case es.prefix: {
      const t = e || es;
      return [
        es.prefix,
        t.decode(n)
      ];
    }
    case su.prefix: {
      const t = e || su;
      return [
        su.prefix,
        t.decode(n)
      ];
    }
    default: {
      if (e == null)
        throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
      return [
        n[0],
        e.decode(n)
      ];
    }
  }
}, lO = (n, e, t) => {
  const { prefix: r } = t;
  if (r !== es.prefix)
    throw Error(`Cannot string encode V0 in ${t.name} encoding`);
  const i = e.get(r);
  if (i == null) {
    const s = t.encode(n).slice(1);
    return e.set(r, s), s;
  } else
    return i;
}, uO = (n, e, t) => {
  const { prefix: r } = t, i = e.get(r);
  if (i == null) {
    const s = t.encode(n);
    return e.set(r, s), s;
  } else
    return i;
}, jo = 112, dO = 18, Dx = (n, e, t) => {
  const r = cd(n), i = r + cd(e), s = new Uint8Array(i + t.byteLength);
  return od(n, s, 0), od(e, s, r), s.set(t, i), s;
}, Nx = Symbol.for("@ipld/js-cid/CID"), Bl = {
  writable: !1,
  configurable: !1,
  enumerable: !0
}, $l = {
  writable: !1,
  enumerable: !1,
  configurable: !1
}, fO = "0.0.0-dev", hO = (n, e) => {
  if (n.test(fO))
    console.warn(e);
  else
    throw new Error(e);
}, pO = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`, mO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CID: tn
}, Symbol.toStringTag, { value: "Module" }));
function a3(n) {
  return globalThis.Buffer != null ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : n;
}
function o3(n = 0) {
  return globalThis.Buffer?.allocUnsafe != null ? a3(globalThis.Buffer.allocUnsafe(n)) : new Uint8Array(n);
}
function yO(n, e) {
  e == null && (e = n.reduce((i, s) => i + s.length, 0));
  const t = o3(e);
  let r = 0;
  for (const i of n)
    t.set(i, r), r += i.length;
  return a3(t);
}
const gO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  concat: yO
}, Symbol.toStringTag, { value: "Module" }));
function bO(n, e) {
  if (n.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), r = 0; r < t.length; r++)
    t[r] = 255;
  for (var i = 0; i < n.length; i++) {
    var s = n.charAt(i), a = s.charCodeAt(0);
    if (t[a] !== 255)
      throw new TypeError(s + " is ambiguous");
    t[a] = i;
  }
  var o = n.length, c = n.charAt(0), l = Math.log(o) / Math.log(256), f = Math.log(256) / Math.log(o);
  function p(v) {
    if (v instanceof Uint8Array || (ArrayBuffer.isView(v) ? v = new Uint8Array(v.buffer, v.byteOffset, v.byteLength) : Array.isArray(v) && (v = Uint8Array.from(v))), !(v instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (v.length === 0)
      return "";
    for (var w = 0, C = 0, _ = 0, I = v.length; _ !== I && v[_] === 0; )
      _++, w++;
    for (var B = (I - _) * f + 1 >>> 0, N = new Uint8Array(B); _ !== I; ) {
      for (var D = v[_], U = 0, W = B - 1; (D !== 0 || U < C) && W !== -1; W--, U++)
        D += 256 * N[W] >>> 0, N[W] = D % o >>> 0, D = D / o >>> 0;
      if (D !== 0)
        throw new Error("Non-zero carry");
      C = U, _++;
    }
    for (var j = B - C; j !== B && N[j] === 0; )
      j++;
    for (var q = c.repeat(w); j < B; ++j)
      q += n.charAt(N[j]);
    return q;
  }
  function g(v) {
    if (typeof v != "string")
      throw new TypeError("Expected String");
    if (v.length === 0)
      return new Uint8Array();
    var w = 0;
    if (v[w] !== " ") {
      for (var C = 0, _ = 0; v[w] === c; )
        C++, w++;
      for (var I = (v.length - w) * l + 1 >>> 0, B = new Uint8Array(I); v[w]; ) {
        var N = t[v.charCodeAt(w)];
        if (N === 255)
          return;
        for (var D = 0, U = I - 1; (N !== 0 || D < _) && U !== -1; U--, D++)
          N += o * B[U] >>> 0, B[U] = N % 256 >>> 0, N = N / 256 >>> 0;
        if (N !== 0)
          throw new Error("Non-zero carry");
        _ = D, w++;
      }
      if (v[w] !== " ") {
        for (var W = I - _; W !== I && B[W] === 0; )
          W++;
        for (var j = new Uint8Array(C + (I - W)), q = C; W !== I; )
          j[q++] = B[W++];
        return j;
      }
    }
  }
  function T(v) {
    var w = g(v);
    if (w)
      return w;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: p,
    decodeUnsafe: g,
    decode: T
  };
}
var xO = bO, vO = xO;
const c3 = (n) => {
  if (n instanceof Uint8Array && n.constructor.name === "Uint8Array")
    return n;
  if (n instanceof ArrayBuffer)
    return new Uint8Array(n);
  if (ArrayBuffer.isView(n))
    return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
  throw new Error("Unknown type, must be binary type");
}, wO = (n) => new TextEncoder().encode(n), AO = (n) => new TextDecoder().decode(n);
class TO {
  constructor(e, t, r) {
    this.name = e, this.prefix = t, this.baseEncode = r;
  }
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class CO {
  constructor(e, t, r) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = t.codePointAt(0), this.baseDecode = r;
  }
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(e) {
    return l3(this, e);
  }
}
class EO {
  constructor(e) {
    this.decoders = e;
  }
  or(e) {
    return l3(this, e);
  }
  decode(e) {
    const t = e[0], r = this.decoders[t];
    if (r)
      return r.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const l3 = (n, e) => new EO({
  ...n.decoders || { [n.prefix]: n },
  ...e.decoders || { [e.prefix]: e }
});
class SO {
  constructor(e, t, r, i) {
    this.name = e, this.prefix = t, this.baseEncode = r, this.baseDecode = i, this.encoder = new TO(e, t, r), this.decoder = new CO(e, t, i);
  }
  encode(e) {
    return this.encoder.encode(e);
  }
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Hd = ({ name: n, prefix: e, encode: t, decode: r }) => new SO(n, e, t, r), hl = ({ prefix: n, name: e, alphabet: t }) => {
  const { encode: r, decode: i } = vO(t, e);
  return Hd({
    prefix: n,
    name: e,
    encode: r,
    decode: (s) => c3(i(s))
  });
}, _O = (n, e, t, r) => {
  const i = {};
  for (let f = 0; f < e.length; ++f)
    i[e[f]] = f;
  let s = n.length;
  for (; n[s - 1] === "="; )
    --s;
  const a = new Uint8Array(s * t / 8 | 0);
  let o = 0, c = 0, l = 0;
  for (let f = 0; f < s; ++f) {
    const p = i[n[f]];
    if (p === void 0)
      throw new SyntaxError(`Non-${r} character`);
    c = c << t | p, o += t, o >= 8 && (o -= 8, a[l++] = 255 & c >> o);
  }
  if (o >= t || 255 & c << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a;
}, PO = (n, e, t) => {
  const r = e[e.length - 1] === "=", i = (1 << t) - 1;
  let s = "", a = 0, o = 0;
  for (let c = 0; c < n.length; ++c)
    for (o = o << 8 | n[c], a += 8; a > t; )
      a -= t, s += e[i & o >> a];
  if (a && (s += e[i & o << t - a]), r)
    for (; s.length * t & 7; )
      s += "=";
  return s;
}, Zt = ({ name: n, prefix: e, bitsPerChar: t, alphabet: r }) => Hd({
  prefix: e,
  name: n,
  encode(i) {
    return PO(i, r, t);
  },
  decode(i) {
    return _O(i, r, t, n);
  }
}), MO = Hd({
  prefix: "\0",
  name: "identity",
  encode: (n) => AO(n),
  decode: (n) => wO(n)
}), RO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: MO
}, Symbol.toStringTag, { value: "Module" })), kO = Zt({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), IO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: kO
}, Symbol.toStringTag, { value: "Module" })), OO = Zt({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), DO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: OO
}, Symbol.toStringTag, { value: "Module" })), NO = hl({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), BO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: NO
}, Symbol.toStringTag, { value: "Module" })), $O = Zt({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), LO = Zt({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), FO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: $O,
  base16upper: LO
}, Symbol.toStringTag, { value: "Module" })), UO = Zt({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), VO = Zt({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), jO = Zt({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), GO = Zt({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), WO = Zt({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), HO = Zt({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), zO = Zt({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), KO = Zt({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), qO = Zt({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), QO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: UO,
  base32upper: VO,
  base32pad: jO,
  base32padupper: GO,
  base32hex: WO,
  base32hexupper: HO,
  base32hexpad: zO,
  base32hexpadupper: KO,
  base32z: qO
}, Symbol.toStringTag, { value: "Module" })), JO = hl({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), YO = hl({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), XO = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: JO,
  base36upper: YO
}, Symbol.toStringTag, { value: "Module" })), ZO = hl({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), eD = hl({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), tD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: ZO,
  base58flickr: eD
}, Symbol.toStringTag, { value: "Module" })), nD = Zt({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), rD = Zt({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), iD = Zt({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), sD = Zt({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), aD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: nD,
  base64pad: rD,
  base64url: iD,
  base64urlpad: sD
}, Symbol.toStringTag, { value: "Module" })), u3 = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}"), oD = u3.reduce((n, e, t) => (n[t] = e, n), []), cD = u3.reduce((n, e, t) => (n[e.codePointAt(0)] = t, n), []);
function lD(n) {
  return n.reduce((e, t) => (e += oD[t], e), "");
}
function uD(n) {
  const e = [];
  for (const t of n) {
    const r = cD[t.codePointAt(0)];
    if (r === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(r);
  }
  return new Uint8Array(e);
}
const dD = Hd({
  prefix: "\u{1F680}",
  name: "base256emoji",
  encode: lD,
  decode: uD
}), fD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: dD
}, Symbol.toStringTag, { value: "Module" }));
var hD = d3, Bx = 128, pD = 127, mD = ~pD, yD = Math.pow(2, 31);
function d3(n, e, t) {
  e = e || [], t = t || 0;
  for (var r = t; n >= yD; )
    e[t++] = n & 255 | Bx, n /= 128;
  for (; n & mD; )
    e[t++] = n & 255 | Bx, n >>>= 7;
  return e[t] = n | 0, d3.bytes = t - r + 1, e;
}
var gD = a0, bD = 128, $x = 127;
function a0(n, r) {
  var t = 0, r = r || 0, i = 0, s = r, a, o = n.length;
  do {
    if (s >= o)
      throw a0.bytes = 0, new RangeError("Could not decode varint");
    a = n[s++], t += i < 28 ? (a & $x) << i : (a & $x) * Math.pow(2, i), i += 7;
  } while (a >= bD);
  return a0.bytes = s - r, t;
}
var xD = Math.pow(2, 7), vD = Math.pow(2, 14), wD = Math.pow(2, 21), AD = Math.pow(2, 28), TD = Math.pow(2, 35), CD = Math.pow(2, 42), ED = Math.pow(2, 49), SD = Math.pow(2, 56), _D = Math.pow(2, 63), PD = function(n) {
  return n < xD ? 1 : n < vD ? 2 : n < wD ? 3 : n < AD ? 4 : n < TD ? 5 : n < CD ? 6 : n < ED ? 7 : n < SD ? 8 : n < _D ? 9 : 10;
}, MD = {
  encode: hD,
  decode: gD,
  encodingLength: PD
}, f3 = MD;
const Lx = (n, e, t = 0) => (f3.encode(n, e, t), e), Fx = (n) => f3.encodingLength(n), o0 = (n, e) => {
  const t = e.byteLength, r = Fx(n), i = r + Fx(t), s = new Uint8Array(i + t);
  return Lx(n, s, 0), Lx(t, s, r), s.set(e, i), new RD(n, t, e, s);
};
class RD {
  constructor(e, t, r, i) {
    this.code = e, this.size = t, this.digest = r, this.bytes = i;
  }
}
const h3 = ({ name: n, code: e, encode: t }) => new kD(n, e, t);
class kD {
  constructor(e, t, r) {
    this.name = e, this.code = t, this.encode = r;
  }
  digest(e) {
    if (e instanceof Uint8Array) {
      const t = this.encode(e);
      return t instanceof Uint8Array ? o0(this.code, t) : t.then((r) => o0(this.code, r));
    } else
      throw Error("Unknown type, must be binary type");
  }
}
const p3 = (n) => async (e) => new Uint8Array(await crypto.subtle.digest(n, e)), ID = h3({
  name: "sha2-256",
  code: 18,
  encode: p3("SHA-256")
}), OD = h3({
  name: "sha2-512",
  code: 19,
  encode: p3("SHA-512")
}), DD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  sha256: ID,
  sha512: OD
}, Symbol.toStringTag, { value: "Module" })), m3 = 0, ND = "identity", y3 = c3, BD = (n) => o0(m3, y3(n)), $D = { code: m3, name: ND, encode: y3, digest: BD }, LD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: $D
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const Ux = { ...RO, ...IO, ...DO, ...BO, ...FO, ...QO, ...XO, ...tD, ...aD, ...fD };
({ ...DD, ...LD });
function g3(n, e, t, r) {
  return {
    name: n,
    prefix: e,
    encoder: {
      name: n,
      prefix: e,
      encode: t
    },
    decoder: {
      decode: r
    }
  };
}
const Vx = g3("utf8", "u", (n) => "u" + new TextDecoder("utf8").decode(n), (n) => new TextEncoder().encode(n.substring(1))), rh = g3("ascii", "a", (n) => {
  let e = "a";
  for (let t = 0; t < n.length; t++)
    e += String.fromCharCode(n[t]);
  return e;
}, (n) => {
  n = n.substring(1);
  const e = o3(n.length);
  for (let t = 0; t < n.length; t++)
    e[t] = n.charCodeAt(t);
  return e;
}), FD = {
  utf8: Vx,
  "utf-8": Vx,
  hex: Ux.base16,
  latin1: rh,
  ascii: rh,
  binary: rh,
  ...Ux
};
function UD(n, e = "utf8") {
  const t = FD[e];
  if (t == null)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString("utf8") : t.encoder.encode(n).substring(1);
}
const VD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  toString: UD
}, Symbol.toStringTag, { value: "Module" }));
Array.prototype.sum = function() {
  return this.reduce((n, e) => n + e, 0);
};
function On(n) {
  return typeof n == "object" && n !== null || typeof n == "function";
}
function c0(n) {
  return n == null;
}
let dc = /* @__PURE__ */ new WeakMap();
const ln = (n, e, t, r, i) => new TypeError(`${n}(${e.map(String).join(",")}) - Expected '${t}' to be of type ${i}, but got: ${Object.prototype.toString.call(r)} (${String(r)})`);
function ys(n) {
  switch (typeof n) {
    case "undefined":
    case "string":
    case "symbol":
      return n;
    default:
      return `${n}`;
  }
}
function b3(n) {
  switch (typeof n) {
    case "string":
    case "symbol":
      return n;
    default:
      return `${n}`;
  }
}
function x3(n) {
  switch (typeof n) {
    case "undefined":
    case "string":
    case "symbol":
      return n;
    default:
      throw new TypeError(`Invalid metadata propertyKey: ${n}.`);
  }
}
function Uc(n, e, t) {
  let r = dc.get(n);
  if (r === void 0) {
    if (!t)
      return;
    r = /* @__PURE__ */ new Map(), dc.set(n, r);
  }
  let i = r.get(e);
  if (i === void 0) {
    if (!t)
      return;
    i = /* @__PURE__ */ new Map(), r.set(e, i);
  }
  return i;
}
function l0(n, e, t) {
  const r = Uc(e, t, !1);
  return r === void 0 ? !1 : r.has(n);
}
function jx(n, e, t) {
  if (l0(n, e, t))
    return !0;
  const r = u0(e);
  return r !== null ? jx(n, r, t) : !1;
}
function Gx(n, e, t) {
  const r = Uc(e, t, !1);
  if (r !== void 0)
    return r.get(n);
}
function Wx(n, e, t) {
  if (l0(n, e, t))
    return Gx(n, e, t);
  const r = u0(e);
  if (r !== null)
    return Wx(n, r, t);
}
function Hx(n, e, t, r) {
  Uc(t, r, !0).set(n, e);
}
function zx(n, e) {
  const t = [], r = Uc(n, e, !1);
  if (r === void 0)
    return t;
  const i = r.keys();
  let s = 0;
  for (const a of i)
    t[s] = a, ++s;
  return t;
}
function Kx(n, e) {
  const t = zx(n, e), r = u0(n);
  if (r === null)
    return t;
  const i = Kx(r, e), s = t.length;
  if (s === 0)
    return i;
  const a = i.length;
  if (a === 0)
    return t;
  const o = /* @__PURE__ */ new Set(), c = [];
  let l = 0, f;
  for (let p = 0; p < s; ++p)
    f = t[p], o.has(f) || (o.add(f), c[l] = f, ++l);
  for (let p = 0; p < a; ++p)
    f = i[p], o.has(f) || (o.add(f), c[l] = f, ++l);
  return c;
}
function v3(n, e, t) {
  const r = Uc(n, t, !1);
  return r === void 0 ? !1 : r.delete(e);
}
function w3(n, e) {
  function t(r, i) {
    if (!On(r))
      throw ln("@metadata", [n, e, r, i], "target", r, "Object or Function");
    Hx(n, e, r, x3(i));
  }
  return t;
}
function A3(n, e, t, r) {
  if (t !== void 0) {
    if (!Array.isArray(n))
      throw ln("Metadata.decorate", [n, e, t, r], "decorators", n, "Array");
    if (!On(e))
      throw ln("Metadata.decorate", [n, e, t, r], "target", e, "Object or Function");
    if (!On(r) && !c0(r))
      throw ln("Metadata.decorate", [n, e, t, r], "attributes", r, "Object, Function, null, or undefined");
    return r === null && (r = void 0), t = b3(t), C3(n, e, t, r);
  } else {
    if (!Array.isArray(n))
      throw ln("Metadata.decorate", [n, e, t, r], "decorators", n, "Array");
    if (typeof e != "function")
      throw ln("Metadata.decorate", [n, e, t, r], "target", e, "Function");
    return T3(n, e);
  }
}
function T3(n, e) {
  for (let t = n.length - 1; t >= 0; --t) {
    const r = n[t], i = r(e);
    if (!c0(i)) {
      if (typeof i != "function")
        throw ln("DecorateConstructor", [n, e], "decorated", i, "Function, null, or undefined");
      e = i;
    }
  }
  return e;
}
function C3(n, e, t, r) {
  for (let i = n.length - 1; i >= 0; --i) {
    const s = n[i], a = s(e, t, r);
    if (!c0(a)) {
      if (!On(a))
        throw ln("DecorateProperty", [n, e, t, r], "decorated", a, "Object, Function, null, or undefined");
      r = a;
    }
  }
  return r;
}
function qx(n, e, t, r) {
  if (!On(t))
    throw ln("Metadata.define", [n, e, t, r], "target", t, "Object or Function");
  return Hx(n, e, t, ys(r));
}
function Qx(n, e, t) {
  if (!On(e))
    throw ln("Metadata.has", [n, e, t], "target", e, "Object or Function");
  return jx(n, e, ys(t));
}
function Jx(n, e, t) {
  if (!On(e))
    throw ln("Metadata.hasOwn", [n, e, t], "target", e, "Object or Function");
  return l0(n, e, ys(t));
}
function Yx(n, e, t) {
  if (!On(e))
    throw ln("Metadata.get", [n, e, t], "target", e, "Object or Function");
  return Wx(n, e, ys(t));
}
function Xx(n, e, t) {
  if (!On(e))
    throw ln("Metadata.getOwn", [n, e, t], "target", e, "Object or Function");
  return Gx(n, e, ys(t));
}
function Zx(n, e) {
  if (!On(n))
    throw ln("Metadata.getKeys", [n, e], "target", n, "Object or Function");
  return Kx(n, ys(e));
}
function e1(n, e) {
  if (!On(n))
    throw ln("Metadata.getOwnKeys", [n, e], "target", n, "Object or Function");
  return zx(n, ys(e));
}
function t1(n, e, t) {
  if (!On(e))
    throw ln("Metadata.delete", [n, e, t], "target", e, "Object or Function");
  return v3(e, n, ys(t));
}
const Yr = {
  define: qx,
  has: Qx,
  hasOwn: Jx,
  get: Yx,
  getOwn: Xx,
  getKeys: Zx,
  getOwnKeys: e1,
  delete: t1
}, E3 = (n, e, t, r, i) => {
  if (!Reflect.defineProperty(n, e, {
    writable: r,
    enumerable: !1,
    configurable: i,
    value: t
  }))
    throw ih(`AUR1000:${e}`);
}, Ko = "[[$au]]", S3 = (n) => Ko in n, nm = (n, e, t) => [[Ko, dc], ["metadata", w3], ["decorate", A3], ["defineMetadata", qx], ["hasMetadata", Qx], ["hasOwnMetadata", Jx], ["getMetadata", Yx], ["getOwnMetadata", Xx], ["getMetadataKeys", Zx], ["getOwnMetadataKeys", e1], ["deleteMetadata", t1]].forEach(([r, i]) => E3(n, r, i, e, t)), _3 = (n, e = !0, t = !1, r = !0, i = !0) => {
  if (S3(n)) {
    if (n[Ko] === dc)
      return;
    if (n[Ko] instanceof WeakMap) {
      dc = n[Ko];
      return;
    }
    throw ih("AUR1001");
  }
  const s = "metadata decorate defineMetadata hasMetadata hasOwnMetadata getMetadata getOwnMetadata getMetadataKeys getOwnMetadataKeys deleteMetadata".split(" ").filter((a) => a in Reflect);
  if (s.length > 0)
    if (e) {
      const a = s.map(function(o) {
        const c = `${Reflect[o].toString().slice(0, 100)}...`;
        return `${o}:
${c}`;
      }).join(`

`);
      throw ih(`AUR1002:${a}`);
    } else
      t && nm(n, r, i);
  else
    nm(n, r, i);
}, ih = (n) => new Error(n), u0 = Object.getPrototypeOf, oo = String, Rn = Yr.getOwn, P3 = Yr.hasOwn, ds = Yr.define, vi = (n) => typeof n == "function", au = (n) => typeof n == "string", yi = () => /* @__PURE__ */ Object.create(null), Ft = (n) => new Error(n), pl = {}, fc = (n) => {
  switch (typeof n) {
    case "number":
      return n >= 0 && (0 | n) === n;
    case "string": {
      const e = pl[n];
      if (e !== void 0)
        return e;
      const t = n.length;
      if (t === 0)
        return pl[n] = !1;
      let r = 0, i = 0;
      for (; i < t; ++i)
        if (r = en(n, i), i === 0 && r === 48 && t > 1 || r < 48 || r > 57)
          return pl[n] = !1;
      return pl[n] = !0;
    }
    default:
      return !1;
  }
}, n1 = function() {
  const n = Object.assign(yi(), {
    0: !0,
    1: !0,
    2: !0,
    3: !0,
    4: !0,
    5: !0,
    6: !0,
    7: !0,
    8: !0,
    9: !0
  }), e = (t) => t === "" ? 0 : t !== t.toUpperCase() ? 3 : t !== t.toLowerCase() ? 2 : n[t] === !0 ? 1 : 0;
  return (t, r) => {
    const i = t.length;
    if (i === 0)
      return t;
    let s = !1, a = "", o, c = "", l = 0, f = t.charAt(0), p = e(f), g = 0;
    for (; g < i; ++g)
      o = l, c = f, l = p, f = t.charAt(g + 1), p = e(f), l === 0 ? a.length > 0 && (s = !0) : (!s && a.length > 0 && l === 2 && (s = o === 3 || p === 3), a += r(c, s), s = !1);
    return a;
  };
}(), Kn = function() {
  const n = yi(), e = (t, r) => r ? t.toUpperCase() : t.toLowerCase();
  return (t) => {
    let r = n[t];
    return r === void 0 && (r = n[t] = n1(t, e)), r;
  };
}(), M3 = function() {
  const n = yi();
  return (e) => {
    let t = n[e];
    return t === void 0 && (t = Kn(e), t.length > 0 && (t = t[0].toUpperCase() + t.slice(1)), n[e] = t), t;
  };
}(), r1 = function() {
  const n = yi(), e = (t, r) => r ? `-${t.toLowerCase()}` : t.toLowerCase();
  return (t) => {
    let r = n[t];
    return r === void 0 && (r = n[t] = n1(t, e)), r;
  };
}(), of = (n) => {
  const e = n.length, t = Array(e);
  let r = 0;
  for (; r < e; ++r)
    t[r] = n[r];
  return t;
}, co = (n, e, t) => ({
  configurable: !0,
  enumerable: t.enumerable,
  get() {
    const r = t.value.bind(this);
    return Reflect.defineProperty(this, e, {
      value: r,
      writable: !0,
      configurable: !0,
      enumerable: t.enumerable
    }), r;
  }
}), kt = (...n) => {
  const e = [];
  let t = 0;
  const r = n.length;
  let i = 0, s, a = 0;
  for (; a < r; ++a)
    if (s = n[a], s !== void 0) {
      i = s.length;
      let o = 0;
      for (; o < i; ++o)
        e[t++] = s[o];
    }
  return e;
}, on = (...n) => {
  const e = n.length;
  let t, r = 0;
  for (; e > r; ++r)
    if (t = n[r], t !== void 0)
      return t;
  throw Ft("No default value found");
}, i1 = function() {
  const n = Function.prototype, e = Object.getPrototypeOf, t = /* @__PURE__ */ new WeakMap();
  let r = n, i = 0, s;
  return function(a) {
    if (s = t.get(a), s === void 0)
      for (t.set(a, s = [r = a]), i = 0; (r = e(r)) !== n; )
        s[++i] = r;
    return s;
  };
}();
function hc(...n) {
  return Object.assign(yi(), ...n);
}
const rm = function() {
  const n = /* @__PURE__ */ new WeakMap();
  let e = !1, t = "", r = 0;
  return (i) => (e = n.get(i), e === void 0 && (t = i.toString(), r = t.length, e = r >= 29 && r <= 100 && en(t, r - 1) === 125 && en(t, r - 2) <= 32 && en(t, r - 3) === 93 && en(t, r - 4) === 101 && en(t, r - 5) === 100 && en(t, r - 6) === 111 && en(t, r - 7) === 99 && en(t, r - 8) === 32 && en(t, r - 9) === 101 && en(t, r - 10) === 118 && en(t, r - 11) === 105 && en(t, r - 12) === 116 && en(t, r - 13) === 97 && en(t, r - 14) === 110 && en(t, r - 15) === 88, n.set(i, e)), e);
}(), Se = (n, e) => n instanceof Promise ? n.then(e) : e(n), jt = (...n) => {
  let e, t, r, i = 0, s = n.length;
  for (; i < s; ++i)
    e = n[i], (e = n[i]) instanceof Promise && (t === void 0 ? t = e : r === void 0 ? r = [t, e] : r.push(e));
  return r === void 0 ? t : Promise.all(r);
}, en = (n, e) => n.charCodeAt(e), Qs = "au:annotation", gi = (n, e) => e === void 0 ? `${Qs}:${n}` : `${Qs}:${n}:${e}`, d0 = (n, e) => {
  const t = Rn(Qs, n);
  t === void 0 ? ds(Qs, [e], n) : t.push(e);
}, R3 = Object.freeze({
  name: "au:annotation",
  appendTo: d0,
  set(n, e, t) {
    ds(gi(e), t, n);
  },
  get: (n, e) => Rn(gi(e), n),
  getKeys(n) {
    let e = Rn(Qs, n);
    return e === void 0 && ds(Qs, e = [], n), e;
  },
  isKey: (n) => n.startsWith(Qs),
  keyFor: gi
}), Ir = "au:resource", k3 = Object.freeze({
  name: Ir,
  appendTo(n, e) {
    const t = Rn(Ir, n);
    t === void 0 ? ds(Ir, [e], n) : t.push(e);
  },
  has: (n) => P3(Ir, n),
  getAll(n) {
    const e = Rn(Ir, n);
    return e === void 0 ? Ne : e.map((t) => Rn(t, n));
  },
  getKeys(n) {
    let e = Rn(Ir, n);
    return e === void 0 && ds(Ir, e = [], n), e;
  },
  isKey: (n) => n.startsWith(Ir),
  keyFor(n, e) {
    return e === void 0 ? `${Ir}:${n}` : `${Ir}:${n}:${e}`;
  }
}), Ar = {
  annotation: R3,
  resource: k3
}, s1 = Object.prototype.hasOwnProperty;
function mr(n, e, t, r) {
  let i = Rn(gi(n), t);
  return i === void 0 ? (i = e[n], i === void 0 ? (i = t[n], i === void 0 || !s1.call(t, n) ? r() : i) : i) : i;
}
function Xn(n, e, t) {
  let r = Rn(gi(n), e);
  return r === void 0 ? (r = e[n], r === void 0 || !s1.call(e, n) ? t() : r) : r;
}
function Cn(n, e, t) {
  const r = e[n];
  return r === void 0 ? t() : r;
}
const I3 = new Set("Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise RangeError ReferenceError RegExp Set SharedArrayBuffer String SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet".split(" "));
let O3 = 0;
class qo {
  constructor(e, t) {
    this.parent = e, this.config = t, this.id = ++O3, this.t = 0, this.i = /* @__PURE__ */ new Map(), e === null ? (this.root = this, this.u = /* @__PURE__ */ new Map(), this.h = /* @__PURE__ */ new Map(), this.res = yi()) : (this.root = e.root, this.u = /* @__PURE__ */ new Map(), this.h = e.h, t.inheritParentResources ? this.res = Object.assign(yi(), e.res, this.root.res) : this.res = yi()), this.u.set(lo, D3);
  }
  get depth() {
    return this.parent === null ? 0 : this.parent.depth + 1;
  }
  register(...e) {
    if (++this.t === 100)
      throw L3(e);
    let t, r, i, s, a, o = 0, c = e.length;
    for (; o < c; ++o)
      if (t = e[o], !!On(t))
        if (Ll(t))
          t.register(this);
        else if (Ar.resource.has(t)) {
          const l = Ar.resource.getAll(t);
          if (l.length === 1)
            l[0].register(this);
          else
            for (s = 0, a = l.length; a > s; )
              l[s].register(this), ++s;
        } else if (B3(t))
          fe.singleton(t, t).register(this);
        else
          for (r = Object.keys(t), s = 0, a = r.length; s < a; ++s)
            i = t[r[s]], On(i) && (Ll(i) ? i.register(this) : this.register(i));
    return --this.t, this;
  }
  registerResolver(e, t, r = !1) {
    ml(e);
    const i = this.u, s = i.get(e);
    if (s == null) {
      if (i.set(e, t), $3(e)) {
        if (this.res[e] !== void 0)
          throw F3(e);
        this.res[e] = t;
      }
    } else
      s instanceof or && s.R === 4 ? s._state.push(t) : i.set(e, new or(e, 4, [s, t]));
    return r && this.i.set(e, t), t;
  }
  registerTransformer(e, t) {
    const r = this.getResolver(e);
    if (r == null)
      return !1;
    if (r.getFactory) {
      const i = r.getFactory(this);
      return i == null ? !1 : (i.registerTransformer(t), !0);
    }
    return !1;
  }
  getResolver(e, t = !0) {
    if (ml(e), e.resolve !== void 0)
      return e;
    let r = this, i, s;
    for (; r != null; )
      if (i = r.u.get(e), i == null) {
        if (r.parent == null)
          return s = sm(e) ? this : r, t ? this.$(e, s) : null;
        r = r.parent;
      } else
        return i;
    return null;
  }
  has(e, t = !1) {
    return this.u.has(e) ? !0 : t && this.parent != null ? this.parent.has(e, !0) : !1;
  }
  get(e) {
    if (ml(e), e.$isResolver)
      return e.resolve(this, this);
    let t = this, r, i;
    for (; t != null; )
      if (r = t.u.get(e), r == null) {
        if (t.parent == null)
          return i = sm(e) ? this : t, r = this.$(e, i), r.resolve(t, this);
        t = t.parent;
      } else
        return r.resolve(t, this);
    throw U3(e);
  }
  getAll(e, t = !1) {
    ml(e);
    const r = this;
    let i = r, s;
    if (t) {
      let a = Ne;
      for (; i != null; )
        s = i.u.get(e), s != null && (a = a.concat(im(s, i, r))), i = i.parent;
      return a;
    } else
      for (; i != null; )
        if (s = i.u.get(e), s == null) {
          if (i = i.parent, i == null)
            return Ne;
        } else
          return im(s, i, r);
    return Ne;
  }
  invoke(e, t) {
    if (rm(e))
      throw om(e);
    return t === void 0 ? new e(...Qo(e).map(ou, this)) : new e(...Qo(e).map(ou, this), ...t);
  }
  getFactory(e) {
    let t = this.h.get(e);
    if (t === void 0) {
      if (rm(e))
        throw om(e);
      this.h.set(e, t = new l5(e, Qo(e)));
    }
    return t;
  }
  registerFactory(e, t) {
    this.h.set(e, t);
  }
  createChild(e) {
    return e === void 0 && this.config.inheritParentResources ? this.config === Gr.DEFAULT ? new qo(this, this.config) : new qo(this, Gr.from({
      ...this.config,
      inheritParentResources: !1
    })) : new qo(this, Gr.from(e ?? this.config));
  }
  disposeResolvers() {
    const e = this.u, t = this.i;
    let r, i;
    for ([i, r] of t.entries())
      r.dispose(), e.delete(i);
    t.clear();
  }
  find(e, t) {
    const r = e.keyFrom(t);
    let i = this.res[r];
    if (i === void 0 && (i = this.root.res[r], i === void 0) || i === null)
      return null;
    if (vi(i.getFactory)) {
      const s = i.getFactory(this);
      if (s == null)
        return null;
      const a = Rn(e.name, s.Type);
      return a === void 0 ? null : a;
    }
    return null;
  }
  create(e, t) {
    const r = e.keyFrom(t);
    let i = this.res[r];
    return i === void 0 ? (i = this.root.res[r], i === void 0 ? null : i.resolve(this.root, this) ?? null) : i.resolve(this, this) ?? null;
  }
  dispose() {
    this.i.size > 0 && this.disposeResolvers(), this.u.clear();
  }
  $(e, t) {
    if (!vi(e))
      throw V3(e);
    if (I3.has(e.name))
      throw j3(e);
    if (Ll(e)) {
      const r = e.register(t, e);
      if (!(r instanceof Object) || r.resolve == null) {
        const i = t.u.get(e);
        if (i != null)
          return i;
        throw am();
      }
      return r;
    } else if (Ar.resource.has(e)) {
      const r = Ar.resource.getAll(e);
      if (r.length === 1)
        r[0].register(t);
      else {
        const s = r.length;
        for (let a = 0; a < s; ++a)
          r[a].register(t);
      }
      const i = t.u.get(e);
      if (i != null)
        return i;
      throw am();
    } else {
      if (e.$isInterface)
        throw G3(e.friendlyName);
      {
        const r = this.config.defaultResolver(e, t);
        return t.u.set(e, r), r;
      }
    }
  }
}
function ml(n) {
  if (n == null)
    throw Ft("AUR0014");
}
const im = (n, e, t) => {
  if (n instanceof or && n.R === 4) {
    const r = n._state;
    let i = r.length;
    const s = new Array(i);
    for (; i--; )
      s[i] = r[i].resolve(e, t);
    return s;
  }
  return [n.resolve(e, t)];
}, D3 = {
  $isResolver: !0,
  resolve(n, e) {
    return e;
  }
}, Ll = (n) => vi(n.register), N3 = (n) => Ll(n) && typeof n.registerInRequestor == "boolean", sm = (n) => N3(n) && n.registerInRequestor, B3 = (n) => n.prototype !== void 0, $3 = (n) => au(n) && n.indexOf(":") > 0, L3 = (n) => Ft(`AUR0006:${n.map(oo)}`), F3 = (n) => Ft(`AUR0007:${oo(n)}`), U3 = (n) => Ft(`AUR0008:${oo(n)}`), V3 = (n) => Ft(`AUR0009:${oo(n)}`), j3 = (n) => Ft(`AUR0010:${n.name}`), am = () => Ft("AUR0011"), G3 = (n) => Ft(`AUR0012:${n}`), om = (n) => Ft(`AUR0015:${n.name}`), a1 = (n, e) => new or(n, 0, e), f0 = (n, e) => new or(n, 1, e), W3 = (n, e) => new or(n, 2, e), H3 = (n, e) => new or(n, 3, e), z3 = (n, e) => new or(n, 3, o1(e)), K3 = (n, e) => new or(e, 5, n), q3 = (n, ...e) => new u5(n, e), cm = /* @__PURE__ */ new WeakMap(), o1 = (n) => (e, t, r) => {
  let i = cm.get(e);
  if (i === void 0 && cm.set(e, i = /* @__PURE__ */ new WeakMap()), i.has(r))
    return i.get(r);
  const s = n(e, t, r);
  return i.set(r, s), s;
};
_3(Reflect, !1, !1);
class Q3 {
  constructor(e, t) {
    this.c = e, this.k = t;
  }
  instance(e) {
    return this.C(0, e);
  }
  singleton(e) {
    return this.C(1, e);
  }
  transient(e) {
    return this.C(2, e);
  }
  callback(e) {
    return this.C(3, e);
  }
  cachedCallback(e) {
    return this.C(3, o1(e));
  }
  aliasTo(e) {
    return this.C(5, e);
  }
  C(e, t) {
    const { c: r, k: i } = this;
    return this.c = this.k = void 0, r.registerResolver(i, new or(i, e, t));
  }
}
const Io = (n) => {
  const e = n.slice(), t = Object.keys(n), r = t.length;
  let i;
  for (let s = 0; s < r; ++s)
    i = t[s], fc(i) || (e[i] = n[i]);
  return e;
}, J3 = {
  none(n) {
    throw Y3(n);
  },
  singleton: (n) => new or(n, 1, n),
  transient: (n) => new or(n, 2, n)
}, Y3 = (n) => Ft(`AUR0002:${oo(n)}`);
class Gr {
  constructor(e, t) {
    this.inheritParentResources = e, this.defaultResolver = t;
  }
  static from(e) {
    return e === void 0 || e === Gr.DEFAULT ? Gr.DEFAULT : new Gr(e.inheritParentResources ?? !1, e.defaultResolver ?? J3.singleton);
  }
}
Gr.DEFAULT = Gr.from({});
const X3 = (n) => new qo(null, Gr.from(n)), c1 = (n) => {
  const e = gi("di:paramtypes");
  return Rn(e, n);
}, Z3 = (n) => Rn("design:paramtypes", n), ka = (n) => {
  const e = gi("di:paramtypes");
  let t = Rn(e, n);
  return t === void 0 && (ds(e, t = [], n), d0(n, e)), t;
}, Qo = (n) => {
  const e = gi("di:dependencies");
  let t = Rn(e, n);
  if (t === void 0) {
    const r = n.inject;
    if (r === void 0) {
      const i = pe.getDesignParamtypes(n), s = c1(n);
      if (i === void 0)
        if (s === void 0) {
          const a = Object.getPrototypeOf(n);
          vi(a) && a !== Function.prototype ? t = Io(Qo(a)) : t = [];
        } else
          t = Io(s);
      else if (s === void 0)
        t = Io(i);
      else {
        t = Io(i);
        let a = s.length, o, c = 0;
        for (; c < a; ++c)
          o = s[c], o !== void 0 && (t[c] = o);
        const l = Object.keys(s);
        let f;
        for (c = 0, a = l.length, c = 0; c < a; ++c)
          f = l[c], fc(f) || (t[f] = s[f]);
      }
    } else
      t = Io(r);
    ds(e, t, n), d0(n, e);
  }
  return t;
}, Xr = (n, e) => {
  const t = vi(n) ? n : e, r = au(n) ? n : void 0, i = function(s, a, o) {
    if (s == null || new.target !== void 0)
      throw e5(i.friendlyName);
    const c = ka(s);
    c[o] = i;
  };
  return i.$isInterface = !0, i.friendlyName = r ?? "(anonymous)", t != null && (i.register = (s, a) => t(new Q3(s, a ?? i))), i.toString = () => `InterfaceSymbol<${i.friendlyName}>`, i;
}, e5 = (n) => Ft(`AUR0001:${n}`), pe = {
  createContainer: X3,
  getDesignParamtypes: Z3,
  getAnnotationParamtypes: c1,
  getOrCreateAnnotationParamTypes: ka,
  getDependencies: Qo,
  createInterface: Xr,
  inject(...n) {
    return (e, t, r) => {
      if (typeof r == "number") {
        const i = ka(e), s = n[0];
        s !== void 0 && (i[r] = s);
      } else if (t) {
        const i = ka(e.constructor), s = n[0];
        s !== void 0 && (i[t] = s);
      } else if (r) {
        const i = r.value, s = ka(i);
        let a, o = 0;
        for (; o < n.length; ++o)
          a = n[o], a !== void 0 && (s[o] = a);
      } else {
        const i = ka(e);
        let s, a = 0;
        for (; a < n.length; ++a)
          s = n[a], s !== void 0 && (i[a] = s);
      }
    };
  },
  transient(n) {
    return n.register = function(e) {
      return fe.transient(n, n).register(e, n);
    }, n.registerInRequestor = !1, n;
  },
  singleton(n, e = r5) {
    return n.register = function(t) {
      return fe.singleton(n, n).register(t, n);
    }, n.registerInRequestor = e.scoped, n;
  }
}, lo = Xr("IContainer"), t5 = lo;
function n5(n) {
  return function(e) {
    const t = function(r, i, s) {
      h0(t)(r, i, s);
    };
    return t.$isResolver = !0, t.resolve = function(r, i) {
      return n(e, r, i);
    }, t;
  };
}
const h0 = pe.inject;
function lm(n) {
  return pe.transient(n);
}
function l1(n) {
  return n == null ? lm : lm(n);
}
const r5 = {
  scoped: !1
}, i5 = (n) => (e, t) => {
  t = !!t;
  const r = function(i, s, a) {
    h0(r)(i, s, a);
  };
  return r.$isResolver = !0, r.resolve = function(i, s) {
    return n(e, i, s, t);
  }, r;
}, u1 = i5((n, e, t, r) => t.getAll(n, r)), d1 = n5((n, e, t) => {
  if (t.has(n, !0))
    return t.get(n);
}), ld = (n, e, t) => {
  h0(ld)(n, e, t);
};
ld.$isResolver = !0;
ld.resolve = () => {
};
class or {
  constructor(e, t, r) {
    this.k = e, this.R = t, this._state = r, this.resolving = !1;
  }
  get $isResolver() {
    return !0;
  }
  register(e, t) {
    return e.registerResolver(t || this.k, this);
  }
  resolve(e, t) {
    switch (this.R) {
      case 0:
        return this._state;
      case 1:
        if (this.resolving)
          throw s5(this._state.name);
        return this.resolving = !0, this._state = e.getFactory(this._state).construct(t), this.R = 0, this.resolving = !1, this._state;
      case 2: {
        const r = e.getFactory(this._state);
        if (r === null)
          throw a5(this.k);
        return r.construct(t);
      }
      case 3:
        return this._state(e, t, this);
      case 4:
        return this._state[0].resolve(e, t);
      case 5:
        return t.get(this._state);
      default:
        throw o5(this.R);
    }
  }
  getFactory(e) {
    switch (this.R) {
      case 1:
      case 2:
        return e.getFactory(this._state);
      case 5:
        return e.getResolver(this._state)?.getFactory?.(e) ?? null;
      default:
        return null;
    }
  }
}
const s5 = (n) => Ft(`AUR0003:${n}`), a5 = (n) => Ft(`AUR0004:${oo(n)}`), o5 = (n) => Ft(`AUR0005:${n}`);
function ou(n) {
  return this.get(n);
}
function c5(n, e) {
  return e(n);
}
class l5 {
  constructor(e, t) {
    this.Type = e, this.dependencies = t, this.transformers = null;
  }
  construct(e, t) {
    let r;
    return t === void 0 ? r = new this.Type(...this.dependencies.map(ou, e)) : r = new this.Type(...this.dependencies.map(ou, e), ...t), this.transformers == null ? r : this.transformers.reduce(c5, r);
  }
  registerTransformer(e) {
    (this.transformers ?? (this.transformers = [])).push(e);
  }
}
class u5 {
  constructor(e, t) {
    this.key = e, this.params = t;
  }
  register(e) {
    e.has(this.key, !0) ? e.get(this.key).register(e, ...this.params) : e.register(...this.params.filter((t) => typeof t == "object"));
  }
}
const fe = {
  instance: a1,
  singleton: f0,
  transient: W3,
  callback: H3,
  cachedCallback: z3,
  aliasTo: K3,
  defer: q3
};
class un {
  constructor(e, t) {
    this.A = null, this.j = e, t !== void 0 && (this.A = t);
  }
  get friendlyName() {
    return this.j;
  }
  prepare(e) {
    this.A = e;
  }
  get $isResolver() {
    return !0;
  }
  resolve() {
    if (this.A == null)
      throw d5(this.j);
    return this.A;
  }
  dispose() {
    this.A = null;
  }
}
const d5 = (n) => Ft(`AUR0013:${n}`), Ne = Object.freeze([]), f5 = Object.freeze({});
function bi() {
}
const Vc = Xr("IPlatform");
function Ri(n, e, t, r) {
  var i = arguments.length, s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, r);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (a = n[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function Hs(n, e) {
  return function(t, r) {
    e(t, r, n);
  };
}
var um;
(function(n) {
  n[n.trace = 0] = "trace", n[n.debug = 1] = "debug", n[n.info = 2] = "info", n[n.warn = 3] = "warn", n[n.error = 4] = "error", n[n.fatal = 5] = "fatal", n[n.none = 6] = "none";
})(um || (um = {}));
var dm;
(function(n) {
  n[n.noColors = 0] = "noColors", n[n.colors = 1] = "colors";
})(dm || (dm = {}));
const p0 = Xr("ILogConfig", (n) => n.instance(new f1(0, 3))), m0 = Xr("ISink"), h5 = Xr("ILogEventFactory", (n) => n.singleton(sh)), pa = Xr("ILogger", (n) => n.singleton(wi)), p5 = Xr("ILogScope"), m5 = Object.freeze({
  key: gi("logger-sink-handles"),
  define(n, e) {
    return ds(this.key, e.handles, n.prototype), n;
  },
  getHandles(n) {
    return Yr.get(this.key, n);
  }
}), si = hc({
  red(n) {
    return `\x1B[31m${n}\x1B[39m`;
  },
  green(n) {
    return `\x1B[32m${n}\x1B[39m`;
  },
  yellow(n) {
    return `\x1B[33m${n}\x1B[39m`;
  },
  blue(n) {
    return `\x1B[34m${n}\x1B[39m`;
  },
  magenta(n) {
    return `\x1B[35m${n}\x1B[39m`;
  },
  cyan(n) {
    return `\x1B[36m${n}\x1B[39m`;
  },
  white(n) {
    return `\x1B[37m${n}\x1B[39m`;
  },
  grey(n) {
    return `\x1B[90m${n}\x1B[39m`;
  }
});
class f1 {
  constructor(e, t) {
    this.colorOptions = e, this.level = t;
  }
}
const fm = function() {
  const n = [hc({
    TRC: "TRC",
    DBG: "DBG",
    INF: "INF",
    WRN: "WRN",
    ERR: "ERR",
    FTL: "FTL",
    QQQ: "???"
  }), hc({
    TRC: si.grey("TRC"),
    DBG: si.grey("DBG"),
    INF: si.white("INF"),
    WRN: si.yellow("WRN"),
    ERR: si.red("ERR"),
    FTL: si.red("FTL"),
    QQQ: si.grey("???")
  })];
  return (e, t) => e <= 0 ? n[t].TRC : e <= 1 ? n[t].DBG : e <= 2 ? n[t].INF : e <= 3 ? n[t].WRN : e <= 4 ? n[t].ERR : e <= 5 ? n[t].FTL : n[t].QQQ;
}(), y5 = (n, e) => e === 0 ? n.join(".") : n.map(si.cyan).join("."), hm = (n, e) => e === 0 ? new Date(n).toISOString() : si.grey(new Date(n).toISOString());
class g5 {
  constructor(e, t, r, i, s, a) {
    this.severity = e, this.message = t, this.optionalParams = r, this.scope = i, this.colorOptions = s, this.timestamp = a;
  }
  toString() {
    const { severity: e, message: t, scope: r, colorOptions: i, timestamp: s } = this;
    return r.length === 0 ? `${hm(s, i)} [${fm(e, i)}] ${t}` : `${hm(s, i)} [${fm(e, i)} ${y5(r, i)}] ${t}`;
  }
}
let sh = class {
  constructor(e) {
    this.config = e;
  }
  createLogEvent(e, t, r, i) {
    return new g5(t, r, i, e.scope, this.config.colorOptions, Date.now());
  }
};
sh = Ri([Hs(0, p0)], sh);
let pm = class h1 {
  constructor(e) {
    const t = e.console;
    this.handleEvent = function(i) {
      const s = i.optionalParams;
      if (s === void 0 || s.length === 0) {
        const a = i.toString();
        switch (i.severity) {
          case 0:
          case 1:
            return t.debug(a);
          case 2:
            return t.info(a);
          case 3:
            return t.warn(a);
          case 4:
          case 5:
            return t.error(a);
        }
      } else {
        let a = i.toString(), o = 0;
        for (; a.includes("%s"); )
          a = a.replace("%s", String(s[o++]));
        switch (i.severity) {
          case 0:
          case 1:
            return t.debug(a, ...s.slice(o));
          case 2:
            return t.info(a, ...s.slice(o));
          case 3:
            return t.warn(a, ...s.slice(o));
          case 4:
          case 5:
            return t.error(a, ...s.slice(o));
        }
      }
    };
  }
  static register(e) {
    f0(m0, h1).register(e);
  }
};
pm = Ri([Hs(0, Vc)], pm);
let wi = class p1 {
  constructor(e, t, r, i = [], s = null) {
    this.scope = i, this.I = yi();
    let a, o, c, l, f, p;
    if (this.config = e, this.f = t, this.sinks = r, s === null) {
      this.root = this, this.parent = this, a = this.O = [], o = this.M = [], c = this.F = [], l = this.L = [], f = this.U = [], p = this.T = [];
      for (const g of r) {
        const T = m5.getHandles(g);
        (T?.includes(0) ?? !0) && a.push(g), (T?.includes(1) ?? !0) && o.push(g), (T?.includes(2) ?? !0) && c.push(g), (T?.includes(3) ?? !0) && l.push(g), (T?.includes(4) ?? !0) && f.push(g), (T?.includes(5) ?? !0) && p.push(g);
      }
    } else
      this.root = s.root, this.parent = s, a = this.O = s.O, o = this.M = s.M, c = this.F = s.F, l = this.L = s.L, f = this.U = s.U, p = this.T = s.T;
  }
  trace(e, ...t) {
    this.config.level <= 0 && this.P(this.O, 0, e, t);
  }
  debug(e, ...t) {
    this.config.level <= 1 && this.P(this.M, 1, e, t);
  }
  info(e, ...t) {
    this.config.level <= 2 && this.P(this.F, 2, e, t);
  }
  warn(e, ...t) {
    this.config.level <= 3 && this.P(this.L, 3, e, t);
  }
  error(e, ...t) {
    this.config.level <= 4 && this.P(this.U, 4, e, t);
  }
  fatal(e, ...t) {
    this.config.level <= 5 && this.P(this.T, 5, e, t);
  }
  scopeTo(e) {
    const t = this.I;
    let r = t[e];
    return r === void 0 && (r = t[e] = new p1(this.config, this.f, void 0, this.scope.concat(e), this)), r;
  }
  P(e, t, r, i) {
    const s = vi(r) ? r() : r, a = this.f.createLogEvent(this, t, s, i);
    for (let o = 0, c = e.length; o < c; ++o)
      e[o].handleEvent(a);
  }
};
Ri([co], wi.prototype, "trace", null);
Ri([co], wi.prototype, "debug", null);
Ri([co], wi.prototype, "info", null);
Ri([co], wi.prototype, "warn", null);
Ri([co], wi.prototype, "error", null);
Ri([co], wi.prototype, "fatal", null);
wi = Ri([Hs(0, p0), Hs(1, h5), Hs(2, u1(m0)), Hs(3, d1(p5)), Hs(4, ld)], wi);
hc({
  create({ level: n = 3, colorOptions: e = 0, sinks: t = [] } = {}) {
    return hc({
      register(r) {
        r.register(a1(p0, new f1(e, n)));
        for (const i of t)
          vi(i) ? r.register(f0(m0, i)) : r.register(i);
        return r;
      }
    });
  }
});
Xr((n) => n.singleton(v5));
const b5 = (n) => n;
class x5 {
  constructor(e) {
    this.N = /* @__PURE__ */ new Map(), this.W = /* @__PURE__ */ new Map(), this.B = e;
  }
  transform(e) {
    if (e instanceof Promise)
      return this._(e);
    if (typeof e == "object" && e !== null)
      return this.G(e);
    throw Ft(`Invalid input: ${String(e)}. Expected Promise or Object.`);
  }
  _(e) {
    if (this.N.has(e))
      return this.N.get(e);
    const t = e.then((r) => this.G(r));
    return this.N.set(e, t), t.then((r) => {
      this.N.set(e, r);
    }), t;
  }
  G(e) {
    if (this.W.has(e))
      return this.W.get(e);
    const t = this.B(this.K(e));
    return this.W.set(e, t), t instanceof Promise && t.then((r) => {
      this.W.set(e, r);
    }), t;
  }
  K(e) {
    if (e == null)
      throw new Error(`Invalid input: ${String(e)}. Expected Object.`);
    if (typeof e != "object")
      return new mm(e, []);
    let t, r, i, s;
    const a = [];
    for (const o in e) {
      switch (typeof (t = e[o])) {
        case "object":
          if (t === null)
            continue;
          r = vi(t.register), i = !1, s = Ne;
          break;
        case "function":
          r = vi(t.register), i = t.prototype !== void 0, s = Ar.resource.getAll(t);
          break;
        default:
          continue;
      }
      a.push(new w5(o, t, r, i, s));
    }
    return new mm(e, a);
  }
}
class v5 {
  constructor() {
    this.transformers = /* @__PURE__ */ new Map();
  }
  load(e, t = b5) {
    const r = this.transformers;
    let i = r.get(t);
    return i === void 0 && r.set(t, i = new x5(t)), i.transform(e);
  }
  dispose() {
    this.transformers.clear();
  }
}
class mm {
  constructor(e, t) {
    this.raw = e, this.items = t;
  }
}
class w5 {
  constructor(e, t, r, i, s) {
    this.key = e, this.value = t, this.isRegistry = r, this.isConstructable = i, this.definitions = s;
  }
}
class A5 {
  constructor(e, t) {
    this.type = e, this.cb = t;
  }
  handle(e) {
    e instanceof this.type && this.cb.call(null, e);
  }
}
const ud = Xr("IEventAggregator", (n) => n.singleton(T5));
class T5 {
  constructor() {
    this.eventLookup = {}, this.messageHandlers = [];
  }
  publish(e, t) {
    if (!e)
      throw Ft(`Invalid channel name or instance: ${e}.`);
    if (au(e)) {
      let r = this.eventLookup[e];
      if (r !== void 0) {
        r = r.slice();
        let i = r.length;
        for (; i-- > 0; )
          r[i](t, e);
      }
    } else {
      const r = this.messageHandlers.slice();
      let i = r.length;
      for (; i-- > 0; )
        r[i].handle(e);
    }
  }
  subscribe(e, t) {
    if (!e)
      throw Ft(`Invalid channel name or type: ${e}.`);
    let r, i;
    return au(e) ? (this.eventLookup[e] === void 0 && (this.eventLookup[e] = []), r = t, i = this.eventLookup[e]) : (r = new A5(e, t), i = this.messageHandlers), i.push(r), {
      dispose() {
        const s = i.indexOf(r);
        s !== -1 && i.splice(s, 1);
      }
    };
  }
  subscribeOnce(e, t) {
    const r = this.subscribe(e, (i, s) => {
      r.dispose(), t(i, s);
    });
    return r;
  }
}
const dd = Object, C5 = dd.prototype.hasOwnProperty, cr = Reflect.defineProperty, se = (n) => new Error(n), rr = (n) => typeof n == "function", Jo = (n) => n instanceof dd, fs = (n) => n instanceof Array, jc = (n) => n instanceof Set, is = (n) => n instanceof Map, y0 = dd.is;
function fd(n, e, t) {
  return cr(n, e, {
    enumerable: !1,
    configurable: !0,
    writable: !0,
    value: t
  }), t;
}
function ui(n, e, t) {
  e in n || fd(n, e, t);
}
const g0 = String, uo = pe.createInterface, Yo = () => dd.create(null), fo = Yr.getOwn, ho = Yr.define;
Ar.annotation.keyFor;
Ar.resource.keyFor;
Ar.resource.appendTo;
var ym;
(function(n) {
  n[n.AccessThis = 0] = "AccessThis", n[n.AccessScope = 1] = "AccessScope", n[n.ArrayLiteral = 2] = "ArrayLiteral", n[n.ObjectLiteral = 3] = "ObjectLiteral", n[n.PrimitiveLiteral = 4] = "PrimitiveLiteral", n[n.Template = 5] = "Template", n[n.Unary = 6] = "Unary", n[n.CallScope = 7] = "CallScope", n[n.CallMember = 8] = "CallMember", n[n.CallFunction = 9] = "CallFunction", n[n.AccessMember = 10] = "AccessMember", n[n.AccessKeyed = 11] = "AccessKeyed", n[n.TaggedTemplate = 12] = "TaggedTemplate", n[n.Binary = 13] = "Binary", n[n.Conditional = 14] = "Conditional", n[n.Assign = 15] = "Assign", n[n.ArrowFunction = 16] = "ArrowFunction", n[n.ValueConverter = 17] = "ValueConverter", n[n.BindingBehavior = 18] = "BindingBehavior", n[n.ArrayBindingPattern = 19] = "ArrayBindingPattern", n[n.ObjectBindingPattern = 20] = "ObjectBindingPattern", n[n.BindingIdentifier = 21] = "BindingIdentifier", n[n.ForOfStatement = 22] = "ForOfStatement", n[n.Interpolation = 23] = "Interpolation", n[n.ArrayDestructuring = 24] = "ArrayDestructuring", n[n.ObjectDestructuring = 25] = "ObjectDestructuring", n[n.DestructuringAssignmentLeaf = 26] = "DestructuringAssignmentLeaf", n[n.DestructuringAssignmentRestLeaf = 27] = "DestructuringAssignmentRestLeaf", n[n.Custom = 28] = "Custom";
})(ym || (ym = {}));
class b0 {
  constructor(e) {
    this.value = e, this.$kind = 28;
  }
  evaluate(e, t, r) {
    return this.value;
  }
  assign(e, t, r) {
    return r;
  }
  bind(e, t) {
  }
  unbind(e, t) {
  }
  accept(e) {
  }
}
class E5 {
  constructor(e, t, r) {
    this.expression = e, this.name = t, this.args = r, this.$kind = 18, this.key = `_bb_${t}`;
  }
}
class pc {
  constructor(e, t, r) {
    this.expression = e, this.name = t, this.args = r, this.$kind = 17;
  }
}
class S5 {
  constructor(e, t) {
    this.target = e, this.value = t, this.$kind = 15;
  }
}
class _5 {
  constructor(e, t, r) {
    this.condition = e, this.yes = t, this.no = r, this.$kind = 14;
  }
}
class xi {
  constructor(e = 0) {
    this.ancestor = e, this.$kind = 0;
  }
}
xi.$this = new xi(0);
xi.$parent = new xi(1);
class Fl {
  constructor(e, t = 0) {
    this.name = e, this.ancestor = t, this.$kind = 1;
  }
}
class ah {
  constructor(e, t, r = !1) {
    this.object = e, this.name = t, this.optional = r, this.$kind = 10;
  }
}
class m1 {
  constructor(e, t, r = !1) {
    this.object = e, this.key = t, this.optional = r, this.$kind = 11;
  }
}
class y1 {
  constructor(e, t, r = 0, i = !1) {
    this.name = e, this.args = t, this.ancestor = r, this.optional = i, this.$kind = 7;
  }
}
class cu {
  constructor(e, t, r, i = !1, s = !1) {
    this.object = e, this.name = t, this.args = r, this.optionalMember = i, this.optionalCall = s, this.$kind = 8;
  }
}
class Ul {
  constructor(e, t, r = !1) {
    this.func = e, this.args = t, this.optional = r, this.$kind = 9;
  }
}
class P5 {
  constructor(e, t, r) {
    this.operation = e, this.left = t, this.right = r, this.$kind = 13;
  }
}
class M5 {
  constructor(e, t) {
    this.operation = e, this.expression = t, this.$kind = 6;
  }
}
class Jt {
  constructor(e) {
    this.value = e, this.$kind = 4;
  }
}
Jt.$undefined = new Jt(void 0);
Jt.$null = new Jt(null);
Jt.$true = new Jt(!0);
Jt.$false = new Jt(!1);
Jt.$empty = new Jt("");
class oh {
  constructor(e) {
    this.elements = e, this.$kind = 2;
  }
}
oh.$empty = new oh(Ne);
class ch {
  constructor(e, t) {
    this.keys = e, this.values = t, this.$kind = 3;
  }
}
ch.$empty = new ch(Ne, Ne);
class lu {
  constructor(e, t = Ne) {
    this.cooked = e, this.expressions = t, this.$kind = 5;
  }
}
lu.$empty = new lu([""]);
class g1 {
  constructor(e, t, r, i = Ne) {
    this.cooked = e, this.func = r, this.expressions = i, this.$kind = 12, e.raw = t;
  }
}
class R5 {
  constructor(e) {
    this.elements = e, this.$kind = 19;
  }
}
class k5 {
  constructor(e, t) {
    this.keys = e, this.values = t, this.$kind = 20;
  }
}
class uu {
  constructor(e) {
    this.name = e, this.$kind = 21;
  }
}
class I5 {
  constructor(e, t, r) {
    this.declaration = e, this.iterable = t, this.semiIdx = r, this.$kind = 22;
  }
}
class b1 {
  constructor(e, t = Ne) {
    this.parts = e, this.expressions = t, this.$kind = 23, this.isMulti = t.length > 1, this.firstExpression = t[0];
  }
}
class O5 {
  constructor(e, t, r, i) {
    this.$kind = e, this.list = t, this.source = r, this.initializer = i;
  }
}
class x1 {
  constructor(e, t, r) {
    this.target = e, this.source = t, this.initializer = r, this.$kind = 26;
  }
}
class lh {
  constructor(e, t, r = !1) {
    this.args = e, this.body = t, this.rest = r, this.$kind = 16;
  }
}
class gm {
  constructor(e, t) {
    e !== void 0 && (this[e] = t);
  }
}
class Yt {
  constructor(e, t, r, i) {
    this.parent = e, this.bindingContext = t, this.overrideContext = r, this.isBoundary = i;
  }
  static getContext(e, t, r) {
    if (e == null)
      throw bm();
    let i = e.overrideContext, s = e;
    if (r > 0) {
      for (; r > 0; )
        if (r--, s = s.parent, s == null)
          return;
      return i = s.overrideContext, t in i ? i : s.bindingContext;
    }
    for (; s != null && !s.isBoundary && !(t in s.overrideContext) && !(t in s.bindingContext); )
      s = s.parent;
    return s == null ? e.bindingContext : (i = s.overrideContext, t in i ? i : s.bindingContext);
  }
  static create(e, t, r) {
    if (e == null)
      throw D5();
    return new Yt(null, e, t ?? new xm(), r ?? !1);
  }
  static fromParent(e, t) {
    if (e == null)
      throw bm();
    return new Yt(e, t, new xm(), !1);
  }
}
const bm = () => se("AUR0203"), D5 = () => se("AUR0204");
class xm {
}
const uh = Yt.getContext;
function V(n, e, t, r) {
  switch (n.$kind) {
    case 0: {
      let i = e.overrideContext, s = e, a = n.ancestor;
      for (; a-- && i; )
        s = s.parent, i = s?.overrideContext ?? null;
      return a < 1 && s ? s.bindingContext : void 0;
    }
    case 1: {
      const i = uh(e, n.name, n.ancestor);
      r !== null && r.observe(i, n.name);
      const s = i[n.name];
      if (s == null && n.name === "$host")
        throw se("AUR0105");
      return t?.strict ? t?.boundFn && rr(s) ? s.bind(i) : s : s == null ? "" : t?.boundFn && rr(s) ? s.bind(i) : s;
    }
    case 2:
      return n.elements.map((i) => V(i, e, t, r));
    case 3: {
      const i = {};
      for (let s = 0; s < n.keys.length; ++s)
        i[n.keys[s]] = V(n.values[s], e, t, r);
      return i;
    }
    case 4:
      return n.value;
    case 5: {
      let i = n.cooked[0];
      for (let s = 0; s < n.expressions.length; ++s)
        i += String(V(n.expressions[s], e, t, r)), i += n.cooked[s + 1];
      return i;
    }
    case 6:
      switch (n.operation) {
        case "void":
          return void V(n.expression, e, t, r);
        case "typeof":
          return typeof V(n.expression, e, t, r);
        case "!":
          return !V(n.expression, e, t, r);
        case "-":
          return -V(n.expression, e, t, r);
        case "+":
          return +V(n.expression, e, t, r);
        default:
          throw se(`AUR0109:${n.operation}`);
      }
    case 7: {
      const i = n.args.map((o) => V(o, e, t, r)), s = uh(e, n.name, n.ancestor), a = vm(t?.strictFnCall, s, n.name);
      return a ? a.apply(s, i) : void 0;
    }
    case 8: {
      const i = V(n.object, e, t, r), s = n.args.map((c) => V(c, e, t, r)), a = vm(t?.strictFnCall, i, n.name);
      let o;
      return a && (o = a.apply(i, s), fs(i) && $5.includes(n.name) && r?.observeCollection(i)), o;
    }
    case 9: {
      const i = V(n.func, e, t, r);
      if (rr(i))
        return i(...n.args.map((s) => V(s, e, t, r)));
      if (!t?.strictFnCall && i == null)
        return;
      throw se("AUR0107");
    }
    case 16:
      return (...s) => {
        const a = n.args, o = n.rest, c = a.length - 1, l = a.reduce((p, g, T) => (o && T === c ? p[g.name] = s.slice(T) : p[g.name] = s[T], p), {}), f = Yt.fromParent(e, l);
        return V(n.body, f, t, r);
      };
    case 10: {
      const i = V(n.object, e, t, r);
      let s;
      return t?.strict ? i == null ? i : (r !== null && r.observe(i, n.name), s = i[n.name], t?.boundFn && rr(s) ? s.bind(i) : s) : (r !== null && Jo(i) && r.observe(i, n.name), i ? (s = i[n.name], t?.boundFn && rr(s) ? s.bind(i) : s) : "");
    }
    case 11: {
      const i = V(n.object, e, t, r);
      if (Jo(i)) {
        const s = V(n.key, e, t, r);
        return r !== null && r.observe(i, s), i[s];
      }
      return;
    }
    case 12: {
      const i = n.expressions.map((a) => V(a, e, t, r)), s = V(n.func, e, t, r);
      if (!rr(s))
        throw se("AUR0110");
      return s(n.cooked, ...i);
    }
    case 13: {
      const i = n.left, s = n.right;
      switch (n.operation) {
        case "&&":
          return V(i, e, t, r) && V(s, e, t, r);
        case "||":
          return V(i, e, t, r) || V(s, e, t, r);
        case "??":
          return V(i, e, t, r) ?? V(s, e, t, r);
        case "==":
          return V(i, e, t, r) == V(s, e, t, r);
        case "===":
          return V(i, e, t, r) === V(s, e, t, r);
        case "!=":
          return V(i, e, t, r) != V(s, e, t, r);
        case "!==":
          return V(i, e, t, r) !== V(s, e, t, r);
        case "instanceof": {
          const a = V(s, e, t, r);
          return rr(a) ? V(i, e, t, r) instanceof a : !1;
        }
        case "in": {
          const a = V(s, e, t, r);
          return Jo(a) ? V(i, e, t, r) in a : !1;
        }
        case "+": {
          const a = V(i, e, t, r), o = V(s, e, t, r);
          if (t?.strict)
            return a + o;
          if (!a || !o) {
            if (wm(a) || wm(o))
              return (a || 0) + (o || 0);
            if (Am(a) || Am(o))
              return (a || "") + (o || "");
          }
          return a + o;
        }
        case "-":
          return V(i, e, t, r) - V(s, e, t, r);
        case "*":
          return V(i, e, t, r) * V(s, e, t, r);
        case "/":
          return V(i, e, t, r) / V(s, e, t, r);
        case "%":
          return V(i, e, t, r) % V(s, e, t, r);
        case "<":
          return V(i, e, t, r) < V(s, e, t, r);
        case ">":
          return V(i, e, t, r) > V(s, e, t, r);
        case "<=":
          return V(i, e, t, r) <= V(s, e, t, r);
        case ">=":
          return V(i, e, t, r) >= V(s, e, t, r);
        default:
          throw se(`AUR0108:${n.operation}`);
      }
    }
    case 14:
      return V(n.condition, e, t, r) ? V(n.yes, e, t, r) : V(n.no, e, t, r);
    case 15:
      return rn(n.target, e, t, V(n.value, e, t, r));
    case 17: {
      const i = t?.getConverter?.(n.name);
      if (i == null)
        throw se(`AUR0103:${n.name}`);
      return "toView" in i ? i.toView(V(n.expression, e, t, r), ...n.args.map((s) => V(s, e, t, r))) : V(n.expression, e, t, r);
    }
    case 18:
      return V(n.expression, e, t, r);
    case 21:
      return n.name;
    case 22:
      return V(n.iterable, e, t, r);
    case 23:
      if (n.isMulti) {
        let i = n.parts[0], s = 0;
        for (; s < n.expressions.length; ++s)
          i += g0(V(n.expressions[s], e, t, r)), i += n.parts[s + 1];
        return i;
      } else
        return `${n.parts[0]}${V(n.firstExpression, e, t, r)}${n.parts[1]}`;
    case 26:
      return V(n.target, e, t, r);
    case 24:
      return n.list.map((i) => V(i, e, t, r));
    case 19:
    case 20:
    case 25:
    default:
      return;
    case 28:
      return n.evaluate(e, t, r);
  }
}
function rn(n, e, t, r) {
  switch (n.$kind) {
    case 1: {
      if (n.name === "$host")
        throw se("AUR0106");
      const i = uh(e, n.name, n.ancestor);
      return i[n.name] = r;
    }
    case 10: {
      const i = V(n.object, e, t, null);
      return Jo(i) ? n.name === "length" && fs(i) && !isNaN(r) ? i.splice(r) : i[n.name] = r : rn(n.object, e, t, {
        [n.name]: r
      }), r;
    }
    case 11: {
      const i = V(n.object, e, t, null), s = V(n.key, e, t, null);
      if (fs(i)) {
        if (s === "length" && !isNaN(r))
          return i.splice(r), r;
        if (fc(s))
          return i.splice(s, 1, r), r;
      }
      return i[s] = r;
    }
    case 15:
      return rn(n.value, e, t, r), rn(n.target, e, t, r);
    case 17: {
      const i = t?.getConverter?.(n.name);
      if (i == null)
        throw v1(n.name);
      return "fromView" in i && (r = i.fromView(r, ...n.args.map((s) => V(s, e, t, null)))), rn(n.expression, e, t, r);
    }
    case 18:
      return rn(n.expression, e, t, r);
    case 24:
    case 25: {
      const i = n.list, s = i.length;
      let a, o;
      for (a = 0; a < s; a++)
        switch (o = i[a], o.$kind) {
          case 26:
            rn(o, e, t, r);
            break;
          case 24:
          case 25: {
            if (typeof r != "object" || r === null)
              throw se("AUR0112");
            let c = V(o.source, Yt.create(r), t, null);
            c === void 0 && o.initializer && (c = V(o.initializer, e, t, null)), rn(o, e, t, c);
            break;
          }
        }
      break;
    }
    case 26:
      if (n instanceof x1) {
        if (r == null)
          return;
        if (typeof r != "object")
          throw se("AUR0112");
        let i = V(n.source, Yt.create(r), t, null);
        i === void 0 && n.initializer && (i = V(n.initializer, e, t, null)), rn(n.target, e, t, i);
      } else {
        if (r == null)
          return;
        if (typeof r != "object")
          throw se("AUR0112");
        const i = n.indexOrProperties;
        let s;
        if (fc(i)) {
          if (!Array.isArray(r))
            throw se("AUR0112");
          s = r.slice(i);
        } else
          s = Object.entries(r).reduce((a, [o, c]) => (i.includes(o) || (a[o] = c), a), {});
        rn(n.target, e, t, s);
      }
      break;
    case 28:
      return n.assign(e, t, r);
    default:
      return;
  }
}
function Er(n, e, t) {
  switch (n.$kind) {
    case 18: {
      const r = n.name, i = n.key, s = t.getBehavior?.(r);
      if (s == null)
        throw N5(r);
      if (t[i] === void 0)
        t[i] = s, s.bind?.(e, t, ...n.args.map((a) => V(a, e, t, null)));
      else
        throw B5(r);
      Er(n.expression, e, t);
      return;
    }
    case 17: {
      const r = n.name, i = t.getConverter?.(r);
      if (i == null)
        throw v1(r);
      const s = i.signals;
      if (s != null) {
        const a = t.getSignaler?.(), o = s.length;
        let c = 0;
        for (; c < o; ++c)
          a?.addSignalListener(s[c], t);
      }
      Er(n.expression, e, t);
      return;
    }
    case 22:
      Er(n.iterable, e, t);
      break;
    case 28:
      n.bind?.(e, t);
  }
}
function sr(n, e, t) {
  switch (n.$kind) {
    case 18: {
      const r = n.key, i = t;
      i[r] !== void 0 && (i[r].unbind?.(e, t), i[r] = void 0), sr(n.expression, e, t);
      break;
    }
    case 17: {
      const r = t.getConverter?.(n.name);
      if (r?.signals === void 0)
        return;
      const i = t.getSignaler?.();
      let s = 0;
      for (; s < r.signals.length; ++s)
        i?.removeSignalListener(r.signals[s], t);
      sr(n.expression, e, t);
      break;
    }
    case 22:
      sr(n.iterable, e, t);
      break;
    case 28:
      n.unbind?.(e, t);
  }
}
const N5 = (n) => se(`AUR0101:${n}`), B5 = (n) => se(`AUR0102:${n}`), v1 = (n) => se(`AUR0103:${n}`), vm = (n, e, t) => {
  const r = e == null ? null : e[t];
  if (rr(r))
    return r;
  if (!n && r == null)
    return null;
  throw se(`AUR0111:${t}`);
}, wm = (n) => {
  switch (typeof n) {
    case "number":
    case "bigint":
      return !0;
    default:
      return !1;
  }
}, Am = (n) => {
  switch (typeof n) {
    case "string":
      return !0;
    case "object":
      return n instanceof Date;
    default:
      return !1;
  }
}, $5 = "at map filter includes indexOf lastIndexOf findIndex find flat flatMap join reduce reduceRight slice every some sort".split(" "), Tm = pe.createInterface("ICoercionConfiguration");
var Cm;
(function(n) {
  n[n.indexed = 8] = "indexed", n[n.keyed = 4] = "keyed", n[n.array = 9] = "array", n[n.map = 6] = "map", n[n.set = 7] = "set";
})(Cm || (Cm = {}));
var Em;
(function(n) {
  n[n.None = 0] = "None", n[n.Observer = 1] = "Observer", n[n.Node = 2] = "Node", n[n.Layout = 4] = "Layout", n[n.Primtive = 8] = "Primtive", n[n.Array = 18] = "Array", n[n.Set = 34] = "Set", n[n.Map = 66] = "Map";
})(Em || (Em = {}));
function Ys(n = 0) {
  const e = Array(n);
  let t = 0;
  for (; t < n; )
    e[t] = t++;
  return e.deletedIndices = [], e.deletedItems = [], e.isIndexMap = !0, e;
}
function L5(n) {
  const e = n.slice();
  return e.deletedIndices = n.deletedIndices.slice(), e.deletedItems = n.deletedItems.slice(), e.isIndexMap = !0, e;
}
function An(n) {
  return n == null ? Sm : Sm(n);
}
function Sm(n) {
  const e = n.prototype;
  cr(e, "subs", {
    get: U5
  }), ui(e, "subscribe", V5), ui(e, "unsubscribe", j5);
}
class F5 {
  constructor() {
    this.count = 0, this.t = [];
  }
  add(e) {
    return this.t.includes(e) ? !1 : (this.t[this.t.length] = e, ++this.count, !0);
  }
  remove(e) {
    const t = this.t.indexOf(e);
    return t !== -1 ? (this.t.splice(t, 1), --this.count, !0) : !1;
  }
  notify(e, t) {
    const r = this.t.slice(0), i = r.length;
    let s = 0;
    for (; s < i; ++s)
      r[s].handleChange(e, t);
  }
  notifyCollection(e, t) {
    const r = this.t.slice(0), i = r.length;
    let s = 0;
    for (; s < i; ++s)
      r[s].handleCollectionChange(e, t);
  }
}
function U5() {
  return fd(this, "subs", new F5());
}
function V5(n) {
  return this.subs.add(n);
}
function j5(n) {
  return this.subs.remove(n);
}
class w1 {
  constructor(e) {
    this.owner = e, this.type = 18, this.v = (this.o = e.collection).length;
  }
  getValue() {
    return this.o.length;
  }
  setValue(e) {
    e !== this.v && (Number.isNaN(e) || (this.o.splice(e), this.v = this.o.length));
  }
  handleCollectionChange(e, t) {
    const r = this.v, i = this.o.length;
    (this.v = i) !== r && this.subs.notify(this.v, r);
  }
}
class x0 {
  constructor(e) {
    this.owner = e, this.v = (this.o = e.collection).size, this.type = is(this.o) ? 66 : 34;
  }
  getValue() {
    return this.o.size;
  }
  setValue() {
    throw se("AUR02");
  }
  handleCollectionChange(e, t) {
    const r = this.v, i = this.o.size;
    (this.v = i) !== r && this.subs.notify(this.v, r);
  }
}
function A1(n) {
  const e = n.prototype;
  ui(e, "subscribe", G5), ui(e, "unsubscribe", W5), An(n);
}
function G5(n) {
  this.subs.add(n) && this.subs.count === 1 && this.owner.subscribe(this);
}
function W5(n) {
  this.subs.remove(n) && this.subs.count === 0 && this.owner.subscribe(this);
}
A1(w1);
A1(x0);
const _m = "__au_array_obs__", ai = (() => {
  let n = fo(_m, Array);
  return n == null && ho(_m, n = /* @__PURE__ */ new WeakMap(), Array), n;
})();
function H5(n, e) {
  return n === e ? 0 : (n = n === null ? "null" : n.toString(), e = e === null ? "null" : e.toString(), n < e ? -1 : 1);
}
function z5(n, e) {
  return n === void 0 ? e === void 0 ? 0 : 1 : e === void 0 ? -1 : 0;
}
function K5(n, e, t, r, i) {
  let s, a, o, c, l, f, p;
  for (f = t + 1; f < r; f++) {
    for (s = n[f], a = e[f], p = f - 1; p >= t && (o = n[p], c = e[p], l = i(o, s), l > 0); p--)
      n[p + 1] = o, e[p + 1] = c;
    n[p + 1] = s, e[p + 1] = a;
  }
}
function du(n, e, t, r, i) {
  let s = 0, a = 0, o, c, l, f, p, g, T, v, w, C, _, I, B, N, D, U, W, j, q;
  for (; ; ) {
    if (r - t <= 10) {
      K5(n, e, t, r, i);
      return;
    }
    s = t + (r - t >> 1), o = n[t], f = e[t], c = n[r - 1], p = e[r - 1], l = n[s], g = e[s], T = i(o, c), T > 0 && (C = o, _ = f, o = c, f = p, c = C, p = _), v = i(o, l), v >= 0 ? (C = o, _ = f, o = l, f = g, l = c, g = p, c = C, p = _) : (w = i(c, l), w > 0 && (C = c, _ = p, c = l, p = g, l = C, g = _)), n[t] = o, e[t] = f, n[r - 1] = l, e[r - 1] = g, I = c, B = p, N = t + 1, D = r - 1, n[s] = n[N], e[s] = e[N], n[N] = I, e[N] = B;
    e:
      for (a = N + 1; a < D; a++)
        if (U = n[a], W = e[a], j = i(U, I), j < 0)
          n[a] = n[N], e[a] = e[N], n[N] = U, e[N] = W, N++;
        else if (j > 0) {
          do {
            if (D--, D == a)
              break e;
            q = n[D], j = i(q, I);
          } while (j > 0);
          n[a] = n[D], e[a] = e[D], n[D] = U, e[D] = W, j < 0 && (U = n[a], W = e[a], n[a] = n[N], e[a] = e[N], n[N] = U, e[N] = W, N++);
        }
    r - D < N - t ? (du(n, e, D, r, i), r = N) : (du(n, e, t, N, i), t = D);
  }
}
const Ai = Array.prototype, q5 = Ai.push, cf = Ai.unshift, lf = Ai.pop, uf = Ai.shift, yl = Ai.splice, Q5 = Ai.reverse, J5 = Ai.sort, T1 = ["push", "unshift", "pop", "shift", "splice", "reverse", "sort"], C1 = {
  push: function(...n) {
    const e = ai.get(this);
    if (e === void 0)
      return q5.apply(this, n);
    const t = this.length, r = n.length;
    if (r === 0)
      return t;
    this.length = e.indexMap.length = t + r;
    let i = t;
    for (; i < this.length; )
      this[i] = n[i - t], e.indexMap[i] = -2, i++;
    return e.notify(), this.length;
  },
  unshift: function(...n) {
    const e = ai.get(this);
    if (e === void 0)
      return cf.apply(this, n);
    const t = n.length, r = new Array(t);
    let i = 0;
    for (; i < t; )
      r[i++] = -2;
    cf.apply(e.indexMap, r);
    const s = cf.apply(this, n);
    return e.notify(), s;
  },
  pop: function() {
    const n = ai.get(this);
    if (n === void 0)
      return lf.call(this);
    const e = n.indexMap, t = lf.call(this), r = e.length - 1;
    return e[r] > -1 && (e.deletedIndices.push(e[r]), e.deletedItems.push(t)), lf.call(e), n.notify(), t;
  },
  shift: function() {
    const n = ai.get(this);
    if (n === void 0)
      return uf.call(this);
    const e = n.indexMap, t = uf.call(this);
    return e[0] > -1 && (e.deletedIndices.push(e[0]), e.deletedItems.push(t)), uf.call(e), n.notify(), t;
  },
  splice: function(...n) {
    const e = n[0], t = n[1], r = ai.get(this);
    if (r === void 0)
      return yl.apply(this, n);
    const i = this.length, s = 0 | e, a = s < 0 ? Math.max(i + s, 0) : Math.min(s, i), o = r.indexMap, c = n.length, l = c === 0 ? 0 : c === 1 ? i - a : t;
    let f = a;
    if (l > 0) {
      const g = f + l;
      for (; f < g; )
        o[f] > -1 && (o.deletedIndices.push(o[f]), o.deletedItems.push(this[f])), f++;
    }
    if (f = 0, c > 2) {
      const g = c - 2, T = new Array(g);
      for (; f < g; )
        T[f++] = -2;
      yl.call(o, e, t, ...T);
    } else
      yl.apply(o, n);
    const p = yl.apply(this, n);
    return (l > 0 || f > 0) && r.notify(), p;
  },
  reverse: function() {
    const n = ai.get(this);
    if (n === void 0)
      return Q5.call(this), this;
    const e = this.length, t = e / 2 | 0;
    let r = 0;
    for (; r !== t; ) {
      const i = e - r - 1, s = this[r], a = n.indexMap[r], o = this[i], c = n.indexMap[i];
      this[r] = o, n.indexMap[r] = c, this[i] = s, n.indexMap[i] = a, r++;
    }
    return n.notify(), this;
  },
  sort: function(n) {
    const e = ai.get(this);
    if (e === void 0)
      return J5.call(this, n), this;
    let t = this.length;
    if (t < 2)
      return this;
    du(this, e.indexMap, 0, t, z5);
    let r = 0;
    for (; r < t && this[r] !== void 0; )
      r++;
    (n === void 0 || !rr(n)) && (n = H5), du(this, e.indexMap, 0, r, n);
    let i = !1;
    for (r = 0, t = e.indexMap.length; t > r; ++r)
      if (e.indexMap[r] !== r) {
        i = !0;
        break;
      }
    return i && e.notify(), this;
  }
};
for (const n of T1)
  cr(C1[n], "observing", {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1
  });
let Pm = !1;
const Mm = "__au_arr_on__";
function Y5() {
  if (!(fo(Mm, Array) ?? !1)) {
    ho(Mm, !0, Array);
    for (const n of T1)
      Ai[n].observing !== !0 && fd(Ai, n, C1[n]);
  }
}
class E1 {
  constructor(e) {
    this.type = 18, Pm || (Pm = !0, Y5()), this.indexObservers = {}, this.collection = e, this.indexMap = Ys(e.length), this.lenObs = void 0, ai.set(e, this);
  }
  notify() {
    this.subs;
    const e = this.indexMap, t = this.collection, r = t.length;
    this.indexMap = Ys(r), this.subs.notifyCollection(t, e);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new w1(this));
  }
  getIndexObserver(e) {
    var t;
    return (t = this.indexObservers)[e] ?? (t[e] = new S1(this, e));
  }
}
class S1 {
  constructor(e, t) {
    this.owner = e, this.index = t, this.doNotCache = !0, this.value = this.getValue();
  }
  getValue() {
    return this.owner.collection[this.index];
  }
  setValue(e) {
    if (e === this.getValue())
      return;
    const t = this.owner, r = this.index, i = t.indexMap;
    i[r] > -1 && i.deletedIndices.push(i[r]), i[r] = -2, t.collection[r] = e, t.notify();
  }
  handleCollectionChange(e, t) {
    const r = this.index;
    if (t[r] === r)
      return;
    const s = this.value, a = this.value = this.getValue();
    s !== a && this.subs.notify(a, s);
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && this.owner.subscribe(this);
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && this.owner.unsubscribe(this);
  }
}
An(E1);
An(S1);
function Xo(n) {
  let e = ai.get(n);
  return e === void 0 && (e = new E1(n)), e;
}
const X5 = (n, e) => n - e;
function Z5(n) {
  let e = 0, t = 0, r = 0;
  const i = L5(n);
  i.deletedIndices.length > 1 && i.deletedIndices.sort(X5);
  const s = i.length;
  for (; r < s; ++r) {
    for (; i.deletedIndices[t] <= r - e; )
      ++t, --e;
    i[r] === -2 ? ++e : i[r] += e;
  }
  return i;
}
function eA(n, e) {
  const t = n.slice(), r = e.length;
  let i = 0, s = 0;
  for (; i < r; )
    s = e[i], s !== -2 && (n[i] = t[s]), ++i;
}
const Rm = "__au_set_obs__", Zo = (() => {
  let n = fo(Rm, Set);
  return n == null && ho(Rm, n = /* @__PURE__ */ new WeakMap(), Set), n;
})(), mc = Set.prototype, km = mc.add, Im = mc.clear, Om = mc.delete, _1 = ["add", "clear", "delete"], P1 = {
  add: function(n) {
    const e = Zo.get(this);
    if (e === void 0)
      return km.call(this, n), this;
    const t = this.size;
    return km.call(this, n), this.size === t ? this : (e.indexMap[t] = -2, e.notify(), this);
  },
  clear: function() {
    const n = Zo.get(this);
    if (n === void 0)
      return Im.call(this);
    if (this.size > 0) {
      const t = n.indexMap;
      let r = 0;
      for (const i of this.keys())
        t[r] > -1 && (t.deletedIndices.push(t[r]), t.deletedItems.push(i)), r++;
      Im.call(this), t.length = 0, n.notify();
    }
  },
  delete: function(n) {
    const e = Zo.get(this);
    if (e === void 0)
      return Om.call(this, n);
    if (this.size === 0)
      return !1;
    let r = 0;
    const i = e.indexMap;
    for (const s of this.keys()) {
      if (s === n) {
        i[r] > -1 && (i.deletedIndices.push(i[r]), i.deletedItems.push(s)), i.splice(r, 1);
        const a = Om.call(this, n);
        return a === !0 && e.notify(), a;
      }
      r++;
    }
    return !1;
  }
}, tA = {
  writable: !0,
  enumerable: !1,
  configurable: !0
};
for (const n of _1)
  cr(P1[n], "observing", {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1
  });
let Dm = !1;
const Nm = "__au_set_on__";
function nA() {
  if (!(fo(Nm, Set) ?? !1)) {
    ho(Nm, !0, Set);
    for (const n of _1)
      mc[n].observing !== !0 && cr(mc, n, {
        ...tA,
        value: P1[n]
      });
  }
}
class M1 {
  constructor(e) {
    this.type = 34, Dm || (Dm = !0, nA()), this.collection = e, this.indexMap = Ys(e.size), this.lenObs = void 0, Zo.set(e, this);
  }
  notify() {
    this.subs;
    const e = this.indexMap, t = this.collection, r = t.size;
    this.indexMap = Ys(r), this.subs.notifyCollection(t, e);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new x0(this));
  }
}
An(M1);
function fu(n) {
  let e = Zo.get(n);
  return e === void 0 && (e = new M1(n)), e;
}
const Bm = "__au_map_obs__", ec = (() => {
  let n = fo(Bm, Map);
  return n == null && ho(Bm, n = /* @__PURE__ */ new WeakMap(), Map), n;
})(), yc = Map.prototype, $m = yc.set, Lm = yc.clear, Fm = yc.delete, R1 = ["set", "clear", "delete"], k1 = {
  set: function(n, e) {
    const t = ec.get(this);
    if (t === void 0)
      return $m.call(this, n, e), this;
    const r = this.get(n), i = this.size;
    if ($m.call(this, n, e), this.size === i) {
      let a = 0;
      for (const o of this.entries()) {
        if (o[0] === n)
          return o[1] !== r && (t.indexMap.deletedIndices.push(t.indexMap[a]), t.indexMap.deletedItems.push(o), t.indexMap[a] = -2, t.notify()), this;
        a++;
      }
      return this;
    }
    return t.indexMap[i] = -2, t.notify(), this;
  },
  clear: function() {
    const n = ec.get(this);
    if (n === void 0)
      return Lm.call(this);
    if (this.size > 0) {
      const t = n.indexMap;
      let r = 0;
      for (const i of this.keys())
        t[r] > -1 && (t.deletedIndices.push(t[r]), t.deletedItems.push(i)), r++;
      Lm.call(this), t.length = 0, n.notify();
    }
  },
  delete: function(n) {
    const e = ec.get(this);
    if (e === void 0)
      return Fm.call(this, n);
    if (this.size === 0)
      return !1;
    let r = 0;
    const i = e.indexMap;
    for (const s of this.keys()) {
      if (s === n) {
        i[r] > -1 && (i.deletedIndices.push(i[r]), i.deletedItems.push(s)), i.splice(r, 1);
        const a = Fm.call(this, n);
        return a === !0 && e.notify(), a;
      }
      ++r;
    }
    return !1;
  }
}, rA = {
  writable: !0,
  enumerable: !1,
  configurable: !0
};
for (const n of R1)
  cr(k1[n], "observing", {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1
  });
let Um = !1;
const Vm = "__au_map_on__";
function iA() {
  if (!(fo(Vm, Map) ?? !1)) {
    ho(Vm, !0, Map);
    for (const n of R1)
      yc[n].observing !== !0 && cr(yc, n, {
        ...rA,
        value: k1[n]
      });
  }
}
class I1 {
  constructor(e) {
    this.type = 66, Um || (Um = !0, iA()), this.collection = e, this.indexMap = Ys(e.size), this.lenObs = void 0, ec.set(e, this);
  }
  notify() {
    const e = this.subs, t = this.indexMap, r = this.collection, i = r.size;
    this.indexMap = Ys(i), e.notifyCollection(r, t);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new x0(this));
  }
}
An(I1);
function hu(n) {
  let e = ec.get(n);
  return e === void 0 && (e = new I1(n)), e;
}
function sA() {
  return fd(this, "obs", new dA(this));
}
function aA(n, e) {
  this.obs.add(this.oL.getObserver(n, e));
}
function oA(n) {
  let e;
  if (fs(n))
    e = Xo(n);
  else if (jc(n))
    e = fu(n);
  else if (is(n))
    e = hu(n);
  else
    throw se("AUR0210");
  this.obs.add(e);
}
function cA(n) {
  this.obs.add(n);
}
function lA() {
  throw se("AUR2011:handleChange");
}
function uA() {
  throw se("AUR2011:handleCollectionChange");
}
class dA {
  constructor(e) {
    this.version = 0, this.count = 0, this.o = /* @__PURE__ */ new Map(), this.b = e;
  }
  add(e) {
    this.o.has(e) || (e.subscribe(this.b), ++this.count), this.o.set(e, this.version);
  }
  clear() {
    this.o.forEach(hA, this), this.count = this.o.size;
  }
  clearAll() {
    this.o.forEach(fA, this), this.o.clear(), this.count = 0;
  }
}
function fA(n, e) {
  e.unsubscribe(this.b);
}
function hA(n, e) {
  this.version !== n && (e.unsubscribe(this.b), this.o.delete(e));
}
function jm(n) {
  const e = n.prototype;
  return ui(e, "observe", aA), ui(e, "observeCollection", oA), ui(e, "subscribeTo", cA), cr(e, "obs", {
    get: sA
  }), ui(e, "handleChange", lA), ui(e, "handleCollectionChange", uA), n;
}
function Rr(n) {
  return n == null ? jm : jm(n);
}
const v0 = uo("IExpressionParser", (n) => n.singleton(pA));
class pA {
  constructor() {
    this.i = Yo(), this.u = Yo(), this.h = Yo();
  }
  parse(e, t) {
    let r;
    switch (t) {
      case 32:
        return new b0(e);
      case 1:
        return r = this.h[e], r === void 0 && (r = this.h[e] = this.$parse(e, t)), r;
      case 2:
        return r = this.u[e], r === void 0 && (r = this.u[e] = this.$parse(e, t)), r;
      default:
        if (e.length === 0) {
          if ((t & 24) > 0)
            return Jt.$empty;
          throw kA();
        }
        return r = this.i[e], r === void 0 && (r = this.i[e] = this.$parse(e, t)), r;
    }
  }
  $parse(e, t) {
    return Me = e, Te = 0, Kr = e.length, Gn = 0, Xs = 0, Y = 6291456, $e = "", gt = Zs(0), Re = !0, Ce = !1, A0 = -1, St(61, t === void 0 ? 16 : t);
  }
}
function w0(n) {
  switch (n) {
    case 98:
      return 8;
    case 116:
      return 9;
    case 110:
      return 10;
    case 118:
      return 11;
    case 102:
      return 12;
    case 114:
      return 13;
    case 34:
      return 34;
    case 39:
      return 39;
    case 92:
      return 92;
    default:
      return n;
  }
}
const mA = Jt.$false, yA = Jt.$true, gA = Jt.$null, O1 = Jt.$undefined, tc = xi.$this, df = xi.$parent;
var Gm;
(function(n) {
  n[n.None = 0] = "None", n[n.Interpolation = 1] = "Interpolation", n[n.IsIterator = 2] = "IsIterator", n[n.IsChainable = 4] = "IsChainable", n[n.IsFunction = 8] = "IsFunction", n[n.IsProperty = 16] = "IsProperty", n[n.IsCustom = 32] = "IsCustom";
})(Gm || (Gm = {}));
let Me = "", Te = 0, Kr = 0, Gn = 0, Xs = 0, Y = 6291456, $e = "", gt, Re = !0, Ce = !1, A0 = -1;
const gc = String.fromCharCode, Zs = (n) => Me.charCodeAt(n), Fa = () => Me.slice(Xs, Te);
function St(n, e) {
  if (e === 32)
    return new b0(Me);
  if (Te === 0) {
    if (1 & e)
      return CA();
    if (oe(), 4194304 & Y)
      throw PA();
  }
  Re = 513 > n, Ce = !1;
  let t = !1, r, i = 0;
  if (131072 & Y) {
    const s = Gl[63 & Y];
    oe(), r = new M5(s, St(514, e)), Re = !1;
  } else {
    e:
      switch (Y) {
        case 12294:
          i = Gn, Re = !1;
          do
            switch (oe(), ++i, Y) {
              case 65545:
                if (oe(), (12288 & Y) === 0)
                  throw ii();
                break;
              case 10:
              case 11:
                throw ii();
              case 2162700:
                if (Ce = !0, oe(), (12288 & Y) === 0) {
                  r = i === 0 ? tc : i === 1 ? df : new xi(i), t = !0;
                  break e;
                }
                break;
              default:
                if (2097152 & Y) {
                  r = i === 0 ? tc : i === 1 ? df : new xi(i);
                  break e;
                }
                throw MA();
            }
          while (Y === 12294);
        case 4096: {
          const s = $e;
          if (2 & e ? r = new uu(s) : r = new Fl(s, i), Re = !Ce, oe(), vr(50)) {
            if (Y === 524296)
              throw U1();
            const a = Ce, o = Gn;
            ++Gn;
            const c = St(62, 0);
            Ce = a, Gn = o, Re = !1, r = new lh([new uu(s)], c);
          }
          break;
        }
        case 10:
          throw UA();
        case 11:
          throw dh();
        case 12292:
          switch (Re = !1, oe(), Gn) {
            case 0:
              r = tc;
              break;
            case 1:
              r = df;
              break;
            default:
              r = new xi(Gn);
              break;
          }
          break;
        case 2688007:
          r = vA(e);
          break;
        case 2688016:
          r = Me.search(/\s+of\s+/) > Te ? bA() : wA(e);
          break;
        case 524296:
          r = TA(e);
          break;
        case 2163759:
          r = new lu([$e]), Re = !1, oe();
          break;
        case 2163760:
          r = ff(e, r, !1);
          break;
        case 16384:
        case 32768:
          r = new Jt($e), Re = !1, oe();
          break;
        case 8194:
        case 8195:
        case 8193:
        case 8192:
          r = Gl[63 & Y], Re = !1, oe();
          break;
        default:
          throw Te >= Kr ? RA() : hf();
      }
    if (2 & e)
      return AA(r);
    if (514 < n)
      return r;
    if (Y === 10 || Y === 11)
      throw ii();
    if (r.$kind === 0)
      switch (Y) {
        case 2162700:
          if (Ce = !0, Re = !1, oe(), (13312 & Y) === 0)
            throw T0();
          if (12288 & Y)
            r = new Fl($e, r.ancestor), oe();
          else if (Y === 2688007)
            r = new Ul(r, Lr(), !0);
          else if (Y === 2688016)
            r = Vl(r, !0);
          else
            throw jl();
          break;
        case 65545:
          if (Re = !Ce, oe(), (12288 & Y) === 0)
            throw ii();
          r = new Fl($e, r.ancestor), oe();
          break;
        case 10:
        case 11:
          throw ii();
        case 2688007:
          r = new Ul(r, Lr(), t);
          break;
        case 2688016:
          r = Vl(r, t);
          break;
        case 2163759:
          r = Wm(r);
          break;
        case 2163760:
          r = ff(e, r, !0);
          break;
      }
    for (; (65536 & Y) > 0; )
      switch (Y) {
        case 2162700:
          r = xA(r);
          break;
        case 65545:
          if (oe(), (12288 & Y) === 0)
            throw ii();
          r = D1(r, !1);
          break;
        case 10:
        case 11:
          throw ii();
        case 2688007:
          r.$kind === 1 ? r = new y1(r.name, Lr(), r.ancestor, !1) : r.$kind === 10 ? r = new cu(r.object, r.name, Lr(), r.optional, !1) : r = new Ul(r, Lr(), !1);
          break;
        case 2688016:
          r = Vl(r, !1);
          break;
        case 2163759:
          if (Ce)
            throw jl();
          r = Wm(r);
          break;
        case 2163760:
          if (Ce)
            throw jl();
          r = ff(e, r, !0);
          break;
      }
  }
  if (Y === 10 || Y === 11)
    throw ii();
  if (513 < n)
    return r;
  for (; (262144 & Y) > 0; ) {
    const s = Y;
    if ((960 & s) <= n)
      break;
    oe(), r = new P5(Gl[63 & s], r, St(960 & s, e)), Re = !1;
  }
  if (63 < n)
    return r;
  if (vr(6291478)) {
    const s = St(62, e);
    Sr(6291476), r = new _5(r, s, St(62, e)), Re = !1;
  }
  if (62 < n)
    return r;
  if (vr(4194349)) {
    if (!Re)
      throw IA();
    r = new S5(r, St(62, e));
  }
  if (61 < n)
    return r;
  for (; vr(6291480); ) {
    if (Y === 6291456)
      throw OA();
    const s = $e;
    oe();
    const a = new Array();
    for (; vr(6291476); )
      a.push(St(62, e));
    r = new pc(r, s, a);
  }
  for (; vr(6291479); ) {
    if (Y === 6291456)
      throw DA();
    const s = $e;
    oe();
    const a = new Array();
    for (; vr(6291476); )
      a.push(St(62, e));
    r = new E5(r, s, a);
  }
  if (Y !== 6291456) {
    if ((1 & e) > 0 && Y === 7340045)
      return r;
    if ((4 & e) > 0 && Y === 6291477) {
      if (Te === Kr)
        throw hf();
      return A0 = Te - 1, r;
    }
    throw Fa() === "of" ? NA() : hf();
  }
  return r;
}
function bA() {
  const n = [], e = new O5(24, n, void 0, void 0);
  let t = "", r = !0, i = 0;
  for (; r; )
    switch (oe(), Y) {
      case 7340051:
        r = !1, s();
        break;
      case 6291471:
        s();
        break;
      case 4096:
        t = Fa();
        break;
      default:
        throw LA();
    }
  return Sr(7340051), e;
  function s() {
    t !== "" ? (n.push(new x1(new ah(tc, t), new m1(tc, new Jt(i++)), void 0)), t = "") : i++;
  }
}
function Lr() {
  const n = Ce;
  oe();
  const e = [];
  for (; Y !== 7340046 && (e.push(St(62, 0)), !!vr(6291471)); )
    ;
  return Sr(7340046), Re = !1, Ce = n, e;
}
function Vl(n, e) {
  const t = Ce;
  return oe(), n = new m1(n, St(62, 0), e), Sr(7340051), Re = !t, Ce = t, n;
}
function xA(n) {
  if (Ce = !0, Re = !1, oe(), (13312 & Y) === 0)
    throw T0();
  if (12288 & Y)
    return D1(n, !0);
  if (Y === 2688007)
    return n.$kind === 1 ? new y1(n.name, Lr(), n.ancestor, !0) : n.$kind === 10 ? new cu(n.object, n.name, Lr(), n.optional, !0) : new Ul(n, Lr(), !0);
  if (Y === 2688016)
    return Vl(n, !0);
  throw jl();
}
function D1(n, e) {
  const t = $e;
  switch (Y) {
    case 2162700: {
      Ce = !0, Re = !1;
      const r = Te, i = Xs, s = Y, a = gt, o = $e, c = Re, l = Ce;
      if (oe(), (13312 & Y) === 0)
        throw T0();
      return Y === 2688007 ? new cu(n, t, Lr(), e, !0) : (Te = r, Xs = i, Y = s, gt = a, $e = o, Re = c, Ce = l, new ah(n, t, e));
    }
    case 2688007:
      return Re = !1, new cu(n, t, Lr(), e, !1);
    default:
      return Re = !Ce, oe(), new ah(n, t, e);
  }
}
function vA(n) {
  oe();
  const e = Te, t = Xs, r = Y, i = gt, s = $e, a = Re, o = Ce, c = [];
  let l = 1, f = !1;
  e:
    for (; ; ) {
      if (Y === 11) {
        if (oe(), Y !== 4096)
          throw ii();
        if (c.push(new uu($e)), oe(), Y === 6291471)
          throw FA();
        if (Y !== 7340046 || (oe(), Y !== 50))
          throw dh();
        oe();
        const T = Ce, v = Gn;
        ++Gn;
        const w = St(62, 0);
        return Ce = T, Gn = v, Re = !1, new lh(c, w, !0);
      }
      switch (Y) {
        case 4096:
          c.push(new uu($e)), oe();
          break;
        case 7340046:
          oe();
          break e;
        case 524296:
        case 2688016:
          oe(), l = 4;
          break;
        case 6291471:
          l = 2, f = !0;
          break e;
        case 2688007:
          l = 2;
          break e;
        default:
          oe(), l = 2;
          break;
      }
      switch (Y) {
        case 6291471:
          if (oe(), f = !0, l === 1)
            break;
          break e;
        case 7340046:
          oe();
          break e;
        case 4194349:
          l === 1 && (l = 3);
          break e;
        case 50:
          if (f)
            throw gl();
          oe(), l = 2;
          break e;
        default:
          l === 1 && (l = 2);
          break e;
      }
    }
  if (Y === 50) {
    if (l === 1) {
      if (oe(), Y === 524296)
        throw U1();
      const T = Ce, v = Gn;
      ++Gn;
      const w = St(62, 0);
      return Ce = T, Gn = v, Re = !1, new lh(c, w);
    }
    throw gl();
  } else if (l === 1 && c.length === 0)
    throw L1(50);
  if (f)
    switch (l) {
      case 2:
        throw gl();
      case 3:
        throw zm();
      case 4:
        throw Km();
    }
  Te = e, Xs = t, Y = r, gt = i, $e = s, Re = a, Ce = o;
  const p = Ce, g = St(62, n);
  if (Ce = p, Sr(7340046), Y === 50)
    switch (l) {
      case 2:
        throw gl();
      case 3:
        throw zm();
      case 4:
        throw Km();
    }
  return g;
}
function wA(n) {
  const e = Ce;
  oe();
  const t = new Array();
  for (; Y !== 7340051; )
    if (vr(6291471)) {
      if (t.push(O1), Y === 7340051)
        break;
    } else if (t.push(St(62, -3 & n)), vr(6291471)) {
      if (Y === 7340051)
        break;
    } else
      break;
  return Ce = e, Sr(7340051), 2 & n ? new R5(t) : (Re = !1, new oh(t));
}
function AA(n) {
  if ((n.$kind & 23) === 0 || Y !== 4204593)
    throw Hm();
  oe();
  const e = n, t = St(61, 4);
  return new I5(e, t, A0);
}
function TA(n) {
  const e = Ce, t = new Array(), r = new Array();
  for (oe(); Y !== 7340045; ) {
    if (t.push($e), 49152 & Y)
      oe(), Sr(6291476), r.push(St(62, -3 & n));
    else if (12288 & Y) {
      const i = gt, s = Y, a = Te;
      oe(), vr(6291476) ? r.push(St(62, -3 & n)) : (gt = i, Y = s, Te = a, r.push(St(515, -3 & n)));
    } else
      throw BA();
    Y !== 7340045 && Sr(6291471);
  }
  return Ce = e, Sr(7340045), 2 & n ? new k5(t, r) : (Re = !1, new ch(t, r));
}
function CA() {
  const n = [], e = [], t = Kr;
  let r = "";
  for (; Te < t; ) {
    switch (gt) {
      case 36:
        if (Zs(Te + 1) === 123) {
          n.push(r), r = "", Te += 2, gt = Zs(Te), oe();
          const i = St(61, 1);
          e.push(i);
          continue;
        } else
          r += "$";
        break;
      case 92:
        r += gc(w0(ye()));
        break;
      default:
        r += gc(gt);
    }
    ye();
  }
  return e.length ? (n.push(r), new b1(n, e)) : null;
}
function ff(n, e, t) {
  const r = Ce, i = [$e];
  Sr(2163760);
  const s = [St(62, n)];
  for (; (Y = _A()) !== 2163759; )
    i.push($e), Sr(2163760), s.push(St(62, n));
  return i.push($e), Re = !1, Ce = r, t ? (oe(), new g1(i, i, e, s)) : (oe(), new lu(i, s));
}
function Wm(n) {
  Re = !1;
  const e = [$e];
  return oe(), new g1(e, e, n);
}
function oe() {
  for (; Te < Kr; )
    if (Xs = Te, (Y = Ie[gt]()) != null)
      return;
  Y = 6291456;
}
function ye() {
  return gt = Zs(++Te);
}
function EA() {
  for (; C0[ye()]; )
    ;
  const n = VA[$e = Fa()];
  return n === void 0 ? 4096 : n;
}
function N1(n) {
  let e = gt;
  if (n === !1) {
    do
      e = ye();
    while (e <= 57 && e >= 48);
    if (e !== 46)
      return $e = parseInt(Fa(), 10), 32768;
    if (e = ye(), Te >= Kr)
      return $e = parseInt(Fa().slice(0, -1), 10), 32768;
  }
  if (e <= 57 && e >= 48)
    do
      e = ye();
    while (e <= 57 && e >= 48);
  else
    gt = Zs(--Te);
  return $e = parseFloat(Fa()), 32768;
}
function SA() {
  const n = gt;
  ye();
  let e = 0;
  const t = new Array();
  let r = Te;
  for (; gt !== n; )
    if (gt === 92)
      t.push(Me.slice(r, Te)), ye(), e = w0(gt), ye(), t.push(gc(e)), r = Te;
    else {
      if (Te >= Kr)
        throw $A();
      ye();
    }
  const i = Me.slice(r, Te);
  return ye(), t.push(i), $e = t.join(""), 16384;
}
function B1() {
  let n = !0, e = "";
  for (; ye() !== 96; )
    if (gt === 36)
      if (Te + 1 < Kr && Zs(Te + 1) === 123) {
        Te++, n = !1;
        break;
      } else
        e += "$";
    else if (gt === 92)
      e += gc(w0(ye()));
    else {
      if (Te >= Kr)
        throw $1();
      e += gc(gt);
    }
  return ye(), $e = e, n ? 2163759 : 2163760;
}
const _A = () => {
  if (Te >= Kr)
    throw $1();
  return Te--, B1();
}, vr = (n) => Y === n ? (oe(), !0) : !1, Sr = (n) => {
  if (Y === n)
    oe();
  else
    throw L1(n);
}, PA = () => se(`AUR0151:${Me}`), dh = () => se(`AUR0152:${Me}`), ii = () => se(`AUR0153:${Me}`), MA = () => se(`AUR0154:${Me}`), RA = () => se(`AUR0155:${Me}`), hf = () => se(`AUR0156:${Me}`), kA = () => se("AUR0157"), IA = () => se(`AUR0158:${Me}`), OA = () => se(`AUR0159:${Me}`), DA = () => se(`AUR0160:${Me}`), NA = () => se(`AUR0161:${Me}`), Hm = () => se(`AUR0163:${Me}`), BA = () => se(`AUR0164:${Me}`), $A = () => se(`AUR0165:${Me}`), $1 = () => se(`AUR0166:${Me}`), L1 = (n) => se(`AUR0167:${Me}<${Gl[63 & n]}`), F1 = () => {
  throw se(`AUR0168:${Me}`);
};
F1.notMapped = !0;
const LA = () => se(`AUR0170:${Me}`), T0 = () => se(`AUR0171:${Me}`), jl = () => se(`AUR0172:${Me}`), gl = () => se(`AUR0173:${Me}`), zm = () => se(`AUR0174:${Me}`), Km = () => se(`AUR0175:${Me}`), FA = () => se(`AUR0176:${Me}`), U1 = () => se(`AUR0178:${Me}`), UA = () => se(`AUR0179:${Me}`), Gl = [mA, yA, gA, O1, "$this", null, "$parent", "(", "{", ".", "..", "...", "?.", "}", ")", ",", "[", "]", ":", ";", "?", "'", '"', "&", "|", "??", "||", "&&", "==", "!=", "===", "!==", "<", ">", "<=", ">=", "in", "instanceof", "+", "-", "typeof", "void", "*", "%", "/", "=", "!", 2163759, 2163760, "of", "=>"], VA = Object.assign(/* @__PURE__ */ Object.create(null), {
  true: 8193,
  null: 8194,
  false: 8192,
  undefined: 8195,
  $this: 12292,
  $parent: 12294,
  in: 6562212,
  instanceof: 6562213,
  typeof: 139304,
  void: 139305,
  of: 4204593
}), po = {
  AsciiIdPart: [36, 0, 48, 58, 65, 91, 95, 0, 97, 123],
  IdStart: [36, 0, 65, 91, 95, 0, 97, 123, 170, 0, 186, 0, 192, 215, 216, 247, 248, 697, 736, 741, 7424, 7462, 7468, 7517, 7522, 7526, 7531, 7544, 7545, 7615, 7680, 7936, 8305, 0, 8319, 0, 8336, 8349, 8490, 8492, 8498, 0, 8526, 0, 8544, 8585, 11360, 11392, 42786, 42888, 42891, 42927, 42928, 42936, 42999, 43008, 43824, 43867, 43868, 43877, 64256, 64263, 65313, 65339, 65345, 65371],
  Digit: [48, 58],
  Skip: [0, 33, 127, 161]
}, mo = (n, e, t, r) => {
  const i = t.length;
  for (let s = 0; s < i; s += 2) {
    const a = t[s];
    let o = t[s + 1];
    if (o = o > 0 ? o : a + 1, n && n.fill(r, a, o), e)
      for (let c = a; c < o; c++)
        e.add(c);
  }
}, Nn = (n) => () => (ye(), n), jA = /* @__PURE__ */ new Set();
mo(null, jA, po.AsciiIdPart, !0);
const C0 = new Uint8Array(65535);
mo(C0, null, po.IdStart, 1);
mo(C0, null, po.Digit, 1);
const Ie = new Array(65535);
Ie.fill(F1, 0, 65535);
mo(Ie, null, po.Skip, () => (ye(), null));
mo(Ie, null, po.IdStart, EA);
mo(Ie, null, po.Digit, () => N1(!1));
Ie[34] = Ie[39] = () => SA();
Ie[96] = () => B1();
Ie[33] = () => ye() !== 61 ? 131118 : ye() !== 61 ? 6553949 : (ye(), 6553951);
Ie[61] = () => ye() === 62 ? (ye(), 50) : gt !== 61 ? 4194349 : ye() !== 61 ? 6553948 : (ye(), 6553950);
Ie[38] = () => ye() !== 38 ? 6291479 : (ye(), 6553883);
Ie[124] = () => ye() !== 124 ? 6291480 : (ye(), 6553818);
Ie[63] = () => {
  if (ye() === 46) {
    const n = Zs(Te + 1);
    return n <= 48 || n >= 57 ? (ye(), 2162700) : 6291478;
  }
  return gt !== 63 ? 6291478 : (ye(), 6553753);
};
Ie[46] = () => ye() <= 57 && gt >= 48 ? N1(!0) : gt === 46 ? ye() !== 46 ? 10 : (ye(), 11) : 65545;
Ie[60] = () => ye() !== 61 ? 6554016 : (ye(), 6554018);
Ie[62] = () => ye() !== 61 ? 6554017 : (ye(), 6554019);
Ie[37] = Nn(6554155);
Ie[40] = Nn(2688007);
Ie[41] = Nn(7340046);
Ie[42] = Nn(6554154);
Ie[43] = Nn(2490854);
Ie[44] = Nn(6291471);
Ie[45] = Nn(2490855);
Ie[47] = Nn(6554156);
Ie[58] = Nn(6291476);
Ie[59] = Nn(6291477);
Ie[91] = Nn(2688016);
Ie[93] = Nn(7340051);
Ie[123] = Nn(524296);
Ie[125] = Nn(7340045);
let xe = null;
const Na = [];
let Ti = !1;
function GA() {
  Ti = !1;
}
function WA() {
  Ti = !0;
}
function E0() {
  return xe;
}
function S0(n) {
  if (n == null)
    throw se("AUR0206");
  if (xe == null) {
    xe = n, Na[0] = xe, Ti = !0;
    return;
  }
  if (xe === n)
    throw se("AUR0207");
  Na.push(n), xe = n, Ti = !0;
}
function _0(n) {
  if (n == null)
    throw se("AUR0208");
  if (xe !== n)
    throw se("AUR0209");
  Na.pop(), xe = Na.length > 0 ? Na[Na.length - 1] : null, Ti = xe != null;
}
const HA = Object.freeze({
  get current() {
    return xe;
  },
  get connecting() {
    return Ti;
  },
  enter: S0,
  exit: _0,
  pause: GA,
  resume: WA
}), qa = Reflect.get, zA = Object.prototype.toString, V1 = /* @__PURE__ */ new WeakMap();
function j1(n) {
  switch (zA.call(n)) {
    case "[object Object]":
    case "[object Array]":
    case "[object Map]":
    case "[object Set]":
      return !0;
    default:
      return !1;
  }
}
const yo = "__raw__";
function ge(n) {
  return j1(n) ? hd(n) : n;
}
function hd(n) {
  return V1.get(n) ?? KA(n);
}
function Ee(n) {
  return n[yo] ?? n;
}
function vn(n) {
  return j1(n) && n[yo] || n;
}
function P0(n) {
  return n === "constructor" || n === "__proto__" || n === "$observers" || n === Symbol.toPrimitive || n === Symbol.toStringTag;
}
function KA(n) {
  const e = fs(n) ? QA : is(n) || jc(n) ? b4 : qA, t = new Proxy(n, e);
  return V1.set(n, t), t;
}
const qA = {
  get(n, e, t) {
    if (e === yo)
      return n;
    const r = E0();
    return !Ti || P0(e) || r == null ? qa(n, e, t) : (r.observe(n, e), ge(qa(n, e, t)));
  }
}, QA = {
  get(n, e, t) {
    if (e === yo)
      return n;
    if (!Ti || P0(e) || xe == null)
      return qa(n, e, t);
    switch (e) {
      case "length":
        return xe.observe(n, "length"), n.length;
      case "map":
        return JA;
      case "includes":
        return ZA;
      case "indexOf":
        return e4;
      case "lastIndexOf":
        return t4;
      case "every":
        return YA;
      case "filter":
        return XA;
      case "find":
        return r4;
      case "findIndex":
        return n4;
      case "flat":
        return i4;
      case "flatMap":
        return s4;
      case "join":
        return a4;
      case "push":
        return c4;
      case "pop":
        return o4;
      case "reduce":
        return y4;
      case "reduceRight":
        return g4;
      case "reverse":
        return f4;
      case "shift":
        return l4;
      case "unshift":
        return u4;
      case "slice":
        return m4;
      case "splice":
        return d4;
      case "some":
        return h4;
      case "sort":
        return p4;
      case "keys":
        return G1;
      case "values":
      case Symbol.iterator:
        return fh;
      case "entries":
        return hh;
    }
    return xe.observe(n, e), ge(qa(n, e, t));
  },
  ownKeys(n) {
    return E0()?.observe(n, "length"), Reflect.ownKeys(n);
  }
};
function JA(n, e) {
  const t = Ee(this), r = t.map((i, s) => vn(n.call(e, ge(i), s, this)));
  return Ct(xe, t), ge(r);
}
function YA(n, e) {
  const t = Ee(this), r = t.every((i, s) => n.call(e, ge(i), s, this));
  return Ct(xe, t), r;
}
function XA(n, e) {
  const t = Ee(this), r = t.filter((i, s) => vn(n.call(e, ge(i), s, this)));
  return Ct(xe, t), ge(r);
}
function ZA(n) {
  const e = Ee(this), t = e.includes(vn(n));
  return Ct(xe, e), t;
}
function e4(n) {
  const e = Ee(this), t = e.indexOf(vn(n));
  return Ct(xe, e), t;
}
function t4(n) {
  const e = Ee(this), t = e.lastIndexOf(vn(n));
  return Ct(xe, e), t;
}
function n4(n, e) {
  const t = Ee(this), r = t.findIndex((i, s) => vn(n.call(e, ge(i), s, this)));
  return Ct(xe, t), r;
}
function r4(n, e) {
  const t = Ee(this), r = t.find((i, s) => n(ge(i), s, this), e);
  return Ct(xe, t), ge(r);
}
function i4() {
  const n = Ee(this);
  return Ct(xe, n), ge(n.flat());
}
function s4(n, e) {
  const t = Ee(this);
  return Ct(xe, t), hd(t.flatMap((r, i) => ge(n.call(e, ge(r), i, this))));
}
function a4(n) {
  const e = Ee(this);
  return Ct(xe, e), e.join(n);
}
function o4() {
  return ge(Ee(this).pop());
}
function c4(...n) {
  return Ee(this).push(...n);
}
function l4() {
  return ge(Ee(this).shift());
}
function u4(...n) {
  return Ee(this).unshift(...n);
}
function d4(...n) {
  return ge(Ee(this).splice(...n));
}
function f4(...n) {
  const e = Ee(this), t = e.reverse();
  return Ct(xe, e), ge(t);
}
function h4(n, e) {
  const t = Ee(this), r = t.some((i, s) => vn(n.call(e, ge(i), s, this)));
  return Ct(xe, t), r;
}
function p4(n) {
  const e = Ee(this), t = e.sort(n);
  return Ct(xe, e), ge(t);
}
function m4(n, e) {
  const t = Ee(this);
  return Ct(xe, t), hd(t.slice(n, e));
}
function y4(n, e) {
  const t = Ee(this), r = t.reduce((i, s, a) => n(i, ge(s), a, this), e);
  return Ct(xe, t), ge(r);
}
function g4(n, e) {
  const t = Ee(this), r = t.reduceRight((i, s, a) => n(i, ge(s), a, this), e);
  return Ct(xe, t), ge(r);
}
const b4 = {
  get(n, e, t) {
    if (e === yo)
      return n;
    const r = E0();
    if (!Ti || P0(e) || r == null)
      return qa(n, e, t);
    switch (e) {
      case "size":
        return r.observe(n, "size"), n.size;
      case "clear":
        return C4;
      case "delete":
        return E4;
      case "forEach":
        return x4;
      case "add":
        if (jc(n))
          return T4;
        break;
      case "get":
        if (is(n))
          return w4;
        break;
      case "set":
        if (is(n))
          return A4;
        break;
      case "has":
        return v4;
      case "keys":
        return G1;
      case "values":
        return fh;
      case "entries":
        return hh;
      case Symbol.iterator:
        return is(n) ? hh : fh;
    }
    return ge(qa(n, e, t));
  }
};
function x4(n, e) {
  const t = Ee(this);
  return Ct(xe, t), t.forEach((r, i) => {
    n.call(e, ge(r), ge(i), this);
  });
}
function v4(n) {
  const e = Ee(this);
  return Ct(xe, e), e.has(vn(n));
}
function w4(n) {
  const e = Ee(this);
  return Ct(xe, e), ge(e.get(vn(n)));
}
function A4(n, e) {
  return ge(Ee(this).set(vn(n), vn(e)));
}
function T4(n) {
  return ge(Ee(this).add(vn(n)));
}
function C4() {
  return ge(Ee(this).clear());
}
function E4(n) {
  return ge(Ee(this).delete(vn(n)));
}
function G1() {
  const n = Ee(this);
  Ct(xe, n);
  const e = n.keys();
  return {
    next() {
      const t = e.next(), r = t.value, i = t.done;
      return i ? {
        value: void 0,
        done: i
      } : {
        value: ge(r),
        done: i
      };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function fh() {
  const n = Ee(this);
  Ct(xe, n);
  const e = n.values();
  return {
    next() {
      const t = e.next(), r = t.value, i = t.done;
      return i ? {
        value: void 0,
        done: i
      } : {
        value: ge(r),
        done: i
      };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function hh() {
  const n = Ee(this);
  Ct(xe, n);
  const e = n.entries();
  return {
    next() {
      const t = e.next(), r = t.value, i = t.done;
      return i ? {
        value: void 0,
        done: i
      } : {
        value: [ge(r[0]), ge(r[1])],
        done: i
      };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
const Ct = (n, e) => n?.observeCollection(e), S4 = Object.freeze({
  getProxy: hd,
  getRaw: Ee,
  wrap: ge,
  unwrap: vn,
  rawKey: yo
});
class Gc {
  constructor(e, t, r, i, s) {
    this.type = 1, this.v = void 0, this.ov = void 0, this.ir = !1, this.D = !1, this.o = e, this.$get = t, this.$set = r, this.up = i, this.oL = s;
  }
  static create(e, t, r, i, s) {
    const a = r.get, o = r.set, c = new Gc(e, a, o, s, i), l = () => c.getValue();
    return l.getObserver = () => c, cr(e, t, {
      enumerable: r.enumerable,
      configurable: !0,
      get: l,
      set: (f) => {
        c.setValue(f);
      }
    }), c;
  }
  getValue() {
    return this.subs.count === 0 ? this.$get.call(this.o, this) : (this.D && (this.compute(), this.D = !1), this.v);
  }
  setValue(e) {
    if (rr(this.$set))
      e !== this.v && (this.ir = !0, this.$set.call(this.o, e), this.ir = !1, this.run());
    else
      throw se("AUR0221");
  }
  handleChange() {
    this.D = !0, this.subs.count > 0 && this.run();
  }
  handleCollectionChange() {
    this.D = !0, this.subs.count > 0 && this.run();
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.compute(), this.D = !1);
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && (this.D = !0, this.obs.clearAll());
  }
  run() {
    if (this.ir)
      return;
    const e = this.v, t = this.compute();
    this.D = !1, y0(t, e) || (this.ov = e, qm = this.ov, this.ov = this.v, this.subs.notify(this.v, qm));
  }
  compute() {
    this.ir = !0, this.obs.version++;
    try {
      return S0(this), this.v = vn(this.$get.call(this.up ? ge(this.o) : this.o, this));
    } finally {
      this.obs.clear(), this.ir = !1, _0(this);
    }
  }
}
Rr(Gc);
An(Gc);
let qm;
const W1 = uo("IDirtyChecker", (n) => n.singleton(H1)), _4 = {
  timeoutsPerCheck: 25,
  disabled: !1,
  throw: !1,
  resetToDefault() {
    this.timeoutsPerCheck = 6, this.disabled = !1, this.throw = !1;
  }
}, P4 = {
  persistent: !0
};
class H1 {
  constructor(e) {
    this.p = e, this.tracked = [], this.A = null, this.O = 0, this.check = () => {
      if (++this.O < _4.timeoutsPerCheck)
        return;
      this.O = 0;
      const t = this.tracked, r = t.length;
      let i, s = 0;
      for (; s < r; ++s)
        i = t[s], i.isDirty() && i.flush();
    };
  }
  createProperty(e, t) {
    return new z1(this, e, t);
  }
  addProperty(e) {
    this.tracked.push(e), this.tracked.length === 1 && (this.A = this.p.taskQueue.queueTask(this.check, P4));
  }
  removeProperty(e) {
    this.tracked.splice(this.tracked.indexOf(e), 1), this.tracked.length === 0 && (this.A.cancel(), this.A = null);
  }
}
H1.inject = [Vc];
class z1 {
  constructor(e, t, r) {
    this.obj = t, this.key = r, this.type = 0, this.ov = void 0, this.C = e;
  }
  getValue() {
    return this.obj[this.key];
  }
  setValue(e) {
    throw se(`Trying to set value for property ${g0(this.key)} in dirty checker`);
  }
  isDirty() {
    return this.ov !== this.obj[this.key];
  }
  flush() {
    const e = this.ov, t = this.getValue();
    this.ov = t, this.subs.notify(t, e);
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.ov = this.obj[this.key], this.C.addProperty(this));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && this.C.removeProperty(this);
  }
}
An(z1);
class M4 {
  constructor(e, t) {
    this.type = 0, this.o = e, this.k = t;
  }
  get doNotCache() {
    return !0;
  }
  getValue() {
    return this.o[this.k];
  }
  setValue() {
  }
  subscribe() {
  }
  unsubscribe() {
  }
}
class K1 {
  constructor() {
    this.type = 0;
  }
  getValue(e, t) {
    return e[t];
  }
  setValue(e, t, r) {
    t[r] = e;
  }
}
class M0 {
  constructor(e, t) {
    this.type = 1, this.v = void 0, this.iO = !1, this.o = e, this.k = t;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    if (this.iO) {
      if (y0(e, this.v))
        return;
      pu = this.v, this.v = e, this.subs.notify(e, pu);
    } else
      this.o[this.k] = e;
  }
  subscribe(e) {
    this.iO === !1 && this.start(), this.subs.add(e);
  }
  start() {
    return this.iO === !1 && (this.iO = !0, this.v = this.o[this.k], cr(this.o, this.k, {
      enumerable: !0,
      configurable: !0,
      get: () => this.getValue(),
      set: (e) => {
        this.setValue(e);
      }
    })), this;
  }
  stop() {
    return this.iO && (cr(this.o, this.k, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.v
    }), this.iO = !1), this;
  }
}
class R4 {
  constructor(e, t, r, i) {
    this.type = 1, this.v = void 0, this.ov = void 0, this.o = e, this.S = r, this.hs = rr(r);
    const s = e[t];
    this.cb = rr(s) ? s : void 0, this.v = i;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.hs && (e = this.S(e, null)), y0(e, this.v) || (this.ov = this.v, this.v = e, this.cb?.call(this.o, this.v, this.ov), pu = this.ov, this.ov = this.v, this.subs.notify(this.v, pu));
  }
}
An(M0);
An(R4);
let pu;
const ph = new K1(), ma = uo("IObserverLocator", (n) => n.singleton(q1)), mu = uo("INodeObserverLocator", (n) => n.cachedCallback((e) => new k4()));
class k4 {
  handles() {
    return !1;
  }
  getObserver() {
    return ph;
  }
  getAccessor() {
    return ph;
  }
}
class q1 {
  constructor(e, t) {
    this.$ = [], this.C = e, this.R = t;
  }
  addAdapter(e) {
    this.$.push(e);
  }
  getObserver(e, t) {
    if (e == null)
      throw O4(t);
    if (!Jo(e))
      return new M4(e, t);
    const r = Q1(e);
    let i = r[t];
    return i === void 0 && (i = this.createObserver(e, t), i.doNotCache || (r[t] = i)), i;
  }
  getAccessor(e, t) {
    const r = e.$observers?.[t];
    return r !== void 0 ? r : this.R.handles(e, t, this) ? this.R.getAccessor(e, t, this) : ph;
  }
  getArrayObserver(e) {
    return Xo(e);
  }
  getMapObserver(e) {
    return hu(e);
  }
  getSetObserver(e) {
    return fu(e);
  }
  createObserver(e, t) {
    if (this.R.handles(e, t, this))
      return this.R.getObserver(e, t, this);
    switch (t) {
      case "length":
        if (fs(e))
          return Xo(e).getLengthObserver();
        break;
      case "size":
        if (is(e))
          return hu(e).getLengthObserver();
        if (jc(e))
          return fu(e).getLengthObserver();
        break;
      default:
        if (fs(e) && fc(t))
          return Xo(e).getIndexObserver(Number(t));
        break;
    }
    let r = Jm(e, t);
    if (r === void 0) {
      let i = Qm(e);
      for (; i !== null && (r = Jm(i, t), r === void 0); )
        i = Qm(i);
    }
    if (r !== void 0 && !C5.call(r, "value")) {
      let i = this.U(e, t, r);
      return i == null && (i = (r.get?.getObserver ?? r.set?.getObserver)?.(e, this)), i ?? (r.configurable ? Gc.create(e, t, r, this, !0) : this.C.createProperty(e, t));
    }
    return new M0(e, t);
  }
  U(e, t, r) {
    if (this.$.length > 0)
      for (const i of this.$) {
        const s = i.getObserver(e, t, r, this);
        if (s != null)
          return s;
      }
    return null;
  }
}
q1.inject = [W1, mu];
const I4 = (n) => {
  let e;
  return fs(n) ? e = Xo(n) : is(n) ? e = hu(n) : jc(n) && (e = fu(n)), e;
}, Qm = Object.getPrototypeOf, Jm = Object.getOwnPropertyDescriptor, Q1 = (n) => {
  let e = n.$observers;
  return e === void 0 && cr(n, "$observers", {
    enumerable: !1,
    value: e = Yo()
  }), e;
}, O4 = (n) => se(`AUR0199:${g0(n)}`);
uo("IObservation", (n) => n.singleton(D4));
class D4 {
  constructor(e) {
    this.oL = e;
  }
  static get inject() {
    return [ma];
  }
  run(e) {
    const t = new J1(this.oL, e);
    return t.run(), t;
  }
}
class J1 {
  constructor(e, t) {
    this.oL = e, this.fn = t, this.maxRunCount = 10, this.queued = !1, this.running = !1, this.runCount = 0, this.stopped = !1;
  }
  handleChange() {
    this.queued = !0, this.run();
  }
  handleCollectionChange() {
    this.queued = !0, this.run();
  }
  run() {
    if (this.stopped)
      throw se("AUR0225");
    if (!this.running) {
      ++this.runCount, this.running = !0, this.queued = !1, ++this.obs.version;
      try {
        S0(this), this.fn(this);
      } finally {
        this.obs.clear(), this.running = !1, _0(this);
      }
      if (this.queued) {
        if (this.runCount > this.maxRunCount)
          throw this.runCount = 0, se("AUR0226");
        this.run();
      } else
        this.runCount = 0;
    }
  }
  stop() {
    this.stopped = !0, this.obs.clearAll();
  }
}
Rr(J1);
const R0 = uo("ISignaler", (n) => n.singleton(N4));
class N4 {
  constructor() {
    this.signals = Yo();
  }
  dispatchSignal(e) {
    const t = this.signals[e];
    if (t === void 0)
      return;
    let r;
    for (r of t.keys())
      r.handleChange(void 0, void 0);
  }
  addSignalListener(e, t) {
    const r = this.signals, i = r[e];
    i === void 0 ? r[e] = /* @__PURE__ */ new Set([t]) : i.add(t);
  }
  removeSignalListener(e, t) {
    this.signals[e]?.delete(t);
  }
}
class B4 extends Error {
  constructor(e) {
    super("Task was canceled."), this.task = e;
  }
}
var Ym;
(function(n) {
  n[n.pending = 0] = "pending", n[n.running = 1] = "running", n[n.completed = 2] = "completed", n[n.canceled = 3] = "canceled";
})(Ym || (Ym = {}));
var Xm;
(function(n) {
  n[n.render = 0] = "render", n[n.macroTask = 1] = "macroTask", n[n.postRender = 2] = "postRender";
})(Xm || (Xm = {}));
function Q(n, e, t, r) {
  var i = arguments.length, s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, r);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (a = n[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function fn(n, e) {
  return function(t, r) {
    e(t, r, n);
  };
}
const mn = Yr.getOwn, Wc = Yr.hasOwn, Tt = Yr.define, { annotation: k0, resource: Y1 } = Ar, yn = k0.keyFor, ya = Y1.keyFor, gs = Y1.appendTo, I0 = k0.appendTo, X1 = k0.getKeys, bs = Object, O0 = bs.prototype, sn = () => bs.create(null), ne = (n) => new Error(n), ss = O0.hasOwnProperty, Qn = bs.freeze, D0 = bs.assign, N0 = bs.getOwnPropertyNames, B0 = bs.keys, Zm = sn(), mh = (n, e, t) => {
  if (Zm[e] === !0)
    return !0;
  if (!bt(e))
    return !1;
  const r = e.slice(0, 5);
  return Zm[e] = r === "aria-" || r === "data-" || t.isStandardSvgAttribute(n, e);
}, Qt = (n) => n instanceof Promise, _r = (n) => n instanceof Array, kn = (n) => typeof n == "function", bt = (n) => typeof n == "string", $4 = bs.defineProperty, yu = (n) => {
  throw n;
}, Hc = bs.is, yh = Reflect.defineProperty, Tr = (n, e, t) => (yh(n, e, {
  enumerable: !1,
  configurable: !0,
  writable: !0,
  value: t
}), t);
function Be(n, e) {
  let t;
  function r(i, s) {
    arguments.length > 1 && (t.property = s), Tt(Xi, ts.create(s, i, t), i.constructor, s), I0(i.constructor, di.keyFrom(s));
  }
  if (arguments.length > 1) {
    t = {}, r(n, e);
    return;
  } else if (bt(n))
    return t = {}, r;
  return t = n === void 0 ? {} : n, r;
}
function L4(n) {
  return n.startsWith(Xi);
}
const Xi = yn("bindable"), di = Qn({
  name: Xi,
  keyFrom: (n) => `${Xi}:${n}`,
  from(n, ...e) {
    const t = {}, r = Array.isArray;
    function i(o) {
      t[o] = ts.create(o, n);
    }
    function s(o, c) {
      t[o] = c instanceof ts ? c : ts.create(o, n, c);
    }
    function a(o) {
      r(o) ? o.forEach(i) : o instanceof ts ? t[o.property] = o : o !== void 0 && B0(o).forEach((c) => s(c, o[c]));
    }
    return e.forEach(a), t;
  },
  for(n) {
    let e;
    const t = {
      add(r) {
        let i, s;
        return bt(r) ? (i = r, s = {
          property: i
        }) : (i = r.property, s = r), e = ts.create(i, n, s), Wc(Xi, n, i) || I0(n, di.keyFrom(i)), Tt(Xi, e, n, i), t;
      },
      mode(r) {
        return e.mode = r, t;
      },
      callback(r) {
        return e.callback = r, t;
      },
      attribute(r) {
        return e.attribute = r, t;
      },
      primary() {
        return e.primary = !0, t;
      },
      set(r) {
        return e.set = r, t;
      }
    };
    return t;
  },
  getAll(n) {
    const e = Xi.length + 1, t = [], r = i1(n);
    let i = r.length, s = 0, a, o, c, l;
    for (; --i >= 0; )
      for (c = r[i], a = X1(c).filter(L4), o = a.length, l = 0; l < o; ++l)
        t[s++] = mn(Xi, c, a[l].slice(e));
    return t;
  }
});
class ts {
  constructor(e, t, r, i, s, a) {
    this.attribute = e, this.callback = t, this.mode = r, this.primary = i, this.property = s, this.set = a;
  }
  static create(e, t, r = {}) {
    return new ts(on(r.attribute, r1(e)), on(r.callback, `${e}Changed`), on(r.mode, 2), on(r.primary, !1), on(r.property, e), on(r.set, F4(e, t, r)));
  }
}
const gh = {
  key: yn("coercer"),
  define(n, e) {
    Tt(gh.key, n[e].bind(n), n);
  },
  for(n) {
    return mn(gh.key, n);
  }
};
function F4(n, e, t = {}) {
  const r = t.type ?? Yr.get("design:type", e, n) ?? null;
  if (r == null)
    return bi;
  let i;
  switch (r) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
      i = r;
      break;
    default: {
      const s = r.coerce;
      i = typeof s == "function" ? s.bind(r) : gh.for(r) ?? bi;
      break;
    }
  }
  return i === bi ? i : U4(i, t.nullable);
}
function U4(n, e) {
  return function(t, r) {
    return r?.enableCoercion ? (e ?? !(r?.coerceNullish ?? !1)) && t == null ? t : n(t, r) : t;
  };
}
class Z1 {
  constructor(e, t, r, i, s, a) {
    this.set = i, this.$controller = s, this.i = a, this.v = void 0, this.ov = void 0;
    const o = e[r], c = e.propertyChanged, l = this.u = kn(o), f = this.A = kn(c), p = this.hs = i !== bi;
    let g;
    this.o = e, this.k = t, this.C = f ? c : bi, this.cb = l ? o : bi, this.cb === void 0 && !f && !p ? this.iO = !1 : (this.iO = !0, g = e[t], this.v = p && g !== void 0 ? i(g, this.i) : g, this.B());
  }
  get type() {
    return 1;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.hs && (e = this.set(e, this.i));
    const t = this.v;
    if (this.iO) {
      if (Hc(e, t))
        return;
      this.v = e, this.ov = t, (this.$controller == null || this.$controller.isBound) && (this.u && this.cb.call(this.o, e, t), this.A && this.C.call(this.o, this.k, e, t)), this.subs.notify(this.v, this.ov);
    } else
      this.o[this.k] = e;
  }
  subscribe(e) {
    this.iO && (this.iO = !0, this.v = this.hs ? this.set(this.o[this.k], this.i) : this.o[this.k], this.B()), this.subs.add(e);
  }
  B() {
    Reflect.defineProperty(this.o, this.k, {
      enumerable: !0,
      configurable: !0,
      get: () => this.v,
      set: (e) => {
        this.setValue(e);
      }
    });
  }
}
An(Z1);
const ey = function(n) {
  function e(t, r, i) {
    pe.inject(e)(t, r, i);
  }
  return e.$isResolver = !0, e.resolve = function(t, r) {
    return r.root === r || r.has(n, !1) ? r.get(n) : r.root.get(n);
  }, e;
}, ke = pe.createInterface, ga = fe.singleton, zc = fe.aliasTo, V4 = fe.instance, ev = fe.transient, At = (n, e, t) => n.registerResolver(e, t);
function j4(...n) {
  return function(e) {
    const t = yn("aliases"), r = mn(t, e);
    r === void 0 ? Tt(t, n, e) : r.push(...n);
  };
}
function Kc(n, e, t, r) {
  for (let i = 0, s = n.length; i < s; ++i)
    fe.aliasTo(t, e.keyFrom(n[i])).register(r);
}
class $0 {
  constructor(e, t, r, i) {
    if (this.chars = e, this.repeat = t, this.isSymbol = r, this.isInverted = i, i)
      switch (e.length) {
        case 0:
          this.has = this.R;
          break;
        case 1:
          this.has = this.I;
          break;
        default:
          this.has = this.T;
      }
    else
      switch (e.length) {
        case 0:
          this.has = this.P;
          break;
        case 1:
          this.has = this.L;
          break;
        default:
          this.has = this.U;
      }
  }
  equals(e) {
    return this.chars === e.chars && this.repeat === e.repeat && this.isSymbol === e.isSymbol && this.isInverted === e.isInverted;
  }
  U(e) {
    return this.chars.includes(e);
  }
  L(e) {
    return this.chars === e;
  }
  P(e) {
    return !1;
  }
  T(e) {
    return !this.chars.includes(e);
  }
  I(e) {
    return this.chars !== e;
  }
  R(e) {
    return !0;
  }
}
class G4 {
  constructor() {
    this.parts = Ne, this.$ = "", this._ = {}, this.q = {};
  }
  get pattern() {
    const e = this.$;
    return e === "" ? null : e;
  }
  set pattern(e) {
    e == null ? (this.$ = "", this.parts = Ne) : (this.$ = e, this.parts = this.q[e]);
  }
  append(e, t) {
    const r = this._;
    r[e] === void 0 ? r[e] = t : r[e] += t;
  }
  next(e) {
    const t = this._;
    let r;
    t[e] !== void 0 && (r = this.q, r[e] === void 0 ? r[e] = [t[e]] : r[e].push(t[e]), t[e] = void 0);
  }
}
class L0 {
  constructor(e, ...t) {
    this.charSpec = e, this.M = [], this.F = null, this.O = !1, this.V = t;
  }
  get $() {
    return this.O ? this.V[0] : null;
  }
  findChild(e) {
    const t = this.M, r = t.length;
    let i = null, s = 0;
    for (; s < r; ++s)
      if (i = t[s], e.equals(i.charSpec))
        return i;
    return null;
  }
  append(e, t) {
    const r = this.V;
    r.includes(t) || r.push(t);
    let i = this.findChild(e);
    return i == null && (i = new L0(e, t), this.M.push(i), e.repeat && i.M.push(i)), i;
  }
  findMatches(e, t) {
    const r = [], i = this.M, s = i.length;
    let a = 0, o = null, c = 0, l = 0;
    for (; c < s; ++c)
      if (o = i[c], o.charSpec.has(e))
        if (r.push(o), a = o.V.length, l = 0, o.charSpec.isSymbol)
          for (; l < a; ++l)
            t.next(o.V[l]);
        else
          for (; l < a; ++l)
            t.append(o.V[l], e);
    return r;
  }
}
class ty {
  constructor(e) {
    this.text = e;
    const t = this.N = e.length, r = this.j = [];
    let i = 0;
    for (; t > i; ++i)
      r.push(new $0(e[i], !1, !1, !1));
  }
  eachChar(e) {
    const t = this.N, r = this.j;
    let i = 0;
    for (; t > i; ++i)
      e(r[i]);
  }
}
class W4 {
  constructor(e) {
    this.text = "PART", this.H = new $0(e, !0, !1, !0);
  }
  eachChar(e) {
    e(this.H);
  }
}
class H4 {
  constructor(e) {
    this.text = e, this.H = new $0(e, !1, !0, !1);
  }
  eachChar(e) {
    e(this.H);
  }
}
class z4 {
  constructor() {
    this.statics = 0, this.dynamics = 0, this.symbols = 0;
  }
}
const K4 = ke("ISyntaxInterpreter", (n) => n.singleton(q4));
class q4 {
  constructor() {
    this.W = new L0(null), this.G = [this.W];
  }
  add(e) {
    e = e.slice(0).sort((g, T) => g.pattern > T.pattern ? 1 : -1);
    const t = e.length;
    let r, i, s, a, o, c, l, f = 0, p;
    for (; t > f; ) {
      for (r = this.W, i = e[f], s = i.pattern, a = new z4(), o = this.X(i, a), c = o.length, l = (g) => r = r.append(g, s), p = 0; c > p; ++p)
        o[p].eachChar(l);
      r.F = a, r.O = !0, ++f;
    }
  }
  interpret(e) {
    const t = new G4(), r = e.length;
    let i = this.G, s = 0, a;
    for (; s < r && (i = this.K(i, e.charAt(s), t), i.length !== 0); ++s)
      ;
    return i = i.filter(Q4), i.length > 0 && (i.sort(J4), a = i[0], a.charSpec.isSymbol || t.next(a.$), t.pattern = a.$), t;
  }
  K(e, t, r) {
    const i = [];
    let s = null;
    const a = e.length;
    let o = 0;
    for (; o < a; ++o)
      s = e[o], i.push(...s.findMatches(t, r));
    return i;
  }
  X(e, t) {
    const r = [], i = e.pattern, s = i.length, a = e.symbols;
    let o = 0, c = 0, l = "";
    for (; o < s; )
      l = i.charAt(o), a.length === 0 || !a.includes(l) ? o === c && l === "P" && i.slice(o, o + 4) === "PART" ? (c = o += 4, r.push(new W4(a)), ++t.dynamics) : ++o : o !== c ? (r.push(new ty(i.slice(c, o))), ++t.statics, c = o) : (r.push(new H4(i.slice(c, o + 1))), ++t.symbols, c = ++o);
    return c !== o && (r.push(new ty(i.slice(c, o))), ++t.statics), r;
  }
}
function Q4(n) {
  return n.O;
}
function J4(n, e) {
  const t = n.F, r = e.F;
  return t.statics !== r.statics ? r.statics - t.statics : t.dynamics !== r.dynamics ? r.dynamics - t.dynamics : t.symbols !== r.symbols ? r.symbols - t.symbols : 0;
}
class lr {
  constructor(e, t, r, i) {
    this.rawName = e, this.rawValue = t, this.target = r, this.command = i;
  }
}
const tv = ke("IAttributePattern"), Y4 = ke("IAttributeParser", (n) => n.singleton(nv));
class nv {
  constructor(e, t) {
    this.Y = {}, this.Z = e;
    const r = this.V = {}, i = t.reduce((s, a) => {
      const o = rv(a.constructor);
      return o.forEach((c) => r[c.pattern] = a), s.concat(o);
    }, Ne);
    e.add(i);
  }
  parse(e, t) {
    let r = this.Y[e];
    r == null && (r = this.Y[e] = this.Z.interpret(e));
    const i = r.pattern;
    return i == null ? new lr(e, t, e, null) : this.V[i][i](e, t, r.parts);
  }
}
nv.inject = [K4, u1(tv)];
function ki(...n) {
  return function(t) {
    return Z4.define(n, t);
  };
}
class X4 {
  constructor(e) {
    this.Type = e, this.name = void 0;
  }
  register(e) {
    ga(tv, this.Type).register(e);
  }
}
const pf = ya("attribute-pattern"), Wl = "attribute-pattern-definitions", rv = (n) => Ar.annotation.get(n, Wl), Z4 = Qn({
  name: pf,
  definitionAnnotationKey: Wl,
  define(n, e) {
    const t = new X4(e);
    return Tt(pf, t, e), gs(e, pf), Ar.annotation.set(e, Wl, n), I0(e, Wl), e;
  },
  getPatternDefinitions: rv
});
let ny = class {
  "PART.PART"(e, t, r) {
    return new lr(e, t, r[0], r[1]);
  }
  "PART.PART.PART"(e, t, r) {
    return new lr(e, t, `${r[0]}.${r[1]}`, r[2]);
  }
};
ny = Q([ki({
  pattern: "PART.PART",
  symbols: "."
}, {
  pattern: "PART.PART.PART",
  symbols: "."
})], ny);
let ry = class {
  ref(e, t, r) {
    return new lr(e, t, "element", "ref");
  }
  "PART.ref"(e, t, r) {
    return new lr(e, t, r[0], "ref");
  }
};
ry = Q([ki({
  pattern: "ref",
  symbols: ""
}, {
  pattern: "PART.ref",
  symbols: "."
})], ry);
let iy = class {
  ":PART"(e, t, r) {
    return new lr(e, t, r[0], "bind");
  }
};
iy = Q([ki({
  pattern: ":PART",
  symbols: ":"
})], iy);
let sy = class {
  "@PART"(e, t, r) {
    return new lr(e, t, r[0], "trigger");
  }
};
sy = Q([ki({
  pattern: "@PART",
  symbols: "@"
})], sy);
let ay = class {
  "...$attrs"(e, t, r) {
    return new lr(e, t, "", "...$attrs");
  }
};
ay = Q([ki({
  pattern: "...$attrs",
  symbols: ""
})], ay);
class iv {
  constructor(e, t, r) {
    this.type = 7, this.v = null, this.ov = null, this.J = !1, this.o = e, this.tt = t, this.et = r;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.v = e, this.J = e !== this.ov, this.it();
  }
  it() {
    if (this.J)
      switch (this.J = !1, this.ov = this.v, this.et) {
        case "class":
          this.o.classList.toggle(this.tt, !!this.v);
          break;
        case "style": {
          let e = "", t = this.v;
          bt(t) && t.includes("!important") && (e = "important", t = t.replace("!important", "")), this.o.style.setProperty(this.tt, t, e);
          break;
        }
        default:
          this.v == null ? this.o.removeAttribute(this.et) : this.o.setAttribute(this.et, String(this.v));
      }
  }
  handleMutation(e) {
    let t = !1;
    for (let r = 0, i = e.length; i > r; ++r) {
      const s = e[r];
      if (s.type === "attributes" && s.attributeName === this.tt) {
        t = !0;
        break;
      }
    }
    if (t) {
      let r;
      switch (this.et) {
        case "class":
          r = this.o.classList.contains(this.tt);
          break;
        case "style":
          r = this.o.style.getPropertyValue(this.tt);
          break;
        default:
          throw ne(`AUR0651:${this.et}`);
      }
      r !== this.v && (this.ov = this.v, this.v = r, this.J = !1, this.st());
    }
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.v = this.ov = this.o.getAttribute(this.tt), eT(this.o.ownerDocument.defaultView.MutationObserver, this.o, this));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && tT(this.o, this);
  }
  st() {
    oy = this.ov, this.ov = this.v, this.subs.notify(this.v, oy);
  }
}
An(iv);
const eT = (n, e, t) => {
  e.$eMObs === void 0 && (e.$eMObs = /* @__PURE__ */ new Set()), e.$mObs === void 0 && (e.$mObs = new n(nT)).observe(e, {
    attributes: !0
  }), e.$eMObs.add(t);
}, tT = (n, e) => {
  const t = n.$eMObs;
  return t && t.delete(e) ? (t.size === 0 && (n.$mObs.disconnect(), n.$mObs = void 0), !0) : !1;
}, nT = (n) => {
  n[0].target.$eMObs.forEach(rT, n);
};
function rT(n) {
  n.handleMutation(this);
}
let oy;
function Bn(n) {
  return function(e) {
    return gu.define(n, e);
  };
}
class F0 {
  constructor(e, t, r, i) {
    this.Type = e, this.name = t, this.aliases = r, this.key = i;
  }
  static create(e, t) {
    let r, i;
    return bt(e) ? (r = e, i = {
      name: r
    }) : (r = e.name, i = e), new F0(t, on(bh(t, "name"), r), kt(bh(t, "aliases"), i.aliases, t.aliases), gu.keyFrom(r));
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    ga(r, t).register(e), zc(r, t).register(e), Kc(i, gu, r, e);
  }
}
const Ls = ya("binding-behavior"), bh = (n, e) => mn(yn(e), n), gu = Qn({
  name: Ls,
  keyFrom(n) {
    return `${Ls}:${n}`;
  },
  isType(n) {
    return kn(n) && Wc(Ls, n);
  },
  define(n, e) {
    const t = F0.create(n, e);
    return Tt(Ls, t, t.Type), Tt(Ls, t, t), gs(e, Ls), t.Type;
  },
  getDefinition(n) {
    const e = mn(Ls, n);
    if (e === void 0)
      throw ne(`AUR0151:${n.name}`);
    return e;
  },
  annotate(n, e, t) {
    Tt(yn(e), t, n);
  },
  getAnnotation: bh
});
function qc(n) {
  return function(e) {
    return bu.define(n, e);
  };
}
class U0 {
  constructor(e, t, r, i) {
    this.Type = e, this.name = t, this.aliases = r, this.key = i;
  }
  static create(e, t) {
    let r, i;
    return bt(e) ? (r = e, i = {
      name: r
    }) : (r = e.name, i = e), new U0(t, on(xh(t, "name"), r), kt(xh(t, "aliases"), i.aliases, t.aliases), bu.keyFrom(r));
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    fe.singleton(r, t).register(e), fe.aliasTo(r, t).register(e), Kc(i, bu, r, e);
  }
}
const Fs = ya("value-converter"), xh = (n, e) => mn(yn(e), n), bu = Qn({
  name: Fs,
  keyFrom: (n) => `${Fs}:${n}`,
  isType(n) {
    return kn(n) && Wc(Fs, n);
  },
  define(n, e) {
    const t = U0.create(n, e);
    return Tt(Fs, t, t.Type), Tt(Fs, t, t), gs(e, Fs), t.Type;
  },
  getDefinition(n) {
    const e = mn(Fs, n);
    if (e === void 0)
      throw ne(`AUR0152:${n.name}`);
    return e;
  },
  annotate(n, e, t) {
    Tt(yn(e), t, n);
  },
  getAnnotation: xh
});
class iT {
  constructor(e, t) {
    this.v = void 0, this.b = e, this.nt = t;
  }
  flush() {
    this.b.updateSource(this.v);
  }
  handleChange(e, t) {
    const r = this.b;
    e !== V(r.ast, r.s, r, null) && (this.v = e, this.nt.add(this));
  }
}
const go = (n) => {
  Tr(n.prototype, "useScope", function(e) {
    this.s = e;
  });
}, Zr = (n, e = !0) => (t) => {
  const r = t.prototype;
  n != null && yh(r, "strict", {
    enumerable: !0,
    get: function() {
      return n;
    }
  }), yh(r, "strictFnCall", {
    enumerable: !0,
    get: function() {
      return e;
    }
  }), Tr(r, "get", function(i) {
    return this.l.get(i);
  }), Tr(r, "getSignaler", function() {
    return this.l.root.get(R0);
  }), Tr(r, "getConverter", function(i) {
    const s = bu.keyFrom(i);
    let a = bl.get(this);
    return a == null && bl.set(this, a = new cy()), a[s] ?? (a[s] = this.l.get(ey(s)));
  }), Tr(r, "getBehavior", function(i) {
    const s = gu.keyFrom(i);
    let a = bl.get(this);
    return a == null && bl.set(this, a = new cy()), a[s] ?? (a[s] = this.l.get(ey(s)));
  });
}, bl = /* @__PURE__ */ new WeakMap();
class cy {
}
const sT = ke("IFlushQueue", (n) => n.singleton(aT));
class aT {
  constructor() {
    this.rt = !1, this.ot = /* @__PURE__ */ new Set();
  }
  get count() {
    return this.ot.size;
  }
  add(e) {
    if (this.ot.add(e), !this.rt) {
      this.rt = !0;
      try {
        this.ot.forEach(oT);
      } finally {
        this.rt = !1;
      }
    }
  }
  clear() {
    this.ot.clear(), this.rt = !1;
  }
}
function oT(n, e, t) {
  t.delete(n), n.flush();
}
const mf = /* @__PURE__ */ new WeakSet(), ba = (n, e) => {
  Tr(n.prototype, "limit", function(t) {
    if (mf.has(this))
      throw ne("AURXXXX: a rate limit has already been applied.");
    mf.add(this);
    const r = e(this, t), i = this[r], s = (...o) => i.call(this, ...o), a = t.type === "debounce" ? cT(t, s, this) : lT(t, s, this);
    return this[r] = a, {
      dispose: () => {
        mf.delete(this), a.dispose(), delete this[r];
      }
    };
  });
}, cT = (n, e, t) => {
  let r, i, s;
  const a = n.queue, o = (c) => {
    s = c, t.isBound ? (i = r, r = a.queueTask(() => e(s), {
      delay: n.delay,
      reusable: !1
    }), i?.cancel()) : e(s);
  };
  return o.dispose = () => {
    i?.cancel(), r?.cancel();
  }, o;
}, lT = (n, e, t) => {
  let r, i, s = 0, a = 0, o;
  const c = n.queue, l = () => n.now(), f = (p) => {
    o = p, t.isBound ? (a = l() - s, i = r, a > n.delay ? (s = l(), e(o)) : r = c.queueTask(() => {
      s = l(), e(o);
    }, {
      delay: n.delay - a,
      reusable: !1
    }), i?.cancel()) : e(o);
  };
  return f.dispose = () => {
    i?.cancel(), r?.cancel();
  }, f;
}, uT = {
  reusable: !1,
  preempt: !0
};
class Qc {
  constructor(e, t, r, i, s, a, o, c, l) {
    this.targetAttribute = o, this.targetProperty = c, this.mode = l, this.isBound = !1, this.s = void 0, this.lt = null, this.v = void 0, this.boundFn = !1, this.l = t, this.ast = s, this.ht = e, this.target = a, this.oL = r, this.ct = i;
  }
  updateTarget(e) {
    this.ut.setValue(e, this.target, this.targetProperty);
  }
  handleChange() {
    if (!this.isBound)
      return;
    let e;
    this.obs.version++;
    const t = V(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    this.obs.clear(), t !== this.v && (this.v = t, this.ht.state !== 1 && (4 & this.ut.type) > 0 ? (e = this.lt, this.lt = this.ct.queueTask(() => {
      this.lt = null, this.updateTarget(t);
    }, uT), e?.cancel()) : this.updateTarget(t));
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Er(this.ast, e, this), this.ut ?? (this.ut = new iv(this.target, this.targetProperty, this.targetAttribute)), this.mode & 3 && this.updateTarget(this.v = V(this.ast, e, this, (2 & this.mode) > 0 ? this : null)), this.isBound = !0;
  }
  unbind() {
    !this.isBound || (this.isBound = !1, sr(this.ast, this.s, this), this.s = void 0, this.v = void 0, this.lt?.cancel(), this.lt = null, this.obs.clearAll());
  }
}
go(Qc);
ba(Qc, () => "updateTarget");
Rr(Qc);
Zr(!0)(Qc);
const sv = {
  reusable: !1,
  preempt: !0
};
class dT {
  constructor(e, t, r, i, s, a, o, c) {
    this.ast = s, this.target = a, this.targetProperty = o, this.mode = c, this.isBound = !1, this.s = void 0, this.lt = null, this.ht = e, this.oL = r, this.ct = i, this.ut = r.getAccessor(a, o);
    const l = s.expressions, f = this.partBindings = Array(l.length), p = l.length;
    let g = 0;
    for (; p > g; ++g)
      f[g] = new Jc(l[g], a, o, t, r, this);
  }
  ft() {
    this.updateTarget();
  }
  updateTarget() {
    const e = this.partBindings, t = this.ast.parts, r = e.length;
    let i = "", s = 0;
    if (r === 1)
      i = t[0] + e[0].v + t[1];
    else
      for (i = t[0]; r > s; ++s)
        i += e[s].v + t[s + 1];
    const a = this.ut, o = this.ht.state !== 1 && (4 & a.type) > 0;
    let c;
    o ? (c = this.lt, this.lt = this.ct.queueTask(() => {
      this.lt = null, a.setValue(i, this.target, this.targetProperty);
    }, sv), c?.cancel(), c = null) : a.setValue(i, this.target, this.targetProperty);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e;
    const t = this.partBindings, r = t.length;
    let i = 0;
    for (; r > i; ++i)
      t[i].bind(e);
    this.updateTarget(), this.isBound = !0;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = !1, this.s = void 0;
    const e = this.partBindings, t = e.length;
    let r = 0;
    for (; t > r; ++r)
      e[r].unbind();
    this.lt?.cancel(), this.lt = null;
  }
}
class Jc {
  constructor(e, t, r, i, s, a) {
    this.ast = e, this.target = t, this.targetProperty = r, this.owner = a, this.mode = 2, this.task = null, this.isBound = !1, this.v = "", this.boundFn = !1, this.l = i, this.oL = s;
  }
  updateTarget() {
    this.owner.ft();
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = V(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    this.obs.clear(), e != this.v && (this.v = e, _r(e) && this.observeCollection(e), this.updateTarget());
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Er(this.ast, e, this), this.v = V(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null), _r(this.v) && this.observeCollection(this.v), this.isBound = !0;
  }
  unbind() {
    !this.isBound || (this.isBound = !1, sr(this.ast, this.s, this), this.s = void 0, this.obs.clearAll());
  }
}
go(Jc);
ba(Jc, () => "updateTarget");
Rr(Jc);
Zr(!0)(Jc);
class Yc {
  constructor(e, t, r, i, s, a, o, c) {
    this.p = s, this.ast = a, this.target = o, this.strict = c, this.isBound = !1, this.mode = 2, this.lt = null, this.v = "", this.boundFn = !1, this.l = t, this.ht = e, this.oL = r, this.ct = i;
  }
  updateTarget(e) {
    const t = this.target, r = this.p.Node, i = this.v;
    this.v = e, i instanceof r && i.parentNode?.removeChild(i), e instanceof r ? (t.textContent = "", t.parentNode?.insertBefore(e, t)) : t.textContent = String(e);
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = V(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    if (this.obs.clear(), e === this.v) {
      this.lt?.cancel(), this.lt = null;
      return;
    }
    this.ht.state !== 1 ? this.dt(e) : this.updateTarget(e);
  }
  handleCollectionChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = this.v = V(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    this.obs.clear(), _r(e) && this.observeCollection(e), this.ht.state !== 1 ? this.dt(e) : this.updateTarget(e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Er(this.ast, e, this);
    const t = this.v = V(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    _r(t) && this.observeCollection(t), this.updateTarget(t), this.isBound = !0;
  }
  unbind() {
    !this.isBound || (this.isBound = !1, sr(this.ast, this.s, this), this.s = void 0, this.obs.clearAll(), this.lt?.cancel(), this.lt = null);
  }
  dt(e) {
    const t = this.lt;
    this.lt = this.ct.queueTask(() => {
      this.lt = null, this.updateTarget(e);
    }, sv), t?.cancel();
  }
}
go(Yc);
ba(Yc, () => "updateTarget");
Rr()(Yc);
Zr(void 0, !1)(Yc);
class Xc {
  constructor(e, t, r, i, s = !1) {
    this.ast = r, this.targetProperty = i, this.isBound = !1, this.s = void 0, this.target = null, this.boundFn = !1, this.l = e, this.oL = t, this.gt = s;
  }
  updateTarget() {
    this.target[this.targetProperty] = this.v;
  }
  handleChange() {
    !this.isBound || (this.obs.version++, this.v = V(this.ast, this.s, this, this), this.obs.clear(), this.updateTarget());
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, this.target = this.gt ? e.bindingContext : e.overrideContext, Er(this.ast, e, this), this.v = V(this.ast, this.s, this, this), this.updateTarget(), this.isBound = !0;
  }
  unbind() {
    !this.isBound || (this.isBound = !1, sr(this.ast, this.s, this), this.s = void 0, this.obs.clearAll());
  }
}
go(Xc);
ba(Xc, () => "updateTarget");
Rr(Xc);
Zr(!0)(Xc);
class Ii {
  constructor(e, t, r, i, s, a, o, c) {
    this.ast = s, this.target = a, this.targetProperty = o, this.mode = c, this.isBound = !1, this.s = void 0, this.ut = void 0, this.lt = null, this.vt = null, this.boundFn = !1, this.l = t, this.ht = e, this.ct = i, this.oL = r;
  }
  updateTarget(e) {
    this.ut.setValue(e, this.target, this.targetProperty);
  }
  updateSource(e) {
    rn(this.ast, this.s, this, e);
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = V(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    this.obs.clear(), this.ht.state !== 1 && (4 & this.ut.type) > 0 ? (yf = this.lt, this.lt = this.ct.queueTask(() => {
      this.updateTarget(e), this.lt = null;
    }, fT), yf?.cancel(), yf = null) : this.updateTarget(e);
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Er(this.ast, e, this);
    const t = this.oL, r = this.mode;
    let i = this.ut;
    i || (4 & r ? i = t.getObserver(this.target, this.targetProperty) : i = t.getAccessor(this.target, this.targetProperty), this.ut = i);
    const s = (2 & r) > 0;
    r & 3 && this.updateTarget(V(this.ast, this.s, this, s ? this : null)), 4 & r && (i.subscribe(this.vt ?? (this.vt = new iT(this, this.l.get(sT)))), s || this.updateSource(i.getValue(this.target, this.targetProperty))), this.isBound = !0;
  }
  unbind() {
    !this.isBound || (this.isBound = !1, sr(this.ast, this.s, this), this.s = void 0, this.vt && (this.ut.unsubscribe(this.vt), this.vt = null), this.lt?.cancel(), this.lt = null, this.obs.clearAll());
  }
  useTargetObserver(e) {
    this.ut?.unsubscribe(this), (this.ut = e).subscribe(this);
  }
  useTargetSubscriber(e) {
    if (this.vt != null)
      throw ne("AURxxxx: binding already has a target subscriber");
    this.vt = e;
  }
}
go(Ii);
ba(Ii, (n) => 4 & n.mode ? "updateSource" : "updateTarget");
Rr(Ii);
Zr(!0, !1)(Ii);
let yf = null;
const fT = {
  reusable: !1,
  preempt: !0
};
class av {
  constructor(e, t, r) {
    this.ast = t, this.target = r, this.isBound = !1, this.s = void 0, this.l = e;
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Er(this.ast, e, this), rn(this.ast, this.s, this, this.target), this.isBound = !0;
  }
  unbind() {
    !this.isBound || (this.isBound = !1, V(this.ast, this.s, this, null) === this.target && rn(this.ast, this.s, this, null), sr(this.ast, this.s, this), this.s = void 0);
  }
}
Zr(!1)(av);
class hT {
  constructor(e, t = !1) {
    this.prevent = e, this.capture = t;
  }
}
class Zc {
  constructor(e, t, r, i, s) {
    this.ast = t, this.target = r, this.targetEvent = i, this.isBound = !1, this.self = !1, this.boundFn = !0, this.l = e, this.xt = s;
  }
  callSource(e) {
    const t = this.s.overrideContext;
    t.$event = e;
    let r = V(this.ast, this.s, this, null);
    return delete t.$event, kn(r) && (r = r(e)), r !== !0 && this.xt.prevent && e.preventDefault(), r;
  }
  handleEvent(e) {
    this.self && this.target !== e.composedPath()[0] || this.callSource(e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Er(this.ast, e, this), this.target.addEventListener(this.targetEvent, this, this.xt), this.isBound = !0;
  }
  unbind() {
    !this.isBound || (this.isBound = !1, sr(this.ast, this.s, this), this.s = void 0, this.target.removeEventListener(this.targetEvent, this, this.xt));
  }
}
go(Zc);
ba(Zc, () => "callSource");
Zr(!0, !0)(Zc);
const pT = ke("IAppTask");
class ly {
  constructor(e, t, r) {
    this.c = void 0, this.slot = e, this.k = t, this.cb = r;
  }
  register(e) {
    return this.c = e.register(V4(pT, this));
  }
  run() {
    const e = this.k, t = this.cb;
    return e === null ? t() : t(this.c.get(e));
  }
}
Qn({
  creating: Us("creating"),
  hydrating: Us("hydrating"),
  hydrated: Us("hydrated"),
  activating: Us("activating"),
  activated: Us("activated"),
  deactivating: Us("deactivating"),
  deactivated: Us("deactivated")
});
function Us(n) {
  function e(t, r) {
    return kn(r) ? new ly(n, t, r) : new ly(n, null, t);
  }
  return e;
}
const mT = Ne, xl = yn("watch"), vh = Qn({
  name: xl,
  add(n, e) {
    let t = mn(xl, n);
    t == null && Tt(xl, t = [], n), t.push(e);
  },
  getAnnotation(n) {
    return mn(xl, n) ?? mT;
  }
});
function ov(n) {
  return function(e) {
    return G0(n, e);
  };
}
function dr(n) {
  return function(e) {
    return G0(bt(n) ? {
      isTemplateController: !0,
      name: n
    } : {
      isTemplateController: !0,
      ...n
    }, e);
  };
}
class V0 {
  constructor(e, t, r, i, s, a, o, c, l, f) {
    this.Type = e, this.name = t, this.aliases = r, this.key = i, this.defaultBindingMode = s, this.isTemplateController = a, this.bindables = o, this.noMultiBindings = c, this.watches = l, this.dependencies = f;
  }
  get type() {
    return 2;
  }
  static create(e, t) {
    let r, i;
    return bt(e) ? (r = e, i = {
      name: r
    }) : (r = e.name, i = e), new V0(t, on(Qi(t, "name"), r), kt(Qi(t, "aliases"), i.aliases, t.aliases), j0(r), on(Qi(t, "defaultBindingMode"), i.defaultBindingMode, t.defaultBindingMode, 2), on(Qi(t, "isTemplateController"), i.isTemplateController, t.isTemplateController, !1), di.from(t, ...di.getAll(t), Qi(t, "bindables"), t.bindables, i.bindables), on(Qi(t, "noMultiBindings"), i.noMultiBindings, t.noMultiBindings, !1), kt(vh.getAnnotation(t), t.watches), kt(Qi(t, "dependencies"), i.dependencies, t.dependencies));
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    ev(r, t).register(e), zc(r, t).register(e), Kc(i, W0, r, e);
  }
}
const Js = ya("custom-attribute"), j0 = (n) => `${Js}:${n}`, Qi = (n, e) => mn(yn(e), n), yT = (n) => kn(n) && Wc(Js, n), cv = (n, e) => Wo(n, j0(e)) ?? void 0, G0 = (n, e) => {
  const t = V0.create(n, e);
  return Tt(Js, t, t.Type), Tt(Js, t, t), gs(e, Js), t.Type;
}, wh = (n) => {
  const e = mn(Js, n);
  if (e === void 0)
    throw ne(`AUR0759:${n.name}`);
  return e;
}, W0 = Qn({
  name: Js,
  keyFrom: j0,
  isType: yT,
  for: cv,
  define: G0,
  getDefinition: wh,
  annotate(n, e, t) {
    Tt(yn(e), t, n);
  },
  getAnnotation: Qi
});
function gT(n) {
  return n.startsWith(Go);
}
const Go = yn("children-observer"), Oo = Qn({
  name: Go,
  keyFrom: (n) => `${Go}:${n}`,
  from(...n) {
    const e = {};
    function t(s) {
      e[s] = nc.create(s);
    }
    function r(s, a) {
      e[s] = nc.create(s, a);
    }
    function i(s) {
      _r(s) ? s.forEach(t) : s instanceof nc ? e[s.property] = s : s !== void 0 && B0(s).forEach((a) => r(a, s));
    }
    return n.forEach(i), e;
  },
  getAll(n) {
    const e = Go.length + 1, t = [], r = i1(n);
    let i = r.length, s = 0, a, o, c;
    for (; --i >= 0; ) {
      c = r[i], a = X1(c).filter(gT), o = a.length;
      for (let l = 0; l < o; ++l)
        t[s++] = mn(Go, c, a[l].slice(e));
    }
    return t;
  }
}), bT = {
  childList: !0
};
class nc {
  constructor(e, t, r, i, s, a) {
    this.callback = e, this.property = t, this.options = r, this.query = i, this.filter = s, this.map = a;
  }
  static create(e, t = {}) {
    return new nc(on(t.callback, `${e}Changed`), on(t.property, e), t.options ?? bT, t.query, t.filter, t.map);
  }
}
class lv {
  constructor(e, t, r, i, s = xT, a = vT, o = wT, c) {
    this.controller = e, this.obj = t, this.propertyKey = r, this.query = s, this.filter = a, this.map = o, this.options = c, this.observing = !1, this.children = void 0, this.observer = void 0, this.callback = t[i], Reflect.defineProperty(this.obj, this.propertyKey, {
      enumerable: !0,
      configurable: !0,
      get: () => this.getValue(),
      set: () => {
      }
    });
  }
  getValue() {
    return this.observing ? this.children : this.get();
  }
  setValue(e) {
  }
  start() {
    this.observing || (this.observing = !0, this.children = this.get(), (this.observer ?? (this.observer = new this.controller.host.ownerDocument.defaultView.MutationObserver(() => {
      this.wt();
    }))).observe(this.controller.host, this.options));
  }
  stop() {
    this.observing && (this.observing = !1, this.observer.disconnect(), this.children = Ne);
  }
  wt() {
    this.children = this.get(), this.callback !== void 0 && this.callback.call(this.obj), this.subs.notify(this.children, void 0);
  }
  get() {
    return TT(this.controller, this.query, this.filter, this.map);
  }
}
An()(lv);
function xT(n) {
  return n.host.childNodes;
}
function vT(n, e, t) {
  return !!t;
}
function wT(n, e, t) {
  return t;
}
const AT = {
  optional: !0
};
function TT(n, e, t, r) {
  const i = e(n), s = i.length, a = [];
  let o, c, l, f = 0;
  for (; f < s; ++f)
    o = i[f], c = as(o, AT), l = c?.viewModel ?? null, t(o, c, l) && a.push(r(o, c, l));
  return a;
}
const Tn = Vc, uy = (n, e, t, r) => {
  n.addEventListener(e, t, r);
}, dy = (n, e, t, r) => {
  n.removeEventListener(e, t, r);
}, H0 = (n) => {
  const e = n.prototype;
  Tr(e, "subscribe", function(t) {
    if (this.subs.add(t) && this.subs.count === 1) {
      for (Hi of this.cf.events)
        uy(this.bt, Hi, this);
      this.yt = !0, this.kt?.();
    }
  }), Tr(e, "unsubscribe", function(t) {
    if (this.subs.remove(t) && this.subs.count === 0) {
      for (Hi of this.cf.events)
        dy(this.bt, Hi, this);
      this.yt = !1, this.At?.();
    }
  }), Tr(e, "useConfig", function(t) {
    if (this.cf = t, this.yt) {
      for (Hi of this.cf.events)
        dy(this.bt, Hi, this);
      for (Hi of this.cf.events)
        uy(this.bt, Hi, this);
    }
  });
};
let Hi;
const pd = (n) => {
  Tr(n.prototype, "subscribe", bi), Tr(n.prototype, "unsubscribe", bi);
};
class uv {
  constructor(e) {
    this.obj = e, this.type = 6, this.value = "", this.ov = "", this.Ct = {}, this.Bt = 0, this.J = !1;
  }
  get doNotCache() {
    return !0;
  }
  getValue() {
    return this.value;
  }
  setValue(e) {
    this.value = e, this.J = e !== this.ov, this.it();
  }
  it() {
    if (this.J) {
      this.J = !1;
      const e = this.value, t = this.Ct, r = dv(e);
      let i = this.Bt;
      if (this.ov = e, r.length > 0 && this.Rt(r), this.Bt += 1, i === 0)
        return;
      i -= 1;
      for (const s in t)
        !ss.call(t, s) || t[s] !== i || this.obj.classList.remove(s);
    }
  }
  Rt(e) {
    const t = this.obj, r = e.length;
    let i = 0, s;
    for (; i < r; i++)
      s = e[i], s.length !== 0 && (this.Ct[s] = this.Bt, t.classList.add(s));
  }
}
function dv(n) {
  if (bt(n))
    return fy(n);
  if (typeof n != "object")
    return Ne;
  if (n instanceof Array) {
    const r = n.length;
    if (r > 0) {
      const i = [];
      let s = 0;
      for (; r > s; ++s)
        i.push(...dv(n[s]));
      return i;
    } else
      return Ne;
  }
  const e = [];
  let t;
  for (t in n)
    Boolean(n[t]) && (t.includes(" ") ? e.push(...fy(t)) : e.push(t));
  return e;
}
function fy(n) {
  const e = n.match(/\S+/g);
  return e === null ? Ne : e;
}
pd(uv);
ke("IShadowDOMStyleFactory", (n) => n.cachedCallback((e) => pv.supported(e.get(Tn)) ? e.get(fv) : e.get(hv)));
class fv {
  constructor(e) {
    this.p = e, this.cache = /* @__PURE__ */ new Map();
  }
  createStyles(e, t) {
    return new pv(this.p, e, this.cache, t);
  }
}
fv.inject = [Tn];
class hv {
  constructor(e) {
    this.p = e;
  }
  createStyles(e, t) {
    return new ET(this.p, e, t);
  }
}
hv.inject = [Tn];
const hy = ke("IShadowDOMStyles"), CT = ke("IShadowDOMGlobalStyles", (n) => n.instance({
  applyTo: bi
}));
class pv {
  constructor(e, t, r, i = null) {
    this.sharedStyles = i, this.styleSheets = t.map((s) => {
      let a;
      return s instanceof e.CSSStyleSheet ? a = s : (a = r.get(s), a === void 0 && (a = new e.CSSStyleSheet(), a.replaceSync(s), r.set(s, a))), a;
    });
  }
  static supported(e) {
    return "adoptedStyleSheets" in e.ShadowRoot.prototype;
  }
  applyTo(e) {
    this.sharedStyles !== null && this.sharedStyles.applyTo(e), e.adoptedStyleSheets = [...e.adoptedStyleSheets, ...this.styleSheets];
  }
}
class ET {
  constructor(e, t, r = null) {
    this.p = e, this.localStyles = t, this.sharedStyles = r;
  }
  applyTo(e) {
    const t = this.localStyles, r = this.p;
    for (let i = t.length - 1; i > -1; --i) {
      const s = r.document.createElement("style");
      s.innerHTML = t[i], e.prepend(s);
    }
    this.sharedStyles !== null && this.sharedStyles.applyTo(e);
  }
}
const { enter: ST, exit: _T } = HA, { wrap: PT, unwrap: MT } = S4;
class mv {
  constructor(e, t, r, i, s) {
    this.obj = e, this.$get = r, this.useProxy = s, this.isBound = !1, this.running = !1, this.v = void 0, this.cb = i, this.oL = t;
  }
  get value() {
    return this.v;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  bind() {
    this.isBound || (this.compute(), this.isBound = !0);
  }
  unbind() {
    !this.isBound || (this.isBound = !1, this.obs.clearAll());
  }
  run() {
    if (!this.isBound || this.running)
      return;
    const e = this.obj, t = this.v, r = this.compute();
    Hc(r, t) || this.cb.call(e, r, t, e);
  }
  compute() {
    this.running = !0, this.obs.version++;
    try {
      return ST(this), this.v = MT(this.$get.call(void 0, this.useProxy ? PT(this.obj) : this.obj, this));
    } finally {
      this.obs.clear(), this.running = !1, _T(this);
    }
  }
}
class z0 {
  constructor(e, t, r, i, s) {
    this.scope = e, this.l = t, this.oL = r, this.isBound = !1, this.boundFn = !1, this.obj = e.bindingContext, this.St = i, this.cb = s;
  }
  get value() {
    return this.v;
  }
  handleChange(e) {
    const t = this.St, r = this.obj, i = this.v;
    t.$kind === 1 && this.obs.count === 1 || (this.obs.version++, e = V(t, this.scope, this, this), this.obs.clear()), Hc(e, i) || (this.v = e, this.cb.call(r, e, i, r));
  }
  bind() {
    this.isBound || (this.obs.version++, this.v = V(this.St, this.scope, this, this), this.obs.clear(), this.isBound = !0);
  }
  unbind() {
    !this.isBound || (this.isBound = !1, this.obs.clearAll(), this.v = void 0);
  }
}
Rr(mv);
Rr(z0);
Zr(!0)(z0);
const Ia = ke("ILifecycleHooks");
class RT {
  constructor(e, t) {
    this.definition = e, this.instance = t;
  }
}
class K0 {
  constructor(e, t) {
    this.Type = e, this.propertyNames = t;
  }
  static create(e, t) {
    const r = /* @__PURE__ */ new Set();
    let i = t.prototype;
    for (; i !== O0; ) {
      for (const s of N0(i))
        s !== "constructor" && r.add(s);
      i = Object.getPrototypeOf(i);
    }
    return new K0(t, r);
  }
  register(e) {
    ga(Ia, this.Type).register(e);
  }
}
const py = /* @__PURE__ */ new WeakMap(), vl = yn("lifecycle-hooks"), my = Qn({
  name: vl,
  define(n, e) {
    const t = K0.create(n, e);
    return Tt(vl, t, e), gs(e, vl), t.Type;
  },
  resolve(n) {
    let e = py.get(n);
    if (e === void 0) {
      py.set(n, e = new kT());
      const t = n.root, r = t.id === n.id ? n.getAll(Ia) : n.has(Ia, !1) ? t.getAll(Ia).concat(n.getAll(Ia)) : t.getAll(Ia);
      let i, s, a, o, c;
      for (i of r) {
        s = mn(vl, i.constructor), a = new RT(s, i);
        for (o of s.propertyNames)
          c = e[o], c === void 0 ? e[o] = [a] : c.push(a);
      }
    }
    return e;
  }
});
class kT {
}
const Jn = ke("IViewFactory");
class md {
  constructor(e, t) {
    this.isCaching = !1, this.Y = null, this.It = -1, this.name = t.name, this.container = e, this.def = t;
  }
  setCacheSize(e, t) {
    e && (e === "*" ? e = md.maxCacheSize : bt(e) && (e = parseInt(e, 10)), (this.It === -1 || !t) && (this.It = e)), this.It > 0 ? this.Y = [] : this.Y = null, this.isCaching = this.It > 0;
  }
  canReturnToCache(e) {
    return this.Y != null && this.Y.length < this.It;
  }
  tryReturnToCache(e) {
    return this.canReturnToCache(e) ? (this.Y.push(e), !0) : !1;
  }
  create(e) {
    const t = this.Y;
    let r;
    return t != null && t.length > 0 ? (r = t.pop(), r) : (r = ir.$view(this, e), r);
  }
}
md.maxCacheSize = 65535;
const xa = ke("IRendering", (n) => n.singleton(yv));
class yv {
  constructor(e) {
    this.Tt = /* @__PURE__ */ new WeakMap(), this.Pt = /* @__PURE__ */ new WeakMap();
    const t = e.root;
    this.p = (this.Et = t).get(Tn), this.ep = t.get(v0), this.oL = t.get(ma), this.Lt = new xf(this.p, this.p.document.createDocumentFragment());
  }
  get renderers() {
    return this.Dt ?? (this.Dt = this.Et.getAll(Sv, !1).reduce((e, t) => (e[t.target] = t, e), sn()));
  }
  compile(e, t, r) {
    if (e.needsCompile !== !1) {
      const i = this.Tt, s = t.get(Ev);
      let a = i.get(e);
      return a == null ? i.set(e, a = s.compile(e, t, r)) : t.register(...a.dependencies), a;
    }
    return e;
  }
  getViewFactory(e, t) {
    return new md(t, Fr.getOrCreate(e));
  }
  createNodes(e) {
    if (e.enhance === !0)
      return new xf(this.p, e.template);
    let t;
    const r = this.Pt;
    if (r.has(e))
      t = r.get(e);
    else {
      const i = this.p, s = i.document, a = e.template;
      let o;
      a === null ? t = null : a instanceof i.Node ? a.nodeName === "TEMPLATE" ? t = s.adoptNode(a.content) : (t = s.adoptNode(s.createDocumentFragment())).appendChild(a.cloneNode(!0)) : (o = s.createElement("template"), bt(a) && (o.innerHTML = a), s.adoptNode(t = o.content)), r.set(e, t);
    }
    return t == null ? this.Lt : new xf(this.p, t.cloneNode(!0));
  }
  render(e, t, r, i) {
    const s = r.instructions, a = this.renderers, o = t.length;
    if (t.length !== s.length)
      throw ne(`AUR0757:${o}<>${s.length}`);
    let c = 0, l = 0, f = 0, p, g, T;
    if (o > 0)
      for (; o > c; ) {
        for (p = s[c], T = t[c], l = 0, f = p.length; f > l; )
          g = p[l], a[g.type].render(e, T, g, this.p, this.ep, this.oL), ++l;
        ++c;
      }
    if (i != null && (p = r.surrogates, (f = p.length) > 0))
      for (l = 0; f > l; )
        g = p[l], a[g.type].render(e, i, g, this.p, this.ep, this.oL), ++l;
  }
}
yv.inject = [lo];
var yy;
(function(n) {
  n[n.none = 0] = "none", n[n.fromBind = 1] = "fromBind", n[n.fromUnbind = 2] = "fromUnbind", n[n.dispose = 4] = "dispose";
})(yy || (yy = {}));
var gy;
(function(n) {
  n[n.none = 0] = "none", n[n.host = 1] = "host", n[n.shadowRoot = 2] = "shadowRoot", n[n.location = 3] = "location";
})(gy || (gy = {}));
const IT = {
  optional: !0
}, zi = /* @__PURE__ */ new WeakMap();
class ir {
  constructor(e, t, r, i, s, a, o) {
    this.container = e, this.vmKind = t, this.definition = r, this.viewFactory = i, this.host = a, this.head = null, this.tail = null, this.next = null, this.parent = null, this.bindings = null, this.children = null, this.hasLockedScope = !1, this.isStrictBinding = !1, this.scope = null, this.isBound = !1, this.hostController = null, this.mountTarget = 0, this.shadowRoot = null, this.nodes = null, this.location = null, this.Ut = null, this.state = 0, this.$t = !1, this._t = Ne, this.flags = 0, this.$initiator = null, this.$flags = 0, this.$resolve = void 0, this.$reject = void 0, this.$promise = void 0, this.qt = 0, this.Mt = 0, this.Ft = 0, this.Ot = s, this.Vt = t === 2 ? Ba.none : new Ba(s), this.location = o, this.r = e.root.get(xa);
  }
  get lifecycleHooks() {
    return this.Ut;
  }
  get isActive() {
    return (this.state & 3) > 0 && (4 & this.state) === 0;
  }
  get name() {
    if (this.parent === null)
      switch (this.vmKind) {
        case 1:
          return `[${this.definition.name}]`;
        case 0:
          return this.definition.name;
        case 2:
          return this.viewFactory.name;
      }
    switch (this.vmKind) {
      case 1:
        return `${this.parent.name}>[${this.definition.name}]`;
      case 0:
        return `${this.parent.name}>${this.definition.name}`;
      case 2:
        return this.viewFactory.name === this.parent.definition?.name ? `${this.parent.name}[view]` : `${this.parent.name}[view:${this.viewFactory.name}]`;
    }
  }
  get hooks() {
    return this.Vt;
  }
  get viewModel() {
    return this.Ot;
  }
  set viewModel(e) {
    this.Ot = e, this.Vt = e == null || this.vmKind === 2 ? Ba.none : new Ba(e);
  }
  static getCached(e) {
    return zi.get(e);
  }
  static getCachedOrThrow(e) {
    const t = ir.getCached(e);
    if (t === void 0)
      throw ne(`AUR0500:${e}`);
    return t;
  }
  static $el(e, t, r, i, s = void 0, a = null) {
    if (zi.has(t))
      return zi.get(t);
    s = s ?? Ch(t.constructor);
    const o = new ir(e, 0, s, null, t, r, a), c = e.get(d1(xu));
    return s.dependencies.length > 0 && e.register(...s.dependencies), At(e, xu, new un("IHydrationContext", new BT(o, i, c))), zi.set(t, o), (i == null || i.hydrate !== !1) && o.hE(i, c), o;
  }
  static $attr(e, t, r, i) {
    if (zi.has(t))
      return zi.get(t);
    i = i ?? wh(t.constructor);
    const s = new ir(e, 1, i, null, t, r, null);
    return i.dependencies.length > 0 && e.register(...i.dependencies), zi.set(t, s), s.Nt(), s;
  }
  static $view(e, t = void 0) {
    const r = new ir(e.container, 2, null, e, null, null, null);
    return r.parent = t ?? null, r.jt(), r;
  }
  hE(e, t) {
    const r = this.container, i = this.flags, s = this.Ot;
    let a = this.definition;
    if (this.scope = Yt.create(s, null, !0), a.watches.length > 0 && vy(this, r, a, s), by(this, a, i, s), this._t = OT(this, a, s), this.Vt.hasDefine) {
      const o = s.define(this, t, a);
      o !== void 0 && o !== a && (a = Fr.getOrCreate(o));
    }
    this.Ut = my.resolve(r), a.register(r), a.injectable !== null && At(r, a.injectable, new un("definition.injectable", s)), (e == null || e.hydrate !== !1) && (this.hS(e), this.hC());
  }
  hS(e) {
    this.Ut.hydrating !== void 0 && this.Ut.hydrating.forEach(LT, this), this.Vt.hasHydrating && this.Ot.hydrating(this);
    const t = this.Ht = this.r.compile(this.definition, this.container, e), { shadowOptions: r, isStrictBinding: i, hasSlots: s, containerless: a } = t;
    let o = this.location;
    if (this.isStrictBinding = i, (this.hostController = as(this.host, IT)) !== null && (this.host = this.container.root.get(Tn).document.createElement(this.definition.name), a && o == null && (o = this.location = q0(this.host))), bn(this.host, Ht, this), bn(this.host, this.definition.key, this), r !== null || s) {
      if (o != null)
        throw ne("AUR0501");
      bn(this.shadowRoot = this.host.attachShadow(r ?? NT), Ht, this), bn(this.shadowRoot, this.definition.key, this), this.mountTarget = 2;
    } else
      o != null ? (bn(o, Ht, this), bn(o, this.definition.key, this), this.mountTarget = 3) : this.mountTarget = 1;
    this.Ot.$controller = this, this.nodes = this.r.createNodes(t), this.Ut.hydrated !== void 0 && this.Ut.hydrated.forEach(FT, this), this.Vt.hasHydrated && this.Ot.hydrated(this);
  }
  hC() {
    this.r.render(this, this.nodes.findTargets(), this.Ht, this.host), this.Ut.created !== void 0 && this.Ut.created.forEach(Cy, this), this.Vt.hasCreated && this.Ot.created(this);
  }
  Nt() {
    const e = this.definition, t = this.Ot;
    e.watches.length > 0 && vy(this, this.container, e, t), by(this, e, this.flags, t), t.$controller = this, this.Ut = my.resolve(this.container), this.Ut.created !== void 0 && this.Ut.created.forEach(Cy, this), this.Vt.hasCreated && this.Ot.created(this);
  }
  jt() {
    this.Ht = this.r.compile(this.viewFactory.def, this.container, null), this.isStrictBinding = this.Ht.isStrictBinding, this.r.render(this, (this.nodes = this.r.createNodes(this.Ht)).findTargets(), this.Ht, void 0);
  }
  activate(e, t, r, i) {
    switch (this.state) {
      case 0:
      case 8:
        if (!(t === null || t.isActive))
          return;
        this.state = 1;
        break;
      case 2:
        return;
      case 32:
        throw ne(`AUR0502:${this.name}`);
      default:
        throw ne(`AUR0503:${this.name} ${Ty(this.state)}`);
    }
    switch (this.parent = t, r |= 1, this.vmKind) {
      case 0:
        this.scope.parent = i ?? null;
        break;
      case 1:
        this.scope = i ?? null;
        break;
      case 2:
        if (i == null)
          throw ne("AUR0504");
        this.hasLockedScope || (this.scope = i);
        break;
    }
    this.isStrictBinding, this.$initiator = e, this.$flags = r, this.Wt();
    let s;
    return this.vmKind !== 2 && this.Ut.binding != null && (s = jt(...this.Ut.binding.map(UT, this))), this.Vt.hasBinding && (s = jt(s, this.Ot.binding(this.$initiator, this.parent, this.$flags))), Qt(s) ? (this.zt(), s.then(() => {
      this.bind();
    }).catch((a) => {
      this.Gt(a);
    }), this.$promise) : (this.bind(), this.$promise);
  }
  bind() {
    let e = 0, t = this._t.length, r;
    if (t > 0)
      for (; t > e; )
        this._t[e].start(), ++e;
    if (this.bindings !== null)
      for (e = 0, t = this.bindings.length; t > e; )
        this.bindings[e].bind(this.scope), ++e;
    if (this.vmKind !== 2 && this.Ut.bound != null && (r = jt(...this.Ut.bound.map(VT, this))), this.Vt.hasBound && (r = jt(r, this.Ot.bound(this.$initiator, this.parent, this.$flags))), Qt(r)) {
      this.zt(), r.then(() => {
        this.isBound = !0, this.Xt();
      }).catch((i) => {
        this.Gt(i);
      });
      return;
    }
    this.isBound = !0, this.Xt();
  }
  Kt(...e) {
    switch (this.mountTarget) {
      case 1:
        this.host.append(...e);
        break;
      case 2:
        this.shadowRoot.append(...e);
        break;
      case 3: {
        let t = 0;
        for (; t < e.length; ++t)
          this.location.parentNode.insertBefore(e[t], this.location);
        break;
      }
    }
  }
  Xt() {
    if (this.hostController !== null)
      switch (this.mountTarget) {
        case 1:
        case 2:
          this.hostController.Kt(this.host);
          break;
        case 3:
          this.hostController.Kt(this.location.$start, this.location);
          break;
      }
    switch (this.mountTarget) {
      case 1:
        this.nodes.appendTo(this.host, this.definition != null && this.definition.enhance);
        break;
      case 2: {
        const r = this.container;
        (r.has(hy, !1) ? r.get(hy) : r.get(CT)).applyTo(this.shadowRoot), this.nodes.appendTo(this.shadowRoot);
        break;
      }
      case 3:
        this.nodes.insertBefore(this.location);
        break;
    }
    let e = 0, t;
    if (this.vmKind !== 2 && this.Ut.attaching != null && (t = jt(...this.Ut.attaching.map(jT, this))), this.Vt.hasAttaching && (t = jt(t, this.Ot.attaching(this.$initiator, this.parent, this.$flags))), Qt(t) && (this.zt(), this.Wt(), t.then(() => {
      this.Qt();
    }).catch((r) => {
      this.Gt(r);
    })), this.children !== null)
      for (; e < this.children.length; ++e)
        this.children[e].activate(this.$initiator, this, this.$flags, this.scope);
    this.Qt();
  }
  deactivate(e, t, r) {
    switch (-17 & this.state) {
      case 2:
        this.state = 4;
        break;
      case 0:
      case 8:
      case 32:
      case 40:
        return;
      default:
        throw ne(`AUR0505:${this.name} ${Ty(this.state)}`);
    }
    this.$initiator = e, this.$flags = r, e === this && this.Yt();
    let i = 0, s;
    if (this._t.length)
      for (; i < this._t.length; ++i)
        this._t[i].stop();
    if (this.children !== null)
      for (i = 0; i < this.children.length; ++i)
        this.children[i].deactivate(e, this, r);
    if (this.vmKind !== 2 && this.Ut.detaching != null && (s = jt(...this.Ut.detaching.map(WT, this))), this.Vt.hasDetaching && (s = jt(s, this.Ot.detaching(this.$initiator, this.parent, this.$flags))), Qt(s) && (this.zt(), e.Yt(), s.then(() => {
      e.Zt();
    }).catch((a) => {
      e.Gt(a);
    })), e.head === null ? e.head = this : e.tail.next = this, e.tail = this, e === this)
      return this.Zt(), this.$promise;
  }
  removeNodes() {
    switch (this.vmKind) {
      case 0:
      case 2:
        this.nodes.remove(), this.nodes.unlink();
    }
    if (this.hostController !== null)
      switch (this.mountTarget) {
        case 1:
        case 2:
          this.host.remove();
          break;
        case 3:
          this.location.$start.remove(), this.location.remove();
          break;
      }
  }
  unbind() {
    const e = 2 | this.$flags;
    let t = 0;
    if (this.bindings !== null)
      for (; t < this.bindings.length; ++t)
        this.bindings[t].unbind();
    switch (this.parent = null, this.vmKind) {
      case 1:
        this.scope = null;
        break;
      case 2:
        this.hasLockedScope || (this.scope = null), (16 & this.state) === 16 && !this.viewFactory.tryReturnToCache(this) && this.$initiator === this && this.dispose();
        break;
      case 0:
        this.scope.parent = null;
        break;
    }
    (4 & e) === 4 && this.$initiator === this && this.dispose(), this.state = 32 & this.state | 8, this.$initiator = null, this.Jt();
  }
  zt() {
    this.$promise === void 0 && (this.$promise = new Promise((e, t) => {
      this.$resolve = e, this.$reject = t;
    }), this.$initiator !== this && this.parent.zt());
  }
  Jt() {
    this.$promise !== void 0 && (gf = this.$resolve, this.$resolve = this.$reject = this.$promise = void 0, gf(), gf = void 0);
  }
  Gt(e) {
    this.$promise !== void 0 && (bf = this.$reject, this.$resolve = this.$reject = this.$promise = void 0, bf(e), bf = void 0), this.$initiator !== this && this.parent.Gt(e);
  }
  Wt() {
    ++this.qt, this.$initiator !== this && this.parent.Wt();
  }
  Qt() {
    if (--this.qt === 0) {
      if (this.vmKind !== 2 && this.Ut.attached != null && (Vs = jt(...this.Ut.attached.map(GT, this))), this.Vt.hasAttached && (Vs = jt(Vs, this.Ot.attached(this.$initiator, this.$flags))), Qt(Vs)) {
        this.zt(), Vs.then(() => {
          this.state = 2, this.Jt(), this.$initiator !== this && this.parent.Qt();
        }).catch((e) => {
          this.Gt(e);
        }), Vs = void 0;
        return;
      }
      Vs = void 0, this.state = 2, this.Jt();
    }
    this.$initiator !== this && this.parent.Qt();
  }
  Yt() {
    ++this.Mt;
  }
  Zt() {
    if (--this.Mt === 0) {
      this.te(), this.removeNodes();
      let e = this.$initiator.head, t;
      for (; e !== null; )
        e !== this && (e.debug && e.logger.trace("detach()"), e.removeNodes()), e.vmKind !== 2 && e.Ut.unbinding != null && (t = jt(...e.Ut.unbinding.map(HT, this))), e.Vt.hasUnbinding && (e.debug && e.logger.trace("unbinding()"), t = jt(t, e.viewModel.unbinding(e.$initiator, e.parent, e.$flags))), Qt(t) && (this.zt(), this.te(), t.then(() => {
          this.ee();
        }).catch((r) => {
          this.Gt(r);
        })), t = void 0, e = e.next;
      this.ee();
    }
  }
  te() {
    ++this.Ft;
  }
  ee() {
    if (--this.Ft === 0) {
      let e = this.$initiator.head, t = null;
      for (; e !== null; )
        e !== this && (e.isBound = !1, e.unbind()), t = e.next, e.next = null, e = t;
      this.head = this.tail = null, this.isBound = !1, this.unbind();
    }
  }
  addBinding(e) {
    this.bindings === null ? this.bindings = [e] : this.bindings[this.bindings.length] = e;
  }
  addChild(e) {
    this.children === null ? this.children = [e] : this.children[this.children.length] = e;
  }
  is(e) {
    switch (this.vmKind) {
      case 1:
        return wh(this.Ot.constructor).name === e;
      case 0:
        return Ch(this.Ot.constructor).name === e;
      case 2:
        return this.viewFactory.name === e;
    }
  }
  lockScope(e) {
    this.scope = e, this.hasLockedScope = !0;
  }
  setHost(e) {
    return this.vmKind === 0 && (bn(e, Ht, this), bn(e, this.definition.key, this)), this.host = e, this.mountTarget = 1, this;
  }
  setShadowRoot(e) {
    return this.vmKind === 0 && (bn(e, Ht, this), bn(e, this.definition.key, this)), this.shadowRoot = e, this.mountTarget = 2, this;
  }
  setLocation(e) {
    return this.vmKind === 0 && (bn(e, Ht, this), bn(e, this.definition.key, this)), this.location = e, this.mountTarget = 3, this;
  }
  release() {
    this.state |= 16;
  }
  dispose() {
    (32 & this.state) !== 32 && (this.state |= 32, this.Vt.hasDispose && this.Ot.dispose(), this.children !== null && (this.children.forEach($T), this.children = null), this.hostController = null, this.scope = null, this.nodes = null, this.location = null, this.viewFactory = null, this.Ot !== null && (zi.delete(this.Ot), this.Ot = null), this.Ot = null, this.host = null, this.shadowRoot = null, this.container.disposeResolvers());
  }
  accept(e) {
    if (e(this) === !0 || this.Vt.hasAccept && this.Ot.accept(e) === !0)
      return !0;
    if (this.children !== null) {
      const { children: t } = this;
      for (let r = 0, i = t.length; r < i; ++r)
        if (t[r].accept(e) === !0)
          return !0;
    }
  }
}
function gv(n) {
  let e = n.$observers;
  return e === void 0 && Reflect.defineProperty(n, "$observers", {
    enumerable: !1,
    value: e = {}
  }), e;
}
function by(n, e, t, r) {
  const i = e.bindables, s = N0(i), a = s.length;
  if (a > 0) {
    let o, c, l = 0;
    const f = gv(r), p = n.container, g = p.has(Tm, !0) ? p.get(Tm) : null;
    for (; l < a; ++l)
      o = s[l], f[o] === void 0 && (c = i[o], f[o] = new Z1(r, o, c.callback, c.set, n, g));
  }
}
function OT(n, e, t) {
  const r = e.childrenObservers, i = N0(r), s = i.length;
  if (s > 0) {
    const a = gv(t), o = [];
    let c, l = 0, f;
    for (; l < s; ++l)
      c = i[l], a[c] == null && (f = r[c], o[o.length] = a[c] = new lv(n, t, c, f.callback, f.query, f.filter, f.map, f.options));
    return o;
  }
  return Ne;
}
const xy = /* @__PURE__ */ new Map(), DT = (n) => {
  let e = xy.get(n);
  return e == null && (e = new Fl(n, 0), xy.set(n, e)), e;
};
function vy(n, e, t, r) {
  const i = e.get(ma), s = e.get(v0), a = t.watches, o = n.vmKind === 0 ? n.scope : Yt.create(r, null, !0), c = a.length;
  let l, f, p, g = 0;
  for (; c > g; ++g) {
    if ({ expression: l, callback: f } = a[g], f = kn(f) ? f : Reflect.get(r, f), !kn(f))
      throw ne(`AUR0506:${String(f)}`);
    kn(l) ? n.addBinding(new mv(r, i, l, f, !0)) : (p = bt(l) ? s.parse(l, 16) : DT(l), n.addBinding(new z0(o, e, i, p, f)));
  }
}
class Ba {
  constructor(e) {
    this.hasDefine = "define" in e, this.hasHydrating = "hydrating" in e, this.hasHydrated = "hydrated" in e, this.hasCreated = "created" in e, this.hasBinding = "binding" in e, this.hasBound = "bound" in e, this.hasAttaching = "attaching" in e, this.hasAttached = "attached" in e, this.hasDetaching = "detaching" in e, this.hasUnbinding = "unbinding" in e, this.hasDispose = "dispose" in e, this.hasAccept = "accept" in e;
  }
}
Ba.none = new Ba({});
const NT = {
  mode: "open"
};
var wy;
(function(n) {
  n[n.customElement = 0] = "customElement", n[n.customAttribute = 1] = "customAttribute", n[n.synthetic = 2] = "synthetic";
})(wy || (wy = {}));
var Ay;
(function(n) {
  n[n.none = 0] = "none", n[n.activating = 1] = "activating", n[n.activated = 2] = "activated", n[n.deactivating = 4] = "deactivating", n[n.deactivated = 8] = "deactivated", n[n.released = 16] = "released", n[n.disposed = 32] = "disposed";
})(Ay || (Ay = {}));
function Ty(n) {
  const e = [];
  return (1 & n) === 1 && e.push("activating"), (2 & n) === 2 && e.push("activated"), (4 & n) === 4 && e.push("deactivating"), (8 & n) === 8 && e.push("deactivated"), (16 & n) === 16 && e.push("released"), (32 & n) === 32 && e.push("disposed"), e.length === 0 ? "none" : e.join("|");
}
const yd = ke("IController"), xu = ke("IHydrationContext");
class BT {
  constructor(e, t, r) {
    this.instruction = t, this.parent = r, this.controller = e;
  }
}
function $T(n) {
  n.dispose();
}
function Cy(n) {
  n.instance.created(this.Ot, this);
}
function LT(n) {
  n.instance.hydrating(this.Ot, this);
}
function FT(n) {
  n.instance.hydrated(this.Ot, this);
}
function UT(n) {
  return n.instance.binding(this.Ot, this.$initiator, this.parent, this.$flags);
}
function VT(n) {
  return n.instance.bound(this.Ot, this.$initiator, this.parent, this.$flags);
}
function jT(n) {
  return n.instance.attaching(this.Ot, this.$initiator, this.parent, this.$flags);
}
function GT(n) {
  return n.instance.attached(this.Ot, this.$initiator, this.$flags);
}
function WT(n) {
  return n.instance.detaching(this.Ot, this.$initiator, this.parent, this.$flags);
}
function HT(n) {
  return n.instance.unbinding(this.Ot, this.$initiator, this.parent, this.$flags);
}
let gf, bf, Vs;
const Ey = ke("IAppRoot"), zT = "au-start", KT = "au-end", Sy = (n, e) => n.document.createComment(e), qT = (n) => {
  const e = Sy(n, KT);
  return e.$start = Sy(n, zT), e;
}, QT = (n, e) => n.document.createTextNode(e), JT = (n, e, t) => n.insertBefore(e, t), wl = (n, e, t) => {
  if (n === null)
    return;
  const r = t.length;
  let i = 0;
  for (; r > i; )
    n.insertBefore(t[i], e), ++i;
}, YT = (n) => {
  const e = n.previousSibling;
  let t;
  if (e?.nodeType === 8 && e.textContent === "au-end") {
    if (t = e, (t.$start = t.previousSibling) == null)
      throw _y();
    return n.parentNode?.removeChild(n), t;
  } else
    throw _y();
}, _y = () => ne("AURxxxx");
class XT {
}
function Wo(n, e) {
  return n.$au?.[e] ?? null;
}
function bn(n, e, t) {
  var r;
  ((r = n).$au ?? (r.$au = new XT()))[e] = t;
}
const Qa = ke("INode");
ke("IEventTarget", (n) => n.cachedCallback((e) => e.has(Ey, !0) ? e.get(Ey).host : e.get(Tn).document));
const wn = ke("IRenderLocation"), vu = /* @__PURE__ */ new WeakMap();
function Ah(n) {
  if (vu.has(n))
    return vu.get(n);
  let e = 0, t = n.nextSibling;
  for (; t !== null; ) {
    if (t.nodeType === 8)
      switch (t.textContent) {
        case "au-start":
          ++e;
          break;
        case "au-end":
          if (e-- === 0)
            return t;
      }
    t = t.nextSibling;
  }
  if (n.parentNode === null && n.nodeType === 11) {
    const r = as(n);
    if (r === void 0)
      return null;
    if (r.mountTarget === 2)
      return Ah(r.host);
  }
  return n.parentNode;
}
function ZT(n, e) {
  if (n.platform !== void 0 && !(n instanceof n.platform.Node)) {
    const t = n.childNodes;
    for (let r = 0, i = t.length; r < i; ++r)
      vu.set(t[r], e);
  } else
    vu.set(n, e);
}
function q0(n) {
  if (wu(n))
    return n;
  const e = n.ownerDocument.createComment("au-end"), t = e.$start = n.ownerDocument.createComment("au-start"), r = n.parentNode;
  return r !== null && (r.replaceChild(e, n), r.insertBefore(t, e)), e;
}
function wu(n) {
  return n.textContent === "au-end";
}
class xf {
  constructor(e, t) {
    this.platform = e, this.next = void 0, this.ne = !1, this.re = !1, this.ref = null, this.f = t;
    const r = t.querySelectorAll(".au");
    let i = 0, s = r.length, a, o = this.t = Array(s);
    for (; s > i; )
      a = r[i], a.nodeName === "AU-M" ? o[i] = YT(a) : o[i] = a, ++i;
    const c = t.childNodes, l = this.childNodes = Array(s = c.length);
    for (i = 0; s > i; )
      l[i] = c[i], ++i;
    this.oe = t.firstChild, this.le = t.lastChild;
  }
  get firstChild() {
    return this.oe;
  }
  get lastChild() {
    return this.le;
  }
  findTargets() {
    return this.t;
  }
  insertBefore(e) {
    if (this.re && !!this.ref)
      this.addToLinked();
    else {
      const t = e.parentNode;
      if (this.ne) {
        let r = this.oe, i;
        const s = this.le;
        for (; r != null && (i = r.nextSibling, t.insertBefore(r, e), r !== s); )
          r = i;
      } else
        this.ne = !0, e.parentNode.insertBefore(this.f, e);
    }
  }
  appendTo(e, t = !1) {
    if (this.ne) {
      let r = this.oe, i;
      const s = this.le;
      for (; r != null && (i = r.nextSibling, e.appendChild(r), r !== s); )
        r = i;
    } else
      this.ne = !0, t || e.appendChild(this.f);
  }
  remove() {
    if (this.ne) {
      this.ne = !1;
      const e = this.f, t = this.le;
      let r, i = this.oe;
      for (; i !== null && (r = i.nextSibling, e.appendChild(i), i !== t); )
        i = r;
    }
  }
  addToLinked() {
    const e = this.ref, t = e.parentNode;
    if (this.ne) {
      let r = this.oe, i;
      const s = this.le;
      for (; r != null && (i = r.nextSibling, t.insertBefore(r, e), r !== s); )
        r = i;
    } else
      this.ne = !0, t.insertBefore(this.f, e);
  }
  unlink() {
    this.re = !1, this.next = void 0, this.ref = void 0;
  }
  link(e) {
    this.re = !0, wu(e) ? this.ref = e : (this.next = e, this.he());
  }
  he() {
    this.next !== void 0 ? this.ref = this.next.firstChild : this.ref = void 0;
  }
}
const bv = ke("IWindow", (n) => n.callback((e) => e.get(Tn).window));
ke("ILocation", (n) => n.callback((e) => e.get(bv).location));
ke("IHistory", (n) => n.callback((e) => e.get(bv).history));
function xv(n) {
  return function(e) {
    return vv(n, e);
  };
}
const vf = /* @__PURE__ */ new WeakMap();
class Fr {
  constructor(e, t, r, i, s, a, o, c, l, f, p, g, T, v, w, C, _, I, B, N, D) {
    this.Type = e, this.name = t, this.aliases = r, this.key = i, this.cache = s, this.capture = a, this.template = o, this.instructions = c, this.dependencies = l, this.injectable = f, this.needsCompile = p, this.surrogates = g, this.bindables = T, this.childrenObservers = v, this.containerless = w, this.isStrictBinding = C, this.shadowOptions = _, this.hasSlots = I, this.enhance = B, this.watches = N, this.processContent = D;
  }
  get type() {
    return 1;
  }
  static create(e, t = null) {
    if (t === null) {
      const i = e;
      if (bt(i))
        throw ne(`AUR0761:${e}`);
      const s = Cn("name", i, Th);
      return kn(i.Type) ? t = i.Type : t = wv(M3(s)), new Fr(t, s, kt(i.aliases), Cn("key", i, () => Hl(s)), Cn("cache", i, wf), Cn("capture", i, gn), Cn("template", i, Zn), kt(i.instructions), kt(i.dependencies), Cn("injectable", i, Zn), Cn("needsCompile", i, Af), kt(i.surrogates), di.from(t, i.bindables), Oo.from(i.childrenObservers), Cn("containerless", i, gn), Cn("isStrictBinding", i, gn), Cn("shadowOptions", i, Zn), Cn("hasSlots", i, gn), Cn("enhance", i, gn), Cn("watches", i, t8), Xn("processContent", t, Zn));
    }
    if (bt(e))
      return new Fr(t, e, kt(Fn(t, "aliases"), t.aliases), Hl(e), Xn("cache", t, wf), Xn("capture", t, gn), Xn("template", t, Zn), kt(Fn(t, "instructions"), t.instructions), kt(Fn(t, "dependencies"), t.dependencies), Xn("injectable", t, Zn), Xn("needsCompile", t, Af), kt(Fn(t, "surrogates"), t.surrogates), di.from(t, ...di.getAll(t), Fn(t, "bindables"), t.bindables), Oo.from(...Oo.getAll(t), Fn(t, "childrenObservers"), t.childrenObservers), Xn("containerless", t, gn), Xn("isStrictBinding", t, gn), Xn("shadowOptions", t, Zn), Xn("hasSlots", t, gn), Xn("enhance", t, gn), kt(vh.getAnnotation(t), t.watches), Xn("processContent", t, Zn));
    const r = Cn("name", e, Th);
    return new Fr(t, r, kt(Fn(t, "aliases"), e.aliases, t.aliases), Hl(r), mr("cache", e, t, wf), mr("capture", e, t, gn), mr("template", e, t, Zn), kt(Fn(t, "instructions"), e.instructions, t.instructions), kt(Fn(t, "dependencies"), e.dependencies, t.dependencies), mr("injectable", e, t, Zn), mr("needsCompile", e, t, Af), kt(Fn(t, "surrogates"), e.surrogates, t.surrogates), di.from(t, ...di.getAll(t), Fn(t, "bindables"), t.bindables, e.bindables), Oo.from(...Oo.getAll(t), Fn(t, "childrenObservers"), t.childrenObservers, e.childrenObservers), mr("containerless", e, t, gn), mr("isStrictBinding", e, t, gn), mr("shadowOptions", e, t, Zn), mr("hasSlots", e, t, gn), mr("enhance", e, t, gn), kt(e.watches, vh.getAnnotation(t), t.watches), mr("processContent", e, t, Zn));
  }
  static getOrCreate(e) {
    if (e instanceof Fr)
      return e;
    if (vf.has(e))
      return vf.get(e);
    const t = Fr.create(e);
    return vf.set(e, t), Tt(Ht, t, t.Type), t;
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    e.has(r, !1) || (ev(r, t).register(e), zc(r, t).register(e), Kc(i, Ua, r, e));
  }
}
const e8 = {
  name: void 0,
  searchParents: !1,
  optional: !1
}, wf = () => 0, Zn = () => null, gn = () => !1, Af = () => !0, t8 = () => Ne, Ht = ya("custom-element"), Hl = (n) => `${Ht}:${n}`, Th = (() => {
  let n = 0;
  return () => `unnamed-${++n}`;
})(), n8 = (n, e, t) => {
  Tt(yn(e), t, n);
}, vv = (n, e) => {
  const t = Fr.create(n, e);
  return Tt(Ht, t, t.Type), Tt(Ht, t, t), gs(t.Type, Ht), t.Type;
}, r8 = (n) => kn(n) && Wc(Ht, n), as = (n, e = e8) => {
  if (e.name === void 0 && e.searchParents !== !0) {
    const r = Wo(n, Ht);
    if (r === null) {
      if (e.optional === !0)
        return null;
      throw ne("AUR0762");
    }
    return r;
  }
  if (e.name !== void 0) {
    if (e.searchParents !== !0) {
      const s = Wo(n, Ht);
      if (s === null)
        throw ne("AUR0763");
      return s.is(e.name) ? s : void 0;
    }
    let r = n, i = !1;
    for (; r !== null; ) {
      const s = Wo(r, Ht);
      if (s !== null && (i = !0, s.is(e.name)))
        return s;
      r = Ah(r);
    }
    if (i)
      return;
    throw ne("AUR0764");
  }
  let t = n;
  for (; t !== null; ) {
    const r = Wo(t, Ht);
    if (r !== null)
      return r;
    t = Ah(t);
  }
  throw ne("AUR0765");
}, Fn = (n, e) => mn(yn(e), n), Ch = (n) => {
  const e = mn(Ht, n);
  if (e === void 0)
    throw ne(`AUR0760:${n.name}`);
  return e;
}, i8 = () => {
  const n = function(e, t, r) {
    const i = pe.getOrCreateAnnotationParamTypes(e);
    return i[r] = n, e;
  };
  return n.register = function(e) {
    return {
      resolve(t, r) {
        return r.has(n, !0) ? r.get(n) : null;
      }
    };
  }, n;
}, wv = function() {
  const n = {
    value: "",
    writable: !1,
    enumerable: !1,
    configurable: !0
  }, e = {};
  return function(t, r = e) {
    const i = class {
    };
    return n.value = t, Reflect.defineProperty(i, "name", n), r !== e && D0(i.prototype, r), i;
  };
}(), Ua = Qn({
  name: Ht,
  keyFrom: Hl,
  isType: r8,
  for: as,
  define: vv,
  getDefinition: Ch,
  annotate: n8,
  getAnnotation: Fn,
  generateName: Th,
  createInjectable: i8,
  generateType: wv
});
yn("processContent");
ke("IProjections");
const Av = ke("IAuSlotsInfo");
class Tv {
  constructor(e) {
    this.projectedSlots = e;
  }
}
var Py;
(function(n) {
  n.hydrateElement = "ra", n.hydrateAttribute = "rb", n.hydrateTemplateController = "rc", n.hydrateLetElement = "rd", n.setProperty = "re", n.interpolation = "rf", n.propertyBinding = "rg", n.letBinding = "ri", n.refBinding = "rj", n.iteratorBinding = "rk", n.multiAttr = "rl", n.textBinding = "ha", n.listenerBinding = "hb", n.attributeBinding = "hc", n.stylePropertyBinding = "hd", n.setAttribute = "he", n.setClassAttribute = "hf", n.setStyleAttribute = "hg", n.spreadBinding = "hs", n.spreadElementProp = "hp";
})(Py || (Py = {}));
const bo = ke("Instruction");
class el {
  constructor(e, t, r) {
    this.from = e, this.to = t, this.mode = r, this.type = "rg";
  }
}
class s8 {
  constructor(e, t, r) {
    this.forOf = e, this.to = t, this.props = r, this.type = "rk";
  }
}
class a8 {
  constructor(e, t) {
    this.from = e, this.to = t, this.type = "rj";
  }
}
class o8 {
  constructor(e, t, r) {
    this.value = e, this.to = t, this.command = r, this.type = "rl";
  }
}
class Cv {
  constructor(e, t, r, i) {
    this.from = e, this.to = t, this.preventDefault = r, this.capture = i, this.type = "hb";
  }
}
class Q0 {
  constructor(e, t, r) {
    this.attr = e, this.from = t, this.to = r, this.type = "hc";
  }
}
class c8 {
  constructor() {
    this.type = "hs";
  }
}
const Ev = ke("ITemplateCompiler"), Sv = ke("IRenderer");
function Nt(n) {
  return function(t) {
    return t.register = function(r) {
      ga(Sv, this).register(r);
    }, $4(t.prototype, "target", {
      configurable: !0,
      get: function() {
        return n;
      }
    }), t;
  };
}
function Oi(n, e, t) {
  return bt(e) ? n.parse(e, t) : e;
}
function gd(n) {
  return n.viewModel != null ? n.viewModel : n;
}
function l8(n, e) {
  if (e === "element")
    return n;
  switch (e) {
    case "controller":
      return as(n);
    case "view":
      throw ne("AUR0750");
    case "view-model":
      return as(n).viewModel;
    default: {
      const t = cv(n, e);
      if (t !== void 0)
        return t.viewModel;
      const r = as(n, {
        name: e
      });
      if (r === void 0)
        throw ne(`AUR0751:${e}`);
      return r.viewModel;
    }
  }
}
let My = class {
  render(e, t, r) {
    const i = gd(t);
    i.$observers?.[r.to] !== void 0 ? i.$observers[r.to].setValue(r.value) : i[r.to] = r.value;
  }
};
My = Q([Nt("re")], My);
let Ry = class {
  constructor(e) {
    this.r = e;
  }
  static get inject() {
    return [xa];
  }
  render(e, t, r, i, s, a) {
    let o, c, l, f;
    const p = r.res, g = r.projections, T = e.container;
    switch (typeof p) {
      case "string":
        if (o = T.find(Ua, p), o == null)
          throw ne(`AUR0752:${p}@${e.name}`);
        break;
      default:
        o = p;
    }
    const w = r.containerless || o.containerless ? q0(t) : null, C = p8(i, e, t, r, w, g == null ? void 0 : new Tv(B0(g)));
    c = o.Type, l = C.invoke(c), At(C, c, new un(o.key, l)), f = ir.$el(C, l, t, r, o, w), bn(t, o.key, f);
    const _ = this.r.renderers, I = r.props, B = I.length;
    let N = 0, D;
    for (; B > N; )
      D = I[N], _[D.type].render(e, f, D, i, s, a), ++N;
    e.addChild(f);
  }
};
Ry = Q([Nt("ra")], Ry);
let ky = class {
  constructor(e) {
    this.r = e;
  }
  static get inject() {
    return [xa];
  }
  render(e, t, r, i, s, a) {
    let o = e.container, c;
    switch (typeof r.res) {
      case "string":
        if (c = o.find(W0, r.res), c == null)
          throw ne(`AUR0753:${r.res}@${e.name}`);
        break;
      default:
        c = r.res;
    }
    const l = Rv(i, c, e, t, r, void 0, void 0), f = ir.$attr(l.ctn, l.vm, t, c);
    bn(t, c.key, f);
    const p = this.r.renderers, g = r.props, T = g.length;
    let v = 0, w;
    for (; T > v; )
      w = g[v], p[w.type].render(e, f, w, i, s, a), ++v;
    e.addChild(f);
  }
};
ky = Q([Nt("rb")], ky);
let Iy = class {
  constructor(e, t) {
    this.r = e, this.p = t;
  }
  static get inject() {
    return [xa, Tn];
  }
  render(e, t, r, i, s, a) {
    let o = e.container, c;
    switch (typeof r.res) {
      case "string":
        if (c = o.find(W0, r.res), c == null)
          throw ne(`AUR0754:${r.res}@${e.name}`);
        break;
      default:
        c = r.res;
    }
    const l = this.r.getViewFactory(r.def, o), f = q0(t), p = Rv(this.p, c, e, t, r, l, f), g = ir.$attr(p.ctn, p.vm, t, c);
    bn(f, c.key, g), p.vm.link?.(e, g, t, r);
    const T = this.r.renderers, v = r.props, w = v.length;
    let C = 0, _;
    for (; w > C; )
      _ = v[C], T[_.type].render(e, g, _, i, s, a), ++C;
    e.addChild(g);
  }
};
Iy = Q([Nt("rc")], Iy);
let Oy = class {
  render(e, t, r, i, s, a) {
    t.remove();
    const o = r.instructions, c = r.toBindingContext, l = e.container, f = o.length;
    let p, g, T = 0;
    for (; f > T; )
      p = o[T], g = Oi(s, p.from, 16), e.addBinding(new Xc(l, a, g, p.to, c)), ++T;
  }
};
Oy = Q([Nt("rd")], Oy);
let Dy = class {
  render(e, t, r, i, s) {
    e.addBinding(new av(e.container, Oi(s, r.from, 16), l8(t, r.to)));
  }
};
Dy = Q([Nt("rj")], Dy);
let Ny = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new dT(e, e.container, a, i.domWriteQueue, Oi(s, r.from, 1), gd(t), r.to, 2));
  }
};
Ny = Q([Nt("rf")], Ny);
let By = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Ii(e, e.container, a, i.domWriteQueue, Oi(s, r.from, 16), gd(t), r.to, r.mode));
  }
};
By = Q([Nt("rg")], By);
let $y = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Ii(e, e.container, a, i.domWriteQueue, Oi(s, r.forOf, 2), gd(t), r.to, 2));
  }
};
$y = Q([Nt("rk")], $y);
let Ly = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Yc(e, e.container, a, i.domWriteQueue, i, Oi(s, r.from, 16), JT(t.parentNode, QT(i, ""), t), r.strict));
  }
};
Ly = Q([Nt("ha")], Ly);
let Fy = class {
  render(e, t, r, i, s) {
    e.addBinding(new Zc(e.container, Oi(s, r.from, 8), t, r.to, new hT(r.preventDefault, r.capture)));
  }
};
Fy = Q([Nt("hb")], Fy);
let Uy = class {
  render(e, t, r) {
    t.setAttribute(r.to, r.value);
  }
};
Uy = Q([Nt("he")], Uy);
let Vy = class {
  render(e, t, r) {
    d8(t.classList, r.value);
  }
};
Vy = Q([Nt("hf")], Vy);
let jy = class {
  render(e, t, r) {
    t.style.cssText += r.value;
  }
};
jy = Q([Nt("hg")], jy);
let Gy = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Ii(e, e.container, a, i.domWriteQueue, Oi(s, r.from, 16), t.style, r.to, 2));
  }
};
Gy = Q([Nt("hd")], Gy);
let Wy = class {
  render(e, t, r, i, s, a) {
    e.addBinding(new Qc(e, e.container, a, i.domWriteQueue, Oi(s, r.from, 16), t, r.attr, r.to, 2));
  }
};
Wy = Q([Nt("hc")], Wy);
let Hy = class {
  constructor(e, t) {
    this.ae = e, this.r = t;
  }
  static get inject() {
    return [Ev, xa];
  }
  render(e, t, r, i, s, a) {
    const c = e.container.get(xu), l = this.r.renderers, f = (g) => {
      let T = g, v = c;
      for (; v != null && T > 0; )
        v = v.parent, --T;
      if (v == null)
        throw ne("No scope context for spread binding.");
      return v;
    }, p = (g) => {
      const T = f(g), v = f8(T), w = this.ae.compileSpread(T.controller.definition, T.instruction?.captures ?? Ne, T.controller.container, t);
      let C;
      for (C of w)
        switch (C.type) {
          case "hs":
            p(g + 1);
            break;
          case "hp":
            l[C.instructions.type].render(v, as(t), C.instructions, i, s, a);
            break;
          default:
            l[C.type].render(v, t, C, i, s, a);
        }
      e.addBinding(v);
    };
    p(0);
  }
};
Hy = Q([Nt("hs")], Hy);
class u8 {
  constructor(e, t) {
    this.ce = e, this.ue = t, this.isBound = !1, this.ctrl = t.controller, this.locator = this.ctrl.container;
  }
  get container() {
    return this.locator;
  }
  get definition() {
    return this.ctrl.definition;
  }
  get isStrictBinding() {
    return this.ctrl.isStrictBinding;
  }
  get state() {
    return this.ctrl.state;
  }
  get(e) {
    return this.locator.get(e);
  }
  bind(e) {
    if (this.isBound)
      return;
    this.isBound = !0;
    const t = this.scope = this.ue.controller.scope.parent ?? void 0;
    if (t == null)
      throw ne("Invalid spreading. Context scope is null/undefined");
    this.ce.forEach((r) => r.bind(t));
  }
  unbind() {
    this.ce.forEach((e) => e.unbind()), this.isBound = !1;
  }
  addBinding(e) {
    this.ce.push(e);
  }
  addChild(e) {
    if (e.vmKind !== 1)
      throw ne("Spread binding does not support spreading custom attributes/template controllers");
    this.ctrl.addChild(e);
  }
  limit() {
    throw ne("not implemented");
  }
  useScope() {
    throw ne("not implemented");
  }
}
function d8(n, e) {
  const t = e.length;
  let r = 0;
  for (let i = 0; i < t; ++i)
    e.charCodeAt(i) === 32 ? (i !== r && n.add(e.slice(r, i)), r = i + 1) : i + 1 === t && n.add(e.slice(r));
}
const f8 = (n) => new u8([], n), _v = "IController", Pv = "IInstruction", h8 = "IRenderLocation", J0 = "IAuSlotsInfo";
function p8(n, e, t, r, i, s) {
  const a = e.container.createChild();
  return At(a, n.HTMLElement, At(a, n.Element, At(a, Qa, new un("ElementResolver", t)))), At(a, yd, new un(_v, e)), At(a, bo, new un(Pv, r)), At(a, wn, i == null ? Iv : new kv(i)), At(a, Jn, Ov), At(a, Av, s == null ? Dv : new un(J0, s)), a;
}
class Mv {
  constructor(e) {
    this.f = e;
  }
  get $isResolver() {
    return !0;
  }
  resolve() {
    const e = this.f;
    if (e === null)
      throw ne("AUR7055");
    if (!bt(e.name) || e.name.length === 0)
      throw ne("AUR0756");
    return e;
  }
}
function Rv(n, e, t, r, i, s, a, o) {
  const c = t.container.createChild();
  return At(c, n.HTMLElement, At(c, n.Element, At(c, Qa, new un("ElementResolver", r)))), t = t instanceof ir ? t : t.ctrl, At(c, yd, new un(_v, t)), At(c, bo, new un(Pv, i)), At(c, wn, a == null ? Iv : new un(h8, a)), At(c, Jn, s == null ? Ov : new Mv(s)), At(c, Av, o == null ? Dv : new un(J0, o)), {
    vm: c.invoke(e.Type),
    ctn: c
  };
}
class kv {
  constructor(e) {
    this.l = e;
  }
  get name() {
    return "IRenderLocation";
  }
  get $isResolver() {
    return !0;
  }
  resolve() {
    return this.l;
  }
}
const Iv = new kv(null), Ov = new Mv(null), Dv = new un(J0, new Tv(Ne));
var zy;
(function(n) {
  n[n.None = 0] = "None", n[n.IgnoreAttr = 1] = "IgnoreAttr";
})(zy || (zy = {}));
function $n(n) {
  return function(e) {
    return Bv.define(n, e);
  };
}
class Y0 {
  constructor(e, t, r, i, s) {
    this.Type = e, this.name = t, this.aliases = r, this.key = i, this.type = s;
  }
  static create(e, t) {
    let r, i;
    return bt(e) ? (r = e, i = {
      name: r
    }) : (r = e.name, i = e), new Y0(t, on(zl(t, "name"), r), kt(zl(t, "aliases"), i.aliases, t.aliases), Nv(r), on(zl(t, "type"), i.type, t.type, null));
  }
  register(e) {
    const { Type: t, key: r, aliases: i } = this;
    ga(r, t).register(e), zc(r, t).register(e), Kc(i, Bv, r, e);
  }
}
const Ho = ya("binding-command"), Nv = (n) => `${Ho}:${n}`, zl = (n, e) => mn(yn(e), n), Bv = Qn({
  name: Ho,
  keyFrom: Nv,
  define(n, e) {
    const t = Y0.create(n, e);
    return Tt(Ho, t, t.Type), Tt(Ho, t, t), gs(e, Ho), t.Type;
  },
  getAnnotation: zl
});
let Ky = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    let s = e.attr.target, a = e.attr.rawValue;
    return e.bindable == null ? s = r.map(e.node, s) ?? Kn(s) : (a === "" && e.def.type === 1 && (a = Kn(s)), s = e.bindable.property), new el(t.parse(a, 16), s, 1);
  }
};
Ky = Q([$n("one-time")], Ky);
let qy = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    let s = e.attr.target, a = e.attr.rawValue;
    return e.bindable == null ? s = r.map(e.node, s) ?? Kn(s) : (a === "" && e.def.type === 1 && (a = Kn(s)), s = e.bindable.property), new el(t.parse(a, 16), s, 2);
  }
};
qy = Q([$n("to-view")], qy);
let Qy = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    const i = e.attr;
    let s = i.target, a = i.rawValue;
    return e.bindable == null ? s = r.map(e.node, s) ?? Kn(s) : (a === "" && e.def.type === 1 && (a = Kn(s)), s = e.bindable.property), new el(t.parse(a, 16), s, 4);
  }
};
Qy = Q([$n("from-view")], Qy);
let Jy = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    const i = e.attr;
    let s = i.target, a = i.rawValue;
    return e.bindable == null ? s = r.map(e.node, s) ?? Kn(s) : (a === "" && e.def.type === 1 && (a = Kn(s)), s = e.bindable.property), new el(t.parse(a, 16), s, 6);
  }
};
Jy = Q([$n("two-way")], Jy);
let Yy = class {
  get type() {
    return 0;
  }
  build(e, t, r) {
    const i = e.attr, s = e.bindable;
    let a, o, c = i.target, l = i.rawValue;
    return s == null ? (o = r.isTwoWay(e.node, c) ? 6 : 2, c = r.map(e.node, c) ?? Kn(c)) : (l === "" && e.def.type === 1 && (l = Kn(c)), a = e.def.defaultBindingMode, o = s.mode === 8 || s.mode == null ? a == null || a === 8 ? 2 : a : s.mode, c = s.property), new el(t.parse(l, 16), c, o);
  }
};
Yy = Q([$n("bind")], Yy);
let Xy = class {
  constructor(e) {
    this.fe = e;
  }
  get type() {
    return 0;
  }
  static get inject() {
    return [Y4];
  }
  build(e, t) {
    const r = e.bindable === null ? Kn(e.attr.target) : e.bindable.property, i = t.parse(e.attr.rawValue, 2);
    let s = Ne;
    if (i.semiIdx > -1) {
      const a = e.attr.rawValue.slice(i.semiIdx + 1), o = a.indexOf(":");
      if (o > -1) {
        const c = a.slice(0, o).trim(), l = a.slice(o + 1).trim(), f = this.fe.parse(c, l);
        s = [new o8(l, f.target, f.command)];
      }
    }
    return new s8(i, r, s);
  }
};
Xy = Q([$n("for")], Xy);
let Zy = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Cv(t.parse(e.attr.rawValue, 8), e.attr.target, !0, !1);
  }
};
Zy = Q([$n("trigger")], Zy);
let eg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Cv(t.parse(e.attr.rawValue, 8), e.attr.target, !1, !0);
  }
};
eg = Q([$n("capture")], eg);
let tg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Q0(e.attr.target, t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
tg = Q([$n("attr")], tg);
let ng = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Q0("style", t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
ng = Q([$n("style")], ng);
let rg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Q0("class", t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
rg = Q([$n("class")], rg);
let ig = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new a8(t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
ig = Q([$n("ref")], ig);
let sg = class {
  get type() {
    return 1;
  }
  build(e) {
    return new c8();
  }
};
sg = Q([$n("...$attrs")], sg);
const $v = ke("ISVGAnalyzer", (n) => n.singleton(m8));
class m8 {
  isStandardSvgAttribute(e, t) {
    return !1;
  }
}
ke("IAttrMapper", (n) => n.singleton(y8));
class y8 {
  constructor(e) {
    this.svg = e, this.fns = [], this.pe = sn(), this.ve = sn(), this.useMapping({
      LABEL: {
        for: "htmlFor"
      },
      IMG: {
        usemap: "useMap"
      },
      INPUT: {
        maxlength: "maxLength",
        minlength: "minLength",
        formaction: "formAction",
        formenctype: "formEncType",
        formmethod: "formMethod",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        inputmode: "inputMode"
      },
      TEXTAREA: {
        maxlength: "maxLength"
      },
      TD: {
        rowspan: "rowSpan",
        colspan: "colSpan"
      },
      TH: {
        rowspan: "rowSpan",
        colspan: "colSpan"
      }
    }), this.useGlobalMapping({
      accesskey: "accessKey",
      contenteditable: "contentEditable",
      tabindex: "tabIndex",
      textcontent: "textContent",
      innerhtml: "innerHTML",
      scrolltop: "scrollTop",
      scrollleft: "scrollLeft",
      readonly: "readOnly"
    });
  }
  static get inject() {
    return [$v];
  }
  useMapping(e) {
    var t;
    let r, i, s, a;
    for (s in e) {
      r = e[s], i = (t = this.pe)[s] ?? (t[s] = sn());
      for (a in r) {
        if (i[a] !== void 0)
          throw ag(a, s);
        i[a] = r[a];
      }
    }
  }
  useGlobalMapping(e) {
    const t = this.ve;
    for (const r in e) {
      if (t[r] !== void 0)
        throw ag(r, "*");
      t[r] = e[r];
    }
  }
  useTwoWay(e) {
    this.fns.push(e);
  }
  isTwoWay(e, t) {
    return g8(e, t) || this.fns.length > 0 && this.fns.some((r) => r(e, t));
  }
  map(e, t) {
    return this.pe[e.nodeName]?.[t] ?? this.ve[t] ?? (mh(e, t, this.svg) ? t : null);
  }
}
function g8(n, e) {
  switch (n.nodeName) {
    case "INPUT":
      switch (n.type) {
        case "checkbox":
        case "radio":
          return e === "checked";
        default:
          return e === "value" || e === "files" || e === "value-as-number" || e === "value-as-date";
      }
    case "TEXTAREA":
    case "SELECT":
      return e === "value";
    default:
      switch (e) {
        case "textcontent":
        case "innerhtml":
          return n.hasAttribute("contenteditable");
        case "scrolltop":
        case "scrollleft":
          return !0;
        default:
          return !1;
      }
  }
}
function ag(n, e) {
  return ne(`Attribute ${n} has been already registered for ${e === "*" ? "all elements" : `<${e}/>`}`);
}
ke("ITemplateElementFactory", (n) => n.singleton(Lv));
const og = {};
class Lv {
  constructor(e) {
    this.p = e, this.xe = Tf(this.p);
  }
  createTemplate(e) {
    if (bt(e)) {
      let t = og[e];
      if (t === void 0) {
        const r = this.xe;
        r.innerHTML = e;
        const i = r.content.firstElementChild;
        i == null || i.nodeName !== "TEMPLATE" || i.nextElementSibling != null ? (this.xe = Tf(this.p), t = r) : (r.content.removeChild(i), t = i), og[e] = t;
      }
      return t.cloneNode(!0);
    }
    if (e.nodeName !== "TEMPLATE") {
      const t = Tf(this.p);
      return t.content.appendChild(e), t;
    }
    return e.parentNode?.removeChild(e), e.cloneNode(!0);
  }
}
Lv.inject = [Tn];
const Tf = (n) => n.document.createElement("template");
D0(sn(), {
  id: !0,
  name: !0,
  "au-slot": !0,
  "as-element": !0
});
Qn(["property", "attribute", "mode"]);
const b8 = ke("ITemplateCompilerHooks"), cg = /* @__PURE__ */ new WeakMap(), Cf = ya("compiler-hooks");
Qn({
  name: Cf,
  define(n) {
    let e = cg.get(n);
    return e === void 0 && (cg.set(n, e = new x8(n)), Tt(Cf, e, n), gs(n, Cf)), n;
  }
});
class x8 {
  constructor(e) {
    this.Type = e;
  }
  get name() {
    return "";
  }
  register(e) {
    e.register(ga(b8, this.Type));
  }
}
const Ef = /* @__PURE__ */ new Map();
class bd {
  bind(e, t) {
    Ef.set(t, t.mode), t.mode = this.mode;
  }
  unbind(e, t) {
    t.mode = Ef.get(t), Ef.delete(t);
  }
}
class v8 extends bd {
  get mode() {
    return 1;
  }
}
class w8 extends bd {
  get mode() {
    return 2;
  }
}
class A8 extends bd {
  get mode() {
    return 4;
  }
}
class T8 extends bd {
  get mode() {
    return 6;
  }
}
Bn("oneTime")(v8);
Bn("toView")(w8);
Bn("fromView")(A8);
Bn("twoWay")(T8);
const Sf = /* @__PURE__ */ new WeakMap(), C8 = 200;
class Fv {
  constructor(e) {
    this.p = e;
  }
  bind(e, t, r) {
    r = Number(r);
    const i = {
      type: "debounce",
      delay: r > 0 ? r : C8,
      now: this.p.performanceNow,
      queue: this.p.taskQueue
    }, s = t.limit?.(i);
    s == null || Sf.set(t, s);
  }
  unbind(e, t) {
    Sf.get(t)?.dispose(), Sf.delete(t);
  }
}
Fv.inject = [Vc];
Bn("debounce")(Fv);
class Uv {
  constructor(e) {
    this.Ve = /* @__PURE__ */ new Map(), this.Ne = e;
  }
  bind(e, t, ...r) {
    if (!("handleChange" in t))
      throw ne("AUR0817");
    if (r.length === 0)
      throw ne("AUR0818");
    this.Ve.set(t, r);
    let i;
    for (i of r)
      this.Ne.addSignalListener(i, t);
  }
  unbind(e, t) {
    const r = this.Ve.get(t);
    this.Ve.delete(t);
    let i;
    for (i of r)
      this.Ne.removeSignalListener(i, t);
  }
}
Uv.inject = [R0];
Bn("signal")(Uv);
const _f = /* @__PURE__ */ new WeakMap(), E8 = 200;
class Vv {
  constructor(e) {
    this.je = e.performanceNow, this.ct = e.taskQueue;
  }
  bind(e, t, r) {
    r = Number(r);
    const i = {
      type: "throttle",
      delay: r > 0 ? r : E8,
      now: this.je,
      queue: this.ct
    }, s = t.limit?.(i);
    s == null || _f.set(t, s);
  }
  unbind(e, t) {
    _f.get(t)?.dispose(), _f.delete(t);
  }
}
Vv.inject = [Vc];
Bn("throttle")(Vv);
class jv {
  constructor() {
    this.type = 6;
  }
  getValue(e, t) {
    return e.getAttribute(t);
  }
  setValue(e, t, r) {
    e == null ? t.removeAttribute(r) : t.setAttribute(r, e);
  }
}
pd(jv);
const Kl = new jv();
class S8 {
  bind(e, t) {
    if (!(t instanceof Ii))
      throw ne("AURxxxx");
    t.useTargetObserver(Kl);
  }
}
Bn("attr")(S8);
class _8 {
  bind(e, t) {
    if (!(t instanceof Zc))
      throw ne("AUR0801");
    t.self = !0;
  }
  unbind(e, t) {
    t.self = !1;
  }
}
Bn("self")(_8);
const lg = sn();
class bc {
  constructor(e) {
    this.ns = e, this.type = 6;
  }
  static forNs(e) {
    return lg[e] ?? (lg[e] = new bc(e));
  }
  getValue(e, t) {
    return e.getAttributeNS(this.ns, t);
  }
  setValue(e, t, r) {
    e == null ? t.removeAttributeNS(this.ns, r) : t.setAttributeNS(this.ns, r, e);
  }
}
pd(bc);
function ug(n, e) {
  return n === e;
}
class X0 {
  constructor(e, t, r, i) {
    this.type = 7, this.v = void 0, this.ov = void 0, this.He = void 0, this.We = void 0, this.yt = !1, this.bt = e, this.oL = i, this.cf = r;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    const t = this.v;
    e !== t && (this.v = e, this.ov = t, this.ze(), this.Ge(), this.st());
  }
  handleCollectionChange() {
    this.Ge();
  }
  handleChange(e, t) {
    this.Ge();
  }
  Ge() {
    const e = this.v, t = this.bt, r = ss.call(t, "model") ? t.model : t.value, i = t.type === "radio", s = t.matcher !== void 0 ? t.matcher : ug;
    if (i)
      t.checked = !!s(e, r);
    else if (e === !0)
      t.checked = !0;
    else {
      let a = !1;
      if (_r(e))
        a = e.findIndex((o) => !!s(o, r)) !== -1;
      else if (e instanceof Set) {
        for (const o of e)
          if (s(o, r)) {
            a = !0;
            break;
          }
      } else if (e instanceof Map)
        for (const o of e) {
          const c = o[0], l = o[1];
          if (s(c, r) && l === !0) {
            a = !0;
            break;
          }
        }
      t.checked = a;
    }
  }
  handleEvent() {
    let e = this.ov = this.v;
    const t = this.bt, r = ss.call(t, "model") ? t.model : t.value, i = t.checked, s = t.matcher !== void 0 ? t.matcher : ug;
    if (t.type === "checkbox") {
      if (_r(e)) {
        const a = e.findIndex((o) => !!s(o, r));
        i && a === -1 ? e.push(r) : !i && a !== -1 && e.splice(a, 1);
        return;
      } else if (e instanceof Set) {
        const a = {};
        let o = a;
        for (const c of e)
          if (s(c, r) === !0) {
            o = c;
            break;
          }
        i && o === a ? e.add(r) : !i && o !== a && e.delete(o);
        return;
      } else if (e instanceof Map) {
        let a;
        for (const o of e) {
          const c = o[0];
          if (s(c, r) === !0) {
            a = c;
            break;
          }
        }
        e.set(a, i);
        return;
      }
      e = i;
    } else if (i)
      e = r;
    else
      return;
    this.v = e, this.st();
  }
  kt() {
    this.ze();
  }
  At() {
    this.He?.unsubscribe(this), this.We?.unsubscribe(this), this.He = this.We = void 0;
  }
  st() {
    dg = this.ov, this.ov = this.v, this.subs.notify(this.v, dg);
  }
  ze() {
    const e = this.bt;
    (this.We ?? (this.We = e.$observers?.model ?? e.$observers?.value))?.subscribe(this), this.He?.unsubscribe(this), this.He = void 0, e.type === "checkbox" && (this.He = k8(this.v, this.oL))?.subscribe(this);
  }
}
H0(X0);
An(X0);
let dg;
const P8 = {
  childList: !0,
  subtree: !0,
  characterData: !0
};
function fg(n, e) {
  return n === e;
}
class Z0 {
  constructor(e, t, r, i) {
    this.type = 7, this.v = void 0, this.ov = void 0, this.J = !1, this.Xe = void 0, this.Ke = void 0, this.iO = !1, this.yt = !1, this.bt = e, this.oL = i, this.cf = r;
  }
  getValue() {
    return this.iO ? this.v : this.bt.multiple ? M8(this.bt.options) : this.bt.value;
  }
  setValue(e) {
    this.ov = this.v, this.v = e, this.J = e !== this.ov, this.Qe(e instanceof Array ? e : null), this.it();
  }
  it() {
    this.J && (this.J = !1, this.syncOptions());
  }
  handleCollectionChange() {
    this.syncOptions();
  }
  syncOptions() {
    const e = this.v, t = this.bt, r = _r(e), i = t.matcher ?? fg, s = t.options;
    let a = s.length;
    for (; a-- > 0; ) {
      const o = s[a], c = ss.call(o, "model") ? o.model : o.value;
      if (r) {
        o.selected = e.findIndex((l) => !!i(c, l)) !== -1;
        continue;
      }
      o.selected = !!i(c, e);
    }
  }
  syncValue() {
    const e = this.bt, t = e.options, r = t.length, i = this.v;
    let s = 0;
    if (e.multiple) {
      if (!(i instanceof Array))
        return !0;
      let c;
      const l = e.matcher || fg, f = [];
      for (; s < r; )
        c = t[s], c.selected && f.push(ss.call(c, "model") ? c.model : c.value), ++s;
      let p;
      for (s = 0; s < i.length; )
        p = i[s], f.findIndex((g) => !!l(p, g)) === -1 ? i.splice(s, 1) : ++s;
      for (s = 0; s < f.length; )
        p = f[s], i.findIndex((g) => !!l(p, g)) === -1 && i.push(p), ++s;
      return !1;
    }
    let a = null, o;
    for (; s < r; ) {
      if (o = t[s], o.selected) {
        a = ss.call(o, "model") ? o.model : o.value;
        break;
      }
      ++s;
    }
    return this.ov = this.v, this.v = a, !0;
  }
  kt() {
    (this.Ke = new this.bt.ownerDocument.defaultView.MutationObserver(this.Ye.bind(this))).observe(this.bt, P8), this.Qe(this.v instanceof Array ? this.v : null), this.iO = !0;
  }
  At() {
    this.Ke.disconnect(), this.Xe?.unsubscribe(this), this.Ke = this.Xe = void 0, this.iO = !1;
  }
  Qe(e) {
    if (this.Xe?.unsubscribe(this), this.Xe = void 0, e != null) {
      if (!this.bt.multiple)
        throw ne("AUR0654");
      (this.Xe = this.oL.getArrayObserver(e)).subscribe(this);
    }
  }
  handleEvent() {
    this.syncValue() && this.st();
  }
  Ye(e) {
    this.syncOptions(), this.syncValue() && this.st();
  }
  st() {
    hg = this.ov, this.ov = this.v, this.subs.notify(this.v, hg);
  }
}
H0(Z0);
An(Z0);
function M8(n) {
  const e = [];
  if (n.length === 0)
    return e;
  const t = n.length;
  let r = 0, i;
  for (; t > r; )
    i = n[r], i.selected && (e[e.length] = ss.call(i, "model") ? i.model : i.value), ++r;
  return e;
}
let hg;
const R8 = "--";
class Gv {
  constructor(e) {
    this.obj = e, this.type = 6, this.v = "", this.ov = "", this.styles = {}, this.version = 0, this.J = !1;
  }
  getValue() {
    return this.obj.style.cssText;
  }
  setValue(e) {
    this.v = e, this.J = e !== this.ov, this.it();
  }
  Ze(e) {
    const t = [], r = /url\([^)]+$/;
    let i = 0, s = "", a, o, c, l;
    for (; i < e.length; ) {
      if (a = e.indexOf(";", i), a === -1 && (a = e.length), s += e.substring(i, a), i = a + 1, r.test(s)) {
        s += ";";
        continue;
      }
      o = s.indexOf(":"), c = s.substring(0, o).trim(), l = s.substring(o + 1).trim(), t.push([c, l]), s = "";
    }
    return t;
  }
  Je(e) {
    let t, r;
    const i = [];
    for (r in e)
      if (t = e[r], t != null) {
        if (bt(t)) {
          if (r.startsWith(R8)) {
            i.push([r, t]);
            continue;
          }
          i.push([r1(r), t]);
          continue;
        }
        i.push(...this.ti(t));
      }
    return i;
  }
  ei(e) {
    const t = e.length;
    if (t > 0) {
      const r = [];
      let i = 0;
      for (; t > i; ++i)
        r.push(...this.ti(e[i]));
      return r;
    }
    return Ne;
  }
  ti(e) {
    return bt(e) ? this.Ze(e) : e instanceof Array ? this.ei(e) : e instanceof Object ? this.Je(e) : Ne;
  }
  it() {
    if (this.J) {
      this.J = !1;
      const e = this.v, t = this.styles, r = this.ti(e);
      let i, s = this.version;
      this.ov = e;
      let a, o, c, l = 0;
      const f = r.length;
      for (; l < f; ++l)
        a = r[l], o = a[0], c = a[1], this.setProperty(o, c), t[o] = s;
      if (this.styles = t, this.version += 1, s === 0)
        return;
      s -= 1;
      for (i in t)
        !ss.call(t, i) || t[i] !== s || this.obj.style.removeProperty(i);
    }
  }
  setProperty(e, t) {
    let r = "";
    t != null && kn(t.indexOf) && t.includes("!important") && (r = "important", t = t.replace("!important", "")), this.obj.style.setProperty(e, t, r);
  }
  bind() {
    this.v = this.ov = this.obj.style.cssText;
  }
}
pd(Gv);
class ep {
  constructor(e, t, r) {
    this.type = 7, this.v = "", this.ov = "", this.J = !1, this.yt = !1, this.bt = e, this.k = t, this.cf = r;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    Hc(e, this.v) || (this.ov = this.v, this.v = e, this.J = !0, this.cf.readonly || this.it());
  }
  it() {
    this.J && (this.J = !1, this.bt[this.k] = this.v ?? this.cf.default, this.st());
  }
  handleEvent() {
    this.ov = this.v, this.v = this.bt[this.k], this.ov !== this.v && (this.J = !1, this.st());
  }
  kt() {
    this.v = this.ov = this.bt[this.k];
  }
  st() {
    pg = this.ov, this.ov = this.v, this.subs.notify(this.v, pg);
  }
}
H0(ep);
An(ep);
let pg;
const js = "http://www.w3.org/1999/xlink", mg = "http://www.w3.org/XML/1998/namespace", yg = "http://www.w3.org/2000/xmlns/", gg = D0(sn(), {
  "xlink:actuate": ["actuate", js],
  "xlink:arcrole": ["arcrole", js],
  "xlink:href": ["href", js],
  "xlink:role": ["role", js],
  "xlink:show": ["show", js],
  "xlink:title": ["title", js],
  "xlink:type": ["type", js],
  "xml:lang": ["lang", mg],
  "xml:space": ["space", mg],
  xmlns: ["xmlns", yg],
  "xmlns:xlink": ["xlink", yg]
}), Wv = new K1();
Wv.type = 6;
class xc {
  constructor(e, t, r, i) {
    this.locator = e, this.platform = t, this.dirtyChecker = r, this.svgAnalyzer = i, this.allowDirtyCheck = !0, this.ii = sn(), this.si = sn(), this.ni = sn(), this.ri = sn();
    const s = ["change", "input"], a = {
      events: s,
      default: ""
    };
    this.useConfig({
      INPUT: {
        value: a,
        valueAsNumber: {
          events: s,
          default: 0
        },
        checked: {
          type: X0,
          events: s
        },
        files: {
          events: s,
          readonly: !0
        }
      },
      SELECT: {
        value: {
          type: Z0,
          events: ["change"],
          default: ""
        }
      },
      TEXTAREA: {
        value: a
      }
    });
    const o = {
      events: ["change", "input", "blur", "keyup", "paste"],
      default: ""
    }, c = {
      events: ["scroll"],
      default: 0
    };
    this.useConfigGlobal({
      scrollTop: c,
      scrollLeft: c,
      textContent: o,
      innerHTML: o
    }), this.overrideAccessorGlobal("css", "style", "class"), this.overrideAccessor({
      INPUT: ["value", "checked", "model"],
      SELECT: ["value"],
      TEXTAREA: ["value"]
    });
  }
  static register(e) {
    zc(mu, xc).register(e), ga(mu, xc).register(e);
  }
  handles(e, t) {
    return e instanceof this.platform.Node;
  }
  useConfig(e, t, r) {
    const i = this.ii;
    let s;
    if (bt(e))
      s = i[e] ?? (i[e] = sn()), s[t] == null ? s[t] = r : Al(e, t);
    else
      for (const a in e) {
        s = i[a] ?? (i[a] = sn());
        const o = e[a];
        for (t in o)
          s[t] == null ? s[t] = o[t] : Al(a, t);
      }
  }
  useConfigGlobal(e, t) {
    const r = this.si;
    if (typeof e == "object")
      for (const i in e)
        r[i] == null ? r[i] = e[i] : Al("*", i);
    else
      r[e] == null ? r[e] = t : Al("*", e);
  }
  getAccessor(e, t, r) {
    if (t in this.ri || t in (this.ni[e.tagName] ?? f5))
      return this.getObserver(e, t, r);
    switch (t) {
      case "src":
      case "href":
      case "role":
      case "minLength":
      case "maxLength":
      case "placeholder":
      case "size":
      case "pattern":
      case "title":
        return Kl;
      default: {
        const i = gg[t];
        return i !== void 0 ? bc.forNs(i[1]) : mh(e, t, this.svgAnalyzer) ? Kl : Wv;
      }
    }
  }
  overrideAccessor(e, t) {
    var r, i;
    let s;
    if (bt(e))
      s = (r = this.ni)[e] ?? (r[e] = sn()), s[t] = !0;
    else
      for (const a in e)
        for (const o of e[a])
          s = (i = this.ni)[a] ?? (i[a] = sn()), s[o] = !0;
  }
  overrideAccessorGlobal(...e) {
    for (const t of e)
      this.ri[t] = !0;
  }
  getNodeObserverConfig(e, t) {
    return this.ii[e.tagName]?.[t] ?? this.si[t];
  }
  getNodeObserver(e, t, r) {
    const i = this.ii[e.tagName]?.[t] ?? this.si[t];
    let s;
    return i != null ? (s = new (i.type ?? ep)(e, t, i, r, this.locator), s.doNotCache || (Q1(e)[t] = s), s) : null;
  }
  getObserver(e, t, r) {
    switch (t) {
      case "class":
        return new uv(e);
      case "css":
      case "style":
        return new Gv(e);
    }
    const i = this.getNodeObserver(e, t, r);
    if (i != null)
      return i;
    const s = gg[t];
    if (s !== void 0)
      return bc.forNs(s[1]);
    if (mh(e, t, this.svgAnalyzer))
      return Kl;
    if (t in e.constructor.prototype) {
      if (this.allowDirtyCheck)
        return this.dirtyChecker.createProperty(e, t);
      throw ne(`AUR0652:${String(t)}`);
    } else
      return new M0(e, t);
  }
}
xc.inject = [t5, Tn, W1, $v];
function k8(n, e) {
  if (n instanceof Array)
    return e.getArrayObserver(n);
  if (n instanceof Map)
    return e.getMapObserver(n);
  if (n instanceof Set)
    return e.getSetObserver(n);
}
function Al(n, e) {
  throw ne(`AUR0653:${String(e)}@${n}`);
}
class Hv {
  constructor(e, t) {
    if (!(t instanceof xc))
      throw ne("AURxxxx: updateTrigger binding behavior only works with the default implementation of Aurelia HTML observation. Implement your own node observation + updateTrigger");
    this.oL = e, this.oi = t;
  }
  bind(e, t, ...r) {
    if (r.length === 0)
      throw ne("AUR0802");
    if (!(t instanceof Ii) || !(4 & t.mode))
      throw ne("AUR0803");
    const i = this.oi.getNodeObserverConfig(t.target, t.targetProperty);
    if (i == null)
      throw ne("AURxxxx");
    const s = this.oi.getNodeObserver(t.target, t.targetProperty, this.oL);
    s.useConfig({
      readonly: i.readonly,
      default: i.default,
      events: r
    }), t.useTargetObserver(s);
  }
}
Hv.inject = [ma, mu];
Bn("updateTrigger")(Hv);
class tp {
  constructor(e, t) {
    this.li = !1, this.hi = e, this.p = t;
  }
  binding() {
    this.valueChanged();
  }
  valueChanged() {
    this.$controller.isActive ? this.ai() : this.li = !0;
  }
  attached() {
    this.li && (this.li = !1, this.ai()), this.hi.addEventListener("focus", this), this.hi.addEventListener("blur", this);
  }
  afterDetachChildren() {
    const e = this.hi;
    e.removeEventListener("focus", this), e.removeEventListener("blur", this);
  }
  handleEvent(e) {
    e.type === "focus" ? this.value = !0 : this.ui || (this.value = !1);
  }
  ai() {
    const e = this.hi, t = this.ui, r = this.value;
    r && !t ? e.focus() : !r && t && e.blur();
  }
  get ui() {
    return this.hi === this.p.document.activeElement;
  }
}
tp.inject = [Qa, Tn];
Q([Be({
  mode: 6
})], tp.prototype, "value", void 0);
ov("focus")(tp);
let vc = class {
  constructor(e, t, r) {
    this.el = e, this.p = t, this.fi = !1, this.lt = null, this.$val = "", this.$prio = "", this.update = () => {
      this.lt = null, Boolean(this.value) !== this.di && (this.di === this.mi ? (this.di = !this.mi, this.$val = this.el.style.getPropertyValue("display"), this.$prio = this.el.style.getPropertyPriority("display"), this.el.style.setProperty("display", "none", "important")) : (this.di = this.mi, this.el.style.setProperty("display", this.$val, this.$prio), this.el.getAttribute("style") === "" && this.el.removeAttribute("style")));
    }, this.di = this.mi = r.alias !== "hide";
  }
  binding() {
    this.fi = !0, this.update();
  }
  detaching() {
    this.fi = !1, this.lt?.cancel(), this.lt = null;
  }
  valueChanged() {
    this.fi && this.lt === null && (this.lt = this.p.domWriteQueue.queueTask(this.update));
  }
};
Q([Be], vc.prototype, "value", void 0);
vc = Q([fn(0, Qa), fn(1, Tn), fn(2, bo)], vc);
j4("hide")(vc);
ov("show")(vc);
class kr {
  constructor(e, t, r) {
    this.position = "beforeend", this.strict = !1, this.p = r, this.gi = r.document.createElement("div"), (this.view = e.create()).setLocation(this.pi = qT(r)), ZT(this.view.nodes, t);
  }
  attaching(e, t, r) {
    this.callbackContext == null && (this.callbackContext = this.$controller.scope.bindingContext);
    const i = this.gi = this.vi();
    return this.xi(i, this.position), this.wi(e, i, r);
  }
  detaching(e, t, r) {
    return this.bi(e, this.gi, r);
  }
  targetChanged() {
    const { $controller: e } = this;
    if (!e.isActive)
      return;
    const t = this.vi();
    if (this.gi === t)
      return;
    this.gi = t;
    const r = Se(this.bi(null, t, e.flags), () => (this.xi(t, this.position), this.wi(null, t, e.flags)));
    Qt(r) && r.catch(yu);
  }
  positionChanged() {
    const { $controller: e, gi: t } = this;
    if (!e.isActive)
      return;
    const r = Se(this.bi(null, t, e.flags), () => (this.xi(t, this.position), this.wi(null, t, e.flags)));
    Qt(r) && r.catch(yu);
  }
  wi(e, t, r) {
    const { activating: i, callbackContext: s, view: a } = this;
    return Se(i?.call(s, t, a), () => this.yi(e, t, r));
  }
  yi(e, t, r) {
    const { $controller: i, view: s } = this;
    if (e === null)
      s.nodes.insertBefore(this.pi);
    else
      return Se(s.activate(e ?? s, i, r, i.scope), () => this.ki(t));
    return this.ki(t);
  }
  ki(e) {
    const { activated: t, callbackContext: r, view: i } = this;
    return t?.call(r, e, i);
  }
  bi(e, t, r) {
    const { deactivating: i, callbackContext: s, view: a } = this;
    return Se(i?.call(s, t, a), () => this.Ai(e, t, r));
  }
  Ai(e, t, r) {
    const { $controller: i, view: s } = this;
    if (e === null)
      s.nodes.remove();
    else
      return Se(s.deactivate(e, i, r), () => this.Ci(t));
    return this.Ci(t);
  }
  Ci(e) {
    const { deactivated: t, callbackContext: r, view: i } = this;
    return t?.call(r, e, i);
  }
  vi() {
    const e = this.p, t = e.document;
    let r = this.target, i = this.renderContext;
    if (r === "") {
      if (this.strict)
        throw ne("AUR0811");
      return t.body;
    }
    if (bt(r)) {
      let s = t;
      bt(i) && (i = t.querySelector(i)), i instanceof e.Node && (s = i), r = s.querySelector(r);
    }
    if (r instanceof e.Node)
      return r;
    if (r == null) {
      if (this.strict)
        throw ne("AUR0812");
      return t.body;
    }
    return r;
  }
  xi(e, t) {
    const r = this.pi, i = r.$start, s = e.parentNode, a = [i, r];
    switch (t) {
      case "beforeend":
        wl(e, null, a);
        break;
      case "afterbegin":
        wl(e, e.firstChild, a);
        break;
      case "beforebegin":
        wl(s, e, a);
        break;
      case "afterend":
        wl(s, e.nextSibling, a);
        break;
      default:
        throw new Error("Invalid portal insertion position");
    }
  }
  dispose() {
    this.view.dispose(), this.view = void 0, this.callbackContext = null;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
}
kr.inject = [Jn, wn, Tn];
Q([Be({
  primary: !0
})], kr.prototype, "target", void 0);
Q([Be()], kr.prototype, "position", void 0);
Q([Be({
  callback: "targetChanged"
})], kr.prototype, "renderContext", void 0);
Q([Be()], kr.prototype, "strict", void 0);
Q([Be()], kr.prototype, "deactivating", void 0);
Q([Be()], kr.prototype, "activating", void 0);
Q([Be()], kr.prototype, "deactivated", void 0);
Q([Be()], kr.prototype, "activated", void 0);
Q([Be()], kr.prototype, "callbackContext", void 0);
dr("portal")(kr);
class Ja {
  constructor(e, t) {
    this.elseFactory = void 0, this.elseView = void 0, this.ifView = void 0, this.view = void 0, this.value = !1, this.cache = !0, this.pending = void 0, this.Bi = !1, this.Ri = 0, this.Si = e, this.l = t;
  }
  attaching(e, t, r) {
    let i;
    const s = this.$controller, a = this.Ri++, o = () => !this.Bi && this.Ri === a + 1;
    return Se(this.pending, () => {
      !o() || (this.pending = void 0, this.value ? i = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this.Si.create() : i = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create(), i != null && (i.setLocation(this.l), this.pending = Se(i.activate(e, s, r, s.scope), () => {
        o() && (this.pending = void 0);
      })));
    });
  }
  detaching(e, t, r) {
    return this.Bi = !0, Se(this.pending, () => {
      this.Bi = !1, this.pending = void 0, this.view?.deactivate(e, this.$controller, r);
    });
  }
  valueChanged(e, t, r) {
    if (!this.$controller.isActive || (e = !!e, t = !!t, e === t))
      return;
    const i = this.view, s = this.$controller, a = this.Ri++, o = () => !this.Bi && this.Ri === a + 1;
    let c;
    return Se(this.pending, () => this.pending = Se(i?.deactivate(i, s, r), () => {
      if (!!o() && (e ? c = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this.Si.create() : c = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create(), c != null))
        return c.setLocation(this.l), Se(c.activate(c, s, r, s.scope), () => {
          o() && (this.pending = void 0);
        });
    }));
  }
  dispose() {
    this.ifView?.dispose(), this.elseView?.dispose(), this.ifView = this.elseView = this.view = void 0;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
}
Ja.inject = [Jn, wn];
Q([Be], Ja.prototype, "value", void 0);
Q([Be({
  set: (n) => n === "" || !!n && n !== "false"
})], Ja.prototype, "cache", void 0);
dr("if")(Ja);
class zv {
  constructor(e) {
    this.f = e;
  }
  link(e, t, r, i) {
    const s = e.children, a = s[s.length - 1];
    if (a instanceof Ja)
      a.elseFactory = this.f;
    else if (a.viewModel instanceof Ja)
      a.viewModel.elseFactory = this.f;
    else
      throw ne("AUR0810");
  }
}
zv.inject = [Jn];
dr({
  name: "else"
})(zv);
function I8(n) {
  n.dispose();
}
const O8 = [18, 17];
class np {
  constructor(e, t, r, i, s) {
    this.views = [], this.key = null, this.Ii = /* @__PURE__ */ new Map(), this.Ti = /* @__PURE__ */ new Map(), this.Pi = void 0, this.Ei = !1, this.Li = !1, this.Di = null, this.Ui = void 0, this.$i = !1;
    const a = e.props[0].props[0];
    if (a !== void 0) {
      const { to: o, value: c, command: l } = a;
      if (o === "key")
        if (l === null)
          this.key = c;
        else if (l === "bind")
          this.key = t.parse(c, 16);
        else
          throw ne(`AUR775:${l}`);
      else
        throw ne(`AUR776:${o}`);
    }
    this.l = r, this._i = i, this.f = s;
  }
  binding(e, t, r) {
    const i = this._i.bindings, s = i.length;
    let a, o, c = 0;
    for (; s > c; ++c)
      if (a = i[c], a.target === this && a.targetProperty === "items") {
        o = this.forOf = a.ast, this.qi = a;
        let f = o.iterable;
        for (; f != null && O8.includes(f.$kind); )
          f = f.expression, this.Ei = !0;
        this.Di = f;
        break;
      }
    this.Mi();
    const l = o.declaration;
    (this.$i = l.$kind === 24 || l.$kind === 25) || (this.local = V(l, this.$controller.scope, a, null));
  }
  attaching(e, t, r) {
    return this.Fi(), this.Oi(e);
  }
  detaching(e, t, r) {
    return this.Mi(), this.Vi(e);
  }
  unbinding(e, t, r) {
    this.Ti.clear(), this.Ii.clear();
  }
  itemsChanged() {
    !this.$controller.isActive || (this.Mi(), this.Fi(), this.Ni(this.items, void 0));
  }
  handleCollectionChange(e, t) {
    const r = this.$controller;
    if (!!r.isActive) {
      if (this.Ei) {
        if (this.Li)
          return;
        this.Li = !0, this.items = V(this.forOf.iterable, r.scope, this.qi, null), this.Li = !1;
        return;
      }
      this.Fi(), this.Ni(e, t);
    }
  }
  Ni(e, t) {
    const r = this.views, i = r.length, s = this.key, a = s !== null;
    if (a || t === void 0) {
      const o = this.local, c = this.Ui, l = c.length, f = this.forOf, p = f.declaration, g = this.qi, T = this.$i;
      t = Ys(l);
      let v = 0;
      if (i === 0)
        for (; v < l; ++v)
          t[v] = -2;
      else if (l === 0)
        if (T)
          for (v = 0; v < i; ++v)
            t.deletedIndices.push(v), t.deletedItems.push(V(p, r[v].scope, g, null));
        else
          for (v = 0; v < i; ++v)
            t.deletedIndices.push(v), t.deletedItems.push(r[v].scope.bindingContext[o]);
      else {
        const w = Array(i);
        if (T)
          for (v = 0; v < i; ++v)
            w[v] = V(p, r[v].scope, g, null);
        else
          for (v = 0; v < i; ++v)
            w[v] = r[v].scope.bindingContext[o];
        let C, _, I, B, N = 0;
        const D = i - 1, U = l - 1, W = /* @__PURE__ */ new Map(), j = /* @__PURE__ */ new Map(), q = this.Ii, ce = this.Ti, re = this.$controller.scope;
        v = 0;
        e: {
          for (; ; ) {
            if (C = w[v], _ = c[v], I = a ? Sa(q, s, C, Gs(ce, w[v], f, re, g, o, T), g) : C, B = a ? Sa(q, s, _, Gs(ce, c[v], f, re, g, o, T), g) : _, I !== B) {
              q.set(C, I), q.set(_, B);
              break;
            }
            if (++v, v > D || v > U)
              break e;
          }
          if (D !== U)
            break e;
          for (N = U; ; ) {
            if (C = w[N], _ = c[N], I = a ? Sa(q, s, C, Gs(ce, C, f, re, g, o, T), g) : C, B = a ? Sa(q, s, _, Gs(ce, _, f, re, g, o, T), g) : _, I !== B) {
              q.set(C, I), q.set(_, B);
              break;
            }
            if (--N, v > N)
              break e;
          }
        }
        const me = v, S = v;
        for (v = S; v <= U; ++v)
          q.has(_ = c[v]) ? B = q.get(_) : (B = a ? Sa(q, s, _, Gs(ce, _, f, re, g, o, T), g) : _, q.set(_, B)), j.set(B, v);
        for (v = me; v <= D; ++v)
          q.has(C = w[v]) ? I = q.get(C) : I = a ? Sa(q, s, C, r[v].scope, g) : C, W.set(I, v), j.has(I) ? t[j.get(I)] = v : (t.deletedIndices.push(v), t.deletedItems.push(C));
        for (v = S; v <= U; ++v)
          W.has(q.get(c[v])) || (t[v] = -2);
        W.clear(), j.clear();
      }
    }
    if (t === void 0) {
      const o = Se(this.Vi(null), () => this.Oi(null));
      Qt(o) && o.catch(yu);
    } else {
      const o = Z5(t);
      if (o.deletedIndices.length > 0) {
        const c = Se(this.ji(o), () => this.Hi(i, o));
        Qt(c) && c.catch(yu);
      } else
        this.Hi(i, o);
    }
  }
  Mi() {
    const e = this.$controller.scope;
    let t = this.Wi, r = this.Ei, i;
    r && (t = this.Wi = V(this.Di, e, this.qi, null) ?? null, r = this.Ei = !Hc(this.items, t));
    const s = this.Pi;
    this.$controller.isActive ? (i = this.Pi = I4(r ? t : this.items), s !== i && (s?.unsubscribe(this), i?.subscribe(this))) : (s?.unsubscribe(this), this.Pi = void 0);
  }
  Fi() {
    const { items: e } = this;
    if (_r(e)) {
      this.Ui = e;
      return;
    }
    const t = [];
    bg(e, (r, i) => {
      t[i] = r;
    }), this.Ui = t;
  }
  Oi(e) {
    let t, r, i, s;
    const { $controller: a, f: o, local: c, l, items: f, Ti: p, qi: g, forOf: T, $i: v } = this, w = a.scope, C = B8(f), _ = this.views = Array(C);
    if (bg(f, (I, B) => {
      i = _[B] = o.create().setLocation(l), i.nodes.unlink(), s = Gs(p, I, T, w, g, c, v), Cl(s.overrideContext, B, C), r = i.activate(e ?? i, a, 0, s), Qt(r) && (t ?? (t = [])).push(r);
    }), t !== void 0)
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  Vi(e) {
    let t, r, i, s = 0;
    const { views: a, $controller: o } = this, c = a.length;
    for (; c > s; ++s)
      i = a[s], i.release(), r = i.deactivate(e ?? i, o, 0), Qt(r) && (t ?? (t = [])).push(r);
    if (t !== void 0)
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  ji(e) {
    let t, r, i;
    const { $controller: s, views: a } = this, o = e.deletedIndices, c = o.length;
    let l = 0;
    for (; c > l; ++l)
      i = a[o[l]], i.release(), r = i.deactivate(i, s, 0), Qt(r) && (t ?? (t = [])).push(r);
    l = 0;
    let f = 0;
    for (; c > l; ++l)
      f = o[l] - l, a.splice(f, 1);
    if (t !== void 0)
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  Hi(e, t) {
    let r, i, s, a, o = 0;
    const { $controller: c, f: l, local: f, Ui: p, l: g, views: T, $i: v, qi: w, Ti: C, forOf: _ } = this, I = t.length;
    for (; I > o; ++o)
      t[o] === -2 && (s = l.create(), T.splice(o, 0, s));
    if (T.length !== I)
      throw N8(T.length, I);
    const B = c.scope, N = t.length;
    eA(T, t);
    const D = D8(t), U = D.length, W = _.declaration;
    let j, q = U - 1;
    for (o = N - 1; o >= 0; --o)
      s = T[o], j = T[o + 1], s.nodes.link(j?.nodes ?? g), t[o] === -2 ? (a = Gs(C, p[o], _, B, w, f, v), Cl(a.overrideContext, o, N), s.setLocation(g), i = s.activate(s, c, 0, a), Qt(i) && (r ?? (r = [])).push(i)) : q < 0 || U === 1 || o !== D[q] ? (v ? rn(W, s.scope, w, p[o]) : s.scope.bindingContext[f] = p[o], Cl(s.scope.overrideContext, o, N), s.nodes.insertBefore(s.location)) : (v ? rn(W, s.scope, w, p[o]) : s.scope.bindingContext[f] = p[o], e !== N && Cl(s.scope.overrideContext, o, N), --q);
    if (r !== void 0)
      return r.length === 1 ? r[0] : Promise.all(r);
  }
  dispose() {
    this.views.forEach(I8), this.views = void 0;
  }
  accept(e) {
    const { views: t } = this;
    if (t !== void 0) {
      for (let r = 0, i = t.length; r < i; ++r)
        if (t[r].accept(e) === !0)
          return !0;
    }
  }
}
np.inject = [bo, v0, wn, yd, Jn];
Q([Be], np.prototype, "items", void 0);
dr("repeat")(np);
let Au = 16, ri = new Int32Array(Au), Tl = new Int32Array(Au);
function D8(n) {
  const e = n.length;
  e > Au && (Au = e, ri = new Int32Array(e), Tl = new Int32Array(e));
  let t = 0, r = 0, i = 0, s = 0, a = 0, o = 0, c = 0, l = 0;
  for (; s < e; s++)
    if (r = n[s], r !== -2) {
      if (a = ri[t], i = n[a], i !== -2 && i < r) {
        Tl[s] = a, ri[++t] = s;
        continue;
      }
      for (o = 0, c = t; o < c; )
        l = o + c >> 1, i = n[ri[l]], i !== -2 && i < r ? o = l + 1 : c = l;
      i = n[ri[o]], (r < i || i === -2) && (o > 0 && (Tl[s] = ri[o - 1]), ri[o] = s);
    }
  s = ++t;
  const f = new Int32Array(s);
  for (r = ri[t - 1]; t-- > 0; )
    f[t] = r, r = Tl[r];
  for (; s-- > 0; )
    ri[s] = 0;
  return f;
}
const N8 = (n, e) => ne(`AUR0814:${n}!=${e}`), Cl = (n, e, t) => {
  const r = e === 0, i = e === t - 1, s = e % 2 === 0;
  n.$index = e, n.$first = r, n.$last = i, n.$middle = !r && !i, n.$even = s, n.$odd = !s, n.$length = t;
}, Tu = O0.toString, B8 = (n) => {
  switch (Tu.call(n)) {
    case "[object Array]":
      return n.length;
    case "[object Map]":
      return n.size;
    case "[object Set]":
      return n.size;
    case "[object Number]":
      return n;
    case "[object Null]":
      return 0;
    case "[object Undefined]":
      return 0;
    default:
      throw ne(`Cannot count ${Tu.call(n)}`);
  }
}, bg = (n, e) => {
  switch (Tu.call(n)) {
    case "[object Array]":
      return $8(n, e);
    case "[object Map]":
      return L8(n, e);
    case "[object Set]":
      return F8(n, e);
    case "[object Number]":
      return U8(n, e);
    case "[object Null]":
      return;
    case "[object Undefined]":
      return;
    default:
      throw ne(`Cannot iterate over ${Tu.call(n)}`);
  }
}, $8 = (n, e) => {
  const t = n.length;
  let r = 0;
  for (; r < t; ++r)
    e(n[r], r, n);
}, L8 = (n, e) => {
  let t = -0, r;
  for (r of n.entries())
    e(r, t++, n);
}, F8 = (n, e) => {
  let t = 0, r;
  for (r of n.keys())
    e(r, t++, n);
}, U8 = (n, e) => {
  let t = 0;
  for (; t < n; ++t)
    e(t, t, n);
}, Sa = (n, e, t, r, i) => {
  let s = n.get(t);
  return s === void 0 && (typeof e == "string" ? s = t[e] : s = V(e, r, i, null), n.set(t, s)), s;
}, Gs = (n, e, t, r, i, s, a) => {
  let o = n.get(e);
  return o === void 0 && (a ? rn(t.declaration, o = Yt.fromParent(r, new gm()), i, e) : o = Yt.fromParent(r, new gm(s, e)), n.set(e, o)), o;
};
class rp {
  constructor(e, t) {
    this.view = e.create().setLocation(t);
  }
  valueChanged(e, t, r) {
    const i = this.$controller, s = this.view.bindings;
    let a, o = 0, c = 0;
    if (i.isActive && s != null)
      for (a = Yt.fromParent(i.scope, e === void 0 ? {} : e), c = s.length; c > o; ++o)
        s[o].bind(a);
  }
  attaching(e, t, r) {
    const { $controller: i, value: s } = this, a = Yt.fromParent(i.scope, s === void 0 ? {} : s);
    return this.view.activate(e, i, r, a);
  }
  detaching(e, t, r) {
    return this.view.deactivate(e, this.$controller, r);
  }
  dispose() {
    this.view.dispose(), this.view = void 0;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
}
rp.inject = [Jn, wn];
Q([Be], rp.prototype, "value", void 0);
dr("with")(rp);
let Cu = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.cases = [], this.activeCases = [], this.promise = void 0;
  }
  link(e, t, r, i) {
    this.view = this.f.create(this.$controller).setLocation(this.l);
  }
  attaching(e, t, r) {
    const i = this.view, s = this.$controller;
    return this.queue(() => i.activate(e, s, r, s.scope)), this.queue(() => this.swap(e, this.value)), this.promise;
  }
  detaching(e, t, r) {
    return this.queue(() => this.view.deactivate(e, this.$controller, r)), this.promise;
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
  valueChanged(e, t) {
    !this.$controller.isActive || this.queue(() => this.swap(null, this.value));
  }
  caseChanged(e) {
    this.queue(() => this.zi(e));
  }
  zi(e) {
    const t = e.isMatch(this.value), r = this.activeCases, i = r.length;
    if (!t)
      return i > 0 && r[0].id === e.id ? this.Gi(null) : void 0;
    if (i > 0 && r[0].id < e.id)
      return;
    const s = [];
    let a = e.fallThrough;
    if (!a)
      s.push(e);
    else {
      const o = this.cases, c = o.indexOf(e);
      for (let l = c, f = o.length; l < f && a; l++) {
        const p = o[l];
        s.push(p), a = p.fallThrough;
      }
    }
    return Se(this.Gi(null, s), () => (this.activeCases = s, this.Xi(null)));
  }
  swap(e, t) {
    const r = [];
    let i = !1;
    for (const a of this.cases)
      if ((i || a.isMatch(t)) && (r.push(a), i = a.fallThrough), r.length > 0 && !i)
        break;
    const s = this.defaultCase;
    return r.length === 0 && s !== void 0 && r.push(s), Se(this.activeCases.length > 0 ? this.Gi(e, r) : void 0, () => {
      if (this.activeCases = r, r.length !== 0)
        return this.Xi(e);
    });
  }
  Xi(e) {
    const t = this.$controller;
    if (!t.isActive)
      return;
    const r = this.activeCases, i = r.length;
    if (i === 0)
      return;
    const s = t.scope;
    return i === 1 ? r[0].activate(e, 0, s) : jt(...r.map((a) => a.activate(e, 0, s)));
  }
  Gi(e, t = []) {
    const r = this.activeCases, i = r.length;
    if (i !== 0) {
      if (i === 1) {
        const s = r[0];
        return t.includes(s) ? void 0 : (r.length = 0, s.deactivate(e, 0));
      }
      return Se(jt(...r.reduce((s, a) => (t.includes(a) || s.push(a.deactivate(e, 0)), s), [])), () => {
        r.length = 0;
      });
    }
  }
  queue(e) {
    const t = this.promise;
    let r;
    r = this.promise = Se(Se(t, e), () => {
      this.promise === r && (this.promise = void 0);
    });
  }
  accept(e) {
    if (this.$controller.accept(e) === !0 || this.activeCases.some((t) => t.accept(e)))
      return !0;
  }
};
Q([Be], Cu.prototype, "value", void 0);
Cu = Q([dr("switch"), fn(0, Jn), fn(1, wn)], Cu);
let V8 = 0, Ya = class {
  constructor(e, t, r, i) {
    this.f = e, this.Ki = t, this.l = r, this.id = ++V8, this.fallThrough = !1, this.view = void 0, this.Qi = i.config.level <= 1, this.Oe = i.scopeTo(`${this.constructor.name}-#${this.id}`);
  }
  link(e, t, r, i) {
    const a = e.parent?.viewModel;
    if (a instanceof Cu)
      this.$switch = a, this.linkToSwitch(a);
    else
      throw ne("AUR0815");
  }
  detaching(e, t, r) {
    return this.deactivate(e, r);
  }
  isMatch(e) {
    this.Oe.debug("isMatch()");
    const t = this.value;
    return _r(t) ? (this.Pi === void 0 && (this.Pi = this.Yi(t)), t.includes(e)) : t === e;
  }
  valueChanged(e, t) {
    _r(e) ? (this.Pi?.unsubscribe(this), this.Pi = this.Yi(e)) : this.Pi !== void 0 && this.Pi.unsubscribe(this), this.$switch.caseChanged(this);
  }
  handleCollectionChange() {
    this.$switch.caseChanged(this);
  }
  activate(e, t, r) {
    let i = this.view;
    if (i === void 0 && (i = this.view = this.f.create().setLocation(this.l)), !i.isActive)
      return i.activate(e ?? i, this.$controller, t, r);
  }
  deactivate(e, t) {
    const r = this.view;
    if (!(r === void 0 || !r.isActive))
      return r.deactivate(e ?? r, this.$controller, t);
  }
  dispose() {
    this.Pi?.unsubscribe(this), this.view?.dispose(), this.view = void 0;
  }
  linkToSwitch(e) {
    e.cases.push(this);
  }
  Yi(e) {
    const t = this.Ki.getArrayObserver(e);
    return t.subscribe(this), t;
  }
  accept(e) {
    return this.$controller.accept(e) === !0 ? !0 : this.view?.accept(e);
  }
};
Ya.inject = [Jn, ma, wn, pa];
Q([Be], Ya.prototype, "value", void 0);
Q([Be({
  set: (n) => {
    switch (n) {
      case "true":
        return !0;
      case "false":
        return !1;
      default:
        return !!n;
    }
  },
  mode: 1
})], Ya.prototype, "fallThrough", void 0);
Ya = Q([dr("case")], Ya);
let xg = class extends Ya {
  linkToSwitch(e) {
    if (e.defaultCase !== void 0)
      throw ne("AUR0816");
    e.defaultCase = this;
  }
};
xg = Q([dr("default-case")], xg);
let Eu = class {
  constructor(e, t, r, i) {
    this.f = e, this.l = t, this.p = r, this.preSettledTask = null, this.postSettledTask = null, this.logger = i.scopeTo("promise.resolve");
  }
  link(e, t, r, i) {
    this.view = this.f.create(this.$controller).setLocation(this.l);
  }
  attaching(e, t, r) {
    const i = this.view, s = this.$controller;
    return Se(i.activate(e, s, r, this.viewScope = Yt.fromParent(s.scope, {})), () => this.swap(e, r));
  }
  valueChanged(e, t, r) {
    !this.$controller.isActive || this.swap(null, r);
  }
  swap(e, t) {
    const r = this.value;
    if (!Qt(r)) {
      this.logger.warn(`The value '${String(r)}' is not a promise. No change will be done.`);
      return;
    }
    const i = this.p.domWriteQueue, s = this.fulfilled, a = this.rejected, o = this.pending, c = this.viewScope;
    let l;
    const f = {
      reusable: !1
    }, p = () => {
      jt(l = (this.preSettledTask = i.queueTask(() => jt(s?.deactivate(e, t), a?.deactivate(e, t), o?.activate(e, t, c)), f)).result.catch((g) => {
        if (!(g instanceof B4))
          throw g;
      }), r.then((g) => {
        if (this.value !== r)
          return;
        const T = () => {
          this.postSettlePromise = (this.postSettledTask = i.queueTask(() => jt(o?.deactivate(e, t), a?.deactivate(e, t), s?.activate(e, t, c, g)), f)).result;
        };
        this.preSettledTask.status === 1 ? l.then(T) : (this.preSettledTask.cancel(), T());
      }, (g) => {
        if (this.value !== r)
          return;
        const T = () => {
          this.postSettlePromise = (this.postSettledTask = i.queueTask(() => jt(o?.deactivate(e, t), s?.deactivate(e, t), a?.activate(e, t, c, g)), f)).result;
        };
        this.preSettledTask.status === 1 ? l.then(T) : (this.preSettledTask.cancel(), T());
      }));
    };
    this.postSettledTask?.status === 1 ? this.postSettlePromise.then(p) : (this.postSettledTask?.cancel(), p());
  }
  detaching(e, t, r) {
    return this.preSettledTask?.cancel(), this.postSettledTask?.cancel(), this.preSettledTask = this.postSettledTask = null, this.view.deactivate(e, this.$controller, r);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
Q([Be], Eu.prototype, "value", void 0);
Eu = Q([dr("promise"), fn(0, Jn), fn(1, wn), fn(2, Tn), fn(3, pa)], Eu);
let Eh = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.view = void 0;
  }
  link(e, t, r, i) {
    ip(e).pending = this;
  }
  activate(e, t, r) {
    let i = this.view;
    if (i === void 0 && (i = this.view = this.f.create().setLocation(this.l)), !i.isActive)
      return i.activate(i, this.$controller, t, r);
  }
  deactivate(e, t) {
    const r = this.view;
    if (!(r === void 0 || !r.isActive))
      return r.deactivate(r, this.$controller, t);
  }
  detaching(e, t, r) {
    return this.deactivate(e, r);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
Q([Be({
  mode: 2
})], Eh.prototype, "value", void 0);
Eh = Q([dr("pending"), fn(0, Jn), fn(1, wn)], Eh);
let Sh = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.view = void 0;
  }
  link(e, t, r, i) {
    ip(e).fulfilled = this;
  }
  activate(e, t, r, i) {
    this.value = i;
    let s = this.view;
    if (s === void 0 && (s = this.view = this.f.create().setLocation(this.l)), !s.isActive)
      return s.activate(s, this.$controller, t, r);
  }
  deactivate(e, t) {
    const r = this.view;
    if (!(r === void 0 || !r.isActive))
      return r.deactivate(r, this.$controller, t);
  }
  detaching(e, t, r) {
    return this.deactivate(e, r);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
Q([Be({
  mode: 4
})], Sh.prototype, "value", void 0);
Sh = Q([dr("then"), fn(0, Jn), fn(1, wn)], Sh);
let _h = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.view = void 0;
  }
  link(e, t, r, i) {
    ip(e).rejected = this;
  }
  activate(e, t, r, i) {
    this.value = i;
    let s = this.view;
    if (s === void 0 && (s = this.view = this.f.create().setLocation(this.l)), !s.isActive)
      return s.activate(s, this.$controller, t, r);
  }
  deactivate(e, t) {
    const r = this.view;
    if (!(r === void 0 || !r.isActive))
      return r.deactivate(r, this.$controller, t);
  }
  detaching(e, t, r) {
    return this.deactivate(e, r);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
Q([Be({
  mode: 4
})], _h.prototype, "value", void 0);
_h = Q([dr("catch"), fn(0, Jn), fn(1, wn)], _h);
function ip(n) {
  const t = n.parent?.viewModel;
  if (t instanceof Eu)
    return t;
  throw ne("AUR0813");
}
let vg = class {
  "promise.resolve"(e, t, r) {
    return new lr(e, t, "promise", "bind");
  }
};
vg = Q([ki({
  pattern: "promise.resolve",
  symbols: ""
})], vg);
let wg = class {
  then(e, t, r) {
    return new lr(e, t, "then", "from-view");
  }
};
wg = Q([ki({
  pattern: "then",
  symbols: ""
})], wg);
let Ag = class {
  catch(e, t, r) {
    return new lr(e, t, "catch", "from-view");
  }
};
Ag = Q([ki({
  pattern: "catch",
  symbols: ""
})], Ag);
class tl {
  constructor(e, t, r, i, s, a, o) {
    this.c = e, this.parent = t, this.host = r, this.l = i, this.p = s, this.scopeBehavior = "auto", this.Zi = void 0, this.r = e.get(xa), this.Ji = a, this.ts = o;
  }
  static get inject() {
    return [lo, yd, Qa, wn, Tn, bo, l1(G8)];
  }
  get pending() {
    return this.es;
  }
  get composition() {
    return this.Zi;
  }
  attaching(e, t, r) {
    return this.es = Se(this.queue(new Tg(this.view, this.viewModel, this.model, void 0), e), (i) => {
      this.ts.isCurrent(i) && (this.es = void 0);
    });
  }
  detaching(e) {
    const t = this.Zi, r = this.es;
    return this.ts.invalidate(), this.Zi = this.es = void 0, Se(r, () => t?.deactivate(e));
  }
  propertyChanged(e) {
    if (e === "model" && this.Zi != null) {
      this.Zi.update(this.model);
      return;
    }
    this.es = Se(this.es, () => Se(this.queue(new Tg(this.view, this.viewModel, this.model, e), void 0), (t) => {
      this.ts.isCurrent(t) && (this.es = void 0);
    }));
  }
  queue(e, t) {
    const r = this.ts, i = this.Zi;
    return Se(r.create(e), (s) => r.isCurrent(s) ? Se(this.compose(s), (a) => r.isCurrent(s) ? Se(a.activate(t), () => r.isCurrent(s) ? (this.Zi = a, Se(i?.deactivate(t), () => s)) : Se(a.controller.deactivate(a.controller, this.$controller, 2), () => (a.controller.dispose(), s))) : (a.controller.dispose(), s)) : s);
  }
  compose(e) {
    let t, r, i;
    const { view: s, viewModel: a, model: o } = e.change, { c, host: l, $controller: f, l: p } = this, g = this.getDef(a), T = c.createChild(), v = p == null ? l.parentNode : p.parentNode;
    if (g !== null) {
      if (g.containerless)
        throw ne("AUR0806");
      p == null ? (r = l, i = () => {
      }) : (r = v.insertBefore(this.p.document.createElement(g.name), p), i = () => {
        r.remove();
      }), t = this.getVm(T, a, r);
    } else
      r = p ?? l, t = this.getVm(T, a, r);
    const w = () => {
      if (g !== null) {
        const C = ir.$el(T, t, r, {
          projections: this.Ji.projections
        }, g);
        return new Eg(C, (_) => C.activate(_ ?? C, f, 1, f.scope.parent), (_) => Se(C.deactivate(_ ?? C, f, 2), i), (_) => t.activate?.(_), e);
      } else {
        const C = Fr.create({
          name: Ua.generateName(),
          template: s
        }), _ = this.r.getViewFactory(C, T), I = ir.$view(_, f), B = this.scopeBehavior === "auto" ? Yt.fromParent(this.parent.scope, t) : Yt.create(t);
        return wu(r) ? I.setLocation(r) : I.setHost(r), new Eg(I, (N) => I.activate(N ?? I, f, 1, B), (N) => I.deactivate(N ?? I, f, 2), (N) => t.activate?.(N), e);
      }
    };
    return "activate" in t ? Se(t.activate(o), () => w()) : w();
  }
  getVm(e, t, r) {
    if (t == null)
      return new j8();
    if (typeof t == "object")
      return t;
    const i = this.p, s = wu(r);
    At(e, i.Element, At(e, Qa, new un("ElementResolver", s ? null : r))), At(e, wn, new un("IRenderLocation", s ? r : null));
    const a = e.invoke(t);
    return At(e, t, new un("au-compose.viewModel", a)), a;
  }
  getDef(e) {
    const t = kn(e) ? e : e?.constructor;
    return Ua.isType(t) ? Ua.getDefinition(t) : null;
  }
}
Q([Be], tl.prototype, "view", void 0);
Q([Be], tl.prototype, "viewModel", void 0);
Q([Be], tl.prototype, "model", void 0);
Q([Be({
  set: (n) => {
    if (n === "scoped" || n === "auto")
      return n;
    throw ne("AUR0805");
  }
})], tl.prototype, "scopeBehavior", void 0);
xv("au-compose")(tl);
class j8 {
}
class G8 {
  constructor() {
    this.id = 0;
  }
  isCurrent(e) {
    return e.id === this.id;
  }
  create(e) {
    return Se(e.load(), (t) => new W8(++this.id, t));
  }
  invalidate() {
    this.id++;
  }
}
class Tg {
  constructor(e, t, r, i) {
    this.view = e, this.viewModel = t, this.model = r, this.src = i;
  }
  load() {
    return Qt(this.view) || Qt(this.viewModel) ? Promise.all([this.view, this.viewModel]).then(([e, t]) => new Cg(e, t, this.model, this.src)) : new Cg(this.view, this.viewModel, this.model, this.src);
  }
}
class Cg {
  constructor(e, t, r, i) {
    this.view = e, this.viewModel = t, this.model = r, this.src = i;
  }
}
class W8 {
  constructor(e, t) {
    this.id = e, this.change = t;
  }
}
class Eg {
  constructor(e, t, r, i, s) {
    this.controller = e, this.start = t, this.stop = r, this.update = i, this.context = s, this.state = 0;
  }
  activate(e) {
    if (this.state !== 0)
      throw ne(`AUR0807:${this.controller.name}`);
    return this.state = 1, this.start(e);
  }
  deactivate(e) {
    switch (this.state) {
      case 1:
        return this.state = -1, this.stop(e);
      case -1:
        throw ne("AUR0808");
      default:
        this.state = -1;
    }
  }
}
let Ph = class {
  constructor(e, t, r, i) {
    this.ss = null, this.rs = null;
    let s;
    const a = t.auSlot, o = r.instruction?.projections?.[a.name];
    o == null ? (s = i.getViewFactory(a.fallback, r.controller.container), this.os = !1) : (s = i.getViewFactory(o, r.parent.controller.container), this.os = !0), this.ls = r, this.view = s.create().setLocation(e);
  }
  static get inject() {
    return [wn, bo, xu, xa];
  }
  binding(e, t, r) {
    this.ss = this.$controller.scope.parent;
    let i;
    this.os && (i = this.ls.controller.scope.parent, (this.rs = Yt.fromParent(i, i.bindingContext)).overrideContext.$host = this.expose ?? this.ss.bindingContext);
  }
  attaching(e, t, r) {
    return this.view.activate(e, this.$controller, r, this.os ? this.rs : this.ss);
  }
  detaching(e, t, r) {
    return this.view.deactivate(e, this.$controller, r);
  }
  exposeChanged(e) {
    this.os && this.rs != null && (this.rs.overrideContext.$host = e);
  }
  dispose() {
    this.view.dispose(), this.view = void 0;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
};
Q([Be], Ph.prototype, "expose", void 0);
Ph = Q([xv({
  name: "au-slot",
  template: null,
  containerless: !0
})], Ph);
const H8 = ke("ISanitizer", (n) => n.singleton(class {
  sanitize() {
    throw ne('"sanitize" method not implemented');
  }
}));
let Mh = class {
  constructor(e) {
    this.cs = e;
  }
  toView(e) {
    return e == null ? null : this.cs.sanitize(e);
  }
};
Mh = Q([fn(0, H8)], Mh);
qc("sanitize")(Mh);
ke("IAurelia");
var Sg;
(function(n) {
  n[n.oneTime = 1] = "oneTime", n[n.toView = 2] = "toView", n[n.fromView = 4] = "fromView", n[n.twoWay = 6] = "twoWay", n[n.default = 8] = "default";
})(Sg || (Sg = {}));
var _g;
(function(n) {
  n[n.Element = 1] = "Element", n[n.Attribute = 2] = "Attribute";
})(_g || (_g = {}));
const xo = pe.createInterface("CacheService");
class xd {
  cache = /* @__PURE__ */ new Map();
  setItem(e, t) {
    this.cache.set(e, t);
  }
  getItem(e) {
    return this.cache.get(e);
  }
  static register(e) {
    fe.singleton(xo, xd).register(e);
  }
}
const Pg = (n, e) => {
  const t = n[e];
  return t ? typeof t == "function" ? t() : Promise.resolve(t) : new Promise((r, i) => {
    (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(i.bind(null, new Error("Unknown variable dynamic import: " + e)));
  });
};
var Kv = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function z8(n) {
  var e = n.default;
  if (typeof e == "function") {
    var t = function() {
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(n, r);
    Object.defineProperty(t, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return n[r];
      }
    });
  }), t;
}
var qv = { exports: {} };
const K8 = new Proxy({}, {
  get(n, e) {
    throw new Error(`Module "" has been externalized for browser compatibility. Cannot access ".${e}" in client code.`);
  }
}), q8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: K8
}, Symbol.toStringTag, { value: "Module" })), Q8 = /* @__PURE__ */ z8(q8);
(function(n) {
  (function(e, t) {
    function r(S, d) {
      if (!S)
        throw new Error(d || "Assertion failed");
    }
    function i(S, d) {
      S.super_ = d;
      var m = function() {
      };
      m.prototype = d.prototype, S.prototype = new m(), S.prototype.constructor = S;
    }
    function s(S, d, m) {
      if (s.isBN(S))
        return S;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, S !== null && ((d === "le" || d === "be") && (m = d, d = 10), this._init(S || 0, d || 10, m || "be"));
    }
    typeof e == "object" ? e.exports = s : t.BN = s, s.BN = s, s.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = Q8.Buffer;
    } catch {
    }
    s.isBN = function(d) {
      return d instanceof s ? !0 : d !== null && typeof d == "object" && d.constructor.wordSize === s.wordSize && Array.isArray(d.words);
    }, s.max = function(d, m) {
      return d.cmp(m) > 0 ? d : m;
    }, s.min = function(d, m) {
      return d.cmp(m) < 0 ? d : m;
    }, s.prototype._init = function(d, m, x) {
      if (typeof d == "number")
        return this._initNumber(d, m, x);
      if (typeof d == "object")
        return this._initArray(d, m, x);
      m === "hex" && (m = 16), r(m === (m | 0) && m >= 2 && m <= 36), d = d.toString().replace(/\s+/g, "");
      var E = 0;
      d[0] === "-" && (E++, this.negative = 1), E < d.length && (m === 16 ? this._parseHex(d, E, x) : (this._parseBase(d, m, E), x === "le" && this._initArray(this.toArray(), m, x)));
    }, s.prototype._initNumber = function(d, m, x) {
      d < 0 && (this.negative = 1, d = -d), d < 67108864 ? (this.words = [d & 67108863], this.length = 1) : d < 4503599627370496 ? (this.words = [
        d & 67108863,
        d / 67108864 & 67108863
      ], this.length = 2) : (r(d < 9007199254740992), this.words = [
        d & 67108863,
        d / 67108864 & 67108863,
        1
      ], this.length = 3), x === "le" && this._initArray(this.toArray(), m, x);
    }, s.prototype._initArray = function(d, m, x) {
      if (r(typeof d.length == "number"), d.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(d.length / 3), this.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        this.words[E] = 0;
      var A, P, R = 0;
      if (x === "be")
        for (E = d.length - 1, A = 0; E >= 0; E -= 3)
          P = d[E] | d[E - 1] << 8 | d[E - 2] << 16, this.words[A] |= P << R & 67108863, this.words[A + 1] = P >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, A++);
      else if (x === "le")
        for (E = 0, A = 0; E < d.length; E += 3)
          P = d[E] | d[E + 1] << 8 | d[E + 2] << 16, this.words[A] |= P << R & 67108863, this.words[A + 1] = P >>> 26 - R & 67108863, R += 24, R >= 26 && (R -= 26, A++);
      return this._strip();
    };
    function o(S, d) {
      var m = S.charCodeAt(d);
      if (m >= 48 && m <= 57)
        return m - 48;
      if (m >= 65 && m <= 70)
        return m - 55;
      if (m >= 97 && m <= 102)
        return m - 87;
      r(!1, "Invalid character in " + S);
    }
    function c(S, d, m) {
      var x = o(S, m);
      return m - 1 >= d && (x |= o(S, m - 1) << 4), x;
    }
    s.prototype._parseHex = function(d, m, x) {
      this.length = Math.ceil((d.length - m) / 6), this.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        this.words[E] = 0;
      var A = 0, P = 0, R;
      if (x === "be")
        for (E = d.length - 1; E >= m; E -= 2)
          R = c(d, m, E) << A, this.words[P] |= R & 67108863, A >= 18 ? (A -= 18, P += 1, this.words[P] |= R >>> 26) : A += 8;
      else {
        var y = d.length - m;
        for (E = y % 2 === 0 ? m + 1 : m; E < d.length; E += 2)
          R = c(d, m, E) << A, this.words[P] |= R & 67108863, A >= 18 ? (A -= 18, P += 1, this.words[P] |= R >>> 26) : A += 8;
      }
      this._strip();
    };
    function l(S, d, m, x) {
      for (var E = 0, A = 0, P = Math.min(S.length, m), R = d; R < P; R++) {
        var y = S.charCodeAt(R) - 48;
        E *= x, y >= 49 ? A = y - 49 + 10 : y >= 17 ? A = y - 17 + 10 : A = y, r(y >= 0 && A < x, "Invalid character"), E += A;
      }
      return E;
    }
    s.prototype._parseBase = function(d, m, x) {
      this.words = [0], this.length = 1;
      for (var E = 0, A = 1; A <= 67108863; A *= m)
        E++;
      E--, A = A / m | 0;
      for (var P = d.length - x, R = P % E, y = Math.min(P, P - R) + x, u = 0, b = x; b < y; b += E)
        u = l(d, b, b + E, m), this.imuln(A), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);
      if (R !== 0) {
        var k = 1;
        for (u = l(d, b, d.length, m), b = 0; b < R; b++)
          k *= m;
        this.imuln(k), this.words[0] + u < 67108864 ? this.words[0] += u : this._iaddn(u);
      }
      this._strip();
    }, s.prototype.copy = function(d) {
      d.words = new Array(this.length);
      for (var m = 0; m < this.length; m++)
        d.words[m] = this.words[m];
      d.length = this.length, d.negative = this.negative, d.red = this.red;
    };
    function f(S, d) {
      S.words = d.words, S.length = d.length, S.negative = d.negative, S.red = d.red;
    }
    if (s.prototype._move = function(d) {
      f(d, this);
    }, s.prototype.clone = function() {
      var d = new s(null);
      return this.copy(d), d;
    }, s.prototype._expand = function(d) {
      for (; this.length < d; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = p;
      } catch {
        s.prototype.inspect = p;
      }
    else
      s.prototype.inspect = p;
    function p() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var g = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], T = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], v = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(d, m) {
      d = d || 10, m = m | 0 || 1;
      var x;
      if (d === 16 || d === "hex") {
        x = "";
        for (var E = 0, A = 0, P = 0; P < this.length; P++) {
          var R = this.words[P], y = ((R << E | A) & 16777215).toString(16);
          A = R >>> 24 - E & 16777215, E += 2, E >= 26 && (E -= 26, P--), A !== 0 || P !== this.length - 1 ? x = g[6 - y.length] + y + x : x = y + x;
        }
        for (A !== 0 && (x = A.toString(16) + x); x.length % m !== 0; )
          x = "0" + x;
        return this.negative !== 0 && (x = "-" + x), x;
      }
      if (d === (d | 0) && d >= 2 && d <= 36) {
        var u = T[d], b = v[d];
        x = "";
        var k = this.clone();
        for (k.negative = 0; !k.isZero(); ) {
          var h = k.modrn(b).toString(d);
          k = k.idivn(b), k.isZero() ? x = h + x : x = g[u - h.length] + h + x;
        }
        for (this.isZero() && (x = "0" + x); x.length % m !== 0; )
          x = "0" + x;
        return this.negative !== 0 && (x = "-" + x), x;
      }
      r(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var d = this.words[0];
      return this.length === 2 ? d += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? d += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -d : d;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, a && (s.prototype.toBuffer = function(d, m) {
      return this.toArrayLike(a, d, m);
    }), s.prototype.toArray = function(d, m) {
      return this.toArrayLike(Array, d, m);
    };
    var w = function(d, m) {
      return d.allocUnsafe ? d.allocUnsafe(m) : new d(m);
    };
    s.prototype.toArrayLike = function(d, m, x) {
      this._strip();
      var E = this.byteLength(), A = x || Math.max(1, E);
      r(E <= A, "byte array longer than desired length"), r(A > 0, "Requested array length <= 0");
      var P = w(d, A), R = m === "le" ? "LE" : "BE";
      return this["_toArrayLike" + R](P, E), P;
    }, s.prototype._toArrayLikeLE = function(d, m) {
      for (var x = 0, E = 0, A = 0, P = 0; A < this.length; A++) {
        var R = this.words[A] << P | E;
        d[x++] = R & 255, x < d.length && (d[x++] = R >> 8 & 255), x < d.length && (d[x++] = R >> 16 & 255), P === 6 ? (x < d.length && (d[x++] = R >> 24 & 255), E = 0, P = 0) : (E = R >>> 24, P += 2);
      }
      if (x < d.length)
        for (d[x++] = E; x < d.length; )
          d[x++] = 0;
    }, s.prototype._toArrayLikeBE = function(d, m) {
      for (var x = d.length - 1, E = 0, A = 0, P = 0; A < this.length; A++) {
        var R = this.words[A] << P | E;
        d[x--] = R & 255, x >= 0 && (d[x--] = R >> 8 & 255), x >= 0 && (d[x--] = R >> 16 & 255), P === 6 ? (x >= 0 && (d[x--] = R >> 24 & 255), E = 0, P = 0) : (E = R >>> 24, P += 2);
      }
      if (x >= 0)
        for (d[x--] = E; x >= 0; )
          d[x--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(d) {
      return 32 - Math.clz32(d);
    } : s.prototype._countBits = function(d) {
      var m = d, x = 0;
      return m >= 4096 && (x += 13, m >>>= 13), m >= 64 && (x += 7, m >>>= 7), m >= 8 && (x += 4, m >>>= 4), m >= 2 && (x += 2, m >>>= 2), x + m;
    }, s.prototype._zeroBits = function(d) {
      if (d === 0)
        return 26;
      var m = d, x = 0;
      return (m & 8191) === 0 && (x += 13, m >>>= 13), (m & 127) === 0 && (x += 7, m >>>= 7), (m & 15) === 0 && (x += 4, m >>>= 4), (m & 3) === 0 && (x += 2, m >>>= 2), (m & 1) === 0 && x++, x;
    }, s.prototype.bitLength = function() {
      var d = this.words[this.length - 1], m = this._countBits(d);
      return (this.length - 1) * 26 + m;
    };
    function C(S) {
      for (var d = new Array(S.bitLength()), m = 0; m < d.length; m++) {
        var x = m / 26 | 0, E = m % 26;
        d[m] = S.words[x] >>> E & 1;
      }
      return d;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var d = 0, m = 0; m < this.length; m++) {
        var x = this._zeroBits(this.words[m]);
        if (d += x, x !== 26)
          break;
      }
      return d;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(d) {
      return this.negative !== 0 ? this.abs().inotn(d).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(d) {
      return this.testn(d - 1) ? this.notn(d).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(d) {
      for (; this.length < d.length; )
        this.words[this.length++] = 0;
      for (var m = 0; m < d.length; m++)
        this.words[m] = this.words[m] | d.words[m];
      return this._strip();
    }, s.prototype.ior = function(d) {
      return r((this.negative | d.negative) === 0), this.iuor(d);
    }, s.prototype.or = function(d) {
      return this.length > d.length ? this.clone().ior(d) : d.clone().ior(this);
    }, s.prototype.uor = function(d) {
      return this.length > d.length ? this.clone().iuor(d) : d.clone().iuor(this);
    }, s.prototype.iuand = function(d) {
      var m;
      this.length > d.length ? m = d : m = this;
      for (var x = 0; x < m.length; x++)
        this.words[x] = this.words[x] & d.words[x];
      return this.length = m.length, this._strip();
    }, s.prototype.iand = function(d) {
      return r((this.negative | d.negative) === 0), this.iuand(d);
    }, s.prototype.and = function(d) {
      return this.length > d.length ? this.clone().iand(d) : d.clone().iand(this);
    }, s.prototype.uand = function(d) {
      return this.length > d.length ? this.clone().iuand(d) : d.clone().iuand(this);
    }, s.prototype.iuxor = function(d) {
      var m, x;
      this.length > d.length ? (m = this, x = d) : (m = d, x = this);
      for (var E = 0; E < x.length; E++)
        this.words[E] = m.words[E] ^ x.words[E];
      if (this !== m)
        for (; E < m.length; E++)
          this.words[E] = m.words[E];
      return this.length = m.length, this._strip();
    }, s.prototype.ixor = function(d) {
      return r((this.negative | d.negative) === 0), this.iuxor(d);
    }, s.prototype.xor = function(d) {
      return this.length > d.length ? this.clone().ixor(d) : d.clone().ixor(this);
    }, s.prototype.uxor = function(d) {
      return this.length > d.length ? this.clone().iuxor(d) : d.clone().iuxor(this);
    }, s.prototype.inotn = function(d) {
      r(typeof d == "number" && d >= 0);
      var m = Math.ceil(d / 26) | 0, x = d % 26;
      this._expand(m), x > 0 && m--;
      for (var E = 0; E < m; E++)
        this.words[E] = ~this.words[E] & 67108863;
      return x > 0 && (this.words[E] = ~this.words[E] & 67108863 >> 26 - x), this._strip();
    }, s.prototype.notn = function(d) {
      return this.clone().inotn(d);
    }, s.prototype.setn = function(d, m) {
      r(typeof d == "number" && d >= 0);
      var x = d / 26 | 0, E = d % 26;
      return this._expand(x + 1), m ? this.words[x] = this.words[x] | 1 << E : this.words[x] = this.words[x] & ~(1 << E), this._strip();
    }, s.prototype.iadd = function(d) {
      var m;
      if (this.negative !== 0 && d.negative === 0)
        return this.negative = 0, m = this.isub(d), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && d.negative !== 0)
        return d.negative = 0, m = this.isub(d), d.negative = 1, m._normSign();
      var x, E;
      this.length > d.length ? (x = this, E = d) : (x = d, E = this);
      for (var A = 0, P = 0; P < E.length; P++)
        m = (x.words[P] | 0) + (E.words[P] | 0) + A, this.words[P] = m & 67108863, A = m >>> 26;
      for (; A !== 0 && P < x.length; P++)
        m = (x.words[P] | 0) + A, this.words[P] = m & 67108863, A = m >>> 26;
      if (this.length = x.length, A !== 0)
        this.words[this.length] = A, this.length++;
      else if (x !== this)
        for (; P < x.length; P++)
          this.words[P] = x.words[P];
      return this;
    }, s.prototype.add = function(d) {
      var m;
      return d.negative !== 0 && this.negative === 0 ? (d.negative = 0, m = this.sub(d), d.negative ^= 1, m) : d.negative === 0 && this.negative !== 0 ? (this.negative = 0, m = d.sub(this), this.negative = 1, m) : this.length > d.length ? this.clone().iadd(d) : d.clone().iadd(this);
    }, s.prototype.isub = function(d) {
      if (d.negative !== 0) {
        d.negative = 0;
        var m = this.iadd(d);
        return d.negative = 1, m._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(d), this.negative = 1, this._normSign();
      var x = this.cmp(d);
      if (x === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var E, A;
      x > 0 ? (E = this, A = d) : (E = d, A = this);
      for (var P = 0, R = 0; R < A.length; R++)
        m = (E.words[R] | 0) - (A.words[R] | 0) + P, P = m >> 26, this.words[R] = m & 67108863;
      for (; P !== 0 && R < E.length; R++)
        m = (E.words[R] | 0) + P, P = m >> 26, this.words[R] = m & 67108863;
      if (P === 0 && R < E.length && E !== this)
        for (; R < E.length; R++)
          this.words[R] = E.words[R];
      return this.length = Math.max(this.length, R), E !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(d) {
      return this.clone().isub(d);
    };
    function _(S, d, m) {
      m.negative = d.negative ^ S.negative;
      var x = S.length + d.length | 0;
      m.length = x, x = x - 1 | 0;
      var E = S.words[0] | 0, A = d.words[0] | 0, P = E * A, R = P & 67108863, y = P / 67108864 | 0;
      m.words[0] = R;
      for (var u = 1; u < x; u++) {
        for (var b = y >>> 26, k = y & 67108863, h = Math.min(u, d.length - 1), M = Math.max(0, u - S.length + 1); M <= h; M++) {
          var L = u - M | 0;
          E = S.words[L] | 0, A = d.words[M] | 0, P = E * A + k, b += P / 67108864 | 0, k = P & 67108863;
        }
        m.words[u] = k | 0, y = b | 0;
      }
      return y !== 0 ? m.words[u] = y | 0 : m.length--, m._strip();
    }
    var I = function(d, m, x) {
      var E = d.words, A = m.words, P = x.words, R = 0, y, u, b, k = E[0] | 0, h = k & 8191, M = k >>> 13, L = E[1] | 0, $ = L & 8191, F = L >>> 13, X = E[2] | 0, z = X & 8191, K = X >>> 13, xt = E[3] | 0, Z = xt & 8191, ue = xt >>> 13, As = E[4] | 0, Fe = As & 8191, Ue = As >>> 13, Ts = E[5] | 0, Ve = Ts & 8191, je = Ts >>> 13, Cs = E[6] | 0, Ge = Cs & 8191, We = Cs >>> 13, Es = E[7] | 0, He = Es & 8191, ze = Es >>> 13, Ss = E[8] | 0, Ke = Ss & 8191, qe = Ss >>> 13, _s = E[9] | 0, Qe = _s & 8191, Je = _s >>> 13, Ps = A[0] | 0, Ye = Ps & 8191, Xe = Ps >>> 13, Ms = A[1] | 0, Ze = Ms & 8191, et = Ms >>> 13, Rs = A[2] | 0, tt = Rs & 8191, nt = Rs >>> 13, ks = A[3] | 0, rt = ks & 8191, it = ks >>> 13, Is = A[4] | 0, st = Is & 8191, at = Is >>> 13, Os = A[5] | 0, ot = Os & 8191, ct = Os >>> 13, Ds = A[6] | 0, lt = Ds & 8191, ut = Ds >>> 13, Ns = A[7] | 0, dt = Ns & 8191, ft = Ns >>> 13, Bs = A[8] | 0, ht = Bs & 8191, pt = Bs >>> 13, $s = A[9] | 0, mt = $s & 8191, yt = $s >>> 13;
      x.negative = d.negative ^ m.negative, x.length = 19, y = Math.imul(h, Ye), u = Math.imul(h, Xe), u = u + Math.imul(M, Ye) | 0, b = Math.imul(M, Xe);
      var Ui = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (Ui >>> 26) | 0, Ui &= 67108863, y = Math.imul($, Ye), u = Math.imul($, Xe), u = u + Math.imul(F, Ye) | 0, b = Math.imul(F, Xe), y = y + Math.imul(h, Ze) | 0, u = u + Math.imul(h, et) | 0, u = u + Math.imul(M, Ze) | 0, b = b + Math.imul(M, et) | 0;
      var Vi = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (Vi >>> 26) | 0, Vi &= 67108863, y = Math.imul(z, Ye), u = Math.imul(z, Xe), u = u + Math.imul(K, Ye) | 0, b = Math.imul(K, Xe), y = y + Math.imul($, Ze) | 0, u = u + Math.imul($, et) | 0, u = u + Math.imul(F, Ze) | 0, b = b + Math.imul(F, et) | 0, y = y + Math.imul(h, tt) | 0, u = u + Math.imul(h, nt) | 0, u = u + Math.imul(M, tt) | 0, b = b + Math.imul(M, nt) | 0;
      var ji = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (ji >>> 26) | 0, ji &= 67108863, y = Math.imul(Z, Ye), u = Math.imul(Z, Xe), u = u + Math.imul(ue, Ye) | 0, b = Math.imul(ue, Xe), y = y + Math.imul(z, Ze) | 0, u = u + Math.imul(z, et) | 0, u = u + Math.imul(K, Ze) | 0, b = b + Math.imul(K, et) | 0, y = y + Math.imul($, tt) | 0, u = u + Math.imul($, nt) | 0, u = u + Math.imul(F, tt) | 0, b = b + Math.imul(F, nt) | 0, y = y + Math.imul(h, rt) | 0, u = u + Math.imul(h, it) | 0, u = u + Math.imul(M, rt) | 0, b = b + Math.imul(M, it) | 0;
      var Gi = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (Gi >>> 26) | 0, Gi &= 67108863, y = Math.imul(Fe, Ye), u = Math.imul(Fe, Xe), u = u + Math.imul(Ue, Ye) | 0, b = Math.imul(Ue, Xe), y = y + Math.imul(Z, Ze) | 0, u = u + Math.imul(Z, et) | 0, u = u + Math.imul(ue, Ze) | 0, b = b + Math.imul(ue, et) | 0, y = y + Math.imul(z, tt) | 0, u = u + Math.imul(z, nt) | 0, u = u + Math.imul(K, tt) | 0, b = b + Math.imul(K, nt) | 0, y = y + Math.imul($, rt) | 0, u = u + Math.imul($, it) | 0, u = u + Math.imul(F, rt) | 0, b = b + Math.imul(F, it) | 0, y = y + Math.imul(h, st) | 0, u = u + Math.imul(h, at) | 0, u = u + Math.imul(M, st) | 0, b = b + Math.imul(M, at) | 0;
      var Wi = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (Wi >>> 26) | 0, Wi &= 67108863, y = Math.imul(Ve, Ye), u = Math.imul(Ve, Xe), u = u + Math.imul(je, Ye) | 0, b = Math.imul(je, Xe), y = y + Math.imul(Fe, Ze) | 0, u = u + Math.imul(Fe, et) | 0, u = u + Math.imul(Ue, Ze) | 0, b = b + Math.imul(Ue, et) | 0, y = y + Math.imul(Z, tt) | 0, u = u + Math.imul(Z, nt) | 0, u = u + Math.imul(ue, tt) | 0, b = b + Math.imul(ue, nt) | 0, y = y + Math.imul(z, rt) | 0, u = u + Math.imul(z, it) | 0, u = u + Math.imul(K, rt) | 0, b = b + Math.imul(K, it) | 0, y = y + Math.imul($, st) | 0, u = u + Math.imul($, at) | 0, u = u + Math.imul(F, st) | 0, b = b + Math.imul(F, at) | 0, y = y + Math.imul(h, ot) | 0, u = u + Math.imul(h, ct) | 0, u = u + Math.imul(M, ot) | 0, b = b + Math.imul(M, ct) | 0;
      var zd = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (zd >>> 26) | 0, zd &= 67108863, y = Math.imul(Ge, Ye), u = Math.imul(Ge, Xe), u = u + Math.imul(We, Ye) | 0, b = Math.imul(We, Xe), y = y + Math.imul(Ve, Ze) | 0, u = u + Math.imul(Ve, et) | 0, u = u + Math.imul(je, Ze) | 0, b = b + Math.imul(je, et) | 0, y = y + Math.imul(Fe, tt) | 0, u = u + Math.imul(Fe, nt) | 0, u = u + Math.imul(Ue, tt) | 0, b = b + Math.imul(Ue, nt) | 0, y = y + Math.imul(Z, rt) | 0, u = u + Math.imul(Z, it) | 0, u = u + Math.imul(ue, rt) | 0, b = b + Math.imul(ue, it) | 0, y = y + Math.imul(z, st) | 0, u = u + Math.imul(z, at) | 0, u = u + Math.imul(K, st) | 0, b = b + Math.imul(K, at) | 0, y = y + Math.imul($, ot) | 0, u = u + Math.imul($, ct) | 0, u = u + Math.imul(F, ot) | 0, b = b + Math.imul(F, ct) | 0, y = y + Math.imul(h, lt) | 0, u = u + Math.imul(h, ut) | 0, u = u + Math.imul(M, lt) | 0, b = b + Math.imul(M, ut) | 0;
      var Kd = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (Kd >>> 26) | 0, Kd &= 67108863, y = Math.imul(He, Ye), u = Math.imul(He, Xe), u = u + Math.imul(ze, Ye) | 0, b = Math.imul(ze, Xe), y = y + Math.imul(Ge, Ze) | 0, u = u + Math.imul(Ge, et) | 0, u = u + Math.imul(We, Ze) | 0, b = b + Math.imul(We, et) | 0, y = y + Math.imul(Ve, tt) | 0, u = u + Math.imul(Ve, nt) | 0, u = u + Math.imul(je, tt) | 0, b = b + Math.imul(je, nt) | 0, y = y + Math.imul(Fe, rt) | 0, u = u + Math.imul(Fe, it) | 0, u = u + Math.imul(Ue, rt) | 0, b = b + Math.imul(Ue, it) | 0, y = y + Math.imul(Z, st) | 0, u = u + Math.imul(Z, at) | 0, u = u + Math.imul(ue, st) | 0, b = b + Math.imul(ue, at) | 0, y = y + Math.imul(z, ot) | 0, u = u + Math.imul(z, ct) | 0, u = u + Math.imul(K, ot) | 0, b = b + Math.imul(K, ct) | 0, y = y + Math.imul($, lt) | 0, u = u + Math.imul($, ut) | 0, u = u + Math.imul(F, lt) | 0, b = b + Math.imul(F, ut) | 0, y = y + Math.imul(h, dt) | 0, u = u + Math.imul(h, ft) | 0, u = u + Math.imul(M, dt) | 0, b = b + Math.imul(M, ft) | 0;
      var qd = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (qd >>> 26) | 0, qd &= 67108863, y = Math.imul(Ke, Ye), u = Math.imul(Ke, Xe), u = u + Math.imul(qe, Ye) | 0, b = Math.imul(qe, Xe), y = y + Math.imul(He, Ze) | 0, u = u + Math.imul(He, et) | 0, u = u + Math.imul(ze, Ze) | 0, b = b + Math.imul(ze, et) | 0, y = y + Math.imul(Ge, tt) | 0, u = u + Math.imul(Ge, nt) | 0, u = u + Math.imul(We, tt) | 0, b = b + Math.imul(We, nt) | 0, y = y + Math.imul(Ve, rt) | 0, u = u + Math.imul(Ve, it) | 0, u = u + Math.imul(je, rt) | 0, b = b + Math.imul(je, it) | 0, y = y + Math.imul(Fe, st) | 0, u = u + Math.imul(Fe, at) | 0, u = u + Math.imul(Ue, st) | 0, b = b + Math.imul(Ue, at) | 0, y = y + Math.imul(Z, ot) | 0, u = u + Math.imul(Z, ct) | 0, u = u + Math.imul(ue, ot) | 0, b = b + Math.imul(ue, ct) | 0, y = y + Math.imul(z, lt) | 0, u = u + Math.imul(z, ut) | 0, u = u + Math.imul(K, lt) | 0, b = b + Math.imul(K, ut) | 0, y = y + Math.imul($, dt) | 0, u = u + Math.imul($, ft) | 0, u = u + Math.imul(F, dt) | 0, b = b + Math.imul(F, ft) | 0, y = y + Math.imul(h, ht) | 0, u = u + Math.imul(h, pt) | 0, u = u + Math.imul(M, ht) | 0, b = b + Math.imul(M, pt) | 0;
      var Qd = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (Qd >>> 26) | 0, Qd &= 67108863, y = Math.imul(Qe, Ye), u = Math.imul(Qe, Xe), u = u + Math.imul(Je, Ye) | 0, b = Math.imul(Je, Xe), y = y + Math.imul(Ke, Ze) | 0, u = u + Math.imul(Ke, et) | 0, u = u + Math.imul(qe, Ze) | 0, b = b + Math.imul(qe, et) | 0, y = y + Math.imul(He, tt) | 0, u = u + Math.imul(He, nt) | 0, u = u + Math.imul(ze, tt) | 0, b = b + Math.imul(ze, nt) | 0, y = y + Math.imul(Ge, rt) | 0, u = u + Math.imul(Ge, it) | 0, u = u + Math.imul(We, rt) | 0, b = b + Math.imul(We, it) | 0, y = y + Math.imul(Ve, st) | 0, u = u + Math.imul(Ve, at) | 0, u = u + Math.imul(je, st) | 0, b = b + Math.imul(je, at) | 0, y = y + Math.imul(Fe, ot) | 0, u = u + Math.imul(Fe, ct) | 0, u = u + Math.imul(Ue, ot) | 0, b = b + Math.imul(Ue, ct) | 0, y = y + Math.imul(Z, lt) | 0, u = u + Math.imul(Z, ut) | 0, u = u + Math.imul(ue, lt) | 0, b = b + Math.imul(ue, ut) | 0, y = y + Math.imul(z, dt) | 0, u = u + Math.imul(z, ft) | 0, u = u + Math.imul(K, dt) | 0, b = b + Math.imul(K, ft) | 0, y = y + Math.imul($, ht) | 0, u = u + Math.imul($, pt) | 0, u = u + Math.imul(F, ht) | 0, b = b + Math.imul(F, pt) | 0, y = y + Math.imul(h, mt) | 0, u = u + Math.imul(h, yt) | 0, u = u + Math.imul(M, mt) | 0, b = b + Math.imul(M, yt) | 0;
      var Jd = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (Jd >>> 26) | 0, Jd &= 67108863, y = Math.imul(Qe, Ze), u = Math.imul(Qe, et), u = u + Math.imul(Je, Ze) | 0, b = Math.imul(Je, et), y = y + Math.imul(Ke, tt) | 0, u = u + Math.imul(Ke, nt) | 0, u = u + Math.imul(qe, tt) | 0, b = b + Math.imul(qe, nt) | 0, y = y + Math.imul(He, rt) | 0, u = u + Math.imul(He, it) | 0, u = u + Math.imul(ze, rt) | 0, b = b + Math.imul(ze, it) | 0, y = y + Math.imul(Ge, st) | 0, u = u + Math.imul(Ge, at) | 0, u = u + Math.imul(We, st) | 0, b = b + Math.imul(We, at) | 0, y = y + Math.imul(Ve, ot) | 0, u = u + Math.imul(Ve, ct) | 0, u = u + Math.imul(je, ot) | 0, b = b + Math.imul(je, ct) | 0, y = y + Math.imul(Fe, lt) | 0, u = u + Math.imul(Fe, ut) | 0, u = u + Math.imul(Ue, lt) | 0, b = b + Math.imul(Ue, ut) | 0, y = y + Math.imul(Z, dt) | 0, u = u + Math.imul(Z, ft) | 0, u = u + Math.imul(ue, dt) | 0, b = b + Math.imul(ue, ft) | 0, y = y + Math.imul(z, ht) | 0, u = u + Math.imul(z, pt) | 0, u = u + Math.imul(K, ht) | 0, b = b + Math.imul(K, pt) | 0, y = y + Math.imul($, mt) | 0, u = u + Math.imul($, yt) | 0, u = u + Math.imul(F, mt) | 0, b = b + Math.imul(F, yt) | 0;
      var Yd = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (Yd >>> 26) | 0, Yd &= 67108863, y = Math.imul(Qe, tt), u = Math.imul(Qe, nt), u = u + Math.imul(Je, tt) | 0, b = Math.imul(Je, nt), y = y + Math.imul(Ke, rt) | 0, u = u + Math.imul(Ke, it) | 0, u = u + Math.imul(qe, rt) | 0, b = b + Math.imul(qe, it) | 0, y = y + Math.imul(He, st) | 0, u = u + Math.imul(He, at) | 0, u = u + Math.imul(ze, st) | 0, b = b + Math.imul(ze, at) | 0, y = y + Math.imul(Ge, ot) | 0, u = u + Math.imul(Ge, ct) | 0, u = u + Math.imul(We, ot) | 0, b = b + Math.imul(We, ct) | 0, y = y + Math.imul(Ve, lt) | 0, u = u + Math.imul(Ve, ut) | 0, u = u + Math.imul(je, lt) | 0, b = b + Math.imul(je, ut) | 0, y = y + Math.imul(Fe, dt) | 0, u = u + Math.imul(Fe, ft) | 0, u = u + Math.imul(Ue, dt) | 0, b = b + Math.imul(Ue, ft) | 0, y = y + Math.imul(Z, ht) | 0, u = u + Math.imul(Z, pt) | 0, u = u + Math.imul(ue, ht) | 0, b = b + Math.imul(ue, pt) | 0, y = y + Math.imul(z, mt) | 0, u = u + Math.imul(z, yt) | 0, u = u + Math.imul(K, mt) | 0, b = b + Math.imul(K, yt) | 0;
      var Xd = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (Xd >>> 26) | 0, Xd &= 67108863, y = Math.imul(Qe, rt), u = Math.imul(Qe, it), u = u + Math.imul(Je, rt) | 0, b = Math.imul(Je, it), y = y + Math.imul(Ke, st) | 0, u = u + Math.imul(Ke, at) | 0, u = u + Math.imul(qe, st) | 0, b = b + Math.imul(qe, at) | 0, y = y + Math.imul(He, ot) | 0, u = u + Math.imul(He, ct) | 0, u = u + Math.imul(ze, ot) | 0, b = b + Math.imul(ze, ct) | 0, y = y + Math.imul(Ge, lt) | 0, u = u + Math.imul(Ge, ut) | 0, u = u + Math.imul(We, lt) | 0, b = b + Math.imul(We, ut) | 0, y = y + Math.imul(Ve, dt) | 0, u = u + Math.imul(Ve, ft) | 0, u = u + Math.imul(je, dt) | 0, b = b + Math.imul(je, ft) | 0, y = y + Math.imul(Fe, ht) | 0, u = u + Math.imul(Fe, pt) | 0, u = u + Math.imul(Ue, ht) | 0, b = b + Math.imul(Ue, pt) | 0, y = y + Math.imul(Z, mt) | 0, u = u + Math.imul(Z, yt) | 0, u = u + Math.imul(ue, mt) | 0, b = b + Math.imul(ue, yt) | 0;
      var Zd = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (Zd >>> 26) | 0, Zd &= 67108863, y = Math.imul(Qe, st), u = Math.imul(Qe, at), u = u + Math.imul(Je, st) | 0, b = Math.imul(Je, at), y = y + Math.imul(Ke, ot) | 0, u = u + Math.imul(Ke, ct) | 0, u = u + Math.imul(qe, ot) | 0, b = b + Math.imul(qe, ct) | 0, y = y + Math.imul(He, lt) | 0, u = u + Math.imul(He, ut) | 0, u = u + Math.imul(ze, lt) | 0, b = b + Math.imul(ze, ut) | 0, y = y + Math.imul(Ge, dt) | 0, u = u + Math.imul(Ge, ft) | 0, u = u + Math.imul(We, dt) | 0, b = b + Math.imul(We, ft) | 0, y = y + Math.imul(Ve, ht) | 0, u = u + Math.imul(Ve, pt) | 0, u = u + Math.imul(je, ht) | 0, b = b + Math.imul(je, pt) | 0, y = y + Math.imul(Fe, mt) | 0, u = u + Math.imul(Fe, yt) | 0, u = u + Math.imul(Ue, mt) | 0, b = b + Math.imul(Ue, yt) | 0;
      var ef = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (ef >>> 26) | 0, ef &= 67108863, y = Math.imul(Qe, ot), u = Math.imul(Qe, ct), u = u + Math.imul(Je, ot) | 0, b = Math.imul(Je, ct), y = y + Math.imul(Ke, lt) | 0, u = u + Math.imul(Ke, ut) | 0, u = u + Math.imul(qe, lt) | 0, b = b + Math.imul(qe, ut) | 0, y = y + Math.imul(He, dt) | 0, u = u + Math.imul(He, ft) | 0, u = u + Math.imul(ze, dt) | 0, b = b + Math.imul(ze, ft) | 0, y = y + Math.imul(Ge, ht) | 0, u = u + Math.imul(Ge, pt) | 0, u = u + Math.imul(We, ht) | 0, b = b + Math.imul(We, pt) | 0, y = y + Math.imul(Ve, mt) | 0, u = u + Math.imul(Ve, yt) | 0, u = u + Math.imul(je, mt) | 0, b = b + Math.imul(je, yt) | 0;
      var tf = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (tf >>> 26) | 0, tf &= 67108863, y = Math.imul(Qe, lt), u = Math.imul(Qe, ut), u = u + Math.imul(Je, lt) | 0, b = Math.imul(Je, ut), y = y + Math.imul(Ke, dt) | 0, u = u + Math.imul(Ke, ft) | 0, u = u + Math.imul(qe, dt) | 0, b = b + Math.imul(qe, ft) | 0, y = y + Math.imul(He, ht) | 0, u = u + Math.imul(He, pt) | 0, u = u + Math.imul(ze, ht) | 0, b = b + Math.imul(ze, pt) | 0, y = y + Math.imul(Ge, mt) | 0, u = u + Math.imul(Ge, yt) | 0, u = u + Math.imul(We, mt) | 0, b = b + Math.imul(We, yt) | 0;
      var nf = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (nf >>> 26) | 0, nf &= 67108863, y = Math.imul(Qe, dt), u = Math.imul(Qe, ft), u = u + Math.imul(Je, dt) | 0, b = Math.imul(Je, ft), y = y + Math.imul(Ke, ht) | 0, u = u + Math.imul(Ke, pt) | 0, u = u + Math.imul(qe, ht) | 0, b = b + Math.imul(qe, pt) | 0, y = y + Math.imul(He, mt) | 0, u = u + Math.imul(He, yt) | 0, u = u + Math.imul(ze, mt) | 0, b = b + Math.imul(ze, yt) | 0;
      var rf = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (rf >>> 26) | 0, rf &= 67108863, y = Math.imul(Qe, ht), u = Math.imul(Qe, pt), u = u + Math.imul(Je, ht) | 0, b = Math.imul(Je, pt), y = y + Math.imul(Ke, mt) | 0, u = u + Math.imul(Ke, yt) | 0, u = u + Math.imul(qe, mt) | 0, b = b + Math.imul(qe, yt) | 0;
      var sf = (R + y | 0) + ((u & 8191) << 13) | 0;
      R = (b + (u >>> 13) | 0) + (sf >>> 26) | 0, sf &= 67108863, y = Math.imul(Qe, mt), u = Math.imul(Qe, yt), u = u + Math.imul(Je, mt) | 0, b = Math.imul(Je, yt);
      var af = (R + y | 0) + ((u & 8191) << 13) | 0;
      return R = (b + (u >>> 13) | 0) + (af >>> 26) | 0, af &= 67108863, P[0] = Ui, P[1] = Vi, P[2] = ji, P[3] = Gi, P[4] = Wi, P[5] = zd, P[6] = Kd, P[7] = qd, P[8] = Qd, P[9] = Jd, P[10] = Yd, P[11] = Xd, P[12] = Zd, P[13] = ef, P[14] = tf, P[15] = nf, P[16] = rf, P[17] = sf, P[18] = af, R !== 0 && (P[19] = R, x.length++), x;
    };
    Math.imul || (I = _);
    function B(S, d, m) {
      m.negative = d.negative ^ S.negative, m.length = S.length + d.length;
      for (var x = 0, E = 0, A = 0; A < m.length - 1; A++) {
        var P = E;
        E = 0;
        for (var R = x & 67108863, y = Math.min(A, d.length - 1), u = Math.max(0, A - S.length + 1); u <= y; u++) {
          var b = A - u, k = S.words[b] | 0, h = d.words[u] | 0, M = k * h, L = M & 67108863;
          P = P + (M / 67108864 | 0) | 0, L = L + R | 0, R = L & 67108863, P = P + (L >>> 26) | 0, E += P >>> 26, P &= 67108863;
        }
        m.words[A] = R, x = P, P = E;
      }
      return x !== 0 ? m.words[A] = x : m.length--, m._strip();
    }
    function N(S, d, m) {
      return B(S, d, m);
    }
    s.prototype.mulTo = function(d, m) {
      var x, E = this.length + d.length;
      return this.length === 10 && d.length === 10 ? x = I(this, d, m) : E < 63 ? x = _(this, d, m) : E < 1024 ? x = B(this, d, m) : x = N(this, d, m), x;
    }, s.prototype.mul = function(d) {
      var m = new s(null);
      return m.words = new Array(this.length + d.length), this.mulTo(d, m);
    }, s.prototype.mulf = function(d) {
      var m = new s(null);
      return m.words = new Array(this.length + d.length), N(this, d, m);
    }, s.prototype.imul = function(d) {
      return this.clone().mulTo(d, this);
    }, s.prototype.imuln = function(d) {
      var m = d < 0;
      m && (d = -d), r(typeof d == "number"), r(d < 67108864);
      for (var x = 0, E = 0; E < this.length; E++) {
        var A = (this.words[E] | 0) * d, P = (A & 67108863) + (x & 67108863);
        x >>= 26, x += A / 67108864 | 0, x += P >>> 26, this.words[E] = P & 67108863;
      }
      return x !== 0 && (this.words[E] = x, this.length++), m ? this.ineg() : this;
    }, s.prototype.muln = function(d) {
      return this.clone().imuln(d);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(d) {
      var m = C(d);
      if (m.length === 0)
        return new s(1);
      for (var x = this, E = 0; E < m.length && m[E] === 0; E++, x = x.sqr())
        ;
      if (++E < m.length)
        for (var A = x.sqr(); E < m.length; E++, A = A.sqr())
          m[E] !== 0 && (x = x.mul(A));
      return x;
    }, s.prototype.iushln = function(d) {
      r(typeof d == "number" && d >= 0);
      var m = d % 26, x = (d - m) / 26, E = 67108863 >>> 26 - m << 26 - m, A;
      if (m !== 0) {
        var P = 0;
        for (A = 0; A < this.length; A++) {
          var R = this.words[A] & E, y = (this.words[A] | 0) - R << m;
          this.words[A] = y | P, P = R >>> 26 - m;
        }
        P && (this.words[A] = P, this.length++);
      }
      if (x !== 0) {
        for (A = this.length - 1; A >= 0; A--)
          this.words[A + x] = this.words[A];
        for (A = 0; A < x; A++)
          this.words[A] = 0;
        this.length += x;
      }
      return this._strip();
    }, s.prototype.ishln = function(d) {
      return r(this.negative === 0), this.iushln(d);
    }, s.prototype.iushrn = function(d, m, x) {
      r(typeof d == "number" && d >= 0);
      var E;
      m ? E = (m - m % 26) / 26 : E = 0;
      var A = d % 26, P = Math.min((d - A) / 26, this.length), R = 67108863 ^ 67108863 >>> A << A, y = x;
      if (E -= P, E = Math.max(0, E), y) {
        for (var u = 0; u < P; u++)
          y.words[u] = this.words[u];
        y.length = P;
      }
      if (P !== 0)
        if (this.length > P)
          for (this.length -= P, u = 0; u < this.length; u++)
            this.words[u] = this.words[u + P];
        else
          this.words[0] = 0, this.length = 1;
      var b = 0;
      for (u = this.length - 1; u >= 0 && (b !== 0 || u >= E); u--) {
        var k = this.words[u] | 0;
        this.words[u] = b << 26 - A | k >>> A, b = k & R;
      }
      return y && b !== 0 && (y.words[y.length++] = b), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(d, m, x) {
      return r(this.negative === 0), this.iushrn(d, m, x);
    }, s.prototype.shln = function(d) {
      return this.clone().ishln(d);
    }, s.prototype.ushln = function(d) {
      return this.clone().iushln(d);
    }, s.prototype.shrn = function(d) {
      return this.clone().ishrn(d);
    }, s.prototype.ushrn = function(d) {
      return this.clone().iushrn(d);
    }, s.prototype.testn = function(d) {
      r(typeof d == "number" && d >= 0);
      var m = d % 26, x = (d - m) / 26, E = 1 << m;
      if (this.length <= x)
        return !1;
      var A = this.words[x];
      return !!(A & E);
    }, s.prototype.imaskn = function(d) {
      r(typeof d == "number" && d >= 0);
      var m = d % 26, x = (d - m) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= x)
        return this;
      if (m !== 0 && x++, this.length = Math.min(x, this.length), m !== 0) {
        var E = 67108863 ^ 67108863 >>> m << m;
        this.words[this.length - 1] &= E;
      }
      return this._strip();
    }, s.prototype.maskn = function(d) {
      return this.clone().imaskn(d);
    }, s.prototype.iaddn = function(d) {
      return r(typeof d == "number"), r(d < 67108864), d < 0 ? this.isubn(-d) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= d ? (this.words[0] = d - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(d), this.negative = 1, this) : this._iaddn(d);
    }, s.prototype._iaddn = function(d) {
      this.words[0] += d;
      for (var m = 0; m < this.length && this.words[m] >= 67108864; m++)
        this.words[m] -= 67108864, m === this.length - 1 ? this.words[m + 1] = 1 : this.words[m + 1]++;
      return this.length = Math.max(this.length, m + 1), this;
    }, s.prototype.isubn = function(d) {
      if (r(typeof d == "number"), r(d < 67108864), d < 0)
        return this.iaddn(-d);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(d), this.negative = 1, this;
      if (this.words[0] -= d, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var m = 0; m < this.length && this.words[m] < 0; m++)
          this.words[m] += 67108864, this.words[m + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(d) {
      return this.clone().iaddn(d);
    }, s.prototype.subn = function(d) {
      return this.clone().isubn(d);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(d, m, x) {
      var E = d.length + x, A;
      this._expand(E);
      var P, R = 0;
      for (A = 0; A < d.length; A++) {
        P = (this.words[A + x] | 0) + R;
        var y = (d.words[A] | 0) * m;
        P -= y & 67108863, R = (P >> 26) - (y / 67108864 | 0), this.words[A + x] = P & 67108863;
      }
      for (; A < this.length - x; A++)
        P = (this.words[A + x] | 0) + R, R = P >> 26, this.words[A + x] = P & 67108863;
      if (R === 0)
        return this._strip();
      for (r(R === -1), R = 0, A = 0; A < this.length; A++)
        P = -(this.words[A] | 0) + R, R = P >> 26, this.words[A] = P & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(d, m) {
      var x = this.length - d.length, E = this.clone(), A = d, P = A.words[A.length - 1] | 0, R = this._countBits(P);
      x = 26 - R, x !== 0 && (A = A.ushln(x), E.iushln(x), P = A.words[A.length - 1] | 0);
      var y = E.length - A.length, u;
      if (m !== "mod") {
        u = new s(null), u.length = y + 1, u.words = new Array(u.length);
        for (var b = 0; b < u.length; b++)
          u.words[b] = 0;
      }
      var k = E.clone()._ishlnsubmul(A, 1, y);
      k.negative === 0 && (E = k, u && (u.words[y] = 1));
      for (var h = y - 1; h >= 0; h--) {
        var M = (E.words[A.length + h] | 0) * 67108864 + (E.words[A.length + h - 1] | 0);
        for (M = Math.min(M / P | 0, 67108863), E._ishlnsubmul(A, M, h); E.negative !== 0; )
          M--, E.negative = 0, E._ishlnsubmul(A, 1, h), E.isZero() || (E.negative ^= 1);
        u && (u.words[h] = M);
      }
      return u && u._strip(), E._strip(), m !== "div" && x !== 0 && E.iushrn(x), {
        div: u || null,
        mod: E
      };
    }, s.prototype.divmod = function(d, m, x) {
      if (r(!d.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var E, A, P;
      return this.negative !== 0 && d.negative === 0 ? (P = this.neg().divmod(d, m), m !== "mod" && (E = P.div.neg()), m !== "div" && (A = P.mod.neg(), x && A.negative !== 0 && A.iadd(d)), {
        div: E,
        mod: A
      }) : this.negative === 0 && d.negative !== 0 ? (P = this.divmod(d.neg(), m), m !== "mod" && (E = P.div.neg()), {
        div: E,
        mod: P.mod
      }) : (this.negative & d.negative) !== 0 ? (P = this.neg().divmod(d.neg(), m), m !== "div" && (A = P.mod.neg(), x && A.negative !== 0 && A.isub(d)), {
        div: P.div,
        mod: A
      }) : d.length > this.length || this.cmp(d) < 0 ? {
        div: new s(0),
        mod: this
      } : d.length === 1 ? m === "div" ? {
        div: this.divn(d.words[0]),
        mod: null
      } : m === "mod" ? {
        div: null,
        mod: new s(this.modrn(d.words[0]))
      } : {
        div: this.divn(d.words[0]),
        mod: new s(this.modrn(d.words[0]))
      } : this._wordDiv(d, m);
    }, s.prototype.div = function(d) {
      return this.divmod(d, "div", !1).div;
    }, s.prototype.mod = function(d) {
      return this.divmod(d, "mod", !1).mod;
    }, s.prototype.umod = function(d) {
      return this.divmod(d, "mod", !0).mod;
    }, s.prototype.divRound = function(d) {
      var m = this.divmod(d);
      if (m.mod.isZero())
        return m.div;
      var x = m.div.negative !== 0 ? m.mod.isub(d) : m.mod, E = d.ushrn(1), A = d.andln(1), P = x.cmp(E);
      return P < 0 || A === 1 && P === 0 ? m.div : m.div.negative !== 0 ? m.div.isubn(1) : m.div.iaddn(1);
    }, s.prototype.modrn = function(d) {
      var m = d < 0;
      m && (d = -d), r(d <= 67108863);
      for (var x = (1 << 26) % d, E = 0, A = this.length - 1; A >= 0; A--)
        E = (x * E + (this.words[A] | 0)) % d;
      return m ? -E : E;
    }, s.prototype.modn = function(d) {
      return this.modrn(d);
    }, s.prototype.idivn = function(d) {
      var m = d < 0;
      m && (d = -d), r(d <= 67108863);
      for (var x = 0, E = this.length - 1; E >= 0; E--) {
        var A = (this.words[E] | 0) + x * 67108864;
        this.words[E] = A / d | 0, x = A % d;
      }
      return this._strip(), m ? this.ineg() : this;
    }, s.prototype.divn = function(d) {
      return this.clone().idivn(d);
    }, s.prototype.egcd = function(d) {
      r(d.negative === 0), r(!d.isZero());
      var m = this, x = d.clone();
      m.negative !== 0 ? m = m.umod(d) : m = m.clone();
      for (var E = new s(1), A = new s(0), P = new s(0), R = new s(1), y = 0; m.isEven() && x.isEven(); )
        m.iushrn(1), x.iushrn(1), ++y;
      for (var u = x.clone(), b = m.clone(); !m.isZero(); ) {
        for (var k = 0, h = 1; (m.words[0] & h) === 0 && k < 26; ++k, h <<= 1)
          ;
        if (k > 0)
          for (m.iushrn(k); k-- > 0; )
            (E.isOdd() || A.isOdd()) && (E.iadd(u), A.isub(b)), E.iushrn(1), A.iushrn(1);
        for (var M = 0, L = 1; (x.words[0] & L) === 0 && M < 26; ++M, L <<= 1)
          ;
        if (M > 0)
          for (x.iushrn(M); M-- > 0; )
            (P.isOdd() || R.isOdd()) && (P.iadd(u), R.isub(b)), P.iushrn(1), R.iushrn(1);
        m.cmp(x) >= 0 ? (m.isub(x), E.isub(P), A.isub(R)) : (x.isub(m), P.isub(E), R.isub(A));
      }
      return {
        a: P,
        b: R,
        gcd: x.iushln(y)
      };
    }, s.prototype._invmp = function(d) {
      r(d.negative === 0), r(!d.isZero());
      var m = this, x = d.clone();
      m.negative !== 0 ? m = m.umod(d) : m = m.clone();
      for (var E = new s(1), A = new s(0), P = x.clone(); m.cmpn(1) > 0 && x.cmpn(1) > 0; ) {
        for (var R = 0, y = 1; (m.words[0] & y) === 0 && R < 26; ++R, y <<= 1)
          ;
        if (R > 0)
          for (m.iushrn(R); R-- > 0; )
            E.isOdd() && E.iadd(P), E.iushrn(1);
        for (var u = 0, b = 1; (x.words[0] & b) === 0 && u < 26; ++u, b <<= 1)
          ;
        if (u > 0)
          for (x.iushrn(u); u-- > 0; )
            A.isOdd() && A.iadd(P), A.iushrn(1);
        m.cmp(x) >= 0 ? (m.isub(x), E.isub(A)) : (x.isub(m), A.isub(E));
      }
      var k;
      return m.cmpn(1) === 0 ? k = E : k = A, k.cmpn(0) < 0 && k.iadd(d), k;
    }, s.prototype.gcd = function(d) {
      if (this.isZero())
        return d.abs();
      if (d.isZero())
        return this.abs();
      var m = this.clone(), x = d.clone();
      m.negative = 0, x.negative = 0;
      for (var E = 0; m.isEven() && x.isEven(); E++)
        m.iushrn(1), x.iushrn(1);
      do {
        for (; m.isEven(); )
          m.iushrn(1);
        for (; x.isEven(); )
          x.iushrn(1);
        var A = m.cmp(x);
        if (A < 0) {
          var P = m;
          m = x, x = P;
        } else if (A === 0 || x.cmpn(1) === 0)
          break;
        m.isub(x);
      } while (!0);
      return x.iushln(E);
    }, s.prototype.invm = function(d) {
      return this.egcd(d).a.umod(d);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(d) {
      return this.words[0] & d;
    }, s.prototype.bincn = function(d) {
      r(typeof d == "number");
      var m = d % 26, x = (d - m) / 26, E = 1 << m;
      if (this.length <= x)
        return this._expand(x + 1), this.words[x] |= E, this;
      for (var A = E, P = x; A !== 0 && P < this.length; P++) {
        var R = this.words[P] | 0;
        R += A, A = R >>> 26, R &= 67108863, this.words[P] = R;
      }
      return A !== 0 && (this.words[P] = A, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(d) {
      var m = d < 0;
      if (this.negative !== 0 && !m)
        return -1;
      if (this.negative === 0 && m)
        return 1;
      this._strip();
      var x;
      if (this.length > 1)
        x = 1;
      else {
        m && (d = -d), r(d <= 67108863, "Number is too big");
        var E = this.words[0] | 0;
        x = E === d ? 0 : E < d ? -1 : 1;
      }
      return this.negative !== 0 ? -x | 0 : x;
    }, s.prototype.cmp = function(d) {
      if (this.negative !== 0 && d.negative === 0)
        return -1;
      if (this.negative === 0 && d.negative !== 0)
        return 1;
      var m = this.ucmp(d);
      return this.negative !== 0 ? -m | 0 : m;
    }, s.prototype.ucmp = function(d) {
      if (this.length > d.length)
        return 1;
      if (this.length < d.length)
        return -1;
      for (var m = 0, x = this.length - 1; x >= 0; x--) {
        var E = this.words[x] | 0, A = d.words[x] | 0;
        if (E !== A) {
          E < A ? m = -1 : E > A && (m = 1);
          break;
        }
      }
      return m;
    }, s.prototype.gtn = function(d) {
      return this.cmpn(d) === 1;
    }, s.prototype.gt = function(d) {
      return this.cmp(d) === 1;
    }, s.prototype.gten = function(d) {
      return this.cmpn(d) >= 0;
    }, s.prototype.gte = function(d) {
      return this.cmp(d) >= 0;
    }, s.prototype.ltn = function(d) {
      return this.cmpn(d) === -1;
    }, s.prototype.lt = function(d) {
      return this.cmp(d) === -1;
    }, s.prototype.lten = function(d) {
      return this.cmpn(d) <= 0;
    }, s.prototype.lte = function(d) {
      return this.cmp(d) <= 0;
    }, s.prototype.eqn = function(d) {
      return this.cmpn(d) === 0;
    }, s.prototype.eq = function(d) {
      return this.cmp(d) === 0;
    }, s.red = function(d) {
      return new re(d);
    }, s.prototype.toRed = function(d) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), d.convertTo(this)._forceRed(d);
    }, s.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(d) {
      return this.red = d, this;
    }, s.prototype.forceRed = function(d) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(d);
    }, s.prototype.redAdd = function(d) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, d);
    }, s.prototype.redIAdd = function(d) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, d);
    }, s.prototype.redSub = function(d) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, d);
    }, s.prototype.redISub = function(d) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, d);
    }, s.prototype.redShl = function(d) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, d);
    }, s.prototype.redMul = function(d) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, d), this.red.mul(this, d);
    }, s.prototype.redIMul = function(d) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, d), this.red.imul(this, d);
    }, s.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(d) {
      return r(this.red && !d.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, d);
    };
    var D = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function U(S, d) {
      this.name = S, this.p = new s(d, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    U.prototype._tmp = function() {
      var d = new s(null);
      return d.words = new Array(Math.ceil(this.n / 13)), d;
    }, U.prototype.ireduce = function(d) {
      var m = d, x;
      do
        this.split(m, this.tmp), m = this.imulK(m), m = m.iadd(this.tmp), x = m.bitLength();
      while (x > this.n);
      var E = x < this.n ? -1 : m.ucmp(this.p);
      return E === 0 ? (m.words[0] = 0, m.length = 1) : E > 0 ? m.isub(this.p) : m.strip !== void 0 ? m.strip() : m._strip(), m;
    }, U.prototype.split = function(d, m) {
      d.iushrn(this.n, 0, m);
    }, U.prototype.imulK = function(d) {
      return d.imul(this.k);
    };
    function W() {
      U.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(W, U), W.prototype.split = function(d, m) {
      for (var x = 4194303, E = Math.min(d.length, 9), A = 0; A < E; A++)
        m.words[A] = d.words[A];
      if (m.length = E, d.length <= 9) {
        d.words[0] = 0, d.length = 1;
        return;
      }
      var P = d.words[9];
      for (m.words[m.length++] = P & x, A = 10; A < d.length; A++) {
        var R = d.words[A] | 0;
        d.words[A - 10] = (R & x) << 4 | P >>> 22, P = R;
      }
      P >>>= 22, d.words[A - 10] = P, P === 0 && d.length > 10 ? d.length -= 10 : d.length -= 9;
    }, W.prototype.imulK = function(d) {
      d.words[d.length] = 0, d.words[d.length + 1] = 0, d.length += 2;
      for (var m = 0, x = 0; x < d.length; x++) {
        var E = d.words[x] | 0;
        m += E * 977, d.words[x] = m & 67108863, m = E * 64 + (m / 67108864 | 0);
      }
      return d.words[d.length - 1] === 0 && (d.length--, d.words[d.length - 1] === 0 && d.length--), d;
    };
    function j() {
      U.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(j, U);
    function q() {
      U.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(q, U);
    function ce() {
      U.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(ce, U), ce.prototype.imulK = function(d) {
      for (var m = 0, x = 0; x < d.length; x++) {
        var E = (d.words[x] | 0) * 19 + m, A = E & 67108863;
        E >>>= 26, d.words[x] = A, m = E;
      }
      return m !== 0 && (d.words[d.length++] = m), d;
    }, s._prime = function(d) {
      if (D[d])
        return D[d];
      var m;
      if (d === "k256")
        m = new W();
      else if (d === "p224")
        m = new j();
      else if (d === "p192")
        m = new q();
      else if (d === "p25519")
        m = new ce();
      else
        throw new Error("Unknown prime " + d);
      return D[d] = m, m;
    };
    function re(S) {
      if (typeof S == "string") {
        var d = s._prime(S);
        this.m = d.p, this.prime = d;
      } else
        r(S.gtn(1), "modulus must be greater than 1"), this.m = S, this.prime = null;
    }
    re.prototype._verify1 = function(d) {
      r(d.negative === 0, "red works only with positives"), r(d.red, "red works only with red numbers");
    }, re.prototype._verify2 = function(d, m) {
      r((d.negative | m.negative) === 0, "red works only with positives"), r(
        d.red && d.red === m.red,
        "red works only with red numbers"
      );
    }, re.prototype.imod = function(d) {
      return this.prime ? this.prime.ireduce(d)._forceRed(this) : (f(d, d.umod(this.m)._forceRed(this)), d);
    }, re.prototype.neg = function(d) {
      return d.isZero() ? d.clone() : this.m.sub(d)._forceRed(this);
    }, re.prototype.add = function(d, m) {
      this._verify2(d, m);
      var x = d.add(m);
      return x.cmp(this.m) >= 0 && x.isub(this.m), x._forceRed(this);
    }, re.prototype.iadd = function(d, m) {
      this._verify2(d, m);
      var x = d.iadd(m);
      return x.cmp(this.m) >= 0 && x.isub(this.m), x;
    }, re.prototype.sub = function(d, m) {
      this._verify2(d, m);
      var x = d.sub(m);
      return x.cmpn(0) < 0 && x.iadd(this.m), x._forceRed(this);
    }, re.prototype.isub = function(d, m) {
      this._verify2(d, m);
      var x = d.isub(m);
      return x.cmpn(0) < 0 && x.iadd(this.m), x;
    }, re.prototype.shl = function(d, m) {
      return this._verify1(d), this.imod(d.ushln(m));
    }, re.prototype.imul = function(d, m) {
      return this._verify2(d, m), this.imod(d.imul(m));
    }, re.prototype.mul = function(d, m) {
      return this._verify2(d, m), this.imod(d.mul(m));
    }, re.prototype.isqr = function(d) {
      return this.imul(d, d.clone());
    }, re.prototype.sqr = function(d) {
      return this.mul(d, d);
    }, re.prototype.sqrt = function(d) {
      if (d.isZero())
        return d.clone();
      var m = this.m.andln(3);
      if (r(m % 2 === 1), m === 3) {
        var x = this.m.add(new s(1)).iushrn(2);
        return this.pow(d, x);
      }
      for (var E = this.m.subn(1), A = 0; !E.isZero() && E.andln(1) === 0; )
        A++, E.iushrn(1);
      r(!E.isZero());
      var P = new s(1).toRed(this), R = P.redNeg(), y = this.m.subn(1).iushrn(1), u = this.m.bitLength();
      for (u = new s(2 * u * u).toRed(this); this.pow(u, y).cmp(R) !== 0; )
        u.redIAdd(R);
      for (var b = this.pow(u, E), k = this.pow(d, E.addn(1).iushrn(1)), h = this.pow(d, E), M = A; h.cmp(P) !== 0; ) {
        for (var L = h, $ = 0; L.cmp(P) !== 0; $++)
          L = L.redSqr();
        r($ < M);
        var F = this.pow(b, new s(1).iushln(M - $ - 1));
        k = k.redMul(F), b = F.redSqr(), h = h.redMul(b), M = $;
      }
      return k;
    }, re.prototype.invm = function(d) {
      var m = d._invmp(this.m);
      return m.negative !== 0 ? (m.negative = 0, this.imod(m).redNeg()) : this.imod(m);
    }, re.prototype.pow = function(d, m) {
      if (m.isZero())
        return new s(1).toRed(this);
      if (m.cmpn(1) === 0)
        return d.clone();
      var x = 4, E = new Array(1 << x);
      E[0] = new s(1).toRed(this), E[1] = d;
      for (var A = 2; A < E.length; A++)
        E[A] = this.mul(E[A - 1], d);
      var P = E[0], R = 0, y = 0, u = m.bitLength() % 26;
      for (u === 0 && (u = 26), A = m.length - 1; A >= 0; A--) {
        for (var b = m.words[A], k = u - 1; k >= 0; k--) {
          var h = b >> k & 1;
          if (P !== E[0] && (P = this.sqr(P)), h === 0 && R === 0) {
            y = 0;
            continue;
          }
          R <<= 1, R |= h, y++, !(y !== x && (A !== 0 || k !== 0)) && (P = this.mul(P, E[R]), y = 0, R = 0);
        }
        u = 26;
      }
      return P;
    }, re.prototype.convertTo = function(d) {
      var m = d.umod(this.m);
      return m === d ? m.clone() : m;
    }, re.prototype.convertFrom = function(d) {
      var m = d.clone();
      return m.red = null, m;
    }, s.mont = function(d) {
      return new me(d);
    };
    function me(S) {
      re.call(this, S), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(me, re), me.prototype.convertTo = function(d) {
      return this.imod(d.ushln(this.shift));
    }, me.prototype.convertFrom = function(d) {
      var m = this.imod(d.mul(this.rinv));
      return m.red = null, m;
    }, me.prototype.imul = function(d, m) {
      if (d.isZero() || m.isZero())
        return d.words[0] = 0, d.length = 1, d;
      var x = d.imul(m), E = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = x.isub(E).iushrn(this.shift), P = A;
      return A.cmp(this.m) >= 0 ? P = A.isub(this.m) : A.cmpn(0) < 0 && (P = A.iadd(this.m)), P._forceRed(this);
    }, me.prototype.mul = function(d, m) {
      if (d.isZero() || m.isZero())
        return new s(0)._forceRed(this);
      var x = d.mul(m), E = x.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = x.isub(E).iushrn(this.shift), P = A;
      return A.cmp(this.m) >= 0 ? P = A.isub(this.m) : A.cmpn(0) < 0 && (P = A.iadd(this.m)), P._forceRed(this);
    }, me.prototype.invm = function(d) {
      var m = this.imod(d._invmp(this.m).mul(this.r2));
      return m._forceRed(this);
    };
  })(n, Kv);
})(qv);
const de = qv.exports, J8 = "logger/5.7.0";
let Mg = !1, Rg = !1;
const ql = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let kg = ql.default, Pf = null;
function Y8() {
  try {
    const n = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
      try {
        if ("test".normalize(e) !== "test")
          throw new Error("bad normalize");
      } catch {
        n.push(e);
      }
    }), n.length)
      throw new Error("missing " + n.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (n) {
    return n.message;
  }
  return null;
}
const Ig = Y8();
var Rh;
(function(n) {
  n.DEBUG = "DEBUG", n.INFO = "INFO", n.WARNING = "WARNING", n.ERROR = "ERROR", n.OFF = "OFF";
})(Rh || (Rh = {}));
var xr;
(function(n) {
  n.UNKNOWN_ERROR = "UNKNOWN_ERROR", n.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", n.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", n.NETWORK_ERROR = "NETWORK_ERROR", n.SERVER_ERROR = "SERVER_ERROR", n.TIMEOUT = "TIMEOUT", n.BUFFER_OVERRUN = "BUFFER_OVERRUN", n.NUMERIC_FAULT = "NUMERIC_FAULT", n.MISSING_NEW = "MISSING_NEW", n.INVALID_ARGUMENT = "INVALID_ARGUMENT", n.MISSING_ARGUMENT = "MISSING_ARGUMENT", n.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", n.CALL_EXCEPTION = "CALL_EXCEPTION", n.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", n.NONCE_EXPIRED = "NONCE_EXPIRED", n.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", n.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", n.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", n.ACTION_REJECTED = "ACTION_REJECTED";
})(xr || (xr = {}));
const Og = "0123456789abcdef";
class O {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1
    });
  }
  _log(e, t) {
    const r = e.toLowerCase();
    ql[r] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(kg > ql[r]) && console.log.apply(console, t);
  }
  debug(...e) {
    this._log(O.levels.DEBUG, e);
  }
  info(...e) {
    this._log(O.levels.INFO, e);
  }
  warn(...e) {
    this._log(O.levels.WARNING, e);
  }
  makeError(e, t, r) {
    if (Rg)
      return this.makeError("censored error", t, {});
    t || (t = O.errors.UNKNOWN_ERROR), r || (r = {});
    const i = [];
    Object.keys(r).forEach((c) => {
      const l = r[c];
      try {
        if (l instanceof Uint8Array) {
          let f = "";
          for (let p = 0; p < l.length; p++)
            f += Og[l[p] >> 4], f += Og[l[p] & 15];
          i.push(c + "=Uint8Array(0x" + f + ")");
        } else
          i.push(c + "=" + JSON.stringify(l));
      } catch {
        i.push(c + "=" + JSON.stringify(r[c].toString()));
      }
    }), i.push(`code=${t}`), i.push(`version=${this.version}`);
    const s = e;
    let a = "";
    switch (t) {
      case xr.NUMERIC_FAULT: {
        a = "NUMERIC_FAULT";
        const c = e;
        switch (c) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            a += "-" + c;
            break;
          case "negative-power":
          case "negative-width":
            a += "-unsupported";
            break;
          case "unbound-bitwise-result":
            a += "-unbound-result";
            break;
        }
        break;
      }
      case xr.CALL_EXCEPTION:
      case xr.INSUFFICIENT_FUNDS:
      case xr.MISSING_NEW:
      case xr.NONCE_EXPIRED:
      case xr.REPLACEMENT_UNDERPRICED:
      case xr.TRANSACTION_REPLACED:
      case xr.UNPREDICTABLE_GAS_LIMIT:
        a = t;
        break;
    }
    a && (e += " [ See: https://links.ethers.org/v5-errors-" + a + " ]"), i.length && (e += " (" + i.join(", ") + ")");
    const o = new Error(e);
    return o.reason = s, o.code = t, Object.keys(r).forEach(function(c) {
      o[c] = r[c];
    }), o;
  }
  throwError(e, t, r) {
    throw this.makeError(e, t, r);
  }
  throwArgumentError(e, t, r) {
    return this.throwError(e, O.errors.INVALID_ARGUMENT, {
      argument: t,
      value: r
    });
  }
  assert(e, t, r, i) {
    e || this.throwError(t, r, i);
  }
  assertArgument(e, t, r, i) {
    e || this.throwArgumentError(t, r, i);
  }
  checkNormalize(e) {
    Ig && this.throwError("platform missing String.prototype.normalize", O.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: Ig
    });
  }
  checkSafeUint53(e, t) {
    typeof e == "number" && (t == null && (t = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(t, O.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: e
    }), e % 1 && this.throwError(t, O.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: e
    }));
  }
  checkArgumentCount(e, t, r) {
    r ? r = ": " + r : r = "", e < t && this.throwError("missing argument" + r, O.errors.MISSING_ARGUMENT, {
      count: e,
      expectedCount: t
    }), e > t && this.throwError("too many arguments" + r, O.errors.UNEXPECTED_ARGUMENT, {
      count: e,
      expectedCount: t
    });
  }
  checkNew(e, t) {
    (e === Object || e == null) && this.throwError("missing new", O.errors.MISSING_NEW, { name: t.name });
  }
  checkAbstract(e, t) {
    e === t ? this.throwError("cannot instantiate abstract class " + JSON.stringify(t.name) + " directly; use a sub-class", O.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: "new" }) : (e === Object || e == null) && this.throwError("missing new", O.errors.MISSING_NEW, { name: t.name });
  }
  static globalLogger() {
    return Pf || (Pf = new O(J8)), Pf;
  }
  static setCensorship(e, t) {
    if (!e && t && this.globalLogger().throwError("cannot permanently disable censorship", O.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), Mg) {
      if (!e)
        return;
      this.globalLogger().throwError("error censorship permanent", O.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    Rg = !!e, Mg = !!t;
  }
  static setLogLevel(e) {
    const t = ql[e.toLowerCase()];
    if (t == null) {
      O.globalLogger().warn("invalid log level - " + e);
      return;
    }
    kg = t;
  }
  static from(e) {
    return new O(e);
  }
}
O.errors = xr;
O.levels = Rh;
const X8 = "bytes/5.7.0", Et = new O(X8);
function Qv(n) {
  return !!n.toHexString;
}
function Va(n) {
  return n.slice || (n.slice = function() {
    const e = Array.prototype.slice.call(arguments);
    return Va(new Uint8Array(Array.prototype.slice.apply(n, e)));
  }), n;
}
function sp(n) {
  return Pe(n) && !(n.length % 2) || vo(n);
}
function Dg(n) {
  return typeof n == "number" && n == n && n % 1 === 0;
}
function vo(n) {
  if (n == null)
    return !1;
  if (n.constructor === Uint8Array)
    return !0;
  if (typeof n == "string" || !Dg(n.length) || n.length < 0)
    return !1;
  for (let e = 0; e < n.length; e++) {
    const t = n[e];
    if (!Dg(t) || t < 0 || t >= 256)
      return !1;
  }
  return !0;
}
function ae(n, e) {
  if (e || (e = {}), typeof n == "number") {
    Et.checkSafeUint53(n, "invalid arrayify value");
    const t = [];
    for (; n; )
      t.unshift(n & 255), n = parseInt(String(n / 256));
    return t.length === 0 && t.push(0), Va(new Uint8Array(t));
  }
  if (e.allowMissingPrefix && typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), Qv(n) && (n = n.toHexString()), Pe(n)) {
    let t = n.substring(2);
    t.length % 2 && (e.hexPad === "left" ? t = "0" + t : e.hexPad === "right" ? t += "0" : Et.throwArgumentError("hex data is odd-length", "value", n));
    const r = [];
    for (let i = 0; i < t.length; i += 2)
      r.push(parseInt(t.substring(i, i + 2), 16));
    return Va(new Uint8Array(r));
  }
  return vo(n) ? Va(new Uint8Array(n)) : Et.throwArgumentError("invalid arrayify value", "value", n);
}
function zn(n) {
  const e = n.map((i) => ae(i)), t = e.reduce((i, s) => i + s.length, 0), r = new Uint8Array(t);
  return e.reduce((i, s) => (r.set(s, i), i + s.length), 0), Va(r);
}
function Xa(n) {
  let e = ae(n);
  if (e.length === 0)
    return e;
  let t = 0;
  for (; t < e.length && e[t] === 0; )
    t++;
  return t && (e = e.slice(t)), e;
}
function Z8(n, e) {
  n = ae(n), n.length > e && Et.throwArgumentError("value out of range", "value", arguments[0]);
  const t = new Uint8Array(e);
  return t.set(n, e - n.length), Va(t);
}
function Pe(n, e) {
  return !(typeof n != "string" || !n.match(/^0x[0-9A-Fa-f]*$/) || e && n.length !== 2 + 2 * e);
}
const Mf = "0123456789abcdef";
function te(n, e) {
  if (e || (e = {}), typeof n == "number") {
    Et.checkSafeUint53(n, "invalid hexlify value");
    let t = "";
    for (; n; )
      t = Mf[n & 15] + t, n = Math.floor(n / 16);
    return t.length ? (t.length % 2 && (t = "0" + t), "0x" + t) : "0x00";
  }
  if (typeof n == "bigint")
    return n = n.toString(16), n.length % 2 ? "0x0" + n : "0x" + n;
  if (e.allowMissingPrefix && typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), Qv(n))
    return n.toHexString();
  if (Pe(n))
    return n.length % 2 && (e.hexPad === "left" ? n = "0x0" + n.substring(2) : e.hexPad === "right" ? n += "0" : Et.throwArgumentError("hex data is odd-length", "value", n)), n.toLowerCase();
  if (vo(n)) {
    let t = "0x";
    for (let r = 0; r < n.length; r++) {
      let i = n[r];
      t += Mf[(i & 240) >> 4] + Mf[i & 15];
    }
    return t;
  }
  return Et.throwArgumentError("invalid hexlify value", "value", n);
}
function ea(n) {
  if (typeof n != "string")
    n = te(n);
  else if (!Pe(n) || n.length % 2)
    return null;
  return (n.length - 2) / 2;
}
function an(n, e, t) {
  return typeof n != "string" ? n = te(n) : (!Pe(n) || n.length % 2) && Et.throwArgumentError("invalid hexData", "value", n), e = 2 + 2 * e, t != null ? "0x" + n.substring(e, 2 + 2 * t) : "0x" + n.substring(e);
}
function Pn(n) {
  let e = "0x";
  return n.forEach((t) => {
    e += te(t).substring(2);
  }), e;
}
function ap(n) {
  const e = eC(te(n, { hexPad: "left" }));
  return e === "0x" ? "0x0" : e;
}
function eC(n) {
  typeof n != "string" && (n = te(n)), Pe(n) || Et.throwArgumentError("invalid hex string", "value", n), n = n.substring(2);
  let e = 0;
  for (; e < n.length && n[e] === "0"; )
    e++;
  return "0x" + n.substring(e);
}
function Le(n, e) {
  for (typeof n != "string" ? n = te(n) : Pe(n) || Et.throwArgumentError("invalid hex string", "value", n), n.length > 2 * e + 2 && Et.throwArgumentError("value out of range", "value", arguments[1]); n.length < 2 * e + 2; )
    n = "0x0" + n.substring(2);
  return n;
}
function vd(n) {
  const e = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (sp(n)) {
    let t = ae(n);
    t.length === 64 ? (e.v = 27 + (t[32] >> 7), t[32] &= 127, e.r = te(t.slice(0, 32)), e.s = te(t.slice(32, 64))) : t.length === 65 ? (e.r = te(t.slice(0, 32)), e.s = te(t.slice(32, 64)), e.v = t[64]) : Et.throwArgumentError("invalid signature string", "signature", n), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : Et.throwArgumentError("signature invalid v byte", "signature", n)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (t[32] |= 128), e._vs = te(t.slice(32, 64));
  } else {
    if (e.r = n.r, e.s = n.s, e.v = n.v, e.recoveryParam = n.recoveryParam, e._vs = n._vs, e._vs != null) {
      const i = Z8(ae(e._vs), 32);
      e._vs = te(i);
      const s = i[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && Et.throwArgumentError("signature recoveryParam mismatch _vs", "signature", n), i[0] &= 127;
      const a = te(i);
      e.s == null ? e.s = a : e.s !== a && Et.throwArgumentError("signature v mismatch _vs", "signature", n);
    }
    if (e.recoveryParam == null)
      e.v == null ? Et.throwArgumentError("signature missing v and recoveryParam", "signature", n) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
    else if (e.v == null)
      e.v = 27 + e.recoveryParam;
    else {
      const i = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
      e.recoveryParam !== i && Et.throwArgumentError("signature recoveryParam mismatch v", "signature", n);
    }
    e.r == null || !Pe(e.r) ? Et.throwArgumentError("signature missing or invalid r", "signature", n) : e.r = Le(e.r, 32), e.s == null || !Pe(e.s) ? Et.throwArgumentError("signature missing or invalid s", "signature", n) : e.s = Le(e.s, 32);
    const t = ae(e.s);
    t[0] >= 128 && Et.throwArgumentError("signature s out of range", "signature", n), e.recoveryParam && (t[0] |= 128);
    const r = te(t);
    e._vs && (Pe(e._vs) || Et.throwArgumentError("signature invalid _vs", "signature", n), e._vs = Le(e._vs, 32)), e._vs == null ? e._vs = r : e._vs !== r && Et.throwArgumentError("signature _vs mismatch v and s", "signature", n);
  }
  return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
}
const Jv = "bignumber/5.7.0";
var Su = de.BN;
const oi = new O(Jv), Rf = {}, Ng = 9007199254740991;
function tC(n) {
  return n != null && (G.isBigNumber(n) || typeof n == "number" && n % 1 === 0 || typeof n == "string" && !!n.match(/^-?[0-9]+$/) || Pe(n) || typeof n == "bigint" || vo(n));
}
let Bg = !1;
class G {
  constructor(e, t) {
    e !== Rf && oi.throwError("cannot call constructor directly; use BigNumber.from", O.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = t, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(e) {
    return En(be(this).fromTwos(e));
  }
  toTwos(e) {
    return En(be(this).toTwos(e));
  }
  abs() {
    return this._hex[0] === "-" ? G.from(this._hex.substring(1)) : this;
  }
  add(e) {
    return En(be(this).add(be(e)));
  }
  sub(e) {
    return En(be(this).sub(be(e)));
  }
  div(e) {
    return G.from(e).isZero() && er("division-by-zero", "div"), En(be(this).div(be(e)));
  }
  mul(e) {
    return En(be(this).mul(be(e)));
  }
  mod(e) {
    const t = be(e);
    return t.isNeg() && er("division-by-zero", "mod"), En(be(this).umod(t));
  }
  pow(e) {
    const t = be(e);
    return t.isNeg() && er("negative-power", "pow"), En(be(this).pow(t));
  }
  and(e) {
    const t = be(e);
    return (this.isNegative() || t.isNeg()) && er("unbound-bitwise-result", "and"), En(be(this).and(t));
  }
  or(e) {
    const t = be(e);
    return (this.isNegative() || t.isNeg()) && er("unbound-bitwise-result", "or"), En(be(this).or(t));
  }
  xor(e) {
    const t = be(e);
    return (this.isNegative() || t.isNeg()) && er("unbound-bitwise-result", "xor"), En(be(this).xor(t));
  }
  mask(e) {
    return (this.isNegative() || e < 0) && er("negative-width", "mask"), En(be(this).maskn(e));
  }
  shl(e) {
    return (this.isNegative() || e < 0) && er("negative-width", "shl"), En(be(this).shln(e));
  }
  shr(e) {
    return (this.isNegative() || e < 0) && er("negative-width", "shr"), En(be(this).shrn(e));
  }
  eq(e) {
    return be(this).eq(be(e));
  }
  lt(e) {
    return be(this).lt(be(e));
  }
  lte(e) {
    return be(this).lte(be(e));
  }
  gt(e) {
    return be(this).gt(be(e));
  }
  gte(e) {
    return be(this).gte(be(e));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return be(this).isZero();
  }
  toNumber() {
    try {
      return be(this).toNumber();
    } catch {
      er("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return oi.throwError("this platform does not support BigInt", O.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? Bg || (Bg = !0, oi.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? oi.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", O.errors.UNEXPECTED_ARGUMENT, {}) : oi.throwError("BigNumber.toString does not accept parameters", O.errors.UNEXPECTED_ARGUMENT, {})), be(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(e) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(e) {
    if (e instanceof G)
      return e;
    if (typeof e == "string")
      return e.match(/^-?0x[0-9a-f]+$/i) ? new G(Rf, wc(e)) : e.match(/^-?[0-9]+$/) ? new G(Rf, wc(new Su(e))) : oi.throwArgumentError("invalid BigNumber string", "value", e);
    if (typeof e == "number")
      return e % 1 && er("underflow", "BigNumber.from", e), (e >= Ng || e <= -Ng) && er("overflow", "BigNumber.from", e), G.from(String(e));
    const t = e;
    if (typeof t == "bigint")
      return G.from(t.toString());
    if (vo(t))
      return G.from(te(t));
    if (t)
      if (t.toHexString) {
        const r = t.toHexString();
        if (typeof r == "string")
          return G.from(r);
      } else {
        let r = t._hex;
        if (r == null && t.type === "BigNumber" && (r = t.hex), typeof r == "string" && (Pe(r) || r[0] === "-" && Pe(r.substring(1))))
          return G.from(r);
      }
    return oi.throwArgumentError("invalid BigNumber value", "value", e);
  }
  static isBigNumber(e) {
    return !!(e && e._isBigNumber);
  }
}
function wc(n) {
  if (typeof n != "string")
    return wc(n.toString(16));
  if (n[0] === "-")
    return n = n.substring(1), n[0] === "-" && oi.throwArgumentError("invalid hex", "value", n), n = wc(n), n === "0x00" ? n : "-" + n;
  if (n.substring(0, 2) !== "0x" && (n = "0x" + n), n === "0x")
    return "0x00";
  for (n.length % 2 && (n = "0x0" + n.substring(2)); n.length > 4 && n.substring(0, 4) === "0x00"; )
    n = "0x" + n.substring(4);
  return n;
}
function En(n) {
  return G.from(wc(n));
}
function be(n) {
  const e = G.from(n).toHexString();
  return e[0] === "-" ? new Su("-" + e.substring(3), 16) : new Su(e.substring(2), 16);
}
function er(n, e, t) {
  const r = { fault: n, operation: e };
  return t != null && (r.value = t), oi.throwError(n, O.errors.NUMERIC_FAULT, r);
}
function nC(n) {
  return new Su(n, 36).toString(16);
}
const xn = new O(Jv), rc = {}, Yv = G.from(0), Xv = G.from(-1);
function Zv(n, e, t, r) {
  const i = { fault: e, operation: t };
  return r !== void 0 && (i.value = r), xn.throwError(n, O.errors.NUMERIC_FAULT, i);
}
let ic = "0";
for (; ic.length < 256; )
  ic += ic;
function op(n) {
  if (typeof n != "number")
    try {
      n = G.from(n).toNumber();
    } catch {
    }
  return typeof n == "number" && n >= 0 && n <= 256 && !(n % 1) ? "1" + ic.substring(0, n) : xn.throwArgumentError("invalid decimal size", "decimals", n);
}
function Ql(n, e) {
  e == null && (e = 0);
  const t = op(e);
  n = G.from(n);
  const r = n.lt(Yv);
  r && (n = n.mul(Xv));
  let i = n.mod(t).toString();
  for (; i.length < t.length - 1; )
    i = "0" + i;
  i = i.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const s = n.div(t).toString();
  return t.length === 1 ? n = s : n = s + "." + i, r && (n = "-" + n), n;
}
function Or(n, e) {
  e == null && (e = 0);
  const t = op(e);
  (typeof n != "string" || !n.match(/^-?[0-9.]+$/)) && xn.throwArgumentError("invalid decimal value", "value", n);
  const r = n.substring(0, 1) === "-";
  r && (n = n.substring(1)), n === "." && xn.throwArgumentError("missing value", "value", n);
  const i = n.split(".");
  i.length > 2 && xn.throwArgumentError("too many decimal points", "value", n);
  let s = i[0], a = i[1];
  for (s || (s = "0"), a || (a = "0"); a[a.length - 1] === "0"; )
    a = a.substring(0, a.length - 1);
  for (a.length > t.length - 1 && Zv("fractional component exceeds decimals", "underflow", "parseFixed"), a === "" && (a = "0"); a.length < t.length - 1; )
    a += "0";
  const o = G.from(s), c = G.from(a);
  let l = o.mul(t).add(c);
  return r && (l = l.mul(Xv)), l;
}
class ja {
  constructor(e, t, r, i) {
    e !== rc && xn.throwError("cannot use FixedFormat constructor; use FixedFormat.from", O.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.signed = t, this.width = r, this.decimals = i, this.name = (t ? "" : "u") + "fixed" + String(r) + "x" + String(i), this._multiplier = op(i), Object.freeze(this);
  }
  static from(e) {
    if (e instanceof ja)
      return e;
    typeof e == "number" && (e = `fixed128x${e}`);
    let t = !0, r = 128, i = 18;
    if (typeof e == "string") {
      if (e !== "fixed")
        if (e === "ufixed")
          t = !1;
        else {
          const s = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          s || xn.throwArgumentError("invalid fixed format", "format", e), t = s[1] !== "u", r = parseInt(s[2]), i = parseInt(s[3]);
        }
    } else if (e) {
      const s = (a, o, c) => e[a] == null ? c : (typeof e[a] !== o && xn.throwArgumentError("invalid fixed format (" + a + " not " + o + ")", "format." + a, e[a]), e[a]);
      t = s("signed", "boolean", t), r = s("width", "number", r), i = s("decimals", "number", i);
    }
    return r % 8 && xn.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", r), i > 80 && xn.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", i), new ja(rc, t, r, i);
  }
}
class Kt {
  constructor(e, t, r, i) {
    e !== rc && xn.throwError("cannot use FixedNumber constructor; use FixedNumber.from", O.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.format = i, this._hex = t, this._value = r, this._isFixedNumber = !0, Object.freeze(this);
  }
  _checkFormat(e) {
    this.format.name !== e.format.name && xn.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", e);
  }
  addUnsafe(e) {
    this._checkFormat(e);
    const t = Or(this._value, this.format.decimals), r = Or(e._value, e.format.decimals);
    return Kt.fromValue(t.add(r), this.format.decimals, this.format);
  }
  subUnsafe(e) {
    this._checkFormat(e);
    const t = Or(this._value, this.format.decimals), r = Or(e._value, e.format.decimals);
    return Kt.fromValue(t.sub(r), this.format.decimals, this.format);
  }
  mulUnsafe(e) {
    this._checkFormat(e);
    const t = Or(this._value, this.format.decimals), r = Or(e._value, e.format.decimals);
    return Kt.fromValue(t.mul(r).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(e) {
    this._checkFormat(e);
    const t = Or(this._value, this.format.decimals), r = Or(e._value, e.format.decimals);
    return Kt.fromValue(t.mul(this.format._multiplier).div(r), this.format.decimals, this.format);
  }
  floor() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let t = Kt.from(e[0], this.format);
    const r = !e[1].match(/^(0*)$/);
    return this.isNegative() && r && (t = t.subUnsafe($g.toFormat(t.format))), t;
  }
  ceiling() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let t = Kt.from(e[0], this.format);
    const r = !e[1].match(/^(0*)$/);
    return !this.isNegative() && r && (t = t.addUnsafe($g.toFormat(t.format))), t;
  }
  round(e) {
    e == null && (e = 0);
    const t = this.toString().split(".");
    if (t.length === 1 && t.push("0"), (e < 0 || e > 80 || e % 1) && xn.throwArgumentError("invalid decimal count", "decimals", e), t[1].length <= e)
      return this;
    const r = Kt.from("1" + ic.substring(0, e), this.format), i = rC.toFormat(this.format);
    return this.mulUnsafe(r).addUnsafe(i).floor().divUnsafe(r);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(e) {
    if (e == null)
      return this._hex;
    e % 8 && xn.throwArgumentError("invalid byte width", "width", e);
    const t = G.from(this._hex).fromTwos(this.format.width).toTwos(e).toHexString();
    return Le(t, e / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(e) {
    return Kt.fromString(this._value, e);
  }
  static fromValue(e, t, r) {
    return r == null && t != null && !tC(t) && (r = t, t = null), t == null && (t = 0), r == null && (r = "fixed"), Kt.fromString(Ql(e, t), ja.from(r));
  }
  static fromString(e, t) {
    t == null && (t = "fixed");
    const r = ja.from(t), i = Or(e, r.decimals);
    !r.signed && i.lt(Yv) && Zv("unsigned value cannot be negative", "overflow", "value", e);
    let s = null;
    r.signed ? s = i.toTwos(r.width).toHexString() : (s = i.toHexString(), s = Le(s, r.width / 8));
    const a = Ql(i, r.decimals);
    return new Kt(rc, s, a, r);
  }
  static fromBytes(e, t) {
    t == null && (t = "fixed");
    const r = ja.from(t);
    if (ae(e).length > r.width / 8)
      throw new Error("overflow");
    let i = G.from(e);
    r.signed && (i = i.fromTwos(r.width));
    const s = i.toTwos((r.signed ? 0 : 1) + r.width).toHexString(), a = Ql(i, r.decimals);
    return new Kt(rc, s, a, r);
  }
  static from(e, t) {
    if (typeof e == "string")
      return Kt.fromString(e, t);
    if (vo(e))
      return Kt.fromBytes(e, t);
    try {
      return Kt.fromValue(e, 0, t);
    } catch (r) {
      if (r.code !== O.errors.INVALID_ARGUMENT)
        throw r;
    }
    return xn.throwArgumentError("invalid FixedNumber value", "value", e);
  }
  static isFixedNumber(e) {
    return !!(e && e._isFixedNumber);
  }
}
const $g = Kt.from(1), rC = Kt.from("0.5"), iC = "properties/5.7.0";
var sC = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const _u = new O(iC);
function H(n, e, t) {
  Object.defineProperty(n, e, {
    enumerable: !0,
    value: t,
    writable: !1
  });
}
function jr(n, e) {
  for (let t = 0; t < 32; t++) {
    if (n[e])
      return n[e];
    if (!n.prototype || typeof n.prototype != "object")
      break;
    n = Object.getPrototypeOf(n.prototype).constructor;
  }
  return null;
}
function It(n) {
  return sC(this, void 0, void 0, function* () {
    const e = Object.keys(n).map((r) => {
      const i = n[r];
      return Promise.resolve(i).then((s) => ({ key: r, value: s }));
    });
    return (yield Promise.all(e)).reduce((r, i) => (r[i.key] = i.value, r), {});
  });
}
function aC(n, e) {
  (!n || typeof n != "object") && _u.throwArgumentError("invalid object", "object", n), Object.keys(n).forEach((t) => {
    e[t] || _u.throwArgumentError("invalid object key - " + t, "transaction:" + t, n);
  });
}
function $t(n) {
  const e = {};
  for (const t in n)
    e[t] = n[t];
  return e;
}
const oC = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function e2(n) {
  if (n == null || oC[typeof n])
    return !0;
  if (Array.isArray(n) || typeof n == "object") {
    if (!Object.isFrozen(n))
      return !1;
    const e = Object.keys(n);
    for (let t = 0; t < e.length; t++) {
      let r = null;
      try {
        r = n[e[t]];
      } catch {
        continue;
      }
      if (!e2(r))
        return !1;
    }
    return !0;
  }
  return _u.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n);
}
function cC(n) {
  if (e2(n))
    return n;
  if (Array.isArray(n))
    return Object.freeze(n.map((e) => Ci(e)));
  if (typeof n == "object") {
    const e = {};
    for (const t in n) {
      const r = n[t];
      r !== void 0 && H(e, t, Ci(r));
    }
    return e;
  }
  return _u.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n);
}
function Ci(n) {
  return cC(n);
}
class nl {
  constructor(e) {
    for (const t in e)
      this[t] = Ci(e[t]);
  }
}
const rl = "abi/5.7.0", we = new O(rl), ta = {};
let Lg = { calldata: !0, memory: !0, storage: !0 }, lC = { calldata: !0, memory: !0 };
function El(n, e) {
  if (n === "bytes" || n === "string") {
    if (Lg[e])
      return !0;
  } else if (n === "address") {
    if (e === "payable")
      return !0;
  } else if ((n.indexOf("[") >= 0 || n === "tuple") && lC[e])
    return !0;
  return (Lg[e] || e === "payable") && we.throwArgumentError("invalid modifier", "name", e), !1;
}
function uC(n, e) {
  let t = n;
  function r(o) {
    we.throwArgumentError(`unexpected character at position ${o}`, "param", n);
  }
  n = n.replace(/\s/g, " ");
  function i(o) {
    let c = { type: "", name: "", parent: o, state: { allowType: !0 } };
    return e && (c.indexed = !1), c;
  }
  let s = { type: "", name: "", state: { allowType: !0 } }, a = s;
  for (let o = 0; o < n.length; o++) {
    let c = n[o];
    switch (c) {
      case "(":
        a.state.allowType && a.type === "" ? a.type = "tuple" : a.state.allowParams || r(o), a.state.allowType = !1, a.type = Oa(a.type), a.components = [i(a)], a = a.components[0];
        break;
      case ")":
        delete a.state, a.name === "indexed" && (e || r(o), a.indexed = !0, a.name = ""), El(a.type, a.name) && (a.name = ""), a.type = Oa(a.type);
        let l = a;
        a = a.parent, a || r(o), delete l.parent, a.state.allowParams = !1, a.state.allowName = !0, a.state.allowArray = !0;
        break;
      case ",":
        delete a.state, a.name === "indexed" && (e || r(o), a.indexed = !0, a.name = ""), El(a.type, a.name) && (a.name = ""), a.type = Oa(a.type);
        let f = i(a.parent);
        a.parent.components.push(f), delete a.parent, a = f;
        break;
      case " ":
        a.state.allowType && a.type !== "" && (a.type = Oa(a.type), delete a.state.allowType, a.state.allowName = !0, a.state.allowParams = !0), a.state.allowName && a.name !== "" && (a.name === "indexed" ? (e || r(o), a.indexed && r(o), a.indexed = !0, a.name = "") : El(a.type, a.name) ? a.name = "" : a.state.allowName = !1);
        break;
      case "[":
        a.state.allowArray || r(o), a.type += c, a.state.allowArray = !1, a.state.allowName = !1, a.state.readArray = !0;
        break;
      case "]":
        a.state.readArray || r(o), a.type += c, a.state.readArray = !1, a.state.allowArray = !0, a.state.allowName = !0;
        break;
      default:
        a.state.allowType ? (a.type += c, a.state.allowParams = !0, a.state.allowArray = !0) : a.state.allowName ? (a.name += c, delete a.state.allowArray) : a.state.readArray ? a.type += c : r(o);
    }
  }
  return a.parent && we.throwArgumentError("unexpected eof", "param", n), delete s.state, a.name === "indexed" ? (e || r(t.length - 7), a.indexed && r(t.length - 7), a.indexed = !0, a.name = "") : El(a.type, a.name) && (a.name = ""), s.type = Oa(s.type), s;
}
function Jl(n, e) {
  for (let t in e)
    H(n, t, e[t]);
}
const _e = Object.freeze({
  sighash: "sighash",
  minimal: "minimal",
  full: "full",
  json: "json"
}), dC = new RegExp(/^(.*)\[([0-9]*)\]$/);
class Wt {
  constructor(e, t) {
    e !== ta && we.throwError("use fromString", O.errors.UNSUPPORTED_OPERATION, {
      operation: "new ParamType()"
    }), Jl(this, t);
    let r = this.type.match(dC);
    r ? Jl(this, {
      arrayLength: parseInt(r[2] || "-1"),
      arrayChildren: Wt.fromObject({
        type: r[1],
        components: this.components
      }),
      baseType: "array"
    }) : Jl(this, {
      arrayLength: null,
      arrayChildren: null,
      baseType: this.components != null ? "tuple" : this.type
    }), this._isParamType = !0, Object.freeze(this);
  }
  format(e) {
    if (e || (e = _e.sighash), _e[e] || we.throwArgumentError("invalid format type", "format", e), e === _e.json) {
      let r = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      return typeof this.indexed == "boolean" && (r.indexed = this.indexed), this.components && (r.components = this.components.map((i) => JSON.parse(i.format(e)))), JSON.stringify(r);
    }
    let t = "";
    return this.baseType === "array" ? (t += this.arrayChildren.format(e), t += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (e !== _e.sighash && (t += this.type), t += "(" + this.components.map((r) => r.format(e)).join(e === _e.full ? ", " : ",") + ")") : t += this.type, e !== _e.sighash && (this.indexed === !0 && (t += " indexed"), e === _e.full && this.name && (t += " " + this.name)), t;
  }
  static from(e, t) {
    return typeof e == "string" ? Wt.fromString(e, t) : Wt.fromObject(e);
  }
  static fromObject(e) {
    return Wt.isParamType(e) ? e : new Wt(ta, {
      name: e.name || null,
      type: Oa(e.type),
      indexed: e.indexed == null ? null : !!e.indexed,
      components: e.components ? e.components.map(Wt.fromObject) : null
    });
  }
  static fromString(e, t) {
    function r(i) {
      return Wt.fromObject({
        name: i.name,
        type: i.type,
        indexed: i.indexed,
        components: i.components
      });
    }
    return r(uC(e, !!t));
  }
  static isParamType(e) {
    return !!(e != null && e._isParamType);
  }
}
function Ac(n, e) {
  return hC(n).map((t) => Wt.fromString(t, e));
}
class hi {
  constructor(e, t) {
    e !== ta && we.throwError("use a static from method", O.errors.UNSUPPORTED_OPERATION, {
      operation: "new Fragment()"
    }), Jl(this, t), this._isFragment = !0, Object.freeze(this);
  }
  static from(e) {
    return hi.isFragment(e) ? e : typeof e == "string" ? hi.fromString(e) : hi.fromObject(e);
  }
  static fromObject(e) {
    if (hi.isFragment(e))
      return e;
    switch (e.type) {
      case "function":
        return Vr.fromObject(e);
      case "event":
        return fi.fromObject(e);
      case "constructor":
        return Ur.fromObject(e);
      case "error":
        return ns.fromObject(e);
      case "fallback":
      case "receive":
        return null;
    }
    return we.throwArgumentError("invalid fragment object", "value", e);
  }
  static fromString(e) {
    return e = e.replace(/\s/g, " "), e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), e = e.trim(), e.split(" ")[0] === "event" ? fi.fromString(e.substring(5).trim()) : e.split(" ")[0] === "function" ? Vr.fromString(e.substring(8).trim()) : e.split("(")[0].trim() === "constructor" ? Ur.fromString(e.trim()) : e.split(" ")[0] === "error" ? ns.fromString(e.substring(5).trim()) : we.throwArgumentError("unsupported fragment", "value", e);
  }
  static isFragment(e) {
    return !!(e && e._isFragment);
  }
}
class fi extends hi {
  format(e) {
    if (e || (e = _e.sighash), _e[e] || we.throwArgumentError("invalid format type", "format", e), e === _e.json)
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
    let t = "";
    return e !== _e.sighash && (t += "event "), t += this.name + "(" + this.inputs.map((r) => r.format(e)).join(e === _e.full ? ", " : ",") + ") ", e !== _e.sighash && this.anonymous && (t += "anonymous "), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? fi.fromString(e) : fi.fromObject(e);
  }
  static fromObject(e) {
    if (fi.isEventFragment(e))
      return e;
    e.type !== "event" && we.throwArgumentError("invalid event object", "value", e);
    const t = {
      name: Tc(e.name),
      anonymous: e.anonymous,
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
      type: "event"
    };
    return new fi(ta, t);
  }
  static fromString(e) {
    let t = e.match(Cc);
    t || we.throwArgumentError("invalid event string", "value", e);
    let r = !1;
    return t[3].split(" ").forEach((i) => {
      switch (i.trim()) {
        case "anonymous":
          r = !0;
          break;
        case "":
          break;
        default:
          we.warn("unknown modifier: " + i);
      }
    }), fi.fromObject({
      name: t[1].trim(),
      anonymous: r,
      inputs: Ac(t[2], !0),
      type: "event"
    });
  }
  static isEventFragment(e) {
    return e && e._isFragment && e.type === "event";
  }
}
function t2(n, e) {
  e.gas = null;
  let t = n.split("@");
  return t.length !== 1 ? (t.length > 2 && we.throwArgumentError("invalid human-readable ABI signature", "value", n), t[1].match(/^[0-9]+$/) || we.throwArgumentError("invalid human-readable ABI signature gas", "value", n), e.gas = G.from(t[1]), t[0]) : n;
}
function n2(n, e) {
  e.constant = !1, e.payable = !1, e.stateMutability = "nonpayable", n.split(" ").forEach((t) => {
    switch (t.trim()) {
      case "constant":
        e.constant = !0;
        break;
      case "payable":
        e.payable = !0, e.stateMutability = "payable";
        break;
      case "nonpayable":
        e.payable = !1, e.stateMutability = "nonpayable";
        break;
      case "pure":
        e.constant = !0, e.stateMutability = "pure";
        break;
      case "view":
        e.constant = !0, e.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + t);
    }
  });
}
function r2(n) {
  let e = {
    constant: !1,
    payable: !0,
    stateMutability: "payable"
  };
  return n.stateMutability != null ? (e.stateMutability = n.stateMutability, e.constant = e.stateMutability === "view" || e.stateMutability === "pure", n.constant != null && !!n.constant !== e.constant && we.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", n), e.payable = e.stateMutability === "payable", n.payable != null && !!n.payable !== e.payable && we.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", n)) : n.payable != null ? (e.payable = !!n.payable, n.constant == null && !e.payable && n.type !== "constructor" && we.throwArgumentError("unable to determine stateMutability", "value", n), e.constant = !!n.constant, e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable", e.payable && e.constant && we.throwArgumentError("cannot have constant payable function", "value", n)) : n.constant != null ? (e.constant = !!n.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : n.type !== "constructor" && we.throwArgumentError("unable to determine stateMutability", "value", n), e;
}
class Ur extends hi {
  format(e) {
    if (e || (e = _e.sighash), _e[e] || we.throwArgumentError("invalid format type", "format", e), e === _e.json)
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
    e === _e.sighash && we.throwError("cannot format a constructor for sighash", O.errors.UNSUPPORTED_OPERATION, {
      operation: "format(sighash)"
    });
    let t = "constructor(" + this.inputs.map((r) => r.format(e)).join(e === _e.full ? ", " : ",") + ") ";
    return this.stateMutability && this.stateMutability !== "nonpayable" && (t += this.stateMutability + " "), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? Ur.fromString(e) : Ur.fromObject(e);
  }
  static fromObject(e) {
    if (Ur.isConstructorFragment(e))
      return e;
    e.type !== "constructor" && we.throwArgumentError("invalid constructor object", "value", e);
    let t = r2(e);
    t.constant && we.throwArgumentError("constructor cannot be constant", "value", e);
    const r = {
      name: null,
      type: e.type,
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? G.from(e.gas) : null
    };
    return new Ur(ta, r);
  }
  static fromString(e) {
    let t = { type: "constructor" };
    e = t2(e, t);
    let r = e.match(Cc);
    return (!r || r[1].trim() !== "constructor") && we.throwArgumentError("invalid constructor string", "value", e), t.inputs = Ac(r[2].trim(), !1), n2(r[3].trim(), t), Ur.fromObject(t);
  }
  static isConstructorFragment(e) {
    return e && e._isFragment && e.type === "constructor";
  }
}
class Vr extends Ur {
  format(e) {
    if (e || (e = _e.sighash), _e[e] || we.throwArgumentError("invalid format type", "format", e), e === _e.json)
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e))),
        outputs: this.outputs.map((r) => JSON.parse(r.format(e)))
      });
    let t = "";
    return e !== _e.sighash && (t += "function "), t += this.name + "(" + this.inputs.map((r) => r.format(e)).join(e === _e.full ? ", " : ",") + ") ", e !== _e.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (t += this.stateMutability + " ") : this.constant && (t += "view "), this.outputs && this.outputs.length && (t += "returns (" + this.outputs.map((r) => r.format(e)).join(", ") + ") "), this.gas != null && (t += "@" + this.gas.toString() + " ")), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? Vr.fromString(e) : Vr.fromObject(e);
  }
  static fromObject(e) {
    if (Vr.isFunctionFragment(e))
      return e;
    e.type !== "function" && we.throwArgumentError("invalid function object", "value", e);
    let t = r2(e);
    const r = {
      type: e.type,
      name: Tc(e.name),
      constant: t.constant,
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : [],
      outputs: e.outputs ? e.outputs.map(Wt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? G.from(e.gas) : null
    };
    return new Vr(ta, r);
  }
  static fromString(e) {
    let t = { type: "function" };
    e = t2(e, t);
    let r = e.split(" returns ");
    r.length > 2 && we.throwArgumentError("invalid function string", "value", e);
    let i = r[0].match(Cc);
    if (i || we.throwArgumentError("invalid function signature", "value", e), t.name = i[1].trim(), t.name && Tc(t.name), t.inputs = Ac(i[2], !1), n2(i[3].trim(), t), r.length > 1) {
      let s = r[1].match(Cc);
      (s[1].trim() != "" || s[3].trim() != "") && we.throwArgumentError("unexpected tokens", "value", e), t.outputs = Ac(s[2], !1);
    } else
      t.outputs = [];
    return Vr.fromObject(t);
  }
  static isFunctionFragment(e) {
    return e && e._isFragment && e.type === "function";
  }
}
function Fg(n) {
  const e = n.format();
  return (e === "Error(string)" || e === "Panic(uint256)") && we.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", n), n;
}
class ns extends hi {
  format(e) {
    if (e || (e = _e.sighash), _e[e] || we.throwArgumentError("invalid format type", "format", e), e === _e.json)
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((r) => JSON.parse(r.format(e)))
      });
    let t = "";
    return e !== _e.sighash && (t += "error "), t += this.name + "(" + this.inputs.map((r) => r.format(e)).join(e === _e.full ? ", " : ",") + ") ", t.trim();
  }
  static from(e) {
    return typeof e == "string" ? ns.fromString(e) : ns.fromObject(e);
  }
  static fromObject(e) {
    if (ns.isErrorFragment(e))
      return e;
    e.type !== "error" && we.throwArgumentError("invalid error object", "value", e);
    const t = {
      type: e.type,
      name: Tc(e.name),
      inputs: e.inputs ? e.inputs.map(Wt.fromObject) : []
    };
    return Fg(new ns(ta, t));
  }
  static fromString(e) {
    let t = { type: "error" }, r = e.match(Cc);
    return r || we.throwArgumentError("invalid error signature", "value", e), t.name = r[1].trim(), t.name && Tc(t.name), t.inputs = Ac(r[2], !1), Fg(ns.fromObject(t));
  }
  static isErrorFragment(e) {
    return e && e._isFragment && e.type === "error";
  }
}
function Oa(n) {
  return n.match(/^uint($|[^1-9])/) ? n = "uint256" + n.substring(4) : n.match(/^int($|[^1-9])/) && (n = "int256" + n.substring(3)), n;
}
const fC = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function Tc(n) {
  return (!n || !n.match(fC)) && we.throwArgumentError(`invalid identifier "${n}"`, "value", n), n;
}
const Cc = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function hC(n) {
  n = n.trim();
  let e = [], t = "", r = 0;
  for (let i = 0; i < n.length; i++) {
    let s = n[i];
    s === "," && r === 0 ? (e.push(t), t = "") : (t += s, s === "(" ? r++ : s === ")" && (r--, r === -1 && we.throwArgumentError("unbalanced parenthesis", "value", n)));
  }
  return t && e.push(t), e;
}
const cp = new O(rl);
function pC(n) {
  const e = [], t = function(r, i) {
    if (!!Array.isArray(i))
      for (let s in i) {
        const a = r.slice();
        a.push(s);
        try {
          t(a, i[s]);
        } catch (o) {
          e.push({ path: a, error: o });
        }
      }
  };
  return t([], n), e;
}
class Di {
  constructor(e, t, r, i) {
    this.name = e, this.type = t, this.localName = r, this.dynamic = i;
  }
  _throwError(e, t) {
    cp.throwArgumentError(e, this.localName, t);
  }
}
class kh {
  constructor(e) {
    H(this, "wordSize", e || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(e);
  }
  get data() {
    return Pn(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(e) {
    return this._data.push(e), this._dataLength += e.length, e.length;
  }
  appendWriter(e) {
    return this._writeData(zn(e._data));
  }
  writeBytes(e) {
    let t = ae(e);
    const r = t.length % this.wordSize;
    return r && (t = zn([t, this._padding.slice(r)])), this._writeData(t);
  }
  _getValue(e) {
    let t = ae(G.from(e));
    return t.length > this.wordSize && cp.throwError("value out-of-bounds", O.errors.BUFFER_OVERRUN, {
      length: this.wordSize,
      offset: t.length
    }), t.length % this.wordSize && (t = zn([this._padding.slice(t.length % this.wordSize), t])), t;
  }
  writeValue(e) {
    return this._writeData(this._getValue(e));
  }
  writeUpdatableValue() {
    const e = this._data.length;
    return this._data.push(this._padding), this._dataLength += this.wordSize, (t) => {
      this._data[e] = this._getValue(t);
    };
  }
}
class Pu {
  constructor(e, t, r, i) {
    H(this, "_data", ae(e)), H(this, "wordSize", t || 32), H(this, "_coerceFunc", r), H(this, "allowLoose", i), this._offset = 0;
  }
  get data() {
    return te(this._data);
  }
  get consumed() {
    return this._offset;
  }
  static coerce(e, t) {
    let r = e.match("^u?int([0-9]+)$");
    return r && parseInt(r[1]) <= 48 && (t = t.toNumber()), t;
  }
  coerce(e, t) {
    return this._coerceFunc ? this._coerceFunc(e, t) : Pu.coerce(e, t);
  }
  _peekBytes(e, t, r) {
    let i = Math.ceil(t / this.wordSize) * this.wordSize;
    return this._offset + i > this._data.length && (this.allowLoose && r && this._offset + t <= this._data.length ? i = t : cp.throwError("data out-of-bounds", O.errors.BUFFER_OVERRUN, {
      length: this._data.length,
      offset: this._offset + i
    })), this._data.slice(this._offset, this._offset + i);
  }
  subReader(e) {
    return new Pu(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(e, t) {
    let r = this._peekBytes(0, e, !!t);
    return this._offset += r.length, r.slice(0, e);
  }
  readValue() {
    return G.from(this.readBytes(this.wordSize));
  }
}
const na = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
function i2() {
  throw new Error("setTimeout has not been defined");
}
function s2() {
  throw new Error("clearTimeout has not been defined");
}
var Ji = i2, Yi = s2;
typeof na.setTimeout == "function" && (Ji = setTimeout);
typeof na.clearTimeout == "function" && (Yi = clearTimeout);
function a2(n) {
  if (Ji === setTimeout)
    return setTimeout(n, 0);
  if ((Ji === i2 || !Ji) && setTimeout)
    return Ji = setTimeout, setTimeout(n, 0);
  try {
    return Ji(n, 0);
  } catch {
    try {
      return Ji.call(null, n, 0);
    } catch {
      return Ji.call(this, n, 0);
    }
  }
}
function mC(n) {
  if (Yi === clearTimeout)
    return clearTimeout(n);
  if ((Yi === s2 || !Yi) && clearTimeout)
    return Yi = clearTimeout, clearTimeout(n);
  try {
    return Yi(n);
  } catch {
    try {
      return Yi.call(null, n);
    } catch {
      return Yi.call(this, n);
    }
  }
}
var pi = [], Ga = !1, zs, Yl = -1;
function yC() {
  !Ga || !zs || (Ga = !1, zs.length ? pi = zs.concat(pi) : Yl = -1, pi.length && o2());
}
function o2() {
  if (!Ga) {
    var n = a2(yC);
    Ga = !0;
    for (var e = pi.length; e; ) {
      for (zs = pi, pi = []; ++Yl < e; )
        zs && zs[Yl].run();
      Yl = -1, e = pi.length;
    }
    zs = null, Ga = !1, mC(n);
  }
}
function gC(n) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
  pi.push(new c2(n, e)), pi.length === 1 && !Ga && a2(o2);
}
function c2(n, e) {
  this.fun = n, this.array = e;
}
c2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var bC = "browser", xC = "browser", vC = !0, wC = {}, AC = [], TC = "", CC = {}, EC = {}, SC = {};
function va() {
}
var _C = va, PC = va, MC = va, RC = va, kC = va, IC = va, OC = va;
function DC(n) {
  throw new Error("process.binding is not supported");
}
function NC() {
  return "/";
}
function BC(n) {
  throw new Error("process.chdir is not supported");
}
function $C() {
  return 0;
}
var Da = na.performance || {}, LC = Da.now || Da.mozNow || Da.msNow || Da.oNow || Da.webkitNow || function() {
  return new Date().getTime();
};
function FC(n) {
  var e = LC.call(Da) * 1e-3, t = Math.floor(e), r = Math.floor(e % 1 * 1e9);
  return n && (t = t - n[0], r = r - n[1], r < 0 && (t--, r += 1e9)), [t, r];
}
var UC = new Date();
function VC() {
  var n = new Date(), e = n - UC;
  return e / 1e3;
}
var Xl = {
  nextTick: gC,
  title: bC,
  browser: vC,
  env: wC,
  argv: AC,
  version: TC,
  versions: CC,
  on: _C,
  addListener: PC,
  once: MC,
  off: RC,
  removeListener: kC,
  removeAllListeners: IC,
  emit: OC,
  binding: DC,
  cwd: NC,
  chdir: BC,
  umask: $C,
  hrtime: FC,
  platform: xC,
  release: EC,
  config: SC,
  uptime: VC
}, l2 = { exports: {} };
(function(n) {
  (function() {
    var e = "input is invalid type", t = "finalize already called", r = typeof window == "object", i = r ? window : {};
    i.JS_SHA3_NO_WINDOW && (r = !1);
    var s = !r && typeof self == "object", a = !i.JS_SHA3_NO_NODE_JS && typeof Xl == "object" && Xl.versions && Xl.versions.node;
    a ? i = Kv : s && (i = self);
    var o = !i.JS_SHA3_NO_COMMON_JS && !0 && n.exports, c = !i.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", l = "0123456789abcdef".split(""), f = [31, 7936, 2031616, 520093696], p = [4, 1024, 262144, 67108864], g = [1, 256, 65536, 16777216], T = [6, 1536, 393216, 100663296], v = [0, 8, 16, 24], w = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], C = [224, 256, 384, 512], _ = [128, 256], I = ["hex", "buffer", "arrayBuffer", "array", "digest"], B = {
      128: 168,
      256: 136
    };
    (i.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(h) {
      return Object.prototype.toString.call(h) === "[object Array]";
    }), c && (i.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(h) {
      return typeof h == "object" && h.buffer && h.buffer.constructor === ArrayBuffer;
    });
    for (var N = function(h, M, L) {
      return function($) {
        return new u(h, M, h).update($)[L]();
      };
    }, D = function(h, M, L) {
      return function($, F) {
        return new u(h, M, F).update($)[L]();
      };
    }, U = function(h, M, L) {
      return function($, F, X, z) {
        return d["cshake" + h].update($, F, X, z)[L]();
      };
    }, W = function(h, M, L) {
      return function($, F, X, z) {
        return d["kmac" + h].update($, F, X, z)[L]();
      };
    }, j = function(h, M, L, $) {
      for (var F = 0; F < I.length; ++F) {
        var X = I[F];
        h[X] = M(L, $, X);
      }
      return h;
    }, q = function(h, M) {
      var L = N(h, M, "hex");
      return L.create = function() {
        return new u(h, M, h);
      }, L.update = function($) {
        return L.create().update($);
      }, j(L, N, h, M);
    }, ce = function(h, M) {
      var L = D(h, M, "hex");
      return L.create = function($) {
        return new u(h, M, $);
      }, L.update = function($, F) {
        return L.create(F).update($);
      }, j(L, D, h, M);
    }, re = function(h, M) {
      var L = B[h], $ = U(h, M, "hex");
      return $.create = function(F, X, z) {
        return !X && !z ? d["shake" + h].create(F) : new u(h, M, F).bytepad([X, z], L);
      }, $.update = function(F, X, z, K) {
        return $.create(X, z, K).update(F);
      }, j($, U, h, M);
    }, me = function(h, M) {
      var L = B[h], $ = W(h, M, "hex");
      return $.create = function(F, X, z) {
        return new b(h, M, X).bytepad(["KMAC", z], L).bytepad([F], L);
      }, $.update = function(F, X, z, K) {
        return $.create(F, z, K).update(X);
      }, j($, W, h, M);
    }, S = [
      { name: "keccak", padding: g, bits: C, createMethod: q },
      { name: "sha3", padding: T, bits: C, createMethod: q },
      { name: "shake", padding: f, bits: _, createMethod: ce },
      { name: "cshake", padding: p, bits: _, createMethod: re },
      { name: "kmac", padding: p, bits: _, createMethod: me }
    ], d = {}, m = [], x = 0; x < S.length; ++x)
      for (var E = S[x], A = E.bits, P = 0; P < A.length; ++P) {
        var R = E.name + "_" + A[P];
        if (m.push(R), d[R] = E.createMethod(A[P], E.padding), E.name !== "sha3") {
          var y = E.name + A[P];
          m.push(y), d[y] = d[R];
        }
      }
    function u(h, M, L) {
      this.blocks = [], this.s = [], this.padding = M, this.outputBits = L, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (h << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = L >> 5, this.extraBytes = (L & 31) >> 3;
      for (var $ = 0; $ < 50; ++$)
        this.s[$] = 0;
    }
    u.prototype.update = function(h) {
      if (this.finalized)
        throw new Error(t);
      var M, L = typeof h;
      if (L !== "string") {
        if (L === "object") {
          if (h === null)
            throw new Error(e);
          if (c && h.constructor === ArrayBuffer)
            h = new Uint8Array(h);
          else if (!Array.isArray(h) && (!c || !ArrayBuffer.isView(h)))
            throw new Error(e);
        } else
          throw new Error(e);
        M = !0;
      }
      for (var $ = this.blocks, F = this.byteCount, X = h.length, z = this.blockCount, K = 0, xt = this.s, Z, ue; K < X; ) {
        if (this.reset)
          for (this.reset = !1, $[0] = this.block, Z = 1; Z < z + 1; ++Z)
            $[Z] = 0;
        if (M)
          for (Z = this.start; K < X && Z < F; ++K)
            $[Z >> 2] |= h[K] << v[Z++ & 3];
        else
          for (Z = this.start; K < X && Z < F; ++K)
            ue = h.charCodeAt(K), ue < 128 ? $[Z >> 2] |= ue << v[Z++ & 3] : ue < 2048 ? ($[Z >> 2] |= (192 | ue >> 6) << v[Z++ & 3], $[Z >> 2] |= (128 | ue & 63) << v[Z++ & 3]) : ue < 55296 || ue >= 57344 ? ($[Z >> 2] |= (224 | ue >> 12) << v[Z++ & 3], $[Z >> 2] |= (128 | ue >> 6 & 63) << v[Z++ & 3], $[Z >> 2] |= (128 | ue & 63) << v[Z++ & 3]) : (ue = 65536 + ((ue & 1023) << 10 | h.charCodeAt(++K) & 1023), $[Z >> 2] |= (240 | ue >> 18) << v[Z++ & 3], $[Z >> 2] |= (128 | ue >> 12 & 63) << v[Z++ & 3], $[Z >> 2] |= (128 | ue >> 6 & 63) << v[Z++ & 3], $[Z >> 2] |= (128 | ue & 63) << v[Z++ & 3]);
        if (this.lastByteIndex = Z, Z >= F) {
          for (this.start = Z - F, this.block = $[z], Z = 0; Z < z; ++Z)
            xt[Z] ^= $[Z];
          k(xt), this.reset = !0;
        } else
          this.start = Z;
      }
      return this;
    }, u.prototype.encode = function(h, M) {
      var L = h & 255, $ = 1, F = [L];
      for (h = h >> 8, L = h & 255; L > 0; )
        F.unshift(L), h = h >> 8, L = h & 255, ++$;
      return M ? F.push($) : F.unshift($), this.update(F), F.length;
    }, u.prototype.encodeString = function(h) {
      var M, L = typeof h;
      if (L !== "string") {
        if (L === "object") {
          if (h === null)
            throw new Error(e);
          if (c && h.constructor === ArrayBuffer)
            h = new Uint8Array(h);
          else if (!Array.isArray(h) && (!c || !ArrayBuffer.isView(h)))
            throw new Error(e);
        } else
          throw new Error(e);
        M = !0;
      }
      var $ = 0, F = h.length;
      if (M)
        $ = F;
      else
        for (var X = 0; X < h.length; ++X) {
          var z = h.charCodeAt(X);
          z < 128 ? $ += 1 : z < 2048 ? $ += 2 : z < 55296 || z >= 57344 ? $ += 3 : (z = 65536 + ((z & 1023) << 10 | h.charCodeAt(++X) & 1023), $ += 4);
        }
      return $ += this.encode($ * 8), this.update(h), $;
    }, u.prototype.bytepad = function(h, M) {
      for (var L = this.encode(M), $ = 0; $ < h.length; ++$)
        L += this.encodeString(h[$]);
      var F = M - L % M, X = [];
      return X.length = F, this.update(X), this;
    }, u.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var h = this.blocks, M = this.lastByteIndex, L = this.blockCount, $ = this.s;
        if (h[M >> 2] |= this.padding[M & 3], this.lastByteIndex === this.byteCount)
          for (h[0] = h[L], M = 1; M < L + 1; ++M)
            h[M] = 0;
        for (h[L - 1] |= 2147483648, M = 0; M < L; ++M)
          $[M] ^= h[M];
        k($);
      }
    }, u.prototype.toString = u.prototype.hex = function() {
      this.finalize();
      for (var h = this.blockCount, M = this.s, L = this.outputBlocks, $ = this.extraBytes, F = 0, X = 0, z = "", K; X < L; ) {
        for (F = 0; F < h && X < L; ++F, ++X)
          K = M[F], z += l[K >> 4 & 15] + l[K & 15] + l[K >> 12 & 15] + l[K >> 8 & 15] + l[K >> 20 & 15] + l[K >> 16 & 15] + l[K >> 28 & 15] + l[K >> 24 & 15];
        X % h === 0 && (k(M), F = 0);
      }
      return $ && (K = M[F], z += l[K >> 4 & 15] + l[K & 15], $ > 1 && (z += l[K >> 12 & 15] + l[K >> 8 & 15]), $ > 2 && (z += l[K >> 20 & 15] + l[K >> 16 & 15])), z;
    }, u.prototype.arrayBuffer = function() {
      this.finalize();
      var h = this.blockCount, M = this.s, L = this.outputBlocks, $ = this.extraBytes, F = 0, X = 0, z = this.outputBits >> 3, K;
      $ ? K = new ArrayBuffer(L + 1 << 2) : K = new ArrayBuffer(z);
      for (var xt = new Uint32Array(K); X < L; ) {
        for (F = 0; F < h && X < L; ++F, ++X)
          xt[X] = M[F];
        X % h === 0 && k(M);
      }
      return $ && (xt[F] = M[F], K = K.slice(0, z)), K;
    }, u.prototype.buffer = u.prototype.arrayBuffer, u.prototype.digest = u.prototype.array = function() {
      this.finalize();
      for (var h = this.blockCount, M = this.s, L = this.outputBlocks, $ = this.extraBytes, F = 0, X = 0, z = [], K, xt; X < L; ) {
        for (F = 0; F < h && X < L; ++F, ++X)
          K = X << 2, xt = M[F], z[K] = xt & 255, z[K + 1] = xt >> 8 & 255, z[K + 2] = xt >> 16 & 255, z[K + 3] = xt >> 24 & 255;
        X % h === 0 && k(M);
      }
      return $ && (K = X << 2, xt = M[F], z[K] = xt & 255, $ > 1 && (z[K + 1] = xt >> 8 & 255), $ > 2 && (z[K + 2] = xt >> 16 & 255)), z;
    };
    function b(h, M, L) {
      u.call(this, h, M, L);
    }
    b.prototype = new u(), b.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), u.prototype.finalize.call(this);
    };
    var k = function(h) {
      var M, L, $, F, X, z, K, xt, Z, ue, As, Fe, Ue, Ts, Ve, je, Cs, Ge, We, Es, He, ze, Ss, Ke, qe, _s, Qe, Je, Ps, Ye, Xe, Ms, Ze, et, Rs, tt, nt, ks, rt, it, Is, st, at, Os, ot, ct, Ds, lt, ut, Ns, dt, ft, Bs, ht, pt, $s, mt, yt, Ui, Vi, ji, Gi, Wi;
      for ($ = 0; $ < 48; $ += 2)
        F = h[0] ^ h[10] ^ h[20] ^ h[30] ^ h[40], X = h[1] ^ h[11] ^ h[21] ^ h[31] ^ h[41], z = h[2] ^ h[12] ^ h[22] ^ h[32] ^ h[42], K = h[3] ^ h[13] ^ h[23] ^ h[33] ^ h[43], xt = h[4] ^ h[14] ^ h[24] ^ h[34] ^ h[44], Z = h[5] ^ h[15] ^ h[25] ^ h[35] ^ h[45], ue = h[6] ^ h[16] ^ h[26] ^ h[36] ^ h[46], As = h[7] ^ h[17] ^ h[27] ^ h[37] ^ h[47], Fe = h[8] ^ h[18] ^ h[28] ^ h[38] ^ h[48], Ue = h[9] ^ h[19] ^ h[29] ^ h[39] ^ h[49], M = Fe ^ (z << 1 | K >>> 31), L = Ue ^ (K << 1 | z >>> 31), h[0] ^= M, h[1] ^= L, h[10] ^= M, h[11] ^= L, h[20] ^= M, h[21] ^= L, h[30] ^= M, h[31] ^= L, h[40] ^= M, h[41] ^= L, M = F ^ (xt << 1 | Z >>> 31), L = X ^ (Z << 1 | xt >>> 31), h[2] ^= M, h[3] ^= L, h[12] ^= M, h[13] ^= L, h[22] ^= M, h[23] ^= L, h[32] ^= M, h[33] ^= L, h[42] ^= M, h[43] ^= L, M = z ^ (ue << 1 | As >>> 31), L = K ^ (As << 1 | ue >>> 31), h[4] ^= M, h[5] ^= L, h[14] ^= M, h[15] ^= L, h[24] ^= M, h[25] ^= L, h[34] ^= M, h[35] ^= L, h[44] ^= M, h[45] ^= L, M = xt ^ (Fe << 1 | Ue >>> 31), L = Z ^ (Ue << 1 | Fe >>> 31), h[6] ^= M, h[7] ^= L, h[16] ^= M, h[17] ^= L, h[26] ^= M, h[27] ^= L, h[36] ^= M, h[37] ^= L, h[46] ^= M, h[47] ^= L, M = ue ^ (F << 1 | X >>> 31), L = As ^ (X << 1 | F >>> 31), h[8] ^= M, h[9] ^= L, h[18] ^= M, h[19] ^= L, h[28] ^= M, h[29] ^= L, h[38] ^= M, h[39] ^= L, h[48] ^= M, h[49] ^= L, Ts = h[0], Ve = h[1], ct = h[11] << 4 | h[10] >>> 28, Ds = h[10] << 4 | h[11] >>> 28, Je = h[20] << 3 | h[21] >>> 29, Ps = h[21] << 3 | h[20] >>> 29, Vi = h[31] << 9 | h[30] >>> 23, ji = h[30] << 9 | h[31] >>> 23, st = h[40] << 18 | h[41] >>> 14, at = h[41] << 18 | h[40] >>> 14, et = h[2] << 1 | h[3] >>> 31, Rs = h[3] << 1 | h[2] >>> 31, je = h[13] << 12 | h[12] >>> 20, Cs = h[12] << 12 | h[13] >>> 20, lt = h[22] << 10 | h[23] >>> 22, ut = h[23] << 10 | h[22] >>> 22, Ye = h[33] << 13 | h[32] >>> 19, Xe = h[32] << 13 | h[33] >>> 19, Gi = h[42] << 2 | h[43] >>> 30, Wi = h[43] << 2 | h[42] >>> 30, ht = h[5] << 30 | h[4] >>> 2, pt = h[4] << 30 | h[5] >>> 2, tt = h[14] << 6 | h[15] >>> 26, nt = h[15] << 6 | h[14] >>> 26, Ge = h[25] << 11 | h[24] >>> 21, We = h[24] << 11 | h[25] >>> 21, Ns = h[34] << 15 | h[35] >>> 17, dt = h[35] << 15 | h[34] >>> 17, Ms = h[45] << 29 | h[44] >>> 3, Ze = h[44] << 29 | h[45] >>> 3, Ke = h[6] << 28 | h[7] >>> 4, qe = h[7] << 28 | h[6] >>> 4, $s = h[17] << 23 | h[16] >>> 9, mt = h[16] << 23 | h[17] >>> 9, ks = h[26] << 25 | h[27] >>> 7, rt = h[27] << 25 | h[26] >>> 7, Es = h[36] << 21 | h[37] >>> 11, He = h[37] << 21 | h[36] >>> 11, ft = h[47] << 24 | h[46] >>> 8, Bs = h[46] << 24 | h[47] >>> 8, Os = h[8] << 27 | h[9] >>> 5, ot = h[9] << 27 | h[8] >>> 5, _s = h[18] << 20 | h[19] >>> 12, Qe = h[19] << 20 | h[18] >>> 12, yt = h[29] << 7 | h[28] >>> 25, Ui = h[28] << 7 | h[29] >>> 25, it = h[38] << 8 | h[39] >>> 24, Is = h[39] << 8 | h[38] >>> 24, ze = h[48] << 14 | h[49] >>> 18, Ss = h[49] << 14 | h[48] >>> 18, h[0] = Ts ^ ~je & Ge, h[1] = Ve ^ ~Cs & We, h[10] = Ke ^ ~_s & Je, h[11] = qe ^ ~Qe & Ps, h[20] = et ^ ~tt & ks, h[21] = Rs ^ ~nt & rt, h[30] = Os ^ ~ct & lt, h[31] = ot ^ ~Ds & ut, h[40] = ht ^ ~$s & yt, h[41] = pt ^ ~mt & Ui, h[2] = je ^ ~Ge & Es, h[3] = Cs ^ ~We & He, h[12] = _s ^ ~Je & Ye, h[13] = Qe ^ ~Ps & Xe, h[22] = tt ^ ~ks & it, h[23] = nt ^ ~rt & Is, h[32] = ct ^ ~lt & Ns, h[33] = Ds ^ ~ut & dt, h[42] = $s ^ ~yt & Vi, h[43] = mt ^ ~Ui & ji, h[4] = Ge ^ ~Es & ze, h[5] = We ^ ~He & Ss, h[14] = Je ^ ~Ye & Ms, h[15] = Ps ^ ~Xe & Ze, h[24] = ks ^ ~it & st, h[25] = rt ^ ~Is & at, h[34] = lt ^ ~Ns & ft, h[35] = ut ^ ~dt & Bs, h[44] = yt ^ ~Vi & Gi, h[45] = Ui ^ ~ji & Wi, h[6] = Es ^ ~ze & Ts, h[7] = He ^ ~Ss & Ve, h[16] = Ye ^ ~Ms & Ke, h[17] = Xe ^ ~Ze & qe, h[26] = it ^ ~st & et, h[27] = Is ^ ~at & Rs, h[36] = Ns ^ ~ft & Os, h[37] = dt ^ ~Bs & ot, h[46] = Vi ^ ~Gi & ht, h[47] = ji ^ ~Wi & pt, h[8] = ze ^ ~Ts & je, h[9] = Ss ^ ~Ve & Cs, h[18] = Ms ^ ~Ke & _s, h[19] = Ze ^ ~qe & Qe, h[28] = st ^ ~et & tt, h[29] = at ^ ~Rs & nt, h[38] = ft ^ ~Os & ct, h[39] = Bs ^ ~ot & Ds, h[48] = Gi ^ ~ht & $s, h[49] = Wi ^ ~pt & mt, h[0] ^= w[$], h[1] ^= w[$ + 1];
    };
    if (o)
      n.exports = d;
    else
      for (x = 0; x < m.length; ++x)
        i[m[x]] = d[m[x]];
  })();
})(l2);
const jC = l2.exports;
function Mt(n) {
  return "0x" + jC.keccak_256(ae(n));
}
const GC = "rlp/5.7.0", Nr = new O(GC);
function Ug(n) {
  const e = [];
  for (; n; )
    e.unshift(n & 255), n >>= 8;
  return e;
}
function Vg(n, e, t) {
  let r = 0;
  for (let i = 0; i < t; i++)
    r = r * 256 + n[e + i];
  return r;
}
function u2(n) {
  if (Array.isArray(n)) {
    let r = [];
    if (n.forEach(function(s) {
      r = r.concat(u2(s));
    }), r.length <= 55)
      return r.unshift(192 + r.length), r;
    const i = Ug(r.length);
    return i.unshift(247 + i.length), i.concat(r);
  }
  sp(n) || Nr.throwArgumentError("RLP object must be BytesLike", "object", n);
  const e = Array.prototype.slice.call(ae(n));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const t = Ug(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
function il(n) {
  return te(u2(n));
}
function jg(n, e, t, r) {
  const i = [];
  for (; t < e + 1 + r; ) {
    const s = d2(n, t);
    i.push(s.result), t += s.consumed, t > e + 1 + r && Nr.throwError("child data too short", O.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + r, result: i };
}
function d2(n, e) {
  if (n.length === 0 && Nr.throwError("data too short", O.errors.BUFFER_OVERRUN, {}), n[e] >= 248) {
    const t = n[e] - 247;
    e + 1 + t > n.length && Nr.throwError("data short segment too short", O.errors.BUFFER_OVERRUN, {});
    const r = Vg(n, e + 1, t);
    return e + 1 + t + r > n.length && Nr.throwError("data long segment too short", O.errors.BUFFER_OVERRUN, {}), jg(n, e, e + 1 + t, t + r);
  } else if (n[e] >= 192) {
    const t = n[e] - 192;
    return e + 1 + t > n.length && Nr.throwError("data array too short", O.errors.BUFFER_OVERRUN, {}), jg(n, e, e + 1, t);
  } else if (n[e] >= 184) {
    const t = n[e] - 183;
    e + 1 + t > n.length && Nr.throwError("data array too short", O.errors.BUFFER_OVERRUN, {});
    const r = Vg(n, e + 1, t);
    e + 1 + t + r > n.length && Nr.throwError("data array too short", O.errors.BUFFER_OVERRUN, {});
    const i = te(n.slice(e + 1 + t, e + 1 + t + r));
    return { consumed: 1 + t + r, result: i };
  } else if (n[e] >= 128) {
    const t = n[e] - 128;
    e + 1 + t > n.length && Nr.throwError("data too short", O.errors.BUFFER_OVERRUN, {});
    const r = te(n.slice(e + 1, e + 1 + t));
    return { consumed: 1 + t, result: r };
  }
  return { consumed: 1, result: te(n[e]) };
}
function wd(n) {
  const e = ae(n), t = d2(e, 0);
  return t.consumed !== e.length && Nr.throwArgumentError("invalid rlp data", "data", n), t.result;
}
const WC = "address/5.7.0", $a = new O(WC);
function Gg(n) {
  Pe(n, 20) || $a.throwArgumentError("invalid address", "address", n), n = n.toLowerCase();
  const e = n.substring(2).split(""), t = new Uint8Array(40);
  for (let i = 0; i < 40; i++)
    t[i] = e[i].charCodeAt(0);
  const r = ae(Mt(t));
  for (let i = 0; i < 40; i += 2)
    r[i >> 1] >> 4 >= 8 && (e[i] = e[i].toUpperCase()), (r[i >> 1] & 15) >= 8 && (e[i + 1] = e[i + 1].toUpperCase());
  return "0x" + e.join("");
}
const HC = 9007199254740991;
function zC(n) {
  return Math.log10 ? Math.log10(n) : Math.log(n) / Math.LN10;
}
const lp = {};
for (let n = 0; n < 10; n++)
  lp[String(n)] = String(n);
for (let n = 0; n < 26; n++)
  lp[String.fromCharCode(65 + n)] = String(10 + n);
const Wg = Math.floor(zC(HC));
function KC(n) {
  n = n.toUpperCase(), n = n.substring(4) + n.substring(0, 2) + "00";
  let e = n.split("").map((r) => lp[r]).join("");
  for (; e.length >= Wg; ) {
    let r = e.substring(0, Wg);
    e = parseInt(r, 10) % 97 + e.substring(r.length);
  }
  let t = String(98 - parseInt(e, 10) % 97);
  for (; t.length < 2; )
    t = "0" + t;
  return t;
}
function Rt(n) {
  let e = null;
  if (typeof n != "string" && $a.throwArgumentError("invalid address", "address", n), n.match(/^(0x)?[0-9a-fA-F]{40}$/))
    n.substring(0, 2) !== "0x" && (n = "0x" + n), e = Gg(n), n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== n && $a.throwArgumentError("bad address checksum", "address", n);
  else if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (n.substring(2, 4) !== KC(n) && $a.throwArgumentError("bad icap checksum", "address", n), e = nC(n.substring(4)); e.length < 40; )
      e = "0" + e;
    e = Gg("0x" + e);
  } else
    $a.throwArgumentError("invalid address", "address", n);
  return e;
}
function f2(n) {
  let e = null;
  try {
    e = Rt(n.from);
  } catch {
    $a.throwArgumentError("missing from address", "transaction", n);
  }
  const t = Xa(ae(G.from(n.nonce).toHexString()));
  return Rt(an(Mt(il([e, t])), 12));
}
class qC extends Di {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, t) {
    try {
      t = Rt(t);
    } catch (r) {
      this._throwError(r.message, t);
    }
    return e.writeValue(t);
  }
  decode(e) {
    return Rt(Le(e.readValue().toHexString(), 20));
  }
}
class QC extends Di {
  constructor(e) {
    super(e.name, e.type, void 0, e.dynamic), this.coder = e;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, t) {
    return this.coder.encode(e, t);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
const La = new O(rl);
function h2(n, e, t) {
  let r = null;
  if (Array.isArray(t))
    r = t;
  else if (t && typeof t == "object") {
    let c = {};
    r = e.map((l) => {
      const f = l.localName;
      return f || La.throwError("cannot encode object for signature with missing names", O.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: l,
        value: t
      }), c[f] && La.throwError("cannot encode object for signature with duplicate names", O.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: l,
        value: t
      }), c[f] = !0, t[f];
    });
  } else
    La.throwArgumentError("invalid tuple value", "tuple", t);
  e.length !== r.length && La.throwArgumentError("types/value length mismatch", "tuple", t);
  let i = new kh(n.wordSize), s = new kh(n.wordSize), a = [];
  e.forEach((c, l) => {
    let f = r[l];
    if (c.dynamic) {
      let p = s.length;
      c.encode(s, f);
      let g = i.writeUpdatableValue();
      a.push((T) => {
        g(T + p);
      });
    } else
      c.encode(i, f);
  }), a.forEach((c) => {
    c(i.length);
  });
  let o = n.appendWriter(i);
  return o += n.appendWriter(s), o;
}
function p2(n, e) {
  let t = [], r = n.subReader(0);
  e.forEach((s) => {
    let a = null;
    if (s.dynamic) {
      let o = n.readValue(), c = r.subReader(o.toNumber());
      try {
        a = s.decode(c);
      } catch (l) {
        if (l.code === O.errors.BUFFER_OVERRUN)
          throw l;
        a = l, a.baseType = s.name, a.name = s.localName, a.type = s.type;
      }
    } else
      try {
        a = s.decode(n);
      } catch (o) {
        if (o.code === O.errors.BUFFER_OVERRUN)
          throw o;
        a = o, a.baseType = s.name, a.name = s.localName, a.type = s.type;
      }
    a != null && t.push(a);
  });
  const i = e.reduce((s, a) => {
    const o = a.localName;
    return o && (s[o] || (s[o] = 0), s[o]++), s;
  }, {});
  e.forEach((s, a) => {
    let o = s.localName;
    if (!o || i[o] !== 1 || (o === "length" && (o = "_length"), t[o] != null))
      return;
    const c = t[a];
    c instanceof Error ? Object.defineProperty(t, o, {
      enumerable: !0,
      get: () => {
        throw c;
      }
    }) : t[o] = c;
  });
  for (let s = 0; s < t.length; s++) {
    const a = t[s];
    a instanceof Error && Object.defineProperty(t, s, {
      enumerable: !0,
      get: () => {
        throw a;
      }
    });
  }
  return Object.freeze(t);
}
class JC extends Di {
  constructor(e, t, r) {
    const i = e.type + "[" + (t >= 0 ? t : "") + "]", s = t === -1 || e.dynamic;
    super("array", i, r, s), this.coder = e, this.length = t;
  }
  defaultValue() {
    const e = this.coder.defaultValue(), t = [];
    for (let r = 0; r < this.length; r++)
      t.push(e);
    return t;
  }
  encode(e, t) {
    Array.isArray(t) || this._throwError("expected array value", t);
    let r = this.length;
    r === -1 && (r = t.length, e.writeValue(t.length)), La.checkArgumentCount(t.length, r, "coder array" + (this.localName ? " " + this.localName : ""));
    let i = [];
    for (let s = 0; s < t.length; s++)
      i.push(this.coder);
    return h2(e, i, t);
  }
  decode(e) {
    let t = this.length;
    t === -1 && (t = e.readValue().toNumber(), t * 32 > e._data.length && La.throwError("insufficient data length", O.errors.BUFFER_OVERRUN, {
      length: e._data.length,
      count: t
    }));
    let r = [];
    for (let i = 0; i < t; i++)
      r.push(new QC(this.coder));
    return e.coerce(this.name, p2(e, r));
  }
}
class YC extends Di {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    return e.writeValue(t ? 1 : 0);
  }
  decode(e) {
    return e.coerce(this.type, !e.readValue().isZero());
  }
}
class m2 extends Di {
  constructor(e, t) {
    super(e, e, t, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, t) {
    t = ae(t);
    let r = e.writeValue(t.length);
    return r += e.writeBytes(t), r;
  }
  decode(e) {
    return e.readBytes(e.readValue().toNumber(), !0);
  }
}
class XC extends m2 {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return e.coerce(this.name, te(super.decode(e)));
  }
}
class ZC extends Di {
  constructor(e, t) {
    let r = "bytes" + String(e);
    super(r, r, t, !1), this.size = e;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(e, t) {
    let r = ae(t);
    return r.length !== this.size && this._throwError("incorrect data length", t), e.writeBytes(r);
  }
  decode(e) {
    return e.coerce(this.name, te(e.readBytes(this.size)));
  }
}
class eE extends Di {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, t) {
    return t != null && this._throwError("not null", t), e.writeBytes([]);
  }
  decode(e) {
    return e.readBytes(0), e.coerce(this.name, null);
  }
}
const tE = "0x0000000000000000000000000000000000000000", nE = /* @__PURE__ */ G.from(-1), up = /* @__PURE__ */ G.from(0), rE = /* @__PURE__ */ G.from(1), iE = /* @__PURE__ */ G.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), sE = "0x0000000000000000000000000000000000000000000000000000000000000000";
class aE extends Di {
  constructor(e, t, r) {
    const i = (t ? "int" : "uint") + e * 8;
    super(i, i, r, !1), this.size = e, this.signed = t;
  }
  defaultValue() {
    return 0;
  }
  encode(e, t) {
    let r = G.from(t), i = iE.mask(e.wordSize * 8);
    if (this.signed) {
      let s = i.mask(this.size * 8 - 1);
      (r.gt(s) || r.lt(s.add(rE).mul(nE))) && this._throwError("value out-of-bounds", t);
    } else
      (r.lt(up) || r.gt(i.mask(this.size * 8))) && this._throwError("value out-of-bounds", t);
    return r = r.toTwos(this.size * 8).mask(this.size * 8), this.signed && (r = r.fromTwos(this.size * 8).toTwos(8 * e.wordSize)), e.writeValue(r);
  }
  decode(e) {
    let t = e.readValue().mask(this.size * 8);
    return this.signed && (t = t.fromTwos(this.size * 8)), e.coerce(this.name, t);
  }
}
const oE = "strings/5.7.0", y2 = new O(oE);
var Ec;
(function(n) {
  n.current = "", n.NFC = "NFC", n.NFD = "NFD", n.NFKC = "NFKC", n.NFKD = "NFKD";
})(Ec || (Ec = {}));
var Vn;
(function(n) {
  n.UNEXPECTED_CONTINUE = "unexpected continuation byte", n.BAD_PREFIX = "bad codepoint prefix", n.OVERRUN = "string overrun", n.MISSING_CONTINUE = "missing continuation byte", n.OUT_OF_RANGE = "out of UTF-8 range", n.UTF16_SURROGATE = "UTF-16 surrogate", n.OVERLONG = "overlong representation";
})(Vn || (Vn = {}));
function cE(n, e, t, r, i) {
  return y2.throwArgumentError(`invalid codepoint at offset ${e}; ${n}`, "bytes", t);
}
function g2(n, e, t, r, i) {
  if (n === Vn.BAD_PREFIX || n === Vn.UNEXPECTED_CONTINUE) {
    let s = 0;
    for (let a = e + 1; a < t.length && t[a] >> 6 === 2; a++)
      s++;
    return s;
  }
  return n === Vn.OVERRUN ? t.length - e - 1 : 0;
}
function lE(n, e, t, r, i) {
  return n === Vn.OVERLONG ? (r.push(i), 0) : (r.push(65533), g2(n, e, t));
}
const uE = Object.freeze({
  error: cE,
  ignore: g2,
  replace: lE
});
function b2(n, e) {
  e == null && (e = uE.error), n = ae(n);
  const t = [];
  let r = 0;
  for (; r < n.length; ) {
    const i = n[r++];
    if (i >> 7 === 0) {
      t.push(i);
      continue;
    }
    let s = null, a = null;
    if ((i & 224) === 192)
      s = 1, a = 127;
    else if ((i & 240) === 224)
      s = 2, a = 2047;
    else if ((i & 248) === 240)
      s = 3, a = 65535;
    else {
      (i & 192) === 128 ? r += e(Vn.UNEXPECTED_CONTINUE, r - 1, n, t) : r += e(Vn.BAD_PREFIX, r - 1, n, t);
      continue;
    }
    if (r - 1 + s >= n.length) {
      r += e(Vn.OVERRUN, r - 1, n, t);
      continue;
    }
    let o = i & (1 << 8 - s - 1) - 1;
    for (let c = 0; c < s; c++) {
      let l = n[r];
      if ((l & 192) != 128) {
        r += e(Vn.MISSING_CONTINUE, r, n, t), o = null;
        break;
      }
      o = o << 6 | l & 63, r++;
    }
    if (o !== null) {
      if (o > 1114111) {
        r += e(Vn.OUT_OF_RANGE, r - 1 - s, n, t, o);
        continue;
      }
      if (o >= 55296 && o <= 57343) {
        r += e(Vn.UTF16_SURROGATE, r - 1 - s, n, t, o);
        continue;
      }
      if (o <= a) {
        r += e(Vn.OVERLONG, r - 1 - s, n, t, o);
        continue;
      }
      t.push(o);
    }
  }
  return t;
}
function Pr(n, e = Ec.current) {
  e != Ec.current && (y2.checkNormalize(), n = n.normalize(e));
  let t = [];
  for (let r = 0; r < n.length; r++) {
    const i = n.charCodeAt(r);
    if (i < 128)
      t.push(i);
    else if (i < 2048)
      t.push(i >> 6 | 192), t.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      r++;
      const s = n.charCodeAt(r);
      if (r >= n.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const a = 65536 + ((i & 1023) << 10) + (s & 1023);
      t.push(a >> 18 | 240), t.push(a >> 12 & 63 | 128), t.push(a >> 6 & 63 | 128), t.push(a & 63 | 128);
    } else
      t.push(i >> 12 | 224), t.push(i >> 6 & 63 | 128), t.push(i & 63 | 128);
  }
  return ae(t);
}
function dE(n) {
  return n.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function sl(n, e) {
  return dE(b2(n, e));
}
function fE(n, e = Ec.current) {
  return b2(Pr(n, e));
}
class hE extends m2 {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, t) {
    return super.encode(e, Pr(t));
  }
  decode(e) {
    return sl(super.decode(e));
  }
}
class Sl extends Di {
  constructor(e, t) {
    let r = !1;
    const i = [];
    e.forEach((a) => {
      a.dynamic && (r = !0), i.push(a.type);
    });
    const s = "tuple(" + i.join(",") + ")";
    super("tuple", s, t, r), this.coders = e;
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((r) => {
      e.push(r.defaultValue());
    });
    const t = this.coders.reduce((r, i) => {
      const s = i.localName;
      return s && (r[s] || (r[s] = 0), r[s]++), r;
    }, {});
    return this.coders.forEach((r, i) => {
      let s = r.localName;
      !s || t[s] !== 1 || (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[i]));
    }), Object.freeze(e);
  }
  encode(e, t) {
    return h2(e, this.coders, t);
  }
  decode(e) {
    return e.coerce(this.name, p2(e, this.coders));
  }
}
const _l = new O(rl), pE = new RegExp(/^bytes([0-9]*)$/), mE = new RegExp(/^(u?int)([0-9]*)$/);
class yE {
  constructor(e) {
    H(this, "coerceFunc", e || null);
  }
  _getCoder(e) {
    switch (e.baseType) {
      case "address":
        return new qC(e.name);
      case "bool":
        return new YC(e.name);
      case "string":
        return new hE(e.name);
      case "bytes":
        return new XC(e.name);
      case "array":
        return new JC(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
      case "tuple":
        return new Sl((e.components || []).map((r) => this._getCoder(r)), e.name);
      case "":
        return new eE(e.name);
    }
    let t = e.type.match(mE);
    if (t) {
      let r = parseInt(t[2] || "256");
      return (r === 0 || r > 256 || r % 8 !== 0) && _l.throwArgumentError("invalid " + t[1] + " bit length", "param", e), new aE(r / 8, t[1] === "int", e.name);
    }
    if (t = e.type.match(pE), t) {
      let r = parseInt(t[1]);
      return (r === 0 || r > 32) && _l.throwArgumentError("invalid bytes length", "param", e), new ZC(r, e.name);
    }
    return _l.throwArgumentError("invalid type", "type", e.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(e, t) {
    return new Pu(e, this._getWordSize(), this.coerceFunc, t);
  }
  _getWriter() {
    return new kh(this._getWordSize());
  }
  getDefaultValue(e) {
    const t = e.map((i) => this._getCoder(Wt.from(i)));
    return new Sl(t, "_").defaultValue();
  }
  encode(e, t) {
    e.length !== t.length && _l.throwError("types/values length mismatch", O.errors.INVALID_ARGUMENT, {
      count: { types: e.length, values: t.length },
      value: { types: e, values: t }
    });
    const r = e.map((a) => this._getCoder(Wt.from(a))), i = new Sl(r, "_"), s = this._getWriter();
    return i.encode(s, t), s.data;
  }
  decode(e, t, r) {
    const i = e.map((a) => this._getCoder(Wt.from(a)));
    return new Sl(i, "_").decode(this._getReader(ae(t), r));
  }
}
const gE = new yE();
function Ks(n) {
  return Mt(Pr(n));
}
const x2 = "hash/5.7.0";
function v2(n) {
  n = atob(n);
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push(n.charCodeAt(t));
  return ae(e);
}
function w2(n) {
  n = ae(n);
  let e = "";
  for (let t = 0; t < n.length; t++)
    e += String.fromCharCode(n[t]);
  return btoa(e);
}
function A2(n, e) {
  e == null && (e = 1);
  const t = [], r = t.forEach, i = function(s, a) {
    r.call(s, function(o) {
      a > 0 && Array.isArray(o) ? i(o, a - 1) : t.push(o);
    });
  };
  return i(n, e), t;
}
function bE(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const r = n[t];
    e[r[0]] = r[1];
  }
  return e;
}
function xE(n) {
  let e = 0;
  function t() {
    return n[e++] << 8 | n[e++];
  }
  let r = t(), i = 1, s = [0, 1];
  for (let D = 1; D < r; D++)
    s.push(i += t());
  let a = t(), o = e;
  e += a;
  let c = 0, l = 0;
  function f() {
    return c == 0 && (l = l << 8 | n[e++], c = 8), l >> --c & 1;
  }
  const p = 31, g = Math.pow(2, p), T = g >>> 1, v = T >> 1, w = g - 1;
  let C = 0;
  for (let D = 0; D < p; D++)
    C = C << 1 | f();
  let _ = [], I = 0, B = g;
  for (; ; ) {
    let D = Math.floor(((C - I + 1) * i - 1) / B), U = 0, W = r;
    for (; W - U > 1; ) {
      let ce = U + W >>> 1;
      D < s[ce] ? W = ce : U = ce;
    }
    if (U == 0)
      break;
    _.push(U);
    let j = I + Math.floor(B * s[U] / i), q = I + Math.floor(B * s[U + 1] / i) - 1;
    for (; ((j ^ q) & T) == 0; )
      C = C << 1 & w | f(), j = j << 1 & w, q = q << 1 & w | 1;
    for (; j & ~q & v; )
      C = C & T | C << 1 & w >>> 1 | f(), j = j << 1 ^ T, q = (q ^ T) << 1 | T | 1;
    I = j, B = 1 + q - j;
  }
  let N = r - 4;
  return _.map((D) => {
    switch (D - N) {
      case 3:
        return N + 65792 + (n[o++] << 16 | n[o++] << 8 | n[o++]);
      case 2:
        return N + 256 + (n[o++] << 8 | n[o++]);
      case 1:
        return N + n[o++];
      default:
        return D - 1;
    }
  });
}
function vE(n) {
  let e = 0;
  return () => n[e++];
}
function wE(n) {
  return vE(xE(n));
}
function AE(n) {
  return n & 1 ? ~n >> 1 : n >> 1;
}
function TE(n, e) {
  let t = Array(n);
  for (let r = 0; r < n; r++)
    t[r] = 1 + e();
  return t;
}
function Hg(n, e) {
  let t = Array(n);
  for (let r = 0, i = -1; r < n; r++)
    t[r] = i += 1 + e();
  return t;
}
function CE(n, e) {
  let t = Array(n);
  for (let r = 0, i = 0; r < n; r++)
    t[r] = i += AE(e());
  return t;
}
function Mu(n, e) {
  let t = Hg(n(), n), r = n(), i = Hg(r, n), s = TE(r, n);
  for (let a = 0; a < r; a++)
    for (let o = 0; o < s[a]; o++)
      t.push(i[a] + o);
  return e ? t.map((a) => e[a]) : t;
}
function EE(n) {
  let e = [];
  for (; ; ) {
    let t = n();
    if (t == 0)
      break;
    e.push(_E(t, n));
  }
  for (; ; ) {
    let t = n() - 1;
    if (t < 0)
      break;
    e.push(PE(t, n));
  }
  return bE(A2(e));
}
function SE(n) {
  let e = [];
  for (; ; ) {
    let t = n();
    if (t == 0)
      break;
    e.push(t);
  }
  return e;
}
function T2(n, e, t) {
  let r = Array(n).fill(void 0).map(() => []);
  for (let i = 0; i < e; i++)
    CE(n, t).forEach((s, a) => r[a].push(s));
  return r;
}
function _E(n, e) {
  let t = 1 + e(), r = e(), i = SE(e), s = T2(i.length, 1 + n, e);
  return A2(s.map((a, o) => {
    const c = a[0], l = a.slice(1);
    return Array(i[o]).fill(void 0).map((f, p) => {
      let g = p * r;
      return [c + p * t, l.map((T) => T + g)];
    });
  }));
}
function PE(n, e) {
  let t = 1 + e();
  return T2(t, 1 + n, e).map((i) => [i[0], i.slice(1)]);
}
function ME(n) {
  let e = Mu(n).sort((r, i) => r - i);
  return t();
  function t() {
    let r = [];
    for (; ; ) {
      let l = Mu(n, e);
      if (l.length == 0)
        break;
      r.push({ set: new Set(l), node: t() });
    }
    r.sort((l, f) => f.set.size - l.set.size);
    let i = n(), s = i % 3;
    i = i / 3 | 0;
    let a = !!(i & 1);
    i >>= 1;
    let o = i == 1, c = i == 2;
    return { branches: r, valid: s, fe0f: a, save: o, check: c };
  }
}
function RE() {
  return wE(v2("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const Ad = RE(), kE = new Set(Mu(Ad)), IE = new Set(Mu(Ad)), OE = EE(Ad), DE = ME(Ad), zg = 45, Kg = 95;
function C2(n) {
  return fE(n);
}
function NE(n) {
  return n.filter((e) => e != 65039);
}
function E2(n) {
  for (let e of n.split(".")) {
    let t = C2(e);
    try {
      for (let r = t.lastIndexOf(Kg) - 1; r >= 0; r--)
        if (t[r] !== Kg)
          throw new Error("underscore only allowed at start");
      if (t.length >= 4 && t.every((r) => r < 128) && t[2] === zg && t[3] === zg)
        throw new Error("invalid label extension");
    } catch (r) {
      throw new Error(`Invalid label "${e}": ${r.message}`);
    }
  }
  return n;
}
function BE(n) {
  return E2($E(n, NE));
}
function $E(n, e) {
  let t = C2(n).reverse(), r = [];
  for (; t.length; ) {
    let i = FE(t);
    if (i) {
      r.push(...e(i));
      continue;
    }
    let s = t.pop();
    if (kE.has(s)) {
      r.push(s);
      continue;
    }
    if (IE.has(s))
      continue;
    let a = OE[s];
    if (a) {
      r.push(...a);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`);
  }
  return E2(LE(String.fromCodePoint(...r)));
}
function LE(n) {
  return n.normalize("NFC");
}
function FE(n, e) {
  var t;
  let r = DE, i, s, a = [], o = n.length;
  for (e && (e.length = 0); o; ) {
    let c = n[--o];
    if (r = (t = r.branches.find((l) => l.set.has(c))) === null || t === void 0 ? void 0 : t.node, !r)
      break;
    if (r.save)
      s = c;
    else if (r.check && c === s)
      break;
    a.push(c), r.fe0f && (a.push(65039), o > 0 && n[o - 1] == 65039 && o--), r.valid && (i = a.slice(), r.valid == 2 && i.splice(1, 1), e && e.push(...n.slice(o).reverse()), n.length = o);
  }
  return i;
}
const UE = new O(x2), S2 = new Uint8Array(32);
S2.fill(0);
function qg(n) {
  if (n.length === 0)
    throw new Error("invalid ENS name; empty component");
  return n;
}
function _2(n) {
  const e = Pr(BE(n)), t = [];
  if (n.length === 0)
    return t;
  let r = 0;
  for (let i = 0; i < e.length; i++)
    e[i] === 46 && (t.push(qg(e.slice(r, i))), r = i + 1);
  if (r >= e.length)
    throw new Error("invalid ENS name; empty component");
  return t.push(qg(e.slice(r))), t;
}
function Zl(n) {
  typeof n != "string" && UE.throwArgumentError("invalid ENS name; not a string", "name", n);
  let e = S2;
  const t = _2(n);
  for (; t.length; )
    e = Mt(zn([e, Mt(t.pop())]));
  return te(e);
}
function VE(n) {
  return te(zn(_2(n).map((e) => {
    if (e.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const t = new Uint8Array(e.length + 1);
    return t.set(e, 1), t[0] = t.length - 1, t;
  }))) + "00";
}
var jE = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const wt = new O(x2), P2 = new Uint8Array(32);
P2.fill(0);
const GE = G.from(-1), M2 = G.from(0), R2 = G.from(1), WE = G.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function HE(n) {
  const e = ae(n), t = e.length % 32;
  return t ? Pn([e, P2.slice(t)]) : te(e);
}
const zE = Le(R2.toHexString(), 32), KE = Le(M2.toHexString(), 32), Qg = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, kf = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function Jg(n) {
  return function(e) {
    return typeof e != "string" && wt.throwArgumentError(`invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, e), e;
  };
}
const qE = {
  name: Jg("name"),
  version: Jg("version"),
  chainId: function(n) {
    try {
      return G.from(n).toString();
    } catch {
    }
    return wt.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", n);
  },
  verifyingContract: function(n) {
    try {
      return Rt(n).toLowerCase();
    } catch {
    }
    return wt.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", n);
  },
  salt: function(n) {
    try {
      const e = ae(n);
      if (e.length !== 32)
        throw new Error("bad length");
      return te(e);
    } catch {
    }
    return wt.throwArgumentError('invalid domain value "salt"', "domain.salt", n);
  }
};
function If(n) {
  {
    const e = n.match(/^(u?)int(\d*)$/);
    if (e) {
      const t = e[1] === "", r = parseInt(e[2] || "256");
      (r % 8 !== 0 || r > 256 || e[2] && e[2] !== String(r)) && wt.throwArgumentError("invalid numeric width", "type", n);
      const i = WE.mask(t ? r - 1 : r), s = t ? i.add(R2).mul(GE) : M2;
      return function(a) {
        const o = G.from(a);
        return (o.lt(s) || o.gt(i)) && wt.throwArgumentError(`value out-of-bounds for ${n}`, "value", a), Le(o.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const e = n.match(/^bytes(\d+)$/);
    if (e) {
      const t = parseInt(e[1]);
      return (t === 0 || t > 32 || e[1] !== String(t)) && wt.throwArgumentError("invalid bytes width", "type", n), function(r) {
        return ae(r).length !== t && wt.throwArgumentError(`invalid length for ${n}`, "value", r), HE(r);
      };
    }
  }
  switch (n) {
    case "address":
      return function(e) {
        return Le(Rt(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? zE : KE;
      };
    case "bytes":
      return function(e) {
        return Mt(e);
      };
    case "string":
      return function(e) {
        return Ks(e);
      };
  }
  return null;
}
function Yg(n, e) {
  return `${n}(${e.map(({ name: t, type: r }) => r + " " + t).join(",")})`;
}
class Un {
  constructor(e) {
    H(this, "types", Object.freeze(Ci(e))), H(this, "_encoderCache", {}), H(this, "_types", {});
    const t = {}, r = {}, i = {};
    Object.keys(e).forEach((o) => {
      t[o] = {}, r[o] = [], i[o] = {};
    });
    for (const o in e) {
      const c = {};
      e[o].forEach((l) => {
        c[l.name] && wt.throwArgumentError(`duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(o)}`, "types", e), c[l.name] = !0;
        const f = l.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        f === o && wt.throwArgumentError(`circular type reference to ${JSON.stringify(f)}`, "types", e), !If(f) && (r[f] || wt.throwArgumentError(`unknown type ${JSON.stringify(f)}`, "types", e), r[f].push(o), t[o][f] = !0);
      });
    }
    const s = Object.keys(r).filter((o) => r[o].length === 0);
    s.length === 0 ? wt.throwArgumentError("missing primary type", "types", e) : s.length > 1 && wt.throwArgumentError(`ambiguous primary types or unused types: ${s.map((o) => JSON.stringify(o)).join(", ")}`, "types", e), H(this, "primaryType", s[0]);
    function a(o, c) {
      c[o] && wt.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`, "types", e), c[o] = !0, Object.keys(t[o]).forEach((l) => {
        !r[l] || (a(l, c), Object.keys(c).forEach((f) => {
          i[f][l] = !0;
        }));
      }), delete c[o];
    }
    a(this.primaryType, {});
    for (const o in i) {
      const c = Object.keys(i[o]);
      c.sort(), this._types[o] = Yg(o, e[o]) + c.map((l) => Yg(l, e[l])).join("");
    }
  }
  getEncoder(e) {
    let t = this._encoderCache[e];
    return t || (t = this._encoderCache[e] = this._getEncoder(e)), t;
  }
  _getEncoder(e) {
    {
      const i = If(e);
      if (i)
        return i;
    }
    const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (t) {
      const i = t[1], s = this.getEncoder(i), a = parseInt(t[3]);
      return (o) => {
        a >= 0 && o.length !== a && wt.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", o);
        let c = o.map(s);
        return this._types[i] && (c = c.map(Mt)), Mt(Pn(c));
      };
    }
    const r = this.types[e];
    if (r) {
      const i = Ks(this._types[e]);
      return (s) => {
        const a = r.map(({ name: o, type: c }) => {
          const l = this.getEncoder(c)(s[o]);
          return this._types[c] ? Mt(l) : l;
        });
        return a.unshift(i), Pn(a);
      };
    }
    return wt.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  encodeType(e) {
    const t = this._types[e];
    return t || wt.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), t;
  }
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  hashStruct(e, t) {
    return Mt(this.encodeData(e, t));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, t, r) {
    if (If(e))
      return r(e, t);
    const i = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (i) {
      const a = i[1], o = parseInt(i[3]);
      return o >= 0 && t.length !== o && wt.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", t), t.map((c) => this._visit(a, c, r));
    }
    const s = this.types[e];
    return s ? s.reduce((a, { name: o, type: c }) => (a[o] = this._visit(c, t[o], r), a), {}) : wt.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  static from(e) {
    return new Un(e);
  }
  static getPrimaryType(e) {
    return Un.from(e).primaryType;
  }
  static hashStruct(e, t, r) {
    return Un.from(t).hashStruct(e, r);
  }
  static hashDomain(e) {
    const t = [];
    for (const r in e) {
      const i = Qg[r];
      i || wt.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(r)}`, "domain", e), t.push({ name: r, type: i });
    }
    return t.sort((r, i) => kf.indexOf(r.name) - kf.indexOf(i.name)), Un.hashStruct("EIP712Domain", { EIP712Domain: t }, e);
  }
  static encode(e, t, r) {
    return Pn([
      "0x1901",
      Un.hashDomain(e),
      Un.from(t).hash(r)
    ]);
  }
  static hash(e, t, r) {
    return Mt(Un.encode(e, t, r));
  }
  static resolveNames(e, t, r, i) {
    return jE(this, void 0, void 0, function* () {
      e = $t(e);
      const s = {};
      e.verifyingContract && !Pe(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
      const a = Un.from(t);
      a.visit(r, (o, c) => (o === "address" && !Pe(c, 20) && (s[c] = "0x"), c));
      for (const o in s)
        s[o] = yield i(o);
      return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), r = a.visit(r, (o, c) => o === "address" && s[c] ? s[c] : c), { domain: e, value: r };
    });
  }
  static getPayload(e, t, r) {
    Un.hashDomain(e);
    const i = {}, s = [];
    kf.forEach((c) => {
      const l = e[c];
      l != null && (i[c] = qE[c](l), s.push({ name: c, type: Qg[c] }));
    });
    const a = Un.from(t), o = $t(t);
    return o.EIP712Domain ? wt.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", t) : o.EIP712Domain = s, a.encode(r), {
      types: o,
      domain: i,
      primaryType: a.primaryType,
      message: a.visit(r, (c, l) => {
        if (c.match(/^bytes(\d*)/))
          return te(ae(l));
        if (c.match(/^u?int/))
          return G.from(l).toString();
        switch (c) {
          case "address":
            return l.toLowerCase();
          case "bool":
            return !!l;
          case "string":
            return typeof l != "string" && wt.throwArgumentError("invalid string", "value", l), l;
        }
        return wt.throwArgumentError("unsupported type", "type", c);
      })
    };
  }
}
const vt = new O(rl);
class QE extends nl {
}
class JE extends nl {
}
class YE extends nl {
}
class Ih extends nl {
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const XE = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function Xg(n, e) {
  const t = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
  return t.error = e, t;
}
class Zg {
  constructor(e) {
    let t = [];
    typeof e == "string" ? t = JSON.parse(e) : t = e, H(this, "fragments", t.map((r) => hi.from(r)).filter((r) => r != null)), H(this, "_abiCoder", jr(new.target, "getAbiCoder")()), H(this, "functions", {}), H(this, "errors", {}), H(this, "events", {}), H(this, "structs", {}), this.fragments.forEach((r) => {
      let i = null;
      switch (r.type) {
        case "constructor":
          if (this.deploy) {
            vt.warn("duplicate definition - constructor");
            return;
          }
          H(this, "deploy", r);
          return;
        case "function":
          i = this.functions;
          break;
        case "event":
          i = this.events;
          break;
        case "error":
          i = this.errors;
          break;
        default:
          return;
      }
      let s = r.format();
      if (i[s]) {
        vt.warn("duplicate definition - " + s);
        return;
      }
      i[s] = r;
    }), this.deploy || H(this, "deploy", Ur.from({
      payable: !1,
      type: "constructor"
    })), H(this, "_isInterface", !0);
  }
  format(e) {
    e || (e = _e.full), e === _e.sighash && vt.throwArgumentError("interface does not support formatting sighash", "format", e);
    const t = this.fragments.map((r) => r.format(e));
    return e === _e.json ? JSON.stringify(t.map((r) => JSON.parse(r))) : t;
  }
  static getAbiCoder() {
    return gE;
  }
  static getAddress(e) {
    return Rt(e);
  }
  static getSighash(e) {
    return an(Ks(e.format()), 0, 4);
  }
  static getEventTopic(e) {
    return Ks(e.format());
  }
  getFunction(e) {
    if (Pe(e)) {
      for (const r in this.functions)
        if (e === this.getSighash(r))
          return this.functions[r];
      vt.throwArgumentError("no matching function", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(), i = Object.keys(this.functions).filter((s) => s.split("(")[0] === r);
      return i.length === 0 ? vt.throwArgumentError("no matching function", "name", r) : i.length > 1 && vt.throwArgumentError("multiple matching functions", "name", r), this.functions[i[0]];
    }
    const t = this.functions[Vr.fromString(e).format()];
    return t || vt.throwArgumentError("no matching function", "signature", e), t;
  }
  getEvent(e) {
    if (Pe(e)) {
      const r = e.toLowerCase();
      for (const i in this.events)
        if (r === this.getEventTopic(i))
          return this.events[i];
      vt.throwArgumentError("no matching event", "topichash", r);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(), i = Object.keys(this.events).filter((s) => s.split("(")[0] === r);
      return i.length === 0 ? vt.throwArgumentError("no matching event", "name", r) : i.length > 1 && vt.throwArgumentError("multiple matching events", "name", r), this.events[i[0]];
    }
    const t = this.events[fi.fromString(e).format()];
    return t || vt.throwArgumentError("no matching event", "signature", e), t;
  }
  getError(e) {
    if (Pe(e)) {
      const r = jr(this.constructor, "getSighash");
      for (const i in this.errors) {
        const s = this.errors[i];
        if (e === r(s))
          return this.errors[i];
      }
      vt.throwArgumentError("no matching error", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const r = e.trim(), i = Object.keys(this.errors).filter((s) => s.split("(")[0] === r);
      return i.length === 0 ? vt.throwArgumentError("no matching error", "name", r) : i.length > 1 && vt.throwArgumentError("multiple matching errors", "name", r), this.errors[i[0]];
    }
    const t = this.errors[Vr.fromString(e).format()];
    return t || vt.throwArgumentError("no matching error", "signature", e), t;
  }
  getSighash(e) {
    if (typeof e == "string")
      try {
        e = this.getFunction(e);
      } catch (t) {
        try {
          e = this.getError(e);
        } catch {
          throw t;
        }
      }
    return jr(this.constructor, "getSighash")(e);
  }
  getEventTopic(e) {
    return typeof e == "string" && (e = this.getEvent(e)), jr(this.constructor, "getEventTopic")(e);
  }
  _decodeParams(e, t) {
    return this._abiCoder.decode(e, t);
  }
  _encodeParams(e, t) {
    return this._abiCoder.encode(e, t);
  }
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  decodeErrorResult(e, t) {
    typeof e == "string" && (e = this.getError(e));
    const r = ae(t);
    return te(r.slice(0, 4)) !== this.getSighash(e) && vt.throwArgumentError(`data signature does not match error ${e.name}.`, "data", te(r)), this._decodeParams(e.inputs, r.slice(4));
  }
  encodeErrorResult(e, t) {
    return typeof e == "string" && (e = this.getError(e)), te(zn([
      this.getSighash(e),
      this._encodeParams(e.inputs, t || [])
    ]));
  }
  decodeFunctionData(e, t) {
    typeof e == "string" && (e = this.getFunction(e));
    const r = ae(t);
    return te(r.slice(0, 4)) !== this.getSighash(e) && vt.throwArgumentError(`data signature does not match function ${e.name}.`, "data", te(r)), this._decodeParams(e.inputs, r.slice(4));
  }
  encodeFunctionData(e, t) {
    return typeof e == "string" && (e = this.getFunction(e)), te(zn([
      this.getSighash(e),
      this._encodeParams(e.inputs, t || [])
    ]));
  }
  decodeFunctionResult(e, t) {
    typeof e == "string" && (e = this.getFunction(e));
    let r = ae(t), i = null, s = "", a = null, o = null, c = null;
    switch (r.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(e.outputs, r);
        } catch {
        }
        break;
      case 4: {
        const l = te(r.slice(0, 4)), f = XE[l];
        if (f)
          a = this._abiCoder.decode(f.inputs, r.slice(4)), o = f.name, c = f.signature, f.reason && (i = a[0]), o === "Error" ? s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(a[0])}` : o === "Panic" && (s = `; VM Exception while processing transaction: reverted with panic code ${a[0]}`);
        else
          try {
            const p = this.getError(l);
            a = this._abiCoder.decode(p.inputs, r.slice(4)), o = p.name, c = p.format();
          } catch {
          }
        break;
      }
    }
    return vt.throwError("call revert exception" + s, O.errors.CALL_EXCEPTION, {
      method: e.format(),
      data: te(t),
      errorArgs: a,
      errorName: o,
      errorSignature: c,
      reason: i
    });
  }
  encodeFunctionResult(e, t) {
    return typeof e == "string" && (e = this.getFunction(e)), te(this._abiCoder.encode(e.outputs, t || []));
  }
  encodeFilterTopics(e, t) {
    typeof e == "string" && (e = this.getEvent(e)), t.length > e.inputs.length && vt.throwError("too many arguments for " + e.format(), O.errors.UNEXPECTED_ARGUMENT, {
      argument: "values",
      value: t
    });
    let r = [];
    e.anonymous || r.push(this.getEventTopic(e));
    const i = (s, a) => s.type === "string" ? Ks(a) : s.type === "bytes" ? Mt(te(a)) : (s.type === "bool" && typeof a == "boolean" && (a = a ? "0x01" : "0x00"), s.type.match(/^u?int/) && (a = G.from(a).toHexString()), s.type === "address" && this._abiCoder.encode(["address"], [a]), Le(te(a), 32));
    for (t.forEach((s, a) => {
      let o = e.inputs[a];
      if (!o.indexed) {
        s != null && vt.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + o.name, s);
        return;
      }
      s == null ? r.push(null) : o.baseType === "array" || o.baseType === "tuple" ? vt.throwArgumentError("filtering with tuples or arrays not supported", "contract." + o.name, s) : Array.isArray(s) ? r.push(s.map((c) => i(o, c))) : r.push(i(o, s));
    }); r.length && r[r.length - 1] === null; )
      r.pop();
    return r;
  }
  encodeEventLog(e, t) {
    typeof e == "string" && (e = this.getEvent(e));
    const r = [], i = [], s = [];
    return e.anonymous || r.push(this.getEventTopic(e)), t.length !== e.inputs.length && vt.throwArgumentError("event arguments/values mismatch", "values", t), e.inputs.forEach((a, o) => {
      const c = t[o];
      if (a.indexed)
        if (a.type === "string")
          r.push(Ks(c));
        else if (a.type === "bytes")
          r.push(Mt(c));
        else {
          if (a.baseType === "tuple" || a.baseType === "array")
            throw new Error("not implemented");
          r.push(this._abiCoder.encode([a.type], [c]));
        }
      else
        i.push(a), s.push(c);
    }), {
      data: this._abiCoder.encode(i, s),
      topics: r
    };
  }
  decodeEventLog(e, t, r) {
    if (typeof e == "string" && (e = this.getEvent(e)), r != null && !e.anonymous) {
      let g = this.getEventTopic(e);
      (!Pe(r[0], 32) || r[0].toLowerCase() !== g) && vt.throwError("fragment/topic mismatch", O.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: g, value: r[0] }), r = r.slice(1);
    }
    let i = [], s = [], a = [];
    e.inputs.forEach((g, T) => {
      g.indexed ? g.type === "string" || g.type === "bytes" || g.baseType === "tuple" || g.baseType === "array" ? (i.push(Wt.fromObject({ type: "bytes32", name: g.name })), a.push(!0)) : (i.push(g), a.push(!1)) : (s.push(g), a.push(!1));
    });
    let o = r != null ? this._abiCoder.decode(i, zn(r)) : null, c = this._abiCoder.decode(s, t, !0), l = [], f = 0, p = 0;
    e.inputs.forEach((g, T) => {
      if (g.indexed)
        if (o == null)
          l[T] = new Ih({ _isIndexed: !0, hash: null });
        else if (a[T])
          l[T] = new Ih({ _isIndexed: !0, hash: o[p++] });
        else
          try {
            l[T] = o[p++];
          } catch (v) {
            l[T] = v;
          }
      else
        try {
          l[T] = c[f++];
        } catch (v) {
          l[T] = v;
        }
      if (g.name && l[g.name] == null) {
        const v = l[T];
        v instanceof Error ? Object.defineProperty(l, g.name, {
          enumerable: !0,
          get: () => {
            throw Xg(`property ${JSON.stringify(g.name)}`, v);
          }
        }) : l[g.name] = v;
      }
    });
    for (let g = 0; g < l.length; g++) {
      const T = l[g];
      T instanceof Error && Object.defineProperty(l, g, {
        enumerable: !0,
        get: () => {
          throw Xg(`index ${g}`, T);
        }
      });
    }
    return Object.freeze(l);
  }
  parseTransaction(e) {
    let t = this.getFunction(e.data.substring(0, 10).toLowerCase());
    return t ? new JE({
      args: this._abiCoder.decode(t.inputs, "0x" + e.data.substring(10)),
      functionFragment: t,
      name: t.name,
      signature: t.format(),
      sighash: this.getSighash(t),
      value: G.from(e.value || "0")
    }) : null;
  }
  parseLog(e) {
    let t = this.getEvent(e.topics[0]);
    return !t || t.anonymous ? null : new QE({
      eventFragment: t,
      name: t.name,
      signature: t.format(),
      topic: this.getEventTopic(t),
      args: this.decodeEventLog(t, e.data, e.topics)
    });
  }
  parseError(e) {
    const t = te(e);
    let r = this.getError(t.substring(0, 10).toLowerCase());
    return r ? new YE({
      args: this._abiCoder.decode(r.inputs, "0x" + t.substring(10)),
      errorFragment: r,
      name: r.name,
      signature: r.format(),
      sighash: this.getSighash(r)
    }) : null;
  }
  static isInterface(e) {
    return !!(e && e._isInterface);
  }
}
const ZE = "abstract-provider/5.7.0";
var eS = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const tS = new O(ZE);
class nS extends nl {
  static isForkEvent(e) {
    return !!(e && e._isForkEvent);
  }
}
class Td {
  constructor() {
    tS.checkAbstract(new.target, Td), H(this, "_isProvider", !0);
  }
  getFeeData() {
    return eS(this, void 0, void 0, function* () {
      const { block: e, gasPrice: t } = yield It({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((a) => null)
      });
      let r = null, i = null, s = null;
      return e && e.baseFeePerGas && (r = e.baseFeePerGas, s = G.from("1500000000"), i = e.baseFeePerGas.mul(2).add(s)), { lastBaseFeePerGas: r, maxFeePerGas: i, maxPriorityFeePerGas: s, gasPrice: t };
    });
  }
  addListener(e, t) {
    return this.on(e, t);
  }
  removeListener(e, t) {
    return this.off(e, t);
  }
  static isProvider(e) {
    return !!(e && e._isProvider);
  }
}
const rS = "abstract-signer/5.7.0";
var yr = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const nr = new O(rS), iS = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
], sS = [
  O.errors.INSUFFICIENT_FUNDS,
  O.errors.NONCE_EXPIRED,
  O.errors.REPLACEMENT_UNDERPRICED
];
class os {
  constructor() {
    nr.checkAbstract(new.target, os), H(this, "_isSigner", !0);
  }
  getBalance(e) {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e);
    });
  }
  getTransactionCount(e) {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e);
    });
  }
  estimateGas(e) {
    return yr(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const t = yield It(this.checkTransaction(e));
      return yield this.provider.estimateGas(t);
    });
  }
  call(e, t) {
    return yr(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const r = yield It(this.checkTransaction(e));
      return yield this.provider.call(r, t);
    });
  }
  sendTransaction(e) {
    return yr(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const t = yield this.populateTransaction(e), r = yield this.signTransaction(t);
      return yield this.provider.sendTransaction(r);
    });
  }
  getChainId() {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId;
    });
  }
  getGasPrice() {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
    });
  }
  resolveName(e) {
    return yr(this, void 0, void 0, function* () {
      return this._checkProvider("resolveName"), yield this.provider.resolveName(e);
    });
  }
  checkTransaction(e) {
    for (const r in e)
      iS.indexOf(r) === -1 && nr.throwArgumentError("invalid transaction key: " + r, "transaction", e);
    const t = $t(e);
    return t.from == null ? t.from = this.getAddress() : t.from = Promise.all([
      Promise.resolve(t.from),
      this.getAddress()
    ]).then((r) => (r[0].toLowerCase() !== r[1].toLowerCase() && nr.throwArgumentError("from address mismatch", "transaction", e), r[0])), t;
  }
  populateTransaction(e) {
    return yr(this, void 0, void 0, function* () {
      const t = yield It(this.checkTransaction(e));
      t.to != null && (t.to = Promise.resolve(t.to).then((i) => yr(this, void 0, void 0, function* () {
        if (i == null)
          return null;
        const s = yield this.resolveName(i);
        return s == null && nr.throwArgumentError("provided ENS name resolves to null", "tx.to", i), s;
      })), t.to.catch((i) => {
      }));
      const r = t.maxFeePerGas != null || t.maxPriorityFeePerGas != null;
      if (t.gasPrice != null && (t.type === 2 || r) ? nr.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e) : (t.type === 0 || t.type === 1) && r && nr.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e), (t.type === 2 || t.type == null) && t.maxFeePerGas != null && t.maxPriorityFeePerGas != null)
        t.type = 2;
      else if (t.type === 0 || t.type === 1)
        t.gasPrice == null && (t.gasPrice = this.getGasPrice());
      else {
        const i = yield this.getFeeData();
        if (t.type == null)
          if (i.maxFeePerGas != null && i.maxPriorityFeePerGas != null)
            if (t.type = 2, t.gasPrice != null) {
              const s = t.gasPrice;
              delete t.gasPrice, t.maxFeePerGas = s, t.maxPriorityFeePerGas = s;
            } else
              t.maxFeePerGas == null && (t.maxFeePerGas = i.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = i.maxPriorityFeePerGas);
          else
            i.gasPrice != null ? (r && nr.throwError("network does not support EIP-1559", O.errors.UNSUPPORTED_OPERATION, {
              operation: "populateTransaction"
            }), t.gasPrice == null && (t.gasPrice = i.gasPrice), t.type = 0) : nr.throwError("failed to get consistent fee data", O.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
        else
          t.type === 2 && (t.maxFeePerGas == null && (t.maxFeePerGas = i.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = i.maxPriorityFeePerGas));
      }
      return t.nonce == null && (t.nonce = this.getTransactionCount("pending")), t.gasLimit == null && (t.gasLimit = this.estimateGas(t).catch((i) => {
        if (sS.indexOf(i.code) >= 0)
          throw i;
        return nr.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", O.errors.UNPREDICTABLE_GAS_LIMIT, {
          error: i,
          tx: t
        });
      })), t.chainId == null ? t.chainId = this.getChainId() : t.chainId = Promise.all([
        Promise.resolve(t.chainId),
        this.getChainId()
      ]).then((i) => (i[1] !== 0 && i[0] !== i[1] && nr.throwArgumentError("chainId address mismatch", "transaction", e), i[0])), yield It(t);
    });
  }
  _checkProvider(e) {
    this.provider || nr.throwError("missing provider", O.errors.UNSUPPORTED_OPERATION, {
      operation: e || "_checkProvider"
    });
  }
  static isSigner(e) {
    return !!(e && e._isSigner);
  }
}
class dp extends os {
  constructor(e, t) {
    super(), H(this, "address", e), H(this, "provider", t || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(e, t) {
    return Promise.resolve().then(() => {
      nr.throwError(e, O.errors.UNSUPPORTED_OPERATION, { operation: t });
    });
  }
  signMessage(e) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(e) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(e, t, r) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(e) {
    return new dp(this.address, e);
  }
}
var k2 = {}, ve = {}, al = I2;
function I2(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
I2.equal = function(e, t, r) {
  if (e != t)
    throw new Error(r || "Assertion failed: " + e + " != " + t);
};
var Oh = { exports: {} };
typeof Object.create == "function" ? Oh.exports = function(e, t) {
  t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Oh.exports = function(e, t) {
  if (t) {
    e.super_ = t;
    var r = function() {
    };
    r.prototype = t.prototype, e.prototype = new r(), e.prototype.constructor = e;
  }
};
var aS = al, oS = Oh.exports;
ve.inherits = oS;
function cS(n, e) {
  return (n.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= n.length ? !1 : (n.charCodeAt(e + 1) & 64512) === 56320;
}
function lS(n, e) {
  if (Array.isArray(n))
    return n.slice();
  if (!n)
    return [];
  var t = [];
  if (typeof n == "string")
    if (e) {
      if (e === "hex")
        for (n = n.replace(/[^a-z0-9]+/ig, ""), n.length % 2 !== 0 && (n = "0" + n), i = 0; i < n.length; i += 2)
          t.push(parseInt(n[i] + n[i + 1], 16));
    } else
      for (var r = 0, i = 0; i < n.length; i++) {
        var s = n.charCodeAt(i);
        s < 128 ? t[r++] = s : s < 2048 ? (t[r++] = s >> 6 | 192, t[r++] = s & 63 | 128) : cS(n, i) ? (s = 65536 + ((s & 1023) << 10) + (n.charCodeAt(++i) & 1023), t[r++] = s >> 18 | 240, t[r++] = s >> 12 & 63 | 128, t[r++] = s >> 6 & 63 | 128, t[r++] = s & 63 | 128) : (t[r++] = s >> 12 | 224, t[r++] = s >> 6 & 63 | 128, t[r++] = s & 63 | 128);
      }
  else
    for (i = 0; i < n.length; i++)
      t[i] = n[i] | 0;
  return t;
}
ve.toArray = lS;
function uS(n) {
  for (var e = "", t = 0; t < n.length; t++)
    e += D2(n[t].toString(16));
  return e;
}
ve.toHex = uS;
function O2(n) {
  var e = n >>> 24 | n >>> 8 & 65280 | n << 8 & 16711680 | (n & 255) << 24;
  return e >>> 0;
}
ve.htonl = O2;
function dS(n, e) {
  for (var t = "", r = 0; r < n.length; r++) {
    var i = n[r];
    e === "little" && (i = O2(i)), t += N2(i.toString(16));
  }
  return t;
}
ve.toHex32 = dS;
function D2(n) {
  return n.length === 1 ? "0" + n : n;
}
ve.zero2 = D2;
function N2(n) {
  return n.length === 7 ? "0" + n : n.length === 6 ? "00" + n : n.length === 5 ? "000" + n : n.length === 4 ? "0000" + n : n.length === 3 ? "00000" + n : n.length === 2 ? "000000" + n : n.length === 1 ? "0000000" + n : n;
}
ve.zero8 = N2;
function fS(n, e, t, r) {
  var i = t - e;
  aS(i % 4 === 0);
  for (var s = new Array(i / 4), a = 0, o = e; a < s.length; a++, o += 4) {
    var c;
    r === "big" ? c = n[o] << 24 | n[o + 1] << 16 | n[o + 2] << 8 | n[o + 3] : c = n[o + 3] << 24 | n[o + 2] << 16 | n[o + 1] << 8 | n[o], s[a] = c >>> 0;
  }
  return s;
}
ve.join32 = fS;
function hS(n, e) {
  for (var t = new Array(n.length * 4), r = 0, i = 0; r < n.length; r++, i += 4) {
    var s = n[r];
    e === "big" ? (t[i] = s >>> 24, t[i + 1] = s >>> 16 & 255, t[i + 2] = s >>> 8 & 255, t[i + 3] = s & 255) : (t[i + 3] = s >>> 24, t[i + 2] = s >>> 16 & 255, t[i + 1] = s >>> 8 & 255, t[i] = s & 255);
  }
  return t;
}
ve.split32 = hS;
function pS(n, e) {
  return n >>> e | n << 32 - e;
}
ve.rotr32 = pS;
function mS(n, e) {
  return n << e | n >>> 32 - e;
}
ve.rotl32 = mS;
function yS(n, e) {
  return n + e >>> 0;
}
ve.sum32 = yS;
function gS(n, e, t) {
  return n + e + t >>> 0;
}
ve.sum32_3 = gS;
function bS(n, e, t, r) {
  return n + e + t + r >>> 0;
}
ve.sum32_4 = bS;
function xS(n, e, t, r, i) {
  return n + e + t + r + i >>> 0;
}
ve.sum32_5 = xS;
function vS(n, e, t, r) {
  var i = n[e], s = n[e + 1], a = r + s >>> 0, o = (a < r ? 1 : 0) + t + i;
  n[e] = o >>> 0, n[e + 1] = a;
}
ve.sum64 = vS;
function wS(n, e, t, r) {
  var i = e + r >>> 0, s = (i < e ? 1 : 0) + n + t;
  return s >>> 0;
}
ve.sum64_hi = wS;
function AS(n, e, t, r) {
  var i = e + r;
  return i >>> 0;
}
ve.sum64_lo = AS;
function TS(n, e, t, r, i, s, a, o) {
  var c = 0, l = e;
  l = l + r >>> 0, c += l < e ? 1 : 0, l = l + s >>> 0, c += l < s ? 1 : 0, l = l + o >>> 0, c += l < o ? 1 : 0;
  var f = n + t + i + a + c;
  return f >>> 0;
}
ve.sum64_4_hi = TS;
function CS(n, e, t, r, i, s, a, o) {
  var c = e + r + s + o;
  return c >>> 0;
}
ve.sum64_4_lo = CS;
function ES(n, e, t, r, i, s, a, o, c, l) {
  var f = 0, p = e;
  p = p + r >>> 0, f += p < e ? 1 : 0, p = p + s >>> 0, f += p < s ? 1 : 0, p = p + o >>> 0, f += p < o ? 1 : 0, p = p + l >>> 0, f += p < l ? 1 : 0;
  var g = n + t + i + a + c + f;
  return g >>> 0;
}
ve.sum64_5_hi = ES;
function SS(n, e, t, r, i, s, a, o, c, l) {
  var f = e + r + s + o + l;
  return f >>> 0;
}
ve.sum64_5_lo = SS;
function _S(n, e, t) {
  var r = e << 32 - t | n >>> t;
  return r >>> 0;
}
ve.rotr64_hi = _S;
function PS(n, e, t) {
  var r = n << 32 - t | e >>> t;
  return r >>> 0;
}
ve.rotr64_lo = PS;
function MS(n, e, t) {
  return n >>> t;
}
ve.shr64_hi = MS;
function RS(n, e, t) {
  var r = n << 32 - t | e >>> t;
  return r >>> 0;
}
ve.shr64_lo = RS;
var wo = {}, eb = ve, kS = al;
function Cd() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
wo.BlockHash = Cd;
Cd.prototype.update = function(e, t) {
  if (e = eb.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var r = e.length % this._delta8;
    this.pending = e.slice(e.length - r, e.length), this.pending.length === 0 && (this.pending = null), e = eb.join32(e, 0, e.length - r, this.endian);
    for (var i = 0; i < e.length; i += this._delta32)
      this._update(e, i, i + this._delta32);
  }
  return this;
};
Cd.prototype.digest = function(e) {
  return this.update(this._pad()), kS(this.pending === null), this._digest(e);
};
Cd.prototype._pad = function() {
  var e = this.pendingTotal, t = this._delta8, r = t - (e + this.padLength) % t, i = new Array(r + this.padLength);
  i[0] = 128;
  for (var s = 1; s < r; s++)
    i[s] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var a = 8; a < this.padLength; a++)
      i[s++] = 0;
    i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = e >>> 24 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 8 & 255, i[s++] = e & 255;
  } else
    for (i[s++] = e & 255, i[s++] = e >>> 8 & 255, i[s++] = e >>> 16 & 255, i[s++] = e >>> 24 & 255, i[s++] = 0, i[s++] = 0, i[s++] = 0, i[s++] = 0, a = 8; a < this.padLength; a++)
      i[s++] = 0;
  return i;
};
var Ao = {}, ei = {}, IS = ve, Wr = IS.rotr32;
function OS(n, e, t, r) {
  if (n === 0)
    return B2(e, t, r);
  if (n === 1 || n === 3)
    return L2(e, t, r);
  if (n === 2)
    return $2(e, t, r);
}
ei.ft_1 = OS;
function B2(n, e, t) {
  return n & e ^ ~n & t;
}
ei.ch32 = B2;
function $2(n, e, t) {
  return n & e ^ n & t ^ e & t;
}
ei.maj32 = $2;
function L2(n, e, t) {
  return n ^ e ^ t;
}
ei.p32 = L2;
function DS(n) {
  return Wr(n, 2) ^ Wr(n, 13) ^ Wr(n, 22);
}
ei.s0_256 = DS;
function NS(n) {
  return Wr(n, 6) ^ Wr(n, 11) ^ Wr(n, 25);
}
ei.s1_256 = NS;
function BS(n) {
  return Wr(n, 7) ^ Wr(n, 18) ^ n >>> 3;
}
ei.g0_256 = BS;
function $S(n) {
  return Wr(n, 17) ^ Wr(n, 19) ^ n >>> 10;
}
ei.g1_256 = $S;
var Za = ve, LS = wo, FS = ei, Of = Za.rotl32, Do = Za.sum32, US = Za.sum32_5, VS = FS.ft_1, F2 = LS.BlockHash, jS = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function qr() {
  if (!(this instanceof qr))
    return new qr();
  F2.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
Za.inherits(qr, F2);
var GS = qr;
qr.blockSize = 512;
qr.outSize = 160;
qr.hmacStrength = 80;
qr.padLength = 64;
qr.prototype._update = function(e, t) {
  for (var r = this.W, i = 0; i < 16; i++)
    r[i] = e[t + i];
  for (; i < r.length; i++)
    r[i] = Of(r[i - 3] ^ r[i - 8] ^ r[i - 14] ^ r[i - 16], 1);
  var s = this.h[0], a = this.h[1], o = this.h[2], c = this.h[3], l = this.h[4];
  for (i = 0; i < r.length; i++) {
    var f = ~~(i / 20), p = US(Of(s, 5), VS(f, a, o, c), l, r[i], jS[f]);
    l = c, c = o, o = Of(a, 30), a = s, s = p;
  }
  this.h[0] = Do(this.h[0], s), this.h[1] = Do(this.h[1], a), this.h[2] = Do(this.h[2], o), this.h[3] = Do(this.h[3], c), this.h[4] = Do(this.h[4], l);
};
qr.prototype._digest = function(e) {
  return e === "hex" ? Za.toHex32(this.h, "big") : Za.split32(this.h, "big");
};
var eo = ve, WS = wo, To = ei, HS = al, gr = eo.sum32, zS = eo.sum32_4, KS = eo.sum32_5, qS = To.ch32, QS = To.maj32, JS = To.s0_256, YS = To.s1_256, XS = To.g0_256, ZS = To.g1_256, U2 = WS.BlockHash, e7 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function Qr() {
  if (!(this instanceof Qr))
    return new Qr();
  U2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = e7, this.W = new Array(64);
}
eo.inherits(Qr, U2);
var V2 = Qr;
Qr.blockSize = 512;
Qr.outSize = 256;
Qr.hmacStrength = 192;
Qr.padLength = 64;
Qr.prototype._update = function(e, t) {
  for (var r = this.W, i = 0; i < 16; i++)
    r[i] = e[t + i];
  for (; i < r.length; i++)
    r[i] = zS(ZS(r[i - 2]), r[i - 7], XS(r[i - 15]), r[i - 16]);
  var s = this.h[0], a = this.h[1], o = this.h[2], c = this.h[3], l = this.h[4], f = this.h[5], p = this.h[6], g = this.h[7];
  for (HS(this.k.length === r.length), i = 0; i < r.length; i++) {
    var T = KS(g, YS(l), qS(l, f, p), this.k[i], r[i]), v = gr(JS(s), QS(s, a, o));
    g = p, p = f, f = l, l = gr(c, T), c = o, o = a, a = s, s = gr(T, v);
  }
  this.h[0] = gr(this.h[0], s), this.h[1] = gr(this.h[1], a), this.h[2] = gr(this.h[2], o), this.h[3] = gr(this.h[3], c), this.h[4] = gr(this.h[4], l), this.h[5] = gr(this.h[5], f), this.h[6] = gr(this.h[6], p), this.h[7] = gr(this.h[7], g);
};
Qr.prototype._digest = function(e) {
  return e === "hex" ? eo.toHex32(this.h, "big") : eo.split32(this.h, "big");
};
var Dh = ve, j2 = V2;
function Ei() {
  if (!(this instanceof Ei))
    return new Ei();
  j2.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
Dh.inherits(Ei, j2);
var t7 = Ei;
Ei.blockSize = 512;
Ei.outSize = 224;
Ei.hmacStrength = 192;
Ei.padLength = 64;
Ei.prototype._digest = function(e) {
  return e === "hex" ? Dh.toHex32(this.h.slice(0, 7), "big") : Dh.split32(this.h.slice(0, 7), "big");
};
var Dn = ve, n7 = wo, r7 = al, Hr = Dn.rotr64_hi, zr = Dn.rotr64_lo, G2 = Dn.shr64_hi, W2 = Dn.shr64_lo, Ki = Dn.sum64, Df = Dn.sum64_hi, Nf = Dn.sum64_lo, i7 = Dn.sum64_4_hi, s7 = Dn.sum64_4_lo, a7 = Dn.sum64_5_hi, o7 = Dn.sum64_5_lo, H2 = n7.BlockHash, c7 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function Mr() {
  if (!(this instanceof Mr))
    return new Mr();
  H2.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = c7, this.W = new Array(160);
}
Dn.inherits(Mr, H2);
var z2 = Mr;
Mr.blockSize = 1024;
Mr.outSize = 512;
Mr.hmacStrength = 192;
Mr.padLength = 128;
Mr.prototype._prepareBlock = function(e, t) {
  for (var r = this.W, i = 0; i < 32; i++)
    r[i] = e[t + i];
  for (; i < r.length; i += 2) {
    var s = x7(r[i - 4], r[i - 3]), a = v7(r[i - 4], r[i - 3]), o = r[i - 14], c = r[i - 13], l = g7(r[i - 30], r[i - 29]), f = b7(r[i - 30], r[i - 29]), p = r[i - 32], g = r[i - 31];
    r[i] = i7(
      s,
      a,
      o,
      c,
      l,
      f,
      p,
      g
    ), r[i + 1] = s7(
      s,
      a,
      o,
      c,
      l,
      f,
      p,
      g
    );
  }
};
Mr.prototype._update = function(e, t) {
  this._prepareBlock(e, t);
  var r = this.W, i = this.h[0], s = this.h[1], a = this.h[2], o = this.h[3], c = this.h[4], l = this.h[5], f = this.h[6], p = this.h[7], g = this.h[8], T = this.h[9], v = this.h[10], w = this.h[11], C = this.h[12], _ = this.h[13], I = this.h[14], B = this.h[15];
  r7(this.k.length === r.length);
  for (var N = 0; N < r.length; N += 2) {
    var D = I, U = B, W = m7(g, T), j = y7(g, T), q = l7(g, T, v, w, C), ce = u7(g, T, v, w, C, _), re = this.k[N], me = this.k[N + 1], S = r[N], d = r[N + 1], m = a7(
      D,
      U,
      W,
      j,
      q,
      ce,
      re,
      me,
      S,
      d
    ), x = o7(
      D,
      U,
      W,
      j,
      q,
      ce,
      re,
      me,
      S,
      d
    );
    D = h7(i, s), U = p7(i, s), W = d7(i, s, a, o, c), j = f7(i, s, a, o, c, l);
    var E = Df(D, U, W, j), A = Nf(D, U, W, j);
    I = C, B = _, C = v, _ = w, v = g, w = T, g = Df(f, p, m, x), T = Nf(p, p, m, x), f = c, p = l, c = a, l = o, a = i, o = s, i = Df(m, x, E, A), s = Nf(m, x, E, A);
  }
  Ki(this.h, 0, i, s), Ki(this.h, 2, a, o), Ki(this.h, 4, c, l), Ki(this.h, 6, f, p), Ki(this.h, 8, g, T), Ki(this.h, 10, v, w), Ki(this.h, 12, C, _), Ki(this.h, 14, I, B);
};
Mr.prototype._digest = function(e) {
  return e === "hex" ? Dn.toHex32(this.h, "big") : Dn.split32(this.h, "big");
};
function l7(n, e, t, r, i) {
  var s = n & t ^ ~n & i;
  return s < 0 && (s += 4294967296), s;
}
function u7(n, e, t, r, i, s) {
  var a = e & r ^ ~e & s;
  return a < 0 && (a += 4294967296), a;
}
function d7(n, e, t, r, i) {
  var s = n & t ^ n & i ^ t & i;
  return s < 0 && (s += 4294967296), s;
}
function f7(n, e, t, r, i, s) {
  var a = e & r ^ e & s ^ r & s;
  return a < 0 && (a += 4294967296), a;
}
function h7(n, e) {
  var t = Hr(n, e, 28), r = Hr(e, n, 2), i = Hr(e, n, 7), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function p7(n, e) {
  var t = zr(n, e, 28), r = zr(e, n, 2), i = zr(e, n, 7), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function m7(n, e) {
  var t = Hr(n, e, 14), r = Hr(n, e, 18), i = Hr(e, n, 9), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function y7(n, e) {
  var t = zr(n, e, 14), r = zr(n, e, 18), i = zr(e, n, 9), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function g7(n, e) {
  var t = Hr(n, e, 1), r = Hr(n, e, 8), i = G2(n, e, 7), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function b7(n, e) {
  var t = zr(n, e, 1), r = zr(n, e, 8), i = W2(n, e, 7), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function x7(n, e) {
  var t = Hr(n, e, 19), r = Hr(e, n, 29), i = G2(n, e, 6), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
function v7(n, e) {
  var t = zr(n, e, 19), r = zr(e, n, 29), i = W2(n, e, 6), s = t ^ r ^ i;
  return s < 0 && (s += 4294967296), s;
}
var Nh = ve, K2 = z2;
function Si() {
  if (!(this instanceof Si))
    return new Si();
  K2.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
Nh.inherits(Si, K2);
var w7 = Si;
Si.blockSize = 1024;
Si.outSize = 384;
Si.hmacStrength = 192;
Si.padLength = 128;
Si.prototype._digest = function(e) {
  return e === "hex" ? Nh.toHex32(this.h.slice(0, 12), "big") : Nh.split32(this.h.slice(0, 12), "big");
};
Ao.sha1 = GS;
Ao.sha224 = t7;
Ao.sha256 = V2;
Ao.sha384 = w7;
Ao.sha512 = z2;
var q2 = {}, ra = ve, A7 = wo, Pl = ra.rotl32, tb = ra.sum32, No = ra.sum32_3, nb = ra.sum32_4, Q2 = A7.BlockHash;
function Jr() {
  if (!(this instanceof Jr))
    return new Jr();
  Q2.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
ra.inherits(Jr, Q2);
q2.ripemd160 = Jr;
Jr.blockSize = 512;
Jr.outSize = 160;
Jr.hmacStrength = 192;
Jr.padLength = 64;
Jr.prototype._update = function(e, t) {
  for (var r = this.h[0], i = this.h[1], s = this.h[2], a = this.h[3], o = this.h[4], c = r, l = i, f = s, p = a, g = o, T = 0; T < 80; T++) {
    var v = tb(
      Pl(
        nb(r, rb(T, i, s, a), e[E7[T] + t], T7(T)),
        _7[T]
      ),
      o
    );
    r = o, o = a, a = Pl(s, 10), s = i, i = v, v = tb(
      Pl(
        nb(c, rb(79 - T, l, f, p), e[S7[T] + t], C7(T)),
        P7[T]
      ),
      g
    ), c = g, g = p, p = Pl(f, 10), f = l, l = v;
  }
  v = No(this.h[1], s, p), this.h[1] = No(this.h[2], a, g), this.h[2] = No(this.h[3], o, c), this.h[3] = No(this.h[4], r, l), this.h[4] = No(this.h[0], i, f), this.h[0] = v;
};
Jr.prototype._digest = function(e) {
  return e === "hex" ? ra.toHex32(this.h, "little") : ra.split32(this.h, "little");
};
function rb(n, e, t, r) {
  return n <= 15 ? e ^ t ^ r : n <= 31 ? e & t | ~e & r : n <= 47 ? (e | ~t) ^ r : n <= 63 ? e & r | t & ~r : e ^ (t | ~r);
}
function T7(n) {
  return n <= 15 ? 0 : n <= 31 ? 1518500249 : n <= 47 ? 1859775393 : n <= 63 ? 2400959708 : 2840853838;
}
function C7(n) {
  return n <= 15 ? 1352829926 : n <= 31 ? 1548603684 : n <= 47 ? 1836072691 : n <= 63 ? 2053994217 : 0;
}
var E7 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], S7 = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], _7 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], P7 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], M7 = ve, R7 = al;
function to(n, e, t) {
  if (!(this instanceof to))
    return new to(n, e, t);
  this.Hash = n, this.blockSize = n.blockSize / 8, this.outSize = n.outSize / 8, this.inner = null, this.outer = null, this._init(M7.toArray(e, t));
}
var k7 = to;
to.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), R7(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++)
    e.push(0);
  for (t = 0; t < e.length; t++)
    e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++)
    e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
to.prototype.update = function(e, t) {
  return this.inner.update(e, t), this;
};
to.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(n) {
  var e = n;
  e.utils = ve, e.common = wo, e.sha = Ao, e.ripemd = q2, e.hmac = k7, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(k2);
const Dr = k2;
function Co(n, e, t) {
  return t = {
    path: e,
    exports: {},
    require: function(r, i) {
      return I7(r, i ?? t.path);
    }
  }, n(t, t.exports), t.exports;
}
function I7() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var fp = J2;
function J2(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
J2.equal = function(e, t, r) {
  if (e != t)
    throw new Error(r || "Assertion failed: " + e + " != " + t);
};
var Cr = Co(function(n, e) {
  var t = e;
  function r(a, o) {
    if (Array.isArray(a))
      return a.slice();
    if (!a)
      return [];
    var c = [];
    if (typeof a != "string") {
      for (var l = 0; l < a.length; l++)
        c[l] = a[l] | 0;
      return c;
    }
    if (o === "hex") {
      a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a);
      for (var l = 0; l < a.length; l += 2)
        c.push(parseInt(a[l] + a[l + 1], 16));
    } else
      for (var l = 0; l < a.length; l++) {
        var f = a.charCodeAt(l), p = f >> 8, g = f & 255;
        p ? c.push(p, g) : c.push(g);
      }
    return c;
  }
  t.toArray = r;
  function i(a) {
    return a.length === 1 ? "0" + a : a;
  }
  t.zero2 = i;
  function s(a) {
    for (var o = "", c = 0; c < a.length; c++)
      o += i(a[c].toString(16));
    return o;
  }
  t.toHex = s, t.encode = function(o, c) {
    return c === "hex" ? s(o) : o;
  };
}), Yn = Co(function(n, e) {
  var t = e;
  t.assert = fp, t.toArray = Cr.toArray, t.zero2 = Cr.zero2, t.toHex = Cr.toHex, t.encode = Cr.encode;
  function r(c, l, f) {
    var p = new Array(Math.max(c.bitLength(), f) + 1);
    p.fill(0);
    for (var g = 1 << l + 1, T = c.clone(), v = 0; v < p.length; v++) {
      var w, C = T.andln(g - 1);
      T.isOdd() ? (C > (g >> 1) - 1 ? w = (g >> 1) - C : w = C, T.isubn(w)) : w = 0, p[v] = w, T.iushrn(1);
    }
    return p;
  }
  t.getNAF = r;
  function i(c, l) {
    var f = [
      [],
      []
    ];
    c = c.clone(), l = l.clone();
    for (var p = 0, g = 0, T; c.cmpn(-p) > 0 || l.cmpn(-g) > 0; ) {
      var v = c.andln(3) + p & 3, w = l.andln(3) + g & 3;
      v === 3 && (v = -1), w === 3 && (w = -1);
      var C;
      (v & 1) === 0 ? C = 0 : (T = c.andln(7) + p & 7, (T === 3 || T === 5) && w === 2 ? C = -v : C = v), f[0].push(C);
      var _;
      (w & 1) === 0 ? _ = 0 : (T = l.andln(7) + g & 7, (T === 3 || T === 5) && v === 2 ? _ = -w : _ = w), f[1].push(_), 2 * p === C + 1 && (p = 1 - p), 2 * g === _ + 1 && (g = 1 - g), c.iushrn(1), l.iushrn(1);
    }
    return f;
  }
  t.getJSF = i;
  function s(c, l, f) {
    var p = "_" + l;
    c.prototype[l] = function() {
      return this[p] !== void 0 ? this[p] : this[p] = f.call(this);
    };
  }
  t.cachedProperty = s;
  function a(c) {
    return typeof c == "string" ? t.toArray(c, "hex") : c;
  }
  t.parseBytes = a;
  function o(c) {
    return new de(c, "hex", "le");
  }
  t.intFromLE = o;
}), Ru = Yn.getNAF, O7 = Yn.getJSF, ku = Yn.assert;
function xs(n, e) {
  this.type = n, this.p = new de(e.p, 16), this.red = e.prime ? de.red(e.prime) : de.mont(this.p), this.zero = new de(0).toRed(this.red), this.one = new de(1).toRed(this.red), this.two = new de(2).toRed(this.red), this.n = e.n && new de(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var t = this.n && this.p.div(this.n);
  !t || t.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var wa = xs;
xs.prototype.point = function() {
  throw new Error("Not implemented");
};
xs.prototype.validate = function() {
  throw new Error("Not implemented");
};
xs.prototype._fixedNafMul = function(e, t) {
  ku(e.precomputed);
  var r = e._getDoubles(), i = Ru(t, 1, this._bitLength), s = (1 << r.step + 1) - (r.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var a = [], o, c;
  for (o = 0; o < i.length; o += r.step) {
    c = 0;
    for (var l = o + r.step - 1; l >= o; l--)
      c = (c << 1) + i[l];
    a.push(c);
  }
  for (var f = this.jpoint(null, null, null), p = this.jpoint(null, null, null), g = s; g > 0; g--) {
    for (o = 0; o < a.length; o++)
      c = a[o], c === g ? p = p.mixedAdd(r.points[o]) : c === -g && (p = p.mixedAdd(r.points[o].neg()));
    f = f.add(p);
  }
  return f.toP();
};
xs.prototype._wnafMul = function(e, t) {
  var r = 4, i = e._getNAFPoints(r);
  r = i.wnd;
  for (var s = i.points, a = Ru(t, r, this._bitLength), o = this.jpoint(null, null, null), c = a.length - 1; c >= 0; c--) {
    for (var l = 0; c >= 0 && a[c] === 0; c--)
      l++;
    if (c >= 0 && l++, o = o.dblp(l), c < 0)
      break;
    var f = a[c];
    ku(f !== 0), e.type === "affine" ? f > 0 ? o = o.mixedAdd(s[f - 1 >> 1]) : o = o.mixedAdd(s[-f - 1 >> 1].neg()) : f > 0 ? o = o.add(s[f - 1 >> 1]) : o = o.add(s[-f - 1 >> 1].neg());
  }
  return e.type === "affine" ? o.toP() : o;
};
xs.prototype._wnafMulAdd = function(e, t, r, i, s) {
  var a = this._wnafT1, o = this._wnafT2, c = this._wnafT3, l = 0, f, p, g;
  for (f = 0; f < i; f++) {
    g = t[f];
    var T = g._getNAFPoints(e);
    a[f] = T.wnd, o[f] = T.points;
  }
  for (f = i - 1; f >= 1; f -= 2) {
    var v = f - 1, w = f;
    if (a[v] !== 1 || a[w] !== 1) {
      c[v] = Ru(r[v], a[v], this._bitLength), c[w] = Ru(r[w], a[w], this._bitLength), l = Math.max(c[v].length, l), l = Math.max(c[w].length, l);
      continue;
    }
    var C = [
      t[v],
      null,
      null,
      t[w]
    ];
    t[v].y.cmp(t[w].y) === 0 ? (C[1] = t[v].add(t[w]), C[2] = t[v].toJ().mixedAdd(t[w].neg())) : t[v].y.cmp(t[w].y.redNeg()) === 0 ? (C[1] = t[v].toJ().mixedAdd(t[w]), C[2] = t[v].add(t[w].neg())) : (C[1] = t[v].toJ().mixedAdd(t[w]), C[2] = t[v].toJ().mixedAdd(t[w].neg()));
    var _ = [
      -3,
      -1,
      -5,
      -7,
      0,
      7,
      5,
      1,
      3
    ], I = O7(r[v], r[w]);
    for (l = Math.max(I[0].length, l), c[v] = new Array(l), c[w] = new Array(l), p = 0; p < l; p++) {
      var B = I[0][p] | 0, N = I[1][p] | 0;
      c[v][p] = _[(B + 1) * 3 + (N + 1)], c[w][p] = 0, o[v] = C;
    }
  }
  var D = this.jpoint(null, null, null), U = this._wnafT4;
  for (f = l; f >= 0; f--) {
    for (var W = 0; f >= 0; ) {
      var j = !0;
      for (p = 0; p < i; p++)
        U[p] = c[p][f] | 0, U[p] !== 0 && (j = !1);
      if (!j)
        break;
      W++, f--;
    }
    if (f >= 0 && W++, D = D.dblp(W), f < 0)
      break;
    for (p = 0; p < i; p++) {
      var q = U[p];
      q !== 0 && (q > 0 ? g = o[p][q - 1 >> 1] : q < 0 && (g = o[p][-q - 1 >> 1].neg()), g.type === "affine" ? D = D.mixedAdd(g) : D = D.add(g));
    }
  }
  for (f = 0; f < i; f++)
    o[f] = null;
  return s ? D : D.toP();
};
function fr(n, e) {
  this.curve = n, this.type = e, this.precomputed = null;
}
xs.BasePoint = fr;
fr.prototype.eq = function() {
  throw new Error("Not implemented");
};
fr.prototype.validate = function() {
  return this.curve.validate(this);
};
xs.prototype.decodePoint = function(e, t) {
  e = Yn.toArray(e, t);
  var r = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * r) {
    e[0] === 6 ? ku(e[e.length - 1] % 2 === 0) : e[0] === 7 && ku(e[e.length - 1] % 2 === 1);
    var i = this.point(
      e.slice(1, 1 + r),
      e.slice(1 + r, 1 + 2 * r)
    );
    return i;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === r)
    return this.pointFromX(e.slice(1, 1 + r), e[0] === 3);
  throw new Error("Unknown point format");
};
fr.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
fr.prototype._encode = function(e) {
  var t = this.curve.p.byteLength(), r = this.getX().toArray("be", t);
  return e ? [this.getY().isEven() ? 2 : 3].concat(r) : [4].concat(r, this.getY().toArray("be", t));
};
fr.prototype.encode = function(e, t) {
  return Yn.encode(this._encode(t), e);
};
fr.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var t = {
    doubles: null,
    naf: null,
    beta: null
  };
  return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this;
};
fr.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
fr.prototype._getDoubles = function(e, t) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var r = [this], i = this, s = 0; s < t; s += e) {
    for (var a = 0; a < e; a++)
      i = i.dbl();
    r.push(i);
  }
  return {
    step: e,
    points: r
  };
};
fr.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var t = [this], r = (1 << e) - 1, i = r === 1 ? null : this.dbl(), s = 1; s < r; s++)
    t[s] = t[s - 1].add(i);
  return {
    wnd: e,
    points: t
  };
};
fr.prototype._getBeta = function() {
  return null;
};
fr.prototype.dblp = function(e) {
  for (var t = this, r = 0; r < e; r++)
    t = t.dbl();
  return t;
};
var hp = Co(function(n) {
  typeof Object.create == "function" ? n.exports = function(t, r) {
    r && (t.super_ = r, t.prototype = Object.create(r.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : n.exports = function(t, r) {
    if (r) {
      t.super_ = r;
      var i = function() {
      };
      i.prototype = r.prototype, t.prototype = new i(), t.prototype.constructor = t;
    }
  };
}), D7 = Yn.assert;
function hr(n) {
  wa.call(this, "short", n), this.a = new de(n.a, 16).toRed(this.red), this.b = new de(n.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(n), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
hp(hr, wa);
var N7 = hr;
hr.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, r;
    if (e.beta)
      t = new de(e.beta, 16).toRed(this.red);
    else {
      var i = this._getEndoRoots(this.p);
      t = i[0].cmp(i[1]) < 0 ? i[0] : i[1], t = t.toRed(this.red);
    }
    if (e.lambda)
      r = new de(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(t)) === 0 ? r = s[0] : (r = s[1], D7(this.g.mul(r).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var a;
    return e.basis ? a = e.basis.map(function(o) {
      return {
        a: new de(o.a, 16),
        b: new de(o.b, 16)
      };
    }) : a = this._getEndoBasis(r), {
      beta: t,
      lambda: r,
      basis: a
    };
  }
};
hr.prototype._getEndoRoots = function(e) {
  var t = e === this.p ? this.red : de.mont(e), r = new de(2).toRed(t).redInvm(), i = r.redNeg(), s = new de(3).toRed(t).redNeg().redSqrt().redMul(r), a = i.redAdd(s).fromRed(), o = i.redSub(s).fromRed();
  return [a, o];
};
hr.prototype._getEndoBasis = function(e) {
  for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), r = e, i = this.n.clone(), s = new de(1), a = new de(0), o = new de(0), c = new de(1), l, f, p, g, T, v, w, C = 0, _, I; r.cmpn(0) !== 0; ) {
    var B = i.div(r);
    _ = i.sub(B.mul(r)), I = o.sub(B.mul(s));
    var N = c.sub(B.mul(a));
    if (!p && _.cmp(t) < 0)
      l = w.neg(), f = s, p = _.neg(), g = I;
    else if (p && ++C === 2)
      break;
    w = _, i = r, r = _, o = s, s = I, c = a, a = N;
  }
  T = _.neg(), v = I;
  var D = p.sqr().add(g.sqr()), U = T.sqr().add(v.sqr());
  return U.cmp(D) >= 0 && (T = l, v = f), p.negative && (p = p.neg(), g = g.neg()), T.negative && (T = T.neg(), v = v.neg()), [
    { a: p, b: g },
    { a: T, b: v }
  ];
};
hr.prototype._endoSplit = function(e) {
  var t = this.endo.basis, r = t[0], i = t[1], s = i.b.mul(e).divRound(this.n), a = r.b.neg().mul(e).divRound(this.n), o = s.mul(r.a), c = a.mul(i.a), l = s.mul(r.b), f = a.mul(i.b), p = e.sub(o).sub(c), g = l.add(f).neg();
  return { k1: p, k2: g };
};
hr.prototype.pointFromX = function(e, t) {
  e = new de(e, 16), e.red || (e = e.toRed(this.red));
  var r = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), i = r.redSqrt();
  if (i.redSqr().redSub(r).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = i.fromRed().isOdd();
  return (t && !s || !t && s) && (i = i.redNeg()), this.point(e, i);
};
hr.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var t = e.x, r = e.y, i = this.a.redMul(t), s = t.redSqr().redMul(t).redIAdd(i).redIAdd(this.b);
  return r.redSqr().redISub(s).cmpn(0) === 0;
};
hr.prototype._endoWnafMulAdd = function(e, t, r) {
  for (var i = this._endoWnafT1, s = this._endoWnafT2, a = 0; a < e.length; a++) {
    var o = this._endoSplit(t[a]), c = e[a], l = c._getBeta();
    o.k1.negative && (o.k1.ineg(), c = c.neg(!0)), o.k2.negative && (o.k2.ineg(), l = l.neg(!0)), i[a * 2] = c, i[a * 2 + 1] = l, s[a * 2] = o.k1, s[a * 2 + 1] = o.k2;
  }
  for (var f = this._wnafMulAdd(1, i, s, a * 2, r), p = 0; p < a * 2; p++)
    i[p] = null, s[p] = null;
  return f;
};
function zt(n, e, t, r) {
  wa.BasePoint.call(this, n, "affine"), e === null && t === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new de(e, 16), this.y = new de(t, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
hp(zt, wa.BasePoint);
hr.prototype.point = function(e, t, r) {
  return new zt(this, e, t, r);
};
hr.prototype.pointFromJSON = function(e, t) {
  return zt.fromJSON(this, e, t);
};
zt.prototype._getBeta = function() {
  if (!!this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var r = this.curve, i = function(s) {
        return r.point(s.x.redMul(r.endo.beta), s.y);
      };
      e.beta = t, t.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(i)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(i)
        }
      };
    }
    return t;
  }
};
zt.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
zt.fromJSON = function(e, t, r) {
  typeof t == "string" && (t = JSON.parse(t));
  var i = e.point(t[0], t[1], r);
  if (!t[2])
    return i;
  function s(o) {
    return e.point(o[0], o[1], r);
  }
  var a = t[2];
  return i.precomputed = {
    beta: null,
    doubles: a.doubles && {
      step: a.doubles.step,
      points: [i].concat(a.doubles.points.map(s))
    },
    naf: a.naf && {
      wnd: a.naf.wnd,
      points: [i].concat(a.naf.points.map(s))
    }
  }, i;
};
zt.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
zt.prototype.isInfinity = function() {
  return this.inf;
};
zt.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var r = t.redSqr().redISub(this.x).redISub(e.x), i = t.redMul(this.x.redSub(r)).redISub(this.y);
  return this.curve.point(r, i);
};
zt.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var t = this.curve.a, r = this.x.redSqr(), i = e.redInvm(), s = r.redAdd(r).redIAdd(r).redIAdd(t).redMul(i), a = s.redSqr().redISub(this.x.redAdd(this.x)), o = s.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, o);
};
zt.prototype.getX = function() {
  return this.x.fromRed();
};
zt.prototype.getY = function() {
  return this.y.fromRed();
};
zt.prototype.mul = function(e) {
  return e = new de(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
zt.prototype.mulAdd = function(e, t, r) {
  var i = [this, t], s = [e, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s) : this.curve._wnafMulAdd(1, i, s, 2);
};
zt.prototype.jmulAdd = function(e, t, r) {
  var i = [this, t], s = [e, r];
  return this.curve.endo ? this.curve._endoWnafMulAdd(i, s, !0) : this.curve._wnafMulAdd(1, i, s, 2, !0);
};
zt.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
zt.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var r = this.precomputed, i = function(s) {
      return s.neg();
    };
    t.precomputed = {
      naf: r.naf && {
        wnd: r.naf.wnd,
        points: r.naf.points.map(i)
      },
      doubles: r.doubles && {
        step: r.doubles.step,
        points: r.doubles.points.map(i)
      }
    };
  }
  return t;
};
zt.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function Xt(n, e, t, r) {
  wa.BasePoint.call(this, n, "jacobian"), e === null && t === null && r === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new de(0)) : (this.x = new de(e, 16), this.y = new de(t, 16), this.z = new de(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
hp(Xt, wa.BasePoint);
hr.prototype.jpoint = function(e, t, r) {
  return new Xt(this, e, t, r);
};
Xt.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), t = e.redSqr(), r = this.x.redMul(t), i = this.y.redMul(t).redMul(e);
  return this.curve.point(r, i);
};
Xt.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
Xt.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var t = e.z.redSqr(), r = this.z.redSqr(), i = this.x.redMul(t), s = e.x.redMul(r), a = this.y.redMul(t.redMul(e.z)), o = e.y.redMul(r.redMul(this.z)), c = i.redSub(s), l = a.redSub(o);
  if (c.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var f = c.redSqr(), p = f.redMul(c), g = i.redMul(f), T = l.redSqr().redIAdd(p).redISub(g).redISub(g), v = l.redMul(g.redISub(T)).redISub(a.redMul(p)), w = this.z.redMul(e.z).redMul(c);
  return this.curve.jpoint(T, v, w);
};
Xt.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var t = this.z.redSqr(), r = this.x, i = e.x.redMul(t), s = this.y, a = e.y.redMul(t).redMul(this.z), o = r.redSub(i), c = s.redSub(a);
  if (o.cmpn(0) === 0)
    return c.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = o.redSqr(), f = l.redMul(o), p = r.redMul(l), g = c.redSqr().redIAdd(f).redISub(p).redISub(p), T = c.redMul(p.redISub(g)).redISub(s.redMul(f)), v = this.z.redMul(o);
  return this.curve.jpoint(g, T, v);
};
Xt.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (t = 0; t < e; t++)
      r = r.dbl();
    return r;
  }
  var i = this.curve.a, s = this.curve.tinv, a = this.x, o = this.y, c = this.z, l = c.redSqr().redSqr(), f = o.redAdd(o);
  for (t = 0; t < e; t++) {
    var p = a.redSqr(), g = f.redSqr(), T = g.redSqr(), v = p.redAdd(p).redIAdd(p).redIAdd(i.redMul(l)), w = a.redMul(g), C = v.redSqr().redISub(w.redAdd(w)), _ = w.redISub(C), I = v.redMul(_);
    I = I.redIAdd(I).redISub(T);
    var B = f.redMul(c);
    t + 1 < e && (l = l.redMul(T)), a = C, c = B, f = I;
  }
  return this.curve.jpoint(a, f.redMul(s), c);
};
Xt.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
Xt.prototype._zeroDbl = function() {
  var e, t, r;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), a = s.redSqr(), o = this.x.redAdd(s).redSqr().redISub(i).redISub(a);
    o = o.redIAdd(o);
    var c = i.redAdd(i).redIAdd(i), l = c.redSqr().redISub(o).redISub(o), f = a.redIAdd(a);
    f = f.redIAdd(f), f = f.redIAdd(f), e = l, t = c.redMul(o.redISub(l)).redISub(f), r = this.y.redAdd(this.y);
  } else {
    var p = this.x.redSqr(), g = this.y.redSqr(), T = g.redSqr(), v = this.x.redAdd(g).redSqr().redISub(p).redISub(T);
    v = v.redIAdd(v);
    var w = p.redAdd(p).redIAdd(p), C = w.redSqr(), _ = T.redIAdd(T);
    _ = _.redIAdd(_), _ = _.redIAdd(_), e = C.redISub(v).redISub(v), t = w.redMul(v.redISub(e)).redISub(_), r = this.y.redMul(this.z), r = r.redIAdd(r);
  }
  return this.curve.jpoint(e, t, r);
};
Xt.prototype._threeDbl = function() {
  var e, t, r;
  if (this.zOne) {
    var i = this.x.redSqr(), s = this.y.redSqr(), a = s.redSqr(), o = this.x.redAdd(s).redSqr().redISub(i).redISub(a);
    o = o.redIAdd(o);
    var c = i.redAdd(i).redIAdd(i).redIAdd(this.curve.a), l = c.redSqr().redISub(o).redISub(o);
    e = l;
    var f = a.redIAdd(a);
    f = f.redIAdd(f), f = f.redIAdd(f), t = c.redMul(o.redISub(l)).redISub(f), r = this.y.redAdd(this.y);
  } else {
    var p = this.z.redSqr(), g = this.y.redSqr(), T = this.x.redMul(g), v = this.x.redSub(p).redMul(this.x.redAdd(p));
    v = v.redAdd(v).redIAdd(v);
    var w = T.redIAdd(T);
    w = w.redIAdd(w);
    var C = w.redAdd(w);
    e = v.redSqr().redISub(C), r = this.y.redAdd(this.z).redSqr().redISub(g).redISub(p);
    var _ = g.redSqr();
    _ = _.redIAdd(_), _ = _.redIAdd(_), _ = _.redIAdd(_), t = v.redMul(w.redISub(e)).redISub(_);
  }
  return this.curve.jpoint(e, t, r);
};
Xt.prototype._dbl = function() {
  var e = this.curve.a, t = this.x, r = this.y, i = this.z, s = i.redSqr().redSqr(), a = t.redSqr(), o = r.redSqr(), c = a.redAdd(a).redIAdd(a).redIAdd(e.redMul(s)), l = t.redAdd(t);
  l = l.redIAdd(l);
  var f = l.redMul(o), p = c.redSqr().redISub(f.redAdd(f)), g = f.redISub(p), T = o.redSqr();
  T = T.redIAdd(T), T = T.redIAdd(T), T = T.redIAdd(T);
  var v = c.redMul(g).redISub(T), w = r.redAdd(r).redMul(i);
  return this.curve.jpoint(p, v, w);
};
Xt.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), t = this.y.redSqr(), r = this.z.redSqr(), i = t.redSqr(), s = e.redAdd(e).redIAdd(e), a = s.redSqr(), o = this.x.redAdd(t).redSqr().redISub(e).redISub(i);
  o = o.redIAdd(o), o = o.redAdd(o).redIAdd(o), o = o.redISub(a);
  var c = o.redSqr(), l = i.redIAdd(i);
  l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
  var f = s.redIAdd(o).redSqr().redISub(a).redISub(c).redISub(l), p = t.redMul(f);
  p = p.redIAdd(p), p = p.redIAdd(p);
  var g = this.x.redMul(c).redISub(p);
  g = g.redIAdd(g), g = g.redIAdd(g);
  var T = this.y.redMul(f.redMul(l.redISub(f)).redISub(o.redMul(c)));
  T = T.redIAdd(T), T = T.redIAdd(T), T = T.redIAdd(T);
  var v = this.z.redAdd(o).redSqr().redISub(r).redISub(c);
  return this.curve.jpoint(g, T, v);
};
Xt.prototype.mul = function(e, t) {
  return e = new de(e, t), this.curve._wnafMul(this, e);
};
Xt.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var t = this.z.redSqr(), r = e.z.redSqr();
  if (this.x.redMul(r).redISub(e.x.redMul(t)).cmpn(0) !== 0)
    return !1;
  var i = t.redMul(this.z), s = r.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(i)).cmpn(0) === 0;
};
Xt.prototype.eqXToP = function(e) {
  var t = this.z.redSqr(), r = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(r) === 0)
    return !0;
  for (var i = e.clone(), s = this.curve.redN.redMul(t); ; ) {
    if (i.iadd(this.curve.n), i.cmp(this.curve.p) >= 0)
      return !1;
    if (r.redIAdd(s), this.x.cmp(r) === 0)
      return !0;
  }
};
Xt.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
Xt.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var eu = Co(function(n, e) {
  var t = e;
  t.base = wa, t.short = N7, t.mont = null, t.edwards = null;
}), tu = Co(function(n, e) {
  var t = e, r = Yn.assert;
  function i(o) {
    o.type === "short" ? this.curve = new eu.short(o) : o.type === "edwards" ? this.curve = new eu.edwards(o) : this.curve = new eu.mont(o), this.g = this.curve.g, this.n = this.curve.n, this.hash = o.hash, r(this.g.validate(), "Invalid curve"), r(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = i;
  function s(o, c) {
    Object.defineProperty(t, o, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var l = new i(c);
        return Object.defineProperty(t, o, {
          configurable: !0,
          enumerable: !0,
          value: l
        }), l;
      }
    });
  }
  s("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Dr.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), s("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Dr.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), s("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Dr.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), s("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Dr.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), s("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Dr.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), s("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Dr.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), s("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Dr.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var a;
  try {
    a = null.crash();
  } catch {
    a = void 0;
  }
  s("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Dr.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      a
    ]
  });
});
function hs(n) {
  if (!(this instanceof hs))
    return new hs(n);
  this.hash = n.hash, this.predResist = !!n.predResist, this.outLen = this.hash.outSize, this.minEntropy = n.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = Cr.toArray(n.entropy, n.entropyEnc || "hex"), t = Cr.toArray(n.nonce, n.nonceEnc || "hex"), r = Cr.toArray(n.pers, n.persEnc || "hex");
  fp(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, t, r);
}
var Y2 = hs;
hs.prototype._init = function(e, t, r) {
  var i = e.concat(t).concat(r);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(i), this._reseed = 1, this.reseedInterval = 281474976710656;
};
hs.prototype._hmac = function() {
  return new Dr.hmac(this.hash, this.K);
};
hs.prototype._update = function(e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
hs.prototype.reseed = function(e, t, r, i) {
  typeof t != "string" && (i = r, r = t, t = null), e = Cr.toArray(e, t), r = Cr.toArray(r, i), fp(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(r || [])), this._reseed = 1;
};
hs.prototype.generate = function(e, t, r, i) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof t != "string" && (i = r, r = t, t = null), r && (r = Cr.toArray(r, i || "hex"), this._update(r));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var a = s.slice(0, e);
  return this._update(r), this._reseed++, Cr.encode(a, t);
};
var Bh = Yn.assert;
function hn(n, e) {
  this.ec = n, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var pp = hn;
hn.fromPublic = function(e, t, r) {
  return t instanceof hn ? t : new hn(e, {
    pub: t,
    pubEnc: r
  });
};
hn.fromPrivate = function(e, t, r) {
  return t instanceof hn ? t : new hn(e, {
    priv: t,
    privEnc: r
  });
};
hn.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
hn.prototype.getPublic = function(e, t) {
  return typeof e == "string" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;
};
hn.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
hn.prototype._importPrivate = function(e, t) {
  this.priv = new de(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
hn.prototype._importPublic = function(e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? Bh(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Bh(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
hn.prototype.derive = function(e) {
  return e.validate() || Bh(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
hn.prototype.sign = function(e, t, r) {
  return this.ec.sign(e, this, t, r);
};
hn.prototype.verify = function(e, t) {
  return this.ec.verify(e, t, this);
};
hn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var B7 = Yn.assert;
function Ed(n, e) {
  if (n instanceof Ed)
    return n;
  this._importDER(n, e) || (B7(n.r && n.s, "Signature without r or s"), this.r = new de(n.r, 16), this.s = new de(n.s, 16), n.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = n.recoveryParam);
}
var Sd = Ed;
function $7() {
  this.place = 0;
}
function Bf(n, e) {
  var t = n[e.place++];
  if (!(t & 128))
    return t;
  var r = t & 15;
  if (r === 0 || r > 4)
    return !1;
  for (var i = 0, s = 0, a = e.place; s < r; s++, a++)
    i <<= 8, i |= n[a], i >>>= 0;
  return i <= 127 ? !1 : (e.place = a, i);
}
function ib(n) {
  for (var e = 0, t = n.length - 1; !n[e] && !(n[e + 1] & 128) && e < t; )
    e++;
  return e === 0 ? n : n.slice(e);
}
Ed.prototype._importDER = function(e, t) {
  e = Yn.toArray(e, t);
  var r = new $7();
  if (e[r.place++] !== 48)
    return !1;
  var i = Bf(e, r);
  if (i === !1 || i + r.place !== e.length || e[r.place++] !== 2)
    return !1;
  var s = Bf(e, r);
  if (s === !1)
    return !1;
  var a = e.slice(r.place, s + r.place);
  if (r.place += s, e[r.place++] !== 2)
    return !1;
  var o = Bf(e, r);
  if (o === !1 || e.length !== o + r.place)
    return !1;
  var c = e.slice(r.place, o + r.place);
  if (a[0] === 0)
    if (a[1] & 128)
      a = a.slice(1);
    else
      return !1;
  if (c[0] === 0)
    if (c[1] & 128)
      c = c.slice(1);
    else
      return !1;
  return this.r = new de(a), this.s = new de(c), this.recoveryParam = null, !0;
};
function $f(n, e) {
  if (e < 128) {
    n.push(e);
    return;
  }
  var t = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (n.push(t | 128); --t; )
    n.push(e >>> (t << 3) & 255);
  n.push(e);
}
Ed.prototype.toDER = function(e) {
  var t = this.r.toArray(), r = this.s.toArray();
  for (t[0] & 128 && (t = [0].concat(t)), r[0] & 128 && (r = [0].concat(r)), t = ib(t), r = ib(r); !r[0] && !(r[1] & 128); )
    r = r.slice(1);
  var i = [2];
  $f(i, t.length), i = i.concat(t), i.push(2), $f(i, r.length);
  var s = i.concat(r), a = [48];
  return $f(a, s.length), a = a.concat(s), Yn.encode(a, e);
};
var L7 = function() {
  throw new Error("unsupported");
}, X2 = Yn.assert;
function ur(n) {
  if (!(this instanceof ur))
    return new ur(n);
  typeof n == "string" && (X2(
    Object.prototype.hasOwnProperty.call(tu, n),
    "Unknown curve " + n
  ), n = tu[n]), n instanceof tu.PresetCurve && (n = { curve: n }), this.curve = n.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = n.curve.g, this.g.precompute(n.curve.n.bitLength() + 1), this.hash = n.hash || n.curve.hash;
}
var F7 = ur;
ur.prototype.keyPair = function(e) {
  return new pp(this, e);
};
ur.prototype.keyFromPrivate = function(e, t) {
  return pp.fromPrivate(this, e, t);
};
ur.prototype.keyFromPublic = function(e, t) {
  return pp.fromPublic(this, e, t);
};
ur.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var t = new Y2({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || L7(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), r = this.n.byteLength(), i = this.n.sub(new de(2)); ; ) {
    var s = new de(t.generate(r));
    if (!(s.cmp(i) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
ur.prototype._truncateToN = function(e, t) {
  var r = e.byteLength() * 8 - this.n.bitLength();
  return r > 0 && (e = e.ushrn(r)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
ur.prototype.sign = function(e, t, r, i) {
  typeof r == "object" && (i = r, r = null), i || (i = {}), t = this.keyFromPrivate(t, r), e = this._truncateToN(new de(e, 16));
  for (var s = this.n.byteLength(), a = t.getPrivate().toArray("be", s), o = e.toArray("be", s), c = new Y2({
    hash: this.hash,
    entropy: a,
    nonce: o,
    pers: i.pers,
    persEnc: i.persEnc || "utf8"
  }), l = this.n.sub(new de(1)), f = 0; ; f++) {
    var p = i.k ? i.k(f) : new de(c.generate(this.n.byteLength()));
    if (p = this._truncateToN(p, !0), !(p.cmpn(1) <= 0 || p.cmp(l) >= 0)) {
      var g = this.g.mul(p);
      if (!g.isInfinity()) {
        var T = g.getX(), v = T.umod(this.n);
        if (v.cmpn(0) !== 0) {
          var w = p.invm(this.n).mul(v.mul(t.getPrivate()).iadd(e));
          if (w = w.umod(this.n), w.cmpn(0) !== 0) {
            var C = (g.getY().isOdd() ? 1 : 0) | (T.cmp(v) !== 0 ? 2 : 0);
            return i.canonical && w.cmp(this.nh) > 0 && (w = this.n.sub(w), C ^= 1), new Sd({ r: v, s: w, recoveryParam: C });
          }
        }
      }
    }
  }
};
ur.prototype.verify = function(e, t, r, i) {
  e = this._truncateToN(new de(e, 16)), r = this.keyFromPublic(r, i), t = new Sd(t, "hex");
  var s = t.r, a = t.s;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0)
    return !1;
  var o = a.invm(this.n), c = o.mul(e).umod(this.n), l = o.mul(s).umod(this.n), f;
  return this.curve._maxwellTrick ? (f = this.g.jmulAdd(c, r.getPublic(), l), f.isInfinity() ? !1 : f.eqXToP(s)) : (f = this.g.mulAdd(c, r.getPublic(), l), f.isInfinity() ? !1 : f.getX().umod(this.n).cmp(s) === 0);
};
ur.prototype.recoverPubKey = function(n, e, t, r) {
  X2((3 & t) === t, "The recovery param is more than two bits"), e = new Sd(e, r);
  var i = this.n, s = new de(n), a = e.r, o = e.s, c = t & 1, l = t >> 1;
  if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
    throw new Error("Unable to find sencond key candinate");
  l ? a = this.curve.pointFromX(a.add(this.curve.n), c) : a = this.curve.pointFromX(a, c);
  var f = e.r.invm(i), p = i.sub(s).mul(f).umod(i), g = o.mul(f).umod(i);
  return this.g.mulAdd(p, a, g);
};
ur.prototype.getKeyRecoveryParam = function(n, e, t, r) {
  if (e = new Sd(e, r), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var i = 0; i < 4; i++) {
    var s;
    try {
      s = this.recoverPubKey(n, e, i);
    } catch {
      continue;
    }
    if (s.eq(t))
      return i;
  }
  throw new Error("Unable to find valid recovery factor");
};
var U7 = Co(function(n, e) {
  var t = e;
  t.version = "6.5.4", t.utils = Yn, t.rand = function() {
    throw new Error("unsupported");
  }, t.curve = eu, t.curves = tu, t.ec = F7, t.eddsa = null;
}), V7 = U7.ec;
const j7 = "signing-key/5.7.0", $h = new O(j7);
let Lf = null;
function Br() {
  return Lf || (Lf = new V7("secp256k1")), Lf;
}
class G7 {
  constructor(e) {
    H(this, "curve", "secp256k1"), H(this, "privateKey", te(e)), ea(this.privateKey) !== 32 && $h.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const t = Br().keyFromPrivate(ae(this.privateKey));
    H(this, "publicKey", "0x" + t.getPublic(!1, "hex")), H(this, "compressedPublicKey", "0x" + t.getPublic(!0, "hex")), H(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const t = Br().keyFromPublic(ae(this.publicKey)), r = Br().keyFromPublic(ae(e));
    return "0x" + t.pub.add(r.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const t = Br().keyFromPrivate(ae(this.privateKey)), r = ae(e);
    r.length !== 32 && $h.throwArgumentError("bad digest length", "digest", e);
    const i = t.sign(r, { canonical: !0 });
    return vd({
      recoveryParam: i.recoveryParam,
      r: Le("0x" + i.r.toString(16), 32),
      s: Le("0x" + i.s.toString(16), 32)
    });
  }
  computeSharedSecret(e) {
    const t = Br().keyFromPrivate(ae(this.privateKey)), r = Br().keyFromPublic(ae(Z2(e)));
    return Le("0x" + t.derive(r.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function W7(n, e) {
  const t = vd(e), r = { r: ae(t.r), s: ae(t.s) };
  return "0x" + Br().recoverPubKey(ae(n), r, t.recoveryParam).encode("hex", !1);
}
function Z2(n, e) {
  const t = ae(n);
  if (t.length === 32) {
    const r = new G7(t);
    return e ? "0x" + Br().keyFromPrivate(t).getPublic(!0, "hex") : r.publicKey;
  } else {
    if (t.length === 33)
      return e ? te(t) : "0x" + Br().keyFromPublic(t).getPublic(!1, "hex");
    if (t.length === 65)
      return e ? "0x" + Br().keyFromPublic(t).getPublic(!0, "hex") : te(t);
  }
  return $h.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const H7 = "transactions/5.7.0", Ni = new O(H7);
var sb;
(function(n) {
  n[n.legacy = 0] = "legacy", n[n.eip2930 = 1] = "eip2930", n[n.eip1559 = 2] = "eip1559";
})(sb || (sb = {}));
function mp(n) {
  return n === "0x" ? null : Rt(n);
}
function cn(n) {
  return n === "0x" ? up : G.from(n);
}
function z7(n) {
  const e = Z2(n);
  return Rt(an(Mt(an(e, 1)), 12));
}
function yp(n, e) {
  return z7(W7(ae(n), e));
}
function jn(n, e) {
  const t = Xa(G.from(n).toHexString());
  return t.length > 32 && Ni.throwArgumentError("invalid length for " + e, "transaction:" + e, n), t;
}
function Ff(n, e) {
  return {
    address: Rt(n),
    storageKeys: (e || []).map((t, r) => (ea(t) !== 32 && Ni.throwArgumentError("invalid access list storageKey", `accessList[${n}:${r}]`, t), t.toLowerCase()))
  };
}
function Eo(n) {
  if (Array.isArray(n))
    return n.map((t, r) => Array.isArray(t) ? (t.length > 2 && Ni.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${r}]`, t), Ff(t[0], t[1])) : Ff(t.address, t.storageKeys));
  const e = Object.keys(n).map((t) => {
    const r = n[t].reduce((i, s) => (i[s] = !0, i), {});
    return Ff(t, Object.keys(r).sort());
  });
  return e.sort((t, r) => t.address.localeCompare(r.address)), e;
}
function ew(n) {
  return Eo(n).map((e) => [e.address, e.storageKeys]);
}
function K7(n, e) {
  if (n.gasPrice != null) {
    const r = G.from(n.gasPrice), i = G.from(n.maxFeePerGas || 0);
    r.eq(i) || Ni.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
      gasPrice: r,
      maxFeePerGas: i
    });
  }
  const t = [
    jn(n.chainId || 0, "chainId"),
    jn(n.nonce || 0, "nonce"),
    jn(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    jn(n.maxFeePerGas || 0, "maxFeePerGas"),
    jn(n.gasLimit || 0, "gasLimit"),
    n.to != null ? Rt(n.to) : "0x",
    jn(n.value || 0, "value"),
    n.data || "0x",
    ew(n.accessList || [])
  ];
  if (e) {
    const r = vd(e);
    t.push(jn(r.recoveryParam, "recoveryParam")), t.push(Xa(r.r)), t.push(Xa(r.s));
  }
  return Pn(["0x02", il(t)]);
}
function q7(n, e) {
  const t = [
    jn(n.chainId || 0, "chainId"),
    jn(n.nonce || 0, "nonce"),
    jn(n.gasPrice || 0, "gasPrice"),
    jn(n.gasLimit || 0, "gasLimit"),
    n.to != null ? Rt(n.to) : "0x",
    jn(n.value || 0, "value"),
    n.data || "0x",
    ew(n.accessList || [])
  ];
  if (e) {
    const r = vd(e);
    t.push(jn(r.recoveryParam, "recoveryParam")), t.push(Xa(r.r)), t.push(Xa(r.s));
  }
  return Pn(["0x01", il(t)]);
}
function tw(n, e, t) {
  try {
    const r = cn(e[0]).toNumber();
    if (r !== 0 && r !== 1)
      throw new Error("bad recid");
    n.v = r;
  } catch {
    Ni.throwArgumentError("invalid v for transaction type: 1", "v", e[0]);
  }
  n.r = Le(e[1], 32), n.s = Le(e[2], 32);
  try {
    const r = Mt(t(n));
    n.from = yp(r, { r: n.r, s: n.s, recoveryParam: n.v });
  } catch {
  }
}
function Q7(n) {
  const e = wd(n.slice(1));
  e.length !== 9 && e.length !== 12 && Ni.throwArgumentError("invalid component count for transaction type: 2", "payload", te(n));
  const t = cn(e[2]), r = cn(e[3]), i = {
    type: 2,
    chainId: cn(e[0]).toNumber(),
    nonce: cn(e[1]).toNumber(),
    maxPriorityFeePerGas: t,
    maxFeePerGas: r,
    gasPrice: null,
    gasLimit: cn(e[4]),
    to: mp(e[5]),
    value: cn(e[6]),
    data: e[7],
    accessList: Eo(e[8])
  };
  return e.length === 9 || (i.hash = Mt(n), tw(i, e.slice(9), K7)), i;
}
function J7(n) {
  const e = wd(n.slice(1));
  e.length !== 8 && e.length !== 11 && Ni.throwArgumentError("invalid component count for transaction type: 1", "payload", te(n));
  const t = {
    type: 1,
    chainId: cn(e[0]).toNumber(),
    nonce: cn(e[1]).toNumber(),
    gasPrice: cn(e[2]),
    gasLimit: cn(e[3]),
    to: mp(e[4]),
    value: cn(e[5]),
    data: e[6],
    accessList: Eo(e[7])
  };
  return e.length === 8 || (t.hash = Mt(n), tw(t, e.slice(8), q7)), t;
}
function Y7(n) {
  const e = wd(n);
  e.length !== 9 && e.length !== 6 && Ni.throwArgumentError("invalid raw transaction", "rawTransaction", n);
  const t = {
    nonce: cn(e[0]).toNumber(),
    gasPrice: cn(e[1]),
    gasLimit: cn(e[2]),
    to: mp(e[3]),
    value: cn(e[4]),
    data: e[5],
    chainId: 0
  };
  if (e.length === 6)
    return t;
  try {
    t.v = G.from(e[6]).toNumber();
  } catch {
    return t;
  }
  if (t.r = Le(e[7], 32), t.s = Le(e[8], 32), G.from(t.r).isZero() && G.from(t.s).isZero())
    t.chainId = t.v, t.v = 0;
  else {
    t.chainId = Math.floor((t.v - 35) / 2), t.chainId < 0 && (t.chainId = 0);
    let r = t.v - 27;
    const i = e.slice(0, 6);
    t.chainId !== 0 && (i.push(te(t.chainId)), i.push("0x"), i.push("0x"), r -= t.chainId * 2 + 8);
    const s = Mt(il(i));
    try {
      t.from = yp(s, { r: te(t.r), s: te(t.s), recoveryParam: r });
    } catch {
    }
    t.hash = Mt(n);
  }
  return t.type = null, t;
}
function X7(n) {
  const e = ae(n);
  if (e[0] > 127)
    return Y7(e);
  switch (e[0]) {
    case 1:
      return J7(e);
    case 2:
      return Q7(e);
  }
  return Ni.throwError(`unsupported transaction type: ${e[0]}`, O.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: e[0]
  });
}
const Z7 = "contracts/5.7.0";
var ia = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const _t = new O(Z7);
function Iu(n, e) {
  return ia(this, void 0, void 0, function* () {
    const t = yield e;
    typeof t != "string" && _t.throwArgumentError("invalid address or ENS name", "name", t);
    try {
      return Rt(t);
    } catch {
    }
    n || _t.throwError("a provider or signer is needed to resolve ENS names", O.errors.UNSUPPORTED_OPERATION, {
      operation: "resolveName"
    });
    const r = yield n.resolveName(t);
    return r == null && _t.throwArgumentError("resolver or addr is not configured for ENS name", "name", t), r;
  });
}
function nu(n, e, t) {
  return ia(this, void 0, void 0, function* () {
    return Array.isArray(t) ? yield Promise.all(t.map((r, i) => nu(n, Array.isArray(e) ? e[i] : e[r.name], r))) : t.type === "address" ? yield Iu(n, e) : t.type === "tuple" ? yield nu(n, e, t.components) : t.baseType === "array" ? Array.isArray(e) ? yield Promise.all(e.map((r) => nu(n, r, t.arrayChildren))) : Promise.reject(_t.makeError("invalid value for array", O.errors.INVALID_ARGUMENT, {
      argument: "value",
      value: e
    })) : e;
  });
}
function _d(n, e, t) {
  return ia(this, void 0, void 0, function* () {
    let r = {};
    t.length === e.inputs.length + 1 && typeof t[t.length - 1] == "object" && (r = $t(t.pop())), _t.checkArgumentCount(t.length, e.inputs.length, "passed to contract"), n.signer ? r.from ? r.from = It({
      override: Iu(n.signer, r.from),
      signer: n.signer.getAddress()
    }).then((l) => ia(this, void 0, void 0, function* () {
      return Rt(l.signer) !== l.override && _t.throwError("Contract with a Signer cannot override from", O.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.from"
      }), l.override;
    })) : r.from = n.signer.getAddress() : r.from && (r.from = Iu(n.provider, r.from));
    const i = yield It({
      args: nu(n.signer || n.provider, t, e.inputs),
      address: n.resolvedAddress,
      overrides: It(r) || {}
    }), s = n.interface.encodeFunctionData(e, i.args), a = {
      data: s,
      to: i.address
    }, o = i.overrides;
    if (o.nonce != null && (a.nonce = G.from(o.nonce).toNumber()), o.gasLimit != null && (a.gasLimit = G.from(o.gasLimit)), o.gasPrice != null && (a.gasPrice = G.from(o.gasPrice)), o.maxFeePerGas != null && (a.maxFeePerGas = G.from(o.maxFeePerGas)), o.maxPriorityFeePerGas != null && (a.maxPriorityFeePerGas = G.from(o.maxPriorityFeePerGas)), o.from != null && (a.from = o.from), o.type != null && (a.type = o.type), o.accessList != null && (a.accessList = Eo(o.accessList)), a.gasLimit == null && e.gas != null) {
      let l = 21e3;
      const f = ae(s);
      for (let p = 0; p < f.length; p++)
        l += 4, f[p] && (l += 64);
      a.gasLimit = G.from(e.gas).add(l);
    }
    if (o.value) {
      const l = G.from(o.value);
      !l.isZero() && !e.payable && _t.throwError("non-payable method cannot override value", O.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.value",
        value: r.value
      }), a.value = l;
    }
    o.customData && (a.customData = $t(o.customData)), o.ccipReadEnabled && (a.ccipReadEnabled = !!o.ccipReadEnabled), delete r.nonce, delete r.gasLimit, delete r.gasPrice, delete r.from, delete r.value, delete r.type, delete r.accessList, delete r.maxFeePerGas, delete r.maxPriorityFeePerGas, delete r.customData, delete r.ccipReadEnabled;
    const c = Object.keys(r).filter((l) => r[l] != null);
    return c.length && _t.throwError(`cannot override ${c.map((l) => JSON.stringify(l)).join(",")}`, O.errors.UNSUPPORTED_OPERATION, {
      operation: "overrides",
      overrides: c
    }), a;
  });
}
function e_(n, e) {
  return function(...t) {
    return _d(n, e, t);
  };
}
function t_(n, e) {
  const t = n.signer || n.provider;
  return function(...r) {
    return ia(this, void 0, void 0, function* () {
      t || _t.throwError("estimate require a provider or signer", O.errors.UNSUPPORTED_OPERATION, {
        operation: "estimateGas"
      });
      const i = yield _d(n, e, r);
      return yield t.estimateGas(i);
    });
  };
}
function n_(n, e) {
  const t = e.wait.bind(e);
  e.wait = (r) => t(r).then((i) => (i.events = i.logs.map((s) => {
    let a = Ci(s), o = null;
    try {
      o = n.interface.parseLog(s);
    } catch {
    }
    return o && (a.args = o.args, a.decode = (c, l) => n.interface.decodeEventLog(o.eventFragment, c, l), a.event = o.name, a.eventSignature = o.signature), a.removeListener = () => n.provider, a.getBlock = () => n.provider.getBlock(i.blockHash), a.getTransaction = () => n.provider.getTransaction(i.transactionHash), a.getTransactionReceipt = () => Promise.resolve(i), a;
  }), i));
}
function nw(n, e, t) {
  const r = n.signer || n.provider;
  return function(...i) {
    return ia(this, void 0, void 0, function* () {
      let s;
      if (i.length === e.inputs.length + 1 && typeof i[i.length - 1] == "object") {
        const c = $t(i.pop());
        c.blockTag != null && (s = yield c.blockTag), delete c.blockTag, i.push(c);
      }
      n.deployTransaction != null && (yield n._deployed(s));
      const a = yield _d(n, e, i), o = yield r.call(a, s);
      try {
        let c = n.interface.decodeFunctionResult(e, o);
        return t && e.outputs.length === 1 && (c = c[0]), c;
      } catch (c) {
        throw c.code === O.errors.CALL_EXCEPTION && (c.address = n.address, c.args = i, c.transaction = a), c;
      }
    });
  };
}
function r_(n, e) {
  return function(...t) {
    return ia(this, void 0, void 0, function* () {
      n.signer || _t.throwError("sending a transaction requires a signer", O.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction"
      }), n.deployTransaction != null && (yield n._deployed());
      const r = yield _d(n, e, t), i = yield n.signer.sendTransaction(r);
      return n_(n, i), i;
    });
  };
}
function ab(n, e, t) {
  return e.constant ? nw(n, e, t) : r_(n, e);
}
function rw(n) {
  return n.address && (n.topics == null || n.topics.length === 0) ? "*" : (n.address || "*") + "@" + (n.topics ? n.topics.map((e) => Array.isArray(e) ? e.join("|") : e).join(":") : "");
}
class Sc {
  constructor(e, t) {
    H(this, "tag", e), H(this, "filter", t), this._listeners = [];
  }
  addListener(e, t) {
    this._listeners.push({ listener: e, once: t });
  }
  removeListener(e) {
    let t = !1;
    this._listeners = this._listeners.filter((r) => t || r.listener !== e ? !0 : (t = !0, !1));
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((e) => e.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(e) {
    const t = this.listenerCount();
    return this._listeners = this._listeners.filter((r) => {
      const i = e.slice();
      return setTimeout(() => {
        r.listener.apply(this, i);
      }, 0), !r.once;
    }), t;
  }
  prepareEvent(e) {
  }
  getEmit(e) {
    return [e];
  }
}
class i_ extends Sc {
  constructor() {
    super("error", null);
  }
}
class ob extends Sc {
  constructor(e, t, r, i) {
    const s = {
      address: e
    };
    let a = t.getEventTopic(r);
    i ? (a !== i[0] && _t.throwArgumentError("topic mismatch", "topics", i), s.topics = i.slice()) : s.topics = [a], super(rw(s), s), H(this, "address", e), H(this, "interface", t), H(this, "fragment", r);
  }
  prepareEvent(e) {
    super.prepareEvent(e), e.event = this.fragment.name, e.eventSignature = this.fragment.format(), e.decode = (t, r) => this.interface.decodeEventLog(this.fragment, t, r);
    try {
      e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics);
    } catch (t) {
      e.args = null, e.decodeError = t;
    }
  }
  getEmit(e) {
    const t = pC(e.args);
    if (t.length)
      throw t[0].error;
    const r = (e.args || []).slice();
    return r.push(e), r;
  }
}
class cb extends Sc {
  constructor(e, t) {
    super("*", { address: e }), H(this, "address", e), H(this, "interface", t);
  }
  prepareEvent(e) {
    super.prepareEvent(e);
    try {
      const t = this.interface.parseLog(e);
      e.event = t.name, e.eventSignature = t.signature, e.decode = (r, i) => this.interface.decodeEventLog(t.eventFragment, r, i), e.args = t.args;
    } catch {
    }
  }
}
class s_ {
  constructor(e, t, r) {
    H(this, "interface", jr(new.target, "getInterface")(t)), r == null ? (H(this, "provider", null), H(this, "signer", null)) : os.isSigner(r) ? (H(this, "provider", r.provider || null), H(this, "signer", r)) : Td.isProvider(r) ? (H(this, "provider", r), H(this, "signer", null)) : _t.throwArgumentError("invalid signer or provider", "signerOrProvider", r), H(this, "callStatic", {}), H(this, "estimateGas", {}), H(this, "functions", {}), H(this, "populateTransaction", {}), H(this, "filters", {});
    {
      const a = {};
      Object.keys(this.interface.events).forEach((o) => {
        const c = this.interface.events[o];
        H(this.filters, o, (...l) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(c, l)
        })), a[c.name] || (a[c.name] = []), a[c.name].push(o);
      }), Object.keys(a).forEach((o) => {
        const c = a[o];
        c.length === 1 ? H(this.filters, o, this.filters[c[0]]) : _t.warn(`Duplicate definition of ${o} (${c.join(", ")})`);
      });
    }
    if (H(this, "_runningEvents", {}), H(this, "_wrappedEmits", {}), e == null && _t.throwArgumentError("invalid contract address or ENS name", "addressOrName", e), H(this, "address", e), this.provider)
      H(this, "resolvedAddress", Iu(this.provider, e));
    else
      try {
        H(this, "resolvedAddress", Promise.resolve(Rt(e)));
      } catch {
        _t.throwError("provider is required to use ENS name as contract address", O.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    this.resolvedAddress.catch((a) => {
    });
    const i = {}, s = {};
    Object.keys(this.interface.functions).forEach((a) => {
      const o = this.interface.functions[a];
      if (s[a]) {
        _t.warn(`Duplicate ABI entry for ${JSON.stringify(a)}`);
        return;
      }
      s[a] = !0;
      {
        const c = o.name;
        i[`%${c}`] || (i[`%${c}`] = []), i[`%${c}`].push(a);
      }
      this[a] == null && H(this, a, ab(this, o, !0)), this.functions[a] == null && H(this.functions, a, ab(this, o, !1)), this.callStatic[a] == null && H(this.callStatic, a, nw(this, o, !0)), this.populateTransaction[a] == null && H(this.populateTransaction, a, e_(this, o)), this.estimateGas[a] == null && H(this.estimateGas, a, t_(this, o));
    }), Object.keys(i).forEach((a) => {
      const o = i[a];
      if (o.length > 1)
        return;
      a = a.substring(1);
      const c = o[0];
      try {
        this[a] == null && H(this, a, this[c]);
      } catch {
      }
      this.functions[a] == null && H(this.functions, a, this.functions[c]), this.callStatic[a] == null && H(this.callStatic, a, this.callStatic[c]), this.populateTransaction[a] == null && H(this.populateTransaction, a, this.populateTransaction[c]), this.estimateGas[a] == null && H(this.estimateGas, a, this.estimateGas[c]);
    });
  }
  static getContractAddress(e) {
    return f2(e);
  }
  static getInterface(e) {
    return Zg.isInterface(e) ? e : new Zg(e);
  }
  deployed() {
    return this._deployed();
  }
  _deployed(e) {
    return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, e).then((t) => (t === "0x" && _t.throwError("contract not deployed", O.errors.UNSUPPORTED_OPERATION, {
      contractAddress: this.address,
      operation: "getDeployed"
    }), this))), this._deployedPromise;
  }
  fallback(e) {
    this.signer || _t.throwError("sending a transactions require a signer", O.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    const t = $t(e || {});
    return ["from", "to"].forEach(function(r) {
      t[r] != null && _t.throwError("cannot override " + r, O.errors.UNSUPPORTED_OPERATION, { operation: r });
    }), t.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(t));
  }
  connect(e) {
    typeof e == "string" && (e = new dp(e, this.provider));
    const t = new this.constructor(this.address, this.interface, e);
    return this.deployTransaction && H(t, "deployTransaction", this.deployTransaction), t;
  }
  attach(e) {
    return new this.constructor(e, this.interface, this.signer || this.provider);
  }
  static isIndexed(e) {
    return Ih.isIndexed(e);
  }
  _normalizeRunningEvent(e) {
    return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e;
  }
  _getRunningEvent(e) {
    if (typeof e == "string") {
      if (e === "error")
        return this._normalizeRunningEvent(new i_());
      if (e === "event")
        return this._normalizeRunningEvent(new Sc("event", null));
      if (e === "*")
        return this._normalizeRunningEvent(new cb(this.address, this.interface));
      const t = this.interface.getEvent(e);
      return this._normalizeRunningEvent(new ob(this.address, this.interface, t));
    }
    if (e.topics && e.topics.length > 0) {
      try {
        const r = e.topics[0];
        if (typeof r != "string")
          throw new Error("invalid topic");
        const i = this.interface.getEvent(r);
        return this._normalizeRunningEvent(new ob(this.address, this.interface, i, e.topics));
      } catch {
      }
      const t = {
        address: this.address,
        topics: e.topics
      };
      return this._normalizeRunningEvent(new Sc(rw(t), t));
    }
    return this._normalizeRunningEvent(new cb(this.address, this.interface));
  }
  _checkRunningEvents(e) {
    if (e.listenerCount() === 0) {
      delete this._runningEvents[e.tag];
      const t = this._wrappedEmits[e.tag];
      t && e.filter && (this.provider.off(e.filter, t), delete this._wrappedEmits[e.tag]);
    }
  }
  _wrapEvent(e, t, r) {
    const i = Ci(t);
    return i.removeListener = () => {
      !r || (e.removeListener(r), this._checkRunningEvents(e));
    }, i.getBlock = () => this.provider.getBlock(t.blockHash), i.getTransaction = () => this.provider.getTransaction(t.transactionHash), i.getTransactionReceipt = () => this.provider.getTransactionReceipt(t.transactionHash), e.prepareEvent(i), i;
  }
  _addEventListener(e, t, r) {
    if (this.provider || _t.throwError("events require a provider or a signer with a provider", O.errors.UNSUPPORTED_OPERATION, { operation: "once" }), e.addListener(t, r), this._runningEvents[e.tag] = e, !this._wrappedEmits[e.tag]) {
      const i = (s) => {
        let a = this._wrapEvent(e, s, t);
        if (a.decodeError == null)
          try {
            const o = e.getEmit(a);
            this.emit(e.filter, ...o);
          } catch (o) {
            a.decodeError = o.error;
          }
        e.filter != null && this.emit("event", a), a.decodeError != null && this.emit("error", a.decodeError, a);
      };
      this._wrappedEmits[e.tag] = i, e.filter != null && this.provider.on(e.filter, i);
    }
  }
  queryFilter(e, t, r) {
    const i = this._getRunningEvent(e), s = $t(i.filter);
    return typeof t == "string" && Pe(t, 32) ? (r != null && _t.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", r), s.blockHash = t) : (s.fromBlock = t ?? 0, s.toBlock = r ?? "latest"), this.provider.getLogs(s).then((a) => a.map((o) => this._wrapEvent(i, o, null)));
  }
  on(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !1), this;
  }
  once(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !0), this;
  }
  emit(e, ...t) {
    if (!this.provider)
      return !1;
    const r = this._getRunningEvent(e), i = r.run(t) > 0;
    return this._checkRunningEvents(r), i;
  }
  listenerCount(e) {
    return this.provider ? e == null ? Object.keys(this._runningEvents).reduce((t, r) => t + this._runningEvents[r].listenerCount(), 0) : this._getRunningEvent(e).listenerCount() : 0;
  }
  listeners(e) {
    if (!this.provider)
      return [];
    if (e == null) {
      const t = [];
      for (let r in this._runningEvents)
        this._runningEvents[r].listeners().forEach((i) => {
          t.push(i);
        });
      return t;
    }
    return this._getRunningEvent(e).listeners();
  }
  removeAllListeners(e) {
    if (!this.provider)
      return this;
    if (e == null) {
      for (const r in this._runningEvents) {
        const i = this._runningEvents[r];
        i.removeAllListeners(), this._checkRunningEvents(i);
      }
      return this;
    }
    const t = this._getRunningEvent(e);
    return t.removeAllListeners(), this._checkRunningEvents(t), this;
  }
  off(e, t) {
    if (!this.provider)
      return this;
    const r = this._getRunningEvent(e);
    return r.removeListener(t), this._checkRunningEvents(r), this;
  }
  removeListener(e, t) {
    return this.off(e, t);
  }
}
class iw extends s_ {
}
const a_ = !0, o_ = "https://primedao.mypinata.cloud//", c_ = "Alfajores", l_ = { KOL_IPFS_GATEWAY: "https://primedao.mypinata.cloud//", KOL_FIREBASE_API_KEY: "AIzaSyCItD_gHaRvRrd8evJtFKPALsZLY1EkHe4", KOL_NETWORK: "Alfajores", BASE_URL: "/", MODE: "development", DEV: !0, PROD: !1 }.KOL_ETHERSCAN_LINK ?? "https://alfajores-blockscout.celo-testnet.org/{type}/{address}", u_ = "networks/5.7.1", lb = new O(u_);
function d_(n) {
  return n && typeof n.renetwork == "function";
}
function li(n) {
  const e = function(t, r) {
    r == null && (r = {});
    const i = [];
    if (t.InfuraProvider && r.infura !== "-")
      try {
        i.push(new t.InfuraProvider(n, r.infura));
      } catch {
      }
    if (t.EtherscanProvider && r.etherscan !== "-")
      try {
        i.push(new t.EtherscanProvider(n, r.etherscan));
      } catch {
      }
    if (t.AlchemyProvider && r.alchemy !== "-")
      try {
        i.push(new t.AlchemyProvider(n, r.alchemy));
      } catch {
      }
    if (t.PocketProvider && r.pocket !== "-") {
      const s = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const a = new t.PocketProvider(n, r.pocket);
        a.network && s.indexOf(a.network.name) === -1 && i.push(a);
      } catch {
      }
    }
    if (t.CloudflareProvider && r.cloudflare !== "-")
      try {
        i.push(new t.CloudflareProvider(n));
      } catch {
      }
    if (t.AnkrProvider && r.ankr !== "-")
      try {
        const s = ["ropsten"], a = new t.AnkrProvider(n, r.ankr);
        a.network && s.indexOf(a.network.name) === -1 && i.push(a);
      } catch {
      }
    if (i.length === 0)
      return null;
    if (t.FallbackProvider) {
      let s = 1;
      return r.quorum != null ? s = r.quorum : n === "homestead" && (s = 2), new t.FallbackProvider(i, s);
    }
    return i[0];
  };
  return e.renetwork = function(t) {
    return li(t);
  }, e;
}
function Ou(n, e) {
  const t = function(r, i) {
    return r.JsonRpcProvider ? new r.JsonRpcProvider(n, e) : null;
  };
  return t.renetwork = function(r) {
    return Ou(n, r);
  }, t;
}
const ub = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: li("homestead")
}, db = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: li("ropsten")
}, fb = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: Ou("https://www.ethercluster.com/mordor", "classicMordor")
}, Ml = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead: ub,
  mainnet: ub,
  morden: { chainId: 2, name: "morden" },
  ropsten: db,
  testnet: db,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: li("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: li("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: li("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: li("sepolia")
  },
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: Ou("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor: fb,
  classicTestnet: fb,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: Ou("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: li("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: li("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function sw(n) {
  if (n == null)
    return null;
  if (typeof n == "number") {
    for (const r in Ml) {
      const i = Ml[r];
      if (i.chainId === n)
        return {
          name: i.name,
          chainId: i.chainId,
          ensAddress: i.ensAddress || null,
          _defaultProvider: i._defaultProvider || null
        };
    }
    return {
      chainId: n,
      name: "unknown"
    };
  }
  if (typeof n == "string") {
    const r = Ml[n];
    return r == null ? null : {
      name: r.name,
      chainId: r.chainId,
      ensAddress: r.ensAddress,
      _defaultProvider: r._defaultProvider || null
    };
  }
  const e = Ml[n.name];
  if (!e)
    return typeof n.chainId != "number" && lb.throwArgumentError("invalid network chainId", "network", n), n;
  n.chainId !== 0 && n.chainId !== e.chainId && lb.throwArgumentError("network chainId mismatch", "network", n);
  let t = n._defaultProvider || null;
  return t == null && e._defaultProvider && (d_(e._defaultProvider) ? t = e._defaultProvider.renetwork(n) : t = e._defaultProvider), {
    name: n.name,
    chainId: e.chainId,
    ensAddress: n.ensAddress || e.ensAddress || null,
    _defaultProvider: t
  };
}
class aw {
  constructor(e) {
    H(this, "alphabet", e), H(this, "base", e.length), H(this, "_alphabetMap", {}), H(this, "_leader", e.charAt(0));
    for (let t = 0; t < e.length; t++)
      this._alphabetMap[e.charAt(t)] = t;
  }
  encode(e) {
    let t = ae(e);
    if (t.length === 0)
      return "";
    let r = [0];
    for (let s = 0; s < t.length; ++s) {
      let a = t[s];
      for (let o = 0; o < r.length; ++o)
        a += r[o] << 8, r[o] = a % this.base, a = a / this.base | 0;
      for (; a > 0; )
        r.push(a % this.base), a = a / this.base | 0;
    }
    let i = "";
    for (let s = 0; t[s] === 0 && s < t.length - 1; ++s)
      i += this._leader;
    for (let s = r.length - 1; s >= 0; --s)
      i += this.alphabet[r[s]];
    return i;
  }
  decode(e) {
    if (typeof e != "string")
      throw new TypeError("Expected String");
    let t = [];
    if (e.length === 0)
      return new Uint8Array(t);
    t.push(0);
    for (let r = 0; r < e.length; r++) {
      let i = this._alphabetMap[e[r]];
      if (i === void 0)
        throw new Error("Non-base" + this.base + " character");
      let s = i;
      for (let a = 0; a < t.length; ++a)
        s += t[a] * this.base, t[a] = s & 255, s >>= 8;
      for (; s > 0; )
        t.push(s & 255), s >>= 8;
    }
    for (let r = 0; e[r] === this._leader && r < e.length - 1; ++r)
      t.push(0);
    return ae(new Uint8Array(t.reverse()));
  }
}
new aw("abcdefghijklmnopqrstuvwxyz234567");
const Lh = new aw("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var hb;
(function(n) {
  n.sha256 = "sha256", n.sha512 = "sha512";
})(hb || (hb = {}));
const f_ = "sha2/5.7.0", $N = new O(f_);
function pb(n) {
  return "0x" + Dr.sha256().update(ae(n)).digest("hex");
}
const h_ = "web/5.7.1";
var p_ = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
function m_(n, e) {
  return p_(this, void 0, void 0, function* () {
    e == null && (e = {});
    const t = {
      method: e.method || "GET",
      headers: e.headers || {},
      body: e.body || void 0
    };
    if (e.skipFetchSetup !== !0 && (t.mode = "cors", t.cache = "no-cache", t.credentials = "same-origin", t.redirect = "follow", t.referrer = "client"), e.fetchOptions != null) {
      const a = e.fetchOptions;
      a.mode && (t.mode = a.mode), a.cache && (t.cache = a.cache), a.credentials && (t.credentials = a.credentials), a.redirect && (t.redirect = a.redirect), a.referrer && (t.referrer = a.referrer);
    }
    const r = yield fetch(n, t), i = yield r.arrayBuffer(), s = {};
    return r.headers.forEach ? r.headers.forEach((a, o) => {
      s[o.toLowerCase()] = a;
    }) : r.headers.keys().forEach((a) => {
      s[a.toLowerCase()] = r.headers.get(a);
    }), {
      headers: s,
      statusCode: r.status,
      statusMessage: r.statusText,
      body: ae(new Uint8Array(i))
    };
  });
}
var y_ = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const br = new O(h_);
function mb(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function qi(n, e) {
  if (n == null)
    return null;
  if (typeof n == "string")
    return n;
  if (sp(n)) {
    if (e && (e.split("/")[0] === "text" || e.split(";")[0].trim() === "application/json"))
      try {
        return sl(n);
      } catch {
      }
    return te(n);
  }
  return n;
}
function g_(n) {
  return Pr(n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))));
}
function b_(n, e, t) {
  const r = typeof n == "object" && n.throttleLimit != null ? n.throttleLimit : 12;
  br.assertArgument(r > 0 && r % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", r);
  const i = typeof n == "object" ? n.throttleCallback : null, s = typeof n == "object" && typeof n.throttleSlotInterval == "number" ? n.throttleSlotInterval : 100;
  br.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
  const a = typeof n == "object" ? !!n.errorPassThrough : !1, o = {};
  let c = null;
  const l = {
    method: "GET"
  };
  let f = !1, p = 2 * 60 * 1e3;
  if (typeof n == "string")
    c = n;
  else if (typeof n == "object") {
    if ((n == null || n.url == null) && br.throwArgumentError("missing URL", "connection.url", n), c = n.url, typeof n.timeout == "number" && n.timeout > 0 && (p = n.timeout), n.headers)
      for (const _ in n.headers)
        o[_.toLowerCase()] = { key: _, value: String(n.headers[_]) }, ["if-none-match", "if-modified-since"].indexOf(_.toLowerCase()) >= 0 && (f = !0);
    if (l.allowGzip = !!n.allowGzip, n.user != null && n.password != null) {
      c.substring(0, 6) !== "https:" && n.allowInsecureAuthentication !== !0 && br.throwError("basic authentication requires a secure https url", O.errors.INVALID_ARGUMENT, { argument: "url", url: c, user: n.user, password: "[REDACTED]" });
      const _ = n.user + ":" + n.password;
      o.authorization = {
        key: "Authorization",
        value: "Basic " + w2(Pr(_))
      };
    }
    n.skipFetchSetup != null && (l.skipFetchSetup = !!n.skipFetchSetup), n.fetchOptions != null && (l.fetchOptions = $t(n.fetchOptions));
  }
  const g = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), T = c ? c.match(g) : null;
  if (T)
    try {
      const _ = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": T[1] || "text/plain" },
        body: T[2] ? v2(T[3]) : g_(T[3])
      };
      let I = _.body;
      return t && (I = t(_.body, _)), Promise.resolve(I);
    } catch (_) {
      br.throwError("processing response error", O.errors.SERVER_ERROR, {
        body: qi(T[1], T[2]),
        error: _,
        requestBody: null,
        requestMethod: "GET",
        url: c
      });
    }
  e && (l.method = "POST", l.body = e, o["content-type"] == null && (o["content-type"] = { key: "Content-Type", value: "application/octet-stream" }), o["content-length"] == null && (o["content-length"] = { key: "Content-Length", value: String(e.length) }));
  const v = {};
  Object.keys(o).forEach((_) => {
    const I = o[_];
    v[I.key] = I.value;
  }), l.headers = v;
  const w = function() {
    let _ = null;
    return { promise: new Promise(function(N, D) {
      p && (_ = setTimeout(() => {
        _ != null && (_ = null, D(br.makeError("timeout", O.errors.TIMEOUT, {
          requestBody: qi(l.body, v["content-type"]),
          requestMethod: l.method,
          timeout: p,
          url: c
        })));
      }, p));
    }), cancel: function() {
      _ != null && (clearTimeout(_), _ = null);
    } };
  }(), C = function() {
    return y_(this, void 0, void 0, function* () {
      for (let _ = 0; _ < r; _++) {
        let I = null;
        try {
          if (I = yield m_(c, l), _ < r) {
            if (I.statusCode === 301 || I.statusCode === 302) {
              const N = I.headers.location || "";
              if (l.method === "GET" && N.match(/^https:/)) {
                c = I.headers.location;
                continue;
              }
            } else if (I.statusCode === 429) {
              let N = !0;
              if (i && (N = yield i(_, c)), N) {
                let D = 0;
                const U = I.headers["retry-after"];
                typeof U == "string" && U.match(/^[1-9][0-9]*$/) ? D = parseInt(U) * 1e3 : D = s * parseInt(String(Math.random() * Math.pow(2, _))), yield mb(D);
                continue;
              }
            }
          }
        } catch (N) {
          I = N.response, I == null && (w.cancel(), br.throwError("missing response", O.errors.SERVER_ERROR, {
            requestBody: qi(l.body, v["content-type"]),
            requestMethod: l.method,
            serverError: N,
            url: c
          }));
        }
        let B = I.body;
        if (f && I.statusCode === 304 ? B = null : !a && (I.statusCode < 200 || I.statusCode >= 300) && (w.cancel(), br.throwError("bad response", O.errors.SERVER_ERROR, {
          status: I.statusCode,
          headers: I.headers,
          body: qi(B, I.headers ? I.headers["content-type"] : null),
          requestBody: qi(l.body, v["content-type"]),
          requestMethod: l.method,
          url: c
        })), t)
          try {
            const N = yield t(B, I);
            return w.cancel(), N;
          } catch (N) {
            if (N.throttleRetry && _ < r) {
              let D = !0;
              if (i && (D = yield i(_, c)), D) {
                const U = s * parseInt(String(Math.random() * Math.pow(2, _)));
                yield mb(U);
                continue;
              }
            }
            w.cancel(), br.throwError("processing response error", O.errors.SERVER_ERROR, {
              body: qi(B, I.headers ? I.headers["content-type"] : null),
              error: N,
              requestBody: qi(l.body, v["content-type"]),
              requestMethod: l.method,
              url: c
            });
          }
        return w.cancel(), B;
      }
      return br.throwError("failed response", O.errors.SERVER_ERROR, {
        requestBody: qi(l.body, v["content-type"]),
        requestMethod: l.method,
        url: c
      });
    });
  }();
  return Promise.race([w.promise, C]);
}
function gp(n, e, t) {
  let r = (s, a) => {
    let o = null;
    if (s != null)
      try {
        o = JSON.parse(sl(s));
      } catch (c) {
        br.throwError("invalid JSON", O.errors.SERVER_ERROR, {
          body: s,
          error: c
        });
      }
    return t && (o = t(o, a)), o;
  }, i = null;
  if (e != null) {
    i = Pr(e);
    const s = typeof n == "string" ? { url: n } : $t(n);
    s.headers ? Object.keys(s.headers).filter((o) => o.toLowerCase() === "content-type").length !== 0 || (s.headers = $t(s.headers), s.headers["content-type"] = "application/json") : s.headers = { "content-type": "application/json" }, n = s;
  }
  return b_(n, i, r);
}
function zo(n, e) {
  return e || (e = {}), e = $t(e), e.floor == null && (e.floor = 0), e.ceiling == null && (e.ceiling = 1e4), e.interval == null && (e.interval = 250), new Promise(function(t, r) {
    let i = null, s = !1;
    const a = () => s ? !1 : (s = !0, i && clearTimeout(i), !0);
    e.timeout && (i = setTimeout(() => {
      a() && r(new Error("timeout"));
    }, e.timeout));
    const o = e.retryLimit;
    let c = 0;
    function l() {
      return n().then(function(f) {
        if (f !== void 0)
          a() && t(f);
        else if (e.oncePoll)
          e.oncePoll.once("poll", l);
        else if (e.onceBlock)
          e.onceBlock.once("block", l);
        else if (!s) {
          if (c++, c > o) {
            a() && r(new Error("retry limit reached"));
            return;
          }
          let p = e.interval * parseInt(String(Math.random() * Math.pow(2, c)));
          p < e.floor && (p = e.floor), p > e.ceiling && (p = e.ceiling), setTimeout(l, p);
        }
        return null;
      }, function(f) {
        a() && r(f);
      });
    }
    l();
  });
}
var Du = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Fh = {};
for (var Rl = 0; Rl < Du.length; Rl++) {
  var Uf = Du.charAt(Rl);
  if (Fh[Uf] !== void 0)
    throw new TypeError(Uf + " is ambiguous");
  Fh[Uf] = Rl;
}
function Wa(n) {
  var e = n >> 25;
  return (n & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059;
}
function ow(n) {
  for (var e = 1, t = 0; t < n.length; ++t) {
    var r = n.charCodeAt(t);
    if (r < 33 || r > 126)
      return "Invalid prefix (" + n + ")";
    e = Wa(e) ^ r >> 5;
  }
  for (e = Wa(e), t = 0; t < n.length; ++t) {
    var i = n.charCodeAt(t);
    e = Wa(e) ^ i & 31;
  }
  return e;
}
function x_(n, e, t) {
  if (t = t || 90, n.length + 7 + e.length > t)
    throw new TypeError("Exceeds length limit");
  n = n.toLowerCase();
  var r = ow(n);
  if (typeof r == "string")
    throw new Error(r);
  for (var i = n + "1", s = 0; s < e.length; ++s) {
    var a = e[s];
    if (a >> 5 !== 0)
      throw new Error("Non 5-bit word");
    r = Wa(r) ^ a, i += Du.charAt(a);
  }
  for (s = 0; s < 6; ++s)
    r = Wa(r);
  for (r ^= 1, s = 0; s < 6; ++s) {
    var o = r >> (5 - s) * 5 & 31;
    i += Du.charAt(o);
  }
  return i;
}
function cw(n, e) {
  if (e = e || 90, n.length < 8)
    return n + " too short";
  if (n.length > e)
    return "Exceeds length limit";
  var t = n.toLowerCase(), r = n.toUpperCase();
  if (n !== t && n !== r)
    return "Mixed-case string " + n;
  n = t;
  var i = n.lastIndexOf("1");
  if (i === -1)
    return "No separator character for " + n;
  if (i === 0)
    return "Missing prefix for " + n;
  var s = n.slice(0, i), a = n.slice(i + 1);
  if (a.length < 6)
    return "Data too short";
  var o = ow(s);
  if (typeof o == "string")
    return o;
  for (var c = [], l = 0; l < a.length; ++l) {
    var f = a.charAt(l), p = Fh[f];
    if (p === void 0)
      return "Unknown character " + f;
    o = Wa(o) ^ p, !(l + 6 >= a.length) && c.push(p);
  }
  return o !== 1 ? "Invalid checksum for " + n : { prefix: s, words: c };
}
function v_() {
  var n = cw.apply(null, arguments);
  if (typeof n == "object")
    return n;
}
function w_(n) {
  var e = cw.apply(null, arguments);
  if (typeof e == "object")
    return e;
  throw new Error(e);
}
function Pd(n, e, t, r) {
  for (var i = 0, s = 0, a = (1 << t) - 1, o = [], c = 0; c < n.length; ++c)
    for (i = i << e | n[c], s += e; s >= t; )
      s -= t, o.push(i >> s & a);
  if (r)
    s > 0 && o.push(i << t - s & a);
  else {
    if (s >= e)
      return "Excess padding";
    if (i << t - s & a)
      return "Non-zero padding";
  }
  return o;
}
function A_(n) {
  var e = Pd(n, 8, 5, !0);
  if (Array.isArray(e))
    return e;
}
function T_(n) {
  var e = Pd(n, 8, 5, !0);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
function C_(n) {
  var e = Pd(n, 5, 8, !1);
  if (Array.isArray(e))
    return e;
}
function E_(n) {
  var e = Pd(n, 5, 8, !1);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
var yb = {
  decodeUnsafe: v_,
  decode: w_,
  encode: x_,
  toWordsUnsafe: A_,
  toWords: T_,
  fromWordsUnsafe: C_,
  fromWords: E_
};
const ol = "providers/5.7.2", Bo = new O(ol);
class ee {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const e = {}, t = this.address.bind(this), r = this.bigNumber.bind(this), i = this.blockTag.bind(this), s = this.data.bind(this), a = this.hash.bind(this), o = this.hex.bind(this), c = this.number.bind(this), l = this.type.bind(this), f = (p) => this.data(p, !0);
    return e.transaction = {
      hash: a,
      type: l,
      accessList: ee.allowNull(this.accessList.bind(this), null),
      blockHash: ee.allowNull(a, null),
      blockNumber: ee.allowNull(c, null),
      transactionIndex: ee.allowNull(c, null),
      confirmations: ee.allowNull(c, null),
      from: t,
      gasPrice: ee.allowNull(r),
      maxPriorityFeePerGas: ee.allowNull(r),
      maxFeePerGas: ee.allowNull(r),
      gasLimit: r,
      to: ee.allowNull(t, null),
      value: r,
      nonce: c,
      data: s,
      r: ee.allowNull(this.uint256),
      s: ee.allowNull(this.uint256),
      v: ee.allowNull(c),
      creates: ee.allowNull(t, null),
      raw: ee.allowNull(s)
    }, e.transactionRequest = {
      from: ee.allowNull(t),
      nonce: ee.allowNull(c),
      gasLimit: ee.allowNull(r),
      gasPrice: ee.allowNull(r),
      maxPriorityFeePerGas: ee.allowNull(r),
      maxFeePerGas: ee.allowNull(r),
      to: ee.allowNull(t),
      value: ee.allowNull(r),
      data: ee.allowNull(f),
      type: ee.allowNull(c),
      accessList: ee.allowNull(this.accessList.bind(this), null)
    }, e.receiptLog = {
      transactionIndex: c,
      blockNumber: c,
      transactionHash: a,
      address: t,
      topics: ee.arrayOf(a),
      data: s,
      logIndex: c,
      blockHash: a
    }, e.receipt = {
      to: ee.allowNull(this.address, null),
      from: ee.allowNull(this.address, null),
      contractAddress: ee.allowNull(t, null),
      transactionIndex: c,
      root: ee.allowNull(o),
      gasUsed: r,
      logsBloom: ee.allowNull(s),
      blockHash: a,
      transactionHash: a,
      logs: ee.arrayOf(this.receiptLog.bind(this)),
      blockNumber: c,
      confirmations: ee.allowNull(c, null),
      cumulativeGasUsed: r,
      effectiveGasPrice: ee.allowNull(r),
      status: ee.allowNull(c),
      type: l
    }, e.block = {
      hash: ee.allowNull(a),
      parentHash: a,
      number: c,
      timestamp: c,
      nonce: ee.allowNull(o),
      difficulty: this.difficulty.bind(this),
      gasLimit: r,
      gasUsed: r,
      miner: ee.allowNull(t),
      extraData: s,
      transactions: ee.allowNull(ee.arrayOf(a)),
      baseFeePerGas: ee.allowNull(r)
    }, e.blockWithTransactions = $t(e.block), e.blockWithTransactions.transactions = ee.allowNull(ee.arrayOf(this.transactionResponse.bind(this))), e.filter = {
      fromBlock: ee.allowNull(i, void 0),
      toBlock: ee.allowNull(i, void 0),
      blockHash: ee.allowNull(a, void 0),
      address: ee.allowNull(t, void 0),
      topics: ee.allowNull(this.topics.bind(this), void 0)
    }, e.filterLog = {
      blockNumber: ee.allowNull(c),
      blockHash: ee.allowNull(a),
      transactionIndex: c,
      removed: ee.allowNull(this.boolean.bind(this)),
      address: t,
      data: ee.allowFalsish(s, "0x"),
      topics: ee.arrayOf(a),
      transactionHash: a,
      logIndex: c
    }, e;
  }
  accessList(e) {
    return Eo(e || []);
  }
  number(e) {
    return e === "0x" ? 0 : G.from(e).toNumber();
  }
  type(e) {
    return e === "0x" || e == null ? 0 : G.from(e).toNumber();
  }
  bigNumber(e) {
    return G.from(e);
  }
  boolean(e) {
    if (typeof e == "boolean")
      return e;
    if (typeof e == "string") {
      if (e = e.toLowerCase(), e === "true")
        return !0;
      if (e === "false")
        return !1;
    }
    throw new Error("invalid boolean - " + e);
  }
  hex(e, t) {
    return typeof e == "string" && (!t && e.substring(0, 2) !== "0x" && (e = "0x" + e), Pe(e)) ? e.toLowerCase() : Bo.throwArgumentError("invalid hash", "value", e);
  }
  data(e, t) {
    const r = this.hex(e, t);
    if (r.length % 2 !== 0)
      throw new Error("invalid data; odd-length - " + e);
    return r;
  }
  address(e) {
    return Rt(e);
  }
  callAddress(e) {
    if (!Pe(e, 32))
      return null;
    const t = Rt(an(e, 12));
    return t === tE ? null : t;
  }
  contractAddress(e) {
    return f2(e);
  }
  blockTag(e) {
    if (e == null)
      return "latest";
    if (e === "earliest")
      return "0x0";
    switch (e) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return e;
    }
    if (typeof e == "number" || Pe(e))
      return ap(e);
    throw new Error("invalid blockTag");
  }
  hash(e, t) {
    const r = this.hex(e, t);
    return ea(r) !== 32 ? Bo.throwArgumentError("invalid hash", "value", e) : r;
  }
  difficulty(e) {
    if (e == null)
      return null;
    const t = G.from(e);
    try {
      return t.toNumber();
    } catch {
    }
    return null;
  }
  uint256(e) {
    if (!Pe(e))
      throw new Error("invalid uint256");
    return Le(e, 32);
  }
  _block(e, t) {
    e.author != null && e.miner == null && (e.miner = e.author);
    const r = e._difficulty != null ? e._difficulty : e.difficulty, i = ee.check(t, e);
    return i._difficulty = r == null ? null : G.from(r), i;
  }
  block(e) {
    return this._block(e, this.formats.block);
  }
  blockWithTransactions(e) {
    return this._block(e, this.formats.blockWithTransactions);
  }
  transactionRequest(e) {
    return ee.check(this.formats.transactionRequest, e);
  }
  transactionResponse(e) {
    e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas), e.to && G.from(e.to).isZero() && (e.to = "0x0000000000000000000000000000000000000000"), e.input != null && e.data == null && (e.data = e.input), e.to == null && e.creates == null && (e.creates = this.contractAddress(e)), (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = []);
    const t = ee.check(this.formats.transaction, e);
    if (e.chainId != null) {
      let r = e.chainId;
      Pe(r) && (r = G.from(r).toNumber()), t.chainId = r;
    } else {
      let r = e.networkId;
      r == null && t.v == null && (r = e.chainId), Pe(r) && (r = G.from(r).toNumber()), typeof r != "number" && t.v != null && (r = (t.v - 35) / 2, r < 0 && (r = 0), r = parseInt(r)), typeof r != "number" && (r = 0), t.chainId = r;
    }
    return t.blockHash && t.blockHash.replace(/0/g, "") === "x" && (t.blockHash = null), t;
  }
  transaction(e) {
    return X7(e);
  }
  receiptLog(e) {
    return ee.check(this.formats.receiptLog, e);
  }
  receipt(e) {
    const t = ee.check(this.formats.receipt, e);
    if (t.root != null)
      if (t.root.length <= 4) {
        const r = G.from(t.root).toNumber();
        r === 0 || r === 1 ? (t.status != null && t.status !== r && Bo.throwArgumentError("alt-root-status/status mismatch", "value", { root: t.root, status: t.status }), t.status = r, delete t.root) : Bo.throwArgumentError("invalid alt-root-status", "value.root", t.root);
      } else
        t.root.length !== 66 && Bo.throwArgumentError("invalid root hash", "value.root", t.root);
    return t.status != null && (t.byzantium = !0), t;
  }
  topics(e) {
    return Array.isArray(e) ? e.map((t) => this.topics(t)) : e != null ? this.hash(e, !0) : null;
  }
  filter(e) {
    return ee.check(this.formats.filter, e);
  }
  filterLog(e) {
    return ee.check(this.formats.filterLog, e);
  }
  static check(e, t) {
    const r = {};
    for (const i in e)
      try {
        const s = e[i](t[i]);
        s !== void 0 && (r[i] = s);
      } catch (s) {
        throw s.checkKey = i, s.checkValue = t[i], s;
      }
    return r;
  }
  static allowNull(e, t) {
    return function(r) {
      return r == null ? t : e(r);
    };
  }
  static allowFalsish(e, t) {
    return function(r) {
      return r ? e(r) : t;
    };
  }
  static arrayOf(e) {
    return function(t) {
      if (!Array.isArray(t))
        throw new Error("not an array");
      const r = [];
      return t.forEach(function(i) {
        r.push(e(i));
      }), r;
    };
  }
}
var le = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const he = new O(ol), S_ = 10;
function gb(n) {
  return n == null ? "null" : (ea(n) !== 32 && he.throwArgumentError("invalid topic", "topic", n), n.toLowerCase());
}
function bb(n) {
  for (n = n.slice(); n.length > 0 && n[n.length - 1] == null; )
    n.pop();
  return n.map((e) => {
    if (Array.isArray(e)) {
      const t = {};
      e.forEach((i) => {
        t[gb(i)] = !0;
      });
      const r = Object.keys(t);
      return r.sort(), r.join("|");
    } else
      return gb(e);
  }).join("&");
}
function __(n) {
  return n === "" ? [] : n.split(/&/g).map((e) => {
    if (e === "")
      return [];
    const t = e.split("|").map((r) => r === "null" ? null : r);
    return t.length === 1 ? t[0] : t;
  });
}
function _a(n) {
  if (typeof n == "string") {
    if (n = n.toLowerCase(), ea(n) === 32)
      return "tx:" + n;
    if (n.indexOf(":") === -1)
      return n;
  } else {
    if (Array.isArray(n))
      return "filter:*:" + bb(n);
    if (nS.isForkEvent(n))
      throw he.warn("not implemented"), new Error("not implemented");
    if (n && typeof n == "object")
      return "filter:" + (n.address || "*") + ":" + bb(n.topics || []);
  }
  throw new Error("invalid event - " + n);
}
function $o() {
  return new Date().getTime();
}
function xb(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
const P_ = ["block", "network", "pending", "poll"];
class M_ {
  constructor(e, t, r) {
    H(this, "tag", e), H(this, "listener", t), H(this, "once", r), this._lastBlockNumber = -2, this._inflight = !1;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const e = this.tag.split(":");
    return e[0] !== "tx" ? null : e[1];
  }
  get filter() {
    const e = this.tag.split(":");
    if (e[0] !== "filter")
      return null;
    const t = e[1], r = __(e[2]), i = {};
    return r.length > 0 && (i.topics = r), t && t !== "*" && (i.address = t), i;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || P_.indexOf(this.tag) >= 0;
  }
}
const R_ = {
  0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
  60: { symbol: "eth", ilk: "eth" },
  61: { symbol: "etc", ilk: "eth" },
  700: { symbol: "xdai", ilk: "eth" }
};
function Vf(n) {
  return Le(G.from(n).toHexString(), 32);
}
function vb(n) {
  return Lh.encode(zn([n, an(pb(pb(n)), 0, 4)]));
}
const lw = new RegExp("^(ipfs)://(.*)$", "i"), wb = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  lw,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function ru(n, e) {
  try {
    return sl(_c(n, e));
  } catch {
  }
  return null;
}
function _c(n, e) {
  if (n === "0x")
    return null;
  const t = G.from(an(n, e, e + 32)).toNumber(), r = G.from(an(n, t, t + 32)).toNumber();
  return an(n, t + 32, t + 32 + r);
}
function jf(n) {
  return n.match(/^ipfs:\/\/ipfs\//i) ? n = n.substring(12) : n.match(/^ipfs:\/\//i) ? n = n.substring(7) : he.throwArgumentError("unsupported IPFS format", "link", n), `https://gateway.ipfs.io/ipfs/${n}`;
}
function Ab(n) {
  const e = ae(n);
  if (e.length > 32)
    throw new Error("internal; should not happen");
  const t = new Uint8Array(32);
  return t.set(e, 32 - e.length), t;
}
function k_(n) {
  if (n.length % 32 === 0)
    return n;
  const e = new Uint8Array(Math.ceil(n.length / 32) * 32);
  return e.set(n), e;
}
function uw(n) {
  const e = [];
  let t = 0;
  for (let r = 0; r < n.length; r++)
    e.push(null), t += 32;
  for (let r = 0; r < n.length; r++) {
    const i = ae(n[r]);
    e[r] = Ab(t), e.push(Ab(i.length)), e.push(k_(i)), t += 32 + Math.ceil(i.length / 32) * 32;
  }
  return Pn(e);
}
class Tb {
  constructor(e, t, r, i) {
    H(this, "provider", e), H(this, "name", r), H(this, "address", e.formatter.address(t)), H(this, "_resolvedAddress", i);
  }
  supportsWildcard() {
    return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
      to: this.address,
      data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
    }).then((e) => G.from(e).eq(1)).catch((e) => {
      if (e.code === O.errors.CALL_EXCEPTION)
        return !1;
      throw this._supportsEip2544 = null, e;
    })), this._supportsEip2544;
  }
  _fetch(e, t) {
    return le(this, void 0, void 0, function* () {
      const r = {
        to: this.address,
        ccipReadEnabled: !0,
        data: Pn([e, Zl(this.name), t || "0x"])
      };
      let i = !1;
      (yield this.supportsWildcard()) && (i = !0, r.data = Pn(["0x9061b923", uw([VE(this.name), r.data])]));
      try {
        let s = yield this.provider.call(r);
        return ae(s).length % 32 === 4 && he.throwError("resolver threw error", O.errors.CALL_EXCEPTION, {
          transaction: r,
          data: s
        }), i && (s = _c(s, 0)), s;
      } catch (s) {
        if (s.code === O.errors.CALL_EXCEPTION)
          return null;
        throw s;
      }
    });
  }
  _fetchBytes(e, t) {
    return le(this, void 0, void 0, function* () {
      const r = yield this._fetch(e, t);
      return r != null ? _c(r, 0) : null;
    });
  }
  _getAddress(e, t) {
    const r = R_[String(e)];
    if (r == null && he.throwError(`unsupported coin type: ${e}`, O.errors.UNSUPPORTED_OPERATION, {
      operation: `getAddress(${e})`
    }), r.ilk === "eth")
      return this.provider.formatter.address(t);
    const i = ae(t);
    if (r.p2pkh != null) {
      const s = t.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75)
          return vb(zn([[r.p2pkh], "0x" + s[2]]));
      }
    }
    if (r.p2sh != null) {
      const s = t.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75)
          return vb(zn([[r.p2sh], "0x" + s[2]]));
      }
    }
    if (r.prefix != null) {
      const s = i[1];
      let a = i[0];
      if (a === 0 ? s !== 20 && s !== 32 && (a = -1) : a = -1, a >= 0 && i.length === 2 + s && s >= 1 && s <= 75) {
        const o = yb.toWords(i.slice(2));
        return o.unshift(a), yb.encode(r.prefix, o);
      }
    }
    return null;
  }
  getAddress(e) {
    return le(this, void 0, void 0, function* () {
      if (e == null && (e = 60), e === 60)
        try {
          const i = yield this._fetch("0x3b3b57de");
          return i === "0x" || i === sE ? null : this.provider.formatter.callAddress(i);
        } catch (i) {
          if (i.code === O.errors.CALL_EXCEPTION)
            return null;
          throw i;
        }
      const t = yield this._fetchBytes("0xf1cb7e06", Vf(e));
      if (t == null || t === "0x")
        return null;
      const r = this._getAddress(e, t);
      return r == null && he.throwError("invalid or unsupported coin data", O.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${e})`,
        coinType: e,
        data: t
      }), r;
    });
  }
  getAvatar() {
    return le(this, void 0, void 0, function* () {
      const e = [{ type: "name", content: this.name }];
      try {
        const t = yield this.getText("avatar");
        if (t == null)
          return null;
        for (let r = 0; r < wb.length; r++) {
          const i = t.match(wb[r]);
          if (i == null)
            continue;
          const s = i[1].toLowerCase();
          switch (s) {
            case "https":
              return e.push({ type: "url", content: t }), { linkage: e, url: t };
            case "data":
              return e.push({ type: "data", content: t }), { linkage: e, url: t };
            case "ipfs":
              return e.push({ type: "ipfs", content: t }), { linkage: e, url: jf(t) };
            case "erc721":
            case "erc1155": {
              const a = s === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              e.push({ type: s, content: t });
              const o = this._resolvedAddress || (yield this.getAddress()), c = (i[2] || "").split("/");
              if (c.length !== 2)
                return null;
              const l = yield this.provider.formatter.address(c[0]), f = Le(G.from(c[1]).toHexString(), 32);
              if (s === "erc721") {
                const w = this.provider.formatter.callAddress(yield this.provider.call({
                  to: l,
                  data: Pn(["0x6352211e", f])
                }));
                if (o !== w)
                  return null;
                e.push({ type: "owner", content: w });
              } else if (s === "erc1155") {
                const w = G.from(yield this.provider.call({
                  to: l,
                  data: Pn(["0x00fdd58e", Le(o, 32), f])
                }));
                if (w.isZero())
                  return null;
                e.push({ type: "balance", content: w.toString() });
              }
              const p = {
                to: this.provider.formatter.address(c[0]),
                data: Pn([a, f])
              };
              let g = ru(yield this.provider.call(p), 0);
              if (g == null)
                return null;
              e.push({ type: "metadata-url-base", content: g }), s === "erc1155" && (g = g.replace("{id}", f.substring(2)), e.push({ type: "metadata-url-expanded", content: g })), g.match(/^ipfs:/i) && (g = jf(g)), e.push({ type: "metadata-url", content: g });
              const T = yield gp(g);
              if (!T)
                return null;
              e.push({ type: "metadata", content: JSON.stringify(T) });
              let v = T.image;
              if (typeof v != "string")
                return null;
              if (!v.match(/^(https:\/\/|data:)/i)) {
                if (v.match(lw) == null)
                  return null;
                e.push({ type: "url-ipfs", content: v }), v = jf(v);
              }
              return e.push({ type: "url", content: v }), { linkage: e, url: v };
            }
          }
        }
      } catch {
      }
      return null;
    });
  }
  getContentHash() {
    return le(this, void 0, void 0, function* () {
      const e = yield this._fetchBytes("0xbc1c58d1");
      if (e == null || e === "0x")
        return null;
      const t = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (t) {
        const a = parseInt(t[3], 16);
        if (t[4].length === a * 2)
          return "ipfs://" + Lh.encode("0x" + t[1]);
      }
      const r = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (r) {
        const a = parseInt(r[3], 16);
        if (r[4].length === a * 2)
          return "ipns://" + Lh.encode("0x" + r[1]);
      }
      const i = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (i && i[1].length === 32 * 2)
        return "bzz://" + i[1];
      const s = e.match(/^0x90b2c605([0-9a-f]*)$/);
      if (s && s[1].length === 34 * 2) {
        const a = { "=": "", "+": "-", "/": "_" };
        return "sia://" + w2("0x" + s[1]).replace(/[=+\/]/g, (c) => a[c]);
      }
      return he.throwError("invalid or unsupported content hash data", O.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: e
      });
    });
  }
  getText(e) {
    return le(this, void 0, void 0, function* () {
      let t = Pr(e);
      t = zn([Vf(64), Vf(t.length), t]), t.length % 32 !== 0 && (t = zn([t, Le("0x", 32 - e.length % 32)]));
      const r = yield this._fetchBytes("0x59d1d43c", te(t));
      return r == null || r === "0x" ? null : sl(r);
    });
  }
}
let Gf = null, I_ = 1;
class O_ extends Td {
  constructor(e) {
    if (super(), this._events = [], this._emitted = { block: -2 }, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), H(this, "anyNetwork", e === "any"), this.anyNetwork && (e = this.detectNetwork()), e instanceof Promise)
      this._networkPromise = e, e.catch((t) => {
      }), this._ready().catch((t) => {
      });
    else {
      const t = jr(new.target, "getNetwork")(e);
      t ? (H(this, "_network", t), this.emit("network", t, null)) : he.throwArgumentError("invalid network", "network", e);
    }
    this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0;
  }
  _ready() {
    return le(this, void 0, void 0, function* () {
      if (this._network == null) {
        let e = null;
        if (this._networkPromise)
          try {
            e = yield this._networkPromise;
          } catch {
          }
        e == null && (e = yield this.detectNetwork()), e || he.throwError("no network detected", O.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = e : H(this, "_network", e), this.emit("network", e, null));
      }
      return this._network;
    });
  }
  get ready() {
    return zo(() => this._ready().then((e) => e, (e) => {
      if (!(e.code === O.errors.NETWORK_ERROR && e.event === "noNetwork"))
        throw e;
    }));
  }
  static getFormatter() {
    return Gf == null && (Gf = new ee()), Gf;
  }
  static getNetwork(e) {
    return sw(e ?? "homestead");
  }
  ccipReadFetch(e, t, r) {
    return le(this, void 0, void 0, function* () {
      if (this.disableCcipRead || r.length === 0)
        return null;
      const i = e.to.toLowerCase(), s = t.toLowerCase(), a = [];
      for (let o = 0; o < r.length; o++) {
        const c = r[o], l = c.replace("{sender}", i).replace("{data}", s), f = c.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: s, sender: i }), p = yield gp({ url: l, errorPassThrough: !0 }, f, (T, v) => (T.status = v.statusCode, T));
        if (p.data)
          return p.data;
        const g = p.message || "unknown error";
        if (p.status >= 400 && p.status < 500)
          return he.throwError(`response not found during CCIP fetch: ${g}`, O.errors.SERVER_ERROR, { url: c, errorMessage: g });
        a.push(g);
      }
      return he.throwError(`error encountered during CCIP fetch: ${a.map((o) => JSON.stringify(o)).join(", ")}`, O.errors.SERVER_ERROR, {
        urls: r,
        errorMessages: a
      });
    });
  }
  _getInternalBlockNumber(e) {
    return le(this, void 0, void 0, function* () {
      if (yield this._ready(), e > 0)
        for (; this._internalBlockNumber; ) {
          const i = this._internalBlockNumber;
          try {
            const s = yield i;
            if ($o() - s.respTime <= e)
              return s.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === i)
              break;
          }
        }
      const t = $o(), r = It({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((i) => null, (i) => i)
      }).then(({ blockNumber: i, networkError: s }) => {
        if (s)
          throw this._internalBlockNumber === r && (this._internalBlockNumber = null), s;
        const a = $o();
        return i = G.from(i).toNumber(), i < this._maxInternalBlockNumber && (i = this._maxInternalBlockNumber), this._maxInternalBlockNumber = i, this._setFastBlockNumber(i), { blockNumber: i, reqTime: t, respTime: a };
      });
      return this._internalBlockNumber = r, r.catch((i) => {
        this._internalBlockNumber === r && (this._internalBlockNumber = null);
      }), (yield r).blockNumber;
    });
  }
  poll() {
    return le(this, void 0, void 0, function* () {
      const e = I_++, t = [];
      let r = null;
      try {
        r = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (i) {
        this.emit("error", i);
        return;
      }
      if (this._setFastBlockNumber(r), this.emit("poll", e, r), r === this._lastBlockNumber) {
        this.emit("didPoll", e);
        return;
      }
      if (this._emitted.block === -2 && (this._emitted.block = r - 1), Math.abs(this._emitted.block - r) > 1e3)
        he.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${r})`), this.emit("error", he.makeError("network block skew detected", O.errors.NETWORK_ERROR, {
          blockNumber: r,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        })), this.emit("block", r);
      else
        for (let i = this._emitted.block + 1; i <= r; i++)
          this.emit("block", i);
      this._emitted.block !== r && (this._emitted.block = r, Object.keys(this._emitted).forEach((i) => {
        if (i === "block")
          return;
        const s = this._emitted[i];
        s !== "pending" && r - s > 12 && delete this._emitted[i];
      })), this._lastBlockNumber === -2 && (this._lastBlockNumber = r - 1), this._events.forEach((i) => {
        switch (i.type) {
          case "tx": {
            const s = i.hash;
            let a = this.getTransactionReceipt(s).then((o) => (!o || o.blockNumber == null || (this._emitted["t:" + s] = o.blockNumber, this.emit(s, o)), null)).catch((o) => {
              this.emit("error", o);
            });
            t.push(a);
            break;
          }
          case "filter": {
            if (!i._inflight) {
              i._inflight = !0, i._lastBlockNumber === -2 && (i._lastBlockNumber = r - 1);
              const s = i.filter;
              s.fromBlock = i._lastBlockNumber + 1, s.toBlock = r;
              const a = s.toBlock - this._maxFilterBlockRange;
              a > s.fromBlock && (s.fromBlock = a), s.fromBlock < 0 && (s.fromBlock = 0);
              const o = this.getLogs(s).then((c) => {
                i._inflight = !1, c.length !== 0 && c.forEach((l) => {
                  l.blockNumber > i._lastBlockNumber && (i._lastBlockNumber = l.blockNumber), this._emitted["b:" + l.blockHash] = l.blockNumber, this._emitted["t:" + l.transactionHash] = l.blockNumber, this.emit(s, l);
                });
              }).catch((c) => {
                this.emit("error", c), i._inflight = !1;
              });
              t.push(o);
            }
            break;
          }
        }
      }), this._lastBlockNumber = r, Promise.all(t).then(() => {
        this.emit("didPoll", e);
      }).catch((i) => {
        this.emit("error", i);
      });
    });
  }
  resetEventsBlock(e) {
    this._lastBlockNumber = e - 1, this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  detectNetwork() {
    return le(this, void 0, void 0, function* () {
      return he.throwError("provider does not support network detection", O.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return le(this, void 0, void 0, function* () {
      const e = yield this._ready(), t = yield this.detectNetwork();
      if (e.chainId !== t.chainId) {
        if (this.anyNetwork)
          return this._network = t, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", t, e), yield xb(0), this._network;
        const r = he.makeError("underlying network changed", O.errors.NETWORK_ERROR, {
          event: "changed",
          network: e,
          detectedNetwork: t
        });
        throw this.emit("error", r), r;
      }
      return e;
    });
  }
  get blockNumber() {
    return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((e) => {
      this._setFastBlockNumber(e);
    }, (e) => {
    }), this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(e) {
    e && !this._poller ? (this._poller = setInterval(() => {
      this.poll();
    }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
      this.poll(), this._bootstrapPoll = setTimeout(() => {
        this._poller || this.poll(), this._bootstrapPoll = null;
      }, this.pollingInterval);
    }, 0))) : !e && this._poller && (clearInterval(this._poller), this._poller = null);
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(e) {
    if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e)
      throw new Error("invalid polling interval");
    this._pollingInterval = e, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
      this.poll();
    }, this._pollingInterval));
  }
  _getFastBlockNumber() {
    const e = $o();
    return e - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = e, this._fastBlockNumberPromise = this.getBlockNumber().then((t) => ((this._fastBlockNumber == null || t > this._fastBlockNumber) && (this._fastBlockNumber = t), this._fastBlockNumber))), this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(e) {
    this._fastBlockNumber != null && e < this._fastBlockNumber || (this._fastQueryDate = $o(), (this._fastBlockNumber == null || e > this._fastBlockNumber) && (this._fastBlockNumber = e, this._fastBlockNumberPromise = Promise.resolve(e)));
  }
  waitForTransaction(e, t, r) {
    return le(this, void 0, void 0, function* () {
      return this._waitForTransaction(e, t ?? 1, r || 0, null);
    });
  }
  _waitForTransaction(e, t, r, i) {
    return le(this, void 0, void 0, function* () {
      const s = yield this.getTransactionReceipt(e);
      return (s ? s.confirmations : 0) >= t ? s : new Promise((a, o) => {
        const c = [];
        let l = !1;
        const f = function() {
          return l ? !0 : (l = !0, c.forEach((g) => {
            g();
          }), !1);
        }, p = (g) => {
          g.confirmations < t || f() || a(g);
        };
        if (this.on(e, p), c.push(() => {
          this.removeListener(e, p);
        }), i) {
          let g = i.startBlock, T = null;
          const v = (w) => le(this, void 0, void 0, function* () {
            l || (yield xb(1e3), this.getTransactionCount(i.from).then((C) => le(this, void 0, void 0, function* () {
              if (!l) {
                if (C <= i.nonce)
                  g = w;
                else {
                  {
                    const _ = yield this.getTransaction(e);
                    if (_ && _.blockNumber != null)
                      return;
                  }
                  for (T == null && (T = g - 3, T < i.startBlock && (T = i.startBlock)); T <= w; ) {
                    if (l)
                      return;
                    const _ = yield this.getBlockWithTransactions(T);
                    for (let I = 0; I < _.transactions.length; I++) {
                      const B = _.transactions[I];
                      if (B.hash === e)
                        return;
                      if (B.from === i.from && B.nonce === i.nonce) {
                        if (l)
                          return;
                        const N = yield this.waitForTransaction(B.hash, t);
                        if (f())
                          return;
                        let D = "replaced";
                        B.data === i.data && B.to === i.to && B.value.eq(i.value) ? D = "repriced" : B.data === "0x" && B.from === B.to && B.value.isZero() && (D = "cancelled"), o(he.makeError("transaction was replaced", O.errors.TRANSACTION_REPLACED, {
                          cancelled: D === "replaced" || D === "cancelled",
                          reason: D,
                          replacement: this._wrapTransaction(B),
                          hash: e,
                          receipt: N
                        }));
                        return;
                      }
                    }
                    T++;
                  }
                }
                l || this.once("block", v);
              }
            }), (C) => {
              l || this.once("block", v);
            }));
          });
          if (l)
            return;
          this.once("block", v), c.push(() => {
            this.removeListener("block", v);
          });
        }
        if (typeof r == "number" && r > 0) {
          const g = setTimeout(() => {
            f() || o(he.makeError("timeout exceeded", O.errors.TIMEOUT, { timeout: r }));
          }, r);
          g.unref && g.unref(), c.push(() => {
            clearTimeout(g);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return le(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const e = yield this.perform("getGasPrice", {});
      try {
        return G.from(e);
      } catch (t) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result: e,
          error: t
        });
      }
    });
  }
  getBalance(e, t) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield It({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(t)
      }), i = yield this.perform("getBalance", r);
      try {
        return G.from(i);
      } catch (s) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "getBalance",
          params: r,
          result: i,
          error: s
        });
      }
    });
  }
  getTransactionCount(e, t) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield It({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(t)
      }), i = yield this.perform("getTransactionCount", r);
      try {
        return G.from(i).toNumber();
      } catch (s) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params: r,
          result: i,
          error: s
        });
      }
    });
  }
  getCode(e, t) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield It({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(t)
      }), i = yield this.perform("getCode", r);
      try {
        return te(i);
      } catch (s) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "getCode",
          params: r,
          result: i,
          error: s
        });
      }
    });
  }
  getStorageAt(e, t, r) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield It({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(r),
        position: Promise.resolve(t).then((a) => ap(a))
      }), s = yield this.perform("getStorageAt", i);
      try {
        return te(s);
      } catch (a) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params: i,
          result: s,
          error: a
        });
      }
    });
  }
  _wrapTransaction(e, t, r) {
    if (t != null && ea(t) !== 32)
      throw new Error("invalid response - sendTransaction");
    const i = e;
    return t != null && e.hash !== t && he.throwError("Transaction hash mismatch from Provider.sendTransaction.", O.errors.UNKNOWN_ERROR, { expectedHash: e.hash, returnedHash: t }), i.wait = (s, a) => le(this, void 0, void 0, function* () {
      s == null && (s = 1), a == null && (a = 0);
      let o;
      s !== 0 && r != null && (o = {
        data: e.data,
        from: e.from,
        nonce: e.nonce,
        to: e.to,
        value: e.value,
        startBlock: r
      });
      const c = yield this._waitForTransaction(e.hash, s, a, o);
      return c == null && s === 0 ? null : (this._emitted["t:" + e.hash] = c.blockNumber, c.status === 0 && he.throwError("transaction failed", O.errors.CALL_EXCEPTION, {
        transactionHash: e.hash,
        transaction: e,
        receipt: c
      }), c);
    }), i;
  }
  sendTransaction(e) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Promise.resolve(e).then((s) => te(s)), r = this.formatter.transaction(e);
      r.confirmations == null && (r.confirmations = 0);
      const i = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const s = yield this.perform("sendTransaction", { signedTransaction: t });
        return this._wrapTransaction(r, s, i);
      } catch (s) {
        throw s.transaction = r, s.transactionHash = r.hash, s;
      }
    });
  }
  _getTransactionRequest(e) {
    return le(this, void 0, void 0, function* () {
      const t = yield e, r = {};
      return ["from", "to"].forEach((i) => {
        t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => s ? this._getAddress(s) : null));
      }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((i) => {
        t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => s ? G.from(s) : null));
      }), ["type"].forEach((i) => {
        t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => s ?? null));
      }), t.accessList && (r.accessList = this.formatter.accessList(t.accessList)), ["data"].forEach((i) => {
        t[i] != null && (r[i] = Promise.resolve(t[i]).then((s) => s ? te(s) : null));
      }), this.formatter.transactionRequest(yield It(r));
    });
  }
  _getFilter(e) {
    return le(this, void 0, void 0, function* () {
      e = yield e;
      const t = {};
      return e.address != null && (t.address = this._getAddress(e.address)), ["blockHash", "topics"].forEach((r) => {
        e[r] != null && (t[r] = e[r]);
      }), ["fromBlock", "toBlock"].forEach((r) => {
        e[r] != null && (t[r] = this._getBlockTag(e[r]));
      }), this.formatter.filter(yield It(t));
    });
  }
  _call(e, t, r) {
    return le(this, void 0, void 0, function* () {
      r >= S_ && he.throwError("CCIP read exceeded maximum redirections", O.errors.SERVER_ERROR, {
        redirects: r,
        transaction: e
      });
      const i = e.to, s = yield this.perform("call", { transaction: e, blockTag: t });
      if (r >= 0 && t === "latest" && i != null && s.substring(0, 10) === "0x556f1830" && ea(s) % 32 === 4)
        try {
          const a = an(s, 4), o = an(a, 0, 32);
          G.from(o).eq(i) || he.throwError("CCIP Read sender did not match", O.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const c = [], l = G.from(an(a, 32, 64)).toNumber(), f = G.from(an(a, l, l + 32)).toNumber(), p = an(a, l + 32);
          for (let _ = 0; _ < f; _++) {
            const I = ru(p, _ * 32);
            I == null && he.throwError("CCIP Read contained corrupt URL string", O.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: e,
              data: s
            }), c.push(I);
          }
          const g = _c(a, 64);
          G.from(an(a, 100, 128)).isZero() || he.throwError("CCIP Read callback selector included junk", O.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const T = an(a, 96, 100), v = _c(a, 128), w = yield this.ccipReadFetch(e, g, c);
          w == null && he.throwError("CCIP Read disabled or provided no URLs", O.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const C = {
            to: i,
            data: Pn([T, uw([w, v])])
          };
          return this._call(C, t, r + 1);
        } catch (a) {
          if (a.code === O.errors.SERVER_ERROR)
            throw a;
        }
      try {
        return te(s);
      } catch (a) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction: e, blockTag: t },
          result: s,
          error: a
        });
      }
    });
  }
  call(e, t) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield It({
        transaction: this._getTransactionRequest(e),
        blockTag: this._getBlockTag(t),
        ccipReadEnabled: Promise.resolve(e.ccipReadEnabled)
      });
      return this._call(r.transaction, r.blockTag, r.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(e) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield It({
        transaction: this._getTransactionRequest(e)
      }), r = yield this.perform("estimateGas", t);
      try {
        return G.from(r);
      } catch (i) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "estimateGas",
          params: t,
          result: r,
          error: i
        });
      }
    });
  }
  _getAddress(e) {
    return le(this, void 0, void 0, function* () {
      e = yield e, typeof e != "string" && he.throwArgumentError("invalid address or ENS name", "name", e);
      const t = yield this.resolveName(e);
      return t == null && he.throwError("ENS name not configured", O.errors.UNSUPPORTED_OPERATION, {
        operation: `resolveName(${JSON.stringify(e)})`
      }), t;
    });
  }
  _getBlock(e, t) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork(), e = yield e;
      let r = -128;
      const i = {
        includeTransactions: !!t
      };
      if (Pe(e, 32))
        i.blockHash = e;
      else
        try {
          i.blockTag = yield this._getBlockTag(e), Pe(i.blockTag) && (r = parseInt(i.blockTag.substring(2), 16));
        } catch {
          he.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", e);
        }
      return zo(() => le(this, void 0, void 0, function* () {
        const s = yield this.perform("getBlock", i);
        if (s == null)
          return i.blockHash != null && this._emitted["b:" + i.blockHash] == null || i.blockTag != null && r > this._emitted.block ? null : void 0;
        if (t) {
          let a = null;
          for (let c = 0; c < s.transactions.length; c++) {
            const l = s.transactions[c];
            if (l.blockNumber == null)
              l.confirmations = 0;
            else if (l.confirmations == null) {
              a == null && (a = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
              let f = a - l.blockNumber + 1;
              f <= 0 && (f = 1), l.confirmations = f;
            }
          }
          const o = this.formatter.blockWithTransactions(s);
          return o.transactions = o.transactions.map((c) => this._wrapTransaction(c)), o;
        }
        return this.formatter.block(s);
      }), { oncePoll: this });
    });
  }
  getBlock(e) {
    return this._getBlock(e, !1);
  }
  getBlockWithTransactions(e) {
    return this._getBlock(e, !0);
  }
  getTransaction(e) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork(), e = yield e;
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return zo(() => le(this, void 0, void 0, function* () {
        const r = yield this.perform("getTransaction", t);
        if (r == null)
          return this._emitted["t:" + e] == null ? null : void 0;
        const i = this.formatter.transactionResponse(r);
        if (i.blockNumber == null)
          i.confirmations = 0;
        else if (i.confirmations == null) {
          let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
          a <= 0 && (a = 1), i.confirmations = a;
        }
        return this._wrapTransaction(i);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(e) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork(), e = yield e;
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return zo(() => le(this, void 0, void 0, function* () {
        const r = yield this.perform("getTransactionReceipt", t);
        if (r == null)
          return this._emitted["t:" + e] == null ? null : void 0;
        if (r.blockHash == null)
          return;
        const i = this.formatter.receipt(r);
        if (i.blockNumber == null)
          i.confirmations = 0;
        else if (i.confirmations == null) {
          let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - i.blockNumber + 1;
          a <= 0 && (a = 1), i.confirmations = a;
        }
        return i;
      }), { oncePoll: this });
    });
  }
  getLogs(e) {
    return le(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield It({ filter: this._getFilter(e) }), r = yield this.perform("getLogs", t);
      return r.forEach((i) => {
        i.removed == null && (i.removed = !1);
      }), ee.arrayOf(this.formatter.filterLog.bind(this.formatter))(r);
    });
  }
  getEtherPrice() {
    return le(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(e) {
    return le(this, void 0, void 0, function* () {
      if (e = yield e, typeof e == "number" && e < 0) {
        e % 1 && he.throwArgumentError("invalid BlockTag", "blockTag", e);
        let t = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        return t += e, t < 0 && (t = 0), this.formatter.blockTag(t);
      }
      return this.formatter.blockTag(e);
    });
  }
  getResolver(e) {
    return le(this, void 0, void 0, function* () {
      let t = e;
      for (; ; ) {
        if (t === "" || t === "." || e !== "eth" && t === "eth")
          return null;
        const r = yield this._getResolver(t, "getResolver");
        if (r != null) {
          const i = new Tb(this, r, e);
          return t !== e && !(yield i.supportsWildcard()) ? null : i;
        }
        t = t.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(e, t) {
    return le(this, void 0, void 0, function* () {
      t == null && (t = "ENS");
      const r = yield this.getNetwork();
      r.ensAddress || he.throwError("network does not support ENS", O.errors.UNSUPPORTED_OPERATION, { operation: t, network: r.name });
      try {
        const i = yield this.call({
          to: r.ensAddress,
          data: "0x0178b8bf" + Zl(e).substring(2)
        });
        return this.formatter.callAddress(i);
      } catch {
      }
      return null;
    });
  }
  resolveName(e) {
    return le(this, void 0, void 0, function* () {
      e = yield e;
      try {
        return Promise.resolve(this.formatter.address(e));
      } catch (r) {
        if (Pe(e))
          throw r;
      }
      typeof e != "string" && he.throwArgumentError("invalid ENS name", "name", e);
      const t = yield this.getResolver(e);
      return t ? yield t.getAddress() : null;
    });
  }
  lookupAddress(e) {
    return le(this, void 0, void 0, function* () {
      e = yield e, e = this.formatter.address(e);
      const t = e.substring(2).toLowerCase() + ".addr.reverse", r = yield this._getResolver(t, "lookupAddress");
      if (r == null)
        return null;
      const i = ru(yield this.call({
        to: r,
        data: "0x691f3431" + Zl(t).substring(2)
      }), 0);
      return (yield this.resolveName(i)) != e ? null : i;
    });
  }
  getAvatar(e) {
    return le(this, void 0, void 0, function* () {
      let t = null;
      if (Pe(e)) {
        const s = this.formatter.address(e).substring(2).toLowerCase() + ".addr.reverse", a = yield this._getResolver(s, "getAvatar");
        if (!a)
          return null;
        t = new Tb(this, a, s);
        try {
          const o = yield t.getAvatar();
          if (o)
            return o.url;
        } catch (o) {
          if (o.code !== O.errors.CALL_EXCEPTION)
            throw o;
        }
        try {
          const o = ru(yield this.call({
            to: a,
            data: "0x691f3431" + Zl(s).substring(2)
          }), 0);
          t = yield this.getResolver(o);
        } catch (o) {
          if (o.code !== O.errors.CALL_EXCEPTION)
            throw o;
          return null;
        }
      } else if (t = yield this.getResolver(e), !t)
        return null;
      const r = yield t.getAvatar();
      return r == null ? null : r.url;
    });
  }
  perform(e, t) {
    return he.throwError(e + " not implemented", O.errors.NOT_IMPLEMENTED, { operation: e });
  }
  _startEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _stopEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _addEventListener(e, t, r) {
    const i = new M_(_a(e), t, r);
    return this._events.push(i), this._startEvent(i), this;
  }
  on(e, t) {
    return this._addEventListener(e, t, !1);
  }
  once(e, t) {
    return this._addEventListener(e, t, !0);
  }
  emit(e, ...t) {
    let r = !1, i = [], s = _a(e);
    return this._events = this._events.filter((a) => a.tag !== s ? !0 : (setTimeout(() => {
      a.listener.apply(this, t);
    }, 0), r = !0, a.once ? (i.push(a), !1) : !0)), i.forEach((a) => {
      this._stopEvent(a);
    }), r;
  }
  listenerCount(e) {
    if (!e)
      return this._events.length;
    let t = _a(e);
    return this._events.filter((r) => r.tag === t).length;
  }
  listeners(e) {
    if (e == null)
      return this._events.map((r) => r.listener);
    let t = _a(e);
    return this._events.filter((r) => r.tag === t).map((r) => r.listener);
  }
  off(e, t) {
    if (t == null)
      return this.removeAllListeners(e);
    const r = [];
    let i = !1, s = _a(e);
    return this._events = this._events.filter((a) => a.tag !== s || a.listener != t || i ? !0 : (i = !0, r.push(a), !1)), r.forEach((a) => {
      this._stopEvent(a);
    }), this;
  }
  removeAllListeners(e) {
    let t = [];
    if (e == null)
      t = this._events, this._events = [];
    else {
      const r = _a(e);
      this._events = this._events.filter((i) => i.tag !== r ? !0 : (t.push(i), !1));
    }
    return t.forEach((r) => {
      this._stopEvent(r);
    }), this;
  }
}
var ci = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const Ot = new O(ol), D_ = ["call", "estimateGas"];
function sc(n, e) {
  if (n == null)
    return null;
  if (typeof n.message == "string" && n.message.match("reverted")) {
    const t = Pe(n.data) ? n.data : null;
    if (!e || t)
      return { message: n.message, data: t };
  }
  if (typeof n == "object") {
    for (const t in n) {
      const r = sc(n[t], e);
      if (r)
        return r;
    }
    return null;
  }
  if (typeof n == "string")
    try {
      return sc(JSON.parse(n), e);
    } catch {
    }
  return null;
}
function dw(n, e, t) {
  const r = t.transaction || t.signedTransaction;
  if (n === "call") {
    const s = sc(e, !0);
    if (s)
      return s.data;
    Ot.throwError("missing revert data in call exception; Transaction reverted without a reason string", O.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction: r,
      error: e
    });
  }
  if (n === "estimateGas") {
    let s = sc(e.body, !1);
    s == null && (s = sc(e, !1)), s && Ot.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", O.errors.UNPREDICTABLE_GAS_LIMIT, {
      reason: s.message,
      method: n,
      transaction: r,
      error: e
    });
  }
  let i = e.message;
  throw e.code === O.errors.SERVER_ERROR && e.error && typeof e.error.message == "string" ? i = e.error.message : typeof e.body == "string" ? i = e.body : typeof e.responseText == "string" && (i = e.responseText), i = (i || "").toLowerCase(), i.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && Ot.throwError("insufficient funds for intrinsic transaction cost", O.errors.INSUFFICIENT_FUNDS, {
    error: e,
    method: n,
    transaction: r
  }), i.match(/nonce (is )?too low/i) && Ot.throwError("nonce has already been used", O.errors.NONCE_EXPIRED, {
    error: e,
    method: n,
    transaction: r
  }), i.match(/replacement transaction underpriced|transaction gas price.*too low/i) && Ot.throwError("replacement fee too low", O.errors.REPLACEMENT_UNDERPRICED, {
    error: e,
    method: n,
    transaction: r
  }), i.match(/only replay-protected/i) && Ot.throwError("legacy pre-eip-155 transactions not supported", O.errors.UNSUPPORTED_OPERATION, {
    error: e,
    method: n,
    transaction: r
  }), D_.indexOf(n) >= 0 && i.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && Ot.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", O.errors.UNPREDICTABLE_GAS_LIMIT, {
    error: e,
    method: n,
    transaction: r
  }), e;
}
function Cb(n) {
  return new Promise(function(e) {
    setTimeout(e, n);
  });
}
function N_(n) {
  if (n.error) {
    const e = new Error(n.error.message);
    throw e.code = n.error.code, e.data = n.error.data, e;
  }
  return n.result;
}
function Lo(n) {
  return n && n.toLowerCase();
}
const Uh = {};
class fw extends os {
  constructor(e, t, r) {
    if (super(), e !== Uh)
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    H(this, "provider", t), r == null && (r = 0), typeof r == "string" ? (H(this, "_address", this.provider.formatter.address(r)), H(this, "_index", null)) : typeof r == "number" ? (H(this, "_index", r), H(this, "_address", null)) : Ot.throwArgumentError("invalid address or index", "addressOrIndex", r);
  }
  connect(e) {
    return Ot.throwError("cannot alter JSON-RPC Signer connection", O.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new B_(Uh, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then((e) => (e.length <= this._index && Ot.throwError("unknown account #" + this._index, O.errors.UNSUPPORTED_OPERATION, {
      operation: "getAddress"
    }), this.provider.formatter.address(e[this._index])));
  }
  sendUncheckedTransaction(e) {
    e = $t(e);
    const t = this.getAddress().then((r) => (r && (r = r.toLowerCase()), r));
    if (e.gasLimit == null) {
      const r = $t(e);
      r.from = t, e.gasLimit = this.provider.estimateGas(r);
    }
    return e.to != null && (e.to = Promise.resolve(e.to).then((r) => ci(this, void 0, void 0, function* () {
      if (r == null)
        return null;
      const i = yield this.provider.resolveName(r);
      return i == null && Ot.throwArgumentError("provided ENS name resolves to null", "tx.to", r), i;
    }))), It({
      tx: It(e),
      sender: t
    }).then(({ tx: r, sender: i }) => {
      r.from != null ? r.from.toLowerCase() !== i && Ot.throwArgumentError("from address mismatch", "transaction", e) : r.from = i;
      const s = this.provider.constructor.hexlifyTransaction(r, { from: !0 });
      return this.provider.send("eth_sendTransaction", [s]).then((a) => a, (a) => (typeof a.message == "string" && a.message.match(/user denied/i) && Ot.throwError("user rejected transaction", O.errors.ACTION_REJECTED, {
        action: "sendTransaction",
        transaction: r
      }), dw("sendTransaction", a, s)));
    });
  }
  signTransaction(e) {
    return Ot.throwError("signing transactions is unsupported", O.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(e) {
    return ci(this, void 0, void 0, function* () {
      const t = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), r = yield this.sendUncheckedTransaction(e);
      try {
        return yield zo(() => ci(this, void 0, void 0, function* () {
          const i = yield this.provider.getTransaction(r);
          if (i !== null)
            return this.provider._wrapTransaction(i, r, t);
        }), { oncePoll: this.provider });
      } catch (i) {
        throw i.transactionHash = r, i;
      }
    });
  }
  signMessage(e) {
    return ci(this, void 0, void 0, function* () {
      const t = typeof e == "string" ? Pr(e) : e, r = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [te(t), r.toLowerCase()]);
      } catch (i) {
        throw typeof i.message == "string" && i.message.match(/user denied/i) && Ot.throwError("user rejected signing", O.errors.ACTION_REJECTED, {
          action: "signMessage",
          from: r,
          messageData: e
        }), i;
      }
    });
  }
  _legacySignMessage(e) {
    return ci(this, void 0, void 0, function* () {
      const t = typeof e == "string" ? Pr(e) : e, r = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [r.toLowerCase(), te(t)]);
      } catch (i) {
        throw typeof i.message == "string" && i.message.match(/user denied/i) && Ot.throwError("user rejected signing", O.errors.ACTION_REJECTED, {
          action: "_legacySignMessage",
          from: r,
          messageData: e
        }), i;
      }
    });
  }
  _signTypedData(e, t, r) {
    return ci(this, void 0, void 0, function* () {
      const i = yield Un.resolveNames(e, t, r, (a) => this.provider.resolveName(a)), s = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          s.toLowerCase(),
          JSON.stringify(Un.getPayload(i.domain, t, i.value))
        ]);
      } catch (a) {
        throw typeof a.message == "string" && a.message.match(/user denied/i) && Ot.throwError("user rejected signing", O.errors.ACTION_REJECTED, {
          action: "_signTypedData",
          from: s,
          messageData: { domain: i.domain, types: t, value: i.value }
        }), a;
      }
    });
  }
  unlock(e) {
    return ci(this, void 0, void 0, function* () {
      const t = this.provider, r = yield this.getAddress();
      return t.send("personal_unlockAccount", [r.toLowerCase(), e, null]);
    });
  }
}
class B_ extends fw {
  sendTransaction(e) {
    return this.sendUncheckedTransaction(e).then((t) => ({
      hash: t,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (r) => this.provider.waitForTransaction(t, r)
    }));
  }
}
const $_ = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0
};
class bp extends O_ {
  constructor(e, t) {
    let r = t;
    r == null && (r = new Promise((i, s) => {
      setTimeout(() => {
        this.detectNetwork().then((a) => {
          i(a);
        }, (a) => {
          s(a);
        });
      }, 0);
    })), super(r), e || (e = jr(this.constructor, "defaultUrl")()), typeof e == "string" ? H(this, "connection", Object.freeze({
      url: e
    })) : H(this, "connection", Object.freeze($t(e))), this._nextId = 42;
  }
  get _cache() {
    return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
      this._cache.detectNetwork = null;
    }, 0)), this._cache.detectNetwork;
  }
  _uncachedDetectNetwork() {
    return ci(this, void 0, void 0, function* () {
      yield Cb(0);
      let e = null;
      try {
        e = yield this.send("eth_chainId", []);
      } catch {
        try {
          e = yield this.send("net_version", []);
        } catch {
        }
      }
      if (e != null) {
        const t = jr(this.constructor, "getNetwork");
        try {
          return t(G.from(e).toNumber());
        } catch (r) {
          return Ot.throwError("could not detect network", O.errors.NETWORK_ERROR, {
            chainId: e,
            event: "invalidNetwork",
            serverError: r
          });
        }
      }
      return Ot.throwError("could not detect network", O.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(e) {
    return new fw(Uh, this, e);
  }
  getUncheckedSigner(e) {
    return this.getSigner(e).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((e) => e.map((t) => this.formatter.address(t)));
  }
  send(e, t) {
    const r = {
      method: e,
      params: t,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: Ci(r),
      provider: this
    });
    const i = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0;
    if (i && this._cache[e])
      return this._cache[e];
    const s = gp(this.connection, JSON.stringify(r), N_).then((a) => (this.emit("debug", {
      action: "response",
      request: r,
      response: a,
      provider: this
    }), a), (a) => {
      throw this.emit("debug", {
        action: "response",
        error: a,
        request: r,
        provider: this
      }), a;
    });
    return i && (this._cache[e] = s, setTimeout(() => {
      this._cache[e] = null;
    }, 0)), s;
  }
  prepareRequest(e, t) {
    switch (e) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [Lo(t.address), t.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [Lo(t.address), t.blockTag]];
      case "getCode":
        return ["eth_getCode", [Lo(t.address), t.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [Lo(t.address), Le(t.position, 32), t.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [t.signedTransaction]];
      case "getBlock":
        return t.blockTag ? ["eth_getBlockByNumber", [t.blockTag, !!t.includeTransactions]] : t.blockHash ? ["eth_getBlockByHash", [t.blockHash, !!t.includeTransactions]] : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [t.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [t.transactionHash]];
      case "call":
        return ["eth_call", [jr(this.constructor, "hexlifyTransaction")(t.transaction, { from: !0 }), t.blockTag]];
      case "estimateGas":
        return ["eth_estimateGas", [jr(this.constructor, "hexlifyTransaction")(t.transaction, { from: !0 })]];
      case "getLogs":
        return t.filter && t.filter.address != null && (t.filter.address = Lo(t.filter.address)), ["eth_getLogs", [t.filter]];
    }
    return null;
  }
  perform(e, t) {
    return ci(this, void 0, void 0, function* () {
      if (e === "call" || e === "estimateGas") {
        const i = t.transaction;
        if (i && i.type != null && G.from(i.type).isZero() && i.maxFeePerGas == null && i.maxPriorityFeePerGas == null) {
          const s = yield this.getFeeData();
          s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (t = $t(t), t.transaction = $t(i), delete t.transaction.type);
        }
      }
      const r = this.prepareRequest(e, t);
      r == null && Ot.throwError(e + " not implemented", O.errors.NOT_IMPLEMENTED, { operation: e });
      try {
        return yield this.send(r[0], r[1]);
      } catch (i) {
        return dw(e, i, t);
      }
    });
  }
  _startEvent(e) {
    e.tag === "pending" && this._startPending(), super._startEvent(e);
  }
  _startPending() {
    if (this._pendingFilter != null)
      return;
    const e = this, t = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = t, t.then(function(r) {
      function i() {
        e.send("eth_getFilterChanges", [r]).then(function(s) {
          if (e._pendingFilter != t)
            return null;
          let a = Promise.resolve();
          return s.forEach(function(o) {
            e._emitted["t:" + o.toLowerCase()] = "pending", a = a.then(function() {
              return e.getTransaction(o).then(function(c) {
                return e.emit("pending", c), null;
              });
            });
          }), a.then(function() {
            return Cb(1e3);
          });
        }).then(function() {
          if (e._pendingFilter != t) {
            e.send("eth_uninstallFilter", [r]);
            return;
          }
          return setTimeout(function() {
            i();
          }, 0), null;
        }).catch((s) => {
        });
      }
      return i(), r;
    }).catch((r) => {
    });
  }
  _stopEvent(e) {
    e.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(e);
  }
  static hexlifyTransaction(e, t) {
    const r = $t($_);
    if (t)
      for (const s in t)
        t[s] && (r[s] = !0);
    aC(e, r);
    const i = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(s) {
      if (e[s] == null)
        return;
      const a = ap(G.from(e[s]));
      s === "gasLimit" && (s = "gas"), i[s] = a;
    }), ["from", "to", "data"].forEach(function(s) {
      e[s] != null && (i[s] = te(e[s]));
    }), e.accessList && (i.accessList = Eo(e.accessList)), i;
  }
}
const L_ = "random/5.7.0", Eb = new O(L_);
function F_() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof na < "u")
    return na;
  throw new Error("unable to locate global object");
}
const Sb = F_();
let Wf = Sb.crypto || Sb.msCrypto;
(!Wf || !Wf.getRandomValues) && (Eb.warn("WARNING: Missing strong random number source"), Wf = {
  getRandomValues: function(n) {
    return Eb.throwError("no secure random source avaialble", O.errors.UNSUPPORTED_OPERATION, {
      operation: "crypto.getRandomValues"
    });
  }
});
const _b = new O(ol);
let U_ = 1;
function Pb(n, e) {
  const t = "Web3LegacyFetcher";
  return function(r, i) {
    const s = {
      method: r,
      params: i,
      id: U_++,
      jsonrpc: "2.0"
    };
    return new Promise((a, o) => {
      this.emit("debug", {
        action: "request",
        fetcher: t,
        request: Ci(s),
        provider: this
      }), e(s, (c, l) => {
        if (c)
          return this.emit("debug", {
            action: "response",
            fetcher: t,
            error: c,
            request: s,
            provider: this
          }), o(c);
        if (this.emit("debug", {
          action: "response",
          fetcher: t,
          request: s,
          response: l,
          provider: this
        }), l.error) {
          const f = new Error(l.error.message);
          return f.code = l.error.code, f.data = l.error.data, o(f);
        }
        a(l.result);
      });
    });
  };
}
function V_(n) {
  return function(e, t) {
    t == null && (t = []);
    const r = { method: e, params: t };
    return this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: Ci(r),
      provider: this
    }), n.request(r).then((i) => (this.emit("debug", {
      action: "response",
      fetcher: "Eip1193Fetcher",
      request: r,
      response: i,
      provider: this
    }), i), (i) => {
      throw this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request: r,
        error: i,
        provider: this
      }), i;
    });
  };
}
class j_ extends bp {
  constructor(e, t) {
    e == null && _b.throwArgumentError("missing provider", "provider", e);
    let r = null, i = null, s = null;
    typeof e == "function" ? (r = "unknown:", i = e) : (r = e.host || e.path || "", !r && e.isMetaMask && (r = "metamask"), s = e, e.request ? (r === "" && (r = "eip-1193:"), i = V_(e)) : e.sendAsync ? i = Pb(e, e.sendAsync.bind(e)) : e.send ? i = Pb(e, e.send.bind(e)) : _b.throwArgumentError("unsupported provider", "provider", e), r || (r = "unknown:")), super(r, t), H(this, "jsonRpcFetchFunc", i), H(this, "provider", s);
  }
  send(e, t) {
    return this.jsonRpcFetchFunc(e, t);
  }
}
new O(ol);
const G_ = "wordlists/5.7.0", W_ = new O(G_);
class cl {
  constructor(e) {
    W_.checkAbstract(new.target, cl), H(this, "locale", e);
  }
  split(e) {
    return e.toLowerCase().split(/ +/g);
  }
  join(e) {
    return e.join(" ");
  }
  static check(e) {
    const t = [];
    for (let r = 0; r < 2048; r++) {
      const i = e.getWord(r);
      if (r !== e.getWordIndex(i))
        return "0x";
      t.push(i);
    }
    return Ks(t.join(`
`) + `
`);
  }
  static register(e, t) {
    t || (t = e.locale);
  }
}
const H_ = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let ac = null;
function Mb(n) {
  if (ac == null && (ac = H_.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), cl.check(n) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"))
    throw ac = null, new Error("BIP39 Wordlist for en (English) FAILED");
}
class z_ extends cl {
  constructor() {
    super("en");
  }
  getWord(e) {
    return Mb(this), ac[e];
  }
  getWordIndex(e) {
    return Mb(this), ac.indexOf(e);
  }
}
const K_ = new z_();
cl.register(K_);
const q_ = "hdnode/5.7.0", LN = new O(q_), FN = G.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), UN = Pr("Bitcoin seed");
var hw = { exports: {} };
(function(n, e) {
  (function(t) {
    function r(y) {
      return parseInt(y) === y;
    }
    function i(y) {
      if (!r(y.length))
        return !1;
      for (var u = 0; u < y.length; u++)
        if (!r(y[u]) || y[u] < 0 || y[u] > 255)
          return !1;
      return !0;
    }
    function s(y, u) {
      if (y.buffer && ArrayBuffer.isView(y) && y.name === "Uint8Array")
        return u && (y.slice ? y = y.slice() : y = Array.prototype.slice.call(y)), y;
      if (Array.isArray(y)) {
        if (!i(y))
          throw new Error("Array contains invalid value: " + y);
        return new Uint8Array(y);
      }
      if (r(y.length) && i(y))
        return new Uint8Array(y);
      throw new Error("unsupported array-like object");
    }
    function a(y) {
      return new Uint8Array(y);
    }
    function o(y, u, b, k, h) {
      (k != null || h != null) && (y.slice ? y = y.slice(k, h) : y = Array.prototype.slice.call(y, k, h)), u.set(y, b);
    }
    var c = function() {
      function y(b) {
        var k = [], h = 0;
        for (b = encodeURI(b); h < b.length; ) {
          var M = b.charCodeAt(h++);
          M === 37 ? (k.push(parseInt(b.substr(h, 2), 16)), h += 2) : k.push(M);
        }
        return s(k);
      }
      function u(b) {
        for (var k = [], h = 0; h < b.length; ) {
          var M = b[h];
          M < 128 ? (k.push(String.fromCharCode(M)), h++) : M > 191 && M < 224 ? (k.push(String.fromCharCode((M & 31) << 6 | b[h + 1] & 63)), h += 2) : (k.push(String.fromCharCode((M & 15) << 12 | (b[h + 1] & 63) << 6 | b[h + 2] & 63)), h += 3);
        }
        return k.join("");
      }
      return {
        toBytes: y,
        fromBytes: u
      };
    }(), l = function() {
      function y(k) {
        for (var h = [], M = 0; M < k.length; M += 2)
          h.push(parseInt(k.substr(M, 2), 16));
        return h;
      }
      var u = "0123456789abcdef";
      function b(k) {
        for (var h = [], M = 0; M < k.length; M++) {
          var L = k[M];
          h.push(u[(L & 240) >> 4] + u[L & 15]);
        }
        return h.join("");
      }
      return {
        toBytes: y,
        fromBytes: b
      };
    }(), f = { 16: 10, 24: 12, 32: 14 }, p = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145], g = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], T = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], v = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986], w = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766], C = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126], _ = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436], I = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890], B = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935], N = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600], D = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480], U = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795], W = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855], j = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150], q = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function ce(y) {
      for (var u = [], b = 0; b < y.length; b += 4)
        u.push(
          y[b] << 24 | y[b + 1] << 16 | y[b + 2] << 8 | y[b + 3]
        );
      return u;
    }
    var re = function(y) {
      if (!(this instanceof re))
        throw Error("AES must be instanitated with `new`");
      Object.defineProperty(this, "key", {
        value: s(y, !0)
      }), this._prepare();
    };
    re.prototype._prepare = function() {
      var y = f[this.key.length];
      if (y == null)
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      this._Ke = [], this._Kd = [];
      for (var u = 0; u <= y; u++)
        this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (var b = (y + 1) * 4, k = this.key.length / 4, h = ce(this.key), M, u = 0; u < k; u++)
        M = u >> 2, this._Ke[M][u % 4] = h[u], this._Kd[y - M][u % 4] = h[u];
      for (var L = 0, $ = k, F; $ < b; ) {
        if (F = h[k - 1], h[0] ^= g[F >> 16 & 255] << 24 ^ g[F >> 8 & 255] << 16 ^ g[F & 255] << 8 ^ g[F >> 24 & 255] ^ p[L] << 24, L += 1, k != 8)
          for (var u = 1; u < k; u++)
            h[u] ^= h[u - 1];
        else {
          for (var u = 1; u < k / 2; u++)
            h[u] ^= h[u - 1];
          F = h[k / 2 - 1], h[k / 2] ^= g[F & 255] ^ g[F >> 8 & 255] << 8 ^ g[F >> 16 & 255] << 16 ^ g[F >> 24 & 255] << 24;
          for (var u = k / 2 + 1; u < k; u++)
            h[u] ^= h[u - 1];
        }
        for (var u = 0, X, z; u < k && $ < b; )
          X = $ >> 2, z = $ % 4, this._Ke[X][z] = h[u], this._Kd[y - X][z] = h[u++], $++;
      }
      for (var X = 1; X < y; X++)
        for (var z = 0; z < 4; z++)
          F = this._Kd[X][z], this._Kd[X][z] = U[F >> 24 & 255] ^ W[F >> 16 & 255] ^ j[F >> 8 & 255] ^ q[F & 255];
    }, re.prototype.encrypt = function(y) {
      if (y.length != 16)
        throw new Error("invalid plaintext size (must be 16 bytes)");
      for (var u = this._Ke.length - 1, b = [0, 0, 0, 0], k = ce(y), h = 0; h < 4; h++)
        k[h] ^= this._Ke[0][h];
      for (var M = 1; M < u; M++) {
        for (var h = 0; h < 4; h++)
          b[h] = v[k[h] >> 24 & 255] ^ w[k[(h + 1) % 4] >> 16 & 255] ^ C[k[(h + 2) % 4] >> 8 & 255] ^ _[k[(h + 3) % 4] & 255] ^ this._Ke[M][h];
        k = b.slice();
      }
      for (var L = a(16), $, h = 0; h < 4; h++)
        $ = this._Ke[u][h], L[4 * h] = (g[k[h] >> 24 & 255] ^ $ >> 24) & 255, L[4 * h + 1] = (g[k[(h + 1) % 4] >> 16 & 255] ^ $ >> 16) & 255, L[4 * h + 2] = (g[k[(h + 2) % 4] >> 8 & 255] ^ $ >> 8) & 255, L[4 * h + 3] = (g[k[(h + 3) % 4] & 255] ^ $) & 255;
      return L;
    }, re.prototype.decrypt = function(y) {
      if (y.length != 16)
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      for (var u = this._Kd.length - 1, b = [0, 0, 0, 0], k = ce(y), h = 0; h < 4; h++)
        k[h] ^= this._Kd[0][h];
      for (var M = 1; M < u; M++) {
        for (var h = 0; h < 4; h++)
          b[h] = I[k[h] >> 24 & 255] ^ B[k[(h + 3) % 4] >> 16 & 255] ^ N[k[(h + 2) % 4] >> 8 & 255] ^ D[k[(h + 1) % 4] & 255] ^ this._Kd[M][h];
        k = b.slice();
      }
      for (var L = a(16), $, h = 0; h < 4; h++)
        $ = this._Kd[u][h], L[4 * h] = (T[k[h] >> 24 & 255] ^ $ >> 24) & 255, L[4 * h + 1] = (T[k[(h + 3) % 4] >> 16 & 255] ^ $ >> 16) & 255, L[4 * h + 2] = (T[k[(h + 2) % 4] >> 8 & 255] ^ $ >> 8) & 255, L[4 * h + 3] = (T[k[(h + 1) % 4] & 255] ^ $) & 255;
      return L;
    };
    var me = function(y) {
      if (!(this instanceof me))
        throw Error("AES must be instanitated with `new`");
      this.description = "Electronic Code Block", this.name = "ecb", this._aes = new re(y);
    };
    me.prototype.encrypt = function(y) {
      if (y = s(y), y.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var u = a(y.length), b = a(16), k = 0; k < y.length; k += 16)
        o(y, b, 0, k, k + 16), b = this._aes.encrypt(b), o(b, u, k);
      return u;
    }, me.prototype.decrypt = function(y) {
      if (y = s(y), y.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var u = a(y.length), b = a(16), k = 0; k < y.length; k += 16)
        o(y, b, 0, k, k + 16), b = this._aes.decrypt(b), o(b, u, k);
      return u;
    };
    var S = function(y, u) {
      if (!(this instanceof S))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Block Chaining", this.name = "cbc", !u)
        u = a(16);
      else if (u.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastCipherblock = s(u, !0), this._aes = new re(y);
    };
    S.prototype.encrypt = function(y) {
      if (y = s(y), y.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var u = a(y.length), b = a(16), k = 0; k < y.length; k += 16) {
        o(y, b, 0, k, k + 16);
        for (var h = 0; h < 16; h++)
          b[h] ^= this._lastCipherblock[h];
        this._lastCipherblock = this._aes.encrypt(b), o(this._lastCipherblock, u, k);
      }
      return u;
    }, S.prototype.decrypt = function(y) {
      if (y = s(y), y.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var u = a(y.length), b = a(16), k = 0; k < y.length; k += 16) {
        o(y, b, 0, k, k + 16), b = this._aes.decrypt(b);
        for (var h = 0; h < 16; h++)
          u[k + h] = b[h] ^ this._lastCipherblock[h];
        o(y, this._lastCipherblock, 0, k, k + 16);
      }
      return u;
    };
    var d = function(y, u, b) {
      if (!(this instanceof d))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Feedback", this.name = "cfb", !u)
        u = a(16);
      else if (u.length != 16)
        throw new Error("invalid initialation vector size (must be 16 size)");
      b || (b = 1), this.segmentSize = b, this._shiftRegister = s(u, !0), this._aes = new re(y);
    };
    d.prototype.encrypt = function(y) {
      if (y.length % this.segmentSize != 0)
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      for (var u = s(y, !0), b, k = 0; k < u.length; k += this.segmentSize) {
        b = this._aes.encrypt(this._shiftRegister);
        for (var h = 0; h < this.segmentSize; h++)
          u[k + h] ^= b[h];
        o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(u, this._shiftRegister, 16 - this.segmentSize, k, k + this.segmentSize);
      }
      return u;
    }, d.prototype.decrypt = function(y) {
      if (y.length % this.segmentSize != 0)
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      for (var u = s(y, !0), b, k = 0; k < u.length; k += this.segmentSize) {
        b = this._aes.encrypt(this._shiftRegister);
        for (var h = 0; h < this.segmentSize; h++)
          u[k + h] ^= b[h];
        o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(y, this._shiftRegister, 16 - this.segmentSize, k, k + this.segmentSize);
      }
      return u;
    };
    var m = function(y, u) {
      if (!(this instanceof m))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Output Feedback", this.name = "ofb", !u)
        u = a(16);
      else if (u.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastPrecipher = s(u, !0), this._lastPrecipherIndex = 16, this._aes = new re(y);
    };
    m.prototype.encrypt = function(y) {
      for (var u = s(y, !0), b = 0; b < u.length; b++)
        this._lastPrecipherIndex === 16 && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), u[b] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      return u;
    }, m.prototype.decrypt = m.prototype.encrypt;
    var x = function(y) {
      if (!(this instanceof x))
        throw Error("Counter must be instanitated with `new`");
      y !== 0 && !y && (y = 1), typeof y == "number" ? (this._counter = a(16), this.setValue(y)) : this.setBytes(y);
    };
    x.prototype.setValue = function(y) {
      if (typeof y != "number" || parseInt(y) != y)
        throw new Error("invalid counter value (must be an integer)");
      for (var u = 15; u >= 0; --u)
        this._counter[u] = y % 256, y = y >> 8;
    }, x.prototype.setBytes = function(y) {
      if (y = s(y, !0), y.length != 16)
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      this._counter = y;
    }, x.prototype.increment = function() {
      for (var y = 15; y >= 0; y--)
        if (this._counter[y] === 255)
          this._counter[y] = 0;
        else {
          this._counter[y]++;
          break;
        }
    };
    var E = function(y, u) {
      if (!(this instanceof E))
        throw Error("AES must be instanitated with `new`");
      this.description = "Counter", this.name = "ctr", u instanceof x || (u = new x(u)), this._counter = u, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new re(y);
    };
    E.prototype.encrypt = function(y) {
      for (var u = s(y, !0), b = 0; b < u.length; b++)
        this._remainingCounterIndex === 16 && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), u[b] ^= this._remainingCounter[this._remainingCounterIndex++];
      return u;
    }, E.prototype.decrypt = E.prototype.encrypt;
    function A(y) {
      y = s(y, !0);
      var u = 16 - y.length % 16, b = a(y.length + u);
      o(y, b);
      for (var k = y.length; k < b.length; k++)
        b[k] = u;
      return b;
    }
    function P(y) {
      if (y = s(y, !0), y.length < 16)
        throw new Error("PKCS#7 invalid length");
      var u = y[y.length - 1];
      if (u > 16)
        throw new Error("PKCS#7 padding byte out of range");
      for (var b = y.length - u, k = 0; k < u; k++)
        if (y[b + k] !== u)
          throw new Error("PKCS#7 invalid padding byte");
      var h = a(b);
      return o(y, h, 0, 0, b), h;
    }
    var R = {
      AES: re,
      Counter: x,
      ModeOfOperation: {
        ecb: me,
        cbc: S,
        cfb: d,
        ofb: m,
        ctr: E
      },
      utils: {
        hex: l,
        utf8: c
      },
      padding: {
        pkcs7: {
          pad: A,
          strip: P
        }
      },
      _arrayTest: {
        coerceArray: s,
        createArray: a,
        copyArray: o
      }
    };
    n.exports = R;
  })();
})(hw);
const VN = hw.exports, pw = "json-wallets/5.7.0";
const jN = new O(pw);
var mw = { exports: {} };
(function(n, e) {
  (function(t) {
    function i(w) {
      const C = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let _ = 1779033703, I = 3144134277, B = 1013904242, N = 2773480762, D = 1359893119, U = 2600822924, W = 528734635, j = 1541459225;
      const q = new Uint32Array(64);
      function ce(E) {
        let A = 0, P = E.length;
        for (; P >= 64; ) {
          let R = _, y = I, u = B, b = N, k = D, h = U, M = W, L = j, $, F, X, z, K;
          for (F = 0; F < 16; F++)
            X = A + F * 4, q[F] = (E[X] & 255) << 24 | (E[X + 1] & 255) << 16 | (E[X + 2] & 255) << 8 | E[X + 3] & 255;
          for (F = 16; F < 64; F++)
            $ = q[F - 2], z = ($ >>> 17 | $ << 32 - 17) ^ ($ >>> 19 | $ << 32 - 19) ^ $ >>> 10, $ = q[F - 15], K = ($ >>> 7 | $ << 32 - 7) ^ ($ >>> 18 | $ << 32 - 18) ^ $ >>> 3, q[F] = (z + q[F - 7] | 0) + (K + q[F - 16] | 0) | 0;
          for (F = 0; F < 64; F++)
            z = (((k >>> 6 | k << 32 - 6) ^ (k >>> 11 | k << 32 - 11) ^ (k >>> 25 | k << 32 - 25)) + (k & h ^ ~k & M) | 0) + (L + (C[F] + q[F] | 0) | 0) | 0, K = ((R >>> 2 | R << 32 - 2) ^ (R >>> 13 | R << 32 - 13) ^ (R >>> 22 | R << 32 - 22)) + (R & y ^ R & u ^ y & u) | 0, L = M, M = h, h = k, k = b + z | 0, b = u, u = y, y = R, R = z + K | 0;
          _ = _ + R | 0, I = I + y | 0, B = B + u | 0, N = N + b | 0, D = D + k | 0, U = U + h | 0, W = W + M | 0, j = j + L | 0, A += 64, P -= 64;
        }
      }
      ce(w);
      let re, me = w.length % 64, S = w.length / 536870912 | 0, d = w.length << 3, m = me < 56 ? 56 : 120, x = w.slice(w.length - me, w.length);
      for (x.push(128), re = me + 1; re < m; re++)
        x.push(0);
      return x.push(S >>> 24 & 255), x.push(S >>> 16 & 255), x.push(S >>> 8 & 255), x.push(S >>> 0 & 255), x.push(d >>> 24 & 255), x.push(d >>> 16 & 255), x.push(d >>> 8 & 255), x.push(d >>> 0 & 255), ce(x), [
        _ >>> 24 & 255,
        _ >>> 16 & 255,
        _ >>> 8 & 255,
        _ >>> 0 & 255,
        I >>> 24 & 255,
        I >>> 16 & 255,
        I >>> 8 & 255,
        I >>> 0 & 255,
        B >>> 24 & 255,
        B >>> 16 & 255,
        B >>> 8 & 255,
        B >>> 0 & 255,
        N >>> 24 & 255,
        N >>> 16 & 255,
        N >>> 8 & 255,
        N >>> 0 & 255,
        D >>> 24 & 255,
        D >>> 16 & 255,
        D >>> 8 & 255,
        D >>> 0 & 255,
        U >>> 24 & 255,
        U >>> 16 & 255,
        U >>> 8 & 255,
        U >>> 0 & 255,
        W >>> 24 & 255,
        W >>> 16 & 255,
        W >>> 8 & 255,
        W >>> 0 & 255,
        j >>> 24 & 255,
        j >>> 16 & 255,
        j >>> 8 & 255,
        j >>> 0 & 255
      ];
    }
    function s(w, C, _) {
      w = w.length <= 64 ? w : i(w);
      const I = 64 + C.length + 4, B = new Array(I), N = new Array(64);
      let D, U = [];
      for (D = 0; D < 64; D++)
        B[D] = 54;
      for (D = 0; D < w.length; D++)
        B[D] ^= w[D];
      for (D = 0; D < C.length; D++)
        B[64 + D] = C[D];
      for (D = I - 4; D < I; D++)
        B[D] = 0;
      for (D = 0; D < 64; D++)
        N[D] = 92;
      for (D = 0; D < w.length; D++)
        N[D] ^= w[D];
      function W() {
        for (let j = I - 1; j >= I - 4; j--) {
          if (B[j]++, B[j] <= 255)
            return;
          B[j] = 0;
        }
      }
      for (; _ >= 32; )
        W(), U = U.concat(i(N.concat(i(B)))), _ -= 32;
      return _ > 0 && (W(), U = U.concat(i(N.concat(i(B))).slice(0, _))), U;
    }
    function a(w, C, _, I, B) {
      let N;
      for (f(w, (2 * _ - 1) * 16, B, 0, 16), N = 0; N < 2 * _; N++)
        l(w, N * 16, B, 16), c(B, I), f(B, 0, w, C + N * 16, 16);
      for (N = 0; N < _; N++)
        f(w, C + N * 2 * 16, w, N * 16, 16);
      for (N = 0; N < _; N++)
        f(w, C + (N * 2 + 1) * 16, w, (N + _) * 16, 16);
    }
    function o(w, C) {
      return w << C | w >>> 32 - C;
    }
    function c(w, C) {
      f(w, 0, C, 0, 16);
      for (let _ = 8; _ > 0; _ -= 2)
        C[4] ^= o(C[0] + C[12], 7), C[8] ^= o(C[4] + C[0], 9), C[12] ^= o(C[8] + C[4], 13), C[0] ^= o(C[12] + C[8], 18), C[9] ^= o(C[5] + C[1], 7), C[13] ^= o(C[9] + C[5], 9), C[1] ^= o(C[13] + C[9], 13), C[5] ^= o(C[1] + C[13], 18), C[14] ^= o(C[10] + C[6], 7), C[2] ^= o(C[14] + C[10], 9), C[6] ^= o(C[2] + C[14], 13), C[10] ^= o(C[6] + C[2], 18), C[3] ^= o(C[15] + C[11], 7), C[7] ^= o(C[3] + C[15], 9), C[11] ^= o(C[7] + C[3], 13), C[15] ^= o(C[11] + C[7], 18), C[1] ^= o(C[0] + C[3], 7), C[2] ^= o(C[1] + C[0], 9), C[3] ^= o(C[2] + C[1], 13), C[0] ^= o(C[3] + C[2], 18), C[6] ^= o(C[5] + C[4], 7), C[7] ^= o(C[6] + C[5], 9), C[4] ^= o(C[7] + C[6], 13), C[5] ^= o(C[4] + C[7], 18), C[11] ^= o(C[10] + C[9], 7), C[8] ^= o(C[11] + C[10], 9), C[9] ^= o(C[8] + C[11], 13), C[10] ^= o(C[9] + C[8], 18), C[12] ^= o(C[15] + C[14], 7), C[13] ^= o(C[12] + C[15], 9), C[14] ^= o(C[13] + C[12], 13), C[15] ^= o(C[14] + C[13], 18);
      for (let _ = 0; _ < 16; ++_)
        w[_] += C[_];
    }
    function l(w, C, _, I) {
      for (let B = 0; B < I; B++)
        _[B] ^= w[C + B];
    }
    function f(w, C, _, I, B) {
      for (; B--; )
        _[I++] = w[C++];
    }
    function p(w) {
      if (!w || typeof w.length != "number")
        return !1;
      for (let C = 0; C < w.length; C++) {
        const _ = w[C];
        if (typeof _ != "number" || _ % 1 || _ < 0 || _ >= 256)
          return !1;
      }
      return !0;
    }
    function g(w, C) {
      if (typeof w != "number" || w % 1)
        throw new Error("invalid " + C);
      return w;
    }
    function T(w, C, _, I, B, N, D) {
      if (_ = g(_, "N"), I = g(I, "r"), B = g(B, "p"), N = g(N, "dkLen"), _ === 0 || (_ & _ - 1) !== 0)
        throw new Error("N must be power of 2");
      if (_ > 2147483647 / 128 / I)
        throw new Error("N too large");
      if (I > 2147483647 / 128 / B)
        throw new Error("r too large");
      if (!p(w))
        throw new Error("password must be an array or buffer");
      if (w = Array.prototype.slice.call(w), !p(C))
        throw new Error("salt must be an array or buffer");
      C = Array.prototype.slice.call(C);
      let U = s(w, C, B * 128 * I);
      const W = new Uint32Array(B * 32 * I);
      for (let k = 0; k < W.length; k++) {
        const h = k * 4;
        W[k] = (U[h + 3] & 255) << 24 | (U[h + 2] & 255) << 16 | (U[h + 1] & 255) << 8 | (U[h + 0] & 255) << 0;
      }
      const j = new Uint32Array(64 * I), q = new Uint32Array(32 * I * _), ce = 32 * I, re = new Uint32Array(16), me = new Uint32Array(16), S = B * _ * 2;
      let d = 0, m = null, x = !1, E = 0, A = 0, P, R;
      const y = D ? parseInt(1e3 / I) : 4294967295, u = typeof setImmediate < "u" ? setImmediate : setTimeout, b = function() {
        if (x)
          return D(new Error("cancelled"), d / S);
        let k;
        switch (E) {
          case 0:
            R = A * 32 * I, f(W, R, j, 0, ce), E = 1, P = 0;
          case 1:
            k = _ - P, k > y && (k = y);
            for (let M = 0; M < k; M++)
              f(j, 0, q, (P + M) * ce, ce), a(j, ce, I, re, me);
            if (P += k, d += k, D) {
              const M = parseInt(1e3 * d / S);
              if (M !== m) {
                if (x = D(null, d / S), x)
                  break;
                m = M;
              }
            }
            if (P < _)
              break;
            P = 0, E = 2;
          case 2:
            k = _ - P, k > y && (k = y);
            for (let M = 0; M < k; M++) {
              const L = (2 * I - 1) * 16, $ = j[L] & _ - 1;
              l(q, $ * ce, j, ce), a(j, ce, I, re, me);
            }
            if (P += k, d += k, D) {
              const M = parseInt(1e3 * d / S);
              if (M !== m) {
                if (x = D(null, d / S), x)
                  break;
                m = M;
              }
            }
            if (P < _)
              break;
            if (f(j, 0, W, R, ce), A++, A < B) {
              E = 0;
              break;
            }
            U = [];
            for (let M = 0; M < W.length; M++)
              U.push(W[M] >> 0 & 255), U.push(W[M] >> 8 & 255), U.push(W[M] >> 16 & 255), U.push(W[M] >> 24 & 255);
            const h = s(w, U, N);
            return D && D(null, 1, h), h;
        }
        D && u(b);
      };
      if (!D)
        for (; ; ) {
          const k = b();
          if (k != null)
            return k;
        }
      b();
    }
    const v = {
      scrypt: function(w, C, _, I, B, N, D) {
        return new Promise(function(U, W) {
          let j = 0;
          D && D(0), T(w, C, _, I, B, N, function(q, ce, re) {
            if (q)
              W(q);
            else if (re)
              D && j !== 1 && D(1), U(new Uint8Array(re));
            else if (D && ce !== j)
              return j = ce, D(ce);
          });
        });
      },
      syncScrypt: function(w, C, _, I, B, N) {
        return new Uint8Array(T(w, C, _, I, B, N));
      }
    };
    n.exports = v;
  })();
})(mw);
const GN = mw.exports;
var WN = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const HN = new O(pw);
const Q_ = "wallet/5.7.0";
var zN = globalThis && globalThis.__awaiter || function(n, e, t, r) {
  function i(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(f) {
      try {
        l(r.next(f));
      } catch (p) {
        a(p);
      }
    }
    function c(f) {
      try {
        l(r.throw(f));
      } catch (p) {
        a(p);
      }
    }
    function l(f) {
      f.done ? s(f.value) : i(f.value).then(o, c);
    }
    l((r = r.apply(n, e || [])).next());
  });
};
const KN = new O(Q_);
const J_ = "units/5.7.0", Y_ = new O(J_), yw = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function X_(n, e) {
  if (typeof e == "string") {
    const t = yw.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return Ql(n, e ?? 18);
}
function Z_(n, e) {
  if (typeof n != "string" && Y_.throwArgumentError("value must be a string", "value", n), typeof e == "string") {
    const t = yw.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return Or(n, e ?? 18);
}
const e9 = "ethers/5.7.2";
new O(e9);
const t9 = new O("CeloNetworks"), Rb = [
  {
    name: "celo",
    chainId: 42220
  },
  {
    name: "alfajores",
    chainId: 44787
  },
  {
    name: "baklava",
    chainId: 62320
  }
];
function Vh(n) {
  {
    if (n == null)
      return null;
    if (typeof n == "number") {
      const e = Rb.filter((t) => t.chainId === n);
      return e.length ? { name: e[0].name, chainId: e[0].chainId } : {
        name: "unknown",
        chainId: n
      };
    }
    if (typeof n == "string") {
      const e = Rb.filter((t) => t.name === n);
      return e.length ? { name: e[0].name, chainId: e[0].chainId } : null;
    }
    if (typeof n.name == "string" && typeof n.chainId == "number") {
      const e = Vh(n.name), t = Vh(n.chainId);
      if (e == null && t == null)
        return {
          name: n.name,
          chainId: n.chainId
        };
      if (e && t && e.name === t.name && e.chainId === t.chainId)
        return e;
    }
    return t9.throwArgumentError("network chainId mismatch", "network", n);
  }
}
const n9 = new O("celo/transactions");
function r9(n) {
  const e = wd(n);
  e.length !== 12 && e.length !== 9 && n9.throwArgumentError("invalid raw transaction", "rawTransaction", n);
  const t = {
    nonce: Fo(e[0]).toNumber(),
    gasPrice: Fo(e[1]),
    gasLimit: Fo(e[2]),
    feeCurrency: Hf(e[3]),
    gatewayFeeRecipient: Hf(e[4]),
    gatewayFee: Fo(e[5]),
    to: Hf(e[6]),
    value: Fo(e[7]),
    data: e[8],
    chainId: 0
  };
  if (e.length === 9)
    return t;
  try {
    t.v = G.from(e[9]).toNumber();
  } catch (r) {
    return console.log(r), t;
  }
  if (t.r = Le(e[10], 32), t.s = Le(e[11], 32), G.from(t.r).isZero() && G.from(t.s).isZero())
    t.chainId = t.v, t.v = 0;
  else {
    t.chainId = Math.floor((t.v - 35) / 2), t.chainId < 0 && (t.chainId = 0);
    let r = t.v - 27;
    const i = e.slice(0, 6);
    t.chainId !== 0 && (i.push(te(t.chainId)), i.push("0x"), i.push("0x"), r -= t.chainId * 2 + 8);
    const s = Mt(il(i));
    try {
      t.from = yp(s, {
        r: te(t.r),
        s: te(t.s),
        recoveryParam: r
      });
    } catch (a) {
      console.log(a);
    }
    t.hash = Mt(n);
  }
  return t;
}
function Hf(n) {
  if (n !== "0x")
    try {
      return Rt(n);
    } catch {
      return n;
    }
}
function Fo(n) {
  return n === "0x" ? up : G.from(n);
}
const i9 = new O("CeloProvider");
class s9 extends bp {
  constructor(e, t) {
    super(e, t);
    const r = this.formatter.formats.block;
    r.gasLimit = () => G.from(0), r.nonce = () => "", r.difficulty = () => 0;
    const i = this.formatter.formats.blockWithTransactions;
    i.gasLimit = () => G.from(0), i.nonce = () => "", i.difficulty = () => 0;
  }
  async sendTransaction(e) {
    await this.getNetwork();
    const t = await Promise.resolve(e), r = te(t), i = r9(t);
    try {
      const s = await this.perform("sendTransaction", {
        signedTransaction: r
      });
      return this._wrapTransaction(i, s);
    } catch (s) {
      throw s.transaction = i, s.transactionHash = i.hash, s;
    }
  }
  async getGasPrice(e) {
    await this.getNetwork();
    const t = e ? { feeCurrencyAddress: e } : {};
    return G.from(await this.perform("getGasPrice", t));
  }
  prepareRequest(e, t) {
    return e === "getGasPrice" ? ["eth_gasPrice", t.feeCurrencyAddress ? [t.feeCurrencyAddress] : []] : super.prepareRequest(e, t);
  }
  static getNetwork(e) {
    const t = Vh(e ?? "celo");
    return t ?? i9.throwError(`unknown network: ${JSON.stringify(t)}`, O.errors.UNSUPPORTED_OPERATION, {
      operation: "getNetwork",
      value: e
    });
  }
}
const qN = new O("CeloWallet"), QN = [
  O.errors.INSUFFICIENT_FUNDS,
  O.errors.NONCE_EXPIRED,
  O.errors.REPLACEMENT_UNDERPRICED
];
const a9 = "@kolektivo/dapp", o9 = "A collection of institutional technologies that open up new opportunities for local communities to govern and finance their own regenerative economies.", c9 = "1.0.0", l9 = {
  type: "git",
  url: "https://github.com/Kolektivo/dapp"
}, u9 = "CL Cybernetix GmbH", d9 = "./", f9 = "MIT", h9 = {
  node: ">=16.0.0"
}, p9 = {
  http: !1
}, m9 = {
  "lint:js": "eslint src --ext .js,.ts",
  "lint:fix": "eslint src  --fix",
  "lint:scss:fix": 'stylelint "src/**/*.scss" --fix',
  "lint:scss": 'stylelint "src/**/*.scss"',
  "lint:html": "htmlhint -c .htmlhintrc src design-system ",
  lint: "npm run lint:js && npm run lint:html && npm run lint:scss",
  clean: "npx -y rimraf node_modules package-lock.json && npm i",
  dev: "vite",
  start: "vite",
  build: "tsc && vite build",
  "build:chart-data-script": "vite build --config vite.config-lib.ts",
  "build:dev:chart-data-script": "vite build --config vite.config-lib.ts --mode development",
  "build:dev": "vite build --mode development",
  "preview-build": "vite preview --open",
  postinstall: "node build/postinstall/index.mjs",
  test: "vitest --no-threads",
  "test:ui": "vitest --ui",
  coverage: "vitest run --coverage",
  e2e: "playwright test",
  "e2e:watch": "playwright test --watch",
  "e2e:ci": "URL=$npm_config_url playwright test",
  "vercel:deploy": "vercel --token $npm_config_token",
  "vercel:deploy:production": "vercel --prod --token $npm_config_token",
  "vercel:alias": "vercel alias set $npm_config_deployment $npm_config_branch --token $npm_config_token --scope $npm_config_scope"
}, y9 = {
  "@aurelia/i18n": "dev",
  "@aurelia/validation-html": "dev",
  "@celo-tools/celo-ethers-wrapper": "^0.3.0",
  "@dethcrypto/eth-sdk": "^0.3.3",
  "@dethcrypto/eth-sdk-client": "^0.1.6",
  "@material-design-icons/svg": "^0.13.0",
  "@metamask/detect-provider": "^2.0.0",
  "@metamask/providers": "^10.0.0",
  "@walletconnect/web3-provider": "^1.8.0",
  aurelia: "dev",
  "browserify-zlib": "^0.2.0",
  buffer: "^6.0.3",
  "chart.js": "^3.9.1",
  cids: "^1.1.9",
  ethers: "^5.7.2",
  events: "^3.3.0",
  firebase: "^9.12.1",
  "i18next-chained-backend": "^4.0.0",
  "i18next-http-backend": "^2.0.0",
  "i18next-intervalplural-postprocessor": "^3.0.0",
  "i18next-localstorage-backend": "^4.0.0",
  "ipfs-core": "^0.16.1",
  "ipfs-http-client": "^58.0.1",
  "lit-js-sdk": "^1.2.17",
  process: "^0.11.10",
  "stream-browserify": "^3.0.0",
  uint8arrays: "^4.0.2",
  util: "^0.12.5",
  web3modal: "^1.9.9"
}, g9 = {
  "@aurelia/plugin-conventions": "dev",
  "@aurelia/testing": "dev",
  "@esbuild-plugins/node-globals-polyfill": "^0.1.1",
  "@playwright/test": "^1.27.1",
  "@rollup/plugin-inject": "^5.0.2",
  "@typechain/ethers-v5": "^10.1.0",
  "@types/node": "^18.11.4",
  "@typescript-eslint/eslint-plugin": "^5.40.1",
  "@typescript-eslint/parser": "^5.40.1",
  "@vitest/ui": "^0.24.3",
  "cross-env": "^7.0.3",
  eslint: "^8.26.0",
  "eslint-config-prettier": "^8.5.0",
  "eslint-import-resolver-typescript": "^3.5.2",
  "eslint-plugin-cypress": "^2.12.1",
  "eslint-plugin-import": "^2.26.0",
  "eslint-plugin-prettier": "^4.2.1",
  "eslint-plugin-sort-imports-es6-autofix": "^0.6.0",
  "eslint-plugin-unused-imports": "^2.0.0",
  "fs-extra": "^10.1.0",
  glob: "^8.0.3",
  "happy-dom": "^7.6.0",
  "html-loader": "^4.2.0",
  htmlhint: "^1.1.4",
  "http-browserify": "1.7.0",
  "https-browserify": "^1.0.0",
  postcss: "^8.4.18",
  "postcss-loader": "^7.0.1",
  "rollup-plugin-html": "^0.2.1",
  "rollup-plugin-polyfill-node": "^0.10.2",
  "rollup-plugin-swc": "^0.2.1",
  "rollup-plugin-visualizer": "^5.8.3",
  "rollup-pluginutils": "^2.8.2",
  sass: "^1.55.0",
  stylelint: "^14.14.0",
  "stylelint-config-prettier": "^9.0.3",
  "stylelint-config-standard": "^29.0.0",
  "stylelint-config-standard-scss": "^5.0.0",
  "stylelint-prettier": "^2.0.0",
  tslib: "^2.4.0",
  typescript: "~4.8.4",
  "unplugin-swc": "^1.3.2",
  vercel: "^28.4.12",
  vite: "^3.1.8",
  "vite-svg-loader": "^3.6.0",
  "vite-tsconfig-paths": "^3.5.2",
  vitest: "^0.24.3",
  "vitest-mock-extended": "^1.0.2"
}, b9 = {
  terser: "npm:@swc/core"
}, x9 = {
  name: a9,
  description: o9,
  version: c9,
  repository: l9,
  author: u9,
  homepage: d9,
  license: f9,
  engines: h9,
  browser: p9,
  scripts: m9,
  dependencies: y9,
  devDependencies: g9,
  resolutions: b9
}, Md = pe.createInterface("BrowserStorageService");
class xp {
  addVersion(e, t) {
    return {
      data: e,
      _version: t
    };
  }
  getKey(e) {
    return `${x9.name}.${e}`;
  }
  set(e, t, r, i) {
    const s = typeof i == "string" ? this.addVersion(r, i) : r;
    e.setItem(this.getKey(t), JSON.stringify(s));
  }
  get(e, t, r, i) {
    const s = e.getItem(this.getKey(t));
    if (typeof s == "string")
      try {
        const a = JSON.parse(s);
        if (typeof i == "string") {
          const o = a;
          return o._version === i ? o.data : r;
        } else
          return a;
      } catch {
        return r;
      }
    return r;
  }
  remove(e, t) {
    e.removeItem(this.getKey(t));
  }
  lsSet(e, t, r) {
    this.set(localStorage, e, t, r);
  }
  lsGet(e, t, r) {
    return this.get(localStorage, e, t, r);
  }
  lsRemove(e) {
    this.remove(localStorage, e);
  }
  ssSet(e, t, r) {
    this.set(sessionStorage, e, t, r);
  }
  ssGet(e, t, r) {
    return this.get(sessionStorage, e, t, r);
  }
  ssRemove(e) {
    this.remove(sessionStorage, e);
  }
  static register(e) {
    fe.singleton(Md, xp).register(e);
  }
}
const Rd = pe.createInterface();
function v9() {
  return fe.instance(Rd, {
    ipfsGateway: o_,
    network: c_,
    isDevelopment: a_,
    etherscanLink: l_
  });
}
var wr = /* @__PURE__ */ ((n) => (n[n["1h"] = 0] = "1h", n[n["1d"] = 1] = "1d", n[n["1w"] = 2] = "1w", n[n["1m"] = 3] = "1m", n[n["1y"] = 4] = "1y", n))(wr || {});
function w9(n, e) {
  if (typeof n != "number" || Number.isInteger(n) || isNaN(n))
    return n;
  const t = n.toString().split(".");
  return Number(`${t[0]}.${t[1].slice(0, e)}`);
}
function gw(n) {
  switch (n) {
    case wr["1d"]:
      return "hour";
    case wr["1h"]:
      return "minute";
    case wr["1m"]:
    case wr["1w"]:
    case wr["1y"]:
      return "day";
  }
}
function bw(n) {
  const e = new Date();
  switch (n) {
    case wr["1h"]:
      e.setMinutes(e.getMinutes() - 60);
      break;
    case wr["1d"]:
      e.setHours(e.getHours() - 24);
      break;
    case wr["1w"]:
      e.setDate(e.getDate() - 7);
      break;
    case wr["1m"]:
      e.setMonth(e.getMonth() - 1);
      break;
    case wr["1y"]:
      e.setFullYear(e.getFullYear() - 1);
      break;
  }
  return e.getTime();
}
var Ha = /* @__PURE__ */ ((n) => (n.Celo = "Celo", n.Alfajores = "Alfajores", n))(Ha || {});
const xw = pe.createInterface();
var A9 = Object.defineProperty, T9 = Object.getOwnPropertyDescriptor, C9 = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? T9(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && A9(e, t, i), i;
}, E9 = (n, e) => (t, r) => e(t, r, n);
const vw = pe.createInterface();
let kb = class {
  constructor(n) {
    this.walletConnector = n;
  }
  provider;
  async connect(n) {
    this.provider = n ? await this.walletConnector.connectTo(n) : await this.walletConnector.connect();
  }
};
kb = C9([
  E9(0, xw)
], kb);
function vp(n) {
  return function(e, t, r) {
    const i = `${e.constructor.name}_${t}`, s = r.value;
    return r.value = function(...a) {
      const { storage: o } = n.call(this), c = `${i}_${JSON.stringify(a)}`;
      let l = o.getItem(c);
      return l || (l = s?.apply(this, a), o.setItem(c, l), l);
    }, r;
  };
}
const Ib = /* @__PURE__ */ new Map([
  [Ha.Celo, 42220],
  [Ha.Alfajores, 44787]
]);
function S9({ mustBeMetaMask: n = !1, silent: e = !1, timeout: t = 3e3 } = {}) {
  i();
  let r = !1;
  return new Promise((s) => {
    window.ethereum ? a() : (window.addEventListener("ethereum#initialized", a, { once: !0 }), setTimeout(() => {
      a();
    }, t));
    function a() {
      if (r)
        return;
      r = !0, window.removeEventListener("ethereum#initialized", a);
      const { ethereum: o } = window;
      o && (!n || o.isMetaMask) ? s(o) : (!e && console.error("@metamask/detect-provider:", n && o ? "Non-MetaMask window.ethereum detected." : "Unable to detect window.ethereum."), s(null));
    }
  });
  function i() {
    if (typeof n != "boolean")
      throw new Error("@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.");
    if (typeof e != "boolean")
      throw new Error("@metamask/detect-provider: Expected option 'silent' to be a boolean.");
    if (typeof t != "number")
      throw new Error("@metamask/detect-provider: Expected option 'timeout' to be a number.");
  }
}
var _9 = S9, P9 = Object.defineProperty, M9 = Object.getOwnPropertyDescriptor, ww = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? M9(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && P9(e, t, i), i;
}, Pa = (n, e) => (t, r) => e(t, r, n);
const ll = pe.createInterface("EthereumService");
let no = class {
  constructor(n, e, t, r, i, s) {
    this.eventAggregator = n, this.storageService = e, this.logger = t, this.configuration = r, this.cacheService = i, this.walletProvider = s, this.logger = t.scopeTo("EthereumService"), this.initialize();
  }
  static register(n) {
    fe.singleton(ll, no).register(n);
  }
  targetedNetwork = null;
  targetedChainId;
  lastBlock;
  readOnlyProvider = {};
  providerForCeloWithEthers = {};
  currentProvider;
  defaultAccountAddress = null;
  defaultAccount;
  endpoints = {
    Celo: "https://celo.rpcs.dev:8545",
    Alfajores: "https://alfajores.rpcs.dev:8545"
  };
  initialize() {
    if (typeof this.configuration.network != "string")
      throw new Error("Ethereum.initialize: network must be specified");
    if (this.targetedNetwork = this.configuration.network, this.targetedChainId = Ib.get(this.targetedNetwork), !Ib.get(this.configuration.network))
      throw new Error("Ethereum.initialize: `unsupported network");
    if (typeof this.endpoints[this.targetedNetwork] != "string")
      throw new Error(`Please connect your wallet to either ${Ha.Celo} or ${Ha.Alfajores}`);
    this.readOnlyProvider = new bp(
      { url: this.endpoints[this.targetedNetwork], skipFetchSetup: !0 },
      {
        name: this.targetedNetwork.toLowerCase(),
        chainId: this.targetedChainId ?? 0
      }
    ), this.providerForCeloWithEthers = new s9(
      { url: this.endpoints[this.targetedNetwork], skipFetchSetup: !0 },
      {
        name: this.targetedNetwork.toLowerCase(),
        chainId: this.targetedChainId ?? 0
      }
    );
  }
  async getCurrentAccountFromProvider(n) {
    let e;
    if (os.isSigner(n))
      e = n;
    else {
      const t = await n.listAccounts();
      t?.length ? e = Rt(t[0]) : e = null;
    }
    return e;
  }
  fireAccountsChangedHandler(n) {
    this.logger.info(`account changed: ${n ?? "null"}`), this.eventAggregator.publish("Network.Changed.Account", n);
  }
  fireChainChangedHandler(n) {
    this.logger.info(`chain changed: ${n.chainId ?? "undefined"}`), this.eventAggregator.publish("Network.Changed.Id", n);
  }
  fireConnectHandler(n) {
    this.logger.info(`connected: ${n.chainName ?? "undefined"}`), this.eventAggregator.publish("Network.Changed.Connected", n);
  }
  fireDisconnectHandler(n) {
    this.logger.info(`disconnected: ${n.code}: ${n.message}`), this.eventAggregator.publish("Network.Changed.Disconnect", n);
  }
  async getDefaultAccountAddress() {
    if (!this.defaultAccount)
      throw new Error("getDefaultAccountAddress: no defaultAccount");
    return os.isSigner(this.defaultAccount) ? await this.defaultAccount.getAddress() : Rt(this.defaultAccount);
  }
  createSignerOrProvider() {
    return this.createSignerOrProviderForAddress(this.defaultAccountAddress);
  }
  createSignerOrProviderForAddress(n) {
    let e;
    return n && this.currentProvider ? e = os.isSigner(n) ? n : this.currentProvider.getSigner(n) : e = this.readOnlyProvider, e;
  }
  getDefaultSigner() {
    if (!this.defaultAccountAddress)
      throw new Error("getDefaultSigner: no defaultAccountAddress");
    if (!this.currentProvider)
      throw new Error("getDefaultSigner: no walletProvider");
    return this.currentProvider.getSigner(this.defaultAccountAddress);
  }
  async connect() {
    await this.walletProvider.connect(), this.setProvider();
  }
  async connectKolektivoWallet() {
    await this.walletProvider.connect("walletconnect"), this.setProvider();
  }
  ensureConnected() {
    return this.defaultAccountAddress ? !0 : (this.connect(), !1);
  }
  async connectToConnectedProvider() {
    const n = await _9({ mustBeMetaMask: !0 });
    if (!(!n || !await n._metamask.isUnlocked() || Number(await n.request({ method: "eth_chainId" })) !== this.targetedChainId) && !!(await n.request({ method: "eth_accounts" })).length)
      return this.walletProvider.provider = n, this.setProvider();
  }
  cleanNetworkName(n) {
    if (n) {
      const e = Object.assign(n);
      return e.name === "homestead" ? e.name = "Ethereum Mainnet" : e.name === "unknown" && (e.chainId == this.targetedChainId ? e.name = this.targetedNetwork ?? "" : e.name = ""), e;
    }
    return null;
  }
  async getNetwork(n) {
    const e = await n.getNetwork();
    return this.cleanNetworkName(e);
  }
  async setProvider() {
    try {
      if (!this.walletProvider.provider)
        return;
      const n = new j_(this.walletProvider.provider), e = await this.getNetwork(n);
      if (!e)
        return;
      e.chainId !== this.targetedChainId ? this.eventAggregator.publish("Network.wrongNetwork", {
        connectedTo: e.name,
        need: this.targetedNetwork
      }) : (this.currentProvider = n, this.defaultAccount = await this.getCurrentAccountFromProvider(this.currentProvider), this.defaultAccountAddress = await this.getDefaultAccountAddress(), this.fireConnectHandler({ chainId: e.chainId, chainName: e.name, provider: this.currentProvider }), this.fireAccountsChangedHandler(this.defaultAccountAddress), this.walletProvider.provider.on("accountsChanged", (t) => void this.handleAccountsChanged(t)), this.walletProvider.provider.on("chainChanged", this.handleChainChanged), this.walletProvider.provider.on("disconnect", (t) => this.handleDisconnect(t)));
    } catch (n) {
      this.logger.error(`Error connecting to wallet provider ${n?.message}`), alert(`Error connecting to wallet provider ${n?.message}`);
    }
  }
  async handleAccountsChanged(n) {
    this.currentProvider && (this.defaultAccount = await this.getCurrentAccountFromProvider(this.currentProvider), this.defaultAccountAddress = await this.getDefaultAccountAddress(), this.fireAccountsChangedHandler(n?.length ? Rt(n[0]) : null));
  }
  handleChainChanged = (n) => {
    let e = sw(Number(n));
    if (e = this.cleanNetworkName(e), !!e)
      if (e.chainId !== this.targetedChainId) {
        this.eventAggregator.publish("Network.wrongNetwork", {
          connectedTo: e.name,
          need: this.targetedNetwork
        });
        return;
      } else
        this.fireChainChangedHandler({ chainId: e.chainId, chainName: e.name, provider: this.currentProvider ?? null });
  };
  handleDisconnect = (n) => {
    this.disconnect(n);
  };
  disconnect(n) {
    this.walletProvider.provider?.removeListener("accountsChanged", (e) => void this.handleAccountsChanged(e)), this.walletProvider.provider?.removeListener("chainChanged", this.handleChainChanged), this.walletProvider.provider?.removeListener("disconnect", this.handleDisconnect), this.defaultAccount = void 0, this.defaultAccountAddress = null, this.fireAccountsChangedHandler(null), this.currentProvider = void 0, this.fireDisconnectHandler(n);
  }
  async switchToTargetedNetwork() {
    if (typeof this.targetedChainId != "number")
      return !1;
    const n = `0x${this.targetedChainId.toString(16)}`;
    try {
      return await this.walletProvider.provider?.request?.({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: n }]
      }), await this.setProvider(), !0;
    } catch (e) {
      if (e.code !== 4001) {
        if (e.code === 4902)
          throw new Error(`The ${this.targetedNetwork ?? "unknown"} network is not installed in your Metamask configuration`);
      }
    }
    return !1;
  }
  async addTokenToMetamask(n, e, t, r) {
    let i = !1;
    if (this.currentProvider) {
      if (this.getMetamaskHasToken(n))
        return !0;
      try {
        i = await this.walletProvider.provider?.request?.({
          method: "wallet_watchAsset",
          params: [
            {
              type: "ERC20",
              options: {
                address: n,
                symbol: e,
                decimals: t,
                image: r
              }
            }
          ]
        }), i && this.setMetamaskHasToken(n);
      } catch (s) {
        this.logger.error(s);
      }
    }
    return i;
  }
  getMetamaskHasToken(n) {
    if (!this.defaultAccountAddress)
      throw new Error("metamaskHasToken: no account");
    return !!this.storageService.lsGet(this.getKeyForMetamaskHasToken(n));
  }
  getKeyForMetamaskHasToken(n) {
    if (!this.defaultAccountAddress)
      throw new Error("getKeyForMetamaskHasToken: no account");
    return `${this.defaultAccountAddress}_${n}`;
  }
  setMetamaskHasToken(n) {
    if (!this.defaultAccountAddress)
      throw new Error("metamaskHasToken: no account");
    this.storageService.lsSet(this.getKeyForMetamaskHasToken(n), !0);
  }
  async getBlock(n) {
    const e = await this.providerForCeloWithEthers.getBlock(n);
    return e.blockDate = new Date(e.timestamp * 1e3), e;
  }
  getEtherscanLink(n, e = !1) {
    return n ? this.targetedNetwork === Ha.Celo ? `https://celoscan.io/${e ? "tx" : "address"}/${n}` : `https://alfajores-blockscout.celo-testnet.org/${e ? "tx" : "address"}/${n}` : "";
  }
  getEnsForAddress(n) {
    return this.readOnlyProvider.lookupAddress(n).catch(() => null);
  }
  getAddressForEns(n) {
    return this.readOnlyProvider.resolveName(n).catch(() => null);
  }
};
ww([
  vp(function() {
    return { storage: this.cacheService };
  })
], no.prototype, "createSignerOrProviderForAddress", 1);
no = ww([
  Pa(0, ud),
  Pa(1, Md),
  Pa(2, pa),
  Pa(3, Rd),
  Pa(4, xo),
  Pa(5, vw)
], no);
const Ob = (n, e) => {
  const t = typeof n;
  return (t === "string" || t === "number") && (n = w9(Number(n), Number(e))), Z_(n.toString(), e);
}, nn = (n, e) => X_(n.toString(), e);
var R9 = Object.defineProperty, k9 = Object.getOwnPropertyDescriptor, Aw = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? k9(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && R9(e, t, i), i;
}, Db = (n, e) => (t, r) => e(t, r, n);
const So = pe.createInterface();
let ro = class {
  constructor(n, e) {
    this.cacheService = n, this.ethereumService = e;
  }
  static register(n) {
    fe.singleton(So, ro).register(n);
  }
  callPopulateTransaction(n, e, ...t) {
    return n.populateTransaction[e].call(t);
  }
  getContract(n, e, t) {
    return this.getContractForAccount(this.ethereumService.defaultAccountAddress, n, e, t);
  }
  async getContractForProvider(n, e, t, r) {
    const a = (await Pg(/* @__PURE__ */ Object.assign({ "../../contracts/governance/alfajores.json": () => Promise.resolve().then(() => wI), "../../contracts/map/alfajores.json": () => Promise.resolve().then(() => TI), "../../contracts/monetary/alfajores.json": () => Promise.resolve().then(() => EI) }), `../../contracts/${e}/alfajores.json`)).contracts[t];
    let o = a.abi;
    if (typeof o == "string") {
      const c = o;
      o = await this.getSharedAbi(e, c);
    }
    if (r = r ?? a.address, !r)
      throw new Error(`ContractService: requested contract has no address: ${t}`);
    return new iw(r, o, n);
  }
  async getSharedAbi(n, e) {
    return (await Pg(/* @__PURE__ */ Object.assign({ "../../contracts/governance/sharedAbis.json": () => Promise.resolve().then(() => _I), "../../contracts/map/sharedAbis.json": () => Promise.resolve().then(() => MI), "../../contracts/monetary/sharedAbis.json": () => Promise.resolve().then(() => kI) }), `../../contracts/${n}/sharedAbis.json`))[e];
  }
  getContractForAccount(n, e, t, r) {
    const i = this.ethereumService.createSignerOrProviderForAddress(n);
    return this.getContractForProvider(i, e, t, r);
  }
};
Aw([
  vp(function() {
    return { storage: this.cacheService };
  })
], ro.prototype, "getContractForAccount", 1);
ro = Aw([
  Db(0, xo),
  Db(1, ll)
], ro);
var Zi = /* @__PURE__ */ ((n) => (n[n.NonStablecoin = 0] = "NonStablecoin", n[n.Stablecoin = 1] = "Stablecoin", n[n.Ecological = 2] = "Ecological", n))(Zi || {});
const Tw = pe.createInterface();
var jh = /* @__PURE__ */ ((n) => (n[n.MONETARY_CONTROLLER = 1] = "MONETARY_CONTROLLER", n[n.RESERVE_DELEGATE = 2] = "RESERVE_DELEGATE", n[n.RESERVE_VETO_DELEGATE = 3] = "RESERVE_VETO_DELEGATE", n[n.TOPOLOGY_DELEGATE = 4] = "TOPOLOGY_DELEGATE", n[n.ECOLOGY_DELEGATE = 5] = "ECOLOGY_DELEGATE", n[n.ECOLOGY_DELEGATE_PROPOSER = 6] = "ECOLOGY_DELEGATE_PROPOSER", n[n.RESERVE_ARBITRAGEUR = 7] = "RESERVE_ARBITRAGEUR", n[n.LOCAL_MULTI_SIG_MEMBER = 8] = "LOCAL_MULTI_SIG_MEMBER", n[n.TREASURY_DELEGATE = 101] = "TREASURY_DELEGATE", n[n.TREASURY_VETO_DELEGATE = 102] = "TREASURY_VETO_DELEGATE", n[n.TREASURY_ARBITRAGEUR = 103] = "TREASURY_ARBITRAGEUR", n[n.KOLEKTIVO_MULTI_SIG_MEMBER = 104] = "KOLEKTIVO_MULTI_SIG_MEMBER", n))(jh || {});
const I9 = pe.createInterface();
var O9 = Object.defineProperty, D9 = Object.getOwnPropertyDescriptor, N9 = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? D9(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && O9(e, t, i), i;
}, zf = (n, e) => (t, r) => e(t, r, n);
const Cw = pe.createInterface("EncryptionService");
let Nu = class {
  constructor(n, e, t) {
    this.logger = n, this.ethereumService = e, this.container = t;
  }
  client;
  static register(n) {
    fe.singleton(Cw, Nu).register(n);
  }
  authSig;
  encryptedSymmetricKey;
  badgerContractAddress = "";
  get chain() {
    return this.ethereumService.targetedNetwork?.toLowerCase() ?? "";
  }
  getAccessControlConditions(n) {
    return [
      {
        contractAddress: n,
        standardContractType: "ERC1155",
        chain: this.chain,
        method: "balanceOfBatch",
        parameters: [":userAddress,:userAddress", `${jh.RESERVE_DELEGATE},${jh.ECOLOGY_DELEGATE_PROPOSER}`],
        returnValueTest: {
          comparator: ">",
          value: "0"
        }
      }
    ];
  }
  async connect() {
    if (this.client)
      return;
    const n = await this.container.get(I9);
    return this.client = n, await this.client.connect();
  }
  async encrypt(n) {
    if (!this.ethereumService.currentProvider || !this.ethereumService.defaultAccountAddress || !this.ethereumService.targetedChainId || (await this.connect(), !this.client))
      return;
    const e = {
      web3: this.ethereumService.currentProvider,
      account: this.ethereumService.defaultAccountAddress,
      chainId: this.ethereumService.targetedChainId,
      expiration: new Date(Date.now() + 3e5)
    };
    this.authSig = await this.client.getAuthSig(e);
    const { encryptedString: t, symmetricKey: r } = await this.client.encryptString(n);
    return this.encryptedSymmetricKey = this.client.uint8arrayToString(
      await this.client.saveEncryptionKey({
        accessControlConditions: this.getAccessControlConditions(this.badgerContractAddress),
        symmetricKey: r,
        authSig: this.authSig,
        chain: this.chain
      }),
      "base16"
    ), { encryptedString: t, symmetricKey: r };
  }
  async decryptAs(n) {
    if (await this.connect(), !this.client)
      throw new Error("No encryption client connected");
    const e = await this.client.getEncryptionKey({
      accessControlConditions: this.getAccessControlConditions(this.badgerContractAddress),
      toDecrypt: this.encryptedSymmetricKey,
      chain: this.chain,
      authSig: this.authSig
    }), t = await this.client.decryptString(n, e);
    try {
      return JSON.parse(t);
    } catch {
      this.logger.info("Failed to parse data from LIT");
    }
    return t;
  }
};
Nu = N9([
  zf(0, pa),
  zf(1, ll),
  zf(2, lo)
], Nu);
var B9 = Object.defineProperty, $9 = Object.getOwnPropertyDescriptor, L9 = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? $9(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && B9(e, t, i), i;
}, F9 = (n, e) => (t, r) => e(t, r, n);
const Ew = pe.createInterface(), wp = pe.createInterface();
let Pc = class {
  constructor(n) {
    this.container = n;
  }
  static register(n) {
    n.register(fe.singleton(wp, Pc));
  }
  fireStore;
  async connect() {
    const { getFirestore: n } = await Promise.resolve().then(() => kx);
    return this.fireStore ??= n(await this.container.get(Ew)), this.fireStore;
  }
  async getDocs(n, e, t, r) {
    const { getDocs: i, query: s, collection: a, where: o, orderBy: c } = await Promise.resolve().then(() => kx);
    return (await i(
      s(a(await this.connect(), n), o(r.fieldPath, r.opStr, r.value), c(e, t))
    )).docs.map((f) => f.data());
  }
};
Pc = L9([
  F9(0, lo)
], Pc);
var U9 = Object.defineProperty, V9 = Object.getOwnPropertyDescriptor, j9 = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? V9(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && U9(e, t, i), i;
}, G9 = (n, e) => (t, r) => e(t, r, n);
const Sw = pe.createInterface("HttpService"), _w = { accept: "application/json" }, W9 = { "content-type": "application/json", ..._w };
let Bu = class {
  constructor(n) {
    this.logger = n, this.logger = n.scopeTo("HttpService");
  }
  static register(n) {
    n.register(fe.singleton(Sw, Bu));
  }
  async call(n, e, t) {
    const r = await fetch(n, {
      body: e,
      method: e ? "POST" : "GET",
      headers: e ? W9 : _w,
      ...t
    });
    if (r.ok)
      return await r.json();
    const i = new Error(await r.text());
    return this.logger.error({ response: r, error: i }), Promise.reject(i);
  }
};
Bu = j9([
  G9(0, pa)
], Bu);
const H9 = pe.createInterface();
var z9 = Object.defineProperty, K9 = Object.getOwnPropertyDescriptor, q9 = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? K9(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && z9(e, t, i), i;
}, Q9 = (n, e) => (t, r) => e(t, r, n);
const Ap = pe.createInterface();
let $u = class {
  constructor(n) {
    this.client = n;
  }
  static register(n) {
    n.register(fe.singleton(Ap, $u));
  }
  async all(n) {
    const e = [];
    for await (const t of n)
      e.push(t);
    return e;
  }
  save(n, e = !0) {
    return typeof n == "string" ? this.client.add(
      { content: n },
      {
        pin: e
      }
    ).then((t) => t.cid) : this.client.dag.put(n, {
      pin: e
    });
  }
  async get(n, e = !1, t) {
    const r = (await Promise.resolve().then(() => mO)).CID.asCID(n);
    if (!!r) {
      if (!e) {
        const i = this.client.cat(n), s = (await Promise.resolve().then(() => gO)).concat(await this.all(i));
        return (await Promise.resolve().then(() => VD)).toString(s);
      }
      return JSON.stringify((await this.client.dag.get(r, { path: t })).value);
    }
  }
};
$u = q9([
  Q9(0, H9)
], $u);
function cs(n) {
  return cs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, cs(n);
}
function J9(n, e, t) {
  return e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Mn(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {}, r = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && r.push.apply(r, Object.getOwnPropertySymbols(t).filter(function(i) {
      return Object.getOwnPropertyDescriptor(t, i).enumerable;
    })), r.forEach(function(i) {
      J9(n, i, t[i]);
    });
  }
  return n;
}
function Bi(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Nb(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, r.key, r);
  }
}
function $i(n, e, t) {
  return e && Nb(n.prototype, e), t && Nb(n, t), Object.defineProperty(n, "prototype", {
    writable: !1
  }), n;
}
function sa(n) {
  if (n === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function Mc(n, e) {
  if (e && (cs(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return sa(n);
}
function io(n) {
  return io = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, io(n);
}
function Gh(n, e) {
  return Gh = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, i) {
    return r.__proto__ = i, r;
  }, Gh(n, e);
}
function kd(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  n.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: n,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(n, "prototype", {
    writable: !1
  }), e && Gh(n, e);
}
function Wh(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++)
    r[t] = n[t];
  return r;
}
function Y9(n) {
  if (Array.isArray(n))
    return Wh(n);
}
function X9(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
    return Array.from(n);
}
function Pw(n, e) {
  if (!!n) {
    if (typeof n == "string")
      return Wh(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return Wh(n, e);
  }
}
function Z9() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function eP(n) {
  return Y9(n) || X9(n) || Pw(n) || Z9();
}
function tP(n) {
  if (Array.isArray(n))
    return n;
}
function nP(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var r = [], i = !0, s = !1, a, o;
    try {
      for (t = t.call(n); !(i = (a = t.next()).done) && (r.push(a.value), !(e && r.length === e)); i = !0)
        ;
    } catch (c) {
      s = !0, o = c;
    } finally {
      try {
        !i && t.return != null && t.return();
      } finally {
        if (s)
          throw o;
      }
    }
    return r;
  }
}
function rP() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Bb(n, e) {
  return tP(n) || nP(n, e) || Pw(n, e) || rP();
}
var iP = {
  type: "logger",
  log: function(e) {
    this.output("log", e);
  },
  warn: function(e) {
    this.output("warn", e);
  },
  error: function(e) {
    this.output("error", e);
  },
  output: function(e, t) {
    var r;
    console && console[e] && (r = console)[e].apply(r, eP(t));
  }
}, sP = /* @__PURE__ */ function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Bi(this, n), this.init(e, t);
  }
  return $i(n, [{
    key: "init",
    value: function(t) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = r.prefix || "i18next:", this.logger = t || iP, this.options = r, this.debug = r.debug;
    }
  }, {
    key: "setDebug",
    value: function(t) {
      this.debug = t;
    }
  }, {
    key: "log",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
        r[i] = arguments[i];
      return this.forward(r, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(t, r, i, s) {
      return s && !this.debug ? null : (typeof t[0] == "string" && (t[0] = "".concat(i).concat(this.prefix, " ").concat(t[0])), this.logger[r](t));
    }
  }, {
    key: "create",
    value: function(t) {
      return new n(this.logger, Mn({}, {
        prefix: "".concat(this.prefix, ":").concat(t, ":")
      }, this.options));
    }
  }]), n;
}(), mi = new sP(), ps = /* @__PURE__ */ function() {
  function n() {
    Bi(this, n), this.observers = {};
  }
  return $i(n, [{
    key: "on",
    value: function(t, r) {
      var i = this;
      return t.split(" ").forEach(function(s) {
        i.observers[s] = i.observers[s] || [], i.observers[s].push(r);
      }), this;
    }
  }, {
    key: "off",
    value: function(t, r) {
      if (!!this.observers[t]) {
        if (!r) {
          delete this.observers[t];
          return;
        }
        this.observers[t] = this.observers[t].filter(function(i) {
          return i !== r;
        });
      }
    }
  }, {
    key: "emit",
    value: function(t) {
      for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), s = 1; s < r; s++)
        i[s - 1] = arguments[s];
      if (this.observers[t]) {
        var a = [].concat(this.observers[t]);
        a.forEach(function(c) {
          c.apply(void 0, i);
        });
      }
      if (this.observers["*"]) {
        var o = [].concat(this.observers["*"]);
        o.forEach(function(c) {
          c.apply(c, [t].concat(i));
        });
      }
    }
  }]), n;
}();
function Uo() {
  var n, e, t = new Promise(function(r, i) {
    n = r, e = i;
  });
  return t.resolve = n, t.reject = e, t;
}
function Kf(n) {
  return n == null ? "" : "" + n;
}
function aP(n, e, t) {
  n.forEach(function(r) {
    e[r] && (t[r] = e[r]);
  });
}
function Tp(n, e, t) {
  function r(o) {
    return o && o.indexOf("###") > -1 ? o.replace(/###/g, ".") : o;
  }
  function i() {
    return !n || typeof n == "string";
  }
  for (var s = typeof e != "string" ? [].concat(e) : e.split("."); s.length > 1; ) {
    if (i())
      return {};
    var a = r(s.shift());
    !n[a] && t && (n[a] = new t()), n = n[a];
  }
  return i() ? {} : {
    obj: n,
    k: r(s.shift())
  };
}
function $b(n, e, t) {
  var r = Tp(n, e, Object), i = r.obj, s = r.k;
  i[s] = t;
}
function oP(n, e, t, r) {
  var i = Tp(n, e, Object), s = i.obj, a = i.k;
  s[a] = s[a] || [], r && (s[a] = s[a].concat(t)), r || s[a].push(t);
}
function Lu(n, e) {
  var t = Tp(n, e), r = t.obj, i = t.k;
  if (!!r)
    return r[i];
}
function Lb(n, e, t) {
  var r = Lu(n, t);
  return r !== void 0 ? r : Lu(e, t);
}
function Mw(n, e, t) {
  for (var r in e)
    r in n ? typeof n[r] == "string" || n[r] instanceof String || typeof e[r] == "string" || e[r] instanceof String ? t && (n[r] = e[r]) : Mw(n[r], e[r], t) : n[r] = e[r];
  return n;
}
function Ma(n) {
  return n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var cP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function lP(n) {
  return typeof n == "string" ? n.replace(/[&<>"'\/]/g, function(e) {
    return cP[e];
  }) : n;
}
var uP = /* @__PURE__ */ function(n) {
  kd(e, n);
  function e(t) {
    var r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return Bi(this, e), r = Mc(this, io(e).call(this)), ps.call(sa(r)), r.data = t || {}, r.options = i, r.options.keySeparator === void 0 && (r.options.keySeparator = "."), r;
  }
  return $i(e, [{
    key: "addNamespaces",
    value: function(r) {
      this.options.ns.indexOf(r) < 0 && this.options.ns.push(r);
    }
  }, {
    key: "removeNamespaces",
    value: function(r) {
      var i = this.options.ns.indexOf(r);
      i > -1 && this.options.ns.splice(i, 1);
    }
  }, {
    key: "getResource",
    value: function(r, i, s) {
      var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, o = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator, c = [r, i];
      return s && typeof s != "string" && (c = c.concat(s)), s && typeof s == "string" && (c = c.concat(o ? s.split(o) : s)), r.indexOf(".") > -1 && (c = r.split(".")), Lu(this.data, c);
    }
  }, {
    key: "addResource",
    value: function(r, i, s, a) {
      var o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, c = this.options.keySeparator;
      c === void 0 && (c = ".");
      var l = [r, i];
      s && (l = l.concat(c ? s.split(c) : s)), r.indexOf(".") > -1 && (l = r.split("."), a = i, i = l[1]), this.addNamespaces(i), $b(this.data, l, a), o.silent || this.emit("added", r, i, s, a);
    }
  }, {
    key: "addResources",
    value: function(r, i, s) {
      var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var o in s)
        (typeof s[o] == "string" || Object.prototype.toString.apply(s[o]) === "[object Array]") && this.addResource(r, i, o, s[o], {
          silent: !0
        });
      a.silent || this.emit("added", r, i, s);
    }
  }, {
    key: "addResourceBundle",
    value: function(r, i, s, a, o) {
      var c = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, l = [r, i];
      r.indexOf(".") > -1 && (l = r.split("."), a = s, s = i, i = l[1]), this.addNamespaces(i);
      var f = Lu(this.data, l) || {};
      a ? Mw(f, s, o) : f = Mn({}, f, s), $b(this.data, l, f), c.silent || this.emit("added", r, i, s);
    }
  }, {
    key: "removeResourceBundle",
    value: function(r, i) {
      this.hasResourceBundle(r, i) && delete this.data[r][i], this.removeNamespaces(i), this.emit("removed", r, i);
    }
  }, {
    key: "hasResourceBundle",
    value: function(r, i) {
      return this.getResource(r, i) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(r, i) {
      return i || (i = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? Mn({}, {}, this.getResource(r, i)) : this.getResource(r, i);
    }
  }, {
    key: "getDataByLanguage",
    value: function(r) {
      return this.data[r];
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), e;
}(ps), Rw = {
  processors: {},
  addPostProcessor: function(e) {
    this.processors[e.name] = e;
  },
  handle: function(e, t, r, i, s) {
    var a = this;
    return e.forEach(function(o) {
      a.processors[o] && (t = a.processors[o].process(t, r, i, s));
    }), t;
  }
}, Fb = /* @__PURE__ */ function(n) {
  kd(e, n);
  function e(t) {
    var r, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Bi(this, e), r = Mc(this, io(e).call(this)), ps.call(sa(r)), aP(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, sa(r)), r.options = i, r.options.keySeparator === void 0 && (r.options.keySeparator = "."), r.logger = mi.create("translator"), r;
  }
  return $i(e, [{
    key: "changeLanguage",
    value: function(r) {
      r && (this.language = r);
    }
  }, {
    key: "exists",
    value: function(r) {
      var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, s = this.resolve(r, i);
      return s && s.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(r, i) {
      var s = i.nsSeparator || this.options.nsSeparator;
      s === void 0 && (s = ":");
      var a = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, o = i.ns || this.options.defaultNS;
      if (s && r.indexOf(s) > -1) {
        var c = r.split(s);
        (s !== a || s === a && this.options.ns.indexOf(c[0]) > -1) && (o = c.shift()), r = c.join(a);
      }
      return typeof o == "string" && (o = [o]), {
        key: r,
        namespaces: o
      };
    }
  }, {
    key: "translate",
    value: function(r, i) {
      var s = this;
      if (cs(i) !== "object" && this.options.overloadTranslationOptionHandler && (i = this.options.overloadTranslationOptionHandler(arguments)), i || (i = {}), r == null)
        return "";
      Array.isArray(r) || (r = [String(r)]);
      var a = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, o = this.extractFromKey(r[r.length - 1], i), c = o.key, l = o.namespaces, f = l[l.length - 1], p = i.lng || this.language, g = i.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (p && p.toLowerCase() === "cimode") {
        if (g) {
          var T = i.nsSeparator || this.options.nsSeparator;
          return f + T + c;
        }
        return c;
      }
      var v = this.resolve(r, i), w = v && v.res, C = v && v.usedKey || c, _ = v && v.exactUsedKey || c, I = Object.prototype.toString.apply(w), B = ["[object Number]", "[object Function]", "[object RegExp]"], N = i.joinArrays !== void 0 ? i.joinArrays : this.options.joinArrays, D = !this.i18nFormat || this.i18nFormat.handleAsObject, U = typeof w != "string" && typeof w != "boolean" && typeof w != "number";
      if (D && w && U && B.indexOf(I) < 0 && !(typeof N == "string" && I === "[object Array]")) {
        if (!i.returnObjects && !this.options.returnObjects)
          return this.logger.warn("accessing an object - but returnObjects options is not enabled!"), this.options.returnedObjectHandler ? this.options.returnedObjectHandler(C, w, i) : "key '".concat(c, " (").concat(this.language, ")' returned an object instead of string.");
        if (a) {
          var W = I === "[object Array]", j = W ? [] : {}, q = W ? _ : C;
          for (var ce in w)
            if (Object.prototype.hasOwnProperty.call(w, ce)) {
              var re = "".concat(q).concat(a).concat(ce);
              j[ce] = this.translate(re, Mn({}, i, {
                joinArrays: !1,
                ns: l
              })), j[ce] === re && (j[ce] = w[ce]);
            }
          w = j;
        }
      } else if (D && typeof N == "string" && I === "[object Array]")
        w = w.join(N), w && (w = this.extendTranslation(w, r, i));
      else {
        var me = !1, S = !1;
        if (!this.isValidLookup(w) && i.defaultValue !== void 0) {
          if (me = !0, i.count !== void 0) {
            var d = this.pluralResolver.getSuffix(p, i.count);
            w = i["defaultValue".concat(d)];
          }
          w || (w = i.defaultValue);
        }
        this.isValidLookup(w) || (S = !0, w = c);
        var m = i.defaultValue && i.defaultValue !== w && this.options.updateMissing;
        if (S || me || m) {
          this.logger.log(m ? "updateKey" : "missingKey", p, f, c, m ? i.defaultValue : w);
          var x = [], E = this.languageUtils.getFallbackCodes(this.options.fallbackLng, i.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && E && E[0])
            for (var A = 0; A < E.length; A++)
              x.push(E[A]);
          else
            this.options.saveMissingTo === "all" ? x = this.languageUtils.toResolveHierarchy(i.lng || this.language) : x.push(i.lng || this.language);
          var P = function(u, b) {
            s.options.missingKeyHandler ? s.options.missingKeyHandler(u, f, b, m ? i.defaultValue : w, m, i) : s.backendConnector && s.backendConnector.saveMissing && s.backendConnector.saveMissing(u, f, b, m ? i.defaultValue : w, m, i), s.emit("missingKey", u, f, b, w);
          };
          if (this.options.saveMissing) {
            var R = i.count !== void 0 && typeof i.count != "string";
            this.options.saveMissingPlurals && R ? x.forEach(function(y) {
              var u = s.pluralResolver.getPluralFormsOfKey(y, c);
              u.forEach(function(b) {
                return P([y], b);
              });
            }) : P(x, c);
          }
        }
        w = this.extendTranslation(w, r, i, v), S && w === c && this.options.appendNamespaceToMissingKey && (w = "".concat(f, ":").concat(c)), S && this.options.parseMissingKeyHandler && (w = this.options.parseMissingKeyHandler(w));
      }
      return w;
    }
  }, {
    key: "extendTranslation",
    value: function(r, i, s, a) {
      var o = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        r = this.i18nFormat.parse(r, s, a.usedLng, a.usedNS, a.usedKey, {
          resolved: a
        });
      else if (!s.skipInterpolation) {
        s.interpolation && this.interpolator.init(Mn({}, s, {
          interpolation: Mn({}, this.options.interpolation, s.interpolation)
        }));
        var c = s.replace && typeof s.replace != "string" ? s.replace : s;
        this.options.interpolation.defaultVariables && (c = Mn({}, this.options.interpolation.defaultVariables, c)), r = this.interpolator.interpolate(r, c, s.lng || this.language, s), s.nest !== !1 && (r = this.interpolator.nest(r, function() {
          return o.translate.apply(o, arguments);
        }, s)), s.interpolation && this.interpolator.reset();
      }
      var l = s.postProcess || this.options.postProcess, f = typeof l == "string" ? [l] : l;
      return r != null && f && f.length && s.applyPostProcessor !== !1 && (r = Rw.handle(f, r, i, this.options && this.options.postProcessPassResolved ? Mn({
        i18nResolved: a
      }, s) : s, this)), r;
    }
  }, {
    key: "resolve",
    value: function(r) {
      var i = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a, o, c, l, f;
      return typeof r == "string" && (r = [r]), r.forEach(function(p) {
        if (!i.isValidLookup(a)) {
          var g = i.extractFromKey(p, s), T = g.key;
          o = T;
          var v = g.namespaces;
          i.options.fallbackNS && (v = v.concat(i.options.fallbackNS));
          var w = s.count !== void 0 && typeof s.count != "string", C = s.context !== void 0 && typeof s.context == "string" && s.context !== "", _ = s.lngs ? s.lngs : i.languageUtils.toResolveHierarchy(s.lng || i.language, s.fallbackLng);
          v.forEach(function(I) {
            i.isValidLookup(a) || (f = I, i.utils && i.utils.hasLoadedNamespace && !i.utils.hasLoadedNamespace(f) && i.logger.warn('key "'.concat(o, '" for namespace "').concat(f, `" won't get resolved as namespace was not yet loaded`), "This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"), _.forEach(function(B) {
              if (!i.isValidLookup(a)) {
                l = B;
                var N = T, D = [N];
                if (i.i18nFormat && i.i18nFormat.addLookupKeys)
                  i.i18nFormat.addLookupKeys(D, T, B, I, s);
                else {
                  var U;
                  w && (U = i.pluralResolver.getSuffix(B, s.count)), w && C && D.push(N + U), C && D.push(N += "".concat(i.options.contextSeparator).concat(s.context)), w && D.push(N += U);
                }
                for (var W; W = D.pop(); )
                  i.isValidLookup(a) || (c = W, a = i.getResource(B, I, W, s));
              }
            }));
          });
        }
      }), {
        res: a,
        usedKey: o,
        exactUsedKey: c,
        usedLng: l,
        usedNS: f
      };
    }
  }, {
    key: "isValidLookup",
    value: function(r) {
      return r !== void 0 && !(!this.options.returnNull && r === null) && !(!this.options.returnEmptyString && r === "");
    }
  }, {
    key: "getResource",
    value: function(r, i, s) {
      var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(r, i, s, a) : this.resourceStore.getResource(r, i, s, a);
    }
  }]), e;
}(ps);
function qf(n) {
  return n.charAt(0).toUpperCase() + n.slice(1);
}
var dP = /* @__PURE__ */ function() {
  function n(e) {
    Bi(this, n), this.options = e, this.whitelist = this.options.whitelist || !1, this.logger = mi.create("languageUtils");
  }
  return $i(n, [{
    key: "getScriptPartFromCode",
    value: function(t) {
      if (!t || t.indexOf("-") < 0)
        return null;
      var r = t.split("-");
      return r.length === 2 ? null : (r.pop(), this.formatLanguageCode(r.join("-")));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(t) {
      if (!t || t.indexOf("-") < 0)
        return t;
      var r = t.split("-");
      return this.formatLanguageCode(r[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(t) {
      if (typeof t == "string" && t.indexOf("-") > -1) {
        var r = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], i = t.split("-");
        return this.options.lowerCaseLng ? i = i.map(function(s) {
          return s.toLowerCase();
        }) : i.length === 2 ? (i[0] = i[0].toLowerCase(), i[1] = i[1].toUpperCase(), r.indexOf(i[1].toLowerCase()) > -1 && (i[1] = qf(i[1].toLowerCase()))) : i.length === 3 && (i[0] = i[0].toLowerCase(), i[1].length === 2 && (i[1] = i[1].toUpperCase()), i[0] !== "sgn" && i[2].length === 2 && (i[2] = i[2].toUpperCase()), r.indexOf(i[1].toLowerCase()) > -1 && (i[1] = qf(i[1].toLowerCase())), r.indexOf(i[2].toLowerCase()) > -1 && (i[2] = qf(i[2].toLowerCase()))), i.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
    }
  }, {
    key: "isWhitelisted",
    value: function(t) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitWhitelist) && (t = this.getLanguagePartFromCode(t)), !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(t) > -1;
    }
  }, {
    key: "getFallbackCodes",
    value: function(t, r) {
      if (!t)
        return [];
      if (typeof t == "string" && (t = [t]), Object.prototype.toString.apply(t) === "[object Array]")
        return t;
      if (!r)
        return t.default || [];
      var i = t[r];
      return i || (i = t[this.getScriptPartFromCode(r)]), i || (i = t[this.formatLanguageCode(r)]), i || (i = t.default), i || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(t, r) {
      var i = this, s = this.getFallbackCodes(r || this.options.fallbackLng || [], t), a = [], o = function(l) {
        !l || (i.isWhitelisted(l) ? a.push(l) : i.logger.warn("rejecting non-whitelisted language code: ".concat(l)));
      };
      return typeof t == "string" && t.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(t))) : typeof t == "string" && o(this.formatLanguageCode(t)), s.forEach(function(c) {
        a.indexOf(c) < 0 && o(i.formatLanguageCode(c));
      }), a;
    }
  }]), n;
}(), fP = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "id", "ja", "jbo", "ka", "kk", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he"],
  nr: [1, 2, 20, 21],
  fc: 22
}], hP = {
  1: function(e) {
    return Number(e > 1);
  },
  2: function(e) {
    return Number(e != 1);
  },
  3: function(e) {
    return 0;
  },
  4: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  5: function(e) {
    return Number(e === 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5);
  },
  6: function(e) {
    return Number(e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2);
  },
  7: function(e) {
    return Number(e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  8: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3);
  },
  9: function(e) {
    return Number(e >= 2);
  },
  10: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4);
  },
  11: function(e) {
    return Number(e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3);
  },
  12: function(e) {
    return Number(e % 10 != 1 || e % 100 == 11);
  },
  13: function(e) {
    return Number(e !== 0);
  },
  14: function(e) {
    return Number(e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3);
  },
  15: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2);
  },
  16: function(e) {
    return Number(e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2);
  },
  17: function(e) {
    return Number(e == 1 || e % 10 == 1 ? 0 : 1);
  },
  18: function(e) {
    return Number(e == 0 ? 0 : e == 1 ? 1 : 2);
  },
  19: function(e) {
    return Number(e == 1 ? 0 : e === 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3);
  },
  20: function(e) {
    return Number(e == 1 ? 0 : e === 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2);
  },
  21: function(e) {
    return Number(e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0);
  },
  22: function(e) {
    return Number(e === 1 ? 0 : e === 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3);
  }
};
function pP() {
  var n = {};
  return fP.forEach(function(e) {
    e.lngs.forEach(function(t) {
      n[t] = {
        numbers: e.nr,
        plurals: hP[e.fc]
      };
    });
  }), n;
}
var mP = /* @__PURE__ */ function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Bi(this, n), this.languageUtils = e, this.options = t, this.logger = mi.create("pluralResolver"), this.rules = pP();
  }
  return $i(n, [{
    key: "addRule",
    value: function(t, r) {
      this.rules[t] = r;
    }
  }, {
    key: "getRule",
    value: function(t) {
      return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)];
    }
  }, {
    key: "needsPlural",
    value: function(t) {
      var r = this.getRule(t);
      return r && r.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(t, r) {
      var i = this, s = [], a = this.getRule(t);
      return a && a.numbers.forEach(function(o) {
        var c = i.getSuffix(t, o);
        s.push("".concat(r).concat(c));
      }), s;
    }
  }, {
    key: "getSuffix",
    value: function(t, r) {
      var i = this, s = this.getRule(t);
      if (s) {
        var a = s.noAbs ? s.plurals(r) : s.plurals(Math.abs(r)), o = s.numbers[a];
        this.options.simplifyPluralSuffix && s.numbers.length === 2 && s.numbers[0] === 1 && (o === 2 ? o = "plural" : o === 1 && (o = ""));
        var c = function() {
          return i.options.prepend && o.toString() ? i.options.prepend + o.toString() : o.toString();
        };
        return this.options.compatibilityJSON === "v1" ? o === 1 ? "" : typeof o == "number" ? "_plural_".concat(o.toString()) : c() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && s.numbers.length === 2 && s.numbers[0] === 1 ? c() : this.options.prepend && a.toString() ? this.options.prepend + a.toString() : a.toString();
      }
      return this.logger.warn("no plural rule found for: ".concat(t)), "";
    }
  }]), n;
}(), yP = /* @__PURE__ */ function() {
  function n() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Bi(this, n), this.logger = mi.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || function(t) {
      return t;
    }, this.init(e);
  }
  return $i(n, [{
    key: "init",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      t.interpolation || (t.interpolation = {
        escapeValue: !0
      });
      var r = t.interpolation;
      this.escape = r.escape !== void 0 ? r.escape : lP, this.escapeValue = r.escapeValue !== void 0 ? r.escapeValue : !0, this.useRawValueToEscape = r.useRawValueToEscape !== void 0 ? r.useRawValueToEscape : !1, this.prefix = r.prefix ? Ma(r.prefix) : r.prefixEscaped || "{{", this.suffix = r.suffix ? Ma(r.suffix) : r.suffixEscaped || "}}", this.formatSeparator = r.formatSeparator ? r.formatSeparator : r.formatSeparator || ",", this.unescapePrefix = r.unescapeSuffix ? "" : r.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : r.unescapeSuffix || "", this.nestingPrefix = r.nestingPrefix ? Ma(r.nestingPrefix) : r.nestingPrefixEscaped || Ma("$t("), this.nestingSuffix = r.nestingSuffix ? Ma(r.nestingSuffix) : r.nestingSuffixEscaped || Ma(")"), this.maxReplaces = r.maxReplaces ? r.maxReplaces : 1e3, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var t = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(t, "g");
      var r = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(r, "g");
      var i = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(i, "g");
    }
  }, {
    key: "interpolate",
    value: function(t, r, i, s) {
      var a = this, o, c, l, f = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function p(C) {
        return C.replace(/\$/g, "$$$$");
      }
      var g = function(_) {
        if (_.indexOf(a.formatSeparator) < 0)
          return Lb(r, f, _);
        var I = _.split(a.formatSeparator), B = I.shift().trim(), N = I.join(a.formatSeparator).trim();
        return a.format(Lb(r, f, B), N, i);
      };
      this.resetRegExp();
      var T = s && s.missingInterpolationHandler || this.options.missingInterpolationHandler;
      for (l = 0; o = this.regexpUnescape.exec(t); ) {
        if (c = g(o[1].trim()), c === void 0)
          if (typeof T == "function") {
            var v = T(t, o, s);
            c = typeof v == "string" ? v : "";
          } else
            this.logger.warn("missed to pass in variable ".concat(o[1], " for interpolating ").concat(t)), c = "";
        else
          typeof c != "string" && !this.useRawValueToEscape && (c = Kf(c));
        if (t = t.replace(o[0], p(c)), this.regexpUnescape.lastIndex = 0, l++, l >= this.maxReplaces)
          break;
      }
      for (l = 0; o = this.regexp.exec(t); ) {
        if (c = g(o[1].trim()), c === void 0)
          if (typeof T == "function") {
            var w = T(t, o, s);
            c = typeof w == "string" ? w : "";
          } else
            this.logger.warn("missed to pass in variable ".concat(o[1], " for interpolating ").concat(t)), c = "";
        else
          typeof c != "string" && !this.useRawValueToEscape && (c = Kf(c));
        if (c = this.escapeValue ? p(this.escape(c)) : p(c), t = t.replace(o[0], c), this.regexp.lastIndex = 0, l++, l >= this.maxReplaces)
          break;
      }
      return t;
    }
  }, {
    key: "nest",
    value: function(t, r) {
      var i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s, a, o = Mn({}, i);
      o.applyPostProcessor = !1, delete o.defaultValue;
      function c(l, f) {
        if (l.indexOf(",") < 0)
          return l;
        var p = l.split(",");
        l = p.shift();
        var g = p.join(",");
        g = this.interpolate(g, o), g = g.replace(/'/g, '"');
        try {
          o = JSON.parse(g), f && (o = Mn({}, f, o));
        } catch (T) {
          this.logger.error("failed parsing options string in nesting for key ".concat(l), T);
        }
        return delete o.defaultValue, l;
      }
      for (; s = this.nestingRegexp.exec(t); ) {
        if (a = r(c.call(this, s[1].trim(), o), o), a && s[0] === t && typeof a != "string")
          return a;
        typeof a != "string" && (a = Kf(a)), a || (this.logger.warn("missed to resolve ".concat(s[1], " for nesting ").concat(t)), a = ""), t = t.replace(s[0], a), this.regexp.lastIndex = 0;
      }
      return t;
    }
  }]), n;
}();
function gP(n, e) {
  for (var t = n.indexOf(e); t !== -1; )
    n.splice(t, 1), t = n.indexOf(e);
}
var bP = /* @__PURE__ */ function(n) {
  kd(e, n);
  function e(t, r, i) {
    var s, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return Bi(this, e), s = Mc(this, io(e).call(this)), ps.call(sa(s)), s.backend = t, s.store = r, s.services = i, s.languageUtils = i.languageUtils, s.options = a, s.logger = mi.create("backendConnector"), s.state = {}, s.queue = [], s.backend && s.backend.init && s.backend.init(i, a.backend, a), s;
  }
  return $i(e, [{
    key: "queueLoad",
    value: function(r, i, s, a) {
      var o = this, c = [], l = [], f = [], p = [];
      return r.forEach(function(g) {
        var T = !0;
        i.forEach(function(v) {
          var w = "".concat(g, "|").concat(v);
          !s.reload && o.store.hasResourceBundle(g, v) ? o.state[w] = 2 : o.state[w] < 0 || (o.state[w] === 1 ? l.indexOf(w) < 0 && l.push(w) : (o.state[w] = 1, T = !1, l.indexOf(w) < 0 && l.push(w), c.indexOf(w) < 0 && c.push(w), p.indexOf(v) < 0 && p.push(v)));
        }), T || f.push(g);
      }), (c.length || l.length) && this.queue.push({
        pending: l,
        loaded: {},
        errors: [],
        callback: a
      }), {
        toLoad: c,
        pending: l,
        toLoadLanguages: f,
        toLoadNamespaces: p
      };
    }
  }, {
    key: "loaded",
    value: function(r, i, s) {
      var a = r.split("|"), o = Bb(a, 2), c = o[0], l = o[1];
      i && this.emit("failedLoading", c, l, i), s && this.store.addResourceBundle(c, l, s), this.state[r] = i ? -1 : 2;
      var f = {};
      this.queue.forEach(function(p) {
        oP(p.loaded, [c], l), gP(p.pending, r), i && p.errors.push(i), p.pending.length === 0 && !p.done && (Object.keys(p.loaded).forEach(function(g) {
          f[g] || (f[g] = []), p.loaded[g].length && p.loaded[g].forEach(function(T) {
            f[g].indexOf(T) < 0 && f[g].push(T);
          });
        }), p.done = !0, p.errors.length ? p.callback(p.errors) : p.callback());
      }), this.emit("loaded", f), this.queue = this.queue.filter(function(p) {
        return !p.done;
      });
    }
  }, {
    key: "read",
    value: function(r, i, s) {
      var a = this, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 250, l = arguments.length > 5 ? arguments[5] : void 0;
      return r.length ? this.backend[s](r, i, function(f, p) {
        if (f && p && o < 5) {
          setTimeout(function() {
            a.read.call(a, r, i, s, o + 1, c * 2, l);
          }, c);
          return;
        }
        l(f, p);
      }) : l(null, {});
    }
  }, {
    key: "prepareLoading",
    value: function(r, i) {
      var s = this, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), o && o();
      typeof r == "string" && (r = this.languageUtils.toResolveHierarchy(r)), typeof i == "string" && (i = [i]);
      var c = this.queueLoad(r, i, a, o);
      if (!c.toLoad.length)
        return c.pending.length || o(), null;
      c.toLoad.forEach(function(l) {
        s.loadOne(l);
      });
    }
  }, {
    key: "load",
    value: function(r, i, s) {
      this.prepareLoading(r, i, {}, s);
    }
  }, {
    key: "reload",
    value: function(r, i, s) {
      this.prepareLoading(r, i, {
        reload: !0
      }, s);
    }
  }, {
    key: "loadOne",
    value: function(r) {
      var i = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", a = r.split("|"), o = Bb(a, 2), c = o[0], l = o[1];
      this.read(c, l, "read", null, null, function(f, p) {
        f && i.logger.warn("".concat(s, "loading namespace ").concat(l, " for language ").concat(c, " failed"), f), !f && p && i.logger.log("".concat(s, "loaded namespace ").concat(l, " for language ").concat(c), p), i.loaded(r, f, p);
      });
    }
  }, {
    key: "saveMissing",
    value: function(r, i, s, a, o) {
      var c = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(i)) {
        this.logger.warn('did not save key "'.concat(s, '" for namespace "').concat(i, '" as the namespace was not yet loaded'), "This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      this.backend && this.backend.create && this.backend.create(
        r,
        i,
        s,
        a,
        null,
        Mn({}, c, {
          isUpdate: o
        })
      ), !(!r || !r[0]) && this.store.addResource(r[0], i, s, a);
    }
  }]), e;
}(ps);
function xP() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    whitelist: !1,
    nonExplicitWhitelist: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      var t = {};
      if (cs(e[1]) === "object" && (t = e[1]), typeof e[1] == "string" && (t.defaultValue = e[1]), typeof e[2] == "string" && (t.tDescription = e[2]), cs(e[2]) === "object" || cs(e[3]) === "object") {
        var r = e[3] || e[2];
        Object.keys(r).forEach(function(i) {
          t[i] = r[i];
        });
      }
      return t;
    },
    interpolation: {
      escapeValue: !0,
      format: function(e, t, r) {
        return e;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      maxReplaces: 1e3
    }
  };
}
function Ub(n) {
  return typeof n.ns == "string" && (n.ns = [n.ns]), typeof n.fallbackLng == "string" && (n.fallbackLng = [n.fallbackLng]), typeof n.fallbackNS == "string" && (n.fallbackNS = [n.fallbackNS]), n.whitelist && n.whitelist.indexOf("cimode") < 0 && (n.whitelist = n.whitelist.concat(["cimode"])), n;
}
function kl() {
}
var vP = /* @__PURE__ */ function(n) {
  kd(e, n);
  function e() {
    var t, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = arguments.length > 1 ? arguments[1] : void 0;
    if (Bi(this, e), t = Mc(this, io(e).call(this)), ps.call(sa(t)), t.options = Ub(r), t.services = {}, t.logger = mi, t.modules = {
      external: []
    }, i && !t.isInitialized && !r.isClone) {
      if (!t.options.initImmediate)
        return t.init(r, i), Mc(t, sa(t));
      setTimeout(function() {
        t.init(r, i);
      }, 0);
    }
    return t;
  }
  return $i(e, [{
    key: "init",
    value: function() {
      var r = this, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
      typeof i == "function" && (s = i, i = {}), this.options = Mn({}, xP(), this.options, Ub(i)), this.format = this.options.interpolation.format, s || (s = kl);
      function a(g) {
        return g ? typeof g == "function" ? new g() : g : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? mi.init(a(this.modules.logger), this.options) : mi.init(null, this.options);
        var o = new dP(this.options);
        this.store = new uP(this.options.resources, this.options);
        var c = this.services;
        c.logger = mi, c.resourceStore = this.store, c.languageUtils = o, c.pluralResolver = new mP(o, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), c.interpolator = new yP(this.options), c.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, c.backendConnector = new bP(a(this.modules.backend), c.resourceStore, c, this.options), c.backendConnector.on("*", function(g) {
          for (var T = arguments.length, v = new Array(T > 1 ? T - 1 : 0), w = 1; w < T; w++)
            v[w - 1] = arguments[w];
          r.emit.apply(r, [g].concat(v));
        }), this.modules.languageDetector && (c.languageDetector = a(this.modules.languageDetector), c.languageDetector.init(c, this.options.detection, this.options)), this.modules.i18nFormat && (c.i18nFormat = a(this.modules.i18nFormat), c.i18nFormat.init && c.i18nFormat.init(this)), this.translator = new Fb(this.services, this.options), this.translator.on("*", function(g) {
          for (var T = arguments.length, v = new Array(T > 1 ? T - 1 : 0), w = 1; w < T; w++)
            v[w - 1] = arguments[w];
          r.emit.apply(r, [g].concat(v));
        }), this.modules.external.forEach(function(g) {
          g.init && g.init(r);
        });
      }
      var l = ["getResource", "addResource", "addResources", "addResourceBundle", "removeResourceBundle", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      l.forEach(function(g) {
        r[g] = function() {
          var T;
          return (T = r.store)[g].apply(T, arguments);
        };
      });
      var f = Uo(), p = function() {
        r.changeLanguage(r.options.lng, function(T, v) {
          r.isInitialized = !0, r.logger.log("initialized", r.options), r.emit("initialized", r.options), f.resolve(v), s(T, v);
        });
      };
      return this.options.resources || !this.options.initImmediate ? p() : setTimeout(p, 0), f;
    }
  }, {
    key: "loadResources",
    value: function() {
      var r = this, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : kl;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (this.language && this.language.toLowerCase() === "cimode")
          return i();
        var s = [], a = function(l) {
          if (!!l) {
            var f = r.services.languageUtils.toResolveHierarchy(l);
            f.forEach(function(p) {
              s.indexOf(p) < 0 && s.push(p);
            });
          }
        };
        if (this.language)
          a(this.language);
        else {
          var o = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          o.forEach(function(c) {
            return a(c);
          });
        }
        this.options.preload && this.options.preload.forEach(function(c) {
          return a(c);
        }), this.services.backendConnector.load(s, this.options.ns, i);
      } else
        i(null);
    }
  }, {
    key: "reloadResources",
    value: function(r, i, s) {
      var a = Uo();
      return r || (r = this.languages), i || (i = this.options.ns), s || (s = kl), this.services.backendConnector.reload(r, i, function(o) {
        a.resolve(), s(o);
      }), a;
    }
  }, {
    key: "use",
    value: function(r) {
      return r.type === "backend" && (this.modules.backend = r), (r.type === "logger" || r.log && r.warn && r.error) && (this.modules.logger = r), r.type === "languageDetector" && (this.modules.languageDetector = r), r.type === "i18nFormat" && (this.modules.i18nFormat = r), r.type === "postProcessor" && Rw.addPostProcessor(r), r.type === "3rdParty" && this.modules.external.push(r), this;
    }
  }, {
    key: "changeLanguage",
    value: function(r, i) {
      var s = this, a = Uo();
      this.emit("languageChanging", r);
      var o = function(f, p) {
        s.translator.changeLanguage(p), p && (s.emit("languageChanged", p), s.logger.log("languageChanged", p)), a.resolve(function() {
          return s.t.apply(s, arguments);
        }), i && i(f, function() {
          return s.t.apply(s, arguments);
        });
      }, c = function(f) {
        f && (s.language = f, s.languages = s.services.languageUtils.toResolveHierarchy(f), s.translator.language || s.translator.changeLanguage(f), s.services.languageDetector && s.services.languageDetector.cacheUserLanguage(f)), s.loadResources(function(p) {
          o(p, f);
        });
      };
      return !r && this.services.languageDetector && !this.services.languageDetector.async ? c(this.services.languageDetector.detect()) : !r && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(c) : c(r), a;
    }
  }, {
    key: "getFixedT",
    value: function(r, i) {
      var s = this, a = function o(c, l) {
        var f;
        if (cs(l) !== "object") {
          for (var p = arguments.length, g = new Array(p > 2 ? p - 2 : 0), T = 2; T < p; T++)
            g[T - 2] = arguments[T];
          f = s.options.overloadTranslationOptionHandler([c, l].concat(g));
        } else
          f = Mn({}, l);
        return f.lng = f.lng || o.lng, f.lngs = f.lngs || o.lngs, f.ns = f.ns || o.ns, s.t(c, f);
      };
      return typeof r == "string" ? a.lng = r : a.lngs = r, a.ns = i, a;
    }
  }, {
    key: "t",
    value: function() {
      var r;
      return this.translator && (r = this.translator).translate.apply(r, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var r;
      return this.translator && (r = this.translator).exists.apply(r, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(r) {
      this.options.defaultNS = r;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(r) {
      var i = this;
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var s = this.languages[0], a = this.options ? this.options.fallbackLng : !1, o = this.languages[this.languages.length - 1];
      if (s.toLowerCase() === "cimode")
        return !0;
      var c = function(f, p) {
        var g = i.services.backendConnector.state["".concat(f, "|").concat(p)];
        return g === -1 || g === 2;
      };
      return !!(this.hasResourceBundle(s, r) || !this.services.backendConnector.backend || c(s, r) && (!a || c(o, r)));
    }
  }, {
    key: "loadNamespaces",
    value: function(r, i) {
      var s = this, a = Uo();
      return this.options.ns ? (typeof r == "string" && (r = [r]), r.forEach(function(o) {
        s.options.ns.indexOf(o) < 0 && s.options.ns.push(o);
      }), this.loadResources(function(o) {
        a.resolve(), i && i(o);
      }), a) : (i && i(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(r, i) {
      var s = Uo();
      typeof r == "string" && (r = [r]);
      var a = this.options.preload || [], o = r.filter(function(c) {
        return a.indexOf(c) < 0;
      });
      return o.length ? (this.options.preload = a.concat(o), this.loadResources(function(c) {
        s.resolve(), i && i(c);
      }), s) : (i && i(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(r) {
      if (r || (r = this.languages && this.languages.length > 0 ? this.languages[0] : this.language), !r)
        return "rtl";
      var i = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
      return i.indexOf(this.services.languageUtils.getLanguagePartFromCode(r)) >= 0 ? "rtl" : "ltr";
    }
  }, {
    key: "createInstance",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = arguments.length > 1 ? arguments[1] : void 0;
      return new e(r, i);
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var r = this, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : kl, a = Mn({}, this.options, i, {
        isClone: !0
      }), o = new e(a), c = ["store", "services", "language"];
      return c.forEach(function(l) {
        o[l] = r[l];
      }), o.translator = new Fb(o.services, o.options), o.translator.on("*", function(l) {
        for (var f = arguments.length, p = new Array(f > 1 ? f - 1 : 0), g = 1; g < f; g++)
          p[g - 1] = arguments[g];
        o.emit.apply(o, [l].concat(p));
      }), o.init(a, s), o.translator.options = o.options, o;
    }
  }]), e;
}(ps);
new vP();
function Ln(n, e, t, r) {
  var i = arguments.length, s = i < 3 ? e : r === null ? r = Object.getOwnPropertyDescriptor(e, t) : r, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, r);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (a = n[o]) && (s = (i < 3 ? a(s) : i > 3 ? a(e, t, s) : a(e, t)) || s);
  return i > 3 && s && Object.defineProperty(e, t, s), s;
}
function rs(n, e) {
  return function(t, r) {
    e(t, r, n);
  };
}
var Vb;
(function(n) {
  n.I18N_EA_CHANNEL = "i18n:locale:changed", n.I18N_SIGNAL = "aurelia-translation-signal", n.RT_SIGNAL = "aurelia-relativetime-signal";
})(Vb || (Vb = {}));
var jb;
(function(n) {
  n.translationValueConverterName = "t", n.dateFormatValueConverterName = "df", n.numberFormatValueConverterName = "nf", n.relativeTimeValueConverterName = "rt";
})(jb || (jb = {}));
function Cp(n, e) {
  const t = e.ast.expression;
  if (!(t instanceof pc)) {
    const r = new pc(t, n, e.ast.args);
    e.ast.expression = r;
  }
}
let Gb = class {
  bind(e, t) {
    Cp("df", t);
  }
};
Gb = Ln([Bn("df")], Gb);
const wP = pe.createInterface("I18nInitOptions"), AP = pe.createInterface("I18nextWrapper");
var Wb;
(function(n) {
  n[n.Second = 1e3] = "Second", n[n.Minute = 6e4] = "Minute", n[n.Hour = 36e5] = "Hour", n[n.Day = 864e5] = "Day", n[n.Week = 6048e5] = "Week", n[n.Month = 2592e6] = "Month", n[n.Year = 31536e6] = "Year";
})(Wb || (Wb = {}));
class TP {
  constructor(e) {
    this.value = void 0;
    const t = /\[([a-z\-, ]*)\]/gi;
    this.attributes = [];
    const r = t.exec(e);
    r && (e = e.replace(r[0], ""), this.attributes = r[1].split(",")), this.key = e;
  }
}
const Aa = pe.createInterface("I18N");
let Hb = class {
  constructor(e, t, r, i) {
    this.ea = r, this.i = /* @__PURE__ */ new Set(), this.i18next = e.i18next, this.initPromise = this.h(t), this.u = i;
  }
  evaluate(e, t) {
    const r = e.split(";"), i = [];
    for (const s of r) {
      const a = new TP(s), o = a.key, c = this.tr(o, t);
      this.options.skipTranslationOnMissingKey && c === o ? console.warn(`Couldn't find translation for key: ${o}`) : (a.value = c, i.push(a));
    }
    return i;
  }
  tr(e, t) {
    return this.i18next.t(e, t);
  }
  getLocale() {
    return this.i18next.language;
  }
  async setLocale(e) {
    const r = {
      oldLocale: this.getLocale(),
      newLocale: e
    };
    await this.i18next.changeLanguage(e), this.ea.publish("i18n:locale:changed", r), this.i.forEach((i) => i.handleLocaleChange(r)), this.u.dispatchSignal("aurelia-translation-signal");
  }
  createNumberFormat(e, t) {
    return Intl.NumberFormat(t || this.getLocale(), e);
  }
  nf(e, t, r) {
    return this.createNumberFormat(t, r).format(e);
  }
  createDateTimeFormat(e, t) {
    return Intl.DateTimeFormat(t || this.getLocale(), e);
  }
  df(e, t, r) {
    return this.createDateTimeFormat(t, r).format(e);
  }
  uf(e, t) {
    const r = this.nf(3333.3333333333335, void 0, t);
    let i = r[1];
    const s = r[5];
    i === "." && (i = "\\.");
    const a = e.replace(new RegExp(i, "g"), "").replace(/[^\d.,-]/g, "").replace(s, ".");
    return Number(a);
  }
  createRelativeTimeFormat(e, t) {
    return new Intl.RelativeTimeFormat(t || this.getLocale(), e);
  }
  rt(e, t, r) {
    let i = e.getTime() - this.now();
    const s = this.options.rtEpsilon * (i > 0 ? 1 : 0), a = this.createRelativeTimeFormat(t, r);
    let o = i / 31536e6;
    return Math.abs(o + s) >= 1 ? a.format(Math.round(o), "year") : (o = i / 2592e6, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "month") : (o = i / 6048e5, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "week") : (o = i / 864e5, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "day") : (o = i / 36e5, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "hour") : (o = i / 6e4, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "minute") : (i = Math.abs(i) < 1e3 ? 1e3 : i, o = i / 1e3, a.format(Math.round(o), "second")))))));
  }
  subscribeLocaleChange(e) {
    this.i.add(e);
  }
  now() {
    return new Date().getTime();
  }
  async h(e) {
    const t = {
      lng: "en",
      fallbackLng: ["en"],
      debug: !1,
      plugins: [],
      rtEpsilon: 0.01,
      skipTranslationOnMissingKey: !1
    };
    this.options = {
      ...t,
      ...e
    };
    for (const r of this.options.plugins)
      this.i18next.use(r);
    await this.i18next.init(this.options);
  }
};
Hb = Ln([rs(0, AP), rs(1, wP), rs(2, ud), rs(3, R0)], Hb);
let zb = class {
  constructor(e) {
    this.i18n = e, this.signals = ["aurelia-translation-signal"];
  }
  toView(e, t, r) {
    if (!e && e !== 0 || typeof e == "string" && e.trim() === "")
      return e;
    if (typeof e == "string") {
      const i = Number(e), s = new Date(Number.isInteger(i) ? i : e);
      if (isNaN(s.getTime()))
        return e;
      e = s;
    }
    return this.i18n.df(e, t, r);
  }
};
zb = Ln([qc("df"), rs(0, Aa)], zb);
let Kb = class {
  bind(e, t) {
    Cp("nf", t);
  }
};
Kb = Ln([Bn("nf")], Kb);
let qb = class {
  constructor(e) {
    this.i18n = e, this.signals = ["aurelia-translation-signal"];
  }
  toView(e, t, r) {
    return typeof e != "number" ? e : this.i18n.nf(e, t, r);
  }
};
qb = Ln([qc("nf"), rs(0, Aa)], qb);
let Qb = class {
  bind(e, t) {
    Cp("rt", t);
  }
};
Qb = Ln([Bn("rt")], Qb);
let Jb = class {
  constructor(e) {
    this.i18n = e, this.signals = ["aurelia-translation-signal", "aurelia-relativetime-signal"];
  }
  toView(e, t, r) {
    return e instanceof Date ? this.i18n.rt(e, t, r) : e;
  }
};
Jb = Ln([qc("rt"), rs(0, Aa)], Jb);
let Yb = class {
  bind(e, t) {
    const r = t.ast.expression;
    if (!(r instanceof pc)) {
      const i = new pc(r, "t", t.ast.args);
      t.ast.expression = i;
    }
  }
};
Yb = Ln([Bn("t")], Yb);
const CP = ["textContent", "innerHTML", "prepend", "append"], EP = /* @__PURE__ */ new Map([["text", "textContent"], ["html", "innerHTML"]]), SP = {
  optional: !0
}, _P = {
  reusable: !1,
  preempt: !0
};
class _i {
  constructor(e, t, r, i, s) {
    this.isBound = !1, this.T = CP, this.B = null, this.parameter = null, this.boundFn = !1, this.l = t, this.C = e, this.target = s, this.i18n = t.get(Aa), this.p = i, this.I = /* @__PURE__ */ new Set(), this.oL = r, this.i18n.subscribeLocaleChange(this), this.P = i.domWriteQueue;
  }
  static create({ parser: e, observerLocator: t, context: r, controller: i, target: s, instruction: a, platform: o, isParameterContext: c }) {
    const l = this.M({
      observerLocator: t,
      context: r,
      controller: i,
      target: s,
      platform: o
    }), f = typeof a.from == "string" ? e.parse(a.from, 16) : a.from;
    if (c)
      l.useParameter(f);
    else {
      const p = f instanceof b0 ? e.parse(f.value, 1) : void 0;
      l.ast = p || f;
    }
  }
  static M({ observerLocator: e, context: t, controller: r, target: i, platform: s }) {
    let a = r.bindings && r.bindings.find((o) => o instanceof _i && o.target === i);
    return a || (a = new _i(r, t, e, s, i), r.addBinding(a)), a;
  }
  bind(e) {
    if (!this.isBound) {
      if (!this.ast)
        throw new Error("key expression is missing");
      this.s = e, this.A = this.ast instanceof b1, this.L = V(this.ast, e, this, this), this.R(), this.parameter?.bind(e), this.updateTranslations(), this.isBound = !0;
    }
  }
  unbind() {
    !this.isBound || (sr(this.ast, this.s, this), this.parameter?.unbind(), this.I.clear(), this.B !== null && (this.B.cancel(), this.B = null), this.s = void 0, this.obs.clearAll());
  }
  handleChange(e, t) {
    this.obs.version++, this.L = this.A ? V(this.ast, this.s, this, this) : e, this.obs.clear(), this.R(), this.updateTranslations();
  }
  handleLocaleChange() {
    this.updateTranslations();
  }
  useParameter(e) {
    if (this.parameter != null)
      throw new Error("This translation parameter has already been specified.");
    this.parameter = new Ep(this, e, () => this.updateTranslations());
  }
  updateTranslations() {
    const e = this.i18n.evaluate(this.L, this.parameter?.value), t = /* @__PURE__ */ Object.create(null), r = [], i = this.B;
    this.I.clear();
    for (const a of e) {
      const o = a.value, c = this.N(a.attributes);
      for (const l of c)
        if (this.O(l))
          t[l] = o;
        else {
          const f = Ua.for(this.target, SP), p = f?.viewModel ? this.oL.getAccessor(f.viewModel, l) : this.oL.getAccessor(this.target, l);
          this.C.state !== 1 && (4 & p.type) > 0 ? r.push(new PP(p, o, this.target, l)) : p.setValue(o, this.target, l), this.I.add(p);
        }
    }
    let s = !1;
    Object.keys(t).length > 0 && (s = this.C.state !== 1, s || this.V(t)), (r.length > 0 || s) && (this.B = this.P.queueTask(() => {
      this.B = null;
      for (const a of r)
        a.run();
      s && this.V(t);
    }, _P)), i?.cancel();
  }
  N(e) {
    e.length === 0 && (e = this.target.tagName === "IMG" ? ["src"] : ["textContent"]);
    for (const [t, r] of EP) {
      const i = e.findIndex((s) => s === t);
      i > -1 && e.splice(i, 1, r);
    }
    return e;
  }
  O(e) {
    return this.T.includes(e);
  }
  V(e) {
    const t = of(this.target.childNodes), r = [], i = "au-i18n";
    for (const a of t)
      Reflect.get(a, i) || r.push(a);
    const s = this._(e, i, r);
    this.target.innerHTML = "";
    for (const a of of(s.content.childNodes))
      this.target.appendChild(a);
  }
  _(e, t, r) {
    const i = this.p.document.createElement("template");
    if (this.F(i, e.prepend, t), !this.F(i, e.innerHTML ?? e.textContent, t))
      for (const s of r)
        i.content.append(s);
    return this.F(i, e.append, t), i;
  }
  F(e, t, r) {
    if (t != null) {
      const i = this.p.document.createElement("div");
      i.innerHTML = t;
      for (const s of of(i.childNodes))
        Reflect.set(s, r, !0), e.content.append(s);
      return !0;
    }
    return !1;
  }
  R() {
    const e = this.L ?? (this.L = ""), t = typeof e;
    if (t !== "string")
      throw new Error(`Expected the i18n key to be a string, but got ${e} of type ${t}`);
  }
}
Rr(_i);
Zr(!0)(_i);
ba(_i, () => "updateTranslations");
class PP {
  constructor(e, t, r, i) {
    this.accessor = e, this.v = t, this.el = r, this.attr = i;
  }
  run() {
    this.accessor.setValue(this.v, this.el, this.attr);
  }
}
class Ep {
  constructor(e, t, r) {
    this.owner = e, this.ast = t, this.updater = r, this.isBound = !1, this.boundFn = !1, this.oL = e.oL, this.l = e.l;
  }
  handleChange(e, t) {
    !this.isBound || (this.obs.version++, this.value = V(this.ast, this.s, this, this), this.obs.clear(), this.updater());
  }
  bind(e) {
    this.isBound || (this.s = e, Er(this.ast, e, this), this.value = V(this.ast, e, this, this), this.isBound = !0);
  }
  unbind() {
    !this.isBound || (sr(this.ast, this.s, this), this.s = void 0, this.obs.clearAll());
  }
}
Rr(Ep);
Zr(!0)(Ep);
const kw = "tpt", Rc = "t-params.bind";
let Xb = class {
  [Rc](e, t, r) {
    return new lr(e, t, "", Rc);
  }
};
Xb = Ln([ki({
  pattern: Rc,
  symbols: ""
})], Xb);
class MP {
  constructor(e, t) {
    this.from = e, this.to = t, this.type = kw, this.mode = 2;
  }
}
let Zb = class {
  constructor() {
    this.type = 0;
  }
  get name() {
    return Rc;
  }
  build(e, t, r) {
    const i = e.attr;
    let s = i.target;
    return e.bindable == null ? s = r.map(e.node, s) ?? Kn(s) : s = e.bindable.property, new MP(t.parse(i.rawValue, 16), s);
  }
};
Zb = Ln([$n(Rc)], Zb);
let ex = class {
  render(e, t, r, i, s, a) {
    _i.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: r,
      isParameterContext: !0,
      platform: i
    });
  }
};
ex = Ln([Nt(kw)], ex);
const RP = "tt";
let tx = class {
  render(e, t, r, i, s, a) {
    _i.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: r,
      platform: i
    });
  }
};
tx = Ln([Nt(RP)], tx);
const kP = "tbt";
let nx = class {
  render(e, t, r, i, s, a) {
    _i.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: r,
      platform: i
    });
  }
};
nx = Ln([Nt(kP)], nx);
let rx = class {
  constructor(e) {
    this.i18n = e, this.signals = ["aurelia-translation-signal"];
  }
  toView(e, t) {
    return this.i18n.tr(e, t);
  }
};
rx = Ln([qc("t"), rs(0, Aa)], rx);
var IP = Object.defineProperty, OP = Object.getOwnPropertyDescriptor, DP = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? OP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && IP(e, t, i), i;
}, NP = (n, e) => (t, r) => e(t, r, n);
const ul = pe.createInterface("NumberService");
let kc = class {
  constructor(n) {
    this.i18n = n;
  }
  static register(n) {
    n.register(fe.singleton(ul, kc));
  }
  toString(n, e) {
    if (n === null || typeof n > "u" || typeof n == "string")
      return n;
    if (G.isBigNumber(n) && (n = n.toNumber()), Number.isNaN(n))
      return "NaN";
    const t = e?.useGrouping ?? !0, r = e?.isPercentage ?? !1, i = e?.isCurrency ?? !1;
    let s = this.fromString(e?.fractionDigits);
    isNaN(s) && (s = 2);
    const a = i ? { style: "currency", currency: "USD" } : r ? { style: "percent" } : { style: "decimal" };
    return this.i18n.nf(
      n,
      Object.assign(a, {
        useGrouping: t,
        minimumFractionDigits: s,
        maximumFractionDigits: s
      })
    );
  }
  fromString(n) {
    return n === null || typeof n > "u" ? NaN : typeof n == "number" ? n : this.i18n.uf(n);
  }
};
kc = DP([
  NP(0, Aa)
], kc);
var BP = Object.defineProperty, $P = Object.getOwnPropertyDescriptor, LP = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? $P(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && BP(e, t, i), i;
}, ix = (n, e) => (t, r) => e(t, r, n);
const Iw = pe.createInterface("ObserverService");
let Fu = class {
  constructor(n, e) {
    this.locator = n, this.cacheService = e;
  }
  static register(n) {
    n.register(fe.singleton(Iw, Fu));
  }
  listen(n, e, t) {
    const r = this.locator.getObserver(n, e), i = {
      handleChange: t
    };
    return r.subscribe(i), () => r.unsubscribe(i);
  }
};
Fu = LP([
  ix(0, ma),
  ix(1, xo)
], Fu);
var FP = Object.defineProperty, UP = Object.getOwnPropertyDescriptor, VP = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? UP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && FP(e, t, i), i;
}, jP = (n, e) => (t, r) => e(t, r, n);
const Ow = pe.createInterface("TimingService");
let Uu = class {
  constructor(n) {
    this.config = n;
  }
  static register(n) {
    fe.singleton(Ow, Uu).register(n);
  }
  startTimer(n) {
    this.config.isDevelopment && console.time(n);
  }
  endTimer(n) {
    this.config.isDevelopment && console.timeEnd(n);
  }
};
Uu = VP([
  jP(0, Rd)
], Uu);
var GP = Object.defineProperty, WP = Object.getOwnPropertyDescriptor, Dw = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? WP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && GP(e, t, i), i;
}, Qf = (n, e) => (t, r) => e(t, r, n);
const Sp = pe.createInterface();
let so = class {
  constructor(n, e, t) {
    this.cacheService = n, this.ethereumService = e, this.contractService = t;
  }
  static register(n) {
    fe.singleton(Sp, so).register(n);
  }
  async getTokenContract(n, e) {
    return this.getTokenContractForAccount(this.ethereumService.defaultAccountAddress, n, e);
  }
  async getTokenContractForProvider(n, e, t) {
    const r = t ? await this.contractService.getSharedAbi("monetary", "ERC721") : await this.contractService.getSharedAbi("monetary", "ERC20");
    return new iw(e, r, n);
  }
  getTokenContractForAccount(n, e, t) {
    const r = this.ethereumService.createSignerOrProviderForAddress(n);
    return this.getTokenContractForProvider(r, e, t);
  }
};
Dw([
  vp(function() {
    return { storage: this.cacheService };
  })
], so.prototype, "getTokenContractForAccount", 1);
so = Dw([
  Qf(0, xo),
  Qf(1, ll),
  Qf(2, So)
], so);
var HP = Object.defineProperty, zP = Object.getOwnPropertyDescriptor, KP = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? zP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && HP(e, t, i), i;
}, tr = (n, e) => (t, r) => e(t, r, n);
const qP = pe.createInterface();
let Hh = class {
  constructor(n, e, t, r, i, s, a, o, c, l, f, p) {
    this.httpService = n, this.numberService = e, this.ethereumService = t, this.browserStorageService = r, this.timingService = i, this.cacheService = s, this.observerService = a, this.encryptionService = o, this.contractService = c, this.tokenService = l, this.ipfsService = f, this.configuration = p;
  }
  static register(n) {
    n.register(fe.singleton(qP, Hh)).register(Fu).register(Uu).register(xd).register(Pc).register(Bu).register(kc).register(no).register(Nu).register(xp).register($u).register(ro).register(so);
  }
};
Hh = KP([
  tr(0, Sw),
  tr(1, ul),
  tr(2, ll),
  tr(3, Md),
  tr(4, Ow),
  tr(5, xo),
  tr(6, Iw),
  tr(7, Cw),
  tr(8, So),
  tr(9, Sp),
  tr(10, Ap),
  tr(11, Rd)
], Hh);
pe.createInterface("DateServiceIntl");
var QP = Object.defineProperty, JP = Object.getOwnPropertyDescriptor, YP = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? JP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && QP(e, t, i), i;
};
let sx = class {
  disposables;
  constructor() {
    this.disposables = new Array();
  }
  push(n) {
    return this.disposables.push(n);
  }
  dispose(n) {
    if (n)
      this._dispose(n);
    else {
      for (n of this.disposables)
        n.dispose();
      this.disposables.length = 0;
    }
  }
  _dispose(n) {
    n.dispose(), this.disposables.splice(this.disposables.indexOf(n), 1);
  }
};
sx = YP([
  l1()
], sx);
var XP = Object.defineProperty, ZP = Object.getOwnPropertyDescriptor, eM = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? ZP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && XP(e, t, i), i;
}, tM = (n, e) => (t, r) => e(t, r, n);
const nM = pe.createInterface("TransactionsService");
let Vu = class {
  constructor(n) {
    this.eventAggregator = n;
  }
  static blocksToConfirm = 1;
  static register(n) {
    fe.singleton(nM, Vu).register(n);
  }
  async send(n) {
    let e;
    try {
      this.eventAggregator.publish("transaction.sending");
      const t = await n();
      return this.eventAggregator.publish("transaction.sent", t), e = await t.wait(1), this.eventAggregator.publish("transaction.mined", { message: "Transaction was mined", receipt: e }), e = await t.wait(Vu.blocksToConfirm), this.eventAggregator.publish("transaction.confirmed", { message: "Transaction was confirmed", receipt: e }), e;
    } catch (t) {
      return this.eventAggregator.publish("transaction.failed", t), null;
    }
  }
};
Vu = eM([
  tM(0, ud)
], Vu);
var rM = Object.defineProperty, iM = Object.getOwnPropertyDescriptor, sM = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? iM(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && rM(e, t, i), i;
}, Vo = (n, e) => (t, r) => e(t, r, n);
const _p = pe.createInterface("IContractStore");
let ju = class {
  constructor(n, e, t, r, i) {
    this.contractService = n, this.tokenService = e, this.logger = t, this.numberService = r, this.tokenInfo = i;
  }
  static register(n) {
    n.register(fe.singleton(_p, ju));
  }
  async getAsset(n, e, t, r, i, s) {
    let a;
    e && (a = Number(e));
    const c = (await this.tokenInfo.tokens).find((C) => C.address === n && C.id == a);
    if (!c) {
      this.logger.error(`No token info was found for ${n}`);
      return;
    }
    const l = await this.tokenService.getTokenContract(n, c.id);
    if (s || (c.id ? s = await t.oraclePerERC721Id(n, c.id) : s = await t.oraclePerERC20(n)), !s || G.from(s).isZero())
      return;
    const p = await (await this.contractService.getContract("monetary", "Oracle", s)).getData();
    if (!p[1])
      return;
    c.price = this.numberService.fromString(nn(p[0], 18));
    let g = Ob(1, 18), T;
    c.id || (T = await l.totalSupply(), g = await l.balanceOf(r));
    let v;
    c.id ? v = Zi.Ecological : v = await t.assetTypeOfERC20(n), i && this.populateTransactionsForAsset(i, l, r, c);
    const w = {
      quantity: g,
      token: c,
      total: 0,
      type: v,
      totalSupply: T
    };
    return w.total = c.id ? c.price : this.numberService.fromString(nn(w.quantity, 18)) * c.price, w;
  }
  async populateTransactionsForAsset(n, e, t, r) {
    const i = await e.queryFilter(e.filters.Transfer(void 0, t)), s = await this.mapTransactions(i, "deposit", r);
    n.push(...s);
    const a = await e.queryFilter(e.filters.Transfer(t)), o = await this.mapTransactions(a, "withdrawl", r);
    n.push(...o);
  }
  async mapTransactions(n, e, t) {
    return await Promise.all(
      n.map(async (r) => {
        const i = await r.getBlock();
        return {
          address: e === "deposit" ? r.args.from : r.args.to,
          amount: "amount" in r.args ? r.args.amount : Ob(1, 18),
          date: i.timestamp,
          id: r.transactionHash,
          token: t,
          type: e
        };
      })
    );
  }
};
ju = sM([
  Vo(0, So),
  Vo(1, Sp),
  Vo(2, pa),
  Vo(3, ul),
  Vo(4, Tw)
], ju);
var aM = Object.defineProperty, oM = Object.getOwnPropertyDescriptor, cM = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? oM(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && aM(e, t, i), i;
}, lM = (n, e) => (t, r) => e(t, r, n);
const Pp = pe.createInterface("DataStore");
let Gu = class {
  constructor(n) {
    this.firebaseService = n;
  }
  static register(n) {
    n.register(fe.singleton(Pp, Gu));
  }
  async getDocs(...n) {
    return this.firebaseService.getDocs(...n);
  }
};
Gu = cM([
  lM(0, wp)
], Gu);
var iu = /* @__PURE__ */ ((n) => (n.low = "Low Risk", n.moderate = "Moderate Risk", n.high = "High Risk", n))(iu || {});
function Id(n = "") {
  const e = /* @__PURE__ */ new WeakMap();
  return function(t, r, i) {
    const s = t[r];
    if (typeof s != "function")
      throw { ALLUSERSPROFILE: "C:\\ProgramData", AMDRMPATH: "C:\\Program Files\\AMD\\RyzenMaster\\", ANDROID_HOME: "C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk", APPDATA: "C:\\Users\\Brandon\\AppData\\Roaming", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_45880_UWUMZIVXPRYDKNKX", CLASSPATH: ".;", COLOR: "1", COLORTERM: "truecolor", COMMONPROGRAMFILES: "C:\\Program Files\\Common Files", COMPUTERNAME: "DESKTOP-72OQKP6", COMSPEC: "C:\\WINDOWS\\system32\\cmd.exe", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "132215198773539171", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "notepad.exe", EXEPATH: "C:\\Program Files\\Git\\bin", GIT_ASKPASS: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", HOME: "C:\\Users\\Brandon", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\Brandon", INIT_CWD: "C:\\Users\\Brandon\\source\\repos\\dapp", INTEL_DEV_REDIST: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\", JAVA_HOME: "C:\\Program Files\\Java\\jdk1.8.0_231", LANG: "en_US.UTF-8", LOCALAPPDATA: "C:\\Users\\Brandon\\AppData\\Local", LOGONSERVER: "\\\\DESKTOP-72OQKP6", MIC_LD_LIBRARY_PATH: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\compiler\\lib\\mic", MSYSTEM: "MINGW64", MYSQLCONNECTOR_ASSEMBLIESPATH: "C:\\Program Files (x86)\\MySQL\\Connector NET 8.0\\Assemblies\\v4.5.2", NODE: "C:\\Program Files\\nodejs\\node.exe", NUMBER_OF_PROCESSORS: "32", NVM_HOME: "C:\\Users\\Brandon\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", OcpApimSubscriptionKey: "15752dea34354b65bb7b54bca0da1b8d", OneDrive: "C:\\Users\\Brandon\\OneDrive - Grey & Co Salon", OneDriveCommercial: "C:\\Users\\Brandon\\OneDrive - Grey & Co Salon", PAC_CLI_LAUNCHER_AGENT: "powerplatform-vscode/1.0.21", PATH: "C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\Brandon\\bin;C:\\Users\\Brandon\\source\\repos\\dapp\\node_modules\\.bin;C:\\Users\\Brandon\\source\\repos\\node_modules\\.bin;C:\\Users\\Brandon\\source\\node_modules\\.bin;C:\\Users\\Brandon\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Users\\Brandon\\AppData\\Roaming\\Code\\User\\globalStorage\\microsoft-isvexptools.powerplatform-vscode\\pac\\tools;C:\\Program Files (x86)\\Razer Chroma SDK\\bin;C:\\Program Files\\Razer Chroma SDK\\bin;C:\\Program Files (x86)\\Razer\\ChromaBroadcast\\bin;C:\\Program Files\\Razer\\ChromaBroadcast\\bin;C:\\Python39\\Scripts;C:\\Python39;C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\redist\\intel64\\compiler;C:\\Python27;C:\\Python27\\Scripts;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\Program Files\\dotnet;C:\\Program Files\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\130\\Tools\\Binn;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\130\\DTS\\Binn;C:\\WINDOWS\\System32\\OpenSSH;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn;C:\\Program Files\\Microsoft VS Code Insiders\\bin;C:\\Program Files\\Java\\jdk1.8.0_231\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\platform-tools;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\DTS\\Binn;C:\\Program Files\\gradle-6.3\\bin;C:\\flutter\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\tools;C:\\Program Files\\MongoDB\\Server\\4.2\\bin;C:\\Program Files\\Microsoft\\Azure Functions Core Tools;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHu;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\npm;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\L;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files (x8;C:\\Program Files (x86)\\dotnet;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Program Files\\Git\\cmd;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\WINDOWS\\System32\\OpenSSH;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\ProgramData\\DockerDesktop\\version-bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Brandon\\AppData\\Local\\JetBrains\\Toolbox\\scripts;%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW;.CPL", PLINK_PROTOCOL: "ssh", PREFERRED_WORKSPACE_MANAGER: "yarn", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "AMD64 Family 23 Model 113 Stepping 0, AuthenticAMD", PROCESSOR_LEVEL: "23", PROCESSOR_REVISION: "7100", PROGRAMFILES: "C:\\Program Files", PSModulePath: "C:\\Users\\Brandon\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\PowerShell\\Modules\\", PUBLIC: "C:\\Users\\Public", PWD: "C:/Users/Brandon/source/repos/dapp", ProgramData: "C:\\ProgramData", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", SESSIONNAME: "Console", SHLVL: "0", SYSTEMDRIVE: "C:", SYSTEMROOT: "C:\\WINDOWS", TEMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", TERM: "xterm-256color", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.73.1", TMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", USERDOMAIN: "DESKTOP-72OQKP6", USERDOMAIN_ROAMINGPROFILE: "DESKTOP-72OQKP6", USERNAME: "Brandon", USERPROFILE: "C:\\Users\\Brandon", VS160PROCOMNTOOLS: "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\Common7\\Tools\\", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node", VSCODE_GIT_ASKPASS_MAIN: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-b178cbeab5-sock", WINDIR: "C:\\WINDOWS", "asl.log": "Destination=file", npm_command: "run-script", npm_config_cache: "C:\\Users\\Brandon\\AppData\\Local\\npm-cache", npm_config_global_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_globalconfig: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\etc\\npmrc", npm_config_init_module: "C:\\Users\\Brandon\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\Brandon\\source\\repos\\dapp", npm_config_metrics_registry: "https://registry.npmjs.org/", npm_config_node_gyp: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_script_shell: "C:\\Program Files\\git\\bin\\bash.exe", npm_config_shamefully_hoist: "true", npm_config_user_agent: "npm/8.6.0 node/v19.0.1 win32 x64 workspaces/false", npm_config_userconfig: "C:\\Users\\Brandon\\.npmrc", npm_execpath: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build:dev:chart-data-script", npm_lifecycle_script: "vite build --config vite.config-lib.ts --mode development", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_engines_node: ">=16.0.0", npm_package_json: "C:\\Users\\Brandon\\source\\repos\\dapp\\package.json", npm_package_name: "@kolektivo/dapp", npm_package_version: "1.0.0" }.NODE_ENV !== "production" ? new Error(`ER: @callOnce: Invalid decorator target: "${String(r)}", can only be used on a method.`) : new Error(`ER: @callOnce: > ${String(r)}`);
    i.value = function(...a) {
      if (e.has(this))
        return { ALLUSERSPROFILE: "C:\\ProgramData", AMDRMPATH: "C:\\Program Files\\AMD\\RyzenMaster\\", ANDROID_HOME: "C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk", APPDATA: "C:\\Users\\Brandon\\AppData\\Roaming", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_45880_UWUMZIVXPRYDKNKX", CLASSPATH: ".;", COLOR: "1", COLORTERM: "truecolor", COMMONPROGRAMFILES: "C:\\Program Files\\Common Files", COMPUTERNAME: "DESKTOP-72OQKP6", COMSPEC: "C:\\WINDOWS\\system32\\cmd.exe", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "132215198773539171", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "notepad.exe", EXEPATH: "C:\\Program Files\\Git\\bin", GIT_ASKPASS: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", HOME: "C:\\Users\\Brandon", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\Brandon", INIT_CWD: "C:\\Users\\Brandon\\source\\repos\\dapp", INTEL_DEV_REDIST: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\", JAVA_HOME: "C:\\Program Files\\Java\\jdk1.8.0_231", LANG: "en_US.UTF-8", LOCALAPPDATA: "C:\\Users\\Brandon\\AppData\\Local", LOGONSERVER: "\\\\DESKTOP-72OQKP6", MIC_LD_LIBRARY_PATH: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\compiler\\lib\\mic", MSYSTEM: "MINGW64", MYSQLCONNECTOR_ASSEMBLIESPATH: "C:\\Program Files (x86)\\MySQL\\Connector NET 8.0\\Assemblies\\v4.5.2", NODE: "C:\\Program Files\\nodejs\\node.exe", NUMBER_OF_PROCESSORS: "32", NVM_HOME: "C:\\Users\\Brandon\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", OcpApimSubscriptionKey: "15752dea34354b65bb7b54bca0da1b8d", OneDrive: "C:\\Users\\Brandon\\OneDrive - Grey & Co Salon", OneDriveCommercial: "C:\\Users\\Brandon\\OneDrive - Grey & Co Salon", PAC_CLI_LAUNCHER_AGENT: "powerplatform-vscode/1.0.21", PATH: "C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\Brandon\\bin;C:\\Users\\Brandon\\source\\repos\\dapp\\node_modules\\.bin;C:\\Users\\Brandon\\source\\repos\\node_modules\\.bin;C:\\Users\\Brandon\\source\\node_modules\\.bin;C:\\Users\\Brandon\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Users\\Brandon\\AppData\\Roaming\\Code\\User\\globalStorage\\microsoft-isvexptools.powerplatform-vscode\\pac\\tools;C:\\Program Files (x86)\\Razer Chroma SDK\\bin;C:\\Program Files\\Razer Chroma SDK\\bin;C:\\Program Files (x86)\\Razer\\ChromaBroadcast\\bin;C:\\Program Files\\Razer\\ChromaBroadcast\\bin;C:\\Python39\\Scripts;C:\\Python39;C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\redist\\intel64\\compiler;C:\\Python27;C:\\Python27\\Scripts;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\Program Files\\dotnet;C:\\Program Files\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\130\\Tools\\Binn;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\130\\DTS\\Binn;C:\\WINDOWS\\System32\\OpenSSH;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn;C:\\Program Files\\Microsoft VS Code Insiders\\bin;C:\\Program Files\\Java\\jdk1.8.0_231\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\platform-tools;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\DTS\\Binn;C:\\Program Files\\gradle-6.3\\bin;C:\\flutter\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\tools;C:\\Program Files\\MongoDB\\Server\\4.2\\bin;C:\\Program Files\\Microsoft\\Azure Functions Core Tools;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHu;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\npm;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\L;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files (x8;C:\\Program Files (x86)\\dotnet;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Program Files\\Git\\cmd;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\WINDOWS\\System32\\OpenSSH;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\ProgramData\\DockerDesktop\\version-bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Brandon\\AppData\\Local\\JetBrains\\Toolbox\\scripts;%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW;.CPL", PLINK_PROTOCOL: "ssh", PREFERRED_WORKSPACE_MANAGER: "yarn", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "AMD64 Family 23 Model 113 Stepping 0, AuthenticAMD", PROCESSOR_LEVEL: "23", PROCESSOR_REVISION: "7100", PROGRAMFILES: "C:\\Program Files", PSModulePath: "C:\\Users\\Brandon\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\PowerShell\\Modules\\", PUBLIC: "C:\\Users\\Public", PWD: "C:/Users/Brandon/source/repos/dapp", ProgramData: "C:\\ProgramData", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", SESSIONNAME: "Console", SHLVL: "0", SYSTEMDRIVE: "C:", SYSTEMROOT: "C:\\WINDOWS", TEMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", TERM: "xterm-256color", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.73.1", TMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", USERDOMAIN: "DESKTOP-72OQKP6", USERDOMAIN_ROAMINGPROFILE: "DESKTOP-72OQKP6", USERNAME: "Brandon", USERPROFILE: "C:\\Users\\Brandon", VS160PROCOMNTOOLS: "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\Common7\\Tools\\", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node", VSCODE_GIT_ASKPASS_MAIN: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-b178cbeab5-sock", WINDIR: "C:\\WINDOWS", "asl.log": "Destination=file", npm_command: "run-script", npm_config_cache: "C:\\Users\\Brandon\\AppData\\Local\\npm-cache", npm_config_global_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_globalconfig: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\etc\\npmrc", npm_config_init_module: "C:\\Users\\Brandon\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\Brandon\\source\\repos\\dapp", npm_config_metrics_registry: "https://registry.npmjs.org/", npm_config_node_gyp: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_script_shell: "C:\\Program Files\\git\\bin\\bash.exe", npm_config_shamefully_hoist: "true", npm_config_user_agent: "npm/8.6.0 node/v19.0.1 win32 x64 workspaces/false", npm_config_userconfig: "C:\\Users\\Brandon\\.npmrc", npm_execpath: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build:dev:chart-data-script", npm_lifecycle_script: "vite build --config vite.config-lib.ts --mode development", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_engines_node: ">=16.0.0", npm_package_json: "C:\\Users\\Brandon\\source\\repos\\dapp\\package.json", npm_package_name: "@kolektivo/dapp", npm_package_version: "1.0.0" }.NODE_ENV !== "production" && n && (console.warn(`Warning: @callOnce: ${String(r)} ${n}`), console.warn(new Error().stack)), e.get(this);
      const o = s.apply(this, a);
      return e.set(this, o), o;
    };
  };
}
var uM = Object.defineProperty, dM = Object.getOwnPropertyDescriptor, Od = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? dM(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && uM(e, t, i), i;
}, Il = (n, e) => (t, r) => e(t, r, n);
const Nw = pe.createInterface("ReserveStore");
let aa = class {
  constructor(n, e, t, r) {
    this.contractStore = n, this.contractService = e, this.numberService = t, this.dataStore = r;
  }
  reserveValue;
  kCurMarketCap;
  backing;
  kCurPrice;
  kCurSupply;
  transactions = [];
  reserveAssets = [];
  kCurReserveDistribution;
  kCurMentoDistribution;
  kCurPrimaryPoolDistribution;
  minBacking;
  kGuilderCurrentPrice;
  kGuilderTotalSupply;
  kGuilderSpread;
  kGuilderInflationRate;
  kGuilderTobinTax;
  static register(n) {
    n.register(fe.singleton(Nw, aa));
  }
  get kCurCirculatingDistribution() {
    return !this.kCurReserveDistribution || !this.kCurMentoDistribution || !this.kCurPrimaryPoolDistribution ? 0 : 1 - (this.kCurReserveDistribution + this.kCurMentoDistribution + this.kCurPrimaryPoolDistribution);
  }
  get currentCollateralizationRatio() {
    return this.numberService.fromString(nn(this.backing ?? 0, 2));
  }
  get currentLeverageRatio() {
    return this.backing ? this.calculateLeverage(this.backing) : 0;
  }
  get maxLeverageRatio() {
    return 1 / this.numberService.fromString(nn(this.minBacking ?? 0, 4)) * 100;
  }
  get minCollateralizationRatio() {
    return this.numberService.fromString(nn(this.minBacking ?? 0, 4));
  }
  get minCollateralizationValue() {
    return this.kCurMarketCap ? this.minCollateralizationRatio * this.numberService.fromString(nn(this.kCurMarketCap, 18)) : 0;
  }
  get maxLeverageMultiplier() {
    return `${Math.round(this.maxLeverageRatio / 100 * 100) / 100}x`;
  }
  get kCurTotalValue() {
    return this.numberService.fromString(nn(this.kCurMarketCap ?? 0, 18));
  }
  get kGuilderMarketCap() {
    return this.kGuilderCurrentPrice ? this.kGuilderCurrentPrice * this.numberService.fromString(nn(this.kGuilderTotalSupply ?? 0, 18)) : 0;
  }
  get kCurPriceFloor() {
    return !this.reserveValue || !this.kCurSupply ? 0 : this.numberService.fromString(nn(this.reserveValue, 18)) / this.numberService.fromString(nn(this.kCurSupply, 18));
  }
  get kCurPriceCeiling() {
    return !this.reserveValue || !this.kCurSupply ? 0 : this.kCurPriceFloor * 1.9;
  }
  get lowRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === Zi.Stablecoin) ?? [];
  }
  get moderateRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === Zi.NonStablecoin) ?? [];
  }
  get highRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === Zi.Ecological) ?? [];
  }
  get kGuilderValueRatio() {
    return this.kCurPrice ? 4 / this.kCurPrice : 0;
  }
  getRiskClass(n) {
    switch (n) {
      case Zi.Ecological:
        return iu.high;
      case Zi.NonStablecoin:
        return iu.moderate;
      case Zi.Stablecoin:
        return iu.low;
    }
  }
  async loadAssets() {
    const n = await this.getReserveContract(), e = n.address;
    if (!e)
      return;
    const t = (await Promise.all([
      n.allRegisteredERC20s().then((i) => i.map((s) => ({ tokenId: void 0, address: s }))),
      n.allRegisteredERC721Ids().then((i) => i.map((s) => ({ tokenId: s.id, address: s.erc721 })))
    ])).flatMap((i) => i);
    this.reserveAssets = (await Promise.all(
      t.map(
        (i) => this.contractStore.getAsset(i.address, i.tokenId, n, e, this.transactions).catch()
      )
    )).filter(Boolean), this.loadkCurData();
    const r = await n.reserveStatus();
    this.reserveValue = r[0], this.kCurMarketCap = r[1], this.backing = r[2], this.minBacking = await n.minBacking();
  }
  async loadkCur() {
    await this.loadkCurData();
    const n = await this.getReserveContract();
    if (!this.kCurSupply)
      return;
    const t = await (await this.contractService.getContract("monetary", "Kolektivo Curacao Token")).balanceOf(n.address);
    this.kCurReserveDistribution = this.numberService.fromString(nn(t, 18)) / this.numberService.fromString(nn(this.kCurSupply, 18)), this.kCurMentoDistribution = 0.3, this.kCurPrimaryPoolDistribution = 0.4;
  }
  async loadkGuilder() {
    !(await this.getReserveContract()).address || (this.kGuilderCurrentPrice = 4, this.kGuilderTotalSupply = G.from(1934223345231232342413213n), this.kGuilderSpread = 0.2, this.kGuilderInflationRate = 0.01, this.kGuilderTobinTax = 0.05);
  }
  async loadkCurData() {
    if (this.kCurPrice || this.kCurSupply)
      return;
    const n = await this.getReserveContract(), e = await n.token();
    if (!e)
      return;
    const t = n.address;
    if (!t)
      return;
    const r = await n.tokenOracle();
    if (!r)
      return;
    const i = await this.contractStore.getAsset(e, void 0, n, t, void 0, r);
    this.kCurPrice = i?.token.price, this.kCurSupply = i?.totalSupply;
  }
  getReserveContract() {
    return this.contractService.getContract("monetary", "Reserve");
  }
  async getReserveValueOverTime(n) {
    const [e, t] = await Promise.all([
      this.getData("reserve", n),
      this.getReserveContract().then((r) => r.reserveStatus())
    ]);
    return e.push({
      createdAt: new Date(),
      value: t[0]
    }), e;
  }
  async getkGuilderValueRatioOverTime(n) {
    const [e] = await Promise.all([this.getData("kGuilder", n), this.loadkCurData()]);
    return e.push({
      createdAt: new Date(),
      value: this.kGuilderValueRatio
    }), e;
  }
  async getLeverageRatioValueOverTime(n) {
    const [e, [t, r]] = await Promise.all([
      this.getData("kCurRatio", n),
      this.getReserveContract().then((i) => Promise.all([i.reserveStatus(), i.minBacking()]))
    ]);
    return e.push({
      createdAt: new Date(),
      currentLeverageRatio: this.calculateLeverage(t[2]),
      maxLeverageRatio: 1 / (this.numberService.fromString(nn(r, 2)) / 100) * 100
    }), e;
  }
  async getkCurSupplyData(n) {
    const [e] = await Promise.all([this.getData("kCurSupply", n), this.loadkCur()]);
    return e.push({
      createdAt: new Date(),
      kCurCirculatingDistribution: this.kCurCirculatingDistribution,
      kCurMentoDistribution: this.kCurMentoDistribution,
      kCurPrimaryPoolDistribution: this.kCurPrimaryPoolDistribution,
      kCurReserveDistribution: this.kCurReserveDistribution
    }), e;
  }
  async getkCurPriceOverTime(n) {
    const [e] = await Promise.all([this.getData("kCurPrice", n), this.loadkCurData(), this.loadAssets()]);
    return e.push({
      createdAt: new Date(),
      kCurPrice: this.kCurPrice,
      kCurPriceCeiling: this.kCurPriceCeiling,
      kCurPriceFloor: this.kCurPriceFloor
    }), e;
  }
  async getRiskOverTime(n) {
    const [e, [t, r]] = await Promise.all([
      this.getData("risk", n),
      this.getReserveContract().then((i) => Promise.all([i.reserveStatus(), i.minBacking()])),
      this.loadAssets()
    ]);
    return this.kCurMarketCap = t[1], this.minBacking = r, e.push({
      createdAt: new Date(),
      minCollateralValue: this.minCollateralizationValue,
      marketCap: this.kCurTotalValue,
      lowRisk: this.lowRiskAssets.map((i) => i.total).sum(),
      moderateRisk: this.moderateRiskAssets.map((i) => i.total).sum(),
      highRisk: this.highRiskAssets.map((i) => i.total).sum()
    }), e;
  }
  async getData(n, e) {
    const t = bw(e), r = await this.dataStore.getDocs(`chartData/${n}/${gw(e)}`, "createdAt", "desc", {
      fieldPath: "createdAt",
      opStr: ">=",
      value: t
    });
    return r.sort((i, s) => new Date(i.createdAt).getTime() - new Date(s.createdAt).getTime()), r;
  }
  calculateLeverage(n) {
    return 1 / this.numberService.fromString(nn(n, 4)) * 100;
  }
};
Od([
  Id()
], aa.prototype, "loadAssets", 1);
Od([
  Id()
], aa.prototype, "loadkCur", 1);
Od([
  Id()
], aa.prototype, "loadkGuilder", 1);
aa = Od([
  Il(0, _p),
  Il(1, So),
  Il(2, ul),
  Il(3, Pp)
], aa);
var fM = Object.defineProperty, hM = Object.getOwnPropertyDescriptor, Bw = (n, e, t, r) => {
  for (var i = r > 1 ? void 0 : r ? hM(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (i = (r ? a(e, t, i) : a(i)) || i);
  return r && i && fM(e, t, i), i;
}, Ol = (n, e) => (t, r) => e(t, r, n);
const $w = pe.createInterface("TreasuryStore");
let Ic = class {
  constructor(n, e, t, r) {
    this.numberService = n, this.contractStore = e, this.contractService = t, this.dataStore = r;
  }
  totalSupply;
  totalValuation;
  treasuryDistribution;
  reservesDistribution;
  treasuryContract;
  lastRebaseTime;
  treasuryAssets = [];
  transactions = [];
  static register(n) {
    n.register(fe.singleton($w, Ic));
  }
  get treasuryValue() {
    return this.treasuryAssets?.length === 0 ? 0 : this.treasuryAssets?.map((n) => n?.total ?? 0).sum() ?? 0;
  }
  async loadTokenData() {
    if (this.totalValuation && this.totalSupply)
      return;
    const n = await this.getTreasuryContract();
    this.totalValuation = await n.totalValuation(), this.totalSupply = await n.totalSupply(), this.treasuryDistribution = (await this.getDistributionPercentage("Treasury")).toNumber() / 100, this.reservesDistribution = (await this.getDistributionPercentage("Reserve")).toNumber() / 100;
  }
  async loadAssets() {
    const n = await this.getTreasuryContract(), e = n.address;
    if (!e)
      return;
    const t = (await Promise.all([
      n.allRegisteredERC20s().then((r) => r.map((i) => ({ tokenId: void 0, address: i }))),
      n.allRegisteredERC721Ids().then((r) => r.map((i) => ({ tokenId: i.id, address: i.erc721 })))
    ])).flatMap((r) => r);
    this.treasuryAssets = (await Promise.all(
      t.map(
        (r) => this.contractStore.getAsset(r.address, r.tokenId, n, e, this.transactions).catch()
      )
    )).filter(Boolean);
  }
  async getValueOverTime(n) {
    const e = bw(n), r = (await this.dataStore.getDocs(
      `chartData/ktt/${gw(n)}`,
      "createdAt",
      "desc",
      { fieldPath: "createdAt", opStr: ">=", value: e }
    )).map((a) => ({
      createdAt: new Date(a.createdAt),
      value: this.numberService.fromString(nn(a.value, 18))
    }));
    r.sort((a, o) => new Date(a.createdAt).getTime() - new Date(o.createdAt).getTime());
    const s = await (await this.getTreasuryContract()).totalValuation();
    return r.push({
      createdAt: new Date(),
      value: this.numberService.fromString(nn(s, 18))
    }), r;
  }
  async getLastRebaseTime() {
    const n = await this.getTreasuryContract(), e = await n.queryFilter(n.filters.Rebase());
    e.sort((t, r) => r.blockNumber - t.blockNumber), this.lastRebaseTime = e[0] && new Date((await e[0].getBlock()).timestamp * 1e3);
  }
  get circulatingDistribution() {
    return this.treasuryDistribution == null || this.reservesDistribution == null ? 0 : 1 - (this.treasuryDistribution + this.reservesDistribution);
  }
  get currentPrice() {
    return !this.totalSupply || !this.totalValuation ? G.from(0) : this.totalSupply.div(this.totalValuation);
  }
  async getTreasuryContract() {
    return this.treasuryContract ? this.treasuryContract : (this.treasuryContract = await this.contractService.getContract("monetary", "Treasury"), this.treasuryContract);
  }
  async getDistributionPercentage(n) {
    const e = (await this.contractService.getContract("monetary", n)).address;
    return !e || !this.totalSupply ? G.from(0) : (await (await this.getTreasuryContract()).balanceOf(e)).div(this.totalSupply);
  }
};
Bw([
  Id()
], Ic.prototype, "loadAssets", 1);
Ic = Bw([
  Ol(0, ul),
  Ol(1, _p),
  Ol(2, So),
  Ol(3, Pp)
], Ic);
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Lw = function(n) {
  const e = [];
  let t = 0;
  for (let r = 0; r < n.length; r++) {
    let i = n.charCodeAt(r);
    i < 128 ? e[t++] = i : i < 2048 ? (e[t++] = i >> 6 | 192, e[t++] = i & 63 | 128) : (i & 64512) === 55296 && r + 1 < n.length && (n.charCodeAt(r + 1) & 64512) === 56320 ? (i = 65536 + ((i & 1023) << 10) + (n.charCodeAt(++r) & 1023), e[t++] = i >> 18 | 240, e[t++] = i >> 12 & 63 | 128, e[t++] = i >> 6 & 63 | 128, e[t++] = i & 63 | 128) : (e[t++] = i >> 12 | 224, e[t++] = i >> 6 & 63 | 128, e[t++] = i & 63 | 128);
  }
  return e;
}, pM = function(n) {
  const e = [];
  let t = 0, r = 0;
  for (; t < n.length; ) {
    const i = n[t++];
    if (i < 128)
      e[r++] = String.fromCharCode(i);
    else if (i > 191 && i < 224) {
      const s = n[t++];
      e[r++] = String.fromCharCode((i & 31) << 6 | s & 63);
    } else if (i > 239 && i < 365) {
      const s = n[t++], a = n[t++], o = n[t++], c = ((i & 7) << 18 | (s & 63) << 12 | (a & 63) << 6 | o & 63) - 65536;
      e[r++] = String.fromCharCode(55296 + (c >> 10)), e[r++] = String.fromCharCode(56320 + (c & 1023));
    } else {
      const s = n[t++], a = n[t++];
      e[r++] = String.fromCharCode((i & 15) << 12 | (s & 63) << 6 | a & 63);
    }
  }
  return e.join("");
}, Fw = {
  byteToCharMap_: null,
  charToByteMap_: null,
  byteToCharMapWebSafe_: null,
  charToByteMapWebSafe_: null,
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  encodeByteArray(n, e) {
    if (!Array.isArray(n))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const t = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, r = [];
    for (let i = 0; i < n.length; i += 3) {
      const s = n[i], a = i + 1 < n.length, o = a ? n[i + 1] : 0, c = i + 2 < n.length, l = c ? n[i + 2] : 0, f = s >> 2, p = (s & 3) << 4 | o >> 4;
      let g = (o & 15) << 2 | l >> 6, T = l & 63;
      c || (T = 64, a || (g = 64)), r.push(t[f], t[p], t[g], t[T]);
    }
    return r.join("");
  },
  encodeString(n, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? btoa(n) : this.encodeByteArray(Lw(n), e);
  },
  decodeString(n, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? atob(n) : pM(this.decodeStringToByteArray(n, e));
  },
  decodeStringToByteArray(n, e) {
    this.init_();
    const t = e ? this.charToByteMapWebSafe_ : this.charToByteMap_, r = [];
    for (let i = 0; i < n.length; ) {
      const s = t[n.charAt(i++)], o = i < n.length ? t[n.charAt(i)] : 0;
      ++i;
      const l = i < n.length ? t[n.charAt(i)] : 64;
      ++i;
      const p = i < n.length ? t[n.charAt(i)] : 64;
      if (++i, s == null || o == null || l == null || p == null)
        throw Error();
      const g = s << 2 | o >> 4;
      if (r.push(g), l !== 64) {
        const T = o << 4 & 240 | l >> 2;
        if (r.push(T), p !== 64) {
          const v = l << 6 & 192 | p;
          r.push(v);
        }
      }
    }
    return r;
  },
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let n = 0; n < this.ENCODED_VALS.length; n++)
        this.byteToCharMap_[n] = this.ENCODED_VALS.charAt(n), this.charToByteMap_[this.byteToCharMap_[n]] = n, this.byteToCharMapWebSafe_[n] = this.ENCODED_VALS_WEBSAFE.charAt(n), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[n]] = n, n >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(n)] = n, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(n)] = n);
    }
  }
}, mM = function(n) {
  const e = Lw(n);
  return Fw.encodeByteArray(e, !0);
}, Wu = function(n) {
  return mM(n).replace(/\./g, "");
}, yM = function(n) {
  try {
    return Fw.decodeString(n, !0);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
function gM() {
  return typeof indexedDB == "object";
}
function bM() {
  return new Promise((n, e) => {
    try {
      let t = !0;
      const r = "validate-browser-context-for-indexeddb-analytics-module", i = self.indexedDB.open(r);
      i.onsuccess = () => {
        i.result.close(), t || self.indexedDB.deleteDatabase(r), n(!0);
      }, i.onupgradeneeded = () => {
        t = !1;
      }, i.onerror = () => {
        var s;
        e(((s = i.error) === null || s === void 0 ? void 0 : s.message) || "");
      };
    } catch (t) {
      e(t);
    }
  });
}
function xM() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof na < "u")
    return na;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const vM = () => xM().__FIREBASE_DEFAULTS__, wM = () => {
  if (typeof Xl > "u" || typeof { ALLUSERSPROFILE: "C:\\ProgramData", AMDRMPATH: "C:\\Program Files\\AMD\\RyzenMaster\\", ANDROID_HOME: "C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk", APPDATA: "C:\\Users\\Brandon\\AppData\\Roaming", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_45880_UWUMZIVXPRYDKNKX", CLASSPATH: ".;", COLOR: "1", COLORTERM: "truecolor", COMMONPROGRAMFILES: "C:\\Program Files\\Common Files", COMPUTERNAME: "DESKTOP-72OQKP6", COMSPEC: "C:\\WINDOWS\\system32\\cmd.exe", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "132215198773539171", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "notepad.exe", EXEPATH: "C:\\Program Files\\Git\\bin", GIT_ASKPASS: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", HOME: "C:\\Users\\Brandon", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\Brandon", INIT_CWD: "C:\\Users\\Brandon\\source\\repos\\dapp", INTEL_DEV_REDIST: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\", JAVA_HOME: "C:\\Program Files\\Java\\jdk1.8.0_231", LANG: "en_US.UTF-8", LOCALAPPDATA: "C:\\Users\\Brandon\\AppData\\Local", LOGONSERVER: "\\\\DESKTOP-72OQKP6", MIC_LD_LIBRARY_PATH: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\compiler\\lib\\mic", MSYSTEM: "MINGW64", MYSQLCONNECTOR_ASSEMBLIESPATH: "C:\\Program Files (x86)\\MySQL\\Connector NET 8.0\\Assemblies\\v4.5.2", NODE: "C:\\Program Files\\nodejs\\node.exe", NUMBER_OF_PROCESSORS: "32", NVM_HOME: "C:\\Users\\Brandon\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", OcpApimSubscriptionKey: "15752dea34354b65bb7b54bca0da1b8d", OneDrive: "C:\\Users\\Brandon\\OneDrive - Grey & Co Salon", OneDriveCommercial: "C:\\Users\\Brandon\\OneDrive - Grey & Co Salon", PAC_CLI_LAUNCHER_AGENT: "powerplatform-vscode/1.0.21", PATH: "C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\Brandon\\bin;C:\\Users\\Brandon\\source\\repos\\dapp\\node_modules\\.bin;C:\\Users\\Brandon\\source\\repos\\node_modules\\.bin;C:\\Users\\Brandon\\source\\node_modules\\.bin;C:\\Users\\Brandon\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Users\\Brandon\\AppData\\Roaming\\Code\\User\\globalStorage\\microsoft-isvexptools.powerplatform-vscode\\pac\\tools;C:\\Program Files (x86)\\Razer Chroma SDK\\bin;C:\\Program Files\\Razer Chroma SDK\\bin;C:\\Program Files (x86)\\Razer\\ChromaBroadcast\\bin;C:\\Program Files\\Razer\\ChromaBroadcast\\bin;C:\\Python39\\Scripts;C:\\Python39;C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\redist\\intel64\\compiler;C:\\Python27;C:\\Python27\\Scripts;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\Program Files\\dotnet;C:\\Program Files\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\130\\Tools\\Binn;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\130\\DTS\\Binn;C:\\WINDOWS\\System32\\OpenSSH;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn;C:\\Program Files\\Microsoft VS Code Insiders\\bin;C:\\Program Files\\Java\\jdk1.8.0_231\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\platform-tools;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\DTS\\Binn;C:\\Program Files\\gradle-6.3\\bin;C:\\flutter\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\tools;C:\\Program Files\\MongoDB\\Server\\4.2\\bin;C:\\Program Files\\Microsoft\\Azure Functions Core Tools;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHu;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\npm;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\L;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files (x8;C:\\Program Files (x86)\\dotnet;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Program Files\\Git\\cmd;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\WINDOWS\\System32\\OpenSSH;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\ProgramData\\DockerDesktop\\version-bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Brandon\\AppData\\Local\\JetBrains\\Toolbox\\scripts;%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW;.CPL", PLINK_PROTOCOL: "ssh", PREFERRED_WORKSPACE_MANAGER: "yarn", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "AMD64 Family 23 Model 113 Stepping 0, AuthenticAMD", PROCESSOR_LEVEL: "23", PROCESSOR_REVISION: "7100", PROGRAMFILES: "C:\\Program Files", PSModulePath: "C:\\Users\\Brandon\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\PowerShell\\Modules\\", PUBLIC: "C:\\Users\\Public", PWD: "C:/Users/Brandon/source/repos/dapp", ProgramData: "C:\\ProgramData", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", SESSIONNAME: "Console", SHLVL: "0", SYSTEMDRIVE: "C:", SYSTEMROOT: "C:\\WINDOWS", TEMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", TERM: "xterm-256color", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.73.1", TMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", USERDOMAIN: "DESKTOP-72OQKP6", USERDOMAIN_ROAMINGPROFILE: "DESKTOP-72OQKP6", USERNAME: "Brandon", USERPROFILE: "C:\\Users\\Brandon", VS160PROCOMNTOOLS: "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\Common7\\Tools\\", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node", VSCODE_GIT_ASKPASS_MAIN: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-b178cbeab5-sock", WINDIR: "C:\\WINDOWS", "asl.log": "Destination=file", npm_command: "run-script", npm_config_cache: "C:\\Users\\Brandon\\AppData\\Local\\npm-cache", npm_config_global_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_globalconfig: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\etc\\npmrc", npm_config_init_module: "C:\\Users\\Brandon\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\Brandon\\source\\repos\\dapp", npm_config_metrics_registry: "https://registry.npmjs.org/", npm_config_node_gyp: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_script_shell: "C:\\Program Files\\git\\bin\\bash.exe", npm_config_shamefully_hoist: "true", npm_config_user_agent: "npm/8.6.0 node/v19.0.1 win32 x64 workspaces/false", npm_config_userconfig: "C:\\Users\\Brandon\\.npmrc", npm_execpath: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build:dev:chart-data-script", npm_lifecycle_script: "vite build --config vite.config-lib.ts --mode development", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_engines_node: ">=16.0.0", npm_package_json: "C:\\Users\\Brandon\\source\\repos\\dapp\\package.json", npm_package_name: "@kolektivo/dapp", npm_package_version: "1.0.0" } > "u")
    return;
  const n = { ALLUSERSPROFILE: "C:\\ProgramData", AMDRMPATH: "C:\\Program Files\\AMD\\RyzenMaster\\", ANDROID_HOME: "C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk", APPDATA: "C:\\Users\\Brandon\\AppData\\Roaming", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_45880_UWUMZIVXPRYDKNKX", CLASSPATH: ".;", COLOR: "1", COLORTERM: "truecolor", COMMONPROGRAMFILES: "C:\\Program Files\\Common Files", COMPUTERNAME: "DESKTOP-72OQKP6", COMSPEC: "C:\\WINDOWS\\system32\\cmd.exe", ChocolateyInstall: "C:\\ProgramData\\chocolatey", ChocolateyLastPathUpdate: "132215198773539171", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "notepad.exe", EXEPATH: "C:\\Program Files\\Git\\bin", GIT_ASKPASS: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", HOME: "C:\\Users\\Brandon", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\Brandon", INIT_CWD: "C:\\Users\\Brandon\\source\\repos\\dapp", INTEL_DEV_REDIST: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\", JAVA_HOME: "C:\\Program Files\\Java\\jdk1.8.0_231", LANG: "en_US.UTF-8", LOCALAPPDATA: "C:\\Users\\Brandon\\AppData\\Local", LOGONSERVER: "\\\\DESKTOP-72OQKP6", MIC_LD_LIBRARY_PATH: "C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\compiler\\lib\\mic", MSYSTEM: "MINGW64", MYSQLCONNECTOR_ASSEMBLIESPATH: "C:\\Program Files (x86)\\MySQL\\Connector NET 8.0\\Assemblies\\v4.5.2", NODE: "C:\\Program Files\\nodejs\\node.exe", NUMBER_OF_PROCESSORS: "32", NVM_HOME: "C:\\Users\\Brandon\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", OcpApimSubscriptionKey: "15752dea34354b65bb7b54bca0da1b8d", OneDrive: "C:\\Users\\Brandon\\OneDrive - Grey & Co Salon", OneDriveCommercial: "C:\\Users\\Brandon\\OneDrive - Grey & Co Salon", PAC_CLI_LAUNCHER_AGENT: "powerplatform-vscode/1.0.21", PATH: "C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\Brandon\\bin;C:\\Users\\Brandon\\source\\repos\\dapp\\node_modules\\.bin;C:\\Users\\Brandon\\source\\repos\\node_modules\\.bin;C:\\Users\\Brandon\\source\\node_modules\\.bin;C:\\Users\\Brandon\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Users\\Brandon\\AppData\\Roaming\\Code\\User\\globalStorage\\microsoft-isvexptools.powerplatform-vscode\\pac\\tools;C:\\Program Files (x86)\\Razer Chroma SDK\\bin;C:\\Program Files\\Razer Chroma SDK\\bin;C:\\Program Files (x86)\\Razer\\ChromaBroadcast\\bin;C:\\Program Files\\Razer\\ChromaBroadcast\\bin;C:\\Python39\\Scripts;C:\\Python39;C:\\Program Files (x86)\\Common Files\\Intel\\Shared Libraries\\redist\\intel64\\compiler;C:\\Python27;C:\\Python27\\Scripts;C:\\ProgramData\\Oracle\\Java\\javapath;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\Program Files\\dotnet;C:\\Program Files\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\130\\Tools\\Binn;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\Binn;C:\\Program Files\\Microsoft SQL Server\\130\\DTS\\Binn;C:\\WINDOWS\\System32\\OpenSSH;C:\\ProgramData\\chocolatey\\bin;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn;C:\\Program Files\\Microsoft VS Code Insiders\\bin;C:\\Program Files\\Java\\jdk1.8.0_231\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\platform-tools;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\DTS\\Binn;C:\\Program Files\\gradle-6.3\\bin;C:\\flutter\\bin;C:\\Users\\Brandon\\AppData\\Local\\Android\\Sdk\\tools;C:\\Program Files\\MongoDB\\Server\\4.2\\bin;C:\\Program Files\\Microsoft\\Azure Functions Core Tools;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHu;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\npm;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\L;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files (x8;C:\\Program Files (x86)\\dotnet;C:\\WINDOWS\\system32\\config\\systemprofile\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Program Files\\Git\\cmd;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\WINDOWS\\System32\\OpenSSH;C:\\Program Files\\Docker\\Docker\\resources\\bin;C:\\ProgramData\\DockerDesktop\\version-bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\PowerAppsCLI;C:\\Program Files\\MySQL\\MySQL Shell 8.0\\bin;C:\\Users\\Brandon\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\Brandon\\.dotnet\\tools;C:\\Users\\Brandon\\AppData\\Local\\GitHubDesktop\\bin;C:\\Nuget;C:\\Program Files\\OpenSSL-Win64\\bin;C:\\Users\\Brandon\\AppData\\Local\\Programs\\Fiddler;C:\\Program Files\\maven\\bin;C:\\Program Files (x86)\\Rico Suter\\NSwagStudio;C:\\Users\\Brandon\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Brandon\\AppData\\Local\\JetBrains\\Toolbox\\scripts;%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW;.CPL", PLINK_PROTOCOL: "ssh", PREFERRED_WORKSPACE_MANAGER: "yarn", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "AMD64 Family 23 Model 113 Stepping 0, AuthenticAMD", PROCESSOR_LEVEL: "23", PROCESSOR_REVISION: "7100", PROGRAMFILES: "C:\\Program Files", PSModulePath: "C:\\Users\\Brandon\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\130\\Tools\\PowerShell\\Modules\\", PUBLIC: "C:\\Users\\Public", PWD: "C:/Users/Brandon/source/repos/dapp", ProgramData: "C:\\ProgramData", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", SESSIONNAME: "Console", SHLVL: "0", SYSTEMDRIVE: "C:", SYSTEMROOT: "C:\\WINDOWS", TEMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", TERM: "xterm-256color", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.73.1", TMP: "C:\\Users\\Brandon\\AppData\\Local\\Temp", USERDOMAIN: "DESKTOP-72OQKP6", USERDOMAIN_ROAMINGPROFILE: "DESKTOP-72OQKP6", USERNAME: "Brandon", USERPROFILE: "C:\\Users\\Brandon", VS160PROCOMNTOOLS: "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Preview\\Common7\\Tools\\", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node", VSCODE_GIT_ASKPASS_MAIN: "c:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "C:\\Users\\Brandon\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-b178cbeab5-sock", WINDIR: "C:\\WINDOWS", "asl.log": "Destination=file", npm_command: "run-script", npm_config_cache: "C:\\Users\\Brandon\\AppData\\Local\\npm-cache", npm_config_global_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_globalconfig: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\etc\\npmrc", npm_config_init_module: "C:\\Users\\Brandon\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\Brandon\\source\\repos\\dapp", npm_config_metrics_registry: "https://registry.npmjs.org/", npm_config_node_gyp: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_prefix: "C:\\Users\\Brandon\\AppData\\Roaming\\npm", npm_config_script_shell: "C:\\Program Files\\git\\bin\\bash.exe", npm_config_shamefully_hoist: "true", npm_config_user_agent: "npm/8.6.0 node/v19.0.1 win32 x64 workspaces/false", npm_config_userconfig: "C:\\Users\\Brandon\\.npmrc", npm_execpath: "C:\\Users\\Brandon\\AppData\\Roaming\\npm\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build:dev:chart-data-script", npm_lifecycle_script: "vite build --config vite.config-lib.ts --mode development", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_engines_node: ">=16.0.0", npm_package_json: "C:\\Users\\Brandon\\source\\repos\\dapp\\package.json", npm_package_name: "@kolektivo/dapp", npm_package_version: "1.0.0" }.__FIREBASE_DEFAULTS__;
  if (n)
    return JSON.parse(n);
}, AM = () => {
  if (typeof document > "u")
    return;
  let n;
  try {
    n = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const e = n && yM(n[1]);
  return e && JSON.parse(e);
}, Uw = () => {
  try {
    return vM() || wM() || AM();
  } catch (n) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${n}`);
    return;
  }
}, TM = (n) => {
  var e, t;
  return (t = (e = Uw()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || t === void 0 ? void 0 : t[n];
}, CM = (n) => {
  const e = TM(n);
  if (!e)
    return;
  const t = e.lastIndexOf(":");
  if (t <= 0 || t + 1 === e.length)
    throw new Error(`Invalid host ${e} with no separate hostname and port!`);
  const r = parseInt(e.substring(t + 1), 10);
  return e[0] === "[" ? [e.substring(1, t - 1), r] : [e.substring(0, t), r];
}, EM = () => {
  var n;
  return (n = Uw()) === null || n === void 0 ? void 0 : n.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SM {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
  wrapCallback(e) {
    return (t, r) => {
      t ? this.reject(t) : this.resolve(r), typeof e == "function" && (this.promise.catch(() => {
      }), e.length === 1 ? e(t) : e(t, r));
    };
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _M(n, e) {
  if (n.uid)
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  const t = {
    alg: "none",
    type: "JWT"
  }, r = e || "demo-project", i = n.iat || 0, s = n.sub || n.user_id;
  if (!s)
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  const a = Object.assign({
    iss: `https://securetoken.google.com/${r}`,
    aud: r,
    iat: i,
    exp: i + 3600,
    auth_time: i,
    sub: s,
    user_id: s,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, n), o = "";
  return [
    Wu(JSON.stringify(t)),
    Wu(JSON.stringify(a)),
    o
  ].join(".");
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PM = "FirebaseError";
class _o extends Error {
  constructor(e, t, r) {
    super(t), this.code = e, this.customData = r, this.name = PM, Object.setPrototypeOf(this, _o.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Vw.prototype.create);
  }
}
class Vw {
  constructor(e, t, r) {
    this.service = e, this.serviceName = t, this.errors = r;
  }
  create(e, ...t) {
    const r = t[0] || {}, i = `${this.service}/${e}`, s = this.errors[e], a = s ? MM(s, r) : "Error", o = `${this.serviceName}: ${a} (${i}).`;
    return new _o(i, o, r);
  }
}
function MM(n, e) {
  return n.replace(RM, (t, r) => {
    const i = e[r];
    return i != null ? String(i) : `<${r}?>`;
  });
}
const RM = /\{\$([^}]+)}/g;
function Hu(n, e) {
  if (n === e)
    return !0;
  const t = Object.keys(n), r = Object.keys(e);
  for (const i of t) {
    if (!r.includes(i))
      return !1;
    const s = n[i], a = e[i];
    if (ax(s) && ax(a)) {
      if (!Hu(s, a))
        return !1;
    } else if (s !== a)
      return !1;
  }
  for (const i of r)
    if (!t.includes(i))
      return !1;
  return !0;
}
function ax(n) {
  return n !== null && typeof n == "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ut(n) {
  return n && n._delegate ? n._delegate : n;
}
class Oc {
  constructor(e, t, r) {
    this.name = e, this.instanceFactory = t, this.type = r, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(e) {
    return this.instantiationMode = e, this;
  }
  setMultipleInstances(e) {
    return this.multipleInstances = e, this;
  }
  setServiceProps(e) {
    return this.serviceProps = e, this;
  }
  setInstanceCreatedCallback(e) {
    return this.onInstanceCreated = e, this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ws = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class kM {
  constructor(e, t) {
    this.name = e, this.container = t, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  get(e) {
    const t = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(t)) {
      const r = new SM();
      if (this.instancesDeferred.set(t, r), this.isInitialized(t) || this.shouldAutoInitialize())
        try {
          const i = this.getOrInitializeService({
            instanceIdentifier: t
          });
          i && r.resolve(i);
        } catch {
        }
    }
    return this.instancesDeferred.get(t).promise;
  }
  getImmediate(e) {
    var t;
    const r = this.normalizeInstanceIdentifier(e?.identifier), i = (t = e?.optional) !== null && t !== void 0 ? t : !1;
    if (this.isInitialized(r) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: r
        });
      } catch (s) {
        if (i)
          return null;
        throw s;
      }
    else {
      if (i)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name)
      throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = e, !!this.shouldAutoInitialize()) {
      if (OM(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: Ws });
        } catch {
        }
      for (const [t, r] of this.instancesDeferred.entries()) {
        const i = this.normalizeInstanceIdentifier(t);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: i
          });
          r.resolve(s);
        } catch {
        }
      }
    }
  }
  clearInstance(e = Ws) {
    this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
  }
  async delete() {
    const e = Array.from(this.instances.values());
    await Promise.all([
      ...e.filter((t) => "INTERNAL" in t).map((t) => t.INTERNAL.delete()),
      ...e.filter((t) => "_delete" in t).map((t) => t._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(e = Ws) {
    return this.instances.has(e);
  }
  getOptions(e = Ws) {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    const { options: t = {} } = e, r = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(r))
      throw Error(`${this.name}(${r}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const i = this.getOrInitializeService({
      instanceIdentifier: r,
      options: t
    });
    for (const [s, a] of this.instancesDeferred.entries()) {
      const o = this.normalizeInstanceIdentifier(s);
      r === o && a.resolve(i);
    }
    return i;
  }
  onInit(e, t) {
    var r;
    const i = this.normalizeInstanceIdentifier(t), s = (r = this.onInitCallbacks.get(i)) !== null && r !== void 0 ? r : /* @__PURE__ */ new Set();
    s.add(e), this.onInitCallbacks.set(i, s);
    const a = this.instances.get(i);
    return a && e(a, i), () => {
      s.delete(e);
    };
  }
  invokeOnInitCallbacks(e, t) {
    const r = this.onInitCallbacks.get(t);
    if (!!r)
      for (const i of r)
        try {
          i(e, t);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: e, options: t = {} }) {
    let r = this.instances.get(e);
    if (!r && this.component && (r = this.component.instanceFactory(this.container, {
      instanceIdentifier: IM(e),
      options: t
    }), this.instances.set(e, r), this.instancesOptions.set(e, t), this.invokeOnInitCallbacks(r, e), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, e, r);
      } catch {
      }
    return r || null;
  }
  normalizeInstanceIdentifier(e = Ws) {
    return this.component ? this.component.multipleInstances ? e : Ws : e;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function IM(n) {
  return n === Ws ? void 0 : n;
}
function OM(n) {
  return n.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DM {
  constructor(e) {
    this.name = e, this.providers = /* @__PURE__ */ new Map();
  }
  addComponent(e) {
    const t = this.getProvider(e.name);
    if (t.isComponentSet())
      throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
    t.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
  }
  getProvider(e) {
    if (this.providers.has(e))
      return this.providers.get(e);
    const t = new kM(e, this);
    return this.providers.set(e, t), t;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Oe;
(function(n) {
  n[n.DEBUG = 0] = "DEBUG", n[n.VERBOSE = 1] = "VERBOSE", n[n.INFO = 2] = "INFO", n[n.WARN = 3] = "WARN", n[n.ERROR = 4] = "ERROR", n[n.SILENT = 5] = "SILENT";
})(Oe || (Oe = {}));
const NM = {
  debug: Oe.DEBUG,
  verbose: Oe.VERBOSE,
  info: Oe.INFO,
  warn: Oe.WARN,
  error: Oe.ERROR,
  silent: Oe.SILENT
}, BM = Oe.INFO, $M = {
  [Oe.DEBUG]: "log",
  [Oe.VERBOSE]: "log",
  [Oe.INFO]: "info",
  [Oe.WARN]: "warn",
  [Oe.ERROR]: "error"
}, LM = (n, e, ...t) => {
  if (e < n.logLevel)
    return;
  const r = new Date().toISOString(), i = $M[e];
  if (i)
    console[i](`[${r}]  ${n.name}:`, ...t);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
};
class jw {
  constructor(e) {
    this.name = e, this._logLevel = BM, this._logHandler = LM, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(e) {
    if (!(e in Oe))
      throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
    this._logLevel = e;
  }
  setLogLevel(e) {
    this._logLevel = typeof e == "string" ? NM[e] : e;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(e) {
    if (typeof e != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = e;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(e) {
    this._userLogHandler = e;
  }
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, Oe.DEBUG, ...e), this._logHandler(this, Oe.DEBUG, ...e);
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, Oe.VERBOSE, ...e), this._logHandler(this, Oe.VERBOSE, ...e);
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, Oe.INFO, ...e), this._logHandler(this, Oe.INFO, ...e);
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, Oe.WARN, ...e), this._logHandler(this, Oe.WARN, ...e);
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, Oe.ERROR, ...e), this._logHandler(this, Oe.ERROR, ...e);
  }
}
const FM = (n, e) => e.some((t) => n instanceof t);
let ox, cx;
function UM() {
  return ox || (ox = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function VM() {
  return cx || (cx = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const Gw = /* @__PURE__ */ new WeakMap(), zh = /* @__PURE__ */ new WeakMap(), Ww = /* @__PURE__ */ new WeakMap(), Jf = /* @__PURE__ */ new WeakMap(), Mp = /* @__PURE__ */ new WeakMap();
function jM(n) {
  const e = new Promise((t, r) => {
    const i = () => {
      n.removeEventListener("success", s), n.removeEventListener("error", a);
    }, s = () => {
      t(ls(n.result)), i();
    }, a = () => {
      r(n.error), i();
    };
    n.addEventListener("success", s), n.addEventListener("error", a);
  });
  return e.then((t) => {
    t instanceof IDBCursor && Gw.set(t, n);
  }).catch(() => {
  }), Mp.set(e, n), e;
}
function GM(n) {
  if (zh.has(n))
    return;
  const e = new Promise((t, r) => {
    const i = () => {
      n.removeEventListener("complete", s), n.removeEventListener("error", a), n.removeEventListener("abort", a);
    }, s = () => {
      t(), i();
    }, a = () => {
      r(n.error || new DOMException("AbortError", "AbortError")), i();
    };
    n.addEventListener("complete", s), n.addEventListener("error", a), n.addEventListener("abort", a);
  });
  zh.set(n, e);
}
let Kh = {
  get(n, e, t) {
    if (n instanceof IDBTransaction) {
      if (e === "done")
        return zh.get(n);
      if (e === "objectStoreNames")
        return n.objectStoreNames || Ww.get(n);
      if (e === "store")
        return t.objectStoreNames[1] ? void 0 : t.objectStore(t.objectStoreNames[0]);
    }
    return ls(n[e]);
  },
  set(n, e, t) {
    return n[e] = t, !0;
  },
  has(n, e) {
    return n instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in n;
  }
};
function WM(n) {
  Kh = n(Kh);
}
function HM(n) {
  return n === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...t) {
    const r = n.call(Yf(this), e, ...t);
    return Ww.set(r, e.sort ? e.sort() : [e]), ls(r);
  } : VM().includes(n) ? function(...e) {
    return n.apply(Yf(this), e), ls(Gw.get(this));
  } : function(...e) {
    return ls(n.apply(Yf(this), e));
  };
}
function zM(n) {
  return typeof n == "function" ? HM(n) : (n instanceof IDBTransaction && GM(n), FM(n, UM()) ? new Proxy(n, Kh) : n);
}
function ls(n) {
  if (n instanceof IDBRequest)
    return jM(n);
  if (Jf.has(n))
    return Jf.get(n);
  const e = zM(n);
  return e !== n && (Jf.set(n, e), Mp.set(e, n)), e;
}
const Yf = (n) => Mp.get(n);
function KM(n, e, { blocked: t, upgrade: r, blocking: i, terminated: s } = {}) {
  const a = indexedDB.open(n, e), o = ls(a);
  return r && a.addEventListener("upgradeneeded", (c) => {
    r(ls(a.result), c.oldVersion, c.newVersion, ls(a.transaction));
  }), t && a.addEventListener("blocked", () => t()), o.then((c) => {
    s && c.addEventListener("close", () => s()), i && c.addEventListener("versionchange", () => i());
  }).catch(() => {
  }), o;
}
const qM = ["get", "getKey", "getAll", "getAllKeys", "count"], QM = ["put", "add", "delete", "clear"], Xf = /* @__PURE__ */ new Map();
function lx(n, e) {
  if (!(n instanceof IDBDatabase && !(e in n) && typeof e == "string"))
    return;
  if (Xf.get(e))
    return Xf.get(e);
  const t = e.replace(/FromIndex$/, ""), r = e !== t, i = QM.includes(t);
  if (!(t in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || qM.includes(t)))
    return;
  const s = async function(a, ...o) {
    const c = this.transaction(a, i ? "readwrite" : "readonly");
    let l = c.store;
    return r && (l = l.index(o.shift())), (await Promise.all([
      l[t](...o),
      i && c.done
    ]))[0];
  };
  return Xf.set(e, s), s;
}
WM((n) => ({
  ...n,
  get: (e, t, r) => lx(e, t) || n.get(e, t, r),
  has: (e, t) => !!lx(e, t) || n.has(e, t)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JM {
  constructor(e) {
    this.container = e;
  }
  getPlatformInfoString() {
    return this.container.getProviders().map((t) => {
      if (YM(t)) {
        const r = t.getImmediate();
        return `${r.library}/${r.version}`;
      } else
        return null;
    }).filter((t) => t).join(" ");
  }
}
function YM(n) {
  const e = n.getComponent();
  return e?.type === "VERSION";
}
const qh = "@firebase/app", ux = "0.8.3";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const oa = new jw("@firebase/app"), XM = "@firebase/app-compat", ZM = "@firebase/analytics-compat", eR = "@firebase/analytics", tR = "@firebase/app-check-compat", nR = "@firebase/app-check", rR = "@firebase/auth", iR = "@firebase/auth-compat", sR = "@firebase/database", aR = "@firebase/database-compat", oR = "@firebase/functions", cR = "@firebase/functions-compat", lR = "@firebase/installations", uR = "@firebase/installations-compat", dR = "@firebase/messaging", fR = "@firebase/messaging-compat", hR = "@firebase/performance", pR = "@firebase/performance-compat", mR = "@firebase/remote-config", yR = "@firebase/remote-config-compat", gR = "@firebase/storage", bR = "@firebase/storage-compat", xR = "@firebase/firestore", vR = "@firebase/firestore-compat", wR = "firebase", AR = "9.13.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const zu = "[DEFAULT]", TR = {
  [qh]: "fire-core",
  [XM]: "fire-core-compat",
  [eR]: "fire-analytics",
  [ZM]: "fire-analytics-compat",
  [nR]: "fire-app-check",
  [tR]: "fire-app-check-compat",
  [rR]: "fire-auth",
  [iR]: "fire-auth-compat",
  [sR]: "fire-rtdb",
  [aR]: "fire-rtdb-compat",
  [oR]: "fire-fn",
  [cR]: "fire-fn-compat",
  [lR]: "fire-iid",
  [uR]: "fire-iid-compat",
  [dR]: "fire-fcm",
  [fR]: "fire-fcm-compat",
  [hR]: "fire-perf",
  [pR]: "fire-perf-compat",
  [mR]: "fire-rc",
  [yR]: "fire-rc-compat",
  [gR]: "fire-gcs",
  [bR]: "fire-gcs-compat",
  [xR]: "fire-fst",
  [vR]: "fire-fst-compat",
  "fire-js": "fire-js",
  [wR]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ku = /* @__PURE__ */ new Map(), Qh = /* @__PURE__ */ new Map();
function CR(n, e) {
  try {
    n.container.addComponent(e);
  } catch (t) {
    oa.debug(`Component ${e.name} failed to register with FirebaseApp ${n.name}`, t);
  }
}
function qu(n) {
  const e = n.name;
  if (Qh.has(e))
    return oa.debug(`There were multiple attempts to register component ${e}.`), !1;
  Qh.set(e, n);
  for (const t of Ku.values())
    CR(t, n);
  return !0;
}
function Rp(n, e) {
  const t = n.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return t && t.triggerHeartbeat(), n.container.getProvider(e);
}
function ER(n, e, t = zu) {
  Rp(n, e).clearInstance(t);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SR = {
  ["no-app"]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  ["bad-app-name"]: "Illegal App name: '{$appName}",
  ["duplicate-app"]: "Firebase App named '{$appName}' already exists with different options or config",
  ["app-deleted"]: "Firebase App named '{$appName}' already deleted",
  ["no-options"]: "Need to provide options, when not being deployed to hosting via source.",
  ["invalid-app-argument"]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  ["invalid-log-argument"]: "First argument to `onLog` must be null or a function.",
  ["idb-open"]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  ["idb-get"]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  ["idb-set"]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  ["idb-delete"]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
}, us = new Vw("app", "Firebase", SR);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _R {
  constructor(e, t, r) {
    this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, t), this._name = t.name, this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled, this._container = r, this.container.addComponent(new Oc("app", () => this, "PUBLIC"));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = e;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  checkDestroyed() {
    if (this.isDeleted)
      throw us.create("app-deleted", { appName: this._name });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PR = AR;
function Hw(n, e = {}) {
  let t = n;
  typeof e != "object" && (e = { name: e });
  const r = Object.assign({ name: zu, automaticDataCollectionEnabled: !1 }, e), i = r.name;
  if (typeof i != "string" || !i)
    throw us.create("bad-app-name", {
      appName: String(i)
    });
  if (t || (t = EM()), !t)
    throw us.create("no-options");
  const s = Ku.get(i);
  if (s) {
    if (Hu(t, s.options) && Hu(r, s.config))
      return s;
    throw us.create("duplicate-app", { appName: i });
  }
  const a = new DM(i);
  for (const c of Qh.values())
    a.addComponent(c);
  const o = new _R(t, r, a);
  return Ku.set(i, o), o;
}
function MR(n = zu) {
  const e = Ku.get(n);
  if (!e && n === zu)
    return Hw();
  if (!e)
    throw us.create("no-app", { appName: n });
  return e;
}
function za(n, e, t) {
  var r;
  let i = (r = TR[n]) !== null && r !== void 0 ? r : n;
  t && (i += `-${t}`);
  const s = i.match(/\s|\//), a = e.match(/\s|\//);
  if (s || a) {
    const o = [
      `Unable to register library "${i}" with version "${e}":`
    ];
    s && o.push(`library name "${i}" contains illegal characters (whitespace or "/")`), s && a && o.push("and"), a && o.push(`version name "${e}" contains illegal characters (whitespace or "/")`), oa.warn(o.join(" "));
    return;
  }
  qu(new Oc(`${i}-version`, () => ({ library: i, version: e }), "VERSION"));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const RR = "firebase-heartbeat-database", kR = 1, Dc = "firebase-heartbeat-store";
let Zf = null;
function zw() {
  return Zf || (Zf = KM(RR, kR, {
    upgrade: (n, e) => {
      switch (e) {
        case 0:
          n.createObjectStore(Dc);
      }
    }
  }).catch((n) => {
    throw us.create("idb-open", {
      originalErrorMessage: n.message
    });
  })), Zf;
}
async function IR(n) {
  var e;
  try {
    return (await zw()).transaction(Dc).objectStore(Dc).get(Kw(n));
  } catch (t) {
    if (t instanceof _o)
      oa.warn(t.message);
    else {
      const r = us.create("idb-get", {
        originalErrorMessage: (e = t) === null || e === void 0 ? void 0 : e.message
      });
      oa.warn(r.message);
    }
  }
}
async function dx(n, e) {
  var t;
  try {
    const i = (await zw()).transaction(Dc, "readwrite");
    return await i.objectStore(Dc).put(e, Kw(n)), i.done;
  } catch (r) {
    if (r instanceof _o)
      oa.warn(r.message);
    else {
      const i = us.create("idb-set", {
        originalErrorMessage: (t = r) === null || t === void 0 ? void 0 : t.message
      });
      oa.warn(i.message);
    }
  }
}
function Kw(n) {
  return `${n.name}!${n.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const OR = 1024, DR = 30 * 24 * 60 * 60 * 1e3;
class NR {
  constructor(e) {
    this.container = e, this._heartbeatsCache = null;
    const t = this.container.getProvider("app").getImmediate();
    this._storage = new $R(t), this._heartbeatsCachePromise = this._storage.read().then((r) => (this._heartbeatsCache = r, r));
  }
  async triggerHeartbeat() {
    const t = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), r = fx();
    if (this._heartbeatsCache === null && (this._heartbeatsCache = await this._heartbeatsCachePromise), !(this._heartbeatsCache.lastSentHeartbeatDate === r || this._heartbeatsCache.heartbeats.some((i) => i.date === r)))
      return this._heartbeatsCache.heartbeats.push({ date: r, agent: t }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((i) => {
        const s = new Date(i.date).valueOf();
        return Date.now() - s <= DR;
      }), this._storage.overwrite(this._heartbeatsCache);
  }
  async getHeartbeatsHeader() {
    if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0)
      return "";
    const e = fx(), { heartbeatsToSend: t, unsentEntries: r } = BR(this._heartbeatsCache.heartbeats), i = Wu(JSON.stringify({ version: 2, heartbeats: t }));
    return this._heartbeatsCache.lastSentHeartbeatDate = e, r.length > 0 ? (this._heartbeatsCache.heartbeats = r, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), i;
  }
}
function fx() {
  return new Date().toISOString().substring(0, 10);
}
function BR(n, e = OR) {
  const t = [];
  let r = n.slice();
  for (const i of n) {
    const s = t.find((a) => a.agent === i.agent);
    if (s) {
      if (s.dates.push(i.date), hx(t) > e) {
        s.dates.pop();
        break;
      }
    } else if (t.push({
      agent: i.agent,
      dates: [i.date]
    }), hx(t) > e) {
      t.pop();
      break;
    }
    r = r.slice(1);
  }
  return {
    heartbeatsToSend: t,
    unsentEntries: r
  };
}
class $R {
  constructor(e) {
    this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return gM() ? bM().then(() => !0).catch(() => !1) : !1;
  }
  async read() {
    return await this._canUseIndexedDBPromise ? await IR(this.app) || { heartbeats: [] } : { heartbeats: [] };
  }
  async overwrite(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return dx(this.app, {
        lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : i.lastSentHeartbeatDate,
        heartbeats: e.heartbeats
      });
    } else
      return;
  }
  async add(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      const i = await this.read();
      return dx(this.app, {
        lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : i.lastSentHeartbeatDate,
        heartbeats: [
          ...i.heartbeats,
          ...e.heartbeats
        ]
      });
    } else
      return;
  }
}
function hx(n) {
  return Wu(
    JSON.stringify({ version: 2, heartbeats: n })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function LR(n) {
  qu(new Oc("platform-logger", (e) => new JM(e), "PRIVATE")), qu(new Oc("heartbeat", (e) => new NR(e), "PRIVATE")), za(qh, ux, n), za(qh, ux, "esm2017"), za("fire-js", "");
}
LR("");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Sn {
  constructor(e) {
    this.uid = e;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(e) {
    return e.uid === this.uid;
  }
}
Sn.UNAUTHENTICATED = new Sn(null), Sn.GOOGLE_CREDENTIALS = new Sn("google-credentials-uid"), Sn.FIRST_PARTY = new Sn("first-party-uid"), Sn.MOCK_USER = new Sn("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Po = "9.13.0";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ca = new jw("@firebase/firestore");
function FR(n) {
  ca.setLogLevel(n);
}
function la(n, ...e) {
  if (ca.logLevel <= Oe.DEBUG) {
    const t = e.map(kp);
    ca.debug(`Firestore (${Po}): ${n}`, ...t);
  }
}
function Dd(n, ...e) {
  if (ca.logLevel <= Oe.ERROR) {
    const t = e.map(kp);
    ca.error(`Firestore (${Po}): ${n}`, ...t);
  }
}
function qw(n, ...e) {
  if (ca.logLevel <= Oe.WARN) {
    const t = e.map(kp);
    ca.warn(`Firestore (${Po}): ${n}`, ...t);
  }
}
function kp(n) {
  if (typeof n == "string")
    return n;
  try {
    return e = n, JSON.stringify(e);
  } catch {
    return n;
  }
  /**
  * @license
  * Copyright 2020 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  var e;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function De(n = "Unexpected state") {
  const e = `FIRESTORE (${Po}) INTERNAL ASSERTION FAILED: ` + n;
  throw Dd(e), new Error(e);
}
function pn(n, e) {
  n || De();
}
function Mo(n, e) {
  return n;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const px = "ok", Ip = "cancelled", Ka = "unknown", ie = "invalid-argument", Qw = "deadline-exceeded", Op = "not-found", UR = "already-exists", Jw = "permission-denied", Qu = "unauthenticated", Yw = "resource-exhausted", Pi = "failed-precondition", Dp = "aborted", Xw = "out-of-range", Np = "unimplemented", Zw = "internal", e6 = "unavailable", VR = "data-loss";
class J extends _o {
  constructor(e, t) {
    super(e, t), this.code = e, this.message = t, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bp {
  constructor() {
    this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class t6 {
  constructor(e, t) {
    this.user = t, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${e}`);
  }
}
class jR {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
    e.enqueueRetryable(() => t(Sn.UNAUTHENTICATED));
  }
  shutdown() {
  }
}
class GR {
  constructor(e) {
    this.token = e, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(e, t) {
    this.changeListener = t, e.enqueueRetryable(() => t(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class WR {
  constructor(e) {
    this.auth = null, e.onInit((t) => {
      this.auth = t;
    });
  }
  getToken() {
    return this.auth ? this.auth.getToken().then((e) => e ? (pn(typeof e.accessToken == "string"), new t6(e.accessToken, new Sn(this.auth.getUid()))) : null) : Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
  }
  shutdown() {
  }
}
class HR {
  constructor(e, t, r, i) {
    this.t = e, this.i = t, this.o = r, this.u = i, this.type = "FirstParty", this.user = Sn.FIRST_PARTY, this.h = /* @__PURE__ */ new Map();
  }
  l() {
    return this.u ? this.u() : (pn(!(typeof this.t != "object" || this.t === null || !this.t.auth || !this.t.auth.getAuthHeaderValueForFirstParty)), this.t.auth.getAuthHeaderValueForFirstParty([]));
  }
  get headers() {
    this.h.set("X-Goog-AuthUser", this.i);
    const e = this.l();
    return e && this.h.set("Authorization", e), this.o && this.h.set("X-Goog-Iam-Authorization-Token", this.o), this.h;
  }
}
class zR {
  constructor(e, t, r, i) {
    this.t = e, this.i = t, this.o = r, this.u = i;
  }
  getToken() {
    return Promise.resolve(new HR(this.t, this.i, this.o, this.u));
  }
  start(e, t) {
    e.enqueueRetryable(() => t(Sn.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
}
class KR {
  constructor(e) {
    this.value = e, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
}
class qR {
  constructor(e) {
    this.m = e, this.appCheck = null, e.onInit((t) => {
      this.appCheck = t;
    });
  }
  getToken() {
    return this.appCheck ? this.appCheck.getToken().then((e) => e ? (pn(typeof e.token == "string"), new KR(e.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
  }
  shutdown() {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class QR {
  constructor(e, t, r, i, s, a, o, c) {
    this.databaseId = e, this.appId = t, this.persistenceKey = r, this.host = i, this.ssl = s, this.forceLongPolling = a, this.autoDetectLongPolling = o, this.useFetchStreams = c;
  }
}
class Nc {
  constructor(e, t) {
    this.projectId = e, this.database = t || "(default)";
  }
  static empty() {
    return new Nc("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(e) {
    return e instanceof Nc && e.projectId === this.projectId && e.database === this.database;
  }
}
class Bc {
  constructor(e, t, r) {
    t === void 0 ? t = 0 : t > e.length && De(), r === void 0 ? r = e.length - t : r > e.length - t && De(), this.segments = e, this.offset = t, this.len = r;
  }
  get length() {
    return this.len;
  }
  isEqual(e) {
    return Bc.comparator(this, e) === 0;
  }
  child(e) {
    const t = this.segments.slice(this.offset, this.limit());
    return e instanceof Bc ? e.forEach((r) => {
      t.push(r);
    }) : t.push(e), this.construct(t);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(e) {
    return e = e === void 0 ? 1 : e, this.construct(this.segments, this.offset + e, this.length - e);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(e) {
    return this.segments[this.offset + e];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(e) {
    if (e.length < this.length)
      return !1;
    for (let t = 0; t < this.length; t++)
      if (this.get(t) !== e.get(t))
        return !1;
    return !0;
  }
  isImmediateParentOf(e) {
    if (this.length + 1 !== e.length)
      return !1;
    for (let t = 0; t < this.length; t++)
      if (this.get(t) !== e.get(t))
        return !1;
    return !0;
  }
  forEach(e) {
    for (let t = this.offset, r = this.limit(); t < r; t++)
      e(this.segments[t]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(e, t) {
    const r = Math.min(e.length, t.length);
    for (let i = 0; i < r; i++) {
      const s = e.get(i), a = t.get(i);
      if (s < a)
        return -1;
      if (s > a)
        return 1;
    }
    return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
  }
}
class Pt extends Bc {
  construct(e, t, r) {
    return new Pt(e, t, r);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...e) {
    const t = [];
    for (const r of e) {
      if (r.indexOf("//") >= 0)
        throw new J(ie, `Invalid segment (${r}). Paths must not contain // in them.`);
      t.push(...r.split("/").filter((i) => i.length > 0));
    }
    return new Pt(t);
  }
  static emptyPath() {
    return new Pt([]);
  }
}
const JR = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class Wn extends Bc {
  construct(e, t, r) {
    return new Wn(e, t, r);
  }
  static isValidIdentifier(e) {
    return JR.test(e);
  }
  canonicalString() {
    return this.toArray().map((e) => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), Wn.isValidIdentifier(e) || (e = "`" + e + "`"), e)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new Wn(["__name__"]);
  }
  static fromServerFormat(e) {
    const t = [];
    let r = "", i = 0;
    const s = () => {
      if (r.length === 0)
        throw new J(ie, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      t.push(r), r = "";
    };
    let a = !1;
    for (; i < e.length; ) {
      const o = e[i];
      if (o === "\\") {
        if (i + 1 === e.length)
          throw new J(ie, "Path has trailing escape character: " + e);
        const c = e[i + 1];
        if (c !== "\\" && c !== "." && c !== "`")
          throw new J(ie, "Path has invalid escape sequence: " + e);
        r += c, i += 2;
      } else
        o === "`" ? (a = !a, i++) : o !== "." || a ? (r += o, i++) : (s(), i++);
    }
    if (s(), a)
      throw new J(ie, "Unterminated ` in path: " + e);
    return new Wn(t);
  }
  static emptyPath() {
    return new Wn([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dt {
  constructor(e) {
    this.path = e;
  }
  static fromPath(e) {
    return new Dt(Pt.fromString(e));
  }
  static fromName(e) {
    return new Dt(Pt.fromString(e).popFirst(5));
  }
  static empty() {
    return new Dt(Pt.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  hasCollectionId(e) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === e;
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(e) {
    return e !== null && Pt.comparator(this.path, e.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(e, t) {
    return Pt.comparator(e.path, t.path);
  }
  static isDocumentKey(e) {
    return e.length % 2 == 0;
  }
  static fromSegments(e) {
    return new Dt(new Pt(e.slice()));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $p(n, e, t) {
  if (!t)
    throw new J(ie, `Function ${n}() cannot be called with an empty ${e}.`);
}
function mx(n) {
  if (!Dt.isDocumentKey(n))
    throw new J(ie, `Invalid document reference. Document references must have an even number of segments, but ${n} has ${n.length}.`);
}
function yx(n) {
  if (Dt.isDocumentKey(n))
    throw new J(ie, `Invalid collection reference. Collection references must have an odd number of segments, but ${n} has ${n.length}.`);
}
function Nd(n) {
  if (n === void 0)
    return "undefined";
  if (n === null)
    return "null";
  if (typeof n == "string")
    return n.length > 20 && (n = `${n.substring(0, 20)}...`), JSON.stringify(n);
  if (typeof n == "number" || typeof n == "boolean")
    return "" + n;
  if (typeof n == "object") {
    if (n instanceof Array)
      return "an array";
    {
      const e = function(t) {
        return t.constructor ? t.constructor.name : null;
      }(n);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof n == "function" ? "a function" : De();
}
function pr(n, e) {
  if ("_delegate" in n && (n = n._delegate), !(n instanceof e)) {
    if (e.name === n.constructor.name)
      throw new J(ie, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const t = Nd(n);
      throw new J(ie, `Expected type '${e.name}', but it was: ${t}`);
    }
  }
  return n;
}
function n6(n, e) {
  if (e <= 0)
    throw new J(ie, `Function ${n}() requires a positive number, but it was: ${e}.`);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function r6(n) {
  return n == null;
}
function Ju(n) {
  return n === 0 && 1 / n == -1 / 0;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const YR = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery",
  RunAggregationQuery: "runAggregationQuery"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var gx, Ae;
function bx(n) {
  if (n === void 0)
    return Dd("RPC_ERROR", "HTTP error has no status"), Ka;
  switch (n) {
    case 200:
      return px;
    case 400:
      return Pi;
    case 401:
      return Qu;
    case 403:
      return Jw;
    case 404:
      return Op;
    case 409:
      return Dp;
    case 416:
      return Xw;
    case 429:
      return Yw;
    case 499:
      return Ip;
    case 500:
      return Ka;
    case 501:
      return Np;
    case 503:
      return e6;
    case 504:
      return Qw;
    default:
      return n >= 200 && n < 300 ? px : n >= 400 && n < 500 ? Pi : n >= 500 && n < 600 ? Zw : Ka;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(Ae = gx || (gx = {}))[Ae.OK = 0] = "OK", Ae[Ae.CANCELLED = 1] = "CANCELLED", Ae[Ae.UNKNOWN = 2] = "UNKNOWN", Ae[Ae.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", Ae[Ae.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", Ae[Ae.NOT_FOUND = 5] = "NOT_FOUND", Ae[Ae.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", Ae[Ae.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", Ae[Ae.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", Ae[Ae.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", Ae[Ae.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", Ae[Ae.ABORTED = 10] = "ABORTED", Ae[Ae.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", Ae[Ae.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", Ae[Ae.INTERNAL = 13] = "INTERNAL", Ae[Ae.UNAVAILABLE = 14] = "UNAVAILABLE", Ae[Ae.DATA_LOSS = 15] = "DATA_LOSS";
class XR extends class {
  constructor(e) {
    this.databaseInfo = e, this.databaseId = e.databaseId;
    const t = e.ssl ? "https" : "http";
    this.p = t + "://" + e.host, this.g = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  get v() {
    return !1;
  }
  I(e, t, r, i, s) {
    const a = this.T(e, t);
    la("RestConnection", "Sending: ", a, r);
    const o = {};
    return this.A(o, i, s), this.R(e, a, o, r).then((c) => (la("RestConnection", "Received: ", c), c), (c) => {
      throw qw("RestConnection", `${e} failed with error: `, c, "url: ", a, "request:", r), c;
    });
  }
  P(e, t, r, i, s, a) {
    return this.I(e, t, r, i, s);
  }
  A(e, t, r) {
    e["X-Goog-Api-Client"] = "gl-js/ fire/" + Po, e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), t && t.headers.forEach((i, s) => e[s] = i), r && r.headers.forEach((i, s) => e[s] = i);
  }
  T(e, t) {
    const r = YR[e];
    return `${this.p}/v1/${t}:${r}`;
  }
} {
  constructor(e, t) {
    super(e), this.V = t;
  }
  N(e, t) {
    throw new Error("Not supported by FetchConnection");
  }
  async R(e, t, r, i) {
    const s = JSON.stringify(i);
    let a;
    try {
      a = await this.V(t, {
        method: "POST",
        headers: r,
        body: s
      });
    } catch (o) {
      throw new J(bx(o.status), "Request failed with error: " + o.statusText);
    }
    if (!a.ok)
      throw new J(bx(a.status), "Request failed with error: " + a.statusText);
    return a.json();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function ZR(n) {
  const e = typeof self < "u" && (self.crypto || self.msCrypto), t = new Uint8Array(n);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(t);
  else
    for (let r = 0; r < n; r++)
      t[r] = Math.floor(256 * Math.random());
  return t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ek {
  static D() {
    const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", t = Math.floor(256 / e.length) * e.length;
    let r = "";
    for (; r.length < 20; ) {
      const i = ZR(40);
      for (let s = 0; s < i.length; ++s)
        r.length < 20 && i[s] < t && (r += e.charAt(i[s] % e.length));
    }
    return r;
  }
}
function Gt(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
function Lp(n, e, t) {
  return n.length === e.length && n.every((r, i) => t(r, e[i]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class In {
  constructor(e, t) {
    if (this.seconds = e, this.nanoseconds = t, t < 0)
      throw new J(ie, "Timestamp nanoseconds out of range: " + t);
    if (t >= 1e9)
      throw new J(ie, "Timestamp nanoseconds out of range: " + t);
    if (e < -62135596800)
      throw new J(ie, "Timestamp seconds out of range: " + e);
    if (e >= 253402300800)
      throw new J(ie, "Timestamp seconds out of range: " + e);
  }
  static now() {
    return In.fromMillis(Date.now());
  }
  static fromDate(e) {
    return In.fromMillis(e.getTime());
  }
  static fromMillis(e) {
    const t = Math.floor(e / 1e3), r = Math.floor(1e6 * (e - 1e3 * t));
    return new In(t, r);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(e) {
    return this.seconds === e.seconds ? Gt(this.nanoseconds, e.nanoseconds) : Gt(this.seconds, e.seconds);
  }
  isEqual(e) {
    return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const e = this.seconds - -62135596800;
    return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _n {
  constructor(e) {
    this.timestamp = e;
  }
  static fromTimestamp(e) {
    return new _n(e);
  }
  static min() {
    return new _n(new In(0, 0));
  }
  static max() {
    return new _n(new In(253402300799, 999999999));
  }
  compareTo(e) {
    return this.timestamp._compareTo(e.timestamp);
  }
  isEqual(e) {
    return this.timestamp.isEqual(e.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function xx(n) {
  let e = 0;
  for (const t in n)
    Object.prototype.hasOwnProperty.call(n, t) && e++;
  return e;
}
function dl(n, e) {
  for (const t in n)
    Object.prototype.hasOwnProperty.call(n, t) && e(t, n[t]);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Yu {
  constructor(e, t) {
    this.comparator = e, this.root = t || qt.EMPTY;
  }
  insert(e, t) {
    return new Yu(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, qt.BLACK, null, null));
  }
  remove(e) {
    return new Yu(this.comparator, this.root.remove(e, this.comparator).copy(null, null, qt.BLACK, null, null));
  }
  get(e) {
    let t = this.root;
    for (; !t.isEmpty(); ) {
      const r = this.comparator(e, t.key);
      if (r === 0)
        return t.value;
      r < 0 ? t = t.left : r > 0 && (t = t.right);
    }
    return null;
  }
  indexOf(e) {
    let t = 0, r = this.root;
    for (; !r.isEmpty(); ) {
      const i = this.comparator(e, r.key);
      if (i === 0)
        return t + r.left.size;
      i < 0 ? r = r.left : (t += r.left.size + 1, r = r.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(e) {
    return this.root.inorderTraversal(e);
  }
  forEach(e) {
    this.inorderTraversal((t, r) => (e(t, r), !1));
  }
  toString() {
    const e = [];
    return this.inorderTraversal((t, r) => (e.push(`${t}:${r}`), !1)), `{${e.join(", ")}}`;
  }
  reverseTraversal(e) {
    return this.root.reverseTraversal(e);
  }
  getIterator() {
    return new Dl(this.root, null, this.comparator, !1);
  }
  getIteratorFrom(e) {
    return new Dl(this.root, e, this.comparator, !1);
  }
  getReverseIterator() {
    return new Dl(this.root, null, this.comparator, !0);
  }
  getReverseIteratorFrom(e) {
    return new Dl(this.root, e, this.comparator, !0);
  }
}
class Dl {
  constructor(e, t, r, i) {
    this.isReverse = i, this.nodeStack = [];
    let s = 1;
    for (; !e.isEmpty(); )
      if (s = t ? r(e.key, t) : 1, t && i && (s *= -1), s < 0)
        e = this.isReverse ? e.left : e.right;
      else {
        if (s === 0) {
          this.nodeStack.push(e);
          break;
        }
        this.nodeStack.push(e), e = this.isReverse ? e.right : e.left;
      }
  }
  getNext() {
    let e = this.nodeStack.pop();
    const t = {
      key: e.key,
      value: e.value
    };
    if (this.isReverse)
      for (e = e.left; !e.isEmpty(); )
        this.nodeStack.push(e), e = e.right;
    else
      for (e = e.right; !e.isEmpty(); )
        this.nodeStack.push(e), e = e.left;
    return t;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const e = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: e.key,
      value: e.value
    };
  }
}
class qt {
  constructor(e, t, r, i, s) {
    this.key = e, this.value = t, this.color = r ?? qt.RED, this.left = i ?? qt.EMPTY, this.right = s ?? qt.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(e, t, r, i, s) {
    return new qt(e ?? this.key, t ?? this.value, r ?? this.color, i ?? this.left, s ?? this.right);
  }
  isEmpty() {
    return !1;
  }
  inorderTraversal(e) {
    return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e);
  }
  reverseTraversal(e) {
    return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(e, t, r) {
    let i = this;
    const s = r(e, i.key);
    return i = s < 0 ? i.copy(null, null, null, i.left.insert(e, t, r), null) : s === 0 ? i.copy(null, t, null, null, null) : i.copy(null, null, null, null, i.right.insert(e, t, r)), i.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return qt.EMPTY;
    let e = this;
    return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp();
  }
  remove(e, t) {
    let r, i = this;
    if (t(e, i.key) < 0)
      i.left.isEmpty() || i.left.isRed() || i.left.left.isRed() || (i = i.moveRedLeft()), i = i.copy(null, null, null, i.left.remove(e, t), null);
    else {
      if (i.left.isRed() && (i = i.rotateRight()), i.right.isEmpty() || i.right.isRed() || i.right.left.isRed() || (i = i.moveRedRight()), t(e, i.key) === 0) {
        if (i.right.isEmpty())
          return qt.EMPTY;
        r = i.right.min(), i = i.copy(r.key, r.value, null, null, i.right.removeMin());
      }
      i = i.copy(null, null, null, null, i.right.remove(e, t));
    }
    return i.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let e = this;
    return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e;
  }
  moveRedLeft() {
    let e = this.colorFlip();
    return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e;
  }
  moveRedRight() {
    let e = this.colorFlip();
    return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e;
  }
  rotateLeft() {
    const e = this.copy(null, null, qt.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, e, null);
  }
  rotateRight() {
    const e = this.copy(null, null, qt.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, e);
  }
  colorFlip() {
    const e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, e, t);
  }
  checkMaxDepth() {
    const e = this.check();
    return Math.pow(2, e) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed() || this.right.isRed())
      throw De();
    const e = this.left.check();
    if (e !== this.right.check())
      throw De();
    return e + (this.isRed() ? 0 : 1);
  }
}
qt.EMPTY = null, qt.RED = !0, qt.BLACK = !1;
qt.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw De();
  }
  get value() {
    throw De();
  }
  get color() {
    throw De();
  }
  get left() {
    throw De();
  }
  get right() {
    throw De();
  }
  copy(n, e, t, r, i) {
    return this;
  }
  insert(n, e, t) {
    return new qt(n, e);
  }
  remove(n, e) {
    return this;
  }
  isEmpty() {
    return !0;
  }
  inorderTraversal(n) {
    return !1;
  }
  reverseTraversal(n) {
    return !1;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return !1;
  }
  checkMaxDepth() {
    return !0;
  }
  check() {
    return 0;
  }
}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Xu {
  constructor(e) {
    this.comparator = e, this.data = new Yu(this.comparator);
  }
  has(e) {
    return this.data.get(e) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(e) {
    return this.data.indexOf(e);
  }
  forEach(e) {
    this.data.inorderTraversal((t, r) => (e(t), !1));
  }
  forEachInRange(e, t) {
    const r = this.data.getIteratorFrom(e[0]);
    for (; r.hasNext(); ) {
      const i = r.getNext();
      if (this.comparator(i.key, e[1]) >= 0)
        return;
      t(i.key);
    }
  }
  forEachWhile(e, t) {
    let r;
    for (r = t !== void 0 ? this.data.getIteratorFrom(t) : this.data.getIterator(); r.hasNext(); )
      if (!e(r.getNext().key))
        return;
  }
  firstAfterOrEqual(e) {
    const t = this.data.getIteratorFrom(e);
    return t.hasNext() ? t.getNext().key : null;
  }
  getIterator() {
    return new vx(this.data.getIterator());
  }
  getIteratorFrom(e) {
    return new vx(this.data.getIteratorFrom(e));
  }
  add(e) {
    return this.copy(this.data.remove(e).insert(e, !0));
  }
  delete(e) {
    return this.has(e) ? this.copy(this.data.remove(e)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(e) {
    let t = this;
    return t.size < e.size && (t = e, e = this), e.forEach((r) => {
      t = t.add(r);
    }), t;
  }
  isEqual(e) {
    if (!(e instanceof Xu) || this.size !== e.size)
      return !1;
    const t = this.data.getIterator(), r = e.data.getIterator();
    for (; t.hasNext(); ) {
      const i = t.getNext().key, s = r.getNext().key;
      if (this.comparator(i, s) !== 0)
        return !1;
    }
    return !0;
  }
  toArray() {
    const e = [];
    return this.forEach((t) => {
      e.push(t);
    }), e;
  }
  toString() {
    const e = [];
    return this.forEach((t) => e.push(t)), "SortedSet(" + e.toString() + ")";
  }
  copy(e) {
    const t = new Xu(this.comparator);
    return t.data = e, t;
  }
}
class vx {
  constructor(e) {
    this.iter = e;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ua {
  constructor(e) {
    this.fields = e, e.sort(Wn.comparator);
  }
  static empty() {
    return new ua([]);
  }
  unionWith(e) {
    let t = new Xu(Wn.comparator);
    for (const r of this.fields)
      t = t.add(r);
    for (const r of e)
      t = t.add(r);
    return new ua(t.toArray());
  }
  covers(e) {
    for (const t of this.fields)
      if (t.isPrefixOf(e))
        return !0;
    return !1;
  }
  isEqual(e) {
    return Lp(this.fields, e.fields, (t, r) => t.isEqual(r));
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Mi {
  constructor(e) {
    this.binaryString = e;
  }
  static fromBase64String(e) {
    const t = atob(e);
    return new Mi(t);
  }
  static fromUint8Array(e) {
    const t = function(r) {
      let i = "";
      for (let s = 0; s < r.length; ++s)
        i += String.fromCharCode(r[s]);
      return i;
    }(e);
    return new Mi(t);
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(e++),
        done: !1
      } : {
        value: void 0,
        done: !0
      }
    };
  }
  toBase64() {
    return e = this.binaryString, btoa(e);
    var e;
  }
  toUint8Array() {
    return function(e) {
      const t = new Uint8Array(e.length);
      for (let r = 0; r < e.length; r++)
        t[r] = e.charCodeAt(r);
      return t;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(e) {
    return Gt(this.binaryString, e.binaryString);
  }
  isEqual(e) {
    return this.binaryString === e.binaryString;
  }
}
Mi.EMPTY_BYTE_STRING = new Mi("");
const tk = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function da(n) {
  if (pn(!!n), typeof n == "string") {
    let e = 0;
    const t = tk.exec(n);
    if (pn(!!t), t[1]) {
      let i = t[1];
      i = (i + "000000000").substr(0, 9), e = Number(i);
    }
    const r = new Date(n);
    return {
      seconds: Math.floor(r.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Bt(n.seconds),
    nanos: Bt(n.nanos)
  };
}
function Bt(n) {
  return typeof n == "number" ? n : typeof n == "string" ? Number(n) : 0;
}
function $c(n) {
  return typeof n == "string" ? Mi.fromBase64String(n) : Mi.fromUint8Array(n);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Fp(n) {
  var e, t;
  return ((t = (((e = n?.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || t === void 0 ? void 0 : t.stringValue) === "server_timestamp";
}
function i6(n) {
  const e = n.mapValue.fields.__previous_value__;
  return Fp(e) ? i6(e) : e;
}
function Lc(n) {
  const e = da(n.mapValue.fields.__local_write_time__.timestampValue);
  return new In(e.seconds, e.nanos);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Nl = {
  fields: {
    __type__: {
      stringValue: "__max__"
    }
  }
};
function fa(n) {
  return "nullValue" in n ? 0 : "booleanValue" in n ? 1 : "integerValue" in n || "doubleValue" in n ? 2 : "timestampValue" in n ? 3 : "stringValue" in n ? 5 : "bytesValue" in n ? 6 : "referenceValue" in n ? 7 : "geoPointValue" in n ? 8 : "arrayValue" in n ? 9 : "mapValue" in n ? Fp(n) ? 4 : function(e) {
    return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
  }(n) ? 9007199254740991 : 10 : De();
}
function ao(n, e) {
  if (n === e)
    return !0;
  const t = fa(n);
  if (t !== fa(e))
    return !1;
  switch (t) {
    case 0:
    case 9007199254740991:
      return !0;
    case 1:
      return n.booleanValue === e.booleanValue;
    case 4:
      return Lc(n).isEqual(Lc(e));
    case 3:
      return function(r, i) {
        if (typeof r.timestampValue == "string" && typeof i.timestampValue == "string" && r.timestampValue.length === i.timestampValue.length)
          return r.timestampValue === i.timestampValue;
        const s = da(r.timestampValue), a = da(i.timestampValue);
        return s.seconds === a.seconds && s.nanos === a.nanos;
      }(n, e);
    case 5:
      return n.stringValue === e.stringValue;
    case 6:
      return function(r, i) {
        return $c(r.bytesValue).isEqual($c(i.bytesValue));
      }(n, e);
    case 7:
      return n.referenceValue === e.referenceValue;
    case 8:
      return function(r, i) {
        return Bt(r.geoPointValue.latitude) === Bt(i.geoPointValue.latitude) && Bt(r.geoPointValue.longitude) === Bt(i.geoPointValue.longitude);
      }(n, e);
    case 2:
      return function(r, i) {
        if ("integerValue" in r && "integerValue" in i)
          return Bt(r.integerValue) === Bt(i.integerValue);
        if ("doubleValue" in r && "doubleValue" in i) {
          const s = Bt(r.doubleValue), a = Bt(i.doubleValue);
          return s === a ? Ju(s) === Ju(a) : isNaN(s) && isNaN(a);
        }
        return !1;
      }(n, e);
    case 9:
      return Lp(n.arrayValue.values || [], e.arrayValue.values || [], ao);
    case 10:
      return function(r, i) {
        const s = r.mapValue.fields || {}, a = i.mapValue.fields || {};
        if (xx(s) !== xx(a))
          return !1;
        for (const o in s)
          if (s.hasOwnProperty(o) && (a[o] === void 0 || !ao(s[o], a[o])))
            return !1;
        return !0;
      }(n, e);
    default:
      return De();
  }
}
function Fc(n, e) {
  return (n.values || []).find((t) => ao(t, e)) !== void 0;
}
function Zu(n, e) {
  if (n === e)
    return 0;
  const t = fa(n), r = fa(e);
  if (t !== r)
    return Gt(t, r);
  switch (t) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return Gt(n.booleanValue, e.booleanValue);
    case 2:
      return function(i, s) {
        const a = Bt(i.integerValue || i.doubleValue), o = Bt(s.integerValue || s.doubleValue);
        return a < o ? -1 : a > o ? 1 : a === o ? 0 : isNaN(a) ? isNaN(o) ? 0 : -1 : 1;
      }(n, e);
    case 3:
      return wx(n.timestampValue, e.timestampValue);
    case 4:
      return wx(Lc(n), Lc(e));
    case 5:
      return Gt(n.stringValue, e.stringValue);
    case 6:
      return function(i, s) {
        const a = $c(i), o = $c(s);
        return a.compareTo(o);
      }(n.bytesValue, e.bytesValue);
    case 7:
      return function(i, s) {
        const a = i.split("/"), o = s.split("/");
        for (let c = 0; c < a.length && c < o.length; c++) {
          const l = Gt(a[c], o[c]);
          if (l !== 0)
            return l;
        }
        return Gt(a.length, o.length);
      }(n.referenceValue, e.referenceValue);
    case 8:
      return function(i, s) {
        const a = Gt(Bt(i.latitude), Bt(s.latitude));
        return a !== 0 ? a : Gt(Bt(i.longitude), Bt(s.longitude));
      }(n.geoPointValue, e.geoPointValue);
    case 9:
      return function(i, s) {
        const a = i.values || [], o = s.values || [];
        for (let c = 0; c < a.length && c < o.length; ++c) {
          const l = Zu(a[c], o[c]);
          if (l)
            return l;
        }
        return Gt(a.length, o.length);
      }(n.arrayValue, e.arrayValue);
    case 10:
      return function(i, s) {
        if (i === Nl && s === Nl)
          return 0;
        if (i === Nl)
          return 1;
        if (s === Nl)
          return -1;
        const a = i.fields || {}, o = Object.keys(a), c = s.fields || {}, l = Object.keys(c);
        o.sort(), l.sort();
        for (let f = 0; f < o.length && f < l.length; ++f) {
          const p = Gt(o[f], l[f]);
          if (p !== 0)
            return p;
          const g = Zu(a[o[f]], c[l[f]]);
          if (g !== 0)
            return g;
        }
        return Gt(o.length, l.length);
      }(n.mapValue, e.mapValue);
    default:
      throw De();
  }
}
function wx(n, e) {
  if (typeof n == "string" && typeof e == "string" && n.length === e.length)
    return Gt(n, e);
  const t = da(n), r = da(e), i = Gt(t.seconds, r.seconds);
  return i !== 0 ? i : Gt(t.nanos, r.nanos);
}
function ed(n, e) {
  return {
    referenceValue: `projects/${n.projectId}/databases/${n.database}/documents/${e.path.canonicalString()}`
  };
}
function s6(n) {
  return !!n && "arrayValue" in n;
}
function Ax(n) {
  return !!n && "nullValue" in n;
}
function Tx(n) {
  return !!n && "doubleValue" in n && isNaN(Number(n.doubleValue));
}
function eh(n) {
  return !!n && "mapValue" in n;
}
function oc(n) {
  if (n.geoPointValue)
    return {
      geoPointValue: Object.assign({}, n.geoPointValue)
    };
  if (n.timestampValue && typeof n.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, n.timestampValue)
    };
  if (n.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return dl(n.mapValue.fields, (t, r) => e.mapValue.fields[t] = oc(r)), e;
  }
  if (n.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let t = 0; t < (n.arrayValue.values || []).length; ++t)
      e.arrayValue.values[t] = oc(n.arrayValue.values[t]);
    return e;
  }
  return Object.assign({}, n);
}
class Hn {
  constructor(e) {
    this.value = e;
  }
  static empty() {
    return new Hn({
      mapValue: {}
    });
  }
  field(e) {
    if (e.isEmpty())
      return this.value;
    {
      let t = this.value;
      for (let r = 0; r < e.length - 1; ++r)
        if (t = (t.mapValue.fields || {})[e.get(r)], !eh(t))
          return null;
      return t = (t.mapValue.fields || {})[e.lastSegment()], t || null;
    }
  }
  set(e, t) {
    this.getFieldsMap(e.popLast())[e.lastSegment()] = oc(t);
  }
  setAll(e) {
    let t = Wn.emptyPath(), r = {}, i = [];
    e.forEach((a, o) => {
      if (!t.isImmediateParentOf(o)) {
        const c = this.getFieldsMap(t);
        this.applyChanges(c, r, i), r = {}, i = [], t = o.popLast();
      }
      a ? r[o.lastSegment()] = oc(a) : i.push(o.lastSegment());
    });
    const s = this.getFieldsMap(t);
    this.applyChanges(s, r, i);
  }
  delete(e) {
    const t = this.field(e.popLast());
    eh(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()];
  }
  isEqual(e) {
    return ao(this.value, e.value);
  }
  getFieldsMap(e) {
    let t = this.value;
    t.mapValue.fields || (t.mapValue = {
      fields: {}
    });
    for (let r = 0; r < e.length; ++r) {
      let i = t.mapValue.fields[e.get(r)];
      eh(i) && i.mapValue.fields || (i = {
        mapValue: {
          fields: {}
        }
      }, t.mapValue.fields[e.get(r)] = i), t = i;
    }
    return t.mapValue.fields;
  }
  applyChanges(e, t, r) {
    dl(t, (i, s) => e[i] = s);
    for (const i of r)
      delete e[i];
  }
  clone() {
    return new Hn(oc(this.value));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $r {
  constructor(e, t, r, i, s, a) {
    this.key = e, this.documentType = t, this.version = r, this.readTime = i, this.data = s, this.documentState = a;
  }
  static newInvalidDocument(e) {
    return new $r(e, 0, _n.min(), _n.min(), Hn.empty(), 0);
  }
  static newFoundDocument(e, t, r) {
    return new $r(e, 1, t, _n.min(), r, 0);
  }
  static newNoDocument(e, t) {
    return new $r(e, 2, t, _n.min(), Hn.empty(), 0);
  }
  static newUnknownDocument(e, t) {
    return new $r(e, 3, t, _n.min(), Hn.empty(), 2);
  }
  convertToFoundDocument(e, t) {
    return this.version = e, this.documentType = 1, this.data = t, this.documentState = 0, this;
  }
  convertToNoDocument(e) {
    return this.version = e, this.documentType = 2, this.data = Hn.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(e) {
    return this.version = e, this.documentType = 3, this.data = Hn.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = _n.min(), this;
  }
  setReadTime(e) {
    return this.readTime = e, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(e) {
    return e instanceof $r && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data);
  }
  mutableCopy() {
    return new $r(this.key, this.documentType, this.version, this.readTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class nk {
  constructor(e, t = null, r = [], i = [], s = null, a = null, o = null) {
    this.path = e, this.collectionGroup = t, this.orderBy = r, this.filters = i, this.limit = s, this.startAt = a, this.endAt = o, this.$ = null;
  }
}
function Cx(n, e = null, t = [], r = [], i = null, s = null, a = null) {
  return new nk(n, e, t, r, i, s, a);
}
class ti extends class {
} {
  constructor(e, t, r) {
    super(), this.field = e, this.op = t, this.value = r;
  }
  static create(e, t, r) {
    return e.isKeyField() ? t === "in" || t === "not-in" ? this.F(e, t, r) : new rk(e, t, r) : t === "array-contains" ? new ak(e, r) : t === "in" ? new ok(e, r) : t === "not-in" ? new ck(e, r) : t === "array-contains-any" ? new lk(e, r) : new ti(e, t, r);
  }
  static F(e, t, r) {
    return t === "in" ? new ik(e, r) : new sk(e, r);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return this.op === "!=" ? t !== null && this.S(Zu(t, this.value)) : t !== null && fa(this.value) === fa(t) && this.S(Zu(t, this.value));
  }
  S(e) {
    switch (this.op) {
      case "<":
        return e < 0;
      case "<=":
        return e <= 0;
      case "==":
        return e === 0;
      case "!=":
        return e !== 0;
      case ">":
        return e > 0;
      case ">=":
        return e >= 0;
      default:
        return De();
    }
  }
  q() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
}
class rk extends ti {
  constructor(e, t, r) {
    super(e, t, r), this.key = Dt.fromName(r.referenceValue);
  }
  matches(e) {
    const t = Dt.comparator(e.key, this.key);
    return this.S(t);
  }
}
class ik extends ti {
  constructor(e, t) {
    super(e, "in", t), this.keys = a6("in", t);
  }
  matches(e) {
    return this.keys.some((t) => t.isEqual(e.key));
  }
}
class sk extends ti {
  constructor(e, t) {
    super(e, "not-in", t), this.keys = a6("not-in", t);
  }
  matches(e) {
    return !this.keys.some((t) => t.isEqual(e.key));
  }
}
function a6(n, e) {
  var t;
  return (((t = e.arrayValue) === null || t === void 0 ? void 0 : t.values) || []).map((r) => Dt.fromName(r.referenceValue));
}
class ak extends ti {
  constructor(e, t) {
    super(e, "array-contains", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return s6(t) && Fc(t.arrayValue, this.value);
  }
}
class ok extends ti {
  constructor(e, t) {
    super(e, "in", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return t !== null && Fc(this.value.arrayValue, t);
  }
}
class ck extends ti {
  constructor(e, t) {
    super(e, "not-in", t);
  }
  matches(e) {
    if (Fc(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return !1;
    const t = e.data.field(this.field);
    return t !== null && !Fc(this.value.arrayValue, t);
  }
}
class lk extends ti {
  constructor(e, t) {
    super(e, "array-contains-any", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return !(!s6(t) || !t.arrayValue.values) && t.arrayValue.values.some((r) => Fc(this.value.arrayValue, r));
  }
}
class td {
  constructor(e, t) {
    this.position = e, this.inclusive = t;
  }
}
class cc {
  constructor(e, t = "asc") {
    this.field = e, this.dir = t;
  }
}
function uk(n, e) {
  return n.dir === e.dir && n.field.isEqual(e.field);
}
function Ex(n, e) {
  if (n === null)
    return e === null;
  if (e === null || n.inclusive !== e.inclusive || n.position.length !== e.position.length)
    return !1;
  for (let t = 0; t < n.position.length; t++)
    if (!ao(n.position[t], e.position[t]))
      return !1;
  return !0;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ta {
  constructor(e, t = null, r = [], i = [], s = null, a = "F", o = null, c = null) {
    this.path = e, this.collectionGroup = t, this.explicitOrderBy = r, this.filters = i, this.limit = s, this.limitType = a, this.startAt = o, this.endAt = c, this.O = null, this.k = null, this.startAt, this.endAt;
  }
}
function Up(n) {
  return n.explicitOrderBy.length > 0 ? n.explicitOrderBy[0].field : null;
}
function Vp(n) {
  for (const e of n.filters)
    if (e.q())
      return e.field;
  return null;
}
function o6(n) {
  return n.collectionGroup !== null;
}
function Jh(n) {
  const e = Mo(n);
  if (e.O === null) {
    e.O = [];
    const t = Vp(e), r = Up(e);
    if (t !== null && r === null)
      t.isKeyField() || e.O.push(new cc(t)), e.O.push(new cc(Wn.keyField(), "asc"));
    else {
      let i = !1;
      for (const s of e.explicitOrderBy)
        e.O.push(s), s.field.isKeyField() && (i = !0);
      if (!i) {
        const s = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.O.push(new cc(Wn.keyField(), s));
      }
    }
  }
  return e.O;
}
function nd(n) {
  const e = Mo(n);
  if (!e.k)
    if (e.limitType === "F")
      e.k = Cx(e.path, e.collectionGroup, Jh(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t = [];
      for (const s of Jh(e)) {
        const a = s.dir === "desc" ? "asc" : "desc";
        t.push(new cc(s.field, a));
      }
      const r = e.endAt ? new td(e.endAt.position, e.endAt.inclusive) : null, i = e.startAt ? new td(e.startAt.position, e.startAt.inclusive) : null;
      e.k = Cx(e.path, e.collectionGroup, t, e.filters, e.limit, r, i);
    }
  return e.k;
}
function dk(n, e) {
  return function(t, r) {
    if (t.limit !== r.limit || t.orderBy.length !== r.orderBy.length)
      return !1;
    for (let a = 0; a < t.orderBy.length; a++)
      if (!uk(t.orderBy[a], r.orderBy[a]))
        return !1;
    if (t.filters.length !== r.filters.length)
      return !1;
    for (let a = 0; a < t.filters.length; a++)
      if (i = t.filters[a], s = r.filters[a], i.op !== s.op || !i.field.isEqual(s.field) || !ao(i.value, s.value))
        return !1;
    var i, s;
    return t.collectionGroup === r.collectionGroup && !!t.path.isEqual(r.path) && !!Ex(t.startAt, r.startAt) && Ex(t.endAt, r.endAt);
  }(nd(n), nd(e)) && n.limitType === e.limitType;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function c6(n, e) {
  return function(t) {
    return typeof t == "number" && Number.isInteger(t) && !Ju(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER;
  }(e) ? function(t) {
    return {
      integerValue: "" + t
    };
  }(e) : function(t, r) {
    if (t.C) {
      if (isNaN(r))
        return {
          doubleValue: "NaN"
        };
      if (r === 1 / 0)
        return {
          doubleValue: "Infinity"
        };
      if (r === -1 / 0)
        return {
          doubleValue: "-Infinity"
        };
    }
    return {
      doubleValue: Ju(r) ? "-0" : r
    };
  }(n, e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bd {
  constructor() {
    this._ = void 0;
  }
}
class l6 extends Bd {
}
class u6 extends Bd {
  constructor(e) {
    super(), this.elements = e;
  }
}
class d6 extends Bd {
  constructor(e) {
    super(), this.elements = e;
  }
}
class f6 extends Bd {
  constructor(e, t) {
    super(), this.L = e, this.M = t;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $d {
  constructor(e, t) {
    this.field = e, this.transform = t;
  }
}
class dn {
  constructor(e, t) {
    this.updateTime = e, this.exists = t;
  }
  static none() {
    return new dn();
  }
  static exists(e) {
    return new dn(void 0, e);
  }
  static updateTime(e) {
    return new dn(e);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(e) {
    return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime);
  }
}
class Ld {
}
class h6 extends Ld {
  constructor(e, t, r, i = []) {
    super(), this.key = e, this.value = t, this.precondition = r, this.fieldTransforms = i, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
}
class jp extends Ld {
  constructor(e, t, r, i, s = []) {
    super(), this.key = e, this.data = t, this.fieldMask = r, this.precondition = i, this.fieldTransforms = s, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
}
class Fd extends Ld {
  constructor(e, t) {
    super(), this.key = e, this.precondition = t, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
class p6 extends Ld {
  constructor(e, t) {
    super(), this.key = e, this.precondition = t, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fk = (() => ({
  asc: "ASCENDING",
  desc: "DESCENDING"
}))(), hk = (() => ({
  "<": "LESS_THAN",
  "<=": "LESS_THAN_OR_EQUAL",
  ">": "GREATER_THAN",
  ">=": "GREATER_THAN_OR_EQUAL",
  "==": "EQUAL",
  "!=": "NOT_EQUAL",
  "array-contains": "ARRAY_CONTAINS",
  in: "IN",
  "not-in": "NOT_IN",
  "array-contains-any": "ARRAY_CONTAINS_ANY"
}))();
class pk {
  constructor(e, t) {
    this.databaseId = e, this.C = t;
  }
}
function Yh(n, e) {
  return n.C ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z` : {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function mk(n, e) {
  return n.C ? e.toBase64() : e.toUint8Array();
}
function yk(n, e) {
  return Yh(n, e.toTimestamp());
}
function Xh(n) {
  return pn(!!n), _n.fromTimestamp(function(e) {
    const t = da(e);
    return new In(t.seconds, t.nanos);
  }(n));
}
function Gp(n, e) {
  return function(t) {
    return new Pt(["projects", t.projectId, "databases", t.database]);
  }(n).child("documents").child(e).canonicalString();
}
function rd(n, e) {
  return Gp(n.databaseId, e.path);
}
function Zh(n, e) {
  const t = function(i) {
    const s = Pt.fromString(i);
    return pn(g6(s)), s;
  }(e);
  if (t.get(1) !== n.databaseId.projectId)
    throw new J(ie, "Tried to deserialize key from different project: " + t.get(1) + " vs " + n.databaseId.projectId);
  if (t.get(3) !== n.databaseId.database)
    throw new J(ie, "Tried to deserialize key from different database: " + t.get(3) + " vs " + n.databaseId.database);
  return new Dt((pn((r = t).length > 4 && r.get(4) === "documents"), r.popFirst(5)));
  var r;
}
function Sx(n, e) {
  return Gp(n.databaseId, e);
}
function m6(n) {
  return new Pt(["projects", n.databaseId.projectId, "databases", n.databaseId.database]).canonicalString();
}
function _x(n, e, t) {
  return {
    name: rd(n, e),
    fields: t.value.mapValue.fields
  };
}
function gk(n, e) {
  return "found" in e ? function(t, r) {
    pn(!!r.found), r.found.name, r.found.updateTime;
    const i = Zh(t, r.found.name), s = Xh(r.found.updateTime), a = new Hn({
      mapValue: {
        fields: r.found.fields
      }
    });
    return $r.newFoundDocument(i, s, a);
  }(n, e) : "missing" in e ? function(t, r) {
    pn(!!r.missing), pn(!!r.readTime);
    const i = Zh(t, r.missing), s = Xh(r.readTime);
    return $r.newNoDocument(i, s);
  }(n, e) : De();
}
function bk(n, e) {
  let t;
  if (e instanceof h6)
    t = {
      update: _x(n, e.key, e.value)
    };
  else if (e instanceof Fd)
    t = {
      delete: rd(n, e.key)
    };
  else if (e instanceof jp)
    t = {
      update: _x(n, e.key, e.data),
      updateMask: wk(e.fieldMask)
    };
  else {
    if (!(e instanceof p6))
      return De();
    t = {
      verify: rd(n, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (t.updateTransforms = e.fieldTransforms.map((r) => function(i, s) {
    const a = s.transform;
    if (a instanceof l6)
      return {
        fieldPath: s.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (a instanceof u6)
      return {
        fieldPath: s.field.canonicalString(),
        appendMissingElements: {
          values: a.elements
        }
      };
    if (a instanceof d6)
      return {
        fieldPath: s.field.canonicalString(),
        removeAllFromArray: {
          values: a.elements
        }
      };
    if (a instanceof f6)
      return {
        fieldPath: s.field.canonicalString(),
        increment: a.M
      };
    throw De();
  }(0, r))), e.precondition.isNone || (t.currentDocument = function(r, i) {
    return i.updateTime !== void 0 ? {
      updateTime: yk(r, i.updateTime)
    } : i.exists !== void 0 ? {
      exists: i.exists
    } : De();
  }(n, e.precondition)), t;
}
function y6(n, e) {
  const t = {
    structuredQuery: {}
  }, r = e.path;
  e.collectionGroup !== null ? (t.parent = Sx(n, r), t.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: !0
  }]) : (t.parent = Sx(n, r.popLast()), t.structuredQuery.from = [{
    collectionId: r.lastSegment()
  }]);
  const i = function(c) {
    if (c.length === 0)
      return;
    const l = c.map((f) => function(p) {
      if (p.op === "==") {
        if (Tx(p.value))
          return {
            unaryFilter: {
              field: Ra(p.field),
              op: "IS_NAN"
            }
          };
        if (Ax(p.value))
          return {
            unaryFilter: {
              field: Ra(p.field),
              op: "IS_NULL"
            }
          };
      } else if (p.op === "!=") {
        if (Tx(p.value))
          return {
            unaryFilter: {
              field: Ra(p.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Ax(p.value))
          return {
            unaryFilter: {
              field: Ra(p.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: Ra(p.field),
          op: vk(p.op),
          value: p.value
        }
      };
    }(f));
    return l.length === 1 ? l[0] : {
      compositeFilter: {
        op: "AND",
        filters: l
      }
    };
  }(e.filters);
  i && (t.structuredQuery.where = i);
  const s = function(c) {
    if (c.length !== 0)
      return c.map((l) => function(f) {
        return {
          field: Ra(f.field),
          direction: xk(f.dir)
        };
      }(l));
  }(e.orderBy);
  s && (t.structuredQuery.orderBy = s);
  const a = function(c, l) {
    return c.C || r6(l) ? l : {
      value: l
    };
  }(n, e.limit);
  var o;
  return a !== null && (t.structuredQuery.limit = a), e.startAt && (t.structuredQuery.startAt = {
    before: (o = e.startAt).inclusive,
    values: o.position
  }), e.endAt && (t.structuredQuery.endAt = function(c) {
    return {
      before: !c.inclusive,
      values: c.position
    };
  }(e.endAt)), t;
}
function xk(n) {
  return fk[n];
}
function vk(n) {
  return hk[n];
}
function Ra(n) {
  return {
    fieldPath: n.canonicalString()
  };
}
function wk(n) {
  const e = [];
  return n.fields.forEach((t) => e.push(t.canonicalString())), {
    fieldPaths: e
  };
}
function g6(n) {
  return n.length >= 4 && n.get(0) === "projects" && n.get(2) === "databases";
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Wp(n) {
  return new pk(n, !0);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class b6 {
  constructor(e, t, r = 1e3, i = 1.5, s = 6e4) {
    this.U = e, this.timerId = t, this.j = r, this.B = i, this.G = s, this.W = 0, this.K = null, this.Y = Date.now(), this.reset();
  }
  reset() {
    this.W = 0;
  }
  H() {
    this.W = this.G;
  }
  J(e) {
    this.cancel();
    const t = Math.floor(this.W + this.X()), r = Math.max(0, Date.now() - this.Y), i = Math.max(0, t - r);
    i > 0 && la("ExponentialBackoff", `Backing off for ${i} ms (base delay: ${this.W} ms, delay with jitter: ${t} ms, last attempt: ${r} ms ago)`), this.K = this.U.enqueueAfterDelay(this.timerId, i, () => (this.Y = Date.now(), e())), this.W *= this.B, this.W < this.j && (this.W = this.j), this.W > this.G && (this.W = this.G);
  }
  Z() {
    this.K !== null && (this.K.skipDelay(), this.K = null);
  }
  cancel() {
    this.K !== null && (this.K.cancel(), this.K = null);
  }
  X() {
    return (Math.random() - 0.5) * this.W;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ak extends class {
} {
  constructor(e, t, r, i) {
    super(), this.authCredentials = e, this.appCheckCredentials = t, this.connection = r, this.L = i, this.tt = !1;
  }
  et() {
    if (this.tt)
      throw new J(Pi, "The client has already been terminated.");
  }
  I(e, t, r) {
    return this.et(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([i, s]) => this.connection.I(e, t, r, i, s)).catch((i) => {
      throw i.name === "FirebaseError" ? (i.code === Qu && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), i) : new J(Ka, i.toString());
    });
  }
  P(e, t, r, i) {
    return this.et(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, a]) => this.connection.P(e, t, r, s, a, i)).catch((s) => {
      throw s.name === "FirebaseError" ? (s.code === Qu && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), s) : new J(Ka, s.toString());
    });
  }
  terminate() {
    this.tt = !0;
  }
}
async function Ro(n, e) {
  const t = Mo(n), r = m6(t.L) + "/documents", i = {
    writes: e.map((s) => bk(t.L, s))
  };
  await t.I("Commit", r, i);
}
async function x6(n, e) {
  const t = Mo(n), r = m6(t.L) + "/documents", i = {
    documents: e.map((c) => rd(t.L, c))
  }, s = await t.P("BatchGetDocuments", r, i, e.length), a = /* @__PURE__ */ new Map();
  s.forEach((c) => {
    const l = gk(t.L, c);
    a.set(l.key.toString(), l);
  });
  const o = [];
  return e.forEach((c) => {
    const l = a.get(c.toString());
    pn(!!l), o.push(l);
  }), o;
}
async function Tk(n, e) {
  const t = Mo(n), r = y6(t.L, nd(e));
  return (await t.P("RunQuery", r.parent, {
    structuredQuery: r.structuredQuery
  })).filter((i) => !!i.document).map((i) => function(s, a, o) {
    const c = Zh(s, a.name), l = Xh(a.updateTime), f = new Hn({
      mapValue: {
        fields: a.fields
      }
    }), p = $r.newFoundDocument(c, l, f);
    return o && p.setHasCommittedMutations(), o ? p.setHasCommittedMutations() : p;
  }(t.L, i.document, void 0));
}
async function Ck(n, e) {
  const t = Mo(n), r = function(s, a) {
    const o = y6(s, a);
    return {
      structuredAggregationQuery: {
        aggregations: [{
          count: {},
          alias: "count_alias"
        }],
        structuredQuery: o.structuredQuery
      },
      parent: o.parent
    };
  }(t.L, nd(e)), i = r.parent;
  return t.connection.v || delete r.parent, (await t.P("RunAggregationQuery", i, r, 1)).filter((s) => !!s.result).map((s) => s.result.aggregateFields);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const lc = /* @__PURE__ */ new Map();
function Li(n) {
  if (n._terminated)
    throw new J(Pi, "The client has already been terminated.");
  if (!lc.has(n)) {
    la("ComponentProvider", "Initializing Datastore");
    const s = function(c) {
      return new XR(c, fetch.bind(null));
    }((e = n._databaseId, t = n.app.options.appId || "", r = n._persistenceKey, i = n._freezeSettings(), new QR(e, t, r, i.host, i.ssl, i.experimentalForceLongPolling, i.experimentalAutoDetectLongPolling, i.useFetchStreams))), a = Wp(n._databaseId), o = function(c, l, f, p) {
      return new Ak(c, l, f, p);
    }(n._authCredentials, n._appCheckCredentials, s, a);
    lc.set(n, o);
  }
  var e, t, r, i;
  /**
  * @license
  * Copyright 2018 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  return lc.get(n);
}
class Px {
  constructor(e) {
    var t;
    if (e.host === void 0) {
      if (e.ssl !== void 0)
        throw new J(ie, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = !0;
    } else
      this.host = e.host, this.ssl = (t = e.ssl) === null || t === void 0 || t;
    if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, e.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
        throw new J(ie, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = e.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling, this.useFetchStreams = !!e.useFetchStreams, function(r, i, s, a) {
      if (i === !0 && a === !0)
        throw new J(ie, `${r} and ${s} cannot be used together.`);
    }("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling);
  }
  isEqual(e) {
    return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ni {
  constructor(e, t, r, i) {
    this._authCredentials = e, this._appCheckCredentials = t, this._databaseId = r, this._app = i, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Px({}), this._settingsFrozen = !1;
  }
  get app() {
    if (!this._app)
      throw new J(Pi, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(e) {
    if (this._settingsFrozen)
      throw new J(Pi, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new Px(e), e.credentials !== void 0 && (this._authCredentials = function(t) {
      if (!t)
        return new jR();
      switch (t.type) {
        case "gapi":
          const r = t.client;
          return new zR(r, t.sessionIndex || "0", t.iamToken || null, t.authTokenFactory || null);
        case "provider":
          return t.client;
        default:
          throw new J(ie, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(e.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = !0, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(e) {
      const t = lc.get(e);
      t && (la("ComponentProvider", "Removing Datastore"), lc.delete(e), t.terminate());
    }(this), Promise.resolve();
  }
}
function Ek(n, e, t) {
  t || (t = "(default)");
  const r = Rp(n, "firestore/lite");
  if (r.isInitialized(t))
    throw new J(Pi, "Firestore can only be initialized once per app.");
  return r.initialize({
    options: e,
    instanceIdentifier: t
  });
}
function Sk(n, e) {
  const t = typeof n == "object" ? n : MR(), r = typeof n == "string" ? n : e || "(default)", i = Rp(t, "firestore/lite").getImmediate({
    identifier: r
  });
  if (!i._initialized) {
    const s = CM("firestore");
    s && v6(i, ...s);
  }
  return i;
}
function v6(n, e, t, r = {}) {
  var i;
  const s = (n = pr(n, ni))._getSettings();
  if (s.host !== "firestore.googleapis.com" && s.host !== e && qw("Host has been set in both settings() and useEmulator(), emulator host will be used"), n._setSettings(Object.assign(Object.assign({}, s), {
    host: `${e}:${t}`,
    ssl: !1
  })), r.mockUserToken) {
    let a, o;
    if (typeof r.mockUserToken == "string")
      a = r.mockUserToken, o = Sn.MOCK_USER;
    else {
      a = _M(r.mockUserToken, (i = n._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const c = r.mockUserToken.sub || r.mockUserToken.user_id;
      if (!c)
        throw new J(ie, "mockUserToken must contain 'sub' or 'user_id' field!");
      o = new Sn(c);
    }
    n._authCredentials = new GR(new t6(a, o));
  }
}
function _k(n) {
  return n = pr(n, ni), ER(n.app, "firestore/lite"), n._delete();
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Pk {
  constructor() {
    this.type = "AggregateField";
  }
}
class w6 {
  constructor(e, t) {
    this._data = t, this.type = "AggregateQuerySnapshot", this.query = e;
  }
  data() {
    return this._data;
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Mk {
  constructor(e, t, r) {
    this.query = e, this.datastore = t, this.userDataWriter = r;
  }
  run() {
    return Ck(this.datastore, this.query._query).then((e) => {
      pn(e[0] !== void 0);
      const t = Object.entries(e[0]).filter(([r, i]) => r === "count_alias").map(([r, i]) => this.userDataWriter.convertValue(i))[0];
      return pn(typeof t == "number"), Promise.resolve(new w6(this.query, {
        count: t
      }));
    });
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Lt {
  constructor(e, t, r) {
    this.converter = t, this._key = r, this.type = "document", this.firestore = e;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new ar(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(e) {
    return new Lt(this.firestore, e, this._key);
  }
}
class qn {
  constructor(e, t, r) {
    this.converter = t, this._query = r, this.type = "query", this.firestore = e;
  }
  withConverter(e) {
    return new qn(this.firestore, e, this._query);
  }
}
class ar extends qn {
  constructor(e, t, r) {
    super(e, t, new Ta(r)), this._path = r, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const e = this._path.popLast();
    return e.isEmpty() ? null : new Lt(
      this.firestore,
      null,
      new Dt(e)
    );
  }
  withConverter(e) {
    return new ar(this.firestore, e, this._path);
  }
}
function e0(n, e, ...t) {
  if (n = Ut(n), $p("collection", "path", e), n instanceof ni) {
    const r = Pt.fromString(e, ...t);
    return yx(r), new ar(n, null, r);
  }
  {
    if (!(n instanceof Lt || n instanceof ar))
      throw new J(ie, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = n._path.child(Pt.fromString(e, ...t));
    return yx(r), new ar(
      n.firestore,
      null,
      r
    );
  }
}
function Rk(n, e) {
  if (n = pr(n, ni), $p("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new J(ie, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new qn(
    n,
    null,
    function(t) {
      return new Ta(Pt.emptyPath(), t);
    }(e)
  );
}
function uc(n, e, ...t) {
  if (n = Ut(n), arguments.length === 1 && (e = ek.D()), $p("doc", "path", e), n instanceof ni) {
    const r = Pt.fromString(e, ...t);
    return mx(r), new Lt(
      n,
      null,
      new Dt(r)
    );
  }
  {
    if (!(n instanceof Lt || n instanceof ar))
      throw new J(ie, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const r = n._path.child(Pt.fromString(e, ...t));
    return mx(r), new Lt(n.firestore, n instanceof ar ? n.converter : null, new Dt(r));
  }
}
function kk(n, e) {
  return n = Ut(n), e = Ut(e), (n instanceof Lt || n instanceof ar) && (e instanceof Lt || e instanceof ar) && n.firestore === e.firestore && n.path === e.path && n.converter === e.converter;
}
function Hp(n, e) {
  return n = Ut(n), e = Ut(e), n instanceof qn && e instanceof qn && n.firestore === e.firestore && dk(n._query, e._query) && n.converter === e.converter;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ha {
  constructor(e) {
    this._byteString = e;
  }
  static fromBase64String(e) {
    try {
      return new ha(Mi.fromBase64String(e));
    } catch (t) {
      throw new J(ie, "Failed to construct data from Base64 string: " + t);
    }
  }
  static fromUint8Array(e) {
    return new ha(Mi.fromUint8Array(e));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(e) {
    return this._byteString.isEqual(e._byteString);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class vs {
  constructor(...e) {
    for (let t = 0; t < e.length; ++t)
      if (e[t].length === 0)
        throw new J(ie, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new Wn(e);
  }
  isEqual(e) {
    return this._internalPath.isEqual(e._internalPath);
  }
}
function Ik() {
  return new vs("__name__");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ws {
  constructor(e) {
    this._methodName = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ud {
  constructor(e, t) {
    if (!isFinite(e) || e < -90 || e > 90)
      throw new J(ie, "Latitude must be a number between -90 and 90, but was: " + e);
    if (!isFinite(t) || t < -180 || t > 180)
      throw new J(ie, "Longitude must be a number between -180 and 180, but was: " + t);
    this._lat = e, this._long = t;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(e) {
    return this._lat === e._lat && this._long === e._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(e) {
    return Gt(this._lat, e._lat) || Gt(this._long, e._long);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ok = /^__.*__$/;
class Dk {
  constructor(e, t, r) {
    this.data = e, this.fieldMask = t, this.fieldTransforms = r;
  }
  toMutation(e, t) {
    return this.fieldMask !== null ? new jp(e, this.data, this.fieldMask, t, this.fieldTransforms) : new h6(e, this.data, t, this.fieldTransforms);
  }
}
class A6 {
  constructor(e, t, r) {
    this.data = e, this.fieldMask = t, this.fieldTransforms = r;
  }
  toMutation(e, t) {
    return new jp(e, this.data, this.fieldMask, t, this.fieldTransforms);
  }
}
function T6(n) {
  switch (n) {
    case 0:
    case 2:
    case 1:
      return !0;
    case 3:
    case 4:
      return !1;
    default:
      throw De();
  }
}
class Vd {
  constructor(e, t, r, i, s, a) {
    this.settings = e, this.databaseId = t, this.L = r, this.ignoreUndefinedProperties = i, s === void 0 && this.nt(), this.fieldTransforms = s || [], this.fieldMask = a || [];
  }
  get path() {
    return this.settings.path;
  }
  get rt() {
    return this.settings.rt;
  }
  st(e) {
    return new Vd(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.L, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  it(e) {
    var t;
    const r = (t = this.path) === null || t === void 0 ? void 0 : t.child(e), i = this.st({
      path: r,
      ot: !1
    });
    return i.ut(e), i;
  }
  ct(e) {
    var t;
    const r = (t = this.path) === null || t === void 0 ? void 0 : t.child(e), i = this.st({
      path: r,
      ot: !1
    });
    return i.nt(), i;
  }
  at(e) {
    return this.st({
      path: void 0,
      ot: !0
    });
  }
  ht(e) {
    return id(e, this.settings.methodName, this.settings.lt || !1, this.path, this.settings.ft);
  }
  contains(e) {
    return this.fieldMask.find((t) => e.isPrefixOf(t)) !== void 0 || this.fieldTransforms.find((t) => e.isPrefixOf(t.field)) !== void 0;
  }
  nt() {
    if (this.path)
      for (let e = 0; e < this.path.length; e++)
        this.ut(this.path.get(e));
  }
  ut(e) {
    if (e.length === 0)
      throw this.ht("Document fields must not be empty");
    if (T6(this.rt) && Ok.test(e))
      throw this.ht('Document fields cannot begin and end with "__"');
  }
}
class Nk {
  constructor(e, t, r) {
    this.databaseId = e, this.ignoreUndefinedProperties = t, this.L = r || Wp(e);
  }
  dt(e, t, r, i = !1) {
    return new Vd({
      rt: e,
      methodName: t,
      ft: r,
      path: Wn.emptyPath(),
      ot: !1,
      lt: i
    }, this.databaseId, this.L, this.ignoreUndefinedProperties);
  }
}
function Ca(n) {
  const e = n._freezeSettings(), t = Wp(n._databaseId);
  return new Nk(n._databaseId, !!e.ignoreUndefinedProperties, t);
}
function jd(n, e, t, r, i, s = {}) {
  const a = n.dt(s.merge || s.mergeFields ? 2 : 0, e, t, i);
  Qp("Data must be an object, but it was:", a, r);
  const o = S6(r, a);
  let c, l;
  if (s.merge)
    c = new ua(a.fieldMask), l = a.fieldTransforms;
  else if (s.mergeFields) {
    const f = [];
    for (const p of s.mergeFields) {
      const g = t0(e, p, t);
      if (!a.contains(g))
        throw new J(ie, `Field '${g}' is specified in your field mask but missing from your input data.`);
      P6(f, g) || f.push(g);
    }
    c = new ua(f), l = a.fieldTransforms.filter((p) => c.covers(p.field));
  } else
    c = null, l = a.fieldTransforms;
  return new Dk(new Hn(o), c, l);
}
class fl extends ws {
  _toFieldTransform(e) {
    if (e.rt !== 2)
      throw e.rt === 1 ? e.ht(`${this._methodName}() can only appear at the top level of your update data`) : e.ht(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return e.fieldMask.push(e.path), null;
  }
  isEqual(e) {
    return e instanceof fl;
  }
}
function C6(n, e, t) {
  return new Vd({
    rt: 3,
    ft: e.settings.ft,
    methodName: n._methodName,
    ot: t
  }, e.databaseId, e.L, e.ignoreUndefinedProperties);
}
class zp extends ws {
  _toFieldTransform(e) {
    return new $d(e.path, new l6());
  }
  isEqual(e) {
    return e instanceof zp;
  }
}
class Bk extends ws {
  constructor(e, t) {
    super(e), this.wt = t;
  }
  _toFieldTransform(e) {
    const t = C6(
      this,
      e,
      !0
    ), r = this.wt.map((s) => Ea(s, t)), i = new u6(r);
    return new $d(e.path, i);
  }
  isEqual(e) {
    return this === e;
  }
}
class $k extends ws {
  constructor(e, t) {
    super(e), this.wt = t;
  }
  _toFieldTransform(e) {
    const t = C6(
      this,
      e,
      !0
    ), r = this.wt.map((s) => Ea(s, t)), i = new d6(r);
    return new $d(e.path, i);
  }
  isEqual(e) {
    return this === e;
  }
}
class Lk extends ws {
  constructor(e, t) {
    super(e), this.yt = t;
  }
  _toFieldTransform(e) {
    const t = new f6(e.L, c6(e.L, this.yt));
    return new $d(e.path, t);
  }
  isEqual(e) {
    return this === e;
  }
}
function Kp(n, e, t, r) {
  const i = n.dt(1, e, t);
  Qp("Data must be an object, but it was:", i, r);
  const s = [], a = Hn.empty();
  dl(r, (c, l) => {
    const f = Jp(e, c, t);
    l = Ut(l);
    const p = i.ct(f);
    if (l instanceof fl)
      s.push(f);
    else {
      const g = Ea(l, p);
      g != null && (s.push(f), a.set(f, g));
    }
  });
  const o = new ua(s);
  return new A6(a, o, i.fieldTransforms);
}
function qp(n, e, t, r, i, s) {
  const a = n.dt(1, e, t), o = [t0(e, r, t)], c = [i];
  if (s.length % 2 != 0)
    throw new J(ie, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let g = 0; g < s.length; g += 2)
    o.push(t0(e, s[g])), c.push(s[g + 1]);
  const l = [], f = Hn.empty();
  for (let g = o.length - 1; g >= 0; --g)
    if (!P6(l, o[g])) {
      const T = o[g];
      let v = c[g];
      v = Ut(v);
      const w = a.ct(T);
      if (v instanceof fl)
        l.push(T);
      else {
        const C = Ea(v, w);
        C != null && (l.push(T), f.set(T, C));
      }
    }
  const p = new ua(l);
  return new A6(f, p, a.fieldTransforms);
}
function E6(n, e, t, r = !1) {
  return Ea(t, n.dt(r ? 4 : 3, e));
}
function Ea(n, e) {
  if (_6(
    n = Ut(n)
  ))
    return Qp("Unsupported field value:", e, n), S6(n, e);
  if (n instanceof ws)
    return function(t, r) {
      if (!T6(r.rt))
        throw r.ht(`${t._methodName}() can only be used with update() and set()`);
      if (!r.path)
        throw r.ht(`${t._methodName}() is not currently supported inside arrays`);
      const i = t._toFieldTransform(r);
      i && r.fieldTransforms.push(i);
    }(n, e), null;
  if (n === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), n instanceof Array) {
    if (e.settings.ot && e.rt !== 4)
      throw e.ht("Nested arrays are not supported");
    return function(t, r) {
      const i = [];
      let s = 0;
      for (const a of t) {
        let o = Ea(a, r.at(s));
        o == null && (o = {
          nullValue: "NULL_VALUE"
        }), i.push(o), s++;
      }
      return {
        arrayValue: {
          values: i
        }
      };
    }(n, e);
  }
  return function(t, r) {
    if ((t = Ut(t)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t == "number")
      return c6(r.L, t);
    if (typeof t == "boolean")
      return {
        booleanValue: t
      };
    if (typeof t == "string")
      return {
        stringValue: t
      };
    if (t instanceof Date) {
      const i = In.fromDate(t);
      return {
        timestampValue: Yh(r.L, i)
      };
    }
    if (t instanceof In) {
      const i = new In(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3));
      return {
        timestampValue: Yh(r.L, i)
      };
    }
    if (t instanceof Ud)
      return {
        geoPointValue: {
          latitude: t.latitude,
          longitude: t.longitude
        }
      };
    if (t instanceof ha)
      return {
        bytesValue: mk(r.L, t._byteString)
      };
    if (t instanceof Lt) {
      const i = r.databaseId, s = t.firestore._databaseId;
      if (!s.isEqual(i))
        throw r.ht(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${i.projectId}/${i.database}`);
      return {
        referenceValue: Gp(t.firestore._databaseId || r.databaseId, t._key.path)
      };
    }
    throw r.ht(`Unsupported field value: ${Nd(t)}`);
  }(n, e);
}
function S6(n, e) {
  const t = {};
  return function(r) {
    for (const i in r)
      if (Object.prototype.hasOwnProperty.call(r, i))
        return !1;
    return !0;
  }(n) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : dl(n, (r, i) => {
    const s = Ea(i, e.it(r));
    s != null && (t[r] = s);
  }), {
    mapValue: {
      fields: t
    }
  };
}
function _6(n) {
  return !(typeof n != "object" || n === null || n instanceof Array || n instanceof Date || n instanceof In || n instanceof Ud || n instanceof ha || n instanceof Lt || n instanceof ws);
}
function Qp(n, e, t) {
  if (!_6(t) || !function(r) {
    return typeof r == "object" && r !== null && (Object.getPrototypeOf(r) === Object.prototype || Object.getPrototypeOf(r) === null);
  }(t)) {
    const r = Nd(t);
    throw r === "an object" ? e.ht(n + " a custom object") : e.ht(n + " " + r);
  }
}
function t0(n, e, t) {
  if ((e = Ut(e)) instanceof vs)
    return e._internalPath;
  if (typeof e == "string")
    return Jp(n, e);
  throw id(
    "Field path arguments must be of type string or ",
    n,
    !1,
    void 0,
    t
  );
}
const Fk = new RegExp("[~\\*/\\[\\]]");
function Jp(n, e, t) {
  if (e.search(Fk) >= 0)
    throw id(
      `Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,
      n,
      !1,
      void 0,
      t
    );
  try {
    return new vs(...e.split("."))._internalPath;
  } catch {
    throw id(
      `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      n,
      !1,
      void 0,
      t
    );
  }
}
function id(n, e, t, r, i) {
  const s = r && !r.isEmpty(), a = i !== void 0;
  let o = `Function ${e}() called with invalid data`;
  t && (o += " (via `toFirestore()`)"), o += ". ";
  let c = "";
  return (s || a) && (c += " (found", s && (c += ` in field ${r}`), a && (c += ` in document ${i}`), c += ")"), new J(ie, o + n + c);
}
function P6(n, e) {
  return n.some((t) => t.isEqual(e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ms {
  constructor(e, t, r, i, s) {
    this._firestore = e, this._userDataWriter = t, this._key = r, this._document = i, this._converter = s;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new Lt(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const e = new Yp(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          null
        );
        return this._converter.fromFirestore(e);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(e) {
    if (this._document) {
      const t = this._document.data.field(Xp("DocumentSnapshot.get", e));
      if (t !== null)
        return this._userDataWriter.convertValue(t);
    }
  }
}
class Yp extends ms {
  data() {
    return super.data();
  }
}
class sd {
  constructor(e, t) {
    this._docs = t, this.query = e;
  }
  get docs() {
    return [...this._docs];
  }
  get size() {
    return this.docs.length;
  }
  get empty() {
    return this.docs.length === 0;
  }
  forEach(e, t) {
    this._docs.forEach(e, t);
  }
}
function M6(n, e) {
  return n = Ut(n), e = Ut(e), n instanceof ms && e instanceof ms ? n._firestore === e._firestore && n._key.isEqual(e._key) && (n._document === null ? e._document === null : n._document.isEqual(e._document)) && n._converter === e._converter : n instanceof sd && e instanceof sd && Hp(n.query, e.query) && Lp(n.docs, e.docs, M6);
}
function Xp(n, e) {
  return typeof e == "string" ? Jp(n, e) : e instanceof vs ? e._internalPath : e._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ko {
}
function R6(n, ...e) {
  for (const t of e)
    n = t._apply(n);
  return n;
}
class Uk extends ko {
  constructor(e, t, r) {
    super(), this._t = e, this.gt = t, this.vt = r, this.type = "where";
  }
  _apply(e) {
    const t = Ca(e.firestore), r = function(i, s, a, o, c, l, f) {
      let p;
      if (c.isKeyField()) {
        if (l === "array-contains" || l === "array-contains-any")
          throw new J(ie, `Invalid Query. You can't perform '${l}' queries on documentId().`);
        if (l === "in" || l === "not-in") {
          Rx(f, l);
          const T = [];
          for (const v of f)
            T.push(Mx(o, i, v));
          p = {
            arrayValue: {
              values: T
            }
          };
        } else
          p = Mx(o, i, f);
      } else
        l !== "in" && l !== "not-in" && l !== "array-contains-any" || Rx(f, l), p = E6(
          a,
          s,
          f,
          l === "in" || l === "not-in"
        );
      const g = ti.create(c, l, p);
      return function(T, v) {
        if (v.q()) {
          const C = Vp(T);
          if (C !== null && !C.isEqual(v.field))
            throw new J(ie, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${C.toString()}' and '${v.field.toString()}'`);
          const _ = Up(T);
          _ !== null && B6(T, v.field, _);
        }
        const w = function(C, _) {
          for (const I of C.filters)
            if (_.indexOf(I.op) >= 0)
              return I.op;
          return null;
        }(
          T,
          function(C) {
            switch (C) {
              case "!=":
                return ["!=", "not-in"];
              case "array-contains":
                return ["array-contains", "array-contains-any", "not-in"];
              case "in":
                return ["array-contains-any", "in", "not-in"];
              case "array-contains-any":
                return ["array-contains", "array-contains-any", "in", "not-in"];
              case "not-in":
                return ["array-contains", "array-contains-any", "in", "not-in", "!="];
              default:
                return [];
            }
          }(v.op)
        );
        if (w !== null)
          throw w === v.op ? new J(ie, `Invalid query. You cannot use more than one '${v.op.toString()}' filter.`) : new J(ie, `Invalid query. You cannot use '${v.op.toString()}' filters with '${w.toString()}' filters.`);
      }(i, g), g;
    }(e._query, "where", t, e.firestore._databaseId, this._t, this.gt, this.vt);
    return new qn(e.firestore, e.converter, function(i, s) {
      const a = i.filters.concat([s]);
      return new Ta(i.path, i.collectionGroup, i.explicitOrderBy.slice(), a, i.limit, i.limitType, i.startAt, i.endAt);
    }(e._query, r));
  }
}
function k6(n, e, t) {
  const r = e, i = Xp("where", n);
  return new Uk(i, r, t);
}
class Vk extends ko {
  constructor(e, t) {
    super(), this._t = e, this.bt = t, this.type = "orderBy";
  }
  _apply(e) {
    const t = function(r, i, s) {
      if (r.startAt !== null)
        throw new J(ie, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (r.endAt !== null)
        throw new J(ie, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const a = new cc(i, s);
      return function(o, c) {
        if (Up(o) === null) {
          const l = Vp(o);
          l !== null && B6(o, l, c.field);
        }
      }(r, a), a;
    }(e._query, this._t, this.bt);
    return new qn(e.firestore, e.converter, function(r, i) {
      const s = r.explicitOrderBy.concat([i]);
      return new Ta(r.path, r.collectionGroup, s, r.filters.slice(), r.limit, r.limitType, r.startAt, r.endAt);
    }(e._query, t));
  }
}
function jk(n, e = "asc") {
  const t = e, r = Xp("orderBy", n);
  return new Vk(r, t);
}
class I6 extends ko {
  constructor(e, t, r) {
    super(), this.type = e, this.Et = t, this.It = r;
  }
  _apply(e) {
    return new qn(e.firestore, e.converter, function(t, r, i) {
      return new Ta(t.path, t.collectionGroup, t.explicitOrderBy.slice(), t.filters.slice(), r, i, t.startAt, t.endAt);
    }(e._query, this.Et, this.It));
  }
}
function Gk(n) {
  return n6("limit", n), new I6("limit", n, "F");
}
function Wk(n) {
  return n6("limitToLast", n), new I6("limitToLast", n, "L");
}
class O6 extends ko {
  constructor(e, t, r) {
    super(), this.type = e, this.Tt = t, this.At = r;
  }
  _apply(e) {
    const t = N6(e, this.type, this.Tt, this.At);
    return new qn(e.firestore, e.converter, function(r, i) {
      return new Ta(r.path, r.collectionGroup, r.explicitOrderBy.slice(), r.filters.slice(), r.limit, r.limitType, i, r.endAt);
    }(e._query, t));
  }
}
function Hk(...n) {
  return new O6(
    "startAt",
    n,
    !0
  );
}
function zk(...n) {
  return new O6(
    "startAfter",
    n,
    !1
  );
}
class D6 extends ko {
  constructor(e, t, r) {
    super(), this.type = e, this.Tt = t, this.At = r;
  }
  _apply(e) {
    const t = N6(e, this.type, this.Tt, this.At);
    return new qn(e.firestore, e.converter, function(r, i) {
      return new Ta(r.path, r.collectionGroup, r.explicitOrderBy.slice(), r.filters.slice(), r.limit, r.limitType, r.startAt, i);
    }(e._query, t));
  }
}
function Kk(...n) {
  return new D6(
    "endBefore",
    n,
    !1
  );
}
function qk(...n) {
  return new D6("endAt", n, !0);
}
function N6(n, e, t, r) {
  if (t[0] = Ut(t[0]), t[0] instanceof ms)
    return function(i, s, a, o, c) {
      if (!o)
        throw new J(Op, `Can't use a DocumentSnapshot that doesn't exist for ${a}().`);
      const l = [];
      for (const f of Jh(i))
        if (f.field.isKeyField())
          l.push(ed(s, o.key));
        else {
          const p = o.data.field(f.field);
          if (Fp(p))
            throw new J(ie, 'Invalid query. You are trying to start or end a query using a document for which the field "' + f.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (p === null) {
            const g = f.field.canonicalString();
            throw new J(ie, `Invalid query. You are trying to start or end a query using a document for which the field '${g}' (used as the orderBy) does not exist.`);
          }
          l.push(p);
        }
      return new td(l, c);
    }(n._query, n.firestore._databaseId, e, t[0]._document, r);
  {
    const i = Ca(n.firestore);
    return function(s, a, o, c, l, f) {
      const p = s.explicitOrderBy;
      if (l.length > p.length)
        throw new J(ie, `Too many arguments provided to ${c}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const g = [];
      for (let T = 0; T < l.length; T++) {
        const v = l[T];
        if (p[T].field.isKeyField()) {
          if (typeof v != "string")
            throw new J(ie, `Invalid query. Expected a string for document ID in ${c}(), but got a ${typeof v}`);
          if (!o6(s) && v.indexOf("/") !== -1)
            throw new J(ie, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${c}() must be a plain document ID, but '${v}' contains a slash.`);
          const w = s.path.child(Pt.fromString(v));
          if (!Dt.isDocumentKey(w))
            throw new J(ie, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${c}() must result in a valid document path, but '${w}' is not because it contains an odd number of segments.`);
          const C = new Dt(w);
          g.push(ed(a, C));
        } else {
          const w = E6(o, c, v);
          g.push(w);
        }
      }
      return new td(g, f);
    }(n._query, n.firestore._databaseId, i, e, t, r);
  }
}
function Mx(n, e, t) {
  if (typeof (t = Ut(t)) == "string") {
    if (t === "")
      throw new J(ie, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!o6(e) && t.indexOf("/") !== -1)
      throw new J(ie, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${t}' contains a '/' character.`);
    const r = e.path.child(Pt.fromString(t));
    if (!Dt.isDocumentKey(r))
      throw new J(ie, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${r}' is not because it has an odd number of segments (${r.length}).`);
    return ed(n, new Dt(r));
  }
  if (t instanceof Lt)
    return ed(n, t._key);
  throw new J(ie, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${Nd(t)}.`);
}
function Rx(n, e) {
  if (!Array.isArray(n) || n.length === 0)
    throw new J(ie, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (n.length > 10)
    throw new J(ie, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function B6(n, e, t) {
  if (!t.isEqual(e))
    throw new J(ie, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${t.toString()}' instead.`);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Gd(n, e, t) {
  let r;
  return r = n ? t && (t.merge || t.mergeFields) ? n.toFirestore(e, t) : n.toFirestore(e) : e, r;
}
class Wd extends class {
  convertValue(e, t = "none") {
    switch (fa(e)) {
      case 0:
        return null;
      case 1:
        return e.booleanValue;
      case 2:
        return Bt(e.integerValue || e.doubleValue);
      case 3:
        return this.convertTimestamp(e.timestampValue);
      case 4:
        return this.convertServerTimestamp(e, t);
      case 5:
        return e.stringValue;
      case 6:
        return this.convertBytes($c(e.bytesValue));
      case 7:
        return this.convertReference(e.referenceValue);
      case 8:
        return this.convertGeoPoint(e.geoPointValue);
      case 9:
        return this.convertArray(e.arrayValue, t);
      case 10:
        return this.convertObject(e.mapValue, t);
      default:
        throw De();
    }
  }
  convertObject(e, t) {
    const r = {};
    return dl(e.fields, (i, s) => {
      r[i] = this.convertValue(s, t);
    }), r;
  }
  convertGeoPoint(e) {
    return new Ud(Bt(e.latitude), Bt(e.longitude));
  }
  convertArray(e, t) {
    return (e.values || []).map((r) => this.convertValue(r, t));
  }
  convertServerTimestamp(e, t) {
    switch (t) {
      case "previous":
        const r = i6(e);
        return r == null ? null : this.convertValue(r, t);
      case "estimate":
        return this.convertTimestamp(Lc(e));
      default:
        return null;
    }
  }
  convertTimestamp(e) {
    const t = da(e);
    return new In(t.seconds, t.nanos);
  }
  convertDocumentKey(e, t) {
    const r = Pt.fromString(e);
    pn(g6(r));
    const i = new Nc(r.get(1), r.get(3)), s = new Dt(r.popFirst(5));
    return i.isEqual(t) || Dd(`Document ${s} contains a document reference within a different database (${i.projectId}/${i.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`), s;
  }
} {
  constructor(e) {
    super(), this.firestore = e;
  }
  convertBytes(e) {
    return new ha(e);
  }
  convertReference(e) {
    const t = this.convertDocumentKey(e, this.firestore._databaseId);
    return new Lt(this.firestore, null, t);
  }
}
function Qk(n) {
  const e = Li((n = pr(n, Lt)).firestore), t = new Wd(n.firestore);
  return x6(e, [n._key]).then((r) => {
    pn(r.length === 1);
    const i = r[0];
    return new ms(n.firestore, t, n._key, i.isFoundDocument() ? i : null, n.converter);
  });
}
function n0(n) {
  (function(r) {
    if (r.limitType === "L" && r.explicitOrderBy.length === 0)
      throw new J(Np, "limitToLast() queries require specifying at least one orderBy() clause");
  })((n = pr(n, qn))._query);
  const e = Li(n.firestore), t = new Wd(n.firestore);
  return Tk(e, n._query).then((r) => {
    const i = r.map((s) => new Yp(n.firestore, t, s.key, s, n.converter));
    return n._query.limitType === "L" && i.reverse(), new sd(n, i);
  });
}
function r0(n, e, t) {
  const r = Gd((n = pr(n, Lt)).converter, e, t), i = jd(Ca(n.firestore), "setDoc", n._key, r, n.converter !== null, t);
  return Ro(Li(n.firestore), [i.toMutation(n._key, dn.none())]);
}
function Jk(n, e, t, ...r) {
  const i = Ca((n = pr(n, Lt)).firestore);
  let s;
  return s = typeof (e = Ut(e)) == "string" || e instanceof vs ? qp(i, "updateDoc", n._key, e, t, r) : Kp(i, "updateDoc", n._key, e), Ro(Li(n.firestore), [s.toMutation(n._key, dn.exists(!0))]);
}
function $6(n) {
  return Ro(Li((n = pr(n, Lt)).firestore), [new Fd(n._key, dn.none())]);
}
function Yk(n, e) {
  const t = uc(n = pr(n, ar)), r = Gd(n.converter, e), i = jd(Ca(n.firestore), "addDoc", t._key, r, t.converter !== null, {});
  return Ro(Li(n.firestore), [i.toMutation(t._key, dn.exists(!1))]).then(() => t);
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Xk(n) {
  const e = pr(n.firestore, ni), t = Li(e), r = new Wd(e);
  return new Mk(n, t, r).run();
}
function Zk(n, e) {
  return Hp(n.query, e.query) && Hu(n.data(), e.data());
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function eI() {
  return new fl("deleteField");
}
function tI() {
  return new zp("serverTimestamp");
}
function nI(...n) {
  return new Bk("arrayUnion", n);
}
function rI(...n) {
  return new $k("arrayRemove", n);
}
function iI(n) {
  return new Lk("increment", n);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class L6 {
  constructor(e, t) {
    this._firestore = e, this._commitHandler = t, this._mutations = [], this._committed = !1, this._dataReader = Ca(e);
  }
  set(e, t, r) {
    this._verifyNotCommitted();
    const i = qs(e, this._firestore), s = Gd(i.converter, t, r), a = jd(this._dataReader, "WriteBatch.set", i._key, s, i.converter !== null, r);
    return this._mutations.push(a.toMutation(i._key, dn.none())), this;
  }
  update(e, t, r, ...i) {
    this._verifyNotCommitted();
    const s = qs(e, this._firestore);
    let a;
    return a = typeof (t = Ut(t)) == "string" || t instanceof vs ? qp(this._dataReader, "WriteBatch.update", s._key, t, r, i) : Kp(this._dataReader, "WriteBatch.update", s._key, t), this._mutations.push(a.toMutation(s._key, dn.exists(!0))), this;
  }
  delete(e) {
    this._verifyNotCommitted();
    const t = qs(e, this._firestore);
    return this._mutations = this._mutations.concat(new Fd(t._key, dn.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new J(Pi, "A write batch can no longer be used after commit() has been called.");
  }
}
function qs(n, e) {
  if ((n = Ut(n)).firestore !== e)
    throw new J(ie, "Provided document reference is from a different Firestore instance.");
  return n;
}
function F6(n) {
  const e = Li(n = pr(n, ni));
  return new L6(n, (t) => Ro(e, t));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class sI {
  constructor(e) {
    this.datastore = e, this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = !1, this.lastWriteError = null, this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(e) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new J(ie, "Firestore transactions require all reads to be executed before all writes.");
    const t = await x6(this.datastore, e);
    return t.forEach((r) => this.recordVersion(r)), t;
  }
  set(e, t) {
    this.write(t.toMutation(e, this.precondition(e))), this.writtenDocs.add(e.toString());
  }
  update(e, t) {
    try {
      this.write(t.toMutation(e, this.preconditionForUpdate(e)));
    } catch (r) {
      this.lastWriteError = r;
    }
    this.writtenDocs.add(e.toString());
  }
  delete(e) {
    this.write(new Fd(e, this.precondition(e))), this.writtenDocs.add(e.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const e = this.readVersions;
    this.mutations.forEach((t) => {
      e.delete(t.key.toString());
    }), e.forEach((t, r) => {
      const i = Dt.fromPath(r);
      this.mutations.push(new p6(i, this.precondition(i)));
    }), await Ro(this.datastore, this.mutations), this.committed = !0;
  }
  recordVersion(e) {
    let t;
    if (e.isFoundDocument())
      t = e.version;
    else {
      if (!e.isNoDocument())
        throw De();
      t = _n.min();
    }
    const r = this.readVersions.get(e.key.toString());
    if (r) {
      if (!t.isEqual(r))
        throw new J(Dp, "Document version changed between two reads.");
    } else
      this.readVersions.set(e.key.toString(), t);
  }
  precondition(e) {
    const t = this.readVersions.get(e.toString());
    return !this.writtenDocs.has(e.toString()) && t ? t.isEqual(_n.min()) ? dn.exists(!1) : dn.updateTime(t) : dn.none();
  }
  preconditionForUpdate(e) {
    const t = this.readVersions.get(e.toString());
    if (!this.writtenDocs.has(e.toString()) && t) {
      if (t.isEqual(_n.min()))
        throw new J(ie, "Can't update a document that doesn't exist.");
      return dn.updateTime(t);
    }
    return dn.exists(!0);
  }
  write(e) {
    this.ensureCommitNotCalled(), this.mutations.push(e);
  }
  ensureCommitNotCalled() {
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const aI = {
  maxAttempts: 5
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class oI {
  constructor(e, t, r, i, s) {
    this.asyncQueue = e, this.datastore = t, this.options = r, this.updateFunction = i, this.deferred = s, this.Rt = r.maxAttempts, this.Pt = new b6(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.Rt -= 1, this.Vt();
  }
  Vt() {
    this.Pt.J(async () => {
      const e = new sI(this.datastore), t = this.Nt(e);
      t && t.then((r) => {
        this.asyncQueue.enqueueAndForget(() => e.commit().then(() => {
          this.deferred.resolve(r);
        }).catch((i) => {
          this.Dt(i);
        }));
      }).catch((r) => {
        this.Dt(r);
      });
    });
  }
  Nt(e) {
    try {
      const t = this.updateFunction(e);
      return !r6(t) && t.catch && t.then ? t : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t) {
      return this.deferred.reject(t), null;
    }
  }
  Dt(e) {
    this.Rt > 0 && this.$t(e) ? (this.Rt -= 1, this.asyncQueue.enqueueAndForget(() => (this.Vt(), Promise.resolve()))) : this.deferred.reject(e);
  }
  $t(e) {
    if (e.name === "FirebaseError") {
      const t = e.code;
      return t === "aborted" || t === "failed-precondition" || !function(r) {
        switch (r) {
          default:
            return De();
          case Ip:
          case Ka:
          case Qw:
          case Yw:
          case Zw:
          case e6:
          case Qu:
            return !1;
          case ie:
          case Op:
          case UR:
          case Jw:
          case Pi:
          case Dp:
          case Xw:
          case Np:
          case VR:
            return !0;
        }
      }(t);
    }
    return !1;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function th() {
  return typeof document < "u" ? document : null;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Zp {
  constructor(e, t, r, i, s) {
    this.asyncQueue = e, this.timerId = t, this.targetTimeMs = r, this.op = i, this.removalCallback = s, this.deferred = new Bp(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((a) => {
    });
  }
  static createAndSchedule(e, t, r, i, s) {
    const a = Date.now() + r, o = new Zp(e, t, a, i, s);
    return o.start(r), o;
  }
  start(e) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(e) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new J(Ip, "Operation cancelled" + (e ? ": " + e : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((e) => this.deferred.resolve(e))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cI {
  constructor() {
    this.xt = Promise.resolve(), this.Ft = [], this.St = !1, this.qt = [], this.Ot = null, this.kt = !1, this.Ct = !1, this.Lt = [], this.Pt = new b6(this, "async_queue_retry"), this.Mt = () => {
      const t = th();
      t && la("AsyncQueue", "Visibility state changed to " + t.visibilityState), this.Pt.Z();
    };
    const e = th();
    e && typeof e.addEventListener == "function" && e.addEventListener("visibilitychange", this.Mt);
  }
  get isShuttingDown() {
    return this.St;
  }
  enqueueAndForget(e) {
    this.enqueue(e);
  }
  enqueueAndForgetEvenWhileRestricted(e) {
    this.Ut(), this.jt(e);
  }
  enterRestrictedMode(e) {
    if (!this.St) {
      this.St = !0, this.Ct = e || !1;
      const t = th();
      t && typeof t.removeEventListener == "function" && t.removeEventListener("visibilitychange", this.Mt);
    }
  }
  enqueue(e) {
    if (this.Ut(), this.St)
      return new Promise(() => {
      });
    const t = new Bp();
    return this.jt(() => this.St && this.Ct ? Promise.resolve() : (e().then(t.resolve, t.reject), t.promise)).then(() => t.promise);
  }
  enqueueRetryable(e) {
    this.enqueueAndForget(() => (this.Ft.push(e), this.Bt()));
  }
  async Bt() {
    if (this.Ft.length !== 0) {
      try {
        await this.Ft[0](), this.Ft.shift(), this.Pt.reset();
      } catch (e) {
        if (!function(t) {
          return t.name === "IndexedDbTransactionError";
        }(e))
          throw e;
        la("AsyncQueue", "Operation failed with retryable error: " + e);
      }
      this.Ft.length > 0 && this.Pt.J(() => this.Bt());
    }
  }
  jt(e) {
    const t = this.xt.then(() => (this.kt = !0, e().catch((r) => {
      this.Ot = r, this.kt = !1;
      const i = function(s) {
        let a = s.message || "";
        return s.stack && (a = s.stack.includes(s.message) ? s.stack : s.message + `
` + s.stack), a;
      }(r);
      throw Dd("INTERNAL UNHANDLED ERROR: ", i), r;
    }).then((r) => (this.kt = !1, r))));
    return this.xt = t, t;
  }
  enqueueAfterDelay(e, t, r) {
    this.Ut(), this.Lt.indexOf(e) > -1 && (t = 0);
    const i = Zp.createAndSchedule(this, e, t, r, (s) => this.Qt(s));
    return this.qt.push(i), i;
  }
  Ut() {
    this.Ot && De();
  }
  verifyOperationInProgress() {
  }
  async zt() {
    let e;
    do
      e = this.xt, await e;
    while (e !== this.xt);
  }
  Gt(e) {
    for (const t of this.qt)
      if (t.timerId === e)
        return !0;
    return !1;
  }
  Wt(e) {
    return this.zt().then(() => {
      this.qt.sort((t, r) => t.targetTimeMs - r.targetTimeMs);
      for (const t of this.qt)
        if (t.skipDelay(), e !== "all" && t.timerId === e)
          break;
      return this.zt();
    });
  }
  Kt(e) {
    this.Lt.push(e);
  }
  Qt(e) {
    const t = this.qt.indexOf(e);
    this.qt.splice(t, 1);
  }
}
class U6 {
  constructor(e, t) {
    this._firestore = e, this._transaction = t, this._dataReader = Ca(e);
  }
  get(e) {
    const t = qs(e, this._firestore), r = new Wd(this._firestore);
    return this._transaction.lookup([t._key]).then((i) => {
      if (!i || i.length !== 1)
        return De();
      const s = i[0];
      if (s.isFoundDocument())
        return new ms(this._firestore, r, s.key, s, t.converter);
      if (s.isNoDocument())
        return new ms(this._firestore, r, t._key, null, t.converter);
      throw De();
    });
  }
  set(e, t, r) {
    const i = qs(e, this._firestore), s = Gd(i.converter, t, r), a = jd(this._dataReader, "Transaction.set", i._key, s, i.converter !== null, r);
    return this._transaction.set(i._key, a), this;
  }
  update(e, t, r, ...i) {
    const s = qs(e, this._firestore);
    let a;
    return a = typeof (t = Ut(t)) == "string" || t instanceof vs ? qp(this._dataReader, "Transaction.update", s._key, t, r, i) : Kp(this._dataReader, "Transaction.update", s._key, t), this._transaction.update(s._key, a), this;
  }
  delete(e) {
    const t = qs(e, this._firestore);
    return this._transaction.delete(t._key), this;
  }
}
function lI(n, e, t) {
  const r = Li(n = pr(n, ni)), i = Object.assign(Object.assign({}, aI), t);
  (function(a) {
    if (a.maxAttempts < 1)
      throw new J(ie, "Max attempts must be at least 1");
  })(i);
  const s = new Bp();
  return new oI(new cI(), r, i, (a) => e(new U6(n, a)), s).run(), s.promise;
}
(function(n) {
  Po = n;
})(`${PR}_lite`), qu(new Oc("firestore/lite", (n, { instanceIdentifier: e, options: t }) => {
  const r = n.getProvider("app").getImmediate(), i = new ni(new WR(n.getProvider("auth-internal")), new qR(n.getProvider("app-check-internal")), function(s, a) {
    if (!Object.prototype.hasOwnProperty.apply(s.options, ["projectId"]))
      throw new J(ie, '"projectId" not provided in firebase.initializeApp.');
    return new Nc(s.options.projectId, a);
  }(r, e), r);
  return t && i._setSettings(t), i;
}, "PUBLIC").setMultipleInstances(!0)), za("firestore-lite", "3.7.2", ""), za("firestore-lite", "3.7.2", "esm2017");
const kx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AggregateField: Pk,
  AggregateQuerySnapshot: w6,
  Bytes: ha,
  CollectionReference: ar,
  DocumentReference: Lt,
  DocumentSnapshot: ms,
  FieldPath: vs,
  FieldValue: ws,
  Firestore: ni,
  FirestoreError: J,
  GeoPoint: Ud,
  Query: qn,
  QueryConstraint: ko,
  QueryDocumentSnapshot: Yp,
  QuerySnapshot: sd,
  Timestamp: In,
  Transaction: U6,
  WriteBatch: L6,
  addDoc: Yk,
  aggregateQuerySnapshotEqual: Zk,
  arrayRemove: rI,
  arrayUnion: nI,
  collection: e0,
  collectionGroup: Rk,
  connectFirestoreEmulator: v6,
  deleteDoc: $6,
  deleteField: eI,
  doc: uc,
  documentId: Ik,
  endAt: qk,
  endBefore: Kk,
  getCount: Xk,
  getDoc: Qk,
  getDocs: n0,
  getFirestore: Sk,
  increment: iI,
  initializeFirestore: Ek,
  limit: Gk,
  limitToLast: Wk,
  orderBy: jk,
  query: R6,
  queryEqual: Hp,
  refEqual: kk,
  runTransaction: lI,
  serverTimestamp: tI,
  setDoc: r0,
  setLogLevel: FR,
  snapshotEqual: M6,
  startAfter: zk,
  startAt: Hk,
  terminate: _k,
  updateDoc: Jk,
  where: k6,
  writeBatch: F6
}, Symbol.toStringTag, { value: "Module" })), uI = {
  authDomain: "kolektivo-36b63.firebaseapp.com",
  projectId: "kolektivo-36b63",
  storageBucket: "kolektivo-36b63.appspot.com",
  messagingSenderId: "324595180464",
  appId: "1:324595180464:web:69e6b83cdba3bf2d30ac75",
  measurementId: "G-7BSHV1Y6VS"
};
var dI = "firebase", fI = "9.13.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
za(dI, fI, "app");
const hI = "Kolektivo Tokenlist", pI = "2022-08-16T22:25:12+00:00", mI = {
  major: 1,
  minor: 2,
  patch: 0
}, yI = [
  "kolektivo",
  "tokens"
], gI = [
  {
    address: "0xEAc68B2e33fA3dbde9bABf3edF17ed3437f3D992",
    chainId: 44787,
    name: "Kolektivo Treasury Token",
    symbol: "KTT",
    decimals: 18,
    logoURI: "https://gateway.pinata.cloud/ipfs/QmcRYtXPMK54EtwzPqP3Bs59x7oQzNN8X5X3oMZFHe1SBj/ktt.svg"
  },
  {
    address: "0x799aC807A4163899c09086A6C69490f6AecD65Cb",
    chainId: 44787,
    name: "Kolektivo Curacao Token",
    symbol: "kCUR",
    decimals: 18,
    logoURI: "https://gateway.pinata.cloud/ipfs/QmcRYtXPMK54EtwzPqP3Bs59x7oQzNN8X5X3oMZFHe1SBj/kcur.svg"
  },
  {
    address: "0x8E7Af361418CDAb43333c6Bd0fA6906285C0E272",
    chainId: 44787,
    name: "Test Token #1",
    symbol: "TT1",
    decimals: 18,
    logoURI: "https://gateway.pinata.cloud/ipfs/QmcRYtXPMK54EtwzPqP3Bs59x7oQzNN8X5X3oMZFHe1SBj/tt1.svg"
  },
  {
    address: "0x57f046C697B15D0933605F12152c5d96cB6f9cc5",
    chainId: 44787,
    name: "Test Token #2",
    symbol: "TT2",
    decimals: 18,
    logoURI: "https://gateway.pinata.cloud/ipfs/QmcRYtXPMK54EtwzPqP3Bs59x7oQzNN8X5X3oMZFHe1SBj/tt1.svg"
  },
  {
    address: "0x32dB9295556D2B5193FD404253a4a3fD206B754b",
    chainId: 44787,
    name: "Test Token #3",
    symbol: "TT3",
    decimals: 18,
    logoURI: "https://gateway.pinata.cloud/ipfs/QmcRYtXPMK54EtwzPqP3Bs59x7oQzNN8X5X3oMZFHe1SBj/tt1.svg"
  },
  {
    address: "0x3d088f32d7d83FD7868620f76C80604106b74702",
    chainId: 44787,
    name: "GeoNFT #1",
    symbol: "GEO1",
    decimals: 1,
    id: 1,
    logoURI: "https://gateway.pinata.cloud/ipfs/QmcRYtXPMK54EtwzPqP3Bs59x7oQzNN8X5X3oMZFHe1SBj/geo1.svg"
  },
  {
    address: "0x3d088f32d7d83FD7868620f76C80604106b74702",
    chainId: 44787,
    name: "GeoNFT #2",
    symbol: "GEO2",
    decimals: 1,
    id: 2,
    logoURI: "https://gateway.pinata.cloud/ipfs/QmcRYtXPMK54EtwzPqP3Bs59x7oQzNN8X5X3oMZFHe1SBj/geo1.svg"
  }
], bI = {
  name: hI,
  timestamp: pI,
  version: mI,
  keywords: yI,
  tokens: gI
};
var Vt = /* @__PURE__ */ ((n) => (n[n.minute = 0] = "minute", n[n.hour = 1] = "hour", n[n.day = 2] = "day", n))(Vt || {});
const nh = pe.createContainer().register(fe.instance(Ew, Hw({ ...uI, apiKey: globalThis.process.env.FIREBASE_API_KEY }))).register(fe.instance(Ap, {})).register(ro).register(no).register(fe.instance(vw, {})).register(fe.instance(xw, {})).register(fe.instance(Md, { lsGet: () => "", lsSet: () => "" })).register(Pc).register(ju).register(so).register(Gu).register(v9()).register(xd).register(Ic).register(aa).register(
  fe.instance(Tw, {
    tokens: bI.tokens
  })
).register(kc).register(fe.instance(Aa, { uf: (n) => Number(n) })).register(
  fe.instance(ma, {}),
  fe.instance(ud, {}),
  fe.instance(pa, {
    scopeTo: () => {
    }
  })
), xI = async () => {
  let n = !1;
  const e = 5, t = 1, r = 1;
  let i = "";
  const s = nh.get(Nw);
  let a = "", o = 0, c = 0, l = 0, f = 0, p = 0, g = 0, T = 0, v = 0, w = 0, C = 0, _, I = 0, B = 0, N = 0, D = 0, U = 0;
  const j = await nh.get(wp).connect(), q = Object.values(Vt).filter((A) => typeof A == "number").map((A) => A), ce = async (A) => {
    const P = e0(j, `chartData/lastSync/${A}`);
    return (await n0(P)).docs[0]?.id;
  }, re = async (A, P, R) => {
    R && await $6(uc(j, `chartData/lastSync/${A}/${R}`)), await r0(uc(j, `chartData/lastSync/${A}`, P.toString()), {});
  }, me = async (A, P, R, y) => {
    let u = y;
    typeof u != "object" && (u = { value: y }), u.createdAt = R, await r0(uc(j, `chartData/${A}/${P}`, R.toString()), u);
  }, S = async (A, P, R) => {
    const y = F6(j);
    (await n0(R6(e0(j, `chartData/${A}/${P}`), k6("createdAt", "<", R)))).forEach((b) => y.delete(b.ref)), await y.commit();
  }, d = async () => (await (await nh.get($w).getTreasuryContract()).totalValuation()).toHexString(), m = async () => {
    await s.loadAssets(), await s.loadkCur();
  }, x = (A) => {
    const P = new Date();
    switch (A) {
      case 0:
        P.setMinutes(P.getMinutes() - 60, 0, 0);
        break;
      case 1:
        P.setHours(P.getHours() - 24, 0, 0, 0);
        break;
      case 2:
        return Number.MIN_VALUE;
    }
    return P.getTime();
  }, E = async () => {
    i = await d(), await m(), a = s.reserveValue?.toHexString() ?? "", o = s.currentLeverageRatio, c = s.maxLeverageRatio, l = s.kCurPrice ?? 0, f = s.kCurPriceCeiling, p = s.kCurPriceFloor, g = s.kCurReserveDistribution ?? 0, T = s.kCurMentoDistribution ?? 0, v = s.kCurPrimaryPoolDistribution ?? 0, w = s.kCurCirculatingDistribution, I = s.minCollateralizationValue, B = s.kCurTotalValue, N = s.lowRiskAssets.map((A) => A.total).sum(), D = s.moderateRiskAssets.map((A) => A.total).sum(), U = s.highRiskAssets.map((A) => A.total).sum(), C = s.kGuilderValueRatio;
  };
  await Promise.all(
    q.map(async (A) => {
      const P = await ce(Vt[A]), R = new Date();
      let y = new Date();
      if (P && (y = new Date(Number(P))), A === 0 ? (y.setUTCMinutes(y.getUTCMinutes() + e), y.setUTCSeconds(0, 0)) : A === 1 ? (y.setUTCHours(y.getUTCHours() + t), y.setUTCMinutes(0, 0, 0)) : (y.setUTCDate(y.getUTCDate() + r), y.setUTCHours(0, 0, 0, 0)), R >= y || !P) {
        let u = new Date();
        if (A === 0) {
          const b = 6e4 * e;
          u = new Date(Math.floor(R.getTime() / b) * b);
        } else
          A === 1 ? u.setUTCMinutes(0, 0, 0) : u.setUTCHours(0, 0, 0, 0);
        n || (n = !0, _ = E()), _?.then(async () => {
          await me("kCurPrice", Vt[A], u.getTime(), { kCurPrice: l, kCurPriceCeiling: f, kCurPriceFloor: p }), await me("kCurRatio", Vt[A], u.getTime(), { currentLeverageRatio: o, maxLeverageRatio: c }), await me("kCurSupply", Vt[A], u.getTime(), {
            kCurReserveDistribution: g,
            kCurMentoDistribution: T,
            kCurPrimaryPoolDistribution: v,
            kCurCirculatingDistribution: w
          }), await me("ktt", Vt[A], u.getTime(), i), await me("reserve", Vt[A], u.getTime(), a), await me("risk", Vt[A], u.getTime(), {
            minCollateralValue: I,
            marketCap: B,
            lowRisk: N,
            moderateRisk: D,
            highRisk: U
          }), await me("kGuilder", Vt[A], u.getTime(), C), await re(Vt[A], u.getTime(), P);
          const b = x(A);
          await S("kCurPrice", Vt[A], b), await S("kCurRatio", Vt[A], b), await S("kCurSupply", Vt[A], b), await S("ktt", Vt[A], b), await S("reserve", Vt[A], b), await S("risk", Vt[A], b), await S("kGuilder", Vt[A], b);
        });
      }
    })
  );
};
await xI();

export {
  xI as seed
};
