function zn(n) {
  return typeof n == "object" && n !== null || typeof n == "function";
}
function nh(n) {
  return n == null;
}
let ju = /* @__PURE__ */ new WeakMap();
const bn = (n, e, t, i, r) => new TypeError(`${n}(${e.map(String).join(",")}) - Expected '${t}' to be of type ${r}, but got: ${Object.prototype.toString.call(i)} (${String(i)})`);
function Rs(n) {
  switch (typeof n) {
    case "undefined":
    case "string":
    case "symbol":
      return n;
    default:
      return `${n}`;
  }
}
function qw(n) {
  switch (typeof n) {
    case "string":
    case "symbol":
      return n;
    default:
      return `${n}`;
  }
}
function Hw(n) {
  switch (typeof n) {
    case "undefined":
    case "string":
    case "symbol":
      return n;
    default:
      throw new TypeError(`Invalid metadata propertyKey: ${n}.`);
  }
}
function Tl(n, e, t) {
  let i = ju.get(n);
  if (i === void 0) {
    if (!t)
      return;
    i = /* @__PURE__ */ new Map(), ju.set(n, i);
  }
  let r = i.get(e);
  if (r === void 0) {
    if (!t)
      return;
    r = /* @__PURE__ */ new Map(), i.set(e, r);
  }
  return r;
}
function ih(n, e, t) {
  const i = Tl(e, t, !1);
  return i === void 0 ? !1 : i.has(n);
}
function Kv(n, e, t) {
  if (ih(n, e, t))
    return !0;
  const i = rh(e);
  return i !== null ? Kv(n, i, t) : !1;
}
function Wv(n, e, t) {
  const i = Tl(e, t, !1);
  if (i !== void 0)
    return i.get(n);
}
function Jv(n, e, t) {
  if (ih(n, e, t))
    return Wv(n, e, t);
  const i = rh(e);
  if (i !== null)
    return Jv(n, i, t);
}
function Qv(n, e, t, i) {
  Tl(t, i, !0).set(n, e);
}
function Yv(n, e) {
  const t = [], i = Tl(n, e, !1);
  if (i === void 0)
    return t;
  const r = i.keys();
  let s = 0;
  for (const a of r)
    t[s] = a, ++s;
  return t;
}
function Xv(n, e) {
  const t = Yv(n, e), i = rh(n);
  if (i === null)
    return t;
  const r = Xv(i, e), s = t.length;
  if (s === 0)
    return r;
  const a = r.length;
  if (a === 0)
    return t;
  const o = /* @__PURE__ */ new Set(), u = [];
  let l = 0, p;
  for (let f = 0; f < s; ++f)
    p = t[f], o.has(p) || (o.add(p), u[l] = p, ++l);
  for (let f = 0; f < a; ++f)
    p = r[f], o.has(p) || (o.add(p), u[l] = p, ++l);
  return u;
}
function Kw(n, e, t) {
  const i = Tl(n, t, !1);
  return i === void 0 ? !1 : i.delete(e);
}
function Ww(n, e) {
  function t(i, r) {
    if (!zn(i))
      throw bn("@metadata", [n, e, i, r], "target", i, "Object or Function");
    Qv(n, e, i, Hw(r));
  }
  return t;
}
function Jw(n, e, t, i) {
  if (t !== void 0) {
    if (!Array.isArray(n))
      throw bn("Metadata.decorate", [n, e, t, i], "decorators", n, "Array");
    if (!zn(e))
      throw bn("Metadata.decorate", [n, e, t, i], "target", e, "Object or Function");
    if (!zn(i) && !nh(i))
      throw bn("Metadata.decorate", [n, e, t, i], "attributes", i, "Object, Function, null, or undefined");
    return i === null && (i = void 0), t = qw(t), Yw(n, e, t, i);
  } else {
    if (!Array.isArray(n))
      throw bn("Metadata.decorate", [n, e, t, i], "decorators", n, "Array");
    if (typeof e != "function")
      throw bn("Metadata.decorate", [n, e, t, i], "target", e, "Function");
    return Qw(n, e);
  }
}
function Qw(n, e) {
  for (let t = n.length - 1; t >= 0; --t) {
    const i = n[t], r = i(e);
    if (!nh(r)) {
      if (typeof r != "function")
        throw bn("DecorateConstructor", [n, e], "decorated", r, "Function, null, or undefined");
      e = r;
    }
  }
  return e;
}
function Yw(n, e, t, i) {
  for (let r = n.length - 1; r >= 0; --r) {
    const s = n[r], a = s(e, t, i);
    if (!nh(a)) {
      if (!zn(a))
        throw bn("DecorateProperty", [n, e, t, i], "decorated", a, "Object, Function, null, or undefined");
      i = a;
    }
  }
  return i;
}
function Zv(n, e, t, i) {
  if (!zn(t))
    throw bn("Metadata.define", [n, e, t, i], "target", t, "Object or Function");
  return Qv(n, e, t, Rs(i));
}
function ex(n, e, t) {
  if (!zn(e))
    throw bn("Metadata.has", [n, e, t], "target", e, "Object or Function");
  return Kv(n, e, Rs(t));
}
function tx(n, e, t) {
  if (!zn(e))
    throw bn("Metadata.hasOwn", [n, e, t], "target", e, "Object or Function");
  return ih(n, e, Rs(t));
}
function nx(n, e, t) {
  if (!zn(e))
    throw bn("Metadata.get", [n, e, t], "target", e, "Object or Function");
  return Jv(n, e, Rs(t));
}
function ix(n, e, t) {
  if (!zn(e))
    throw bn("Metadata.getOwn", [n, e, t], "target", e, "Object or Function");
  return Wv(n, e, Rs(t));
}
function rx(n, e) {
  if (!zn(n))
    throw bn("Metadata.getKeys", [n, e], "target", n, "Object or Function");
  return Xv(n, Rs(e));
}
function sx(n, e) {
  if (!zn(n))
    throw bn("Metadata.getOwnKeys", [n, e], "target", n, "Object or Function");
  return Yv(n, Rs(e));
}
function ax(n, e, t) {
  if (!zn(e))
    throw bn("Metadata.delete", [n, e, t], "target", e, "Object or Function");
  return Kw(e, n, Rs(t));
}
const lr = {
  define: Zv,
  has: ex,
  hasOwn: tx,
  get: nx,
  getOwn: ix,
  getKeys: rx,
  getOwnKeys: sx,
  delete: ax
}, Xw = (n, e, t, i, r) => {
  if (!Reflect.defineProperty(n, e, {
    writable: i,
    enumerable: !1,
    configurable: r,
    value: t
  }))
    throw qf(`AUR1000:${e}`);
}, xu = "[[$au]]", Zw = (n) => xu in n, fm = (n, e, t) => [[xu, ju], ["metadata", Ww], ["decorate", Jw], ["defineMetadata", Zv], ["hasMetadata", ex], ["hasOwnMetadata", tx], ["getMetadata", nx], ["getOwnMetadata", ix], ["getMetadataKeys", rx], ["getOwnMetadataKeys", sx], ["deleteMetadata", ax]].forEach(([i, r]) => Xw(n, i, r, e, t)), e3 = (n, e = !0, t = !1, i = !0, r = !0) => {
  if (Zw(n)) {
    if (n[xu] === ju)
      return;
    if (n[xu] instanceof WeakMap) {
      ju = n[xu];
      return;
    }
    throw qf("AUR1001");
  }
  const s = "metadata decorate defineMetadata hasMetadata hasOwnMetadata getMetadata getOwnMetadata getMetadataKeys getOwnMetadataKeys deleteMetadata".split(" ").filter((a) => a in Reflect);
  if (s.length > 0)
    if (e) {
      const a = s.map(function(o) {
        const u = `${Reflect[o].toString().slice(0, 100)}...`;
        return `${o}:
${u}`;
      }).join(`

`);
      throw qf(`AUR1002:${a}`);
    } else
      t && fm(n, i, r);
  else
    fm(n, i, r);
}, qf = (n) => new Error(n), rh = Object.getPrototypeOf, Bo = String, Vn = lr.getOwn, t3 = lr.hasOwn, ws = lr.define, Ir = (n) => typeof n == "function", Uc = (n) => typeof n == "string", _r = () => /* @__PURE__ */ Object.create(null), Kt = (n) => new Error(n), Yl = {}, zu = (n) => {
  switch (typeof n) {
    case "number":
      return n >= 0 && (0 | n) === n;
    case "string": {
      const e = Yl[n];
      if (e !== void 0)
        return e;
      const t = n.length;
      if (t === 0)
        return Yl[n] = !1;
      let i = 0, r = 0;
      for (; r < t; ++r)
        if (i = pn(n, r), r === 0 && i === 48 && t > 1 || i < 48 || i > 57)
          return Yl[n] = !1;
      return Yl[n] = !0;
    }
    default:
      return !1;
  }
}, ox = function() {
  const n = Object.assign(_r(), {
    0: !0,
    1: !0,
    2: !0,
    3: !0,
    4: !0,
    5: !0,
    6: !0,
    7: !0,
    8: !0,
    9: !0
  }), e = (t) => t === "" ? 0 : t !== t.toUpperCase() ? 3 : t !== t.toLowerCase() ? 2 : n[t] === !0 ? 1 : 0;
  return (t, i) => {
    const r = t.length;
    if (r === 0)
      return t;
    let s = !1, a = "", o, u = "", l = 0, p = t.charAt(0), f = e(p), b = 0;
    for (; b < r; ++b)
      o = l, u = p, l = f, p = t.charAt(b + 1), f = e(p), l === 0 ? a.length > 0 && (s = !0) : (!s && a.length > 0 && l === 2 && (s = o === 3 || f === 3), a += i(u, s), s = !1);
    return a;
  };
}(), ti = function() {
  const n = _r(), e = (t, i) => i ? t.toUpperCase() : t.toLowerCase();
  return (t) => {
    let i = n[t];
    return i === void 0 && (i = n[t] = ox(t, e)), i;
  };
}(), n3 = function() {
  const n = _r();
  return (e) => {
    let t = n[e];
    return t === void 0 && (t = ti(e), t.length > 0 && (t = t[0].toUpperCase() + t.slice(1)), n[e] = t), t;
  };
}(), ux = function() {
  const n = _r(), e = (t, i) => i ? `-${t.toLowerCase()}` : t.toLowerCase();
  return (t) => {
    let i = n[t];
    return i === void 0 && (i = n[t] = ox(t, e)), i;
  };
}(), Kp = (n) => {
  const e = n.length, t = Array(e);
  let i = 0;
  for (; i < e; ++i)
    t[i] = n[i];
  return t;
}, No = (n, e, t) => ({
  configurable: !0,
  enumerable: t.enumerable,
  get() {
    const i = t.value.bind(this);
    return Reflect.defineProperty(this, e, {
      value: i,
      writable: !0,
      configurable: !0,
      enumerable: t.enumerable
    }), i;
  }
}), $t = (...n) => {
  const e = [];
  let t = 0;
  const i = n.length;
  let r = 0, s, a = 0;
  for (; a < i; ++a)
    if (s = n[a], s !== void 0) {
      r = s.length;
      let o = 0;
      for (; o < r; ++o)
        e[t++] = s[o];
    }
  return e;
}, hn = (...n) => {
  const e = n.length;
  let t, i = 0;
  for (; e > i; ++i)
    if (t = n[i], t !== void 0)
      return t;
  throw Kt("No default value found");
}, lx = function() {
  const n = Function.prototype, e = Object.getPrototypeOf, t = /* @__PURE__ */ new WeakMap();
  let i = n, r = 0, s;
  return function(a) {
    if (s = t.get(a), s === void 0)
      for (t.set(a, s = [i = a]), r = 0; (i = e(i)) !== n; )
        s[++r] = i;
    return s;
  };
}();
function Gu(...n) {
  return Object.assign(_r(), ...n);
}
const ym = function() {
  const n = /* @__PURE__ */ new WeakMap();
  let e = !1, t = "", i = 0;
  return (r) => (e = n.get(r), e === void 0 && (t = r.toString(), i = t.length, e = i >= 29 && i <= 100 && pn(t, i - 1) === 125 && pn(t, i - 2) <= 32 && pn(t, i - 3) === 93 && pn(t, i - 4) === 101 && pn(t, i - 5) === 100 && pn(t, i - 6) === 111 && pn(t, i - 7) === 99 && pn(t, i - 8) === 32 && pn(t, i - 9) === 101 && pn(t, i - 10) === 118 && pn(t, i - 11) === 105 && pn(t, i - 12) === 116 && pn(t, i - 13) === 97 && pn(t, i - 14) === 110 && pn(t, i - 15) === 88, n.set(r, e)), e);
}(), _e = (n, e) => n instanceof Promise ? n.then(e) : e(n), Yt = (...n) => {
  let e, t, i, r = 0, s = n.length;
  for (; r < s; ++r)
    e = n[r], (e = n[r]) instanceof Promise && (t === void 0 ? t = e : i === void 0 ? i = [t, e] : i.push(e));
  return i === void 0 ? t : Promise.all(i);
}, pn = (n, e) => n.charCodeAt(e), ua = "au:annotation", Rr = (n, e) => e === void 0 ? `${ua}:${n}` : `${ua}:${n}:${e}`, sh = (n, e) => {
  const t = Vn(ua, n);
  t === void 0 ? ws(ua, [e], n) : t.push(e);
}, i3 = Object.freeze({
  name: "au:annotation",
  appendTo: sh,
  set(n, e, t) {
    ws(Rr(e), t, n);
  },
  get: (n, e) => Vn(Rr(e), n),
  getKeys(n) {
    let e = Vn(ua, n);
    return e === void 0 && ws(ua, e = [], n), e;
  },
  isKey: (n) => n.startsWith(ua),
  keyFor: Rr
}), ji = "au:resource", r3 = Object.freeze({
  name: ji,
  appendTo(n, e) {
    const t = Vn(ji, n);
    t === void 0 ? ws(ji, [e], n) : t.push(e);
  },
  has: (n) => t3(ji, n),
  getAll(n) {
    const e = Vn(ji, n);
    return e === void 0 ? Fe : e.map((t) => Vn(t, n));
  },
  getKeys(n) {
    let e = Vn(ji, n);
    return e === void 0 && ws(ji, e = [], n), e;
  },
  isKey: (n) => n.startsWith(ji),
  keyFor(n, e) {
    return e === void 0 ? `${ji}:${n}` : `${ji}:${n}:${e}`;
  }
}), Pi = {
  annotation: i3,
  resource: r3
}, cx = Object.prototype.hasOwnProperty;
function Ai(n, e, t, i) {
  let r = Vn(Rr(n), t);
  return r === void 0 ? (r = e[n], r === void 0 ? (r = t[n], r === void 0 || !cx.call(t, n) ? i() : r) : r) : r;
}
function si(n, e, t) {
  let i = Vn(Rr(n), e);
  return i === void 0 ? (i = e[n], i === void 0 || !cx.call(e, n) ? t() : i) : i;
}
function Nn(n, e, t) {
  const i = e[n];
  return i === void 0 ? t() : i;
}
const s3 = new Set("Array ArrayBuffer Boolean DataView Date Error EvalError Float32Array Float64Array Function Int8Array Int16Array Int32Array Map Number Object Promise RangeError ReferenceError RegExp Set SharedArrayBuffer String SyntaxError TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array URIError WeakMap WeakSet".split(" "));
let a3 = 0;
class Tu {
  get depth() {
    return this.parent === null ? 0 : this.parent.depth + 1;
  }
  constructor(e, t) {
    this.parent = e, this.config = t, this.id = ++a3, this.t = 0, this.i = /* @__PURE__ */ new Map(), e === null ? (this.root = this, this.u = /* @__PURE__ */ new Map(), this.h = /* @__PURE__ */ new Map(), this.res = _r()) : (this.root = e.root, this.u = /* @__PURE__ */ new Map(), this.h = e.h, t.inheritParentResources ? this.res = Object.assign(_r(), e.res, this.root.res) : this.res = _r()), this.u.set(Do, o3);
  }
  register(...e) {
    if (++this.t === 100)
      throw d3(e);
    let t, i, r, s, a, o = 0, u = e.length;
    for (; o < u; ++o)
      if (t = e[o], !!zn(t))
        if (vc(t))
          t.register(this);
        else if (Pi.resource.has(t)) {
          const l = Pi.resource.getAll(t);
          if (l.length === 1)
            l[0].register(this);
          else
            for (s = 0, a = l.length; a > s; )
              l[s].register(this), ++s;
        } else if (l3(t))
          fe.singleton(t, t).register(this);
        else
          for (i = Object.keys(t), s = 0, a = i.length; s < a; ++s)
            r = t[i[s]], zn(r) && (vc(r) ? r.register(this) : this.register(r));
    return --this.t, this;
  }
  registerResolver(e, t, i = !1) {
    Xl(e);
    const r = this.u, s = r.get(e);
    if (s == null) {
      if (r.set(e, t), c3(e)) {
        if (this.res[e] !== void 0)
          throw p3(e);
        this.res[e] = t;
      }
    } else
      s instanceof hi && s.R === 4 ? s._state.push(t) : r.set(e, new hi(e, 4, [s, t]));
    return i && this.i.set(e, t), t;
  }
  registerTransformer(e, t) {
    const i = this.getResolver(e);
    if (i == null)
      return !1;
    if (i.getFactory) {
      const r = i.getFactory(this);
      return r == null ? !1 : (r.registerTransformer(t), !0);
    }
    return !1;
  }
  getResolver(e, t = !0) {
    if (Xl(e), e.resolve !== void 0)
      return e;
    let i = this, r, s;
    for (; i != null; )
      if (r = i.u.get(e), r == null) {
        if (i.parent == null)
          return s = mm(e) ? this : i, t ? this.$(e, s) : null;
        i = i.parent;
      } else
        return r;
    return null;
  }
  has(e, t = !1) {
    return this.u.has(e) ? !0 : t && this.parent != null ? this.parent.has(e, !0) : !1;
  }
  get(e) {
    if (Xl(e), e.$isResolver)
      return e.resolve(this, this);
    let t = this, i, r;
    for (; t != null; )
      if (i = t.u.get(e), i == null) {
        if (t.parent == null)
          return r = mm(e) ? this : t, i = this.$(e, r), i.resolve(t, this);
        t = t.parent;
      } else
        return i.resolve(t, this);
    throw f3(e);
  }
  getAll(e, t = !1) {
    Xl(e);
    const i = this;
    let r = i, s;
    if (t) {
      let a = Fe;
      for (; r != null; )
        s = r.u.get(e), s != null && (a = a.concat(hm(s, r, i))), r = r.parent;
      return a;
    } else
      for (; r != null; )
        if (s = r.u.get(e), s == null) {
          if (r = r.parent, r == null)
            return Fe;
        } else
          return hm(s, r, i);
    return Fe;
  }
  invoke(e, t) {
    if (ym(e))
      throw gm(e);
    return t === void 0 ? new e(...wu(e).map(Vc, this)) : new e(...wu(e).map(Vc, this), ...t);
  }
  getFactory(e) {
    let t = this.h.get(e);
    if (t === void 0) {
      if (ym(e))
        throw gm(e);
      this.h.set(e, t = new D3(e, wu(e)));
    }
    return t;
  }
  registerFactory(e, t) {
    this.h.set(e, t);
  }
  createChild(e) {
    return e === void 0 && this.config.inheritParentResources ? this.config === Xi.DEFAULT ? new Tu(this, this.config) : new Tu(this, Xi.from({
      ...this.config,
      inheritParentResources: !1
    })) : new Tu(this, Xi.from(e ?? this.config));
  }
  disposeResolvers() {
    const e = this.u, t = this.i;
    let i, r;
    for ([r, i] of t.entries())
      i.dispose(), e.delete(r);
    t.clear();
  }
  find(e, t) {
    const i = e.keyFrom(t);
    let r = this.res[i];
    if (r === void 0 && (r = this.root.res[i], r === void 0) || r === null)
      return null;
    if (Ir(r.getFactory)) {
      const s = r.getFactory(this);
      if (s == null)
        return null;
      const a = Vn(e.name, s.Type);
      return a === void 0 ? null : a;
    }
    return null;
  }
  create(e, t) {
    const i = e.keyFrom(t);
    let r = this.res[i];
    return r === void 0 ? (r = this.root.res[i], r === void 0 ? null : r.resolve(this.root, this) ?? null) : r.resolve(this, this) ?? null;
  }
  dispose() {
    this.i.size > 0 && this.disposeResolvers(), this.u.clear();
  }
  $(e, t) {
    if (!Ir(e))
      throw y3(e);
    if (s3.has(e.name))
      throw h3(e);
    if (vc(e)) {
      const i = e.register(t, e);
      if (!(i instanceof Object) || i.resolve == null) {
        const r = t.u.get(e);
        if (r != null)
          return r;
        throw bm();
      }
      return i;
    } else if (Pi.resource.has(e)) {
      const i = Pi.resource.getAll(e);
      if (i.length === 1)
        i[0].register(t);
      else {
        const s = i.length;
        for (let a = 0; a < s; ++a)
          i[a].register(t);
      }
      const r = t.u.get(e);
      if (r != null)
        return r;
      throw bm();
    } else {
      if (e.$isInterface)
        throw m3(e.friendlyName);
      {
        const i = this.config.defaultResolver(e, t);
        return t.u.set(e, i), i;
      }
    }
  }
}
function Xl(n) {
  if (n == null)
    throw Kt("AUR0014");
}
const hm = (n, e, t) => {
  if (n instanceof hi && n.R === 4) {
    const i = n._state;
    let r = i.length;
    const s = new Array(r);
    for (; r--; )
      s[r] = i[r].resolve(e, t);
    return s;
  }
  return [n.resolve(e, t)];
}, o3 = {
  $isResolver: !0,
  resolve(n, e) {
    return e;
  }
}, vc = (n) => Ir(n.register), u3 = (n) => vc(n) && typeof n.registerInRequestor == "boolean", mm = (n) => u3(n) && n.registerInRequestor, l3 = (n) => n.prototype !== void 0, c3 = (n) => Uc(n) && n.indexOf(":") > 0, d3 = (n) => Kt(`AUR0006:${n.map(Bo)}`), p3 = (n) => Kt(`AUR0007:${Bo(n)}`), f3 = (n) => Kt(`AUR0008:${Bo(n)}`), y3 = (n) => Kt(`AUR0009:${Bo(n)}`), h3 = (n) => Kt(`AUR0010:${n.name}`), bm = () => Kt("AUR0011"), m3 = (n) => Kt(`AUR0012:${n}`), gm = (n) => Kt(`AUR0015:${n.name}`), dx = (n, e) => new hi(n, 0, e), ah = (n, e) => new hi(n, 1, e), b3 = (n, e) => new hi(n, 2, e), g3 = (n, e) => new hi(n, 3, e), v3 = (n, e) => new hi(n, 3, px(e)), x3 = (n, e) => new hi(e, 5, n), T3 = (n, ...e) => new $3(n, e), vm = /* @__PURE__ */ new WeakMap(), px = (n) => (e, t, i) => {
  let r = vm.get(e);
  if (r === void 0 && vm.set(e, r = /* @__PURE__ */ new WeakMap()), r.has(i))
    return r.get(i);
  const s = n(e, t, i);
  return r.set(i, s), s;
};
e3(Reflect, !1, !1);
class w3 {
  constructor(e, t) {
    this.c = e, this.k = t;
  }
  instance(e) {
    return this.C(0, e);
  }
  singleton(e) {
    return this.C(1, e);
  }
  transient(e) {
    return this.C(2, e);
  }
  callback(e) {
    return this.C(3, e);
  }
  cachedCallback(e) {
    return this.C(3, px(e));
  }
  aliasTo(e) {
    return this.C(5, e);
  }
  C(e, t) {
    const { c: i, k: r } = this;
    return this.c = this.k = void 0, i.registerResolver(r, new hi(r, e, t));
  }
}
const nu = (n) => {
  const e = n.slice(), t = Object.keys(n), i = t.length;
  let r;
  for (let s = 0; s < i; ++s)
    r = t[s], zu(r) || (e[r] = n[r]);
  return e;
}, A3 = {
  none(n) {
    throw E3(n);
  },
  singleton: (n) => new hi(n, 1, n),
  transient: (n) => new hi(n, 2, n)
}, E3 = (n) => Kt(`AUR0002:${Bo(n)}`);
class Xi {
  constructor(e, t) {
    this.inheritParentResources = e, this.defaultResolver = t;
  }
  static from(e) {
    return e === void 0 || e === Xi.DEFAULT ? Xi.DEFAULT : new Xi(e.inheritParentResources ?? !1, e.defaultResolver ?? A3.singleton);
  }
}
Xi.DEFAULT = Xi.from({});
const S3 = (n) => new Tu(null, Xi.from(n)), fx = (n) => {
  const e = Rr("di:paramtypes");
  return Vn(e, n);
}, M3 = (n) => Vn("design:paramtypes", n), Xa = (n) => {
  const e = Rr("di:paramtypes");
  let t = Vn(e, n);
  return t === void 0 && (ws(e, t = [], n), sh(n, e)), t;
}, wu = (n) => {
  const e = Rr("di:dependencies");
  let t = Vn(e, n);
  if (t === void 0) {
    const i = n.inject;
    if (i === void 0) {
      const r = ye.getDesignParamtypes(n), s = fx(n);
      if (r === void 0)
        if (s === void 0) {
          const a = Object.getPrototypeOf(n);
          Ir(a) && a !== Function.prototype ? t = nu(wu(a)) : t = [];
        } else
          t = nu(s);
      else if (s === void 0)
        t = nu(r);
      else {
        t = nu(r);
        let a = s.length, o, u = 0;
        for (; u < a; ++u)
          o = s[u], o !== void 0 && (t[u] = o);
        const l = Object.keys(s);
        let p;
        for (u = 0, a = l.length, u = 0; u < a; ++u)
          p = l[u], zu(p) || (t[p] = s[p]);
      }
    } else
      t = nu(i);
    ws(e, t, n), sh(n, e);
  }
  return t;
}, cr = (n, e) => {
  const t = Ir(n) ? n : e, i = Uc(n) ? n : void 0, r = function(s, a, o) {
    if (s == null || new.target !== void 0)
      throw C3(r.friendlyName);
    const u = Xa(s);
    u[o] = r;
  };
  return r.$isInterface = !0, r.friendlyName = i ?? "(anonymous)", t != null && (r.register = (s, a) => t(new w3(s, a ?? r))), r.toString = () => `InterfaceSymbol<${r.friendlyName}>`, r;
}, C3 = (n) => Kt(`AUR0001:${n}`), ye = {
  createContainer: S3,
  getDesignParamtypes: M3,
  getAnnotationParamtypes: fx,
  getOrCreateAnnotationParamTypes: Xa,
  getDependencies: wu,
  createInterface: cr,
  inject(...n) {
    return (e, t, i) => {
      if (typeof i == "number") {
        const r = Xa(e), s = n[0];
        s !== void 0 && (r[i] = s);
      } else if (t) {
        const r = Xa(e.constructor), s = n[0];
        s !== void 0 && (r[t] = s);
      } else if (i) {
        const r = i.value, s = Xa(r);
        let a, o = 0;
        for (; o < n.length; ++o)
          a = n[o], a !== void 0 && (s[o] = a);
      } else {
        const r = Xa(e);
        let s, a = 0;
        for (; a < n.length; ++a)
          s = n[a], s !== void 0 && (r[a] = s);
      }
    };
  },
  transient(n) {
    return n.register = function(e) {
      return fe.transient(n, n).register(e, n);
    }, n.registerInRequestor = !1, n;
  },
  singleton(n, e = k3) {
    return n.register = function(t) {
      return fe.singleton(n, n).register(t, n);
    }, n.registerInRequestor = e.scoped, n;
  }
}, Do = cr("IContainer"), _3 = Do;
function R3(n) {
  return function(e) {
    const t = function(i, r, s) {
      oh(t)(i, r, s);
    };
    return t.$isResolver = !0, t.resolve = function(i, r) {
      return n(e, i, r);
    }, t;
  };
}
const oh = ye.inject;
function xm(n) {
  return ye.transient(n);
}
function yx(n) {
  return n == null ? xm : xm(n);
}
const k3 = {
  scoped: !1
}, P3 = (n) => (e, t) => {
  t = !!t;
  const i = function(r, s, a) {
    oh(i)(r, s, a);
  };
  return i.$isResolver = !0, i.resolve = function(r, s) {
    return n(e, r, s, t);
  }, i;
}, hx = P3((n, e, t, i) => t.getAll(n, i)), mx = R3((n, e, t) => {
  if (t.has(n, !0))
    return t.get(n);
}), Hd = (n, e, t) => {
  oh(Hd)(n, e, t);
};
Hd.$isResolver = !0;
Hd.resolve = () => {
};
let hi = class {
  constructor(e, t, i) {
    this.k = e, this.R = t, this._state = i, this.resolving = !1;
  }
  get $isResolver() {
    return !0;
  }
  register(e, t) {
    return e.registerResolver(t || this.k, this);
  }
  resolve(e, t) {
    switch (this.R) {
      case 0:
        return this._state;
      case 1:
        if (this.resolving)
          throw I3(this._state.name);
        return this.resolving = !0, this._state = e.getFactory(this._state).construct(t), this.R = 0, this.resolving = !1, this._state;
      case 2: {
        const i = e.getFactory(this._state);
        if (i === null)
          throw O3(this.k);
        return i.construct(t);
      }
      case 3:
        return this._state(e, t, this);
      case 4:
        return this._state[0].resolve(e, t);
      case 5:
        return t.get(this._state);
      default:
        throw B3(this.R);
    }
  }
  getFactory(e) {
    switch (this.R) {
      case 1:
      case 2:
        return e.getFactory(this._state);
      case 5:
        return e.getResolver(this._state)?.getFactory?.(e) ?? null;
      default:
        return null;
    }
  }
};
const I3 = (n) => Kt(`AUR0003:${n}`), O3 = (n) => Kt(`AUR0004:${Bo(n)}`), B3 = (n) => Kt(`AUR0005:${n}`);
function Vc(n) {
  return this.get(n);
}
function N3(n, e) {
  return e(n);
}
class D3 {
  constructor(e, t) {
    this.Type = e, this.dependencies = t, this.transformers = null;
  }
  construct(e, t) {
    let i;
    return t === void 0 ? i = new this.Type(...this.dependencies.map(Vc, e)) : i = new this.Type(...this.dependencies.map(Vc, e), ...t), this.transformers == null ? i : this.transformers.reduce(N3, i);
  }
  registerTransformer(e) {
    (this.transformers ?? (this.transformers = [])).push(e);
  }
}
class $3 {
  constructor(e, t) {
    this.key = e, this.params = t;
  }
  register(e) {
    e.has(this.key, !0) ? e.get(this.key).register(e, ...this.params) : e.register(...this.params.filter((t) => typeof t == "object"));
  }
}
const fe = {
  instance: dx,
  singleton: ah,
  transient: b3,
  callback: g3,
  cachedCallback: v3,
  aliasTo: x3,
  defer: T3
};
class on {
  get friendlyName() {
    return this.A;
  }
  constructor(e, t) {
    this.j = null, this.A = e, t !== void 0 && (this.j = t);
  }
  prepare(e) {
    this.j = e;
  }
  get $isResolver() {
    return !0;
  }
  resolve() {
    if (this.j == null)
      throw F3(this.A);
    return this.j;
  }
  dispose() {
    this.j = null;
  }
}
const F3 = (n) => Kt(`AUR0013:${n}`), Fe = Object.freeze([]), L3 = Object.freeze({});
function kr() {
}
const wl = cr("IPlatform");
function zr(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (a = n[o]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}
function ra(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}
var Tm;
(function(n) {
  n[n.trace = 0] = "trace", n[n.debug = 1] = "debug", n[n.info = 2] = "info", n[n.warn = 3] = "warn", n[n.error = 4] = "error", n[n.fatal = 5] = "fatal", n[n.none = 6] = "none";
})(Tm || (Tm = {}));
var wm;
(function(n) {
  n[n.noColors = 0] = "noColors", n[n.colors = 1] = "colors";
})(wm || (wm = {}));
const uh = cr("ILogConfig", (n) => n.instance(new bx(0, 3))), lh = cr("ISink"), U3 = cr("ILogEventFactory", (n) => n.singleton(Hf)), Ra = cr("ILogger", (n) => n.singleton(Or)), V3 = cr("ILogScope"), j3 = Object.freeze({
  key: Rr("logger-sink-handles"),
  define(n, e) {
    return ws(this.key, e.handles, n.prototype), n;
  },
  getHandles(n) {
    return lr.get(this.key, n);
  }
}), br = Gu({
  red(n) {
    return `\x1B[31m${n}\x1B[39m`;
  },
  green(n) {
    return `\x1B[32m${n}\x1B[39m`;
  },
  yellow(n) {
    return `\x1B[33m${n}\x1B[39m`;
  },
  blue(n) {
    return `\x1B[34m${n}\x1B[39m`;
  },
  magenta(n) {
    return `\x1B[35m${n}\x1B[39m`;
  },
  cyan(n) {
    return `\x1B[36m${n}\x1B[39m`;
  },
  white(n) {
    return `\x1B[37m${n}\x1B[39m`;
  },
  grey(n) {
    return `\x1B[90m${n}\x1B[39m`;
  }
});
class bx {
  constructor(e, t) {
    this.colorOptions = e, this.level = t;
  }
}
const Am = function() {
  const n = [Gu({
    TRC: "TRC",
    DBG: "DBG",
    INF: "INF",
    WRN: "WRN",
    ERR: "ERR",
    FTL: "FTL",
    QQQ: "???"
  }), Gu({
    TRC: br.grey("TRC"),
    DBG: br.grey("DBG"),
    INF: br.white("INF"),
    WRN: br.yellow("WRN"),
    ERR: br.red("ERR"),
    FTL: br.red("FTL"),
    QQQ: br.grey("???")
  })];
  return (e, t) => e <= 0 ? n[t].TRC : e <= 1 ? n[t].DBG : e <= 2 ? n[t].INF : e <= 3 ? n[t].WRN : e <= 4 ? n[t].ERR : e <= 5 ? n[t].FTL : n[t].QQQ;
}(), z3 = (n, e) => e === 0 ? n.join(".") : n.map(br.cyan).join("."), Em = (n, e) => e === 0 ? new Date(n).toISOString() : br.grey(new Date(n).toISOString());
class G3 {
  constructor(e, t, i, r, s, a) {
    this.severity = e, this.message = t, this.optionalParams = i, this.scope = r, this.colorOptions = s, this.timestamp = a;
  }
  toString() {
    const { severity: e, message: t, scope: i, colorOptions: r, timestamp: s } = this;
    return i.length === 0 ? `${Em(s, r)} [${Am(e, r)}] ${t}` : `${Em(s, r)} [${Am(e, r)} ${z3(i, r)}] ${t}`;
  }
}
let Hf = class {
  constructor(e) {
    this.config = e;
  }
  createLogEvent(e, t, i, r) {
    return new G3(t, i, r, e.scope, this.config.colorOptions, Date.now());
  }
};
Hf = zr([ra(0, uh)], Hf);
let Sm = class gx {
  static register(e) {
    ah(lh, gx).register(e);
  }
  constructor(e) {
    const t = e.console;
    this.handleEvent = function(r) {
      const s = r.optionalParams;
      if (s === void 0 || s.length === 0) {
        const a = r.toString();
        switch (r.severity) {
          case 0:
          case 1:
            return t.debug(a);
          case 2:
            return t.info(a);
          case 3:
            return t.warn(a);
          case 4:
          case 5:
            return t.error(a);
        }
      } else {
        let a = r.toString(), o = 0;
        for (; a.includes("%s"); )
          a = a.replace("%s", String(s[o++]));
        switch (r.severity) {
          case 0:
          case 1:
            return t.debug(a, ...s.slice(o));
          case 2:
            return t.info(a, ...s.slice(o));
          case 3:
            return t.warn(a, ...s.slice(o));
          case 4:
          case 5:
            return t.error(a, ...s.slice(o));
        }
      }
    };
  }
};
Sm = zr([ra(0, wl)], Sm);
let Or = class vx {
  constructor(e, t, i, r = [], s = null) {
    this.scope = r, this.I = _r();
    let a, o, u, l, p, f;
    if (this.config = e, this.f = t, this.sinks = i, s === null) {
      this.root = this, this.parent = this, a = this.O = [], o = this.M = [], u = this.F = [], l = this.L = [], p = this.U = [], f = this.T = [];
      for (const b of i) {
        const A = j3.getHandles(b);
        (A?.includes(0) ?? !0) && a.push(b), (A?.includes(1) ?? !0) && o.push(b), (A?.includes(2) ?? !0) && u.push(b), (A?.includes(3) ?? !0) && l.push(b), (A?.includes(4) ?? !0) && p.push(b), (A?.includes(5) ?? !0) && f.push(b);
      }
    } else
      this.root = s.root, this.parent = s, a = this.O = s.O, o = this.M = s.M, u = this.F = s.F, l = this.L = s.L, p = this.U = s.U, f = this.T = s.T;
  }
  trace(e, ...t) {
    this.config.level <= 0 && this.P(this.O, 0, e, t);
  }
  debug(e, ...t) {
    this.config.level <= 1 && this.P(this.M, 1, e, t);
  }
  info(e, ...t) {
    this.config.level <= 2 && this.P(this.F, 2, e, t);
  }
  warn(e, ...t) {
    this.config.level <= 3 && this.P(this.L, 3, e, t);
  }
  error(e, ...t) {
    this.config.level <= 4 && this.P(this.U, 4, e, t);
  }
  fatal(e, ...t) {
    this.config.level <= 5 && this.P(this.T, 5, e, t);
  }
  scopeTo(e) {
    const t = this.I;
    let i = t[e];
    return i === void 0 && (i = t[e] = new vx(this.config, this.f, void 0, this.scope.concat(e), this)), i;
  }
  P(e, t, i, r) {
    const s = Ir(i) ? i() : i, a = this.f.createLogEvent(this, t, s, r);
    for (let o = 0, u = e.length; o < u; ++o)
      e[o].handleEvent(a);
  }
};
zr([No], Or.prototype, "trace", null);
zr([No], Or.prototype, "debug", null);
zr([No], Or.prototype, "info", null);
zr([No], Or.prototype, "warn", null);
zr([No], Or.prototype, "error", null);
zr([No], Or.prototype, "fatal", null);
Or = zr([ra(0, uh), ra(1, U3), ra(2, hx(lh)), ra(3, mx(V3)), ra(4, Hd)], Or);
Gu({
  create({ level: n = 3, colorOptions: e = 0, sinks: t = [] } = {}) {
    return Gu({
      register(i) {
        i.register(dx(uh, new bx(e, n)));
        for (const r of t)
          Ir(r) ? i.register(ah(lh, r)) : i.register(r);
        return i;
      }
    });
  }
});
cr((n) => n.singleton(K3));
const q3 = (n) => n;
class H3 {
  constructor(e) {
    this.N = /* @__PURE__ */ new Map(), this.W = /* @__PURE__ */ new Map(), this.B = e;
  }
  transform(e) {
    if (e instanceof Promise)
      return this._(e);
    if (typeof e == "object" && e !== null)
      return this.G(e);
    throw Kt(`Invalid input: ${String(e)}. Expected Promise or Object.`);
  }
  _(e) {
    if (this.N.has(e))
      return this.N.get(e);
    const t = e.then((i) => this.G(i));
    return this.N.set(e, t), t.then((i) => {
      this.N.set(e, i);
    }), t;
  }
  G(e) {
    if (this.W.has(e))
      return this.W.get(e);
    const t = this.B(this.K(e));
    return this.W.set(e, t), t instanceof Promise && t.then((i) => {
      this.W.set(e, i);
    }), t;
  }
  K(e) {
    if (e == null)
      throw new Error(`Invalid input: ${String(e)}. Expected Object.`);
    if (typeof e != "object")
      return new Mm(e, []);
    let t, i, r, s;
    const a = [];
    for (const o in e) {
      switch (typeof (t = e[o])) {
        case "object":
          if (t === null)
            continue;
          i = Ir(t.register), r = !1, s = Fe;
          break;
        case "function":
          i = Ir(t.register), r = t.prototype !== void 0, s = Pi.resource.getAll(t);
          break;
        default:
          continue;
      }
      a.push(new W3(o, t, i, r, s));
    }
    return new Mm(e, a);
  }
}
class K3 {
  constructor() {
    this.transformers = /* @__PURE__ */ new Map();
  }
  load(e, t = q3) {
    const i = this.transformers;
    let r = i.get(t);
    return r === void 0 && i.set(t, r = new H3(t)), r.transform(e);
  }
  dispose() {
    this.transformers.clear();
  }
}
class Mm {
  constructor(e, t) {
    this.raw = e, this.items = t;
  }
}
class W3 {
  constructor(e, t, i, r, s) {
    this.key = e, this.value = t, this.isRegistry = i, this.isConstructable = r, this.definitions = s;
  }
}
class J3 {
  constructor(e, t) {
    this.type = e, this.cb = t;
  }
  handle(e) {
    e instanceof this.type && this.cb.call(null, e);
  }
}
const Kd = cr("IEventAggregator", (n) => n.singleton(Q3));
class Q3 {
  constructor() {
    this.eventLookup = {}, this.messageHandlers = [];
  }
  publish(e, t) {
    if (!e)
      throw Kt(`Invalid channel name or instance: ${e}.`);
    if (Uc(e)) {
      let i = this.eventLookup[e];
      if (i !== void 0) {
        i = i.slice();
        let r = i.length;
        for (; r-- > 0; )
          i[r](t, e);
      }
    } else {
      const i = this.messageHandlers.slice();
      let r = i.length;
      for (; r-- > 0; )
        i[r].handle(e);
    }
  }
  subscribe(e, t) {
    if (!e)
      throw Kt(`Invalid channel name or type: ${e}.`);
    let i, r;
    return Uc(e) ? (this.eventLookup[e] === void 0 && (this.eventLookup[e] = []), i = t, r = this.eventLookup[e]) : (i = new J3(e, t), r = this.messageHandlers), r.push(i), {
      dispose() {
        const s = r.indexOf(i);
        s !== -1 && r.splice(s, 1);
      }
    };
  }
  subscribeOnce(e, t) {
    const i = this.subscribe(e, (r, s) => {
      i.dispose(), t(r, s);
    });
    return i;
  }
}
const Wd = Object, Y3 = Wd.prototype.hasOwnProperty, mi = Reflect.defineProperty, ae = (n) => new Error(n), di = (n) => typeof n == "function", Au = (n) => n instanceof Wd, As = (n) => n instanceof Array, Al = (n) => n instanceof Set, ms = (n) => n instanceof Map, ch = Wd.is;
function Br(n, e, t) {
  return mi(n, e, {
    enumerable: !1,
    configurable: !0,
    writable: !0,
    value: t
  }), t;
}
function Ar(n, e, t) {
  e in n || Br(n, e, t);
}
const El = String, $o = ye.createInterface, Eu = () => Wd.create(null), dh = lr.getOwn, ph = lr.define;
Pi.annotation.keyFor;
Pi.resource.keyFor;
Pi.resource.appendTo;
var Cm;
(function(n) {
  n[n.AccessThis = 0] = "AccessThis", n[n.AccessScope = 1] = "AccessScope", n[n.ArrayLiteral = 2] = "ArrayLiteral", n[n.ObjectLiteral = 3] = "ObjectLiteral", n[n.PrimitiveLiteral = 4] = "PrimitiveLiteral", n[n.Template = 5] = "Template", n[n.Unary = 6] = "Unary", n[n.CallScope = 7] = "CallScope", n[n.CallMember = 8] = "CallMember", n[n.CallFunction = 9] = "CallFunction", n[n.AccessMember = 10] = "AccessMember", n[n.AccessKeyed = 11] = "AccessKeyed", n[n.TaggedTemplate = 12] = "TaggedTemplate", n[n.Binary = 13] = "Binary", n[n.Conditional = 14] = "Conditional", n[n.Assign = 15] = "Assign", n[n.ArrowFunction = 16] = "ArrowFunction", n[n.ValueConverter = 17] = "ValueConverter", n[n.BindingBehavior = 18] = "BindingBehavior", n[n.ArrayBindingPattern = 19] = "ArrayBindingPattern", n[n.ObjectBindingPattern = 20] = "ObjectBindingPattern", n[n.BindingIdentifier = 21] = "BindingIdentifier", n[n.ForOfStatement = 22] = "ForOfStatement", n[n.Interpolation = 23] = "Interpolation", n[n.ArrayDestructuring = 24] = "ArrayDestructuring", n[n.ObjectDestructuring = 25] = "ObjectDestructuring", n[n.DestructuringAssignmentLeaf = 26] = "DestructuringAssignmentLeaf", n[n.DestructuringAssignmentRestLeaf = 27] = "DestructuringAssignmentRestLeaf", n[n.Custom = 28] = "Custom";
})(Cm || (Cm = {}));
class fh {
  constructor(e) {
    this.value = e, this.$kind = 28;
  }
  evaluate(e, t, i) {
    return this.value;
  }
  assign(e, t, i) {
    return i;
  }
  bind(e, t) {
  }
  unbind(e, t) {
  }
  accept(e) {
  }
}
class X3 {
  constructor(e, t, i) {
    this.expression = e, this.name = t, this.args = i, this.$kind = 18, this.key = `_bb_${t}`;
  }
}
class qu {
  constructor(e, t, i) {
    this.expression = e, this.name = t, this.args = i, this.$kind = 17;
  }
}
class Z3 {
  constructor(e, t) {
    this.target = e, this.value = t, this.$kind = 15;
  }
}
class eA {
  constructor(e, t, i) {
    this.condition = e, this.yes = t, this.no = i, this.$kind = 14;
  }
}
class Pr {
  constructor(e = 0) {
    this.ancestor = e, this.$kind = 0;
  }
}
Pr.$this = new Pr(0);
Pr.$parent = new Pr(1);
class xc {
  constructor(e, t = 0) {
    this.name = e, this.ancestor = t, this.$kind = 1;
  }
}
class Kf {
  constructor(e, t, i = !1) {
    this.object = e, this.name = t, this.optional = i, this.$kind = 10;
  }
}
class xx {
  constructor(e, t, i = !1) {
    this.object = e, this.key = t, this.optional = i, this.$kind = 11;
  }
}
class Tx {
  constructor(e, t, i = 0, r = !1) {
    this.name = e, this.args = t, this.ancestor = i, this.optional = r, this.$kind = 7;
  }
}
class jc {
  constructor(e, t, i, r = !1, s = !1) {
    this.object = e, this.name = t, this.args = i, this.optionalMember = r, this.optionalCall = s, this.$kind = 8;
  }
}
class Tc {
  constructor(e, t, i = !1) {
    this.func = e, this.args = t, this.optional = i, this.$kind = 9;
  }
}
class tA {
  constructor(e, t, i) {
    this.operation = e, this.left = t, this.right = i, this.$kind = 13;
  }
}
class nA {
  constructor(e, t) {
    this.operation = e, this.expression = t, this.$kind = 6;
  }
}
class un {
  constructor(e) {
    this.value = e, this.$kind = 4;
  }
}
un.$undefined = new un(void 0);
un.$null = new un(null);
un.$true = new un(!0);
un.$false = new un(!1);
un.$empty = new un("");
class Wf {
  constructor(e) {
    this.elements = e, this.$kind = 2;
  }
}
Wf.$empty = new Wf(Fe);
class Jf {
  constructor(e, t) {
    this.keys = e, this.values = t, this.$kind = 3;
  }
}
Jf.$empty = new Jf(Fe, Fe);
class zc {
  constructor(e, t = Fe) {
    this.cooked = e, this.expressions = t, this.$kind = 5;
  }
}
zc.$empty = new zc([""]);
class wx {
  constructor(e, t, i, r = Fe) {
    this.cooked = e, this.func = i, this.expressions = r, this.$kind = 12, e.raw = t;
  }
}
class iA {
  constructor(e) {
    this.elements = e, this.$kind = 19;
  }
}
class rA {
  constructor(e, t) {
    this.keys = e, this.values = t, this.$kind = 20;
  }
}
class Gc {
  constructor(e) {
    this.name = e, this.$kind = 21;
  }
}
class sA {
  constructor(e, t, i) {
    this.declaration = e, this.iterable = t, this.semiIdx = i, this.$kind = 22;
  }
}
class Ax {
  constructor(e, t = Fe) {
    this.parts = e, this.expressions = t, this.$kind = 23, this.isMulti = t.length > 1, this.firstExpression = t[0];
  }
}
class aA {
  constructor(e, t, i, r) {
    this.$kind = e, this.list = t, this.source = i, this.initializer = r;
  }
}
class Ex {
  constructor(e, t, i) {
    this.target = e, this.source = t, this.initializer = i, this.$kind = 26;
  }
}
class Qf {
  constructor(e, t, i = !1) {
    this.args = e, this.body = t, this.rest = i, this.$kind = 16;
  }
}
class _m {
  constructor(e, t) {
    e !== void 0 && (this[e] = t);
  }
}
class ln {
  constructor(e, t, i, r) {
    this.parent = e, this.bindingContext = t, this.overrideContext = i, this.isBoundary = r;
  }
  static getContext(e, t, i) {
    if (e == null)
      throw Rm();
    let r = e.overrideContext, s = e;
    if (i > 0) {
      for (; i > 0; )
        if (i--, s = s.parent, s == null)
          return;
      return r = s.overrideContext, t in r ? r : s.bindingContext;
    }
    for (; s != null && !s.isBoundary && !(t in s.overrideContext) && !(t in s.bindingContext); )
      s = s.parent;
    return s == null ? e.bindingContext : (r = s.overrideContext, t in r ? r : s.bindingContext);
  }
  static create(e, t, i) {
    if (e == null)
      throw oA();
    return new ln(null, e, t ?? new km(), i ?? !1);
  }
  static fromParent(e, t) {
    if (e == null)
      throw Rm();
    return new ln(e, t, new km(), !1);
  }
}
const Rm = () => ae("AUR0203"), oA = () => ae("AUR0204");
class km {
}
const Yf = ln.getContext;
function j(n, e, t, i) {
  switch (n.$kind) {
    case 0: {
      let r = e.overrideContext, s = e, a = n.ancestor;
      for (; a-- && r; )
        s = s.parent, r = s?.overrideContext ?? null;
      return a < 1 && s ? s.bindingContext : void 0;
    }
    case 1: {
      const r = Yf(e, n.name, n.ancestor);
      i !== null && i.observe(r, n.name);
      const s = r[n.name];
      if (s == null && n.name === "$host")
        throw ae("AUR0105");
      return t?.strict ? t?.boundFn && di(s) ? s.bind(r) : s : s == null ? "" : t?.boundFn && di(s) ? s.bind(r) : s;
    }
    case 2:
      return n.elements.map((r) => j(r, e, t, i));
    case 3: {
      const r = {};
      for (let s = 0; s < n.keys.length; ++s)
        r[n.keys[s]] = j(n.values[s], e, t, i);
      return r;
    }
    case 4:
      return n.value;
    case 5: {
      let r = n.cooked[0];
      for (let s = 0; s < n.expressions.length; ++s)
        r += String(j(n.expressions[s], e, t, i)), r += n.cooked[s + 1];
      return r;
    }
    case 6:
      switch (n.operation) {
        case "void":
          return void j(n.expression, e, t, i);
        case "typeof":
          return typeof j(n.expression, e, t, i);
        case "!":
          return !j(n.expression, e, t, i);
        case "-":
          return -j(n.expression, e, t, i);
        case "+":
          return +j(n.expression, e, t, i);
        default:
          throw ae(`AUR0109:${n.operation}`);
      }
    case 7: {
      const r = n.args.map((o) => j(o, e, t, i)), s = Yf(e, n.name, n.ancestor), a = Pm(t?.strictFnCall, s, n.name);
      return a ? a.apply(s, r) : void 0;
    }
    case 8: {
      const r = j(n.object, e, t, i), s = n.args.map((u) => j(u, e, t, i)), a = Pm(t?.strictFnCall, r, n.name);
      let o;
      return a && (o = a.apply(r, s), As(r) && cA.includes(n.name) && i?.observeCollection(r)), o;
    }
    case 9: {
      const r = j(n.func, e, t, i);
      if (di(r))
        return r(...n.args.map((s) => j(s, e, t, i)));
      if (!t?.strictFnCall && r == null)
        return;
      throw ae("AUR0107");
    }
    case 16:
      return (...s) => {
        const a = n.args, o = n.rest, u = a.length - 1, l = a.reduce((f, b, A) => (o && A === u ? f[b.name] = s.slice(A) : f[b.name] = s[A], f), {}), p = ln.fromParent(e, l);
        return j(n.body, p, t, i);
      };
    case 10: {
      const r = j(n.object, e, t, i);
      let s;
      return t?.strict ? r == null ? void 0 : (i !== null && i.observe(r, n.name), s = r[n.name], t?.boundFn && di(s) ? s.bind(r) : s) : (i !== null && Au(r) && i.observe(r, n.name), r ? (s = r[n.name], t?.boundFn && di(s) ? s.bind(r) : s) : "");
    }
    case 11: {
      const r = j(n.object, e, t, i), s = j(n.key, e, t, i);
      return Au(r) ? (i !== null && i.observe(r, s), r[s]) : r?.[s];
    }
    case 12: {
      const r = n.expressions.map((a) => j(a, e, t, i)), s = j(n.func, e, t, i);
      if (!di(s))
        throw ae("AUR0110");
      return s(n.cooked, ...r);
    }
    case 13: {
      const r = n.left, s = n.right;
      switch (n.operation) {
        case "&&":
          return j(r, e, t, i) && j(s, e, t, i);
        case "||":
          return j(r, e, t, i) || j(s, e, t, i);
        case "??":
          return j(r, e, t, i) ?? j(s, e, t, i);
        case "==":
          return j(r, e, t, i) == j(s, e, t, i);
        case "===":
          return j(r, e, t, i) === j(s, e, t, i);
        case "!=":
          return j(r, e, t, i) != j(s, e, t, i);
        case "!==":
          return j(r, e, t, i) !== j(s, e, t, i);
        case "instanceof": {
          const a = j(s, e, t, i);
          return di(a) ? j(r, e, t, i) instanceof a : !1;
        }
        case "in": {
          const a = j(s, e, t, i);
          return Au(a) ? j(r, e, t, i) in a : !1;
        }
        case "+": {
          const a = j(r, e, t, i), o = j(s, e, t, i);
          if (t?.strict)
            return a + o;
          if (!a || !o) {
            if (Im(a) || Im(o))
              return (a || 0) + (o || 0);
            if (Om(a) || Om(o))
              return (a || "") + (o || "");
          }
          return a + o;
        }
        case "-":
          return j(r, e, t, i) - j(s, e, t, i);
        case "*":
          return j(r, e, t, i) * j(s, e, t, i);
        case "/":
          return j(r, e, t, i) / j(s, e, t, i);
        case "%":
          return j(r, e, t, i) % j(s, e, t, i);
        case "<":
          return j(r, e, t, i) < j(s, e, t, i);
        case ">":
          return j(r, e, t, i) > j(s, e, t, i);
        case "<=":
          return j(r, e, t, i) <= j(s, e, t, i);
        case ">=":
          return j(r, e, t, i) >= j(s, e, t, i);
        default:
          throw ae(`AUR0108:${n.operation}`);
      }
    }
    case 14:
      return j(n.condition, e, t, i) ? j(n.yes, e, t, i) : j(n.no, e, t, i);
    case 15:
      return fn(n.target, e, t, j(n.value, e, t, i));
    case 17: {
      const r = t?.getConverter?.(n.name);
      if (r == null)
        throw ae(`AUR0103:${n.name}`);
      return "toView" in r ? r.toView(j(n.expression, e, t, i), ...n.args.map((s) => j(s, e, t, i))) : j(n.expression, e, t, i);
    }
    case 18:
      return j(n.expression, e, t, i);
    case 21:
      return n.name;
    case 22:
      return j(n.iterable, e, t, i);
    case 23:
      if (n.isMulti) {
        let r = n.parts[0], s = 0;
        for (; s < n.expressions.length; ++s)
          r += El(j(n.expressions[s], e, t, i)), r += n.parts[s + 1];
        return r;
      } else
        return `${n.parts[0]}${j(n.firstExpression, e, t, i)}${n.parts[1]}`;
    case 26:
      return j(n.target, e, t, i);
    case 24:
      return n.list.map((r) => j(r, e, t, i));
    case 19:
    case 20:
    case 25:
    default:
      return;
    case 28:
      return n.evaluate(e, t, i);
  }
}
function fn(n, e, t, i) {
  switch (n.$kind) {
    case 1: {
      if (n.name === "$host")
        throw ae("AUR0106");
      const r = Yf(e, n.name, n.ancestor);
      return r[n.name] = i;
    }
    case 10: {
      const r = j(n.object, e, t, null);
      return Au(r) ? n.name === "length" && As(r) && !isNaN(i) ? r.splice(i) : r[n.name] = i : fn(n.object, e, t, {
        [n.name]: i
      }), i;
    }
    case 11: {
      const r = j(n.object, e, t, null), s = j(n.key, e, t, null);
      if (As(r)) {
        if (s === "length" && !isNaN(i))
          return r.splice(i), i;
        if (zu(s))
          return r.splice(s, 1, i), i;
      }
      return r[s] = i;
    }
    case 15:
      return fn(n.value, e, t, i), fn(n.target, e, t, i);
    case 17: {
      const r = t?.getConverter?.(n.name);
      if (r == null)
        throw Sx(n.name);
      return "fromView" in r && (i = r.fromView(i, ...n.args.map((s) => j(s, e, t, null)))), fn(n.expression, e, t, i);
    }
    case 18:
      return fn(n.expression, e, t, i);
    case 24:
    case 25: {
      const r = n.list, s = r.length;
      let a, o;
      for (a = 0; a < s; a++)
        switch (o = r[a], o.$kind) {
          case 26:
            fn(o, e, t, i);
            break;
          case 24:
          case 25: {
            if (typeof i != "object" || i === null)
              throw ae("AUR0112");
            let u = j(o.source, ln.create(i), t, null);
            u === void 0 && o.initializer && (u = j(o.initializer, e, t, null)), fn(o, e, t, u);
            break;
          }
        }
      break;
    }
    case 26:
      if (n instanceof Ex) {
        if (i == null)
          return;
        if (typeof i != "object")
          throw ae("AUR0112");
        let r = j(n.source, ln.create(i), t, null);
        r === void 0 && n.initializer && (r = j(n.initializer, e, t, null)), fn(n.target, e, t, r);
      } else {
        if (i == null)
          return;
        if (typeof i != "object")
          throw ae("AUR0112");
        const r = n.indexOrProperties;
        let s;
        if (zu(r)) {
          if (!Array.isArray(i))
            throw ae("AUR0112");
          s = i.slice(r);
        } else
          s = Object.entries(i).reduce((a, [o, u]) => (r.includes(o) || (a[o] = u), a), {});
        fn(n.target, e, t, s);
      }
      break;
    case 28:
      return n.assign(e, t, i);
    default:
      return;
  }
}
function Ni(n, e, t) {
  switch (n.$kind) {
    case 18: {
      const i = n.name, r = n.key, s = t.getBehavior?.(i);
      if (s == null)
        throw uA(i);
      if (t[r] === void 0)
        t[r] = s, s.bind?.(e, t, ...n.args.map((a) => j(a, e, t, null)));
      else
        throw lA(i);
      Ni(n.expression, e, t);
      return;
    }
    case 17: {
      const i = n.name, r = t.getConverter?.(i);
      if (r == null)
        throw Sx(i);
      const s = r.signals;
      if (s != null) {
        const a = t.getSignaler?.(), o = s.length;
        let u = 0;
        for (; u < o; ++u)
          a?.addSignalListener(s[u], t);
      }
      Ni(n.expression, e, t);
      return;
    }
    case 22:
      Ni(n.iterable, e, t);
      break;
    case 28:
      n.bind?.(e, t);
  }
}
function fi(n, e, t) {
  switch (n.$kind) {
    case 18: {
      const i = n.key, r = t;
      r[i] !== void 0 && (r[i].unbind?.(e, t), r[i] = void 0), fi(n.expression, e, t);
      break;
    }
    case 17: {
      const i = t.getConverter?.(n.name);
      if (i?.signals === void 0)
        return;
      const r = t.getSignaler?.();
      let s = 0;
      for (; s < i.signals.length; ++s)
        r?.removeSignalListener(i.signals[s], t);
      fi(n.expression, e, t);
      break;
    }
    case 22:
      fi(n.iterable, e, t);
      break;
    case 28:
      n.unbind?.(e, t);
  }
}
const uA = (n) => ae(`AUR0101:${n}`), lA = (n) => ae(`AUR0102:${n}`), Sx = (n) => ae(`AUR0103:${n}`), Pm = (n, e, t) => {
  const i = e == null ? null : e[t];
  if (di(i))
    return i;
  if (!n && i == null)
    return null;
  throw ae(`AUR0111:${t}`);
}, Im = (n) => {
  switch (typeof n) {
    case "number":
    case "bigint":
      return !0;
    default:
      return !1;
  }
}, Om = (n) => {
  switch (typeof n) {
    case "string":
      return !0;
    case "object":
      return n instanceof Date;
    default:
      return !1;
  }
}, cA = "at map filter includes indexOf lastIndexOf findIndex find flat flatMap join reduce reduceRight slice every some sort".split(" "), Bm = ye.createInterface("ICoercionConfiguration");
var Nm;
(function(n) {
  n[n.indexed = 8] = "indexed", n[n.keyed = 4] = "keyed", n[n.array = 9] = "array", n[n.map = 6] = "map", n[n.set = 7] = "set";
})(Nm || (Nm = {}));
var Dm;
(function(n) {
  n[n.None = 0] = "None", n[n.Observer = 1] = "Observer", n[n.Node = 2] = "Node", n[n.Layout = 4] = "Layout", n[n.Primtive = 8] = "Primtive", n[n.Array = 18] = "Array", n[n.Set = 34] = "Set", n[n.Map = 66] = "Map";
})(Dm || (Dm = {}));
function pa(n = 0) {
  const e = Array(n);
  let t = 0;
  for (; t < n; )
    e[t] = t++;
  return e.deletedIndices = [], e.deletedItems = [], e.isIndexMap = !0, e;
}
function dA(n) {
  const e = n.slice();
  return e.deletedIndices = n.deletedIndices.slice(), e.deletedItems = n.deletedItems.slice(), e.isIndexMap = !0, e;
}
function In(n) {
  return n == null ? $m : $m(n);
}
function $m(n) {
  const e = n.prototype;
  mi(e, "subs", {
    get: fA
  }), Ar(e, "subscribe", yA), Ar(e, "unsubscribe", hA);
}
class pA {
  constructor() {
    this.count = 0, this.t = [];
  }
  add(e) {
    return this.t.includes(e) ? !1 : (this.t[this.t.length] = e, ++this.count, !0);
  }
  remove(e) {
    const t = this.t.indexOf(e);
    return t !== -1 ? (this.t.splice(t, 1), --this.count, !0) : !1;
  }
  notify(e, t) {
    const i = this.t.slice(0), r = i.length;
    let s = 0;
    for (; s < r; ++s)
      i[s].handleChange(e, t);
  }
  notifyCollection(e, t) {
    const i = this.t.slice(0), r = i.length;
    let s = 0;
    for (; s < r; ++s)
      i[s].handleCollectionChange(e, t);
  }
}
function fA() {
  return Br(this, "subs", new pA());
}
function yA(n) {
  return this.subs.add(n);
}
function hA(n) {
  return this.subs.remove(n);
}
class Mx {
  constructor(e) {
    this.owner = e, this.type = 18, this.v = (this.o = e.collection).length;
  }
  getValue() {
    return this.o.length;
  }
  setValue(e) {
    e !== this.v && (Number.isNaN(e) || (this.o.splice(e), this.v = this.o.length));
  }
  handleCollectionChange(e, t) {
    const i = this.v, r = this.o.length;
    (this.v = r) !== i && this.subs.notify(this.v, i);
  }
}
class yh {
  constructor(e) {
    this.owner = e, this.v = (this.o = e.collection).size, this.type = ms(this.o) ? 66 : 34;
  }
  getValue() {
    return this.o.size;
  }
  setValue() {
    throw ae("AUR02");
  }
  handleCollectionChange(e, t) {
    const i = this.v, r = this.o.size;
    (this.v = r) !== i && this.subs.notify(this.v, i);
  }
}
function Cx(n) {
  const e = n.prototype;
  Ar(e, "subscribe", mA), Ar(e, "unsubscribe", bA), In(n);
}
function mA(n) {
  this.subs.add(n) && this.subs.count === 1 && this.owner.subscribe(this);
}
function bA(n) {
  this.subs.remove(n) && this.subs.count === 0 && this.owner.subscribe(this);
}
Cx(Mx);
Cx(yh);
const Fm = Symbol.for("__au_arr_obs__"), gr = Array[Fm] ?? Br(Array, Fm, /* @__PURE__ */ new WeakMap());
function gA(n, e) {
  return n === e ? 0 : (n = n === null ? "null" : n.toString(), e = e === null ? "null" : e.toString(), n < e ? -1 : 1);
}
function vA(n, e) {
  return n === void 0 ? e === void 0 ? 0 : 1 : e === void 0 ? -1 : 0;
}
function xA(n, e, t, i, r) {
  let s, a, o, u, l, p, f;
  for (p = t + 1; p < i; p++) {
    for (s = n[p], a = e[p], f = p - 1; f >= t && (o = n[f], u = e[f], l = r(o, s), l > 0); f--)
      n[f + 1] = o, e[f + 1] = u;
    n[f + 1] = s, e[f + 1] = a;
  }
}
function qc(n, e, t, i, r) {
  let s = 0, a = 0, o, u, l, p, f, b, A, x, w, T, _, I, $, N, B, V, K, G, Y;
  for (; ; ) {
    if (i - t <= 10) {
      xA(n, e, t, i, r);
      return;
    }
    s = t + (i - t >> 1), o = n[t], p = e[t], u = n[i - 1], f = e[i - 1], l = n[s], b = e[s], A = r(o, u), A > 0 && (T = o, _ = p, o = u, p = f, u = T, f = _), x = r(o, l), x >= 0 ? (T = o, _ = p, o = l, p = b, l = u, b = f, u = T, f = _) : (w = r(u, l), w > 0 && (T = u, _ = f, u = l, f = b, l = T, b = _)), n[t] = o, e[t] = p, n[i - 1] = l, e[i - 1] = b, I = u, $ = f, N = t + 1, B = i - 1, n[s] = n[N], e[s] = e[N], n[N] = I, e[N] = $;
    e:
      for (a = N + 1; a < B; a++)
        if (V = n[a], K = e[a], G = r(V, I), G < 0)
          n[a] = n[N], e[a] = e[N], n[N] = V, e[N] = K, N++;
        else if (G > 0) {
          do {
            if (B--, B == a)
              break e;
            Y = n[B], G = r(Y, I);
          } while (G > 0);
          n[a] = n[B], e[a] = e[B], n[B] = V, e[B] = K, G < 0 && (V = n[a], K = e[a], n[a] = n[N], e[a] = e[N], n[N] = V, e[N] = K, N++);
        }
    i - B < N - t ? (qc(n, e, B, i, r), i = N) : (qc(n, e, t, N, r), t = B);
  }
}
const Nr = Array.prototype, TA = Nr.push, Wp = Nr.unshift, Jp = Nr.pop, Qp = Nr.shift, Zl = Nr.splice, wA = Nr.reverse, AA = Nr.sort, _x = ["push", "unshift", "pop", "shift", "splice", "reverse", "sort"], Rx = {
  push: function(...n) {
    const e = gr.get(this);
    if (e === void 0)
      return TA.apply(this, n);
    const t = this.length, i = n.length;
    if (i === 0)
      return t;
    this.length = e.indexMap.length = t + i;
    let r = t;
    for (; r < this.length; )
      this[r] = n[r - t], e.indexMap[r] = -2, r++;
    return e.notify(), this.length;
  },
  unshift: function(...n) {
    const e = gr.get(this);
    if (e === void 0)
      return Wp.apply(this, n);
    const t = n.length, i = new Array(t);
    let r = 0;
    for (; r < t; )
      i[r++] = -2;
    Wp.apply(e.indexMap, i);
    const s = Wp.apply(this, n);
    return e.notify(), s;
  },
  pop: function() {
    const n = gr.get(this);
    if (n === void 0)
      return Jp.call(this);
    const e = n.indexMap, t = Jp.call(this), i = e.length - 1;
    return e[i] > -1 && (e.deletedIndices.push(e[i]), e.deletedItems.push(t)), Jp.call(e), n.notify(), t;
  },
  shift: function() {
    const n = gr.get(this);
    if (n === void 0)
      return Qp.call(this);
    const e = n.indexMap, t = Qp.call(this);
    return e[0] > -1 && (e.deletedIndices.push(e[0]), e.deletedItems.push(t)), Qp.call(e), n.notify(), t;
  },
  splice: function(...n) {
    const e = n[0], t = n[1], i = gr.get(this);
    if (i === void 0)
      return Zl.apply(this, n);
    const r = this.length, s = 0 | e, a = s < 0 ? Math.max(r + s, 0) : Math.min(s, r), o = i.indexMap, u = n.length, l = u === 0 ? 0 : u === 1 ? r - a : t;
    let p = a;
    if (l > 0) {
      const b = p + l;
      for (; p < b; )
        o[p] > -1 && (o.deletedIndices.push(o[p]), o.deletedItems.push(this[p])), p++;
    }
    if (p = 0, u > 2) {
      const b = u - 2, A = new Array(b);
      for (; p < b; )
        A[p++] = -2;
      Zl.call(o, e, t, ...A);
    } else
      Zl.apply(o, n);
    const f = Zl.apply(this, n);
    return (l > 0 || p > 0) && i.notify(), f;
  },
  reverse: function() {
    const n = gr.get(this);
    if (n === void 0)
      return wA.call(this), this;
    const e = this.length, t = e / 2 | 0;
    let i = 0;
    for (; i !== t; ) {
      const r = e - i - 1, s = this[i], a = n.indexMap[i], o = this[r], u = n.indexMap[r];
      this[i] = o, n.indexMap[i] = u, this[r] = s, n.indexMap[r] = a, i++;
    }
    return n.notify(), this;
  },
  sort: function(n) {
    const e = gr.get(this);
    if (e === void 0)
      return AA.call(this, n), this;
    let t = this.length;
    if (t < 2)
      return this;
    qc(this, e.indexMap, 0, t, vA);
    let i = 0;
    for (; i < t && this[i] !== void 0; )
      i++;
    (n === void 0 || !di(n)) && (n = gA), qc(this, e.indexMap, 0, i, n);
    let r = !1;
    for (i = 0, t = e.indexMap.length; t > i; ++i)
      if (e.indexMap[i] !== i) {
        r = !0;
        break;
      }
    return r && e.notify(), this;
  }
};
for (const n of _x)
  mi(Rx[n], "observing", {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1
  });
let Lm = !1;
const Um = "__au_arr_on__";
function EA() {
  if (!(dh(Um, Array) ?? !1)) {
    ph(Um, !0, Array);
    for (const n of _x)
      Nr[n].observing !== !0 && Br(Nr, n, Rx[n]);
  }
}
class kx {
  constructor(e) {
    this.type = 18, Lm || (Lm = !0, EA()), this.indexObservers = {}, this.collection = e, this.indexMap = pa(e.length), this.lenObs = void 0, gr.set(e, this);
  }
  notify() {
    this.subs;
    const e = this.indexMap, t = this.collection, i = t.length;
    this.indexMap = pa(i), this.subs.notifyCollection(t, e);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new Mx(this));
  }
  getIndexObserver(e) {
    var t;
    return (t = this.indexObservers)[e] ?? (t[e] = new Px(this, e));
  }
}
class Px {
  constructor(e, t) {
    this.owner = e, this.index = t, this.doNotCache = !0, this.value = this.getValue();
  }
  getValue() {
    return this.owner.collection[this.index];
  }
  setValue(e) {
    if (e === this.getValue())
      return;
    const t = this.owner, i = this.index, r = t.indexMap;
    r[i] > -1 && r.deletedIndices.push(r[i]), r[i] = -2, t.collection[i] = e, t.notify();
  }
  handleCollectionChange(e, t) {
    const i = this.index;
    if (t[i] === i)
      return;
    const s = this.value, a = this.value = this.getValue();
    s !== a && this.subs.notify(a, s);
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && this.owner.subscribe(this);
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && this.owner.unsubscribe(this);
  }
}
In(kx);
In(Px);
function Su(n) {
  let e = gr.get(n);
  return e === void 0 && (e = new kx(n)), e;
}
const SA = (n, e) => n - e;
function MA(n) {
  let e = 0, t = 0, i = 0;
  const r = dA(n);
  r.deletedIndices.length > 1 && r.deletedIndices.sort(SA);
  const s = r.length;
  for (; i < s; ++i) {
    for (; r.deletedIndices[t] <= i - e; )
      ++t, --e;
    r[i] === -2 ? ++e : r[i] += e;
  }
  return r;
}
function CA(n, e) {
  const t = n.slice(), i = e.length;
  let r = 0, s = 0;
  for (; r < i; )
    s = e[r], s !== -2 && (n[r] = t[s]), ++r;
}
const Vm = Symbol.for("__au_set_obs__"), Mu = Set[Vm] ?? Br(Set, Vm, /* @__PURE__ */ new WeakMap()), Hu = Set.prototype, jm = Hu.add, zm = Hu.clear, Gm = Hu.delete, Ix = ["add", "clear", "delete"], Ox = {
  add: function(n) {
    const e = Mu.get(this);
    if (e === void 0)
      return jm.call(this, n), this;
    const t = this.size;
    return jm.call(this, n), this.size === t ? this : (e.indexMap[t] = -2, e.notify(), this);
  },
  clear: function() {
    const n = Mu.get(this);
    if (n === void 0)
      return zm.call(this);
    if (this.size > 0) {
      const t = n.indexMap;
      let i = 0;
      for (const r of this.keys())
        t[i] > -1 && (t.deletedIndices.push(t[i]), t.deletedItems.push(r)), i++;
      zm.call(this), t.length = 0, n.notify();
    }
  },
  delete: function(n) {
    const e = Mu.get(this);
    if (e === void 0)
      return Gm.call(this, n);
    if (this.size === 0)
      return !1;
    let i = 0;
    const r = e.indexMap;
    for (const s of this.keys()) {
      if (s === n) {
        r[i] > -1 && (r.deletedIndices.push(r[i]), r.deletedItems.push(s)), r.splice(i, 1);
        const a = Gm.call(this, n);
        return a === !0 && e.notify(), a;
      }
      i++;
    }
    return !1;
  }
}, _A = {
  writable: !0,
  enumerable: !1,
  configurable: !0
};
for (const n of Ix)
  mi(Ox[n], "observing", {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1
  });
let qm = !1;
const Hm = "__au_set_on__";
function RA() {
  if (!(dh(Hm, Set) ?? !1)) {
    ph(Hm, !0, Set);
    for (const n of Ix)
      Hu[n].observing !== !0 && mi(Hu, n, {
        ..._A,
        value: Ox[n]
      });
  }
}
class Bx {
  constructor(e) {
    this.type = 34, qm || (qm = !0, RA()), this.collection = e, this.indexMap = pa(e.size), this.lenObs = void 0, Mu.set(e, this);
  }
  notify() {
    this.subs;
    const e = this.indexMap, t = this.collection, i = t.size;
    this.indexMap = pa(i), this.subs.notifyCollection(t, e);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new yh(this));
  }
}
In(Bx);
function Hc(n) {
  let e = Mu.get(n);
  return e === void 0 && (e = new Bx(n)), e;
}
const Km = Symbol.for("__au_map_obs__"), Cu = Map[Km] ?? Br(Map, Km, /* @__PURE__ */ new WeakMap()), Ku = Map.prototype, Wm = Ku.set, Jm = Ku.clear, Qm = Ku.delete, Nx = ["set", "clear", "delete"], Dx = {
  set: function(n, e) {
    const t = Cu.get(this);
    if (t === void 0)
      return Wm.call(this, n, e), this;
    const i = this.get(n), r = this.size;
    if (Wm.call(this, n, e), this.size === r) {
      let a = 0;
      for (const o of this.entries()) {
        if (o[0] === n)
          return o[1] !== i && (t.indexMap.deletedIndices.push(t.indexMap[a]), t.indexMap.deletedItems.push(o), t.indexMap[a] = -2, t.notify()), this;
        a++;
      }
      return this;
    }
    return t.indexMap[r] = -2, t.notify(), this;
  },
  clear: function() {
    const n = Cu.get(this);
    if (n === void 0)
      return Jm.call(this);
    if (this.size > 0) {
      const t = n.indexMap;
      let i = 0;
      for (const r of this.keys())
        t[i] > -1 && (t.deletedIndices.push(t[i]), t.deletedItems.push(r)), i++;
      Jm.call(this), t.length = 0, n.notify();
    }
  },
  delete: function(n) {
    const e = Cu.get(this);
    if (e === void 0)
      return Qm.call(this, n);
    if (this.size === 0)
      return !1;
    let i = 0;
    const r = e.indexMap;
    for (const s of this.keys()) {
      if (s === n) {
        r[i] > -1 && (r.deletedIndices.push(r[i]), r.deletedItems.push(s)), r.splice(i, 1);
        const a = Qm.call(this, n);
        return a === !0 && e.notify(), a;
      }
      ++i;
    }
    return !1;
  }
}, kA = {
  writable: !0,
  enumerable: !1,
  configurable: !0
};
for (const n of Nx)
  mi(Dx[n], "observing", {
    value: !0,
    writable: !1,
    configurable: !1,
    enumerable: !1
  });
let Ym = !1;
const Xm = "__au_map_on__";
function PA() {
  if (!(dh(Xm, Map) ?? !1)) {
    ph(Xm, !0, Map);
    for (const n of Nx)
      Ku[n].observing !== !0 && mi(Ku, n, {
        ...kA,
        value: Dx[n]
      });
  }
}
class $x {
  constructor(e) {
    this.type = 66, Ym || (Ym = !0, PA()), this.collection = e, this.indexMap = pa(e.size), this.lenObs = void 0, Cu.set(e, this);
  }
  notify() {
    const e = this.subs, t = this.indexMap, i = this.collection, r = i.size;
    this.indexMap = pa(r), e.notifyCollection(i, t);
  }
  getLengthObserver() {
    return this.lenObs ?? (this.lenObs = new yh(this));
  }
}
In($x);
function Kc(n) {
  let e = Cu.get(n);
  return e === void 0 && (e = new $x(n)), e;
}
function IA() {
  return Br(this, "obs", new FA(this));
}
function OA(n, e) {
  this.obs.add(this.oL.getObserver(n, e));
}
function BA(n) {
  let e;
  if (As(n))
    e = Su(n);
  else if (Al(n))
    e = Hc(n);
  else if (ms(n))
    e = Kc(n);
  else
    throw ae("AUR0210");
  this.obs.add(e);
}
function NA(n) {
  this.obs.add(n);
}
function DA() {
  throw ae("AUR2011:handleChange");
}
function $A() {
  throw ae("AUR2011:handleCollectionChange");
}
class FA {
  constructor(e) {
    this.version = 0, this.count = 0, this.o = /* @__PURE__ */ new Map(), this.b = e;
  }
  add(e) {
    this.o.has(e) || (e.subscribe(this.b), ++this.count), this.o.set(e, this.version);
  }
  clear() {
    this.o.forEach(UA, this), this.count = this.o.size;
  }
  clearAll() {
    this.o.forEach(LA, this), this.o.clear(), this.count = 0;
  }
}
function LA(n, e) {
  e.unsubscribe(this.b);
}
function UA(n, e) {
  this.version !== n && (e.unsubscribe(this.b), this.o.delete(e));
}
function Zm(n) {
  const e = n.prototype;
  return Ar(e, "observe", OA), Ar(e, "observeCollection", BA), Ar(e, "subscribeTo", NA), mi(e, "obs", {
    get: IA
  }), Ar(e, "handleChange", DA), Ar(e, "handleCollectionChange", $A), n;
}
function Ui(n) {
  return n == null ? Zm : Zm(n);
}
const hh = $o("IExpressionParser", (n) => n.singleton(VA));
class VA {
  constructor() {
    this.i = Eu(), this.u = Eu(), this.h = Eu();
  }
  parse(e, t) {
    let i;
    switch (t) {
      case 32:
        return new fh(e);
      case 1:
        return i = this.h[e], i === void 0 && (i = this.h[e] = this.$parse(e, t)), i;
      case 2:
        return i = this.u[e], i === void 0 && (i = this.u[e] = this.$parse(e, t)), i;
      default:
        if (e.length === 0) {
          if ((t & 24) > 0)
            return un.$empty;
          throw r4();
        }
        return i = this.i[e], i === void 0 && (i = this.i[e] = this.$parse(e, t)), i;
    }
  }
  $parse(e, t) {
    return Re = e, Ee = 0, ir = e.length, Xn = 0, fa = 0, ee = 6291456, Ue = "", xt = ya(0), Pe = !0, Se = !1, bh = -1, Rt(61, t === void 0 ? 16 : t);
  }
}
function mh(n) {
  switch (n) {
    case 98:
      return 8;
    case 116:
      return 9;
    case 110:
      return 10;
    case 118:
      return 11;
    case 102:
      return 12;
    case 114:
      return 13;
    case 34:
      return 34;
    case 39:
      return 39;
    case 92:
      return 92;
    default:
      return n;
  }
}
const jA = un.$false, zA = un.$true, GA = un.$null, Fx = un.$undefined, _u = Pr.$this, Yp = Pr.$parent;
var eb;
(function(n) {
  n[n.None = 0] = "None", n[n.Interpolation = 1] = "Interpolation", n[n.IsIterator = 2] = "IsIterator", n[n.IsChainable = 4] = "IsChainable", n[n.IsFunction = 8] = "IsFunction", n[n.IsProperty = 16] = "IsProperty", n[n.IsCustom = 32] = "IsCustom";
})(eb || (eb = {}));
let Re = "", Ee = 0, ir = 0, Xn = 0, fa = 0, ee = 6291456, Ue = "", xt, Pe = !0, Se = !1, bh = -1;
const Wu = String.fromCharCode, ya = (n) => Re.charCodeAt(n), co = () => Re.slice(fa, Ee);
function Rt(n, e) {
  if (e === 32)
    return new fh(Re);
  if (Ee === 0) {
    if (1 & e)
      return YA();
    if (le(), 4194304 & ee)
      throw t4();
  }
  Pe = 513 > n, Se = !1;
  let t = !1, i, r = 0;
  if (131072 & ee) {
    const s = Ec[63 & ee];
    le(), i = new nA(s, Rt(514, e)), Pe = !1;
  } else {
    e:
      switch (ee) {
        case 12294:
          r = Xn, Pe = !1;
          do
            switch (le(), ++r, ee) {
              case 65545:
                if (le(), !(12288 & ee))
                  throw mr();
                break;
              case 10:
              case 11:
                throw mr();
              case 2162700:
                if (Se = !0, le(), !(12288 & ee)) {
                  i = r === 0 ? _u : r === 1 ? Yp : new Pr(r), t = !0;
                  break e;
                }
                break;
              default:
                if (2097152 & ee) {
                  i = r === 0 ? _u : r === 1 ? Yp : new Pr(r);
                  break e;
                }
                throw n4();
            }
          while (ee === 12294);
        case 4096: {
          const s = Ue;
          if (2 & e ? i = new Gc(s) : i = new xc(s, r), Pe = !Se, le(), Ci(50)) {
            if (ee === 524296)
              throw qx();
            const a = Se, o = Xn;
            ++Xn;
            const u = Rt(62, 0);
            Se = a, Xn = o, Pe = !1, i = new Qf([new Gc(s)], u);
          }
          break;
        }
        case 10:
          throw f4();
        case 11:
          throw Xf();
        case 12292:
          switch (Pe = !1, le(), Xn) {
            case 0:
              i = _u;
              break;
            case 1:
              i = Yp;
              break;
            default:
              i = new Pr(Xn);
              break;
          }
          break;
        case 2688007:
          i = KA(e);
          break;
        case 2688016:
          i = Re.search(/\s+of\s+/) > Ee ? qA() : WA(e);
          break;
        case 524296:
          i = QA(e);
          break;
        case 2163759:
          i = new zc([Ue]), Pe = !1, le();
          break;
        case 2163760:
          i = Xp(e, i, !1);
          break;
        case 16384:
        case 32768:
          i = new un(Ue), Pe = !1, le();
          break;
        case 8194:
        case 8195:
        case 8193:
        case 8192:
          i = Ec[63 & ee], Pe = !1, le();
          break;
        default:
          throw Ee >= ir ? i4() : Zp();
      }
    if (2 & e)
      return JA(i);
    if (514 < n)
      return i;
    if (ee === 10 || ee === 11)
      throw mr();
    if (i.$kind === 0)
      switch (ee) {
        case 2162700:
          if (Se = !0, Pe = !1, le(), !(13312 & ee))
            throw gh();
          if (12288 & ee)
            i = new xc(Ue, i.ancestor), le();
          else if (ee === 2688007)
            i = new Tc(i, Ki(), !0);
          else if (ee === 2688016)
            i = wc(i, !0);
          else
            throw Ac();
          break;
        case 65545:
          if (Pe = !Se, le(), !(12288 & ee))
            throw mr();
          i = new xc(Ue, i.ancestor), le();
          break;
        case 10:
        case 11:
          throw mr();
        case 2688007:
          i = new Tc(i, Ki(), t);
          break;
        case 2688016:
          i = wc(i, t);
          break;
        case 2163759:
          i = tb(i);
          break;
        case 2163760:
          i = Xp(e, i, !0);
          break;
      }
    for (; (65536 & ee) > 0; )
      switch (ee) {
        case 2162700:
          i = HA(i);
          break;
        case 65545:
          if (le(), !(12288 & ee))
            throw mr();
          i = Lx(i, !1);
          break;
        case 10:
        case 11:
          throw mr();
        case 2688007:
          i.$kind === 1 ? i = new Tx(i.name, Ki(), i.ancestor, !1) : i.$kind === 10 ? i = new jc(i.object, i.name, Ki(), i.optional, !1) : i = new Tc(i, Ki(), !1);
          break;
        case 2688016:
          i = wc(i, !1);
          break;
        case 2163759:
          if (Se)
            throw Ac();
          i = tb(i);
          break;
        case 2163760:
          if (Se)
            throw Ac();
          i = Xp(e, i, !0);
          break;
      }
  }
  if (ee === 10 || ee === 11)
    throw mr();
  if (513 < n)
    return i;
  for (; (262144 & ee) > 0; ) {
    const s = ee;
    if ((960 & s) <= n)
      break;
    le(), i = new tA(Ec[63 & s], i, Rt(960 & s, e)), Pe = !1;
  }
  if (63 < n)
    return i;
  if (Ci(6291478)) {
    const s = Rt(62, e);
    Di(6291476), i = new eA(i, s, Rt(62, e)), Pe = !1;
  }
  if (62 < n)
    return i;
  if (Ci(4194349)) {
    if (!Pe)
      throw s4();
    i = new Z3(i, Rt(62, e));
  }
  if (61 < n)
    return i;
  for (; Ci(6291480); ) {
    if (ee === 6291456)
      throw a4();
    const s = Ue;
    le();
    const a = new Array();
    for (; Ci(6291476); )
      a.push(Rt(62, e));
    i = new qu(i, s, a);
  }
  for (; Ci(6291479); ) {
    if (ee === 6291456)
      throw o4();
    const s = Ue;
    le();
    const a = new Array();
    for (; Ci(6291476); )
      a.push(Rt(62, e));
    i = new X3(i, s, a);
  }
  if (ee !== 6291456) {
    if ((1 & e) > 0 && ee === 7340045)
      return i;
    if ((4 & e) > 0 && ee === 6291477) {
      if (Ee === ir)
        throw Zp();
      return bh = Ee - 1, i;
    }
    throw co() === "of" ? u4() : Zp();
  }
  return i;
}
function qA() {
  const n = [], e = new aA(24, n, void 0, void 0);
  let t = "", i = !0, r = 0;
  for (; i; )
    switch (le(), ee) {
      case 7340051:
        i = !1, s();
        break;
      case 6291471:
        s();
        break;
      case 4096:
        t = co();
        break;
      default:
        throw d4();
    }
  return Di(7340051), e;
  function s() {
    t !== "" ? (n.push(new Ex(new Kf(_u, t), new xx(_u, new un(r++)), void 0)), t = "") : r++;
  }
}
function Ki() {
  const n = Se;
  le();
  const e = [];
  for (; ee !== 7340046 && (e.push(Rt(62, 0)), !!Ci(6291471)); )
    ;
  return Di(7340046), Pe = !1, Se = n, e;
}
function wc(n, e) {
  const t = Se;
  return le(), n = new xx(n, Rt(62, 0), e), Di(7340051), Pe = !t, Se = t, n;
}
function HA(n) {
  if (Se = !0, Pe = !1, le(), !(13312 & ee))
    throw gh();
  if (12288 & ee)
    return Lx(n, !0);
  if (ee === 2688007)
    return n.$kind === 1 ? new Tx(n.name, Ki(), n.ancestor, !0) : n.$kind === 10 ? new jc(n.object, n.name, Ki(), n.optional, !0) : new Tc(n, Ki(), !0);
  if (ee === 2688016)
    return wc(n, !0);
  throw Ac();
}
function Lx(n, e) {
  const t = Ue;
  switch (ee) {
    case 2162700: {
      Se = !0, Pe = !1;
      const i = Ee, r = fa, s = ee, a = xt, o = Ue, u = Pe, l = Se;
      if (le(), !(13312 & ee))
        throw gh();
      return ee === 2688007 ? new jc(n, t, Ki(), e, !0) : (Ee = i, fa = r, ee = s, xt = a, Ue = o, Pe = u, Se = l, new Kf(n, t, e));
    }
    case 2688007:
      return Pe = !1, new jc(n, t, Ki(), e, !1);
    default:
      return Pe = !Se, le(), new Kf(n, t, e);
  }
}
function KA(n) {
  le();
  const e = Ee, t = fa, i = ee, r = xt, s = Ue, a = Pe, o = Se, u = [];
  let l = 1, p = !1;
  e:
    for (; ; ) {
      if (ee === 11) {
        if (le(), ee !== 4096)
          throw mr();
        if (u.push(new Gc(Ue)), le(), ee === 6291471)
          throw p4();
        if (ee !== 7340046 || (le(), ee !== 50))
          throw Xf();
        le();
        const A = Se, x = Xn;
        ++Xn;
        const w = Rt(62, 0);
        return Se = A, Xn = x, Pe = !1, new Qf(u, w, !0);
      }
      switch (ee) {
        case 4096:
          u.push(new Gc(Ue)), le();
          break;
        case 7340046:
          le();
          break e;
        case 524296:
        case 2688016:
          le(), l = 4;
          break;
        case 6291471:
          l = 2, p = !0;
          break e;
        case 2688007:
          l = 2;
          break e;
        default:
          le(), l = 2;
          break;
      }
      switch (ee) {
        case 6291471:
          if (le(), p = !0, l === 1)
            break;
          break e;
        case 7340046:
          le();
          break e;
        case 4194349:
          l === 1 && (l = 3);
          break e;
        case 50:
          if (p)
            throw ec();
          le(), l = 2;
          break e;
        default:
          l === 1 && (l = 2);
          break e;
      }
    }
  if (ee === 50) {
    if (l === 1) {
      if (le(), ee === 524296)
        throw qx();
      const A = Se, x = Xn;
      ++Xn;
      const w = Rt(62, 0);
      return Se = A, Xn = x, Pe = !1, new Qf(u, w);
    }
    throw ec();
  } else if (l === 1 && u.length === 0)
    throw zx(50);
  if (p)
    switch (l) {
      case 2:
        throw ec();
      case 3:
        throw ib();
      case 4:
        throw rb();
    }
  Ee = e, fa = t, ee = i, xt = r, Ue = s, Pe = a, Se = o;
  const f = Se, b = Rt(62, n);
  if (Se = f, Di(7340046), ee === 50)
    switch (l) {
      case 2:
        throw ec();
      case 3:
        throw ib();
      case 4:
        throw rb();
    }
  return b;
}
function WA(n) {
  const e = Se;
  le();
  const t = new Array();
  for (; ee !== 7340051; )
    if (Ci(6291471)) {
      if (t.push(Fx), ee === 7340051)
        break;
    } else if (t.push(Rt(62, -3 & n)), Ci(6291471)) {
      if (ee === 7340051)
        break;
    } else
      break;
  return Se = e, Di(7340051), 2 & n ? new iA(t) : (Pe = !1, new Wf(t));
}
function JA(n) {
  if (!(n.$kind & 23) || ee !== 4204593)
    throw nb();
  le();
  const e = n, t = Rt(61, 4);
  return new sA(e, t, bh);
}
function QA(n) {
  const e = Se, t = new Array(), i = new Array();
  for (le(); ee !== 7340045; ) {
    if (t.push(Ue), 49152 & ee)
      le(), Di(6291476), i.push(Rt(62, -3 & n));
    else if (12288 & ee) {
      const r = xt, s = ee, a = Ee;
      le(), Ci(6291476) ? i.push(Rt(62, -3 & n)) : (xt = r, ee = s, Ee = a, i.push(Rt(515, -3 & n)));
    } else
      throw l4();
    ee !== 7340045 && Di(6291471);
  }
  return Se = e, Di(7340045), 2 & n ? new rA(t, i) : (Pe = !1, new Jf(t, i));
}
function YA() {
  const n = [], e = [], t = ir;
  let i = "";
  for (; Ee < t; ) {
    switch (xt) {
      case 36:
        if (ya(Ee + 1) === 123) {
          n.push(i), i = "", Ee += 2, xt = ya(Ee), le();
          const r = Rt(61, 1);
          e.push(r);
          continue;
        } else
          i += "$";
        break;
      case 92:
        i += Wu(mh(me()));
        break;
      default:
        i += Wu(xt);
    }
    me();
  }
  return e.length ? (n.push(i), new Ax(n, e)) : null;
}
function Xp(n, e, t) {
  const i = Se, r = [Ue];
  Di(2163760);
  const s = [Rt(62, n)];
  for (; (ee = e4()) !== 2163759; )
    r.push(Ue), Di(2163760), s.push(Rt(62, n));
  return r.push(Ue), Pe = !1, Se = i, t ? (le(), new wx(r, r, e, s)) : (le(), new zc(r, s));
}
function tb(n) {
  Pe = !1;
  const e = [Ue];
  return le(), new wx(e, e, n);
}
function le() {
  for (; Ee < ir; )
    if (fa = Ee, (ee = Oe[xt]()) != null)
      return;
  ee = 6291456;
}
function me() {
  return xt = ya(++Ee);
}
function XA() {
  for (; vh[me()]; )
    ;
  const n = y4[Ue = co()];
  return n === void 0 ? 4096 : n;
}
function Ux(n) {
  let e = xt;
  if (n === !1) {
    do
      e = me();
    while (e <= 57 && e >= 48);
    if (e !== 46)
      return Ue = parseInt(co(), 10), 32768;
    if (e = me(), Ee >= ir)
      return Ue = parseInt(co().slice(0, -1), 10), 32768;
  }
  if (e <= 57 && e >= 48)
    do
      e = me();
    while (e <= 57 && e >= 48);
  else
    xt = ya(--Ee);
  return Ue = parseFloat(co()), 32768;
}
function ZA() {
  const n = xt;
  me();
  let e = 0;
  const t = new Array();
  let i = Ee;
  for (; xt !== n; )
    if (xt === 92)
      t.push(Re.slice(i, Ee)), me(), e = mh(xt), me(), t.push(Wu(e)), i = Ee;
    else {
      if (Ee >= ir)
        throw c4();
      me();
    }
  const r = Re.slice(i, Ee);
  return me(), t.push(r), Ue = t.join(""), 16384;
}
function Vx() {
  let n = !0, e = "";
  for (; me() !== 96; )
    if (xt === 36)
      if (Ee + 1 < ir && ya(Ee + 1) === 123) {
        Ee++, n = !1;
        break;
      } else
        e += "$";
    else if (xt === 92)
      e += Wu(mh(me()));
    else {
      if (Ee >= ir)
        throw jx();
      e += Wu(xt);
    }
  return me(), Ue = e, n ? 2163759 : 2163760;
}
const e4 = () => {
  if (Ee >= ir)
    throw jx();
  return Ee--, Vx();
}, Ci = (n) => ee === n ? (le(), !0) : !1, Di = (n) => {
  if (ee === n)
    le();
  else
    throw zx(n);
}, t4 = () => ae(`AUR0151:${Re}`), Xf = () => ae(`AUR0152:${Re}`), mr = () => ae(`AUR0153:${Re}`), n4 = () => ae(`AUR0154:${Re}`), i4 = () => ae(`AUR0155:${Re}`), Zp = () => ae(`AUR0156:${Re}`), r4 = () => ae("AUR0157"), s4 = () => ae(`AUR0158:${Re}`), a4 = () => ae(`AUR0159:${Re}`), o4 = () => ae(`AUR0160:${Re}`), u4 = () => ae(`AUR0161:${Re}`), nb = () => ae(`AUR0163:${Re}`), l4 = () => ae(`AUR0164:${Re}`), c4 = () => ae(`AUR0165:${Re}`), jx = () => ae(`AUR0166:${Re}`), zx = (n) => ae(`AUR0167:${Re}<${Ec[63 & n]}`), Gx = () => {
  throw ae(`AUR0168:${Re}`);
};
Gx.notMapped = !0;
const d4 = () => ae(`AUR0170:${Re}`), gh = () => ae(`AUR0171:${Re}`), Ac = () => ae(`AUR0172:${Re}`), ec = () => ae(`AUR0173:${Re}`), ib = () => ae(`AUR0174:${Re}`), rb = () => ae(`AUR0175:${Re}`), p4 = () => ae(`AUR0176:${Re}`), qx = () => ae(`AUR0178:${Re}`), f4 = () => ae(`AUR0179:${Re}`), Ec = [jA, zA, GA, Fx, "$this", null, "$parent", "(", "{", ".", "..", "...", "?.", "}", ")", ",", "[", "]", ":", ";", "?", "'", '"', "&", "|", "??", "||", "&&", "==", "!=", "===", "!==", "<", ">", "<=", ">=", "in", "instanceof", "+", "-", "typeof", "void", "*", "%", "/", "=", "!", 2163759, 2163760, "of", "=>"], y4 = Object.assign(/* @__PURE__ */ Object.create(null), {
  true: 8193,
  null: 8194,
  false: 8192,
  undefined: 8195,
  $this: 12292,
  $parent: 12294,
  in: 6562212,
  instanceof: 6562213,
  typeof: 139304,
  void: 139305,
  of: 4204593
}), Fo = {
  AsciiIdPart: [36, 0, 48, 58, 65, 91, 95, 0, 97, 123],
  IdStart: [36, 0, 65, 91, 95, 0, 97, 123, 170, 0, 186, 0, 192, 215, 216, 247, 248, 697, 736, 741, 7424, 7462, 7468, 7517, 7522, 7526, 7531, 7544, 7545, 7615, 7680, 7936, 8305, 0, 8319, 0, 8336, 8349, 8490, 8492, 8498, 0, 8526, 0, 8544, 8585, 11360, 11392, 42786, 42888, 42891, 42927, 42928, 42936, 42999, 43008, 43824, 43867, 43868, 43877, 64256, 64263, 65313, 65339, 65345, 65371],
  Digit: [48, 58],
  Skip: [0, 33, 127, 161]
}, Lo = (n, e, t, i) => {
  const r = t.length;
  for (let s = 0; s < r; s += 2) {
    const a = t[s];
    let o = t[s + 1];
    if (o = o > 0 ? o : a + 1, n && n.fill(i, a, o), e)
      for (let u = a; u < o; u++)
        e.add(u);
  }
}, Hn = (n) => () => (me(), n), h4 = /* @__PURE__ */ new Set();
Lo(null, h4, Fo.AsciiIdPart, !0);
const vh = new Uint8Array(65535);
Lo(vh, null, Fo.IdStart, 1);
Lo(vh, null, Fo.Digit, 1);
const Oe = new Array(65535);
Oe.fill(Gx, 0, 65535);
Lo(Oe, null, Fo.Skip, () => (me(), null));
Lo(Oe, null, Fo.IdStart, XA);
Lo(Oe, null, Fo.Digit, () => Ux(!1));
Oe[34] = Oe[39] = () => ZA();
Oe[96] = () => Vx();
Oe[33] = () => me() !== 61 ? 131118 : me() !== 61 ? 6553949 : (me(), 6553951);
Oe[61] = () => me() === 62 ? (me(), 50) : xt !== 61 ? 4194349 : me() !== 61 ? 6553948 : (me(), 6553950);
Oe[38] = () => me() !== 38 ? 6291479 : (me(), 6553883);
Oe[124] = () => me() !== 124 ? 6291480 : (me(), 6553818);
Oe[63] = () => {
  if (me() === 46) {
    const n = ya(Ee + 1);
    return n <= 48 || n >= 57 ? (me(), 2162700) : 6291478;
  }
  return xt !== 63 ? 6291478 : (me(), 6553753);
};
Oe[46] = () => me() <= 57 && xt >= 48 ? Ux(!0) : xt === 46 ? me() !== 46 ? 10 : (me(), 11) : 65545;
Oe[60] = () => me() !== 61 ? 6554016 : (me(), 6554018);
Oe[62] = () => me() !== 61 ? 6554017 : (me(), 6554019);
Oe[37] = Hn(6554155);
Oe[40] = Hn(2688007);
Oe[41] = Hn(7340046);
Oe[42] = Hn(6554154);
Oe[43] = Hn(2490854);
Oe[44] = Hn(6291471);
Oe[45] = Hn(2490855);
Oe[47] = Hn(6554156);
Oe[58] = Hn(6291476);
Oe[59] = Hn(6291477);
Oe[91] = Hn(2688016);
Oe[93] = Hn(7340051);
Oe[123] = Hn(524296);
Oe[125] = Hn(7340045);
let ve = null;
const so = [];
let Dr = !1;
function m4() {
  Dr = !1;
}
function b4() {
  Dr = !0;
}
function xh() {
  return ve;
}
function Th(n) {
  if (n == null)
    throw ae("AUR0206");
  if (ve == null) {
    ve = n, so[0] = ve, Dr = !0;
    return;
  }
  if (ve === n)
    throw ae("AUR0207");
  so.push(n), ve = n, Dr = !0;
}
function wh(n) {
  if (n == null)
    throw ae("AUR0208");
  if (ve !== n)
    throw ae("AUR0209");
  so.pop(), ve = so.length > 0 ? so[so.length - 1] : null, Dr = ve != null;
}
const g4 = Object.freeze({
  get current() {
    return ve;
  },
  get connecting() {
    return Dr;
  },
  enter: Th,
  exit: wh,
  pause: m4,
  resume: b4
}), vo = Reflect.get, v4 = Object.prototype.toString, Hx = /* @__PURE__ */ new WeakMap(), Kx = "__au_nw__", Wx = "__au_nw";
function Jx(n) {
  switch (v4.call(n)) {
    case "[object Object]":
      return n.constructor[Kx] !== !0;
    case "[object Array]":
    case "[object Map]":
    case "[object Set]":
      return !0;
    default:
      return !1;
  }
}
const Uo = "__raw__";
function be(n) {
  return Jx(n) ? Jd(n) : n;
}
function Jd(n) {
  return Hx.get(n) ?? x4(n);
}
function Ce(n) {
  return n[Uo] ?? n;
}
function kn(n) {
  return Jx(n) && n[Uo] || n;
}
function Ah(n, e) {
  return e === "constructor" || e === "__proto__" || e === "$observers" || e === Symbol.toPrimitive || e === Symbol.toStringTag || n.constructor[`${Wx}_${El(e)}__`] === !0;
}
function x4(n) {
  const e = As(n) ? w4 : ms(n) || Al(n) ? q4 : T4, t = new Proxy(n, e);
  return Hx.set(n, t), t;
}
const T4 = {
  get(n, e, t) {
    if (e === Uo)
      return n;
    const i = xh();
    return !Dr || Ah(n, e) || i == null ? vo(n, e, t) : (i.observe(n, e), be(vo(n, e, t)));
  }
}, w4 = {
  get(n, e, t) {
    if (e === Uo)
      return n;
    if (!Dr || Ah(n, e) || ve == null)
      return vo(n, e, t);
    switch (e) {
      case "length":
        return ve.observe(n, "length"), n.length;
      case "map":
        return A4;
      case "includes":
        return M4;
      case "indexOf":
        return C4;
      case "lastIndexOf":
        return _4;
      case "every":
        return E4;
      case "filter":
        return S4;
      case "find":
        return k4;
      case "findIndex":
        return R4;
      case "flat":
        return P4;
      case "flatMap":
        return I4;
      case "join":
        return O4;
      case "push":
        return N4;
      case "pop":
        return B4;
      case "reduce":
        return z4;
      case "reduceRight":
        return G4;
      case "reverse":
        return L4;
      case "shift":
        return D4;
      case "unshift":
        return $4;
      case "slice":
        return j4;
      case "splice":
        return F4;
      case "some":
        return U4;
      case "sort":
        return V4;
      case "keys":
        return Qx;
      case "values":
      case Symbol.iterator:
        return Zf;
      case "entries":
        return ey;
    }
    return ve.observe(n, e), be(vo(n, e, t));
  },
  ownKeys(n) {
    return xh()?.observe(n, "length"), Reflect.ownKeys(n);
  }
};
function A4(n, e) {
  const t = Ce(this), i = t.map((r, s) => kn(n.call(e, be(r), s, this)));
  return Mt(ve, t), be(i);
}
function E4(n, e) {
  const t = Ce(this), i = t.every((r, s) => n.call(e, be(r), s, this));
  return Mt(ve, t), i;
}
function S4(n, e) {
  const t = Ce(this), i = t.filter((r, s) => kn(n.call(e, be(r), s, this)));
  return Mt(ve, t), be(i);
}
function M4(n) {
  const e = Ce(this), t = e.includes(kn(n));
  return Mt(ve, e), t;
}
function C4(n) {
  const e = Ce(this), t = e.indexOf(kn(n));
  return Mt(ve, e), t;
}
function _4(n) {
  const e = Ce(this), t = e.lastIndexOf(kn(n));
  return Mt(ve, e), t;
}
function R4(n, e) {
  const t = Ce(this), i = t.findIndex((r, s) => kn(n.call(e, be(r), s, this)));
  return Mt(ve, t), i;
}
function k4(n, e) {
  const t = Ce(this), i = t.find((r, s) => n(be(r), s, this), e);
  return Mt(ve, t), be(i);
}
function P4() {
  const n = Ce(this);
  return Mt(ve, n), be(n.flat());
}
function I4(n, e) {
  const t = Ce(this);
  return Mt(ve, t), Jd(t.flatMap((i, r) => be(n.call(e, be(i), r, this))));
}
function O4(n) {
  const e = Ce(this);
  return Mt(ve, e), e.join(n);
}
function B4() {
  return be(Ce(this).pop());
}
function N4(...n) {
  return Ce(this).push(...n);
}
function D4() {
  return be(Ce(this).shift());
}
function $4(...n) {
  return Ce(this).unshift(...n);
}
function F4(...n) {
  return be(Ce(this).splice(...n));
}
function L4(...n) {
  const e = Ce(this), t = e.reverse();
  return Mt(ve, e), be(t);
}
function U4(n, e) {
  const t = Ce(this), i = t.some((r, s) => kn(n.call(e, be(r), s, this)));
  return Mt(ve, t), i;
}
function V4(n) {
  const e = Ce(this), t = e.sort(n);
  return Mt(ve, e), be(t);
}
function j4(n, e) {
  const t = Ce(this);
  return Mt(ve, t), Jd(t.slice(n, e));
}
function z4(n, e) {
  const t = Ce(this), i = t.reduce((r, s, a) => n(r, be(s), a, this), e);
  return Mt(ve, t), be(i);
}
function G4(n, e) {
  const t = Ce(this), i = t.reduceRight((r, s, a) => n(r, be(s), a, this), e);
  return Mt(ve, t), be(i);
}
const q4 = {
  get(n, e, t) {
    if (e === Uo)
      return n;
    const i = xh();
    if (!Dr || Ah(n, e) || i == null)
      return vo(n, e, t);
    switch (e) {
      case "size":
        return i.observe(n, "size"), n.size;
      case "clear":
        return Y4;
      case "delete":
        return X4;
      case "forEach":
        return H4;
      case "add":
        if (Al(n))
          return Q4;
        break;
      case "get":
        if (ms(n))
          return W4;
        break;
      case "set":
        if (ms(n))
          return J4;
        break;
      case "has":
        return K4;
      case "keys":
        return Qx;
      case "values":
        return Zf;
      case "entries":
        return ey;
      case Symbol.iterator:
        return ms(n) ? ey : Zf;
    }
    return be(vo(n, e, t));
  }
};
function H4(n, e) {
  const t = Ce(this);
  return Mt(ve, t), t.forEach((i, r) => {
    n.call(e, be(i), be(r), this);
  });
}
function K4(n) {
  const e = Ce(this);
  return Mt(ve, e), e.has(kn(n));
}
function W4(n) {
  const e = Ce(this);
  return Mt(ve, e), be(e.get(kn(n)));
}
function J4(n, e) {
  return be(Ce(this).set(kn(n), kn(e)));
}
function Q4(n) {
  return be(Ce(this).add(kn(n)));
}
function Y4() {
  return be(Ce(this).clear());
}
function X4(n) {
  return be(Ce(this).delete(kn(n)));
}
function Qx() {
  const n = Ce(this);
  Mt(ve, n);
  const e = n.keys();
  return {
    next() {
      const t = e.next(), i = t.value, r = t.done;
      return r ? {
        value: void 0,
        done: r
      } : {
        value: be(i),
        done: r
      };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function Zf() {
  const n = Ce(this);
  Mt(ve, n);
  const e = n.values();
  return {
    next() {
      const t = e.next(), i = t.value, r = t.done;
      return r ? {
        value: void 0,
        done: r
      } : {
        value: be(i),
        done: r
      };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
function ey() {
  const n = Ce(this);
  Mt(ve, n);
  const e = n.entries();
  return {
    next() {
      const t = e.next(), i = t.value, r = t.done;
      return r ? {
        value: void 0,
        done: r
      } : {
        value: [be(i[0]), be(i[1])],
        done: r
      };
    },
    [Symbol.iterator]() {
      return this;
    }
  };
}
const Mt = (n, e) => n?.observeCollection(e), Z4 = Object.freeze({
  getProxy: Jd,
  getRaw: Ce,
  wrap: be,
  unwrap: kn,
  rawKey: Uo
});
class Sl {
  static create(e, t, i, r, s) {
    const a = i.get, o = i.set, u = new Sl(e, a, o, s, r), l = () => u.getValue();
    return l.getObserver = () => u, mi(e, t, {
      enumerable: i.enumerable,
      configurable: !0,
      get: l,
      set: (p) => {
        u.setValue(p);
      }
    }), u;
  }
  constructor(e, t, i, r, s) {
    this.type = 1, this.v = void 0, this.ov = void 0, this.ir = !1, this.D = !1, this.o = e, this.$get = t, this.$set = i, this.up = r, this.oL = s;
  }
  getValue() {
    return this.subs.count === 0 ? this.$get.call(this.o, this) : (this.D && (this.compute(), this.D = !1), this.v);
  }
  setValue(e) {
    if (di(this.$set))
      e !== this.v && (this.ir = !0, this.$set.call(this.o, e), this.ir = !1, this.run());
    else
      throw ae("AUR0221");
  }
  handleChange() {
    this.D = !0, this.subs.count > 0 && this.run();
  }
  handleCollectionChange() {
    this.D = !0, this.subs.count > 0 && this.run();
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.compute(), this.D = !1);
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && (this.D = !0, this.obs.clearAll());
  }
  run() {
    if (this.ir)
      return;
    const e = this.v, t = this.compute();
    this.D = !1, ch(t, e) || (this.ov = e, sb = this.ov, this.ov = this.v, this.subs.notify(this.v, sb));
  }
  compute() {
    this.ir = !0, this.obs.version++;
    try {
      return Th(this), this.v = kn(this.$get.call(this.up ? be(this.o) : this.o, this));
    } finally {
      this.obs.clear(), this.ir = !1, wh(this);
    }
  }
}
Ui(Sl);
In(Sl);
let sb;
const Yx = $o("IDirtyChecker", (n) => n.singleton(Xx)), e8 = {
  timeoutsPerCheck: 25,
  disabled: !1,
  throw: !1,
  resetToDefault() {
    this.timeoutsPerCheck = 6, this.disabled = !1, this.throw = !1;
  }
}, t8 = {
  persistent: !0
};
class Xx {
  constructor(e) {
    this.p = e, this.tracked = [], this.A = null, this.O = 0, this.check = () => {
      if (++this.O < e8.timeoutsPerCheck)
        return;
      this.O = 0;
      const t = this.tracked, i = t.length;
      let r, s = 0;
      for (; s < i; ++s)
        r = t[s], r.isDirty() && r.flush();
    };
  }
  createProperty(e, t) {
    return new Zx(this, e, t);
  }
  addProperty(e) {
    this.tracked.push(e), this.tracked.length === 1 && (this.A = this.p.taskQueue.queueTask(this.check, t8));
  }
  removeProperty(e) {
    this.tracked.splice(this.tracked.indexOf(e), 1), this.tracked.length === 0 && (this.A.cancel(), this.A = null);
  }
}
Xx.inject = [wl];
class Zx {
  constructor(e, t, i) {
    this.obj = t, this.key = i, this.type = 0, this.ov = void 0, this.C = e;
  }
  getValue() {
    return this.obj[this.key];
  }
  setValue(e) {
    throw ae(`Trying to set value for property ${El(this.key)} in dirty checker`);
  }
  isDirty() {
    return this.ov !== this.obj[this.key];
  }
  flush() {
    const e = this.ov, t = this.getValue();
    this.ov = t, this.subs.notify(t, e);
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.ov = this.obj[this.key], this.C.addProperty(this));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && this.C.removeProperty(this);
  }
}
In(Zx);
class n8 {
  get doNotCache() {
    return !0;
  }
  constructor(e, t) {
    this.type = 0, this.o = e, this.k = t;
  }
  getValue() {
    return this.o[this.k];
  }
  setValue() {
  }
  subscribe() {
  }
  unsubscribe() {
  }
}
class e1 {
  constructor() {
    this.type = 0;
  }
  getValue(e, t) {
    return e[t];
  }
  setValue(e, t, i) {
    t[i] = e;
  }
}
class Eh {
  constructor(e, t) {
    this.type = 1, this.v = void 0, this.iO = !1, this.o = e, this.k = t;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    if (this.iO) {
      if (ch(e, this.v))
        return;
      Wc = this.v, this.v = e, this.subs.notify(e, Wc);
    } else
      this.o[this.k] = e;
  }
  subscribe(e) {
    this.iO === !1 && this.start(), this.subs.add(e);
  }
  start() {
    return this.iO === !1 && (this.iO = !0, this.v = this.o[this.k], mi(this.o, this.k, {
      enumerable: !0,
      configurable: !0,
      get: () => this.getValue(),
      set: (e) => {
        this.setValue(e);
      }
    })), this;
  }
  stop() {
    return this.iO && (mi(this.o, this.k, {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: this.v
    }), this.iO = !1), this;
  }
}
class i8 {
  constructor(e, t, i, r) {
    this.type = 1, this.v = void 0, this.ov = void 0, this.o = e, this.S = i, this.hs = di(i);
    const s = e[t];
    this.cb = di(s) ? s : void 0, this.v = r;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.hs && (e = this.S(e, null)), ch(e, this.v) || (this.ov = this.v, this.v = e, this.cb?.call(this.o, this.v, this.ov), Wc = this.ov, this.ov = this.v, this.subs.notify(this.v, Wc));
  }
}
In(Eh);
In(i8);
let Wc;
const ty = new e1(), ka = $o("IObserverLocator", (n) => n.singleton(t1)), Jc = $o("INodeObserverLocator", (n) => n.cachedCallback((e) => new r8()));
class r8 {
  handles() {
    return !1;
  }
  getObserver() {
    return ty;
  }
  getAccessor() {
    return ty;
  }
}
class t1 {
  constructor(e, t) {
    this.$ = [], this.C = e, this.R = t;
  }
  addAdapter(e) {
    this.$.push(e);
  }
  getObserver(e, t) {
    if (e == null)
      throw a8(t);
    if (!Au(e))
      return new n8(e, t);
    const i = n1(e);
    let r = i[t];
    return r === void 0 && (r = this.createObserver(e, t), r.doNotCache || (i[t] = r)), r;
  }
  getAccessor(e, t) {
    const i = e.$observers?.[t];
    return i !== void 0 ? i : this.R.handles(e, t, this) ? this.R.getAccessor(e, t, this) : ty;
  }
  getArrayObserver(e) {
    return Su(e);
  }
  getMapObserver(e) {
    return Kc(e);
  }
  getSetObserver(e) {
    return Hc(e);
  }
  createObserver(e, t) {
    if (this.R.handles(e, t, this))
      return this.R.getObserver(e, t, this);
    switch (t) {
      case "length":
        if (As(e))
          return Su(e).getLengthObserver();
        break;
      case "size":
        if (ms(e))
          return Kc(e).getLengthObserver();
        if (Al(e))
          return Hc(e).getLengthObserver();
        break;
      default:
        if (As(e) && zu(t))
          return Su(e).getIndexObserver(Number(t));
        break;
    }
    let i = ob(e, t);
    if (i === void 0) {
      let r = ab(e);
      for (; r !== null && (i = ob(r, t), i === void 0); )
        r = ab(r);
    }
    if (i !== void 0 && !Y3.call(i, "value")) {
      let r = this.U(e, t, i);
      return r == null && (r = (i.get?.getObserver ?? i.set?.getObserver)?.(e, this)), r ?? (i.configurable ? Sl.create(e, t, i, this, !0) : this.C.createProperty(e, t));
    }
    return new Eh(e, t);
  }
  U(e, t, i) {
    if (this.$.length > 0)
      for (const r of this.$) {
        const s = r.getObserver(e, t, i, this);
        if (s != null)
          return s;
      }
    return null;
  }
}
t1.inject = [Yx, Jc];
const s8 = (n) => {
  let e;
  return As(n) ? e = Su(n) : ms(n) ? e = Kc(n) : Al(n) && (e = Hc(n)), e;
}, ab = Object.getPrototypeOf, ob = Object.getOwnPropertyDescriptor, n1 = (n) => {
  let e = n.$observers;
  return e === void 0 && mi(n, "$observers", {
    enumerable: !1,
    value: e = Eu()
  }), e;
}, a8 = (n) => ae(`AUR0199:${El(n)}`);
$o("IObservation", (n) => n.singleton(o8));
class o8 {
  static get inject() {
    return [ka];
  }
  constructor(e) {
    this.oL = e;
  }
  run(e) {
    const t = new i1(this.oL, e);
    return t.run(), t;
  }
}
class i1 {
  constructor(e, t) {
    this.oL = e, this.fn = t, this.maxRunCount = 10, this.queued = !1, this.running = !1, this.runCount = 0, this.stopped = !1;
  }
  handleChange() {
    this.queued = !0, this.run();
  }
  handleCollectionChange() {
    this.queued = !0, this.run();
  }
  run() {
    if (this.stopped)
      throw ae("AUR0225");
    if (!this.running) {
      ++this.runCount, this.running = !0, this.queued = !1, ++this.obs.version;
      try {
        Th(this), this.fn(this);
      } finally {
        this.obs.clear(), this.running = !1, wh(this);
      }
      if (this.queued) {
        if (this.runCount > this.maxRunCount)
          throw this.runCount = 0, ae("AUR0226");
        this.run();
      } else
        this.runCount = 0;
    }
  }
  stop() {
    this.stopped = !0, this.obs.clearAll();
  }
}
Ui(i1);
function u8(n, e) {
  if (n == null)
    return (i, r) => t(i, r);
  return t(n, e);
  function t(i, r) {
    !r ? Br(i, Kx, !0) : Br(i.constructor, `${Wx}_${El(r)}__`, !0);
  }
}
const Sh = $o("ISignaler", (n) => n.singleton(l8));
class l8 {
  constructor() {
    this.signals = Eu();
  }
  dispatchSignal(e) {
    const t = this.signals[e];
    if (t === void 0)
      return;
    let i;
    for (i of t.keys())
      i.handleChange(void 0, void 0);
  }
  addSignalListener(e, t) {
    const i = this.signals, r = i[e];
    r === void 0 ? i[e] = /* @__PURE__ */ new Set([t]) : r.add(t);
  }
  removeSignalListener(e, t) {
    this.signals[e]?.delete(t);
  }
}
class c8 extends Error {
  constructor(e) {
    super("Task was canceled."), this.task = e;
  }
}
var ub;
(function(n) {
  n[n.pending = 0] = "pending", n[n.running = 1] = "running", n[n.completed = 2] = "completed", n[n.canceled = 3] = "canceled";
})(ub || (ub = {}));
var lb;
(function(n) {
  n[n.render = 0] = "render", n[n.macroTask = 1] = "macroTask", n[n.postRender = 2] = "postRender";
})(lb || (lb = {}));
function X(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (a = n[o]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}
function xn(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}
const wn = lr.getOwn, Ml = lr.hasOwn, kt = lr.define, { annotation: Mh, resource: r1 } = Pi, An = Mh.keyFor, Pa = r1.keyFor, Ia = r1.appendTo, Ch = Mh.appendTo, s1 = Mh.getKeys, ks = Object, _h = ks.prototype, yn = () => ks.create(null), re = (n) => new Error(n), bs = _h.hasOwnProperty, dr = ks.freeze, Rh = ks.assign, kh = ks.getOwnPropertyNames, Ph = ks.keys, cb = yn(), ny = (n, e, t) => {
  if (cb[e] === !0)
    return !0;
  if (!wt(e))
    return !1;
  const i = e.slice(0, 5);
  return cb[e] = i === "aria-" || i === "data-" || t.isStandardSvgAttribute(n, e);
}, an = (n) => n instanceof Promise, Fi = (n) => n instanceof Array, ei = (n) => typeof n == "function", wt = (n) => typeof n == "string", d8 = ks.defineProperty, Qc = (n) => {
  throw n;
}, Cl = ks.is, iy = Reflect.defineProperty, Ii = (n, e, t) => (iy(n, e, {
  enumerable: !1,
  configurable: !0,
  writable: !0,
  value: t
}), t);
function Le(n, e) {
  let t;
  function i(r, s) {
    arguments.length > 1 && (t.property = s), kt(us, ds.create(s, r, t), r.constructor, s), Ch(r.constructor, Er.keyFrom(s));
  }
  if (arguments.length > 1) {
    t = {}, i(n, e);
    return;
  } else if (wt(n))
    return t = {}, i;
  return t = n === void 0 ? {} : n, i;
}
function p8(n) {
  return n.startsWith(us);
}
const us = An("bindable"), Er = dr({
  name: us,
  keyFrom: (n) => `${us}:${n}`,
  from(n, ...e) {
    const t = {}, i = Array.isArray;
    function r(o) {
      t[o] = ds.create(o, n);
    }
    function s(o, u) {
      t[o] = u instanceof ds ? u : ds.create(o, n, u);
    }
    function a(o) {
      i(o) ? o.forEach(r) : o instanceof ds ? t[o.property] = o : o !== void 0 && Ph(o).forEach((u) => s(u, o[u]));
    }
    return e.forEach(a), t;
  },
  for(n) {
    let e;
    const t = {
      add(i) {
        let r, s;
        return wt(i) ? (r = i, s = {
          property: r
        }) : (r = i.property, s = i), e = ds.create(r, n, s), Ml(us, n, r) || Ch(n, Er.keyFrom(r)), kt(us, e, n, r), t;
      },
      mode(i) {
        return e.mode = i, t;
      },
      callback(i) {
        return e.callback = i, t;
      },
      attribute(i) {
        return e.attribute = i, t;
      },
      primary() {
        return e.primary = !0, t;
      },
      set(i) {
        return e.set = i, t;
      }
    };
    return t;
  },
  getAll(n) {
    const e = us.length + 1, t = [], i = lx(n);
    let r = i.length, s = 0, a, o, u, l;
    for (; --r >= 0; )
      for (u = i[r], a = s1(u).filter(p8), o = a.length, l = 0; l < o; ++l)
        t[s++] = wn(us, u, a[l].slice(e));
    return t;
  }
});
class ds {
  constructor(e, t, i, r, s, a) {
    this.attribute = e, this.callback = t, this.mode = i, this.primary = r, this.property = s, this.set = a;
  }
  static create(e, t, i = {}) {
    return new ds(hn(i.attribute, ux(e)), hn(i.callback, `${e}Changed`), hn(i.mode, 2), hn(i.primary, !1), hn(i.property, e), hn(i.set, f8(e, t, i)));
  }
}
const ry = {
  key: An("coercer"),
  define(n, e) {
    kt(ry.key, n[e].bind(n), n);
  },
  for(n) {
    return wn(ry.key, n);
  }
};
function f8(n, e, t = {}) {
  const i = t.type ?? lr.get("design:type", e, n) ?? null;
  if (i == null)
    return kr;
  let r;
  switch (i) {
    case Number:
    case Boolean:
    case String:
    case BigInt:
      r = i;
      break;
    default: {
      const s = i.coerce;
      r = typeof s == "function" ? s.bind(i) : ry.for(i) ?? kr;
      break;
    }
  }
  return r === kr ? r : y8(r, t.nullable);
}
function y8(n, e) {
  return function(t, i) {
    return i?.enableCoercion ? (e ?? !(i?.coerceNullish ?? !1)) && t == null ? t : n(t, i) : t;
  };
}
class a1 {
  get type() {
    return 1;
  }
  constructor(e, t, i, r, s, a) {
    this.set = r, this.$controller = s, this.i = a, this.v = void 0, this.ov = void 0;
    const o = e[i], u = e.propertyChanged, l = this.u = ei(o), p = this.A = ei(u), f = this.hs = r !== kr;
    let b;
    this.o = e, this.k = t, this.C = p ? u : kr, this.cb = l ? o : kr, this.cb === void 0 && !p && !f ? this.iO = !1 : (this.iO = !0, b = e[t], this.v = f && b !== void 0 ? r(b, this.i) : b, this.B());
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.hs && (e = this.set(e, this.i));
    const t = this.v;
    if (this.iO) {
      if (Cl(e, t))
        return;
      this.v = e, this.ov = t, (this.$controller == null || this.$controller.isBound) && (this.u && this.cb.call(this.o, e, t), this.A && this.C.call(this.o, this.k, e, t)), this.subs.notify(this.v, this.ov);
    } else
      this.o[this.k] = e;
  }
  subscribe(e) {
    this.iO && (this.iO = !0, this.v = this.hs ? this.set(this.o[this.k], this.i) : this.o[this.k], this.B()), this.subs.add(e);
  }
  B() {
    Reflect.defineProperty(this.o, this.k, {
      enumerable: !0,
      configurable: !0,
      get: () => this.v,
      set: (e) => {
        this.setValue(e);
      }
    });
  }
}
In(a1);
const db = function(n) {
  function e(t, i, r) {
    ye.inject(e)(t, i, r);
  }
  return e.$isResolver = !0, e.resolve = function(t, i) {
    return i.root === i || i.has(n, !1) ? i.get(n) : i.root.get(n);
  }, e;
}, ke = ye.createInterface, Vo = fe.singleton, _l = fe.aliasTo, o1 = fe.transient, Tt = (n, e, t) => n.registerResolver(e, t);
function h8(...n) {
  return function(e) {
    const t = An("aliases"), i = wn(t, e);
    i === void 0 ? kt(t, n, e) : i.push(...n);
  };
}
function Rl(n, e, t, i) {
  for (let r = 0, s = n.length; r < s; ++r)
    fe.aliasTo(t, e.keyFrom(n[r])).register(i);
}
class Ih {
  constructor(e, t, i, r) {
    if (this.chars = e, this.repeat = t, this.isSymbol = i, this.isInverted = r, r)
      switch (e.length) {
        case 0:
          this.has = this.R;
          break;
        case 1:
          this.has = this.I;
          break;
        default:
          this.has = this.T;
      }
    else
      switch (e.length) {
        case 0:
          this.has = this.P;
          break;
        case 1:
          this.has = this.L;
          break;
        default:
          this.has = this._;
      }
  }
  equals(e) {
    return this.chars === e.chars && this.repeat === e.repeat && this.isSymbol === e.isSymbol && this.isInverted === e.isInverted;
  }
  _(e) {
    return this.chars.includes(e);
  }
  L(e) {
    return this.chars === e;
  }
  P(e) {
    return !1;
  }
  T(e) {
    return !this.chars.includes(e);
  }
  I(e) {
    return this.chars !== e;
  }
  R(e) {
    return !0;
  }
}
class m8 {
  constructor() {
    this.parts = Fe, this.U = "", this.$ = {}, this.q = {};
  }
  get pattern() {
    const e = this.U;
    return e === "" ? null : e;
  }
  set pattern(e) {
    e == null ? (this.U = "", this.parts = Fe) : (this.U = e, this.parts = this.q[e]);
  }
  append(e, t) {
    const i = this.$;
    i[e] === void 0 ? i[e] = t : i[e] += t;
  }
  next(e) {
    const t = this.$;
    let i;
    t[e] !== void 0 && (i = this.q, i[e] === void 0 ? i[e] = [t[e]] : i[e].push(t[e]), t[e] = void 0);
  }
}
class Oh {
  get U() {
    return this.M ? this.F[0] : null;
  }
  constructor(e, ...t) {
    this.charSpec = e, this.O = [], this.V = null, this.M = !1, this.F = t;
  }
  findChild(e) {
    const t = this.O, i = t.length;
    let r = null, s = 0;
    for (; s < i; ++s)
      if (r = t[s], e.equals(r.charSpec))
        return r;
    return null;
  }
  append(e, t) {
    const i = this.F;
    i.includes(t) || i.push(t);
    let r = this.findChild(e);
    return r == null && (r = new Oh(e, t), this.O.push(r), e.repeat && r.O.push(r)), r;
  }
  findMatches(e, t) {
    const i = [], r = this.O, s = r.length;
    let a = 0, o = null, u = 0, l = 0;
    for (; u < s; ++u)
      if (o = r[u], o.charSpec.has(e))
        if (i.push(o), a = o.F.length, l = 0, o.charSpec.isSymbol)
          for (; l < a; ++l)
            t.next(o.F[l]);
        else
          for (; l < a; ++l)
            t.append(o.F[l], e);
    return i;
  }
}
class pb {
  constructor(e) {
    this.text = e;
    const t = this.N = e.length, i = this.j = [];
    let r = 0;
    for (; t > r; ++r)
      i.push(new Ih(e[r], !1, !1, !1));
  }
  eachChar(e) {
    const t = this.N, i = this.j;
    let r = 0;
    for (; t > r; ++r)
      e(i[r]);
  }
}
class b8 {
  constructor(e) {
    this.text = "PART", this.H = new Ih(e, !0, !1, !0);
  }
  eachChar(e) {
    e(this.H);
  }
}
class g8 {
  constructor(e) {
    this.text = e, this.H = new Ih(e, !1, !0, !1);
  }
  eachChar(e) {
    e(this.H);
  }
}
class v8 {
  constructor() {
    this.statics = 0, this.dynamics = 0, this.symbols = 0;
  }
}
const x8 = ke("ISyntaxInterpreter", (n) => n.singleton(T8));
class T8 {
  constructor() {
    this.W = new Oh(null), this.G = [this.W];
  }
  add(e) {
    e = e.slice(0).sort((b, A) => b.pattern > A.pattern ? 1 : -1);
    const t = e.length;
    let i, r, s, a, o, u, l, p = 0, f;
    for (; t > p; ) {
      for (i = this.W, r = e[p], s = r.pattern, a = new v8(), o = this.X(r, a), u = o.length, l = (b) => i = i.append(b, s), f = 0; u > f; ++f)
        o[f].eachChar(l);
      i.V = a, i.M = !0, ++p;
    }
  }
  interpret(e) {
    const t = new m8(), i = e.length;
    let r = this.G, s = 0, a;
    for (; s < i && (r = this.K(r, e.charAt(s), t), r.length !== 0); ++s)
      ;
    return r = r.filter(w8), r.length > 0 && (r.sort(A8), a = r[0], a.charSpec.isSymbol || t.next(a.U), t.pattern = a.U), t;
  }
  K(e, t, i) {
    const r = [];
    let s = null;
    const a = e.length;
    let o = 0;
    for (; o < a; ++o)
      s = e[o], r.push(...s.findMatches(t, i));
    return r;
  }
  X(e, t) {
    const i = [], r = e.pattern, s = r.length, a = e.symbols;
    let o = 0, u = 0, l = "";
    for (; o < s; )
      l = r.charAt(o), a.length === 0 || !a.includes(l) ? o === u && l === "P" && r.slice(o, o + 4) === "PART" ? (u = o += 4, i.push(new b8(a)), ++t.dynamics) : ++o : o !== u ? (i.push(new pb(r.slice(u, o))), ++t.statics, u = o) : (i.push(new g8(r.slice(u, o + 1))), ++t.symbols, u = ++o);
    return u !== o && (i.push(new pb(r.slice(u, o))), ++t.statics), i;
  }
}
function w8(n) {
  return n.M;
}
function A8(n, e) {
  const t = n.V, i = e.V;
  return t.statics !== i.statics ? i.statics - t.statics : t.dynamics !== i.dynamics ? i.dynamics - t.dynamics : t.symbols !== i.symbols ? i.symbols - t.symbols : 0;
}
class bi {
  constructor(e, t, i, r) {
    this.rawName = e, this.rawValue = t, this.target = i, this.command = r;
  }
}
const u1 = ke("IAttributePattern"), E8 = ke("IAttributeParser", (n) => n.singleton(l1));
class l1 {
  constructor(e, t) {
    this.Y = {}, this.Z = e;
    const i = this.F = {}, r = t.reduce((s, a) => {
      const o = c1(a.constructor);
      return o.forEach((u) => i[u.pattern] = a), s.concat(o);
    }, Fe);
    e.add(r);
  }
  parse(e, t) {
    let i = this.Y[e];
    i == null && (i = this.Y[e] = this.Z.interpret(e));
    const r = i.pattern;
    return r == null ? new bi(e, t, e, null) : this.F[r][r](e, t, i.parts);
  }
}
l1.inject = [x8, hx(u1)];
function Gr(...n) {
  return function(t) {
    return M8.define(n, t);
  };
}
class S8 {
  constructor(e) {
    this.Type = e, this.name = void 0;
  }
  register(e) {
    Vo(u1, this.Type).register(e);
  }
}
const ef = Pa("attribute-pattern"), Sc = "attribute-pattern-definitions", c1 = (n) => Pi.annotation.get(n, Sc), M8 = dr({
  name: ef,
  definitionAnnotationKey: Sc,
  define(n, e) {
    const t = new S8(e);
    return kt(ef, t, e), Ia(e, ef), Pi.annotation.set(e, Sc, n), Ch(e, Sc), e;
  },
  getPatternDefinitions: c1
});
let fb = class {
  "PART.PART"(e, t, i) {
    return new bi(e, t, i[0], i[1]);
  }
  "PART.PART.PART"(e, t, i) {
    return new bi(e, t, `${i[0]}.${i[1]}`, i[2]);
  }
};
fb = X([Gr({
  pattern: "PART.PART",
  symbols: "."
}, {
  pattern: "PART.PART.PART",
  symbols: "."
})], fb);
let yb = class {
  ref(e, t, i) {
    return new bi(e, t, "element", "ref");
  }
  "PART.ref"(e, t, i) {
    return new bi(e, t, i[0], "ref");
  }
};
yb = X([Gr({
  pattern: "ref",
  symbols: ""
}, {
  pattern: "PART.ref",
  symbols: "."
})], yb);
let hb = class {
  ":PART"(e, t, i) {
    return new bi(e, t, i[0], "bind");
  }
};
hb = X([Gr({
  pattern: ":PART",
  symbols: ":"
})], hb);
let mb = class {
  "@PART"(e, t, i) {
    return new bi(e, t, i[0], "trigger");
  }
};
mb = X([Gr({
  pattern: "@PART",
  symbols: "@"
})], mb);
let bb = class {
  "...$attrs"(e, t, i) {
    return new bi(e, t, "", "...$attrs");
  }
};
bb = X([Gr({
  pattern: "...$attrs",
  symbols: ""
})], bb);
class d1 {
  constructor(e, t, i) {
    this.type = 7, this.v = null, this.ov = null, this.J = !1, this.o = e, this.tt = t, this.et = i;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    this.v = e, this.J = e !== this.ov, this.it();
  }
  it() {
    if (this.J)
      switch (this.J = !1, this.ov = this.v, this.et) {
        case "class":
          this.o.classList.toggle(this.tt, !!this.v);
          break;
        case "style": {
          let e = "", t = this.v;
          wt(t) && t.includes("!important") && (e = "important", t = t.replace("!important", "")), this.o.style.setProperty(this.tt, t, e);
          break;
        }
        default:
          this.v == null ? this.o.removeAttribute(this.et) : this.o.setAttribute(this.et, String(this.v));
      }
  }
  handleMutation(e) {
    let t = !1;
    for (let i = 0, r = e.length; r > i; ++i) {
      const s = e[i];
      if (s.type === "attributes" && s.attributeName === this.tt) {
        t = !0;
        break;
      }
    }
    if (t) {
      let i;
      switch (this.et) {
        case "class":
          i = this.o.classList.contains(this.tt);
          break;
        case "style":
          i = this.o.style.getPropertyValue(this.tt);
          break;
        default:
          throw re(`AUR0651:${this.et}`);
      }
      i !== this.v && (this.ov = this.v, this.v = i, this.J = !1, this.st());
    }
  }
  subscribe(e) {
    this.subs.add(e) && this.subs.count === 1 && (this.v = this.ov = this.o.getAttribute(this.tt), C8(this.o.ownerDocument.defaultView.MutationObserver, this.o, this));
  }
  unsubscribe(e) {
    this.subs.remove(e) && this.subs.count === 0 && _8(this.o, this);
  }
  st() {
    gb = this.ov, this.ov = this.v, this.subs.notify(this.v, gb);
  }
}
In(d1);
const C8 = (n, e, t) => {
  e.$eMObs === void 0 && (e.$eMObs = /* @__PURE__ */ new Set()), e.$mObs === void 0 && (e.$mObs = new n(R8)).observe(e, {
    attributes: !0
  }), e.$eMObs.add(t);
}, _8 = (n, e) => {
  const t = n.$eMObs;
  return t && t.delete(e) ? (t.size === 0 && (n.$mObs.disconnect(), n.$mObs = void 0), !0) : !1;
}, R8 = (n) => {
  n[0].target.$eMObs.forEach(k8, n);
};
function k8(n) {
  n.handleMutation(this);
}
let gb;
function Kn(n) {
  return function(e) {
    return Yc.define(n, e);
  };
}
class Bh {
  constructor(e, t, i, r) {
    this.Type = e, this.name = t, this.aliases = i, this.key = r;
  }
  static create(e, t) {
    let i, r;
    return wt(e) ? (i = e, r = {
      name: i
    }) : (i = e.name, r = e), new Bh(t, hn(sy(t, "name"), i), $t(sy(t, "aliases"), r.aliases, t.aliases), Yc.keyFrom(i));
  }
  register(e) {
    const { Type: t, key: i, aliases: r } = this;
    Vo(i, t).register(e), _l(i, t).register(e), Rl(r, Yc, i, e);
  }
}
const Xs = Pa("binding-behavior"), sy = (n, e) => wn(An(e), n), Yc = dr({
  name: Xs,
  keyFrom(n) {
    return `${Xs}:${n}`;
  },
  isType(n) {
    return ei(n) && Ml(Xs, n);
  },
  define(n, e) {
    const t = Bh.create(n, e);
    return kt(Xs, t, t.Type), kt(Xs, t, t), Ia(e, Xs), t.Type;
  },
  getDefinition(n) {
    const e = wn(Xs, n);
    if (e === void 0)
      throw re(`AUR0151:${n.name}`);
    return e;
  },
  annotate(n, e, t) {
    kt(An(e), t, n);
  },
  getAnnotation: sy
});
function kl(n) {
  return function(e) {
    return Xc.define(n, e);
  };
}
class Nh {
  constructor(e, t, i, r) {
    this.Type = e, this.name = t, this.aliases = i, this.key = r;
  }
  static create(e, t) {
    let i, r;
    return wt(e) ? (i = e, r = {
      name: i
    }) : (i = e.name, r = e), new Nh(t, hn(ay(t, "name"), i), $t(ay(t, "aliases"), r.aliases, t.aliases), Xc.keyFrom(i));
  }
  register(e) {
    const { Type: t, key: i, aliases: r } = this;
    fe.singleton(i, t).register(e), fe.aliasTo(i, t).register(e), Rl(r, Xc, i, e);
  }
}
const Zs = Pa("value-converter"), ay = (n, e) => wn(An(e), n), Xc = dr({
  name: Zs,
  keyFrom: (n) => `${Zs}:${n}`,
  isType(n) {
    return ei(n) && Ml(Zs, n);
  },
  define(n, e) {
    const t = Nh.create(n, e);
    return kt(Zs, t, t.Type), kt(Zs, t, t), Ia(e, Zs), t.Type;
  },
  getDefinition(n) {
    const e = wn(Zs, n);
    if (e === void 0)
      throw re(`AUR0152:${n.name}`);
    return e;
  },
  annotate(n, e, t) {
    kt(An(e), t, n);
  },
  getAnnotation: ay
});
class P8 {
  constructor(e, t) {
    this.v = void 0, this.b = e, this.nt = t;
  }
  flush() {
    this.b.updateSource(this.v);
  }
  handleChange(e, t) {
    const i = this.b;
    e !== j(i.ast, i.s, i, null) && (this.v = e, this.nt.add(this));
  }
}
const jo = (n) => {
  Ii(n.prototype, "useScope", function(e) {
    this.s = e;
  });
}, pr = (n, e = !0) => (t) => {
  const i = t.prototype;
  n != null && iy(i, "strict", {
    enumerable: !0,
    get: function() {
      return n;
    }
  }), iy(i, "strictFnCall", {
    enumerable: !0,
    get: function() {
      return e;
    }
  }), Ii(i, "get", function(r) {
    return this.l.get(r);
  }), Ii(i, "getSignaler", function() {
    return this.l.root.get(Sh);
  }), Ii(i, "getConverter", function(r) {
    const s = Xc.keyFrom(r);
    let a = tc.get(this);
    return a == null && tc.set(this, a = new vb()), a[s] ?? (a[s] = this.l.get(db(s)));
  }), Ii(i, "getBehavior", function(r) {
    const s = Yc.keyFrom(r);
    let a = tc.get(this);
    return a == null && tc.set(this, a = new vb()), a[s] ?? (a[s] = this.l.get(db(s)));
  });
}, tc = /* @__PURE__ */ new WeakMap();
class vb {
}
const I8 = ke("IFlushQueue", (n) => n.singleton(O8));
class O8 {
  constructor() {
    this.rt = !1, this.ot = /* @__PURE__ */ new Set();
  }
  get count() {
    return this.ot.size;
  }
  add(e) {
    if (this.ot.add(e), !this.rt) {
      this.rt = !0;
      try {
        this.ot.forEach(B8);
      } finally {
        this.rt = !1;
      }
    }
  }
  clear() {
    this.ot.clear(), this.rt = !1;
  }
}
function B8(n, e, t) {
  t.delete(n), n.flush();
}
const tf = /* @__PURE__ */ new WeakSet(), Oa = (n, e) => {
  Ii(n.prototype, "limit", function(t) {
    if (tf.has(this))
      throw re("AURXXXX: a rate limit has already been applied.");
    tf.add(this);
    const i = e(this, t), r = this[i], s = (...o) => r.call(this, ...o), a = t.type === "debounce" ? N8(t, s, this) : D8(t, s, this);
    return this[i] = a, {
      dispose: () => {
        tf.delete(this), a.dispose(), delete this[i];
      }
    };
  });
}, N8 = (n, e, t) => {
  let i, r, s;
  const a = n.queue, o = (u) => {
    s = u, t.isBound ? (r = i, i = a.queueTask(() => e(s), {
      delay: n.delay,
      reusable: !1
    }), r?.cancel()) : e(s);
  };
  return o.dispose = () => {
    r?.cancel(), i?.cancel();
  }, o;
}, D8 = (n, e, t) => {
  let i, r, s = 0, a = 0, o;
  const u = n.queue, l = () => n.now(), p = (f) => {
    o = f, t.isBound ? (a = l() - s, r = i, a > n.delay ? (s = l(), e(o)) : i = u.queueTask(() => {
      s = l(), e(o);
    }, {
      delay: n.delay - a,
      reusable: !1
    }), r?.cancel()) : e(o);
  };
  return p.dispose = () => {
    r?.cancel(), i?.cancel();
  }, p;
}, $8 = {
  reusable: !1,
  preempt: !0
};
class Pl {
  constructor(e, t, i, r, s, a, o, u, l) {
    this.targetAttribute = o, this.targetProperty = u, this.mode = l, this.isBound = !1, this.s = void 0, this.lt = null, this.v = void 0, this.boundFn = !1, this.l = t, this.ast = s, this.ht = e, this.target = a, this.oL = i, this.ct = r;
  }
  updateTarget(e) {
    this.ut.setValue(e, this.target, this.targetProperty);
  }
  handleChange() {
    if (!this.isBound)
      return;
    let e;
    this.obs.version++;
    const t = j(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    this.obs.clear(), t !== this.v && (this.v = t, this.ht.state !== 1 && (4 & this.ut.type) > 0 ? (e = this.lt, this.lt = this.ct.queueTask(() => {
      this.lt = null, this.updateTarget(t);
    }, $8), e?.cancel()) : this.updateTarget(t));
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Ni(this.ast, e, this), this.ut ?? (this.ut = new d1(this.target, this.targetProperty, this.targetAttribute)), this.mode & 3 && this.updateTarget(this.v = j(this.ast, e, this, (2 & this.mode) > 0 ? this : null)), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, fi(this.ast, this.s, this), this.s = void 0, this.v = void 0, this.lt?.cancel(), this.lt = null, this.obs.clearAll());
  }
}
jo(Pl);
Oa(Pl, () => "updateTarget");
Ui(Pl);
pr(!0)(Pl);
const p1 = {
  reusable: !1,
  preempt: !0
};
class F8 {
  constructor(e, t, i, r, s, a, o, u) {
    this.ast = s, this.target = a, this.targetProperty = o, this.mode = u, this.isBound = !1, this.s = void 0, this.lt = null, this.ht = e, this.oL = i, this.ct = r, this.ut = i.getAccessor(a, o);
    const l = s.expressions, p = this.partBindings = Array(l.length), f = l.length;
    let b = 0;
    for (; f > b; ++b)
      p[b] = new Il(l[b], a, o, t, i, this);
  }
  ft() {
    this.updateTarget();
  }
  updateTarget() {
    const e = this.partBindings, t = this.ast.parts, i = e.length;
    let r = "", s = 0;
    if (i === 1)
      r = t[0] + e[0].v + t[1];
    else
      for (r = t[0]; i > s; ++s)
        r += e[s].v + t[s + 1];
    const a = this.ut, o = this.ht.state !== 1 && (4 & a.type) > 0;
    let u;
    o ? (u = this.lt, this.lt = this.ct.queueTask(() => {
      this.lt = null, a.setValue(r, this.target, this.targetProperty);
    }, p1), u?.cancel(), u = null) : a.setValue(r, this.target, this.targetProperty);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e;
    const t = this.partBindings, i = t.length;
    let r = 0;
    for (; i > r; ++r)
      t[r].bind(e);
    this.updateTarget(), this.isBound = !0;
  }
  unbind() {
    if (!this.isBound)
      return;
    this.isBound = !1, this.s = void 0;
    const e = this.partBindings, t = e.length;
    let i = 0;
    for (; t > i; ++i)
      e[i].unbind();
    this.lt?.cancel(), this.lt = null;
  }
}
class Il {
  constructor(e, t, i, r, s, a) {
    this.ast = e, this.target = t, this.targetProperty = i, this.owner = a, this.mode = 2, this.task = null, this.isBound = !1, this.v = "", this.boundFn = !1, this.l = r, this.oL = s;
  }
  updateTarget() {
    this.owner.ft();
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = j(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    this.obs.clear(), e != this.v && (this.v = e, Fi(e) && this.observeCollection(e), this.updateTarget());
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Ni(this.ast, e, this), this.v = j(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null), Fi(this.v) && this.observeCollection(this.v), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, fi(this.ast, this.s, this), this.s = void 0, this.obs.clearAll());
  }
}
jo(Il);
Oa(Il, () => "updateTarget");
Ui(Il);
pr(!0)(Il);
class Ol {
  constructor(e, t, i, r, s, a, o, u) {
    this.p = s, this.ast = a, this.target = o, this.strict = u, this.isBound = !1, this.mode = 2, this.lt = null, this.v = "", this.boundFn = !1, this.l = t, this.ht = e, this.oL = i, this.ct = r;
  }
  updateTarget(e) {
    const t = this.target, i = this.p.Node, r = this.v;
    this.v = e, r instanceof i && r.parentNode?.removeChild(r), e instanceof i ? (t.textContent = "", t.parentNode?.insertBefore(e, t)) : t.textContent = String(e);
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = j(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    if (this.obs.clear(), e === this.v) {
      this.lt?.cancel(), this.lt = null;
      return;
    }
    this.ht.state !== 1 ? this.dt(e) : this.updateTarget(e);
  }
  handleCollectionChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = this.v = j(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    this.obs.clear(), Fi(e) && this.observeCollection(e), this.ht.state !== 1 ? this.dt(e) : this.updateTarget(e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Ni(this.ast, e, this);
    const t = this.v = j(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    Fi(t) && this.observeCollection(t), this.updateTarget(t), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, fi(this.ast, this.s, this), this.s = void 0, this.obs.clearAll(), this.lt?.cancel(), this.lt = null);
  }
  dt(e) {
    const t = this.lt;
    this.lt = this.ct.queueTask(() => {
      this.lt = null, this.updateTarget(e);
    }, p1), t?.cancel();
  }
}
jo(Ol);
Oa(Ol, () => "updateTarget");
Ui()(Ol);
pr(void 0, !1)(Ol);
class Bl {
  constructor(e, t, i, r, s = !1) {
    this.ast = i, this.targetProperty = r, this.isBound = !1, this.s = void 0, this.target = null, this.boundFn = !1, this.l = e, this.oL = t, this.gt = s;
  }
  updateTarget() {
    this.target[this.targetProperty] = this.v;
  }
  handleChange() {
    this.isBound && (this.obs.version++, this.v = j(this.ast, this.s, this, this), this.obs.clear(), this.updateTarget());
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, this.target = this.gt ? e.bindingContext : e.overrideContext, Ni(this.ast, e, this), this.v = j(this.ast, this.s, this, this), this.updateTarget(), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, fi(this.ast, this.s, this), this.s = void 0, this.obs.clearAll());
  }
}
jo(Bl);
Oa(Bl, () => "updateTarget");
Ui(Bl);
pr(!0)(Bl);
class qr {
  constructor(e, t, i, r, s, a, o, u) {
    this.ast = s, this.target = a, this.targetProperty = o, this.mode = u, this.isBound = !1, this.s = void 0, this.ut = void 0, this.lt = null, this.vt = null, this.boundFn = !1, this.l = t, this.ht = e, this.ct = r, this.oL = i;
  }
  updateTarget(e) {
    this.ut.setValue(e, this.target, this.targetProperty);
  }
  updateSource(e) {
    fn(this.ast, this.s, this, e);
  }
  handleChange() {
    if (!this.isBound)
      return;
    this.obs.version++;
    const e = j(this.ast, this.s, this, (2 & this.mode) > 0 ? this : null);
    this.obs.clear(), this.ht.state !== 1 && (4 & this.ut.type) > 0 ? (nf = this.lt, this.lt = this.ct.queueTask(() => {
      this.updateTarget(e), this.lt = null;
    }, L8), nf?.cancel(), nf = null) : this.updateTarget(e);
  }
  handleCollectionChange() {
    this.handleChange();
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Ni(this.ast, e, this);
    const t = this.oL, i = this.mode;
    let r = this.ut;
    r || (4 & i ? r = t.getObserver(this.target, this.targetProperty) : r = t.getAccessor(this.target, this.targetProperty), this.ut = r);
    const s = (2 & i) > 0;
    i & 3 && this.updateTarget(j(this.ast, this.s, this, s ? this : null)), 4 & i && (r.subscribe(this.vt ?? (this.vt = new P8(this, this.l.get(I8)))), s || this.updateSource(r.getValue(this.target, this.targetProperty))), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, fi(this.ast, this.s, this), this.s = void 0, this.vt && (this.ut.unsubscribe(this.vt), this.vt = null), this.lt?.cancel(), this.lt = null, this.obs.clearAll());
  }
  useTargetObserver(e) {
    this.ut?.unsubscribe(this), (this.ut = e).subscribe(this);
  }
  useTargetSubscriber(e) {
    if (this.vt != null)
      throw re("AURxxxx: binding already has a target subscriber");
    this.vt = e;
  }
}
jo(qr);
Oa(qr, (n) => 4 & n.mode ? "updateSource" : "updateTarget");
Ui(qr);
pr(!0, !1)(qr);
let nf = null;
const L8 = {
  reusable: !1,
  preempt: !0
};
class f1 {
  constructor(e, t, i) {
    this.ast = t, this.target = i, this.isBound = !1, this.s = void 0, this.l = e;
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Ni(this.ast, e, this), fn(this.ast, this.s, this, this.target), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, j(this.ast, this.s, this, null) === this.target && fn(this.ast, this.s, this, null), fi(this.ast, this.s, this), this.s = void 0);
  }
}
pr(!1)(f1);
class U8 {
  constructor(e, t = !1) {
    this.prevent = e, this.capture = t;
  }
}
class Nl {
  constructor(e, t, i, r, s) {
    this.ast = t, this.target = i, this.targetEvent = r, this.isBound = !1, this.self = !1, this.boundFn = !0, this.l = e, this.xt = s;
  }
  callSource(e) {
    const t = this.s.overrideContext;
    t.$event = e;
    let i = j(this.ast, this.s, this, null);
    return delete t.$event, ei(i) && (i = i(e)), i !== !0 && this.xt.prevent && e.preventDefault(), i;
  }
  handleEvent(e) {
    this.self && this.target !== e.composedPath()[0] || this.callSource(e);
  }
  bind(e) {
    if (this.isBound) {
      if (this.s === e)
        return;
      this.unbind();
    }
    this.s = e, Ni(this.ast, e, this), this.target.addEventListener(this.targetEvent, this, this.xt), this.isBound = !0;
  }
  unbind() {
    this.isBound && (this.isBound = !1, fi(this.ast, this.s, this), this.s = void 0, this.target.removeEventListener(this.targetEvent, this, this.xt));
  }
}
jo(Nl);
Oa(Nl, () => "callSource");
pr(!0, !0)(Nl);
ke("IAppTask");
const V8 = Fe, nc = An("watch"), oy = dr({
  name: nc,
  add(n, e) {
    let t = wn(nc, n);
    t == null && kt(nc, t = [], n), t.push(e);
  },
  getAnnotation(n) {
    return wn(nc, n) ?? V8;
  }
});
function y1(n) {
  return function(e) {
    return Fh(n, e);
  };
}
function vi(n) {
  return function(e) {
    return Fh(wt(n) ? {
      isTemplateController: !0,
      name: n
    } : {
      isTemplateController: !0,
      ...n
    }, e);
  };
}
class Dh {
  get type() {
    return 2;
  }
  constructor(e, t, i, r, s, a, o, u, l, p) {
    this.Type = e, this.name = t, this.aliases = i, this.key = r, this.defaultBindingMode = s, this.isTemplateController = a, this.bindables = o, this.noMultiBindings = u, this.watches = l, this.dependencies = p;
  }
  static create(e, t) {
    let i, r;
    return wt(e) ? (i = e, r = {
      name: i
    }) : (i = e.name, r = e), new Dh(t, hn(ss(t, "name"), i), $t(ss(t, "aliases"), r.aliases, t.aliases), $h(i), hn(ss(t, "defaultBindingMode"), r.defaultBindingMode, t.defaultBindingMode, 2), hn(ss(t, "isTemplateController"), r.isTemplateController, t.isTemplateController, !1), Er.from(t, ...Er.getAll(t), ss(t, "bindables"), t.bindables, r.bindables), hn(ss(t, "noMultiBindings"), r.noMultiBindings, t.noMultiBindings, !1), $t(oy.getAnnotation(t), t.watches), $t(ss(t, "dependencies"), r.dependencies, t.dependencies));
  }
  register(e) {
    const { Type: t, key: i, aliases: r } = this;
    o1(i, t).register(e), _l(i, t).register(e), Rl(r, Lh, i, e);
  }
}
const la = Pa("custom-attribute"), $h = (n) => `${la}:${n}`, ss = (n, e) => wn(An(e), n), j8 = (n) => ei(n) && Ml(la, n), h1 = (n, e) => gu(n, $h(e)) ?? void 0, Fh = (n, e) => {
  const t = Dh.create(n, e);
  return kt(la, t, t.Type), kt(la, t, t), Ia(e, la), t.Type;
}, uy = (n) => {
  const e = wn(la, n);
  if (e === void 0)
    throw re(`AUR0759:${n.name}`);
  return e;
}, Lh = dr({
  name: la,
  keyFrom: $h,
  isType: j8,
  for: h1,
  define: Fh,
  getDefinition: uy,
  annotate(n, e, t) {
    kt(An(e), t, n);
  },
  getAnnotation: ss
});
function z8(n) {
  return n.startsWith(bu);
}
const bu = An("children-observer"), iu = dr({
  name: bu,
  keyFrom: (n) => `${bu}:${n}`,
  from(...n) {
    const e = {};
    function t(s) {
      e[s] = Ru.create(s);
    }
    function i(s, a) {
      e[s] = Ru.create(s, a);
    }
    function r(s) {
      Fi(s) ? s.forEach(t) : s instanceof Ru ? e[s.property] = s : s !== void 0 && Ph(s).forEach((a) => i(a, s));
    }
    return n.forEach(r), e;
  },
  getAll(n) {
    const e = bu.length + 1, t = [], i = lx(n);
    let r = i.length, s = 0, a, o, u;
    for (; --r >= 0; ) {
      u = i[r], a = s1(u).filter(z8), o = a.length;
      for (let l = 0; l < o; ++l)
        t[s++] = wn(bu, u, a[l].slice(e));
    }
    return t;
  }
}), G8 = {
  childList: !0
};
class Ru {
  constructor(e, t, i, r, s, a) {
    this.callback = e, this.property = t, this.options = i, this.query = r, this.filter = s, this.map = a;
  }
  static create(e, t = {}) {
    return new Ru(hn(t.callback, `${e}Changed`), hn(t.property, e), t.options ?? G8, t.query, t.filter, t.map);
  }
}
class m1 {
  constructor(e, t, i, r, s = q8, a = H8, o = K8, u) {
    this.controller = e, this.obj = t, this.propertyKey = i, this.query = s, this.filter = a, this.map = o, this.options = u, this.observing = !1, this.children = void 0, this.observer = void 0, this.callback = t[r], Reflect.defineProperty(this.obj, this.propertyKey, {
      enumerable: !0,
      configurable: !0,
      get: () => this.getValue(),
      set: () => {
      }
    });
  }
  getValue() {
    return this.observing ? this.children : this.get();
  }
  setValue(e) {
  }
  start() {
    this.observing || (this.observing = !0, this.children = this.get(), (this.observer ?? (this.observer = new this.controller.host.ownerDocument.defaultView.MutationObserver(() => {
      this.wt();
    }))).observe(this.controller.host, this.options));
  }
  stop() {
    this.observing && (this.observing = !1, this.observer.disconnect(), this.children = Fe);
  }
  wt() {
    this.children = this.get(), this.callback !== void 0 && this.callback.call(this.obj), this.subs.notify(this.children, void 0);
  }
  get() {
    return J8(this.controller, this.query, this.filter, this.map);
  }
}
In()(m1);
function q8(n) {
  return n.host.childNodes;
}
function H8(n, e, t) {
  return !!t;
}
function K8(n, e, t) {
  return t;
}
const W8 = {
  optional: !0
};
function J8(n, e, t, i) {
  const r = e(n), s = r.length, a = [];
  let o, u, l, p = 0;
  for (; p < s; ++p)
    o = r[p], u = gs(o, W8), l = u?.viewModel ?? null, t(o, u, l) && a.push(i(o, u, l));
  return a;
}
const On = wl, xb = (n, e, t, i) => {
  n.addEventListener(e, t, i);
}, Tb = (n, e, t, i) => {
  n.removeEventListener(e, t, i);
}, Uh = (n) => {
  let e;
  const t = n.prototype;
  Ii(t, "subscribe", function(i) {
    if (this.subs.add(i) && this.subs.count === 1) {
      for (e of this.cf.events)
        xb(this.bt, e, this);
      this.yt = !0, this.kt?.();
    }
  }), Ii(t, "unsubscribe", function(i) {
    if (this.subs.remove(i) && this.subs.count === 0) {
      for (e of this.cf.events)
        Tb(this.bt, e, this);
      this.yt = !1, this.At?.();
    }
  }), Ii(t, "useConfig", function(i) {
    if (this.cf = i, this.yt) {
      for (e of this.cf.events)
        Tb(this.bt, e, this);
      for (e of this.cf.events)
        xb(this.bt, e, this);
    }
  });
}, Qd = (n) => {
  Ii(n.prototype, "subscribe", kr), Ii(n.prototype, "unsubscribe", kr);
};
class b1 {
  get doNotCache() {
    return !0;
  }
  constructor(e) {
    this.obj = e, this.type = 6, this.value = "", this.ov = "", this.Ct = {}, this.Bt = 0, this.J = !1;
  }
  getValue() {
    return this.value;
  }
  setValue(e) {
    this.value = e, this.J = e !== this.ov, this.it();
  }
  it() {
    if (this.J) {
      this.J = !1;
      const e = this.value, t = this.Ct, i = g1(e);
      let r = this.Bt;
      if (this.ov = e, i.length > 0 && this.Rt(i), this.Bt += 1, r === 0)
        return;
      r -= 1;
      for (const s in t)
        !bs.call(t, s) || t[s] !== r || this.obj.classList.remove(s);
    }
  }
  Rt(e) {
    const t = this.obj, i = e.length;
    let r = 0, s;
    for (; r < i; r++)
      s = e[r], s.length !== 0 && (this.Ct[s] = this.Bt, t.classList.add(s));
  }
}
function g1(n) {
  if (wt(n))
    return wb(n);
  if (typeof n != "object")
    return Fe;
  if (n instanceof Array) {
    const i = n.length;
    if (i > 0) {
      const r = [];
      let s = 0;
      for (; i > s; ++s)
        r.push(...g1(n[s]));
      return r;
    } else
      return Fe;
  }
  const e = [];
  let t;
  for (t in n)
    n[t] && (t.includes(" ") ? e.push(...wb(t)) : e.push(t));
  return e;
}
function wb(n) {
  const e = n.match(/\S+/g);
  return e === null ? Fe : e;
}
Qd(b1);
ke("IShadowDOMStyleFactory", (n) => n.cachedCallback((e) => T1.supported(e.get(On)) ? e.get(v1) : e.get(x1)));
class v1 {
  constructor(e) {
    this.p = e, this.cache = /* @__PURE__ */ new Map();
  }
  createStyles(e, t) {
    return new T1(this.p, e, this.cache, t);
  }
}
v1.inject = [On];
class x1 {
  constructor(e) {
    this.p = e;
  }
  createStyles(e, t) {
    return new Y8(this.p, e, t);
  }
}
x1.inject = [On];
const Ab = ke("IShadowDOMStyles"), Q8 = ke("IShadowDOMGlobalStyles", (n) => n.instance({
  applyTo: kr
}));
class T1 {
  constructor(e, t, i, r = null) {
    this.sharedStyles = r, this.styleSheets = t.map((s) => {
      let a;
      return s instanceof e.CSSStyleSheet ? a = s : (a = i.get(s), a === void 0 && (a = new e.CSSStyleSheet(), a.replaceSync(s), i.set(s, a))), a;
    });
  }
  static supported(e) {
    return "adoptedStyleSheets" in e.ShadowRoot.prototype;
  }
  applyTo(e) {
    this.sharedStyles !== null && this.sharedStyles.applyTo(e), e.adoptedStyleSheets = [...e.adoptedStyleSheets, ...this.styleSheets];
  }
}
class Y8 {
  constructor(e, t, i = null) {
    this.p = e, this.localStyles = t, this.sharedStyles = i;
  }
  applyTo(e) {
    const t = this.localStyles, i = this.p;
    for (let r = t.length - 1; r > -1; --r) {
      const s = i.document.createElement("style");
      s.innerHTML = t[r], e.prepend(s);
    }
    this.sharedStyles !== null && this.sharedStyles.applyTo(e);
  }
}
const { enter: X8, exit: Z8 } = g4, { wrap: eE, unwrap: tE } = Z4;
class w1 {
  get value() {
    return this.v;
  }
  constructor(e, t, i, r, s) {
    this.obj = e, this.$get = i, this.useProxy = s, this.isBound = !1, this.running = !1, this.v = void 0, this.cb = r, this.oL = t;
  }
  handleChange() {
    this.run();
  }
  handleCollectionChange() {
    this.run();
  }
  bind() {
    this.isBound || (this.compute(), this.isBound = !0);
  }
  unbind() {
    this.isBound && (this.isBound = !1, this.obs.clearAll());
  }
  run() {
    if (!this.isBound || this.running)
      return;
    const e = this.obj, t = this.v, i = this.compute();
    Cl(i, t) || this.cb.call(e, i, t, e);
  }
  compute() {
    this.running = !0, this.obs.version++;
    try {
      return X8(this), this.v = tE(this.$get.call(void 0, this.useProxy ? eE(this.obj) : this.obj, this));
    } finally {
      this.obs.clear(), this.running = !1, Z8(this);
    }
  }
}
class Vh {
  get value() {
    return this.v;
  }
  constructor(e, t, i, r, s) {
    this.scope = e, this.l = t, this.oL = i, this.isBound = !1, this.boundFn = !1, this.obj = e.bindingContext, this.It = r, this.cb = s;
  }
  handleChange(e) {
    const t = this.It, i = this.obj, r = this.v;
    t.$kind === 1 && this.obs.count === 1 || (this.obs.version++, e = j(t, this.scope, this, this), this.obs.clear()), Cl(e, r) || (this.v = e, this.cb.call(i, e, r, i));
  }
  bind() {
    this.isBound || (this.obs.version++, this.v = j(this.It, this.scope, this, this), this.obs.clear(), this.isBound = !0);
  }
  unbind() {
    this.isBound && (this.isBound = !1, this.obs.clearAll(), this.v = void 0);
  }
}
Ui(w1);
Ui(Vh);
pr(!0)(Vh);
const Za = ke("ILifecycleHooks");
class nE {
  constructor(e, t) {
    this.definition = e, this.instance = t;
  }
}
class jh {
  constructor(e, t) {
    this.Type = e, this.propertyNames = t;
  }
  static create(e, t) {
    const i = /* @__PURE__ */ new Set();
    let r = t.prototype;
    for (; r !== _h; ) {
      for (const s of kh(r))
        s !== "constructor" && i.add(s);
      r = Object.getPrototypeOf(r);
    }
    return new jh(t, i);
  }
  register(e) {
    Vo(Za, this.Type).register(e);
  }
}
const Eb = /* @__PURE__ */ new WeakMap(), ic = An("lifecycle-hooks"), Sb = dr({
  name: ic,
  define(n, e) {
    const t = jh.create(n, e);
    return kt(ic, t, e), Ia(e, ic), t.Type;
  },
  resolve(n) {
    let e = Eb.get(n);
    if (e === void 0) {
      Eb.set(n, e = new iE());
      const t = n.root, i = t.id === n.id ? n.getAll(Za) : n.has(Za, !1) ? t.getAll(Za).concat(n.getAll(Za)) : t.getAll(Za);
      let r, s, a, o, u;
      for (r of i) {
        s = wn(ic, r.constructor), a = new nE(s, r);
        for (o of s.propertyNames)
          u = e[o], u === void 0 ? e[o] = [a] : u.push(a);
      }
    }
    return e;
  }
});
class iE {
}
const ii = ke("IViewFactory");
class Yd {
  constructor(e, t) {
    this.isCaching = !1, this.Y = null, this.Tt = -1, this.name = t.name, this.container = e, this.def = t;
  }
  setCacheSize(e, t) {
    e && (e === "*" ? e = Yd.maxCacheSize : wt(e) && (e = parseInt(e, 10)), (this.Tt === -1 || !t) && (this.Tt = e)), this.Tt > 0 ? this.Y = [] : this.Y = null, this.isCaching = this.Tt > 0;
  }
  canReturnToCache(e) {
    return this.Y != null && this.Y.length < this.Tt;
  }
  tryReturnToCache(e) {
    return this.canReturnToCache(e) ? (this.Y.push(e), !0) : !1;
  }
  create(e) {
    const t = this.Y;
    let i;
    return t != null && t.length > 0 ? (i = t.pop(), i) : (i = pi.$view(this, e), i);
  }
}
Yd.maxCacheSize = 65535;
const Ba = ke("IRendering", (n) => n.singleton(A1));
class A1 {
  get renderers() {
    return this.Pt ?? (this.Pt = this.Et.getAll(O1, !1).reduce((e, t) => (e[t.target] = t, e), yn()));
  }
  constructor(e) {
    this.Lt = /* @__PURE__ */ new WeakMap(), this.Dt = /* @__PURE__ */ new WeakMap();
    const t = e.root;
    this.p = (this.Et = t).get(On), this.ep = t.get(hh), this.oL = t.get(ka), this._t = new af(this.p, this.p.document.createDocumentFragment());
  }
  compile(e, t, i) {
    if (e.needsCompile !== !1) {
      const r = this.Lt, s = t.get(I1);
      let a = r.get(e);
      return a == null ? r.set(e, a = s.compile(e, t, i)) : t.register(...a.dependencies), a;
    }
    return e;
  }
  getViewFactory(e, t) {
    return new Yd(t, Wi.getOrCreate(e));
  }
  createNodes(e) {
    if (e.enhance === !0)
      return new af(this.p, e.template);
    let t, i = !1;
    const r = this.Dt, s = this.p, a = s.document;
    if (r.has(e))
      t = r.get(e);
    else {
      const o = e.template;
      let u;
      o === null ? t = null : o instanceof s.Node ? o.nodeName === "TEMPLATE" ? (t = o.content, i = !0) : (t = a.createDocumentFragment()).appendChild(o.cloneNode(!0)) : (u = a.createElement("template"), wt(o) && (u.innerHTML = o), t = u.content, i = !0), r.set(e, t);
    }
    return t == null ? this._t : new af(this.p, i ? a.importNode(t, !0) : a.adoptNode(t.cloneNode(!0)));
  }
  render(e, t, i, r) {
    const s = i.instructions, a = this.renderers, o = t.length;
    if (t.length !== s.length)
      throw re(`AUR0757:${o}<>${s.length}`);
    let u = 0, l = 0, p = 0, f, b, A;
    if (o > 0)
      for (; o > u; ) {
        for (f = s[u], A = t[u], l = 0, p = f.length; p > l; )
          b = f[l], a[b.type].render(e, A, b, this.p, this.ep, this.oL), ++l;
        ++u;
      }
    if (r != null && (f = i.surrogates, (p = f.length) > 0))
      for (l = 0; p > l; )
        b = f[l], a[b.type].render(e, r, b, this.p, this.ep, this.oL), ++l;
  }
}
A1.inject = [Do];
var Mb;
(function(n) {
  n[n.none = 0] = "none", n[n.host = 1] = "host", n[n.shadowRoot = 2] = "shadowRoot", n[n.location = 3] = "location";
})(Mb || (Mb = {}));
const rE = {
  optional: !0
}, ns = /* @__PURE__ */ new WeakMap();
class pi {
  get lifecycleHooks() {
    return this.Ut;
  }
  get isActive() {
    return (this.state & 3) > 0 && (4 & this.state) === 0;
  }
  get name() {
    if (this.parent === null)
      switch (this.vmKind) {
        case 1:
          return `[${this.definition.name}]`;
        case 0:
          return this.definition.name;
        case 2:
          return this.viewFactory.name;
      }
    switch (this.vmKind) {
      case 1:
        return `${this.parent.name}>[${this.definition.name}]`;
      case 0:
        return `${this.parent.name}>${this.definition.name}`;
      case 2:
        return this.viewFactory.name === this.parent.definition?.name ? `${this.parent.name}[view]` : `${this.parent.name}[view:${this.viewFactory.name}]`;
    }
  }
  get hooks() {
    return this.$t;
  }
  get viewModel() {
    return this.qt;
  }
  set viewModel(e) {
    this.qt = e, this.$t = e == null || this.vmKind === 2 ? ao.none : new ao(e);
  }
  constructor(e, t, i, r, s, a, o) {
    this.container = e, this.vmKind = t, this.definition = i, this.viewFactory = r, this.host = a, this.head = null, this.tail = null, this.next = null, this.parent = null, this.bindings = null, this.children = null, this.hasLockedScope = !1, this.isStrictBinding = !1, this.scope = null, this.isBound = !1, this.hostController = null, this.mountTarget = 0, this.shadowRoot = null, this.nodes = null, this.location = null, this.Ut = null, this.state = 0, this.Mt = !1, this.Ft = Fe, this.$initiator = null, this.$resolve = void 0, this.$reject = void 0, this.$promise = void 0, this.Ot = 0, this.Vt = 0, this.Nt = 0, this.qt = s, this.$t = t === 2 ? ao.none : new ao(s), this.location = o, this.r = e.root.get(Ba);
  }
  static getCached(e) {
    return ns.get(e);
  }
  static getCachedOrThrow(e) {
    const t = pi.getCached(e);
    if (t === void 0)
      throw re(`AUR0500:${e}`);
    return t;
  }
  static $el(e, t, i, r, s = void 0, a = null) {
    if (ns.has(t))
      return ns.get(t);
    s = s ?? dy(t.constructor);
    const o = new pi(e, 0, s, null, t, i, a), u = e.get(mx(Zc));
    return s.dependencies.length > 0 && e.register(...s.dependencies), Tt(e, Zc, new on("IHydrationContext", new uE(o, r, u))), ns.set(t, o), (r == null || r.hydrate !== !1) && o.hE(r, u), o;
  }
  static $attr(e, t, i, r) {
    if (ns.has(t))
      return ns.get(t);
    r = r ?? uy(t.constructor);
    const s = new pi(e, 1, r, null, t, i, null);
    return r.dependencies.length > 0 && e.register(...r.dependencies), ns.set(t, s), s.jt(), s;
  }
  static $view(e, t = void 0) {
    const i = new pi(e.container, 2, null, e, null, null, null);
    return i.parent = t ?? null, i.Ht(), i;
  }
  hE(e, t) {
    const i = this.container, r = this.qt;
    let s = this.definition;
    if (this.scope = ln.create(r, null, !0), s.watches.length > 0 && Rb(this, i, s, r), Cb(this, s, r), this.Ft = sE(this, s, r), this.$t.hasDefine) {
      const a = r.define(this, t, s);
      a !== void 0 && a !== s && (s = Wi.getOrCreate(a));
    }
    this.Ut = Sb.resolve(i), s.register(i), s.injectable !== null && Tt(i, s.injectable, new on("definition.injectable", r)), (e == null || e.hydrate !== !1) && (this.hS(e), this.hC());
  }
  hS(e) {
    this.Ut.hydrating !== void 0 && this.Ut.hydrating.forEach(cE, this), this.$t.hasHydrating && this.qt.hydrating(this);
    const t = this.Wt = this.r.compile(this.definition, this.container, e), { shadowOptions: i, isStrictBinding: r, hasSlots: s, containerless: a } = t;
    let o = this.location;
    if (this.isStrictBinding = r, (this.hostController = gs(this.host, rE)) !== null && (this.host = this.container.root.get(On).document.createElement(this.definition.name), a && o == null && (o = this.location = zh(this.host))), Sn(this.host, en, this), Sn(this.host, this.definition.key, this), i !== null || s) {
      if (o != null)
        throw re("AUR0501");
      Sn(this.shadowRoot = this.host.attachShadow(i ?? oE), en, this), Sn(this.shadowRoot, this.definition.key, this), this.mountTarget = 2;
    } else
      o != null ? (Sn(o, en, this), Sn(o, this.definition.key, this), this.mountTarget = 3) : this.mountTarget = 1;
    this.qt.$controller = this, this.nodes = this.r.createNodes(t), this.Ut.hydrated !== void 0 && this.Ut.hydrated.forEach(dE, this), this.$t.hasHydrated && this.qt.hydrated(this);
  }
  hC() {
    this.r.render(this, this.nodes.findTargets(), this.Wt, this.host), this.Ut.created !== void 0 && this.Ut.created.forEach(Ob, this), this.$t.hasCreated && this.qt.created(this);
  }
  jt() {
    const e = this.definition, t = this.qt;
    e.watches.length > 0 && Rb(this, this.container, e, t), Cb(this, e, t), t.$controller = this, this.Ut = Sb.resolve(this.container), this.Ut.created !== void 0 && this.Ut.created.forEach(Ob, this), this.$t.hasCreated && this.qt.created(this);
  }
  Ht() {
    this.Wt = this.r.compile(this.viewFactory.def, this.container, null), this.isStrictBinding = this.Wt.isStrictBinding, this.r.render(this, (this.nodes = this.r.createNodes(this.Wt)).findTargets(), this.Wt, void 0);
  }
  activate(e, t, i) {
    switch (this.state) {
      case 0:
      case 8:
        if (!(t === null || t.isActive))
          return;
        this.state = 1;
        break;
      case 2:
        return;
      case 32:
        throw re(`AUR0502:${this.name}`);
      default:
        throw re(`AUR0503:${this.name} ${Ib(this.state)}`);
    }
    switch (this.parent = t, this.vmKind) {
      case 0:
        this.scope.parent = i ?? null;
        break;
      case 1:
        this.scope = i ?? null;
        break;
      case 2:
        if (i == null)
          throw re("AUR0504");
        this.hasLockedScope || (this.scope = i);
        break;
    }
    this.isStrictBinding, this.$initiator = e, this.zt();
    let r;
    return this.vmKind !== 2 && this.Ut.binding != null && (r = Yt(...this.Ut.binding.map(pE, this))), this.$t.hasBinding && (r = Yt(r, this.qt.binding(this.$initiator, this.parent))), an(r) ? (this.Gt(), r.then(() => {
      this.bind();
    }).catch((s) => {
      this.Xt(s);
    }), this.$promise) : (this.bind(), this.$promise);
  }
  bind() {
    let e = 0, t = this.Ft.length, i;
    if (t > 0)
      for (; t > e; )
        this.Ft[e].start(), ++e;
    if (this.bindings !== null)
      for (e = 0, t = this.bindings.length; t > e; )
        this.bindings[e].bind(this.scope), ++e;
    if (this.vmKind !== 2 && this.Ut.bound != null && (i = Yt(...this.Ut.bound.map(fE, this))), this.$t.hasBound && (i = Yt(i, this.qt.bound(this.$initiator, this.parent))), an(i)) {
      this.Gt(), i.then(() => {
        this.isBound = !0, this.Kt();
      }).catch((r) => {
        this.Xt(r);
      });
      return;
    }
    this.isBound = !0, this.Kt();
  }
  Qt(...e) {
    switch (this.mountTarget) {
      case 1:
        this.host.append(...e);
        break;
      case 2:
        this.shadowRoot.append(...e);
        break;
      case 3: {
        let t = 0;
        for (; t < e.length; ++t)
          this.location.parentNode.insertBefore(e[t], this.location);
        break;
      }
    }
  }
  Kt() {
    if (this.hostController !== null)
      switch (this.mountTarget) {
        case 1:
        case 2:
          this.hostController.Qt(this.host);
          break;
        case 3:
          this.hostController.Qt(this.location.$start, this.location);
          break;
      }
    switch (this.mountTarget) {
      case 1:
        this.nodes.appendTo(this.host, this.definition != null && this.definition.enhance);
        break;
      case 2: {
        const i = this.container;
        (i.has(Ab, !1) ? i.get(Ab) : i.get(Q8)).applyTo(this.shadowRoot), this.nodes.appendTo(this.shadowRoot);
        break;
      }
      case 3:
        this.nodes.insertBefore(this.location);
        break;
    }
    let e = 0, t;
    if (this.vmKind !== 2 && this.Ut.attaching != null && (t = Yt(...this.Ut.attaching.map(yE, this))), this.$t.hasAttaching && (t = Yt(t, this.qt.attaching(this.$initiator, this.parent))), an(t) && (this.Gt(), this.zt(), t.then(() => {
      this.Yt();
    }).catch((i) => {
      this.Xt(i);
    })), this.children !== null)
      for (; e < this.children.length; ++e)
        this.children[e].activate(this.$initiator, this, this.scope);
    this.Yt();
  }
  deactivate(e, t) {
    switch (-17 & this.state) {
      case 2:
        this.state = 4;
        break;
      case 0:
      case 8:
      case 32:
      case 40:
        return;
      default:
        throw re(`AUR0505:${this.name} ${Ib(this.state)}`);
    }
    this.$initiator = e, e === this && this.Zt();
    let i = 0, r;
    if (this.Ft.length)
      for (; i < this.Ft.length; ++i)
        this.Ft[i].stop();
    if (this.children !== null)
      for (i = 0; i < this.children.length; ++i)
        this.children[i].deactivate(e, this);
    if (this.vmKind !== 2 && this.Ut.detaching != null && (r = Yt(...this.Ut.detaching.map(mE, this))), this.$t.hasDetaching && (r = Yt(r, this.qt.detaching(this.$initiator, this.parent))), an(r) && (this.Gt(), e.Zt(), r.then(() => {
      e.Jt();
    }).catch((s) => {
      e.Xt(s);
    })), e.head === null ? e.head = this : e.tail.next = this, e.tail = this, e === this)
      return this.Jt(), this.$promise;
  }
  removeNodes() {
    switch (this.vmKind) {
      case 0:
      case 2:
        this.nodes.remove(), this.nodes.unlink();
    }
    if (this.hostController !== null)
      switch (this.mountTarget) {
        case 1:
        case 2:
          this.host.remove();
          break;
        case 3:
          this.location.$start.remove(), this.location.remove();
          break;
      }
  }
  unbind() {
    let e = 0;
    if (this.bindings !== null)
      for (; e < this.bindings.length; ++e)
        this.bindings[e].unbind();
    switch (this.parent = null, this.vmKind) {
      case 1:
        this.scope = null;
        break;
      case 2:
        this.hasLockedScope || (this.scope = null), (16 & this.state) === 16 && !this.viewFactory.tryReturnToCache(this) && this.$initiator === this && this.dispose();
        break;
      case 0:
        this.scope.parent = null;
        break;
    }
    this.state = 8, this.$initiator = null, this.te();
  }
  Gt() {
    this.$promise === void 0 && (this.$promise = new Promise((e, t) => {
      this.$resolve = e, this.$reject = t;
    }), this.$initiator !== this && this.parent.Gt());
  }
  te() {
    this.$promise !== void 0 && (rf = this.$resolve, this.$resolve = this.$reject = this.$promise = void 0, rf(), rf = void 0);
  }
  Xt(e) {
    this.$promise !== void 0 && (sf = this.$reject, this.$resolve = this.$reject = this.$promise = void 0, sf(e), sf = void 0), this.$initiator !== this && this.parent.Xt(e);
  }
  zt() {
    ++this.Ot, this.$initiator !== this && this.parent.zt();
  }
  Yt() {
    if (--this.Ot === 0) {
      if (this.vmKind !== 2 && this.Ut.attached != null && (ea = Yt(...this.Ut.attached.map(hE, this))), this.$t.hasAttached && (ea = Yt(ea, this.qt.attached(this.$initiator))), an(ea)) {
        this.Gt(), ea.then(() => {
          this.state = 2, this.te(), this.$initiator !== this && this.parent.Yt();
        }).catch((e) => {
          this.Xt(e);
        }), ea = void 0;
        return;
      }
      ea = void 0, this.state = 2, this.te();
    }
    this.$initiator !== this && this.parent.Yt();
  }
  Zt() {
    ++this.Vt;
  }
  Jt() {
    if (--this.Vt === 0) {
      this.ee(), this.removeNodes();
      let e = this.$initiator.head, t;
      for (; e !== null; )
        e !== this && (e.debug && e.logger.trace("detach()"), e.removeNodes()), e.vmKind !== 2 && e.Ut.unbinding != null && (t = Yt(...e.Ut.unbinding.map(bE, this))), e.$t.hasUnbinding && (e.debug && e.logger.trace("unbinding()"), t = Yt(t, e.viewModel.unbinding(e.$initiator, e.parent))), an(t) && (this.Gt(), this.ee(), t.then(() => {
          this.ie();
        }).catch((i) => {
          this.Xt(i);
        })), t = void 0, e = e.next;
      this.ie();
    }
  }
  ee() {
    ++this.Nt;
  }
  ie() {
    if (--this.Nt === 0) {
      let e = this.$initiator.head, t = null;
      for (; e !== null; )
        e !== this && (e.isBound = !1, e.unbind()), t = e.next, e.next = null, e = t;
      this.head = this.tail = null, this.isBound = !1, this.unbind();
    }
  }
  addBinding(e) {
    this.bindings === null ? this.bindings = [e] : this.bindings[this.bindings.length] = e;
  }
  addChild(e) {
    this.children === null ? this.children = [e] : this.children[this.children.length] = e;
  }
  is(e) {
    switch (this.vmKind) {
      case 1:
        return uy(this.qt.constructor).name === e;
      case 0:
        return dy(this.qt.constructor).name === e;
      case 2:
        return this.viewFactory.name === e;
    }
  }
  lockScope(e) {
    this.scope = e, this.hasLockedScope = !0;
  }
  setHost(e) {
    return this.vmKind === 0 && (Sn(e, en, this), Sn(e, this.definition.key, this)), this.host = e, this.mountTarget = 1, this;
  }
  setShadowRoot(e) {
    return this.vmKind === 0 && (Sn(e, en, this), Sn(e, this.definition.key, this)), this.shadowRoot = e, this.mountTarget = 2, this;
  }
  setLocation(e) {
    return this.vmKind === 0 && (Sn(e, en, this), Sn(e, this.definition.key, this)), this.location = e, this.mountTarget = 3, this;
  }
  release() {
    this.state |= 16;
  }
  dispose() {
    (32 & this.state) !== 32 && (this.state |= 32, this.$t.hasDispose && this.qt.dispose(), this.children !== null && (this.children.forEach(lE), this.children = null), this.hostController = null, this.scope = null, this.nodes = null, this.location = null, this.viewFactory = null, this.qt !== null && (ns.delete(this.qt), this.qt = null), this.qt = null, this.host = null, this.shadowRoot = null, this.container.disposeResolvers());
  }
  accept(e) {
    if (e(this) === !0 || this.$t.hasAccept && this.qt.accept(e) === !0)
      return !0;
    if (this.children !== null) {
      const { children: t } = this;
      for (let i = 0, r = t.length; i < r; ++i)
        if (t[i].accept(e) === !0)
          return !0;
    }
  }
}
function E1(n) {
  let e = n.$observers;
  return e === void 0 && Reflect.defineProperty(n, "$observers", {
    enumerable: !1,
    value: e = {}
  }), e;
}
function Cb(n, e, t) {
  const i = e.bindables, r = kh(i), s = r.length;
  if (s > 0) {
    let a, o, u = 0;
    const l = E1(t), p = n.container, f = p.has(Bm, !0) ? p.get(Bm) : null;
    for (; u < s; ++u)
      a = r[u], l[a] === void 0 && (o = i[a], l[a] = new a1(t, a, o.callback, o.set, n, f));
  }
}
function sE(n, e, t) {
  const i = e.childrenObservers, r = kh(i), s = r.length;
  if (s > 0) {
    const a = E1(t), o = [];
    let u, l = 0, p;
    for (; l < s; ++l)
      u = r[l], a[u] == null && (p = i[u], o[o.length] = a[u] = new m1(n, t, u, p.callback, p.query, p.filter, p.map, p.options));
    return o;
  }
  return Fe;
}
const _b = /* @__PURE__ */ new Map(), aE = (n) => {
  let e = _b.get(n);
  return e == null && (e = new xc(n, 0), _b.set(n, e)), e;
};
function Rb(n, e, t, i) {
  const r = e.get(ka), s = e.get(hh), a = t.watches, o = n.vmKind === 0 ? n.scope : ln.create(i, null, !0), u = a.length;
  let l, p, f, b = 0;
  for (; u > b; ++b) {
    if ({ expression: l, callback: p } = a[b], p = ei(p) ? p : Reflect.get(i, p), !ei(p))
      throw re(`AUR0506:${String(p)}`);
    ei(l) ? n.addBinding(new w1(i, r, l, p, !0)) : (f = wt(l) ? s.parse(l, 16) : aE(l), n.addBinding(new Vh(o, e, r, f, p)));
  }
}
class ao {
  constructor(e) {
    this.hasDefine = "define" in e, this.hasHydrating = "hydrating" in e, this.hasHydrated = "hydrated" in e, this.hasCreated = "created" in e, this.hasBinding = "binding" in e, this.hasBound = "bound" in e, this.hasAttaching = "attaching" in e, this.hasAttached = "attached" in e, this.hasDetaching = "detaching" in e, this.hasUnbinding = "unbinding" in e, this.hasDispose = "dispose" in e, this.hasAccept = "accept" in e;
  }
}
ao.none = new ao({});
const oE = {
  mode: "open"
};
var kb;
(function(n) {
  n[n.customElement = 0] = "customElement", n[n.customAttribute = 1] = "customAttribute", n[n.synthetic = 2] = "synthetic";
})(kb || (kb = {}));
var Pb;
(function(n) {
  n[n.none = 0] = "none", n[n.activating = 1] = "activating", n[n.activated = 2] = "activated", n[n.deactivating = 4] = "deactivating", n[n.deactivated = 8] = "deactivated", n[n.released = 16] = "released", n[n.disposed = 32] = "disposed";
})(Pb || (Pb = {}));
function Ib(n) {
  const e = [];
  return (1 & n) === 1 && e.push("activating"), (2 & n) === 2 && e.push("activated"), (4 & n) === 4 && e.push("deactivating"), (8 & n) === 8 && e.push("deactivated"), (16 & n) === 16 && e.push("released"), (32 & n) === 32 && e.push("disposed"), e.length === 0 ? "none" : e.join("|");
}
const Xd = ke("IController"), Zc = ke("IHydrationContext");
class uE {
  constructor(e, t, i) {
    this.instruction = t, this.parent = i, this.controller = e;
  }
}
function lE(n) {
  n.dispose();
}
function Ob(n) {
  n.instance.created(this.qt, this);
}
function cE(n) {
  n.instance.hydrating(this.qt, this);
}
function dE(n) {
  n.instance.hydrated(this.qt, this);
}
function pE(n) {
  return n.instance.binding(this.qt, this.$initiator, this.parent);
}
function fE(n) {
  return n.instance.bound(this.qt, this.$initiator, this.parent);
}
function yE(n) {
  return n.instance.attaching(this.qt, this.$initiator, this.parent);
}
function hE(n) {
  return n.instance.attached(this.qt, this.$initiator);
}
function mE(n) {
  return n.instance.detaching(this.qt, this.$initiator, this.parent);
}
function bE(n) {
  return n.instance.unbinding(this.qt, this.$initiator, this.parent);
}
let rf, sf, ea;
const Bb = ke("IAppRoot"), gE = "au-start", vE = "au-end", Nb = (n, e) => n.document.createComment(e), xE = (n) => {
  const e = Nb(n, vE);
  return e.$start = Nb(n, gE), e;
}, TE = (n, e) => n.document.createTextNode(e), wE = (n, e, t) => n.insertBefore(e, t), rc = (n, e, t) => {
  if (n === null)
    return;
  const i = t.length;
  let r = 0;
  for (; i > r; )
    n.insertBefore(t[r], e), ++r;
}, AE = (n) => {
  const e = n.previousSibling;
  let t;
  if (e?.nodeType === 8 && e.textContent === "au-end") {
    if (t = e, (t.$start = t.previousSibling) == null)
      throw Db();
    return n.parentNode?.removeChild(n), t;
  } else
    throw Db();
}, Db = () => re("AURxxxx");
class EE {
}
function gu(n, e) {
  return n.$au?.[e] ?? null;
}
function Sn(n, e, t) {
  var i;
  ((i = n).$au ?? (i.$au = new EE()))[e] = t;
}
const xo = ke("INode");
ke("IEventTarget", (n) => n.cachedCallback((e) => e.has(Bb, !0) ? e.get(Bb).host : e.get(On).document));
const Pn = ke("IRenderLocation"), $b = ke("CssModules"), ed = /* @__PURE__ */ new WeakMap();
function ly(n) {
  if (ed.has(n))
    return ed.get(n);
  let e = 0, t = n.nextSibling;
  for (; t !== null; ) {
    if (t.nodeType === 8)
      switch (t.textContent) {
        case "au-start":
          ++e;
          break;
        case "au-end":
          if (e-- === 0)
            return t;
      }
    t = t.nextSibling;
  }
  if (n.parentNode === null && n.nodeType === 11) {
    const i = gs(n);
    if (i === void 0)
      return null;
    if (i.mountTarget === 2)
      return ly(i.host);
  }
  return n.parentNode;
}
function SE(n, e) {
  if (n.platform !== void 0 && !(n instanceof n.platform.Node)) {
    const t = n.childNodes;
    for (let i = 0, r = t.length; i < r; ++i)
      ed.set(t[i], e);
  } else
    ed.set(n, e);
}
function zh(n) {
  if (td(n))
    return n;
  const e = n.ownerDocument.createComment("au-end"), t = e.$start = n.ownerDocument.createComment("au-start"), i = n.parentNode;
  return i !== null && (i.replaceChild(e, n), i.insertBefore(t, e)), e;
}
function td(n) {
  return n.textContent === "au-end";
}
class af {
  get firstChild() {
    return this.re;
  }
  get lastChild() {
    return this.oe;
  }
  constructor(e, t) {
    this.platform = e, this.next = void 0, this.le = !1, this.he = !1, this.ref = null, this.f = t;
    const i = t.querySelectorAll(".au");
    let r = 0, s = i.length, a, o = this.t = Array(s);
    for (; s > r; )
      a = i[r], a.nodeName === "AU-M" ? o[r] = AE(a) : o[r] = a, ++r;
    const u = t.childNodes, l = this.childNodes = Array(s = u.length);
    for (r = 0; s > r; )
      l[r] = u[r], ++r;
    this.re = t.firstChild, this.oe = t.lastChild;
  }
  findTargets() {
    return this.t;
  }
  insertBefore(e) {
    if (this.he && this.ref)
      this.addToLinked();
    else {
      const t = e.parentNode;
      if (this.le) {
        let i = this.re, r;
        const s = this.oe;
        for (; i != null && (r = i.nextSibling, t.insertBefore(i, e), i !== s); )
          i = r;
      } else
        this.le = !0, e.parentNode.insertBefore(this.f, e);
    }
  }
  appendTo(e, t = !1) {
    if (this.le) {
      let i = this.re, r;
      const s = this.oe;
      for (; i != null && (r = i.nextSibling, e.appendChild(i), i !== s); )
        i = r;
    } else
      this.le = !0, t || e.appendChild(this.f);
  }
  remove() {
    if (this.le) {
      this.le = !1;
      const e = this.f, t = this.oe;
      let i, r = this.re;
      for (; r !== null && (i = r.nextSibling, e.appendChild(r), r !== t); )
        r = i;
    }
  }
  addToLinked() {
    const e = this.ref, t = e.parentNode;
    if (this.le) {
      let i = this.re, r;
      const s = this.oe;
      for (; i != null && (r = i.nextSibling, t.insertBefore(i, e), i !== s); )
        i = r;
    } else
      this.le = !0, t.insertBefore(this.f, e);
  }
  unlink() {
    this.he = !1, this.next = void 0, this.ref = void 0;
  }
  link(e) {
    this.he = !0, td(e) ? this.ref = e : (this.next = e, this.ae());
  }
  ae() {
    this.next !== void 0 ? this.ref = this.next.firstChild : this.ref = void 0;
  }
}
const S1 = ke("IWindow", (n) => n.callback((e) => e.get(On).window));
ke("ILocation", (n) => n.callback((e) => e.get(S1).location));
ke("IHistory", (n) => n.callback((e) => e.get(S1).history));
function M1(n) {
  return function(e) {
    return C1(n, e);
  };
}
const of = /* @__PURE__ */ new WeakMap();
class Wi {
  get type() {
    return 1;
  }
  constructor(e, t, i, r, s, a, o, u, l, p, f, b, A, x, w, T, _, I, $, N, B) {
    this.Type = e, this.name = t, this.aliases = i, this.key = r, this.cache = s, this.capture = a, this.template = o, this.instructions = u, this.dependencies = l, this.injectable = p, this.needsCompile = f, this.surrogates = b, this.bindables = A, this.childrenObservers = x, this.containerless = w, this.isStrictBinding = T, this.shadowOptions = _, this.hasSlots = I, this.enhance = $, this.watches = N, this.processContent = B;
  }
  static create(e, t = null) {
    if (t === null) {
      const r = e;
      if (wt(r))
        throw re(`AUR0761:${e}`);
      const s = Nn("name", r, cy);
      return ei(r.Type) ? t = r.Type : t = _1(n3(s)), new Wi(t, s, $t(r.aliases), Nn("key", r, () => Mc(s)), Nn("cache", r, uf), Nn("capture", r, En), Nn("template", r, ai), $t(r.instructions), $t(r.dependencies), Nn("injectable", r, ai), Nn("needsCompile", r, lf), $t(r.surrogates), Er.from(t, r.bindables), iu.from(r.childrenObservers), Nn("containerless", r, En), Nn("isStrictBinding", r, En), Nn("shadowOptions", r, ai), Nn("hasSlots", r, En), Nn("enhance", r, En), Nn("watches", r, CE), si("processContent", t, ai));
    }
    if (wt(e))
      return new Wi(t, e, $t(Jn(t, "aliases"), t.aliases), Mc(e), si("cache", t, uf), si("capture", t, En), si("template", t, ai), $t(Jn(t, "instructions"), t.instructions), $t(Jn(t, "dependencies"), t.dependencies), si("injectable", t, ai), si("needsCompile", t, lf), $t(Jn(t, "surrogates"), t.surrogates), Er.from(t, ...Er.getAll(t), Jn(t, "bindables"), t.bindables), iu.from(...iu.getAll(t), Jn(t, "childrenObservers"), t.childrenObservers), si("containerless", t, En), si("isStrictBinding", t, En), si("shadowOptions", t, ai), si("hasSlots", t, En), si("enhance", t, En), $t(oy.getAnnotation(t), t.watches), si("processContent", t, ai));
    const i = Nn("name", e, cy);
    return new Wi(t, i, $t(Jn(t, "aliases"), e.aliases, t.aliases), Mc(i), Ai("cache", e, t, uf), Ai("capture", e, t, En), Ai("template", e, t, ai), $t(Jn(t, "instructions"), e.instructions, t.instructions), $t(Jn(t, "dependencies"), e.dependencies, t.dependencies), Ai("injectable", e, t, ai), Ai("needsCompile", e, t, lf), $t(Jn(t, "surrogates"), e.surrogates, t.surrogates), Er.from(t, ...Er.getAll(t), Jn(t, "bindables"), t.bindables, e.bindables), iu.from(...iu.getAll(t), Jn(t, "childrenObservers"), t.childrenObservers, e.childrenObservers), Ai("containerless", e, t, En), Ai("isStrictBinding", e, t, En), Ai("shadowOptions", e, t, ai), Ai("hasSlots", e, t, En), Ai("enhance", e, t, En), $t(e.watches, oy.getAnnotation(t), t.watches), Ai("processContent", e, t, ai));
  }
  static getOrCreate(e) {
    if (e instanceof Wi)
      return e;
    if (of.has(e))
      return of.get(e);
    const t = Wi.create(e);
    return of.set(e, t), kt(en, t, t.Type), t;
  }
  register(e) {
    const { Type: t, key: i, aliases: r } = this;
    e.has(i, !1) || (o1(i, t).register(e), _l(i, t).register(e), Rl(r, po, i, e));
  }
}
const ME = {
  name: void 0,
  searchParents: !1,
  optional: !1
}, uf = () => 0, ai = () => null, En = () => !1, lf = () => !0, CE = () => Fe, en = Pa("custom-element"), Mc = (n) => `${en}:${n}`, cy = (() => {
  let n = 0;
  return () => `unnamed-${++n}`;
})(), _E = (n, e, t) => {
  kt(An(e), t, n);
}, C1 = (n, e) => {
  const t = Wi.create(n, e);
  return kt(en, t, t.Type), kt(en, t, t), Ia(t.Type, en), t.Type;
}, RE = (n) => ei(n) && Ml(en, n), gs = (n, e = ME) => {
  if (e.name === void 0 && e.searchParents !== !0) {
    const i = gu(n, en);
    if (i === null) {
      if (e.optional === !0)
        return null;
      throw re("AUR0762");
    }
    return i;
  }
  if (e.name !== void 0) {
    if (e.searchParents !== !0) {
      const s = gu(n, en);
      if (s === null)
        throw re("AUR0763");
      return s.is(e.name) ? s : void 0;
    }
    let i = n, r = !1;
    for (; i !== null; ) {
      const s = gu(i, en);
      if (s !== null && (r = !0, s.is(e.name)))
        return s;
      i = ly(i);
    }
    if (r)
      return;
    throw re("AUR0764");
  }
  let t = n;
  for (; t !== null; ) {
    const i = gu(t, en);
    if (i !== null)
      return i;
    t = ly(t);
  }
  throw re("AUR0765");
}, Jn = (n, e) => wn(An(e), n), dy = (n) => {
  const e = wn(en, n);
  if (e === void 0)
    throw re(`AUR0760:${n.name}`);
  return e;
}, kE = () => {
  const n = function(e, t, i) {
    const r = ye.getOrCreateAnnotationParamTypes(e);
    return r[i] = n, e;
  };
  return n.register = function(e) {
    return {
      resolve(t, i) {
        return i.has(n, !0) ? i.get(n) : null;
      }
    };
  }, n;
}, _1 = function() {
  const n = {
    value: "",
    writable: !1,
    enumerable: !1,
    configurable: !0
  }, e = {};
  return function(t, i = e) {
    const r = class {
    };
    return n.value = t, Reflect.defineProperty(r, "name", n), i !== e && Rh(r.prototype, i), r;
  };
}(), po = dr({
  name: en,
  keyFrom: Mc,
  isType: RE,
  for: gs,
  define: C1,
  getDefinition: dy,
  annotate: _E,
  getAnnotation: Jn,
  generateName: cy,
  createInjectable: kE,
  generateType: _1
});
An("processContent");
ke("IProjections");
const R1 = ke("IAuSlotsInfo");
class k1 {
  constructor(e) {
    this.projectedSlots = e;
  }
}
var Fb;
(function(n) {
  n.hydrateElement = "ra", n.hydrateAttribute = "rb", n.hydrateTemplateController = "rc", n.hydrateLetElement = "rd", n.setProperty = "re", n.interpolation = "rf", n.propertyBinding = "rg", n.letBinding = "ri", n.refBinding = "rj", n.iteratorBinding = "rk", n.multiAttr = "rl", n.textBinding = "ha", n.listenerBinding = "hb", n.attributeBinding = "hc", n.stylePropertyBinding = "hd", n.setAttribute = "he", n.setClassAttribute = "hf", n.setStyleAttribute = "hg", n.spreadBinding = "hs", n.spreadElementProp = "hp";
})(Fb || (Fb = {}));
const zo = ke("Instruction");
class Dl {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.mode = i, this.type = "rg";
  }
}
class PE {
  constructor(e, t, i) {
    this.forOf = e, this.to = t, this.props = i, this.type = "rk";
  }
}
class IE {
  constructor(e, t) {
    this.from = e, this.to = t, this.type = "rj";
  }
}
class OE {
  constructor(e, t, i) {
    this.value = e, this.to = t, this.command = i, this.type = "rl";
  }
}
class P1 {
  constructor(e, t, i, r) {
    this.from = e, this.to = t, this.preventDefault = i, this.capture = r, this.type = "hb";
  }
}
class Gh {
  constructor(e, t, i) {
    this.attr = e, this.from = t, this.to = i, this.type = "hc";
  }
}
class BE {
  constructor() {
    this.type = "hs";
  }
}
const I1 = ke("ITemplateCompiler"), O1 = ke("IRenderer");
function jt(n) {
  return function(t) {
    return t.register = function(i) {
      Vo(O1, this).register(i);
    }, d8(t.prototype, "target", {
      configurable: !0,
      get: function() {
        return n;
      }
    }), t;
  };
}
function Hr(n, e, t) {
  return wt(e) ? n.parse(e, t) : e;
}
function Zd(n) {
  return n.viewModel != null ? n.viewModel : n;
}
function NE(n, e) {
  if (e === "element")
    return n;
  switch (e) {
    case "controller":
      return gs(n);
    case "view":
      throw re("AUR0750");
    case "view-model":
      return gs(n).viewModel;
    default: {
      const t = h1(n, e);
      if (t !== void 0)
        return t.viewModel;
      const i = gs(n, {
        name: e
      });
      if (i === void 0)
        throw re(`AUR0751:${e}`);
      return i.viewModel;
    }
  }
}
let Lb = class {
  render(e, t, i) {
    const r = Zd(t);
    r.$observers?.[i.to] !== void 0 ? r.$observers[i.to].setValue(i.value) : r[i.to] = i.value;
  }
};
Lb = X([jt("re")], Lb);
let Ub = class {
  static get inject() {
    return [Ba];
  }
  constructor(e) {
    this.r = e;
  }
  render(e, t, i, r, s, a) {
    let o, u, l, p;
    const f = i.res, b = i.projections, A = e.container;
    switch (typeof f) {
      case "string":
        if (o = A.find(po, f), o == null)
          throw re(`AUR0752:${f}@${e.name}`);
        break;
      default:
        o = f;
    }
    const w = i.containerless || o.containerless ? zh(t) : null, T = UE(r, e, t, i, w, b == null ? void 0 : new k1(Ph(b)));
    u = o.Type, l = T.invoke(u), Tt(T, u, new on(o.key, l)), p = pi.$el(T, l, t, i, o, w), Sn(t, o.key, p);
    const _ = this.r.renderers, I = i.props, $ = I.length;
    let N = 0, B;
    for (; $ > N; )
      B = I[N], _[B.type].render(e, p, B, r, s, a), ++N;
    e.addChild(p);
  }
};
Ub = X([jt("ra")], Ub);
let Vb = class {
  static get inject() {
    return [Ba];
  }
  constructor(e) {
    this.r = e;
  }
  render(e, t, i, r, s, a) {
    let o = e.container, u;
    switch (typeof i.res) {
      case "string":
        if (u = o.find(Lh, i.res), u == null)
          throw re(`AUR0753:${i.res}@${e.name}`);
        break;
      default:
        u = i.res;
    }
    const l = $1(r, u, e, t, i, void 0, void 0), p = pi.$attr(l.ctn, l.vm, t, u);
    Sn(t, u.key, p);
    const f = this.r.renderers, b = i.props, A = b.length;
    let x = 0, w;
    for (; A > x; )
      w = b[x], f[w.type].render(e, p, w, r, s, a), ++x;
    e.addChild(p);
  }
};
Vb = X([jt("rb")], Vb);
let jb = class {
  static get inject() {
    return [Ba, On];
  }
  constructor(e, t) {
    this.r = e, this.p = t;
  }
  render(e, t, i, r, s, a) {
    let o = e.container, u;
    switch (typeof i.res) {
      case "string":
        if (u = o.find(Lh, i.res), u == null)
          throw re(`AUR0754:${i.res}@${e.name}`);
        break;
      default:
        u = i.res;
    }
    const l = this.r.getViewFactory(i.def, o), p = zh(t), f = $1(this.p, u, e, t, i, l, p), b = pi.$attr(f.ctn, f.vm, t, u);
    Sn(p, u.key, b), f.vm.link?.(e, b, t, i);
    const A = this.r.renderers, x = i.props, w = x.length;
    let T = 0, _;
    for (; w > T; )
      _ = x[T], A[_.type].render(e, b, _, r, s, a), ++T;
    e.addChild(b);
  }
};
jb = X([jt("rc")], jb);
let zb = class {
  render(e, t, i, r, s, a) {
    t.remove();
    const o = i.instructions, u = i.toBindingContext, l = e.container, p = o.length;
    let f, b, A = 0;
    for (; p > A; )
      f = o[A], b = Hr(s, f.from, 16), e.addBinding(new Bl(l, a, b, f.to, u)), ++A;
  }
};
zb = X([jt("rd")], zb);
let Gb = class {
  render(e, t, i, r, s) {
    e.addBinding(new f1(e.container, Hr(s, i.from, 16), NE(t, i.to)));
  }
};
Gb = X([jt("rj")], Gb);
let qb = class {
  render(e, t, i, r, s, a) {
    e.addBinding(new F8(e, e.container, a, r.domWriteQueue, Hr(s, i.from, 1), Zd(t), i.to, 2));
  }
};
qb = X([jt("rf")], qb);
let Hb = class {
  render(e, t, i, r, s, a) {
    e.addBinding(new qr(e, e.container, a, r.domWriteQueue, Hr(s, i.from, 16), Zd(t), i.to, i.mode));
  }
};
Hb = X([jt("rg")], Hb);
let Kb = class {
  render(e, t, i, r, s, a) {
    e.addBinding(new qr(e, e.container, a, r.domWriteQueue, Hr(s, i.forOf, 2), Zd(t), i.to, 2));
  }
};
Kb = X([jt("rk")], Kb);
let Wb = class {
  render(e, t, i, r, s, a) {
    e.addBinding(new Ol(e, e.container, a, r.domWriteQueue, r, Hr(s, i.from, 16), wE(t.parentNode, TE(r, ""), t), i.strict));
  }
};
Wb = X([jt("ha")], Wb);
let Jb = class {
  render(e, t, i, r, s) {
    e.addBinding(new Nl(e.container, Hr(s, i.from, 8), t, i.to, new U8(i.preventDefault, i.capture)));
  }
};
Jb = X([jt("hb")], Jb);
let Qb = class {
  render(e, t, i) {
    t.setAttribute(i.to, i.value);
  }
};
Qb = X([jt("he")], Qb);
let Yb = class {
  render(e, t, i) {
    $E(t.classList, i.value);
  }
};
Yb = X([jt("hf")], Yb);
let Xb = class {
  render(e, t, i) {
    t.style.cssText += i.value;
  }
};
Xb = X([jt("hg")], Xb);
let Zb = class {
  render(e, t, i, r, s, a) {
    e.addBinding(new qr(e, e.container, a, r.domWriteQueue, Hr(s, i.from, 16), t.style, i.to, 2));
  }
};
Zb = X([jt("hd")], Zb);
let eg = class {
  render(e, t, i, r, s, a) {
    const o = e.container, u = o.has($b, !1) ? o.get($b) : null;
    e.addBinding(new Pl(e, o, a, r.domWriteQueue, Hr(s, i.from, 16), t, i.attr, u == null ? i.to : i.to.split(/\s/g).map((l) => u[l] ?? l).join(" "), 2));
  }
};
eg = X([jt("hc")], eg);
let tg = class {
  static get inject() {
    return [I1, Ba];
  }
  constructor(e, t) {
    this.ce = e, this.r = t;
  }
  render(e, t, i, r, s, a) {
    const u = e.container.get(Zc), l = this.r.renderers, p = (b) => {
      let A = b, x = u;
      for (; x != null && A > 0; )
        x = x.parent, --A;
      if (x == null)
        throw re("No scope context for spread binding.");
      return x;
    }, f = (b) => {
      const A = p(b), x = FE(A), w = this.ce.compileSpread(A.controller.definition, A.instruction?.captures ?? Fe, A.controller.container, t);
      let T;
      for (T of w)
        switch (T.type) {
          case "hs":
            f(b + 1);
            break;
          case "hp":
            l[T.instructions.type].render(x, gs(t), T.instructions, r, s, a);
            break;
          default:
            l[T.type].render(x, t, T, r, s, a);
        }
      e.addBinding(x);
    };
    f(0);
  }
};
tg = X([jt("hs")], tg);
class DE {
  get container() {
    return this.locator;
  }
  get definition() {
    return this.ctrl.definition;
  }
  get isStrictBinding() {
    return this.ctrl.isStrictBinding;
  }
  get state() {
    return this.ctrl.state;
  }
  constructor(e, t) {
    this.ue = e, this.fe = t, this.isBound = !1, this.ctrl = t.controller, this.locator = this.ctrl.container;
  }
  get(e) {
    return this.locator.get(e);
  }
  bind(e) {
    if (this.isBound)
      return;
    this.isBound = !0;
    const t = this.scope = this.fe.controller.scope.parent ?? void 0;
    if (t == null)
      throw re("Invalid spreading. Context scope is null/undefined");
    this.ue.forEach((i) => i.bind(t));
  }
  unbind() {
    this.ue.forEach((e) => e.unbind()), this.isBound = !1;
  }
  addBinding(e) {
    this.ue.push(e);
  }
  addChild(e) {
    if (e.vmKind !== 1)
      throw re("Spread binding does not support spreading custom attributes/template controllers");
    this.ctrl.addChild(e);
  }
  limit() {
    throw re("not implemented");
  }
  useScope() {
    throw re("not implemented");
  }
}
function $E(n, e) {
  const t = e.length;
  let i = 0;
  for (let r = 0; r < t; ++r)
    e.charCodeAt(r) === 32 ? (r !== i && n.add(e.slice(i, r)), i = r + 1) : r + 1 === t && n.add(e.slice(i));
}
const FE = (n) => new DE([], n), B1 = "IController", N1 = "IInstruction", LE = "IRenderLocation", qh = "IAuSlotsInfo";
function UE(n, e, t, i, r, s) {
  const a = e.container.createChild();
  return Tt(a, n.HTMLElement, Tt(a, n.Element, Tt(a, xo, new on("ElementResolver", t)))), Tt(a, Xd, new on(B1, e)), Tt(a, zo, new on(N1, i)), Tt(a, Pn, r == null ? L1 : new F1(r)), Tt(a, ii, U1), Tt(a, R1, s == null ? V1 : new on(qh, s)), a;
}
class D1 {
  get $isResolver() {
    return !0;
  }
  constructor(e) {
    this.f = e;
  }
  resolve() {
    const e = this.f;
    if (e === null)
      throw re("AUR7055");
    if (!wt(e.name) || e.name.length === 0)
      throw re("AUR0756");
    return e;
  }
}
function $1(n, e, t, i, r, s, a, o) {
  const u = t.container.createChild();
  return Tt(u, n.HTMLElement, Tt(u, n.Element, Tt(u, xo, new on("ElementResolver", i)))), t = t instanceof pi ? t : t.ctrl, Tt(u, Xd, new on(B1, t)), Tt(u, zo, new on(N1, r)), Tt(u, Pn, a == null ? L1 : new on(LE, a)), Tt(u, ii, s == null ? U1 : new D1(s)), Tt(u, R1, o == null ? V1 : new on(qh, o)), {
    vm: u.invoke(e.Type),
    ctn: u
  };
}
class F1 {
  get name() {
    return "IRenderLocation";
  }
  get $isResolver() {
    return !0;
  }
  constructor(e) {
    this.l = e;
  }
  resolve() {
    return this.l;
  }
}
const L1 = new F1(null), U1 = new D1(null), V1 = new on(qh, new k1(Fe));
var ng;
(function(n) {
  n[n.None = 0] = "None", n[n.IgnoreAttr = 1] = "IgnoreAttr";
})(ng || (ng = {}));
function Wn(n) {
  return function(e) {
    return z1.define(n, e);
  };
}
class Hh {
  constructor(e, t, i, r, s) {
    this.Type = e, this.name = t, this.aliases = i, this.key = r, this.type = s;
  }
  static create(e, t) {
    let i, r;
    return wt(e) ? (i = e, r = {
      name: i
    }) : (i = e.name, r = e), new Hh(t, hn(Cc(t, "name"), i), $t(Cc(t, "aliases"), r.aliases, t.aliases), j1(i), hn(Cc(t, "type"), r.type, t.type, null));
  }
  register(e) {
    const { Type: t, key: i, aliases: r } = this;
    Vo(i, t).register(e), _l(i, t).register(e), Rl(r, z1, i, e);
  }
}
const vu = Pa("binding-command"), j1 = (n) => `${vu}:${n}`, Cc = (n, e) => wn(An(e), n), z1 = dr({
  name: vu,
  keyFrom: j1,
  define(n, e) {
    const t = Hh.create(n, e);
    return kt(vu, t, t.Type), kt(vu, t, t), Ia(e, vu), t.Type;
  },
  getAnnotation: Cc
});
let ig = class {
  get type() {
    return 0;
  }
  build(e, t, i) {
    let s = e.attr.target, a = e.attr.rawValue;
    return e.bindable == null ? s = i.map(e.node, s) ?? ti(s) : (a === "" && e.def.type === 1 && (a = ti(s)), s = e.bindable.property), new Dl(t.parse(a, 16), s, 1);
  }
};
ig = X([Wn("one-time")], ig);
let rg = class {
  get type() {
    return 0;
  }
  build(e, t, i) {
    let s = e.attr.target, a = e.attr.rawValue;
    return e.bindable == null ? s = i.map(e.node, s) ?? ti(s) : (a === "" && e.def.type === 1 && (a = ti(s)), s = e.bindable.property), new Dl(t.parse(a, 16), s, 2);
  }
};
rg = X([Wn("to-view")], rg);
let sg = class {
  get type() {
    return 0;
  }
  build(e, t, i) {
    const r = e.attr;
    let s = r.target, a = r.rawValue;
    return e.bindable == null ? s = i.map(e.node, s) ?? ti(s) : (a === "" && e.def.type === 1 && (a = ti(s)), s = e.bindable.property), new Dl(t.parse(a, 16), s, 4);
  }
};
sg = X([Wn("from-view")], sg);
let ag = class {
  get type() {
    return 0;
  }
  build(e, t, i) {
    const r = e.attr;
    let s = r.target, a = r.rawValue;
    return e.bindable == null ? s = i.map(e.node, s) ?? ti(s) : (a === "" && e.def.type === 1 && (a = ti(s)), s = e.bindable.property), new Dl(t.parse(a, 16), s, 6);
  }
};
ag = X([Wn("two-way")], ag);
let og = class {
  get type() {
    return 0;
  }
  build(e, t, i) {
    const r = e.attr, s = e.bindable;
    let a, o, u = r.target, l = r.rawValue;
    return s == null ? (o = i.isTwoWay(e.node, u) ? 6 : 2, u = i.map(e.node, u) ?? ti(u)) : (l === "" && e.def.type === 1 && (l = ti(u)), a = e.def.defaultBindingMode, o = s.mode === 8 || s.mode == null ? a == null || a === 8 ? 2 : a : s.mode, u = s.property), new Dl(t.parse(l, 16), u, o);
  }
};
og = X([Wn("bind")], og);
let ug = class {
  get type() {
    return 0;
  }
  static get inject() {
    return [E8];
  }
  constructor(e) {
    this.de = e;
  }
  build(e, t) {
    const i = e.bindable === null ? ti(e.attr.target) : e.bindable.property, r = t.parse(e.attr.rawValue, 2);
    let s = Fe;
    if (r.semiIdx > -1) {
      const a = e.attr.rawValue.slice(r.semiIdx + 1), o = a.indexOf(":");
      if (o > -1) {
        const u = a.slice(0, o).trim(), l = a.slice(o + 1).trim(), p = this.de.parse(u, l);
        s = [new OE(l, p.target, p.command)];
      }
    }
    return new PE(r, i, s);
  }
};
ug = X([Wn("for")], ug);
let lg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new P1(t.parse(e.attr.rawValue, 8), e.attr.target, !0, !1);
  }
};
lg = X([Wn("trigger")], lg);
let cg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new P1(t.parse(e.attr.rawValue, 8), e.attr.target, !1, !0);
  }
};
cg = X([Wn("capture")], cg);
let dg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Gh(e.attr.target, t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
dg = X([Wn("attr")], dg);
let pg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Gh("style", t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
pg = X([Wn("style")], pg);
let fg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new Gh("class", t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
fg = X([Wn("class")], fg);
let yg = class {
  get type() {
    return 1;
  }
  build(e, t) {
    return new IE(t.parse(e.attr.rawValue, 16), e.attr.target);
  }
};
yg = X([Wn("ref")], yg);
let hg = class {
  get type() {
    return 1;
  }
  build(e) {
    return new BE();
  }
};
hg = X([Wn("...$attrs")], hg);
const G1 = ke("ISVGAnalyzer", (n) => n.singleton(VE));
class VE {
  isStandardSvgAttribute(e, t) {
    return !1;
  }
}
ke("IAttrMapper", (n) => n.singleton(jE));
class jE {
  static get inject() {
    return [G1];
  }
  constructor(e) {
    this.svg = e, this.fns = [], this.ve = yn(), this.xe = yn(), this.useMapping({
      LABEL: {
        for: "htmlFor"
      },
      IMG: {
        usemap: "useMap"
      },
      INPUT: {
        maxlength: "maxLength",
        minlength: "minLength",
        formaction: "formAction",
        formenctype: "formEncType",
        formmethod: "formMethod",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        inputmode: "inputMode"
      },
      TEXTAREA: {
        maxlength: "maxLength"
      },
      TD: {
        rowspan: "rowSpan",
        colspan: "colSpan"
      },
      TH: {
        rowspan: "rowSpan",
        colspan: "colSpan"
      }
    }), this.useGlobalMapping({
      accesskey: "accessKey",
      contenteditable: "contentEditable",
      tabindex: "tabIndex",
      textcontent: "textContent",
      innerhtml: "innerHTML",
      scrolltop: "scrollTop",
      scrollleft: "scrollLeft",
      readonly: "readOnly"
    });
  }
  useMapping(e) {
    var t;
    let i, r, s, a;
    for (s in e) {
      i = e[s], r = (t = this.ve)[s] ?? (t[s] = yn());
      for (a in i) {
        if (r[a] !== void 0)
          throw mg(a, s);
        r[a] = i[a];
      }
    }
  }
  useGlobalMapping(e) {
    const t = this.xe;
    for (const i in e) {
      if (t[i] !== void 0)
        throw mg(i, "*");
      t[i] = e[i];
    }
  }
  useTwoWay(e) {
    this.fns.push(e);
  }
  isTwoWay(e, t) {
    return zE(e, t) || this.fns.length > 0 && this.fns.some((i) => i(e, t));
  }
  map(e, t) {
    return this.ve[e.nodeName]?.[t] ?? this.xe[t] ?? (ny(e, t, this.svg) ? t : null);
  }
}
function zE(n, e) {
  switch (n.nodeName) {
    case "INPUT":
      switch (n.type) {
        case "checkbox":
        case "radio":
          return e === "checked";
        default:
          return e === "value" || e === "files" || e === "value-as-number" || e === "value-as-date";
      }
    case "TEXTAREA":
    case "SELECT":
      return e === "value";
    default:
      switch (e) {
        case "textcontent":
        case "innerhtml":
          return n.hasAttribute("contenteditable");
        case "scrolltop":
        case "scrollleft":
          return !0;
        default:
          return !1;
      }
  }
}
function mg(n, e) {
  return re(`Attribute ${n} has been already registered for ${e === "*" ? "all elements" : `<${e}/>`}`);
}
ke("ITemplateElementFactory", (n) => n.singleton(q1));
const bg = {};
class q1 {
  constructor(e) {
    this.p = e, this.we = cf(this.p);
  }
  createTemplate(e) {
    if (wt(e)) {
      let t = bg[e];
      if (t === void 0) {
        const i = this.we;
        i.innerHTML = e;
        const r = i.content.firstElementChild;
        r == null || r.nodeName !== "TEMPLATE" || r.nextElementSibling != null ? (this.we = cf(this.p), t = i) : (i.content.removeChild(r), t = r), bg[e] = t;
      }
      return t.cloneNode(!0);
    }
    if (e.nodeName !== "TEMPLATE") {
      const t = cf(this.p);
      return t.content.appendChild(e), t;
    }
    return e.parentNode?.removeChild(e), e.cloneNode(!0);
  }
}
q1.inject = [On];
const cf = (n) => n.document.createElement("template");
Rh(yn(), {
  id: !0,
  name: !0,
  "au-slot": !0,
  "as-element": !0
});
ke("ITemplateCompilerHooks");
Pa("compiler-hooks");
const df = /* @__PURE__ */ new Map();
class ep {
  bind(e, t) {
    df.set(t, t.mode), t.mode = this.mode;
  }
  unbind(e, t) {
    t.mode = df.get(t), df.delete(t);
  }
}
class GE extends ep {
  get mode() {
    return 1;
  }
}
class qE extends ep {
  get mode() {
    return 2;
  }
}
class HE extends ep {
  get mode() {
    return 4;
  }
}
class KE extends ep {
  get mode() {
    return 6;
  }
}
Kn("oneTime")(GE);
Kn("toView")(qE);
Kn("fromView")(HE);
Kn("twoWay")(KE);
const pf = /* @__PURE__ */ new WeakMap(), WE = 200;
class H1 {
  constructor(e) {
    this.p = e;
  }
  bind(e, t, i) {
    i = Number(i);
    const r = {
      type: "debounce",
      delay: i > 0 ? i : WE,
      now: this.p.performanceNow,
      queue: this.p.taskQueue
    }, s = t.limit?.(r);
    s == null || pf.set(t, s);
  }
  unbind(e, t) {
    pf.get(t)?.dispose(), pf.delete(t);
  }
}
H1.inject = [wl];
Kn("debounce")(H1);
class K1 {
  constructor(e) {
    this.Ne = /* @__PURE__ */ new Map(), this.je = e;
  }
  bind(e, t, ...i) {
    if (!("handleChange" in t))
      throw re("AUR0817");
    if (i.length === 0)
      throw re("AUR0818");
    this.Ne.set(t, i);
    let r;
    for (r of i)
      this.je.addSignalListener(r, t);
  }
  unbind(e, t) {
    const i = this.Ne.get(t);
    this.Ne.delete(t);
    let r;
    for (r of i)
      this.je.removeSignalListener(r, t);
  }
}
K1.inject = [Sh];
Kn("signal")(K1);
const ff = /* @__PURE__ */ new WeakMap(), JE = 200;
class W1 {
  constructor(e) {
    this.He = e.performanceNow, this.ct = e.taskQueue;
  }
  bind(e, t, i) {
    i = Number(i);
    const r = {
      type: "throttle",
      delay: i > 0 ? i : JE,
      now: this.He,
      queue: this.ct
    }, s = t.limit?.(r);
    s == null || ff.set(t, s);
  }
  unbind(e, t) {
    ff.get(t)?.dispose(), ff.delete(t);
  }
}
W1.inject = [wl];
Kn("throttle")(W1);
class J1 {
  constructor() {
    this.type = 6;
  }
  getValue(e, t) {
    return e.getAttribute(t);
  }
  setValue(e, t, i) {
    e == null ? t.removeAttribute(i) : t.setAttribute(i, e);
  }
}
Qd(J1);
const _c = new J1();
class QE {
  bind(e, t) {
    if (!(t instanceof qr))
      throw re("AURxxxx");
    t.useTargetObserver(_c);
  }
}
Kn("attr")(QE);
class YE {
  bind(e, t) {
    if (!(t instanceof Nl))
      throw re("AUR0801");
    t.self = !0;
  }
  unbind(e, t) {
    t.self = !1;
  }
}
Kn("self")(YE);
const gg = yn();
class Ju {
  static forNs(e) {
    return gg[e] ?? (gg[e] = new Ju(e));
  }
  constructor(e) {
    this.ns = e, this.type = 6;
  }
  getValue(e, t) {
    return e.getAttributeNS(this.ns, t);
  }
  setValue(e, t, i) {
    e == null ? t.removeAttributeNS(this.ns, i) : t.setAttributeNS(this.ns, i, e);
  }
}
Qd(Ju);
function vg(n, e) {
  return n === e;
}
class Kh {
  constructor(e, t, i, r) {
    this.type = 7, this.v = void 0, this.ov = void 0, this.We = void 0, this.ze = void 0, this.yt = !1, this.bt = e, this.oL = r, this.cf = i;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    const t = this.v;
    e !== t && (this.v = e, this.ov = t, this.Ge(), this.Xe(), this.st());
  }
  handleCollectionChange() {
    this.Xe();
  }
  handleChange(e, t) {
    this.Xe();
  }
  Xe() {
    const e = this.v, t = this.bt, i = bs.call(t, "model") ? t.model : t.value, r = t.type === "radio", s = t.matcher !== void 0 ? t.matcher : vg;
    if (r)
      t.checked = !!s(e, i);
    else if (e === !0)
      t.checked = !0;
    else {
      let a = !1;
      if (Fi(e))
        a = e.findIndex((o) => !!s(o, i)) !== -1;
      else if (e instanceof Set) {
        for (const o of e)
          if (s(o, i)) {
            a = !0;
            break;
          }
      } else if (e instanceof Map)
        for (const o of e) {
          const u = o[0], l = o[1];
          if (s(u, i) && l === !0) {
            a = !0;
            break;
          }
        }
      t.checked = a;
    }
  }
  handleEvent() {
    let e = this.ov = this.v;
    const t = this.bt, i = bs.call(t, "model") ? t.model : t.value, r = t.checked, s = t.matcher !== void 0 ? t.matcher : vg;
    if (t.type === "checkbox") {
      if (Fi(e)) {
        const a = e.findIndex((o) => !!s(o, i));
        r && a === -1 ? e.push(i) : !r && a !== -1 && e.splice(a, 1);
        return;
      } else if (e instanceof Set) {
        const a = {};
        let o = a;
        for (const u of e)
          if (s(u, i) === !0) {
            o = u;
            break;
          }
        r && o === a ? e.add(i) : !r && o !== a && e.delete(o);
        return;
      } else if (e instanceof Map) {
        let a;
        for (const o of e) {
          const u = o[0];
          if (s(u, i) === !0) {
            a = u;
            break;
          }
        }
        e.set(a, r);
        return;
      }
      e = r;
    } else if (r)
      e = i;
    else
      return;
    this.v = e, this.st();
  }
  kt() {
    this.Ge();
  }
  At() {
    this.We?.unsubscribe(this), this.ze?.unsubscribe(this), this.We = this.ze = void 0;
  }
  st() {
    xg = this.ov, this.ov = this.v, this.subs.notify(this.v, xg);
  }
  Ge() {
    const e = this.bt;
    (this.ze ?? (this.ze = e.$observers?.model ?? e.$observers?.value))?.subscribe(this), this.We?.unsubscribe(this), this.We = void 0, e.type === "checkbox" && (this.We = t7(this.v, this.oL))?.subscribe(this);
  }
}
Uh(Kh);
In(Kh);
let xg;
const XE = {
  childList: !0,
  subtree: !0,
  characterData: !0
};
function Tg(n, e) {
  return n === e;
}
class Wh {
  constructor(e, t, i, r) {
    this.type = 7, this.v = void 0, this.ov = void 0, this.J = !1, this.Ke = void 0, this.Qe = void 0, this.iO = !1, this.yt = !1, this.bt = e, this.oL = r, this.cf = i;
  }
  getValue() {
    return this.iO ? this.v : this.bt.multiple ? ZE(this.bt.options) : this.bt.value;
  }
  setValue(e) {
    this.ov = this.v, this.v = e, this.J = e !== this.ov, this.Ye(e instanceof Array ? e : null), this.it();
  }
  it() {
    this.J && (this.J = !1, this.syncOptions());
  }
  handleCollectionChange() {
    this.syncOptions();
  }
  syncOptions() {
    const e = this.v, t = this.bt, i = Fi(e), r = t.matcher ?? Tg, s = t.options;
    let a = s.length;
    for (; a-- > 0; ) {
      const o = s[a], u = bs.call(o, "model") ? o.model : o.value;
      if (i) {
        o.selected = e.findIndex((l) => !!r(u, l)) !== -1;
        continue;
      }
      o.selected = !!r(u, e);
    }
  }
  syncValue() {
    const e = this.bt, t = e.options, i = t.length, r = this.v;
    let s = 0;
    if (e.multiple) {
      if (!(r instanceof Array))
        return !0;
      let u;
      const l = e.matcher || Tg, p = [];
      for (; s < i; )
        u = t[s], u.selected && p.push(bs.call(u, "model") ? u.model : u.value), ++s;
      let f;
      for (s = 0; s < r.length; )
        f = r[s], p.findIndex((b) => !!l(f, b)) === -1 ? r.splice(s, 1) : ++s;
      for (s = 0; s < p.length; )
        f = p[s], r.findIndex((b) => !!l(f, b)) === -1 && r.push(f), ++s;
      return !1;
    }
    let a = null, o;
    for (; s < i; ) {
      if (o = t[s], o.selected) {
        a = bs.call(o, "model") ? o.model : o.value;
        break;
      }
      ++s;
    }
    return this.ov = this.v, this.v = a, !0;
  }
  kt() {
    (this.Qe = new this.bt.ownerDocument.defaultView.MutationObserver(this.Ze.bind(this))).observe(this.bt, XE), this.Ye(this.v instanceof Array ? this.v : null), this.iO = !0;
  }
  At() {
    this.Qe.disconnect(), this.Ke?.unsubscribe(this), this.Qe = this.Ke = void 0, this.iO = !1;
  }
  Ye(e) {
    if (this.Ke?.unsubscribe(this), this.Ke = void 0, e != null) {
      if (!this.bt.multiple)
        throw re("AUR0654");
      (this.Ke = this.oL.getArrayObserver(e)).subscribe(this);
    }
  }
  handleEvent() {
    this.syncValue() && this.st();
  }
  Ze(e) {
    this.syncOptions(), this.syncValue() && this.st();
  }
  st() {
    wg = this.ov, this.ov = this.v, this.subs.notify(this.v, wg);
  }
}
Uh(Wh);
In(Wh);
function ZE(n) {
  const e = [];
  if (n.length === 0)
    return e;
  const t = n.length;
  let i = 0, r;
  for (; t > i; )
    r = n[i], r.selected && (e[e.length] = bs.call(r, "model") ? r.model : r.value), ++i;
  return e;
}
let wg;
const e7 = "--";
class Q1 {
  constructor(e) {
    this.obj = e, this.type = 6, this.v = "", this.ov = "", this.styles = {}, this.version = 0, this.J = !1;
  }
  getValue() {
    return this.obj.style.cssText;
  }
  setValue(e) {
    this.v = e, this.J = e !== this.ov, this.it();
  }
  Je(e) {
    const t = [], i = /url\([^)]+$/;
    let r = 0, s = "", a, o, u, l;
    for (; r < e.length; ) {
      if (a = e.indexOf(";", r), a === -1 && (a = e.length), s += e.substring(r, a), r = a + 1, i.test(s)) {
        s += ";";
        continue;
      }
      o = s.indexOf(":"), u = s.substring(0, o).trim(), l = s.substring(o + 1).trim(), t.push([u, l]), s = "";
    }
    return t;
  }
  ti(e) {
    let t, i;
    const r = [];
    for (i in e)
      if (t = e[i], t != null) {
        if (wt(t)) {
          if (i.startsWith(e7)) {
            r.push([i, t]);
            continue;
          }
          r.push([ux(i), t]);
          continue;
        }
        r.push(...this.ei(t));
      }
    return r;
  }
  ii(e) {
    const t = e.length;
    if (t > 0) {
      const i = [];
      let r = 0;
      for (; t > r; ++r)
        i.push(...this.ei(e[r]));
      return i;
    }
    return Fe;
  }
  ei(e) {
    return wt(e) ? this.Je(e) : e instanceof Array ? this.ii(e) : e instanceof Object ? this.ti(e) : Fe;
  }
  it() {
    if (this.J) {
      this.J = !1;
      const e = this.v, t = this.styles, i = this.ei(e);
      let r, s = this.version;
      this.ov = e;
      let a, o, u, l = 0;
      const p = i.length;
      for (; l < p; ++l)
        a = i[l], o = a[0], u = a[1], this.setProperty(o, u), t[o] = s;
      if (this.styles = t, this.version += 1, s === 0)
        return;
      s -= 1;
      for (r in t)
        !bs.call(t, r) || t[r] !== s || this.obj.style.removeProperty(r);
    }
  }
  setProperty(e, t) {
    let i = "";
    t != null && ei(t.indexOf) && t.includes("!important") && (i = "important", t = t.replace("!important", "")), this.obj.style.setProperty(e, t, i);
  }
  bind() {
    this.v = this.ov = this.obj.style.cssText;
  }
}
Qd(Q1);
class Jh {
  constructor(e, t, i) {
    this.type = 7, this.v = "", this.ov = "", this.J = !1, this.yt = !1, this.bt = e, this.k = t, this.cf = i;
  }
  getValue() {
    return this.v;
  }
  setValue(e) {
    Cl(e, this.v) || (this.ov = this.v, this.v = e, this.J = !0, this.cf.readonly || this.it());
  }
  it() {
    this.J && (this.J = !1, this.bt[this.k] = this.v ?? this.cf.default, this.st());
  }
  handleEvent() {
    this.ov = this.v, this.v = this.bt[this.k], this.ov !== this.v && (this.J = !1, this.st());
  }
  kt() {
    this.v = this.ov = this.bt[this.k];
  }
  st() {
    Ag = this.ov, this.ov = this.v, this.subs.notify(this.v, Ag);
  }
}
Uh(Jh);
In(Jh);
let Ag;
const ta = "http://www.w3.org/1999/xlink", Eg = "http://www.w3.org/XML/1998/namespace", Sg = "http://www.w3.org/2000/xmlns/", Mg = Rh(yn(), {
  "xlink:actuate": ["actuate", ta],
  "xlink:arcrole": ["arcrole", ta],
  "xlink:href": ["href", ta],
  "xlink:role": ["role", ta],
  "xlink:show": ["show", ta],
  "xlink:title": ["title", ta],
  "xlink:type": ["type", ta],
  "xml:lang": ["lang", Eg],
  "xml:space": ["space", Eg],
  xmlns: ["xmlns", Sg],
  "xmlns:xlink": ["xlink", Sg]
}), Y1 = new e1();
Y1.type = 6;
class Qu {
  constructor(e, t, i, r) {
    this.locator = e, this.platform = t, this.dirtyChecker = i, this.svgAnalyzer = r, this.allowDirtyCheck = !0, this.si = yn(), this.ni = yn(), this.ri = yn(), this.oi = yn();
    const s = ["change", "input"], a = {
      events: s,
      default: ""
    };
    this.useConfig({
      INPUT: {
        value: a,
        valueAsNumber: {
          events: s,
          default: 0
        },
        checked: {
          type: Kh,
          events: s
        },
        files: {
          events: s,
          readonly: !0
        }
      },
      SELECT: {
        value: {
          type: Wh,
          events: ["change"],
          default: ""
        }
      },
      TEXTAREA: {
        value: a
      }
    });
    const o = {
      events: ["change", "input", "blur", "keyup", "paste"],
      default: ""
    }, u = {
      events: ["scroll"],
      default: 0
    };
    this.useConfigGlobal({
      scrollTop: u,
      scrollLeft: u,
      textContent: o,
      innerHTML: o
    }), this.overrideAccessorGlobal("css", "style", "class"), this.overrideAccessor({
      INPUT: ["value", "checked", "model"],
      SELECT: ["value"],
      TEXTAREA: ["value"]
    });
  }
  static register(e) {
    _l(Jc, Qu).register(e), Vo(Jc, Qu).register(e);
  }
  handles(e, t) {
    return e instanceof this.platform.Node;
  }
  useConfig(e, t, i) {
    const r = this.si;
    let s;
    if (wt(e))
      s = r[e] ?? (r[e] = yn()), s[t] == null ? s[t] = i : sc(e, t);
    else
      for (const a in e) {
        s = r[a] ?? (r[a] = yn());
        const o = e[a];
        for (t in o)
          s[t] == null ? s[t] = o[t] : sc(a, t);
      }
  }
  useConfigGlobal(e, t) {
    const i = this.ni;
    if (typeof e == "object")
      for (const r in e)
        i[r] == null ? i[r] = e[r] : sc("*", r);
    else
      i[e] == null ? i[e] = t : sc("*", e);
  }
  getAccessor(e, t, i) {
    if (t in this.oi || t in (this.ri[e.tagName] ?? L3))
      return this.getObserver(e, t, i);
    switch (t) {
      case "src":
      case "href":
      case "role":
      case "minLength":
      case "maxLength":
      case "placeholder":
      case "size":
      case "pattern":
      case "title":
        return _c;
      default: {
        const r = Mg[t];
        return r !== void 0 ? Ju.forNs(r[1]) : ny(e, t, this.svgAnalyzer) ? _c : Y1;
      }
    }
  }
  overrideAccessor(e, t) {
    var i, r;
    let s;
    if (wt(e))
      s = (i = this.ri)[e] ?? (i[e] = yn()), s[t] = !0;
    else
      for (const a in e)
        for (const o of e[a])
          s = (r = this.ri)[a] ?? (r[a] = yn()), s[o] = !0;
  }
  overrideAccessorGlobal(...e) {
    for (const t of e)
      this.oi[t] = !0;
  }
  getNodeObserverConfig(e, t) {
    return this.si[e.tagName]?.[t] ?? this.ni[t];
  }
  getNodeObserver(e, t, i) {
    const r = this.si[e.tagName]?.[t] ?? this.ni[t];
    let s;
    return r != null ? (s = new (r.type ?? Jh)(e, t, r, i, this.locator), s.doNotCache || (n1(e)[t] = s), s) : null;
  }
  getObserver(e, t, i) {
    switch (t) {
      case "class":
        return new b1(e);
      case "css":
      case "style":
        return new Q1(e);
    }
    const r = this.getNodeObserver(e, t, i);
    if (r != null)
      return r;
    const s = Mg[t];
    if (s !== void 0)
      return Ju.forNs(s[1]);
    if (ny(e, t, this.svgAnalyzer))
      return _c;
    if (t in e.constructor.prototype) {
      if (this.allowDirtyCheck)
        return this.dirtyChecker.createProperty(e, t);
      throw re(`AUR0652:${String(t)}`);
    } else
      return new Eh(e, t);
  }
}
Qu.inject = [_3, On, Yx, G1];
function t7(n, e) {
  if (n instanceof Array)
    return e.getArrayObserver(n);
  if (n instanceof Map)
    return e.getMapObserver(n);
  if (n instanceof Set)
    return e.getSetObserver(n);
}
function sc(n, e) {
  throw re(`AUR0653:${String(e)}@${n}`);
}
class X1 {
  constructor(e, t) {
    if (!(t instanceof Qu))
      throw re("AURxxxx: updateTrigger binding behavior only works with the default implementation of Aurelia HTML observation. Implement your own node observation + updateTrigger");
    this.oL = e, this.li = t;
  }
  bind(e, t, ...i) {
    if (i.length === 0)
      throw re("AUR0802");
    if (!(t instanceof qr) || !(4 & t.mode))
      throw re("AUR0803");
    const r = this.li.getNodeObserverConfig(t.target, t.targetProperty);
    if (r == null)
      throw re("AURxxxx");
    const s = this.li.getNodeObserver(t.target, t.targetProperty, this.oL);
    s.useConfig({
      readonly: r.readonly,
      default: r.default,
      events: i
    }), t.useTargetObserver(s);
  }
}
X1.inject = [ka, Jc];
Kn("updateTrigger")(X1);
class Qh {
  constructor(e, t) {
    this.hi = !1, this.ai = e, this.p = t;
  }
  binding() {
    this.valueChanged();
  }
  valueChanged() {
    this.$controller.isActive ? this.ui() : this.hi = !0;
  }
  attached() {
    this.hi && (this.hi = !1, this.ui()), this.ai.addEventListener("focus", this), this.ai.addEventListener("blur", this);
  }
  afterDetachChildren() {
    const e = this.ai;
    e.removeEventListener("focus", this), e.removeEventListener("blur", this);
  }
  handleEvent(e) {
    e.type === "focus" ? this.value = !0 : this.fi || (this.value = !1);
  }
  ui() {
    const e = this.ai, t = this.fi, i = this.value;
    i && !t ? e.focus() : !i && t && e.blur();
  }
  get fi() {
    return this.ai === this.p.document.activeElement;
  }
}
Qh.inject = [xo, On];
X([Le({
  mode: 6
})], Qh.prototype, "value", void 0);
y1("focus")(Qh);
let Yu = class {
  constructor(e, t, i) {
    this.el = e, this.p = t, this.di = !1, this.lt = null, this.$val = "", this.$prio = "", this.update = () => {
      this.lt = null, !!this.value !== this.mi && (this.mi === this.gi ? (this.mi = !this.gi, this.$val = this.el.style.getPropertyValue("display"), this.$prio = this.el.style.getPropertyPriority("display"), this.el.style.setProperty("display", "none", "important")) : (this.mi = this.gi, this.el.style.setProperty("display", this.$val, this.$prio), this.el.getAttribute("style") === "" && this.el.removeAttribute("style")));
    }, this.mi = this.gi = i.alias !== "hide";
  }
  binding() {
    this.di = !0, this.update();
  }
  detaching() {
    this.di = !1, this.lt?.cancel(), this.lt = null;
  }
  valueChanged() {
    this.di && this.lt === null && (this.lt = this.p.domWriteQueue.queueTask(this.update));
  }
};
X([Le], Yu.prototype, "value", void 0);
Yu = X([xn(0, xo), xn(1, On), xn(2, zo)], Yu);
h8("hide")(Yu);
y1("show")(Yu);
class Vi {
  constructor(e, t, i) {
    this.position = "beforeend", this.strict = !1, this.p = i, this.pi = i.document.createElement("div"), (this.view = e.create()).setLocation(this.vi = xE(i)), SE(this.view.nodes, t);
  }
  attaching(e) {
    this.callbackContext == null && (this.callbackContext = this.$controller.scope.bindingContext);
    const t = this.pi = this.xi();
    return this.wi(t, this.position), this.bi(e, t);
  }
  detaching(e) {
    return this.yi(e, this.pi);
  }
  targetChanged() {
    const { $controller: e } = this;
    if (!e.isActive)
      return;
    const t = this.xi();
    if (this.pi === t)
      return;
    this.pi = t;
    const i = _e(this.yi(null, t), () => (this.wi(t, this.position), this.bi(null, t)));
    an(i) && i.catch(Qc);
  }
  positionChanged() {
    const { $controller: e, pi: t } = this;
    if (!e.isActive)
      return;
    const i = _e(this.yi(null, t), () => (this.wi(t, this.position), this.bi(null, t)));
    an(i) && i.catch(Qc);
  }
  bi(e, t) {
    const { activating: i, callbackContext: r, view: s } = this;
    return _e(i?.call(r, t, s), () => this.ki(e, t));
  }
  ki(e, t) {
    const { $controller: i, view: r } = this;
    if (e === null)
      r.nodes.insertBefore(this.vi);
    else
      return _e(r.activate(e ?? r, i, i.scope), () => this.Ai(t));
    return this.Ai(t);
  }
  Ai(e) {
    const { activated: t, callbackContext: i, view: r } = this;
    return t?.call(i, e, r);
  }
  yi(e, t) {
    const { deactivating: i, callbackContext: r, view: s } = this;
    return _e(i?.call(r, t, s), () => this.Ci(e, t));
  }
  Ci(e, t) {
    const { $controller: i, view: r } = this;
    if (e === null)
      r.nodes.remove();
    else
      return _e(r.deactivate(e, i), () => this.Bi(t));
    return this.Bi(t);
  }
  Bi(e) {
    const { deactivated: t, callbackContext: i, view: r } = this;
    return t?.call(i, e, r);
  }
  xi() {
    const e = this.p, t = e.document;
    let i = this.target, r = this.renderContext;
    if (i === "") {
      if (this.strict)
        throw re("AUR0811");
      return t.body;
    }
    if (wt(i)) {
      let s = t;
      wt(r) && (r = t.querySelector(r)), r instanceof e.Node && (s = r), i = s.querySelector(i);
    }
    if (i instanceof e.Node)
      return i;
    if (i == null) {
      if (this.strict)
        throw re("AUR0812");
      return t.body;
    }
    return i;
  }
  wi(e, t) {
    const i = this.vi, r = i.$start, s = e.parentNode, a = [r, i];
    switch (t) {
      case "beforeend":
        rc(e, null, a);
        break;
      case "afterbegin":
        rc(e, e.firstChild, a);
        break;
      case "beforebegin":
        rc(s, e, a);
        break;
      case "afterend":
        rc(s, e.nextSibling, a);
        break;
      default:
        throw new Error("Invalid portal insertion position");
    }
  }
  dispose() {
    this.view.dispose(), this.view = void 0, this.callbackContext = null;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
}
Vi.inject = [ii, Pn, On];
X([Le({
  primary: !0
})], Vi.prototype, "target", void 0);
X([Le()], Vi.prototype, "position", void 0);
X([Le({
  callback: "targetChanged"
})], Vi.prototype, "renderContext", void 0);
X([Le()], Vi.prototype, "strict", void 0);
X([Le()], Vi.prototype, "deactivating", void 0);
X([Le()], Vi.prototype, "activating", void 0);
X([Le()], Vi.prototype, "deactivated", void 0);
X([Le()], Vi.prototype, "activated", void 0);
X([Le()], Vi.prototype, "callbackContext", void 0);
vi("portal")(Vi);
class To {
  constructor(e, t) {
    this.elseFactory = void 0, this.elseView = void 0, this.ifView = void 0, this.view = void 0, this.value = !1, this.cache = !0, this.pending = void 0, this.Ri = !1, this.Si = 0, this.Ii = e, this.l = t;
  }
  attaching(e, t) {
    let i;
    const r = this.$controller, s = this.Si++, a = () => !this.Ri && this.Si === s + 1;
    return _e(this.pending, () => {
      a() && (this.pending = void 0, this.value ? i = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this.Ii.create() : i = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create(), i != null && (i.setLocation(this.l), this.pending = _e(i.activate(e, r, r.scope), () => {
        a() && (this.pending = void 0);
      })));
    });
  }
  detaching(e, t) {
    return this.Ri = !0, _e(this.pending, () => {
      this.Ri = !1, this.pending = void 0, this.view?.deactivate(e, this.$controller);
    });
  }
  valueChanged(e, t) {
    if (!this.$controller.isActive || (e = !!e, t = !!t, e === t))
      return;
    const i = this.view, r = this.$controller, s = this.Si++, a = () => !this.Ri && this.Si === s + 1;
    let o;
    return _e(this.pending, () => this.pending = _e(i?.deactivate(i, r), () => {
      if (a() && (e ? o = this.view = this.ifView = this.cache && this.ifView != null ? this.ifView : this.Ii.create() : o = this.view = this.elseView = this.cache && this.elseView != null ? this.elseView : this.elseFactory?.create(), o != null))
        return o.setLocation(this.l), _e(o.activate(o, r, r.scope), () => {
          a() && (this.pending = void 0);
        });
    }));
  }
  dispose() {
    this.ifView?.dispose(), this.elseView?.dispose(), this.ifView = this.elseView = this.view = void 0;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
}
To.inject = [ii, Pn];
X([Le], To.prototype, "value", void 0);
X([Le({
  set: (n) => n === "" || !!n && n !== "false"
})], To.prototype, "cache", void 0);
vi("if")(To);
class Z1 {
  constructor(e) {
    this.f = e;
  }
  link(e, t, i, r) {
    const s = e.children, a = s[s.length - 1];
    if (a instanceof To)
      a.elseFactory = this.f;
    else if (a.viewModel instanceof To)
      a.viewModel.elseFactory = this.f;
    else
      throw re("AUR0810");
  }
}
Z1.inject = [ii];
vi({
  name: "else"
})(Z1);
function n7(n) {
  n.dispose();
}
const i7 = [18, 17];
class Yh {
  constructor(e, t, i, r, s) {
    this.views = [], this.key = null, this.Ti = /* @__PURE__ */ new Map(), this.Pi = /* @__PURE__ */ new Map(), this.Ei = void 0, this.Li = !1, this.Di = !1, this._i = null, this.Ui = void 0, this.$i = !1;
    const a = e.props[0].props[0];
    if (a !== void 0) {
      const { to: o, value: u, command: l } = a;
      if (o === "key")
        if (l === null)
          this.key = u;
        else if (l === "bind")
          this.key = t.parse(u, 16);
        else
          throw re(`AUR775:${l}`);
      else
        throw re(`AUR776:${o}`);
    }
    this.l = i, this.qi = r, this.f = s;
  }
  binding(e, t) {
    const i = this.qi.bindings, r = i.length;
    let s, a, o = 0;
    for (; r > o; ++o)
      if (s = i[o], s.target === this && s.targetProperty === "items") {
        a = this.forOf = s.ast, this.Mi = s;
        let l = a.iterable;
        for (; l != null && i7.includes(l.$kind); )
          l = l.expression, this.Li = !0;
        this._i = l;
        break;
      }
    this.Fi();
    const u = a.declaration;
    (this.$i = u.$kind === 24 || u.$kind === 25) || (this.local = j(u, this.$controller.scope, s, null));
  }
  attaching(e, t) {
    return this.Oi(), this.Vi(e);
  }
  detaching(e, t) {
    return this.Fi(), this.Ni(e);
  }
  unbinding(e, t) {
    this.Pi.clear(), this.Ti.clear();
  }
  itemsChanged() {
    this.$controller.isActive && (this.Fi(), this.Oi(), this.ji(this.items, void 0));
  }
  handleCollectionChange(e, t) {
    const i = this.$controller;
    if (i.isActive) {
      if (this.Li) {
        if (this.Di)
          return;
        this.Di = !0, this.items = j(this.forOf.iterable, i.scope, this.Mi, null), this.Di = !1;
        return;
      }
      this.Oi(), this.ji(e, t);
    }
  }
  ji(e, t) {
    const i = this.views, r = i.length, s = this.key, a = s !== null;
    if (a || t === void 0) {
      const o = this.local, u = this.Ui, l = u.length, p = this.forOf, f = p.declaration, b = this.Mi, A = this.$i;
      t = pa(l);
      let x = 0;
      if (r === 0)
        for (; x < l; ++x)
          t[x] = -2;
      else if (l === 0)
        if (A)
          for (x = 0; x < r; ++x)
            t.deletedIndices.push(x), t.deletedItems.push(j(f, i[x].scope, b, null));
        else
          for (x = 0; x < r; ++x)
            t.deletedIndices.push(x), t.deletedItems.push(i[x].scope.bindingContext[o]);
      else {
        const w = Array(r);
        if (A)
          for (x = 0; x < r; ++x)
            w[x] = j(f, i[x].scope, b, null);
        else
          for (x = 0; x < r; ++x)
            w[x] = i[x].scope.bindingContext[o];
        let T, _, I, $, N = 0;
        const B = r - 1, V = l - 1, K = /* @__PURE__ */ new Map(), G = /* @__PURE__ */ new Map(), Y = this.Ti, oe = this.Pi, J = this.$controller.scope;
        x = 0;
        e: {
          for (; ; ) {
            if (T = w[x], _ = u[x], I = a ? Ka(Y, s, T, na(oe, w[x], p, J, b, o, A), b) : T, $ = a ? Ka(Y, s, _, na(oe, u[x], p, J, b, o, A), b) : _, I !== $) {
              Y.set(T, I), Y.set(_, $);
              break;
            }
            if (++x, x > B || x > V)
              break e;
          }
          if (B !== V)
            break e;
          for (N = V; ; ) {
            if (T = w[N], _ = u[N], I = a ? Ka(Y, s, T, na(oe, T, p, J, b, o, A), b) : T, $ = a ? Ka(Y, s, _, na(oe, _, p, J, b, o, A), b) : _, I !== $) {
              Y.set(T, I), Y.set(_, $);
              break;
            }
            if (--N, x > N)
              break e;
          }
        }
        const ue = x, M = x;
        for (x = M; x <= V; ++x)
          Y.has(_ = u[x]) ? $ = Y.get(_) : ($ = a ? Ka(Y, s, _, na(oe, _, p, J, b, o, A), b) : _, Y.set(_, $)), G.set($, x);
        for (x = ue; x <= B; ++x)
          Y.has(T = w[x]) ? I = Y.get(T) : I = a ? Ka(Y, s, T, i[x].scope, b) : T, K.set(I, x), G.has(I) ? t[G.get(I)] = x : (t.deletedIndices.push(x), t.deletedItems.push(T));
        for (x = M; x <= V; ++x)
          K.has(Y.get(u[x])) || (t[x] = -2);
        K.clear(), G.clear();
      }
    }
    if (t === void 0) {
      const o = _e(this.Ni(null), () => this.Vi(null));
      an(o) && o.catch(Qc);
    } else {
      const o = MA(t);
      if (o.deletedIndices.length > 0) {
        const u = _e(this.Hi(o), () => this.Wi(r, o));
        an(u) && u.catch(Qc);
      } else
        this.Wi(r, o);
    }
  }
  Fi() {
    const e = this.$controller.scope;
    let t = this.zi, i = this.Li, r;
    i && (t = this.zi = j(this._i, e, this.Mi, null) ?? null, i = this.Li = !Cl(this.items, t));
    const s = this.Ei;
    this.$controller.isActive ? (r = this.Ei = s8(i ? t : this.items), s !== r && (s?.unsubscribe(this), r?.subscribe(this))) : (s?.unsubscribe(this), this.Ei = void 0);
  }
  Oi() {
    const { items: e } = this;
    if (Fi(e)) {
      this.Ui = e;
      return;
    }
    const t = [];
    Cg(e, (i, r) => {
      t[r] = i;
    }), this.Ui = t;
  }
  Vi(e) {
    let t, i, r, s;
    const { $controller: a, f: o, local: u, l, items: p, Pi: f, Mi: b, forOf: A, $i: x } = this, w = a.scope, T = a7(p), _ = this.views = Array(T);
    if (Cg(p, (I, $) => {
      r = _[$] = o.create().setLocation(l), r.nodes.unlink(), s = na(f, I, A, w, b, u, x), oc(s.overrideContext, $, T), i = r.activate(e ?? r, a, s), an(i) && (t ?? (t = [])).push(i);
    }), t !== void 0)
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  Ni(e) {
    let t, i, r, s = 0;
    const { views: a, $controller: o } = this, u = a.length;
    for (; u > s; ++s)
      r = a[s], r.release(), i = r.deactivate(e ?? r, o), an(i) && (t ?? (t = [])).push(i);
    if (t !== void 0)
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  Hi(e) {
    let t, i, r;
    const { $controller: s, views: a } = this, o = e.deletedIndices, u = o.length;
    let l = 0;
    for (; u > l; ++l)
      r = a[o[l]], r.release(), i = r.deactivate(r, s), an(i) && (t ?? (t = [])).push(i);
    l = 0;
    let p = 0;
    for (; u > l; ++l)
      p = o[l] - l, a.splice(p, 1);
    if (t !== void 0)
      return t.length === 1 ? t[0] : Promise.all(t);
  }
  Wi(e, t) {
    let i, r, s, a, o = 0;
    const { $controller: u, f: l, local: p, Ui: f, l: b, views: A, $i: x, Mi: w, Pi: T, forOf: _ } = this, I = t.length;
    for (; I > o; ++o)
      t[o] === -2 && (s = l.create(), A.splice(o, 0, s));
    if (A.length !== I)
      throw s7(A.length, I);
    const $ = u.scope, N = t.length;
    CA(A, t);
    const B = r7(t), V = B.length, K = _.declaration;
    let G, Y = V - 1;
    for (o = N - 1; o >= 0; --o)
      s = A[o], G = A[o + 1], s.nodes.link(G?.nodes ?? b), t[o] === -2 ? (a = na(T, f[o], _, $, w, p, x), oc(a.overrideContext, o, N), s.setLocation(b), r = s.activate(s, u, a), an(r) && (i ?? (i = [])).push(r)) : Y < 0 || V === 1 || o !== B[Y] ? (x ? fn(K, s.scope, w, f[o]) : s.scope.bindingContext[p] = f[o], oc(s.scope.overrideContext, o, N), s.nodes.insertBefore(s.location)) : (x ? fn(K, s.scope, w, f[o]) : s.scope.bindingContext[p] = f[o], e !== N && oc(s.scope.overrideContext, o, N), --Y);
    if (i !== void 0)
      return i.length === 1 ? i[0] : Promise.all(i);
  }
  dispose() {
    this.views.forEach(n7), this.views = void 0;
  }
  accept(e) {
    const { views: t } = this;
    if (t !== void 0) {
      for (let i = 0, r = t.length; i < r; ++i)
        if (t[i].accept(e) === !0)
          return !0;
    }
  }
}
Yh.inject = [zo, hh, Pn, Xd, ii];
X([Le], Yh.prototype, "items", void 0);
vi("repeat")(Yh);
let nd = 16, hr = new Int32Array(nd), ac = new Int32Array(nd);
function r7(n) {
  const e = n.length;
  e > nd && (nd = e, hr = new Int32Array(e), ac = new Int32Array(e));
  let t = 0, i = 0, r = 0, s = 0, a = 0, o = 0, u = 0, l = 0;
  for (; s < e; s++)
    if (i = n[s], i !== -2) {
      if (a = hr[t], r = n[a], r !== -2 && r < i) {
        ac[s] = a, hr[++t] = s;
        continue;
      }
      for (o = 0, u = t; o < u; )
        l = o + u >> 1, r = n[hr[l]], r !== -2 && r < i ? o = l + 1 : u = l;
      r = n[hr[o]], (i < r || r === -2) && (o > 0 && (ac[s] = hr[o - 1]), hr[o] = s);
    }
  s = ++t;
  const p = new Int32Array(s);
  for (i = hr[t - 1]; t-- > 0; )
    p[t] = i, i = ac[i];
  for (; s-- > 0; )
    hr[s] = 0;
  return p;
}
const s7 = (n, e) => re(`AUR0814:${n}!=${e}`), oc = (n, e, t) => {
  const i = e === 0, r = e === t - 1, s = e % 2 === 0;
  n.$index = e, n.$first = i, n.$last = r, n.$middle = !i && !r, n.$even = s, n.$odd = !s, n.$length = t;
}, id = _h.toString, a7 = (n) => {
  switch (id.call(n)) {
    case "[object Array]":
      return n.length;
    case "[object Map]":
      return n.size;
    case "[object Set]":
      return n.size;
    case "[object Number]":
      return n;
    case "[object Null]":
      return 0;
    case "[object Undefined]":
      return 0;
    default:
      throw re(`Cannot count ${id.call(n)}`);
  }
}, Cg = (n, e) => {
  switch (id.call(n)) {
    case "[object Array]":
      return o7(n, e);
    case "[object Map]":
      return u7(n, e);
    case "[object Set]":
      return l7(n, e);
    case "[object Number]":
      return c7(n, e);
    case "[object Null]":
      return;
    case "[object Undefined]":
      return;
    default:
      throw re(`Cannot iterate over ${id.call(n)}`);
  }
}, o7 = (n, e) => {
  const t = n.length;
  let i = 0;
  for (; i < t; ++i)
    e(n[i], i, n);
}, u7 = (n, e) => {
  let t = -0, i;
  for (i of n.entries())
    e(i, t++, n);
}, l7 = (n, e) => {
  let t = 0, i;
  for (i of n.keys())
    e(i, t++, n);
}, c7 = (n, e) => {
  let t = 0;
  for (; t < n; ++t)
    e(t, t, n);
}, Ka = (n, e, t, i, r) => {
  let s = n.get(t);
  return s === void 0 && (typeof e == "string" ? s = t[e] : s = j(e, i, r, null), n.set(t, s)), s;
}, na = (n, e, t, i, r, s, a) => {
  let o = n.get(e);
  return o === void 0 && (a ? fn(t.declaration, o = ln.fromParent(i, new _m()), r, e) : o = ln.fromParent(i, new _m(s, e)), n.set(e, o)), o;
};
class Xh {
  constructor(e, t) {
    this.view = e.create().setLocation(t);
  }
  valueChanged(e, t) {
    const i = this.$controller, r = this.view.bindings;
    let s, a = 0, o = 0;
    if (i.isActive && r != null)
      for (s = ln.fromParent(i.scope, e === void 0 ? {} : e), o = r.length; o > a; ++a)
        r[a].bind(s);
  }
  attaching(e, t) {
    const { $controller: i, value: r } = this, s = ln.fromParent(i.scope, r === void 0 ? {} : r);
    return this.view.activate(e, i, s);
  }
  detaching(e, t) {
    return this.view.deactivate(e, this.$controller);
  }
  dispose() {
    this.view.dispose(), this.view = void 0;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
}
Xh.inject = [ii, Pn];
X([Le], Xh.prototype, "value", void 0);
vi("with")(Xh);
let rd = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.cases = [], this.activeCases = [], this.promise = void 0;
  }
  link(e, t, i, r) {
    this.view = this.f.create(this.$controller).setLocation(this.l);
  }
  attaching(e, t) {
    const i = this.view, r = this.$controller;
    return this.queue(() => i.activate(e, r, r.scope)), this.queue(() => this.swap(e, this.value)), this.promise;
  }
  detaching(e, t) {
    return this.queue(() => this.view.deactivate(e, this.$controller)), this.promise;
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
  valueChanged(e, t) {
    this.$controller.isActive && this.queue(() => this.swap(null, this.value));
  }
  caseChanged(e) {
    this.queue(() => this.Gi(e));
  }
  Gi(e) {
    const t = e.isMatch(this.value), i = this.activeCases, r = i.length;
    if (!t)
      return r > 0 && i[0].id === e.id ? this.Xi(null) : void 0;
    if (r > 0 && i[0].id < e.id)
      return;
    const s = [];
    let a = e.fallThrough;
    if (!a)
      s.push(e);
    else {
      const o = this.cases, u = o.indexOf(e);
      for (let l = u, p = o.length; l < p && a; l++) {
        const f = o[l];
        s.push(f), a = f.fallThrough;
      }
    }
    return _e(this.Xi(null, s), () => (this.activeCases = s, this.Ki(null)));
  }
  swap(e, t) {
    const i = [];
    let r = !1;
    for (const a of this.cases)
      if ((r || a.isMatch(t)) && (i.push(a), r = a.fallThrough), i.length > 0 && !r)
        break;
    const s = this.defaultCase;
    return i.length === 0 && s !== void 0 && i.push(s), _e(this.activeCases.length > 0 ? this.Xi(e, i) : void 0, () => {
      if (this.activeCases = i, i.length !== 0)
        return this.Ki(e);
    });
  }
  Ki(e) {
    const t = this.$controller;
    if (!t.isActive)
      return;
    const i = this.activeCases, r = i.length;
    if (r === 0)
      return;
    const s = t.scope;
    return r === 1 ? i[0].activate(e, s) : Yt(...i.map((a) => a.activate(e, s)));
  }
  Xi(e, t = []) {
    const i = this.activeCases, r = i.length;
    if (r !== 0) {
      if (r === 1) {
        const s = i[0];
        return t.includes(s) ? void 0 : (i.length = 0, s.deactivate(e));
      }
      return _e(Yt(...i.reduce((s, a) => (t.includes(a) || s.push(a.deactivate(e)), s), [])), () => {
        i.length = 0;
      });
    }
  }
  queue(e) {
    const t = this.promise;
    let i;
    i = this.promise = _e(_e(t, e), () => {
      this.promise === i && (this.promise = void 0);
    });
  }
  accept(e) {
    if (this.$controller.accept(e) === !0 || this.activeCases.some((t) => t.accept(e)))
      return !0;
  }
};
X([Le], rd.prototype, "value", void 0);
rd = X([vi("switch"), xn(0, ii), xn(1, Pn)], rd);
let d7 = 0, wo = class {
  constructor(e, t, i, r) {
    this.f = e, this.Qi = t, this.l = i, this.id = ++d7, this.fallThrough = !1, this.view = void 0, this.Yi = r.config.level <= 1, this.Ve = r.scopeTo(`${this.constructor.name}-#${this.id}`);
  }
  link(e, t, i, r) {
    const a = e.parent?.viewModel;
    if (a instanceof rd)
      this.$switch = a, this.linkToSwitch(a);
    else
      throw re("AUR0815");
  }
  detaching(e, t) {
    return this.deactivate(e);
  }
  isMatch(e) {
    this.Ve.debug("isMatch()");
    const t = this.value;
    return Fi(t) ? (this.Ei === void 0 && (this.Ei = this.Zi(t)), t.includes(e)) : t === e;
  }
  valueChanged(e, t) {
    Fi(e) ? (this.Ei?.unsubscribe(this), this.Ei = this.Zi(e)) : this.Ei !== void 0 && this.Ei.unsubscribe(this), this.$switch.caseChanged(this);
  }
  handleCollectionChange() {
    this.$switch.caseChanged(this);
  }
  activate(e, t) {
    let i = this.view;
    if (i === void 0 && (i = this.view = this.f.create().setLocation(this.l)), !i.isActive)
      return i.activate(e ?? i, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive))
      return t.deactivate(e ?? t, this.$controller);
  }
  dispose() {
    this.Ei?.unsubscribe(this), this.view?.dispose(), this.view = void 0;
  }
  linkToSwitch(e) {
    e.cases.push(this);
  }
  Zi(e) {
    const t = this.Qi.getArrayObserver(e);
    return t.subscribe(this), t;
  }
  accept(e) {
    return this.$controller.accept(e) === !0 ? !0 : this.view?.accept(e);
  }
};
wo.inject = [ii, ka, Pn, Ra];
X([Le], wo.prototype, "value", void 0);
X([Le({
  set: (n) => {
    switch (n) {
      case "true":
        return !0;
      case "false":
        return !1;
      default:
        return !!n;
    }
  },
  mode: 1
})], wo.prototype, "fallThrough", void 0);
wo = X([vi("case")], wo);
let _g = class extends wo {
  linkToSwitch(e) {
    if (e.defaultCase !== void 0)
      throw re("AUR0816");
    e.defaultCase = this;
  }
};
_g = X([vi("default-case")], _g);
let sd = class {
  constructor(e, t, i, r) {
    this.f = e, this.l = t, this.p = i, this.preSettledTask = null, this.postSettledTask = null, this.logger = r.scopeTo("promise.resolve");
  }
  link(e, t, i, r) {
    this.view = this.f.create(this.$controller).setLocation(this.l);
  }
  attaching(e, t) {
    const i = this.view, r = this.$controller;
    return _e(i.activate(e, r, this.viewScope = ln.fromParent(r.scope, {})), () => this.swap(e));
  }
  valueChanged(e, t) {
    this.$controller.isActive && this.swap(null);
  }
  swap(e) {
    const t = this.value;
    if (!an(t)) {
      this.logger.warn(`The value '${String(t)}' is not a promise. No change will be done.`);
      return;
    }
    const i = this.p.domWriteQueue, r = this.fulfilled, s = this.rejected, a = this.pending, o = this.viewScope;
    let u;
    const l = {
      reusable: !1
    }, p = () => {
      Yt(u = (this.preSettledTask = i.queueTask(() => Yt(r?.deactivate(e), s?.deactivate(e), a?.activate(e, o)), l)).result.catch((f) => {
        if (!(f instanceof c8))
          throw f;
      }), t.then((f) => {
        if (this.value !== t)
          return;
        const b = () => {
          this.postSettlePromise = (this.postSettledTask = i.queueTask(() => Yt(a?.deactivate(e), s?.deactivate(e), r?.activate(e, o, f)), l)).result;
        };
        this.preSettledTask.status === 1 ? u.then(b) : (this.preSettledTask.cancel(), b());
      }, (f) => {
        if (this.value !== t)
          return;
        const b = () => {
          this.postSettlePromise = (this.postSettledTask = i.queueTask(() => Yt(a?.deactivate(e), r?.deactivate(e), s?.activate(e, o, f)), l)).result;
        };
        this.preSettledTask.status === 1 ? u.then(b) : (this.preSettledTask.cancel(), b());
      }));
    };
    this.postSettledTask?.status === 1 ? this.postSettlePromise.then(p) : (this.postSettledTask?.cancel(), p());
  }
  detaching(e, t) {
    return this.preSettledTask?.cancel(), this.postSettledTask?.cancel(), this.preSettledTask = this.postSettledTask = null, this.view.deactivate(e, this.$controller);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
X([Le], sd.prototype, "value", void 0);
sd = X([vi("promise"), xn(0, ii), xn(1, Pn), xn(2, On), xn(3, Ra)], sd);
let py = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.view = void 0;
  }
  link(e, t, i, r) {
    Zh(e).pending = this;
  }
  activate(e, t) {
    let i = this.view;
    if (i === void 0 && (i = this.view = this.f.create().setLocation(this.l)), !i.isActive)
      return i.activate(i, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive))
      return t.deactivate(t, this.$controller);
  }
  detaching(e) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
X([Le({
  mode: 2
})], py.prototype, "value", void 0);
py = X([vi("pending"), xn(0, ii), xn(1, Pn)], py);
let fy = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.view = void 0;
  }
  link(e, t, i, r) {
    Zh(e).fulfilled = this;
  }
  activate(e, t, i) {
    this.value = i;
    let r = this.view;
    if (r === void 0 && (r = this.view = this.f.create().setLocation(this.l)), !r.isActive)
      return r.activate(r, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive))
      return t.deactivate(t, this.$controller);
  }
  detaching(e, t) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
X([Le({
  mode: 4
})], fy.prototype, "value", void 0);
fy = X([vi("then"), xn(0, ii), xn(1, Pn)], fy);
let yy = class {
  constructor(e, t) {
    this.f = e, this.l = t, this.view = void 0;
  }
  link(e, t, i, r) {
    Zh(e).rejected = this;
  }
  activate(e, t, i) {
    this.value = i;
    let r = this.view;
    if (r === void 0 && (r = this.view = this.f.create().setLocation(this.l)), !r.isActive)
      return r.activate(r, this.$controller, t);
  }
  deactivate(e) {
    const t = this.view;
    if (!(t === void 0 || !t.isActive))
      return t.deactivate(t, this.$controller);
  }
  detaching(e, t) {
    return this.deactivate(e);
  }
  dispose() {
    this.view?.dispose(), this.view = void 0;
  }
};
X([Le({
  mode: 4
})], yy.prototype, "value", void 0);
yy = X([vi("catch"), xn(0, ii), xn(1, Pn)], yy);
function Zh(n) {
  const t = n.parent?.viewModel;
  if (t instanceof sd)
    return t;
  throw re("AUR0813");
}
let Rg = class {
  "promise.resolve"(e, t, i) {
    return new bi(e, t, "promise", "bind");
  }
};
Rg = X([Gr({
  pattern: "promise.resolve",
  symbols: ""
})], Rg);
let kg = class {
  then(e, t, i) {
    return new bi(e, t, "then", "from-view");
  }
};
kg = X([Gr({
  pattern: "then",
  symbols: ""
})], kg);
let Pg = class {
  catch(e, t, i) {
    return new bi(e, t, "catch", "from-view");
  }
};
Pg = X([Gr({
  pattern: "catch",
  symbols: ""
})], Pg);
class $l {
  static get inject() {
    return [Do, Xd, xo, Pn, On, zo, yx(f7)];
  }
  get pending() {
    return this.Ji;
  }
  get composition() {
    return this.ts;
  }
  constructor(e, t, i, r, s, a, o) {
    this.c = e, this.parent = t, this.host = i, this.l = r, this.p = s, this.scopeBehavior = "auto", this.ts = void 0, this.r = e.get(Ba), this.es = a, this.ss = o;
  }
  attaching(e, t) {
    return this.Ji = _e(this.queue(new Ig(this.template, this.component, this.model, void 0), e), (i) => {
      this.ss.isCurrent(i) && (this.Ji = void 0);
    });
  }
  detaching(e) {
    const t = this.ts, i = this.Ji;
    return this.ss.invalidate(), this.ts = this.Ji = void 0, _e(i, () => t?.deactivate(e));
  }
  propertyChanged(e) {
    if (e === "model" && this.ts != null) {
      this.ts.update(this.model);
      return;
    }
    this.Ji = _e(this.Ji, () => _e(this.queue(new Ig(this.template, this.component, this.model, e), void 0), (t) => {
      this.ss.isCurrent(t) && (this.Ji = void 0);
    }));
  }
  queue(e, t) {
    const i = this.ss, r = this.ts;
    return _e(i.create(e), (s) => i.isCurrent(s) ? _e(this.compose(s), (a) => i.isCurrent(s) ? _e(a.activate(t), () => i.isCurrent(s) ? (this.ts = a, _e(r?.deactivate(t), () => s)) : _e(a.controller.deactivate(a.controller, this.$controller), () => (a.controller.dispose(), s))) : (a.controller.dispose(), s)) : s);
  }
  compose(e) {
    let t, i, r;
    const { we: s, rs: a, os: o } = e.change, { c: u, host: l, $controller: p, l: f } = this, b = this.getDef(a), A = u.createChild(), x = f == null ? l.parentNode : f.parentNode;
    if (b !== null) {
      if (b.containerless)
        throw re("AUR0806");
      f == null ? (i = l, r = () => {
      }) : (i = x.insertBefore(this.p.document.createElement(b.name), f), r = () => {
        i.remove();
      }), t = this.ls(A, a, i);
    } else
      i = f ?? l, t = this.ls(A, a, i);
    const w = () => {
      if (b !== null) {
        const T = pi.$el(A, t, i, {
          projections: this.es.projections
        }, b);
        return new Bg(T, (_) => T.activate(_ ?? T, p, p.scope.parent), (_) => _e(T.deactivate(_ ?? T, p), r), (_) => t.activate?.(_), e);
      } else {
        const T = Wi.create({
          name: po.generateName(),
          template: s
        }), _ = this.r.getViewFactory(T, A), I = pi.$view(_, p), $ = this.scopeBehavior === "auto" ? ln.fromParent(this.parent.scope, t) : ln.create(t);
        return td(i) ? I.setLocation(i) : I.setHost(i), new Bg(I, (N) => I.activate(N ?? I, p, $), (N) => I.deactivate(N ?? I, p), (N) => t.activate?.(N), e);
      }
    };
    return "activate" in t ? _e(t.activate(o), () => w()) : w();
  }
  ls(e, t, i) {
    if (t == null)
      return new p7();
    if (typeof t == "object")
      return t;
    const r = this.p, s = td(i);
    Tt(e, r.Element, Tt(e, xo, new on("ElementResolver", s ? null : i))), Tt(e, Pn, new on("IRenderLocation", s ? i : null));
    const a = e.invoke(t);
    return Tt(e, t, new on("au-compose.component", a)), a;
  }
  getDef(e) {
    const t = ei(e) ? e : e?.constructor;
    return po.isType(t) ? po.getDefinition(t) : null;
  }
}
X([Le], $l.prototype, "template", void 0);
X([Le], $l.prototype, "component", void 0);
X([Le], $l.prototype, "model", void 0);
X([Le({
  set: (n) => {
    if (n === "scoped" || n === "auto")
      return n;
    throw re("AUR0805");
  }
})], $l.prototype, "scopeBehavior", void 0);
M1("au-compose")($l);
class p7 {
}
class f7 {
  constructor() {
    this.id = 0;
  }
  isCurrent(e) {
    return e.id === this.id;
  }
  create(e) {
    return _e(e.load(), (t) => new y7(++this.id, t));
  }
  invalidate() {
    this.id++;
  }
}
class Ig {
  constructor(e, t, i, r) {
    this.we = e, this.rs = t, this.os = i, this.cs = r;
  }
  load() {
    return an(this.we) || an(this.rs) ? Promise.all([this.we, this.rs]).then(([e, t]) => new Og(e, t, this.os, this.cs)) : new Og(this.we, this.rs, this.os, this.cs);
  }
}
class Og {
  constructor(e, t, i, r) {
    this.we = e, this.rs = t, this.os = i, this.cs = r;
  }
}
class y7 {
  constructor(e, t) {
    this.id = e, this.change = t;
  }
}
class Bg {
  constructor(e, t, i, r, s) {
    this.controller = e, this.start = t, this.stop = i, this.update = r, this.context = s, this.state = 0;
  }
  activate(e) {
    if (this.state !== 0)
      throw re(`AUR0807:${this.controller.name}`);
    return this.state = 1, this.start(e);
  }
  deactivate(e) {
    switch (this.state) {
      case 1:
        return this.state = -1, this.stop(e);
      case -1:
        throw re("AUR0808");
      default:
        this.state = -1;
    }
  }
}
let hy = class {
  static get inject() {
    return [Pn, zo, Zc, Ba];
  }
  constructor(e, t, i, r) {
    this.us = null, this.ds = null;
    let s, a;
    const o = t.auSlot, u = i.instruction?.projections?.[o.name];
    u == null ? (s = r.getViewFactory(o.fallback, i.controller.container), this.gs = !1) : (a = i.parent.controller.container.createChild(), Tt(a, i.controller.definition.Type, new on(void 0, i.controller.viewModel)), s = r.getViewFactory(u, a), this.gs = !0), this.ps = i, this.view = s.create().setLocation(e);
  }
  binding(e, t) {
    this.us = this.$controller.scope.parent;
    let i;
    this.gs && (i = this.ps.controller.scope.parent, (this.ds = ln.fromParent(i, i.bindingContext)).overrideContext.$host = this.expose ?? this.us.bindingContext);
  }
  attaching(e, t) {
    return this.view.activate(e, this.$controller, this.gs ? this.ds : this.us);
  }
  detaching(e, t) {
    return this.view.deactivate(e, this.$controller);
  }
  exposeChanged(e) {
    this.gs && this.ds != null && (this.ds.overrideContext.$host = e);
  }
  dispose() {
    this.view.dispose(), this.view = void 0;
  }
  accept(e) {
    if (this.view?.accept(e) === !0)
      return !0;
  }
};
X([Le], hy.prototype, "expose", void 0);
hy = X([M1({
  name: "au-slot",
  template: null,
  containerless: !0
})], hy);
const h7 = ke("ISanitizer", (n) => n.singleton(class {
  sanitize() {
    throw re('"sanitize" method not implemented');
  }
}));
let my = class {
  constructor(e) {
    this.vs = e;
  }
  toView(e) {
    return e == null ? null : this.vs.sanitize(e);
  }
};
my = X([xn(0, h7)], my);
kl("sanitize")(my);
ke("IAurelia");
var Ng;
(function(n) {
  n[n.oneTime = 1] = "oneTime", n[n.toView = 2] = "toView", n[n.fromView = 4] = "fromView", n[n.twoWay = 6] = "twoWay", n[n.default = 8] = "default";
})(Ng || (Ng = {}));
var Dg;
(function(n) {
  n[n.Element = 1] = "Element", n[n.Attribute = 2] = "Attribute";
})(Dg || (Dg = {}));
function $i(n) {
  return $i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, $i(n);
}
function m7(n, e) {
  if ($i(n) !== "object" || n === null)
    return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e || "default");
    if ($i(i) !== "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function e6(n) {
  var e = m7(n, "string");
  return $i(e) === "symbol" ? e : String(e);
}
function b7(n, e, t) {
  return e = e6(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function Ln(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? Object(arguments[e]) : {}, i = Object.keys(t);
    typeof Object.getOwnPropertySymbols == "function" && i.push.apply(i, Object.getOwnPropertySymbols(t).filter(function(r) {
      return Object.getOwnPropertyDescriptor(t, r).enumerable;
    })), i.forEach(function(r) {
      b7(n, r, t[r]);
    });
  }
  return n;
}
function Kr(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function $g(n, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, e6(i.key), i);
  }
}
function Wr(n, e, t) {
  return e && $g(n.prototype, e), t && $g(n, t), Object.defineProperty(n, "prototype", {
    writable: !1
  }), n;
}
function ha(n) {
  if (n === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function Xu(n, e) {
  if (e && ($i(e) === "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return ha(n);
}
function Ao(n) {
  return Ao = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Ao(n);
}
function by(n, e) {
  return by = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(i, r) {
    return i.__proto__ = r, i;
  }, by(n, e);
}
function tp(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  n.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: n,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(n, "prototype", {
    writable: !1
  }), e && by(n, e);
}
function gy(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, i = new Array(e); t < e; t++)
    i[t] = n[t];
  return i;
}
function g7(n) {
  if (Array.isArray(n))
    return gy(n);
}
function v7(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null)
    return Array.from(n);
}
function t6(n, e) {
  if (n) {
    if (typeof n == "string")
      return gy(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return gy(n, e);
  }
}
function x7() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function T7(n) {
  return g7(n) || v7(n) || t6(n) || x7();
}
function w7(n) {
  if (Array.isArray(n))
    return n;
}
function A7(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var i, r, s, a, o = [], u = !0, l = !1;
    try {
      if (s = (t = t.call(n)).next, e === 0) {
        if (Object(t) !== t)
          return;
        u = !1;
      } else
        for (; !(u = (i = s.call(t)).done) && (o.push(i.value), o.length !== e); u = !0)
          ;
    } catch (p) {
      l = !0, r = p;
    } finally {
      try {
        if (!u && t.return != null && (a = t.return(), Object(a) !== a))
          return;
      } finally {
        if (l)
          throw r;
      }
    }
    return o;
  }
}
function E7() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Fg(n, e) {
  return w7(n) || A7(n, e) || t6(n, e) || E7();
}
var S7 = {
  type: "logger",
  log: function(e) {
    this.output("log", e);
  },
  warn: function(e) {
    this.output("warn", e);
  },
  error: function(e) {
    this.output("error", e);
  },
  output: function(e, t) {
    var i;
    console && console[e] && (i = console)[e].apply(i, T7(t));
  }
}, M7 = /* @__PURE__ */ function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Kr(this, n), this.init(e, t);
  }
  return Wr(n, [{
    key: "init",
    value: function(t) {
      var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = i.prefix || "i18next:", this.logger = t || S7, this.options = i, this.debug = i.debug;
    }
  }, {
    key: "setDebug",
    value: function(t) {
      this.debug = t;
    }
  }, {
    key: "log",
    value: function() {
      for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++)
        i[r] = arguments[r];
      return this.forward(i, "log", "", !0);
    }
  }, {
    key: "warn",
    value: function() {
      for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++)
        i[r] = arguments[r];
      return this.forward(i, "warn", "", !0);
    }
  }, {
    key: "error",
    value: function() {
      for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++)
        i[r] = arguments[r];
      return this.forward(i, "error", "");
    }
  }, {
    key: "deprecate",
    value: function() {
      for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++)
        i[r] = arguments[r];
      return this.forward(i, "warn", "WARNING DEPRECATED: ", !0);
    }
  }, {
    key: "forward",
    value: function(t, i, r, s) {
      return s && !this.debug ? null : (typeof t[0] == "string" && (t[0] = "".concat(r).concat(this.prefix, " ").concat(t[0])), this.logger[i](t));
    }
  }, {
    key: "create",
    value: function(t) {
      return new n(this.logger, Ln({}, {
        prefix: "".concat(this.prefix, ":").concat(t, ":")
      }, this.options));
    }
  }]), n;
}(), Mr = new M7(), Es = /* @__PURE__ */ function() {
  function n() {
    Kr(this, n), this.observers = {};
  }
  return Wr(n, [{
    key: "on",
    value: function(t, i) {
      var r = this;
      return t.split(" ").forEach(function(s) {
        r.observers[s] = r.observers[s] || [], r.observers[s].push(i);
      }), this;
    }
  }, {
    key: "off",
    value: function(t, i) {
      if (this.observers[t]) {
        if (!i) {
          delete this.observers[t];
          return;
        }
        this.observers[t] = this.observers[t].filter(function(r) {
          return r !== i;
        });
      }
    }
  }, {
    key: "emit",
    value: function(t) {
      for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), s = 1; s < i; s++)
        r[s - 1] = arguments[s];
      if (this.observers[t]) {
        var a = [].concat(this.observers[t]);
        a.forEach(function(u) {
          u.apply(void 0, r);
        });
      }
      if (this.observers["*"]) {
        var o = [].concat(this.observers["*"]);
        o.forEach(function(u) {
          u.apply(u, [t].concat(r));
        });
      }
    }
  }]), n;
}();
function ru() {
  var n, e, t = new Promise(function(i, r) {
    n = i, e = r;
  });
  return t.resolve = n, t.reject = e, t;
}
function yf(n) {
  return n == null ? "" : "" + n;
}
function C7(n, e, t) {
  n.forEach(function(i) {
    e[i] && (t[i] = e[i]);
  });
}
function e0(n, e, t) {
  function i(o) {
    return o && o.indexOf("###") > -1 ? o.replace(/###/g, ".") : o;
  }
  function r() {
    return !n || typeof n == "string";
  }
  for (var s = typeof e != "string" ? [].concat(e) : e.split("."); s.length > 1; ) {
    if (r())
      return {};
    var a = i(s.shift());
    !n[a] && t && (n[a] = new t()), n = n[a];
  }
  return r() ? {} : {
    obj: n,
    k: i(s.shift())
  };
}
function Lg(n, e, t) {
  var i = e0(n, e, Object), r = i.obj, s = i.k;
  r[s] = t;
}
function _7(n, e, t, i) {
  var r = e0(n, e, Object), s = r.obj, a = r.k;
  s[a] = s[a] || [], i && (s[a] = s[a].concat(t)), i || s[a].push(t);
}
function ad(n, e) {
  var t = e0(n, e), i = t.obj, r = t.k;
  if (i)
    return i[r];
}
function Ug(n, e, t) {
  var i = ad(n, t);
  return i !== void 0 ? i : ad(e, t);
}
function n6(n, e, t) {
  for (var i in e)
    i in n ? typeof n[i] == "string" || n[i] instanceof String || typeof e[i] == "string" || e[i] instanceof String ? t && (n[i] = e[i]) : n6(n[i], e[i], t) : n[i] = e[i];
  return n;
}
function Wa(n) {
  return n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var R7 = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function k7(n) {
  return typeof n == "string" ? n.replace(/[&<>"'\/]/g, function(e) {
    return R7[e];
  }) : n;
}
var P7 = /* @__PURE__ */ function(n) {
  tp(e, n);
  function e(t) {
    var i, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return Kr(this, e), i = Xu(this, Ao(e).call(this)), Es.call(ha(i)), i.data = t || {}, i.options = r, i.options.keySeparator === void 0 && (i.options.keySeparator = "."), i;
  }
  return Wr(e, [{
    key: "addNamespaces",
    value: function(i) {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }
  }, {
    key: "removeNamespaces",
    value: function(i) {
      var r = this.options.ns.indexOf(i);
      r > -1 && this.options.ns.splice(r, 1);
    }
  }, {
    key: "getResource",
    value: function(i, r, s) {
      var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, o = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator, u = [i, r];
      return s && typeof s != "string" && (u = u.concat(s)), s && typeof s == "string" && (u = u.concat(o ? s.split(o) : s)), i.indexOf(".") > -1 && (u = i.split(".")), ad(this.data, u);
    }
  }, {
    key: "addResource",
    value: function(i, r, s, a) {
      var o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, u = this.options.keySeparator;
      u === void 0 && (u = ".");
      var l = [i, r];
      s && (l = l.concat(u ? s.split(u) : s)), i.indexOf(".") > -1 && (l = i.split("."), a = r, r = l[1]), this.addNamespaces(r), Lg(this.data, l, a), o.silent || this.emit("added", i, r, s, a);
    }
  }, {
    key: "addResources",
    value: function(i, r, s) {
      var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var o in s)
        (typeof s[o] == "string" || Object.prototype.toString.apply(s[o]) === "[object Array]") && this.addResource(i, r, o, s[o], {
          silent: !0
        });
      a.silent || this.emit("added", i, r, s);
    }
  }, {
    key: "addResourceBundle",
    value: function(i, r, s, a, o) {
      var u = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, l = [i, r];
      i.indexOf(".") > -1 && (l = i.split("."), a = s, s = r, r = l[1]), this.addNamespaces(r);
      var p = ad(this.data, l) || {};
      a ? n6(p, s, o) : p = Ln({}, p, s), Lg(this.data, l, p), u.silent || this.emit("added", i, r, s);
    }
  }, {
    key: "removeResourceBundle",
    value: function(i, r) {
      this.hasResourceBundle(i, r) && delete this.data[i][r], this.removeNamespaces(r), this.emit("removed", i, r);
    }
  }, {
    key: "hasResourceBundle",
    value: function(i, r) {
      return this.getResource(i, r) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function(i, r) {
      return r || (r = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? Ln({}, {}, this.getResource(i, r)) : this.getResource(i, r);
    }
  }, {
    key: "getDataByLanguage",
    value: function(i) {
      return this.data[i];
    }
  }, {
    key: "toJSON",
    value: function() {
      return this.data;
    }
  }]), e;
}(Es), i6 = {
  processors: {},
  addPostProcessor: function(e) {
    this.processors[e.name] = e;
  },
  handle: function(e, t, i, r, s) {
    var a = this;
    return e.forEach(function(o) {
      a.processors[o] && (t = a.processors[o].process(t, i, r, s));
    }), t;
  }
}, Vg = /* @__PURE__ */ function(n) {
  tp(e, n);
  function e(t) {
    var i, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Kr(this, e), i = Xu(this, Ao(e).call(this)), Es.call(ha(i)), C7(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, ha(i)), i.options = r, i.options.keySeparator === void 0 && (i.options.keySeparator = "."), i.logger = Mr.create("translator"), i;
  }
  return Wr(e, [{
    key: "changeLanguage",
    value: function(i) {
      i && (this.language = i);
    }
  }, {
    key: "exists",
    value: function(i) {
      var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, s = this.resolve(i, r);
      return s && s.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function(i, r) {
      var s = r.nsSeparator || this.options.nsSeparator;
      s === void 0 && (s = ":");
      var a = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator, o = r.ns || this.options.defaultNS;
      if (s && i.indexOf(s) > -1) {
        var u = i.split(s);
        (s !== a || s === a && this.options.ns.indexOf(u[0]) > -1) && (o = u.shift()), i = u.join(a);
      }
      return typeof o == "string" && (o = [o]), {
        key: i,
        namespaces: o
      };
    }
  }, {
    key: "translate",
    value: function(i, r) {
      var s = this;
      if ($i(r) !== "object" && this.options.overloadTranslationOptionHandler && (r = this.options.overloadTranslationOptionHandler(arguments)), r || (r = {}), i == null)
        return "";
      Array.isArray(i) || (i = [String(i)]);
      var a = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator, o = this.extractFromKey(i[i.length - 1], r), u = o.key, l = o.namespaces, p = l[l.length - 1], f = r.lng || this.language, b = r.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (f && f.toLowerCase() === "cimode") {
        if (b) {
          var A = r.nsSeparator || this.options.nsSeparator;
          return p + A + u;
        }
        return u;
      }
      var x = this.resolve(i, r), w = x && x.res, T = x && x.usedKey || u, _ = x && x.exactUsedKey || u, I = Object.prototype.toString.apply(w), $ = ["[object Number]", "[object Function]", "[object RegExp]"], N = r.joinArrays !== void 0 ? r.joinArrays : this.options.joinArrays, B = !this.i18nFormat || this.i18nFormat.handleAsObject, V = typeof w != "string" && typeof w != "boolean" && typeof w != "number";
      if (B && w && V && $.indexOf(I) < 0 && !(typeof N == "string" && I === "[object Array]")) {
        if (!r.returnObjects && !this.options.returnObjects)
          return this.logger.warn("accessing an object - but returnObjects options is not enabled!"), this.options.returnedObjectHandler ? this.options.returnedObjectHandler(T, w, r) : "key '".concat(u, " (").concat(this.language, ")' returned an object instead of string.");
        if (a) {
          var K = I === "[object Array]", G = K ? [] : {}, Y = K ? _ : T;
          for (var oe in w)
            if (Object.prototype.hasOwnProperty.call(w, oe)) {
              var J = "".concat(Y).concat(a).concat(oe);
              G[oe] = this.translate(J, Ln({}, r, {
                joinArrays: !1,
                ns: l
              })), G[oe] === J && (G[oe] = w[oe]);
            }
          w = G;
        }
      } else if (B && typeof N == "string" && I === "[object Array]")
        w = w.join(N), w && (w = this.extendTranslation(w, i, r));
      else {
        var ue = !1, M = !1;
        if (!this.isValidLookup(w) && r.defaultValue !== void 0) {
          if (ue = !0, r.count !== void 0) {
            var c = this.pluralResolver.getSuffix(f, r.count);
            w = r["defaultValue".concat(c)];
          }
          w || (w = r.defaultValue);
        }
        this.isValidLookup(w) || (M = !0, w = u);
        var h = r.defaultValue && r.defaultValue !== w && this.options.updateMissing;
        if (M || ue || h) {
          this.logger.log(h ? "updateKey" : "missingKey", f, p, u, h ? r.defaultValue : w);
          var v = [], S = this.languageUtils.getFallbackCodes(this.options.fallbackLng, r.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && S && S[0])
            for (var E = 0; E < S.length; E++)
              v.push(S[E]);
          else
            this.options.saveMissingTo === "all" ? v = this.languageUtils.toResolveHierarchy(r.lng || this.language) : v.push(r.lng || this.language);
          var C = function(d, g) {
            s.options.missingKeyHandler ? s.options.missingKeyHandler(d, p, g, h ? r.defaultValue : w, h, r) : s.backendConnector && s.backendConnector.saveMissing && s.backendConnector.saveMissing(d, p, g, h ? r.defaultValue : w, h, r), s.emit("missingKey", d, p, g, w);
          };
          if (this.options.saveMissing) {
            var k = r.count !== void 0 && typeof r.count != "string";
            this.options.saveMissingPlurals && k ? v.forEach(function(m) {
              var d = s.pluralResolver.getPluralFormsOfKey(m, u);
              d.forEach(function(g) {
                return C([m], g);
              });
            }) : C(v, u);
          }
        }
        w = this.extendTranslation(w, i, r, x), M && w === u && this.options.appendNamespaceToMissingKey && (w = "".concat(p, ":").concat(u)), M && this.options.parseMissingKeyHandler && (w = this.options.parseMissingKeyHandler(w));
      }
      return w;
    }
  }, {
    key: "extendTranslation",
    value: function(i, r, s, a) {
      var o = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        i = this.i18nFormat.parse(i, s, a.usedLng, a.usedNS, a.usedKey, {
          resolved: a
        });
      else if (!s.skipInterpolation) {
        s.interpolation && this.interpolator.init(Ln({}, s, {
          interpolation: Ln({}, this.options.interpolation, s.interpolation)
        }));
        var u = s.replace && typeof s.replace != "string" ? s.replace : s;
        this.options.interpolation.defaultVariables && (u = Ln({}, this.options.interpolation.defaultVariables, u)), i = this.interpolator.interpolate(i, u, s.lng || this.language, s), s.nest !== !1 && (i = this.interpolator.nest(i, function() {
          return o.translate.apply(o, arguments);
        }, s)), s.interpolation && this.interpolator.reset();
      }
      var l = s.postProcess || this.options.postProcess, p = typeof l == "string" ? [l] : l;
      return i != null && p && p.length && s.applyPostProcessor !== !1 && (i = i6.handle(p, i, r, this.options && this.options.postProcessPassResolved ? Ln({
        i18nResolved: a
      }, s) : s, this)), i;
    }
  }, {
    key: "resolve",
    value: function(i) {
      var r = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a, o, u, l, p;
      return typeof i == "string" && (i = [i]), i.forEach(function(f) {
        if (!r.isValidLookup(a)) {
          var b = r.extractFromKey(f, s), A = b.key;
          o = A;
          var x = b.namespaces;
          r.options.fallbackNS && (x = x.concat(r.options.fallbackNS));
          var w = s.count !== void 0 && typeof s.count != "string", T = s.context !== void 0 && typeof s.context == "string" && s.context !== "", _ = s.lngs ? s.lngs : r.languageUtils.toResolveHierarchy(s.lng || r.language, s.fallbackLng);
          x.forEach(function(I) {
            r.isValidLookup(a) || (p = I, r.utils && r.utils.hasLoadedNamespace && !r.utils.hasLoadedNamespace(p) && r.logger.warn('key "'.concat(o, '" for namespace "').concat(p, `" won't get resolved as namespace was not yet loaded`), "This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"), _.forEach(function($) {
              if (!r.isValidLookup(a)) {
                l = $;
                var N = A, B = [N];
                if (r.i18nFormat && r.i18nFormat.addLookupKeys)
                  r.i18nFormat.addLookupKeys(B, A, $, I, s);
                else {
                  var V;
                  w && (V = r.pluralResolver.getSuffix($, s.count)), w && T && B.push(N + V), T && B.push(N += "".concat(r.options.contextSeparator).concat(s.context)), w && B.push(N += V);
                }
                for (var K; K = B.pop(); )
                  r.isValidLookup(a) || (u = K, a = r.getResource($, I, K, s));
              }
            }));
          });
        }
      }), {
        res: a,
        usedKey: o,
        exactUsedKey: u,
        usedLng: l,
        usedNS: p
      };
    }
  }, {
    key: "isValidLookup",
    value: function(i) {
      return i !== void 0 && !(!this.options.returnNull && i === null) && !(!this.options.returnEmptyString && i === "");
    }
  }, {
    key: "getResource",
    value: function(i, r, s) {
      var a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(i, r, s, a) : this.resourceStore.getResource(i, r, s, a);
    }
  }]), e;
}(Es);
function hf(n) {
  return n.charAt(0).toUpperCase() + n.slice(1);
}
var I7 = /* @__PURE__ */ function() {
  function n(e) {
    Kr(this, n), this.options = e, this.whitelist = this.options.whitelist || !1, this.logger = Mr.create("languageUtils");
  }
  return Wr(n, [{
    key: "getScriptPartFromCode",
    value: function(t) {
      if (!t || t.indexOf("-") < 0)
        return null;
      var i = t.split("-");
      return i.length === 2 ? null : (i.pop(), this.formatLanguageCode(i.join("-")));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function(t) {
      if (!t || t.indexOf("-") < 0)
        return t;
      var i = t.split("-");
      return this.formatLanguageCode(i[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function(t) {
      if (typeof t == "string" && t.indexOf("-") > -1) {
        var i = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], r = t.split("-");
        return this.options.lowerCaseLng ? r = r.map(function(s) {
          return s.toLowerCase();
        }) : r.length === 2 ? (r[0] = r[0].toLowerCase(), r[1] = r[1].toUpperCase(), i.indexOf(r[1].toLowerCase()) > -1 && (r[1] = hf(r[1].toLowerCase()))) : r.length === 3 && (r[0] = r[0].toLowerCase(), r[1].length === 2 && (r[1] = r[1].toUpperCase()), r[0] !== "sgn" && r[2].length === 2 && (r[2] = r[2].toUpperCase()), i.indexOf(r[1].toLowerCase()) > -1 && (r[1] = hf(r[1].toLowerCase())), i.indexOf(r[2].toLowerCase()) > -1 && (r[2] = hf(r[2].toLowerCase()))), r.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
    }
  }, {
    key: "isWhitelisted",
    value: function(t) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitWhitelist) && (t = this.getLanguagePartFromCode(t)), !this.whitelist || !this.whitelist.length || this.whitelist.indexOf(t) > -1;
    }
  }, {
    key: "getFallbackCodes",
    value: function(t, i) {
      if (!t)
        return [];
      if (typeof t == "string" && (t = [t]), Object.prototype.toString.apply(t) === "[object Array]")
        return t;
      if (!i)
        return t.default || [];
      var r = t[i];
      return r || (r = t[this.getScriptPartFromCode(i)]), r || (r = t[this.formatLanguageCode(i)]), r || (r = t.default), r || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function(t, i) {
      var r = this, s = this.getFallbackCodes(i || this.options.fallbackLng || [], t), a = [], o = function(l) {
        l && (r.isWhitelisted(l) ? a.push(l) : r.logger.warn("rejecting non-whitelisted language code: ".concat(l)));
      };
      return typeof t == "string" && t.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && o(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && o(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && o(this.getLanguagePartFromCode(t))) : typeof t == "string" && o(this.formatLanguageCode(t)), s.forEach(function(u) {
        a.indexOf(u) < 0 && o(r.formatLanguageCode(u));
      }), a;
    }
  }]), n;
}(), O7 = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "id", "ja", "jbo", "ka", "kk", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he"],
  nr: [1, 2, 20, 21],
  fc: 22
}], B7 = {
  1: function(e) {
    return +(e > 1);
  },
  2: function(e) {
    return +(e != 1);
  },
  3: function(e) {
    return 0;
  },
  4: function(e) {
    return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
  },
  5: function(e) {
    return e === 0 ? 0 : e == 1 ? 1 : e == 2 ? 2 : e % 100 >= 3 && e % 100 <= 10 ? 3 : e % 100 >= 11 ? 4 : 5;
  },
  6: function(e) {
    return e == 1 ? 0 : e >= 2 && e <= 4 ? 1 : 2;
  },
  7: function(e) {
    return e == 1 ? 0 : e % 10 >= 2 && e % 10 <= 4 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
  },
  8: function(e) {
    return e == 1 ? 0 : e == 2 ? 1 : e != 8 && e != 11 ? 2 : 3;
  },
  9: function(e) {
    return +(e >= 2);
  },
  10: function(e) {
    return e == 1 ? 0 : e == 2 ? 1 : e < 7 ? 2 : e < 11 ? 3 : 4;
  },
  11: function(e) {
    return e == 1 || e == 11 ? 0 : e == 2 || e == 12 ? 1 : e > 2 && e < 20 ? 2 : 3;
  },
  12: function(e) {
    return +(e % 10 != 1 || e % 100 == 11);
  },
  13: function(e) {
    return +(e !== 0);
  },
  14: function(e) {
    return e == 1 ? 0 : e == 2 ? 1 : e == 3 ? 2 : 3;
  },
  15: function(e) {
    return e % 10 == 1 && e % 100 != 11 ? 0 : e % 10 >= 2 && (e % 100 < 10 || e % 100 >= 20) ? 1 : 2;
  },
  16: function(e) {
    return e % 10 == 1 && e % 100 != 11 ? 0 : e !== 0 ? 1 : 2;
  },
  17: function(e) {
    return e == 1 || e % 10 == 1 ? 0 : 1;
  },
  18: function(e) {
    return e == 0 ? 0 : e == 1 ? 1 : 2;
  },
  19: function(e) {
    return e == 1 ? 0 : e === 0 || e % 100 > 1 && e % 100 < 11 ? 1 : e % 100 > 10 && e % 100 < 20 ? 2 : 3;
  },
  20: function(e) {
    return e == 1 ? 0 : e === 0 || e % 100 > 0 && e % 100 < 20 ? 1 : 2;
  },
  21: function(e) {
    return e % 100 == 1 ? 1 : e % 100 == 2 ? 2 : e % 100 == 3 || e % 100 == 4 ? 3 : 0;
  },
  22: function(e) {
    return e === 1 ? 0 : e === 2 ? 1 : (e < 0 || e > 10) && e % 10 == 0 ? 2 : 3;
  }
};
function N7() {
  var n = {};
  return O7.forEach(function(e) {
    e.lngs.forEach(function(t) {
      n[t] = {
        numbers: e.nr,
        plurals: B7[e.fc]
      };
    });
  }), n;
}
var D7 = /* @__PURE__ */ function() {
  function n(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Kr(this, n), this.languageUtils = e, this.options = t, this.logger = Mr.create("pluralResolver"), this.rules = N7();
  }
  return Wr(n, [{
    key: "addRule",
    value: function(t, i) {
      this.rules[t] = i;
    }
  }, {
    key: "getRule",
    value: function(t) {
      return this.rules[t] || this.rules[this.languageUtils.getLanguagePartFromCode(t)];
    }
  }, {
    key: "needsPlural",
    value: function(t) {
      var i = this.getRule(t);
      return i && i.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function(t, i) {
      var r = this, s = [], a = this.getRule(t);
      return a && a.numbers.forEach(function(o) {
        var u = r.getSuffix(t, o);
        s.push("".concat(i).concat(u));
      }), s;
    }
  }, {
    key: "getSuffix",
    value: function(t, i) {
      var r = this, s = this.getRule(t);
      if (s) {
        var a = s.noAbs ? s.plurals(i) : s.plurals(Math.abs(i)), o = s.numbers[a];
        this.options.simplifyPluralSuffix && s.numbers.length === 2 && s.numbers[0] === 1 && (o === 2 ? o = "plural" : o === 1 && (o = ""));
        var u = function() {
          return r.options.prepend && o.toString() ? r.options.prepend + o.toString() : o.toString();
        };
        return this.options.compatibilityJSON === "v1" ? o === 1 ? "" : typeof o == "number" ? "_plural_".concat(o.toString()) : u() : (
          /* v2 */
          this.options.compatibilityJSON === "v2" || /* v3 - gettext index */
          this.options.simplifyPluralSuffix && s.numbers.length === 2 && s.numbers[0] === 1 ? u() : this.options.prepend && a.toString() ? this.options.prepend + a.toString() : a.toString()
        );
      }
      return this.logger.warn("no plural rule found for: ".concat(t)), "";
    }
  }]), n;
}(), $7 = /* @__PURE__ */ function() {
  function n() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Kr(this, n), this.logger = Mr.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || function(t) {
      return t;
    }, this.init(e);
  }
  return Wr(n, [{
    key: "init",
    value: function() {
      var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      t.interpolation || (t.interpolation = {
        escapeValue: !0
      });
      var i = t.interpolation;
      this.escape = i.escape !== void 0 ? i.escape : k7, this.escapeValue = i.escapeValue !== void 0 ? i.escapeValue : !0, this.useRawValueToEscape = i.useRawValueToEscape !== void 0 ? i.useRawValueToEscape : !1, this.prefix = i.prefix ? Wa(i.prefix) : i.prefixEscaped || "{{", this.suffix = i.suffix ? Wa(i.suffix) : i.suffixEscaped || "}}", this.formatSeparator = i.formatSeparator ? i.formatSeparator : i.formatSeparator || ",", this.unescapePrefix = i.unescapeSuffix ? "" : i.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : i.unescapeSuffix || "", this.nestingPrefix = i.nestingPrefix ? Wa(i.nestingPrefix) : i.nestingPrefixEscaped || Wa("$t("), this.nestingSuffix = i.nestingSuffix ? Wa(i.nestingSuffix) : i.nestingSuffixEscaped || Wa(")"), this.maxReplaces = i.maxReplaces ? i.maxReplaces : 1e3, this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function() {
      this.options && this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function() {
      var t = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(t, "g");
      var i = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(i, "g");
      var r = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(r, "g");
    }
  }, {
    key: "interpolate",
    value: function(t, i, r, s) {
      var a = this, o, u, l, p = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function f(T) {
        return T.replace(/\$/g, "$$$$");
      }
      var b = function(_) {
        if (_.indexOf(a.formatSeparator) < 0)
          return Ug(i, p, _);
        var I = _.split(a.formatSeparator), $ = I.shift().trim(), N = I.join(a.formatSeparator).trim();
        return a.format(Ug(i, p, $), N, r);
      };
      this.resetRegExp();
      var A = s && s.missingInterpolationHandler || this.options.missingInterpolationHandler;
      for (l = 0; o = this.regexpUnescape.exec(t); ) {
        if (u = b(o[1].trim()), u === void 0)
          if (typeof A == "function") {
            var x = A(t, o, s);
            u = typeof x == "string" ? x : "";
          } else
            this.logger.warn("missed to pass in variable ".concat(o[1], " for interpolating ").concat(t)), u = "";
        else
          typeof u != "string" && !this.useRawValueToEscape && (u = yf(u));
        if (t = t.replace(o[0], f(u)), this.regexpUnescape.lastIndex = 0, l++, l >= this.maxReplaces)
          break;
      }
      for (l = 0; o = this.regexp.exec(t); ) {
        if (u = b(o[1].trim()), u === void 0)
          if (typeof A == "function") {
            var w = A(t, o, s);
            u = typeof w == "string" ? w : "";
          } else
            this.logger.warn("missed to pass in variable ".concat(o[1], " for interpolating ").concat(t)), u = "";
        else
          typeof u != "string" && !this.useRawValueToEscape && (u = yf(u));
        if (u = this.escapeValue ? f(this.escape(u)) : f(u), t = t.replace(o[0], u), this.regexp.lastIndex = 0, l++, l >= this.maxReplaces)
          break;
      }
      return t;
    }
  }, {
    key: "nest",
    value: function(t, i) {
      var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, s, a, o = Ln({}, r);
      o.applyPostProcessor = !1, delete o.defaultValue;
      function u(l, p) {
        if (l.indexOf(",") < 0)
          return l;
        var f = l.split(",");
        l = f.shift();
        var b = f.join(",");
        b = this.interpolate(b, o), b = b.replace(/'/g, '"');
        try {
          o = JSON.parse(b), p && (o = Ln({}, p, o));
        } catch (A) {
          this.logger.error("failed parsing options string in nesting for key ".concat(l), A);
        }
        return delete o.defaultValue, l;
      }
      for (; s = this.nestingRegexp.exec(t); ) {
        if (a = i(u.call(this, s[1].trim(), o), o), a && s[0] === t && typeof a != "string")
          return a;
        typeof a != "string" && (a = yf(a)), a || (this.logger.warn("missed to resolve ".concat(s[1], " for nesting ").concat(t)), a = ""), t = t.replace(s[0], a), this.regexp.lastIndex = 0;
      }
      return t;
    }
  }]), n;
}();
function F7(n, e) {
  for (var t = n.indexOf(e); t !== -1; )
    n.splice(t, 1), t = n.indexOf(e);
}
var L7 = /* @__PURE__ */ function(n) {
  tp(e, n);
  function e(t, i, r) {
    var s, a = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return Kr(this, e), s = Xu(this, Ao(e).call(this)), Es.call(ha(s)), s.backend = t, s.store = i, s.services = r, s.languageUtils = r.languageUtils, s.options = a, s.logger = Mr.create("backendConnector"), s.state = {}, s.queue = [], s.backend && s.backend.init && s.backend.init(r, a.backend, a), s;
  }
  return Wr(e, [{
    key: "queueLoad",
    value: function(i, r, s, a) {
      var o = this, u = [], l = [], p = [], f = [];
      return i.forEach(function(b) {
        var A = !0;
        r.forEach(function(x) {
          var w = "".concat(b, "|").concat(x);
          !s.reload && o.store.hasResourceBundle(b, x) ? o.state[w] = 2 : o.state[w] < 0 || (o.state[w] === 1 ? l.indexOf(w) < 0 && l.push(w) : (o.state[w] = 1, A = !1, l.indexOf(w) < 0 && l.push(w), u.indexOf(w) < 0 && u.push(w), f.indexOf(x) < 0 && f.push(x)));
        }), A || p.push(b);
      }), (u.length || l.length) && this.queue.push({
        pending: l,
        loaded: {},
        errors: [],
        callback: a
      }), {
        toLoad: u,
        pending: l,
        toLoadLanguages: p,
        toLoadNamespaces: f
      };
    }
  }, {
    key: "loaded",
    value: function(i, r, s) {
      var a = i.split("|"), o = Fg(a, 2), u = o[0], l = o[1];
      r && this.emit("failedLoading", u, l, r), s && this.store.addResourceBundle(u, l, s), this.state[i] = r ? -1 : 2;
      var p = {};
      this.queue.forEach(function(f) {
        _7(f.loaded, [u], l), F7(f.pending, i), r && f.errors.push(r), f.pending.length === 0 && !f.done && (Object.keys(f.loaded).forEach(function(b) {
          p[b] || (p[b] = []), f.loaded[b].length && f.loaded[b].forEach(function(A) {
            p[b].indexOf(A) < 0 && p[b].push(A);
          });
        }), f.done = !0, f.errors.length ? f.callback(f.errors) : f.callback());
      }), this.emit("loaded", p), this.queue = this.queue.filter(function(f) {
        return !f.done;
      });
    }
  }, {
    key: "read",
    value: function(i, r, s) {
      var a = this, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 250, l = arguments.length > 5 ? arguments[5] : void 0;
      return i.length ? this.backend[s](i, r, function(p, f) {
        if (p && f && o < 5) {
          setTimeout(function() {
            a.read.call(a, i, r, s, o + 1, u * 2, l);
          }, u);
          return;
        }
        l(p, f);
      }) : l(null, {});
    }
    /* eslint consistent-return: 0 */
  }, {
    key: "prepareLoading",
    value: function(i, r) {
      var s = this, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), o && o();
      typeof i == "string" && (i = this.languageUtils.toResolveHierarchy(i)), typeof r == "string" && (r = [r]);
      var u = this.queueLoad(i, r, a, o);
      if (!u.toLoad.length)
        return u.pending.length || o(), null;
      u.toLoad.forEach(function(l) {
        s.loadOne(l);
      });
    }
  }, {
    key: "load",
    value: function(i, r, s) {
      this.prepareLoading(i, r, {}, s);
    }
  }, {
    key: "reload",
    value: function(i, r, s) {
      this.prepareLoading(i, r, {
        reload: !0
      }, s);
    }
  }, {
    key: "loadOne",
    value: function(i) {
      var r = this, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", a = i.split("|"), o = Fg(a, 2), u = o[0], l = o[1];
      this.read(u, l, "read", null, null, function(p, f) {
        p && r.logger.warn("".concat(s, "loading namespace ").concat(l, " for language ").concat(u, " failed"), p), !p && f && r.logger.log("".concat(s, "loaded namespace ").concat(l, " for language ").concat(u), f), r.loaded(i, p, f);
      });
    }
  }, {
    key: "saveMissing",
    value: function(i, r, s, a, o) {
      var u = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(r)) {
        this.logger.warn('did not save key "'.concat(s, '" for namespace "').concat(r, '" as the namespace was not yet loaded'), "This means something IS WRONG in your application setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      this.backend && this.backend.create && this.backend.create(
        i,
        r,
        s,
        a,
        null,
        Ln({}, u, {
          isUpdate: o
        })
      ), !(!i || !i[0]) && this.store.addResource(i[0], r, s, a);
    }
  }]), e;
}(Es);
function U7() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    // string or array of namespaces
    whitelist: !1,
    // array with whitelisted languages
    nonExplicitWhitelist: !1,
    load: "all",
    // | currentOnly | languageOnly
    preload: !1,
    // array with preload languages
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    // allow bundling certain languages that are not remotely fetched
    saveMissing: !1,
    // enable to send missing values
    updateMissing: !1,
    // enable to update default values if different from translated value (only useful on initial development, or when keeping code as source of truth)
    saveMissingTo: "fallback",
    // 'current' || 'all'
    saveMissingPlurals: !0,
    // will save all forms not only singular key
    missingKeyHandler: !1,
    // function(lng, ns, key, fallbackValue) -> override if prefer on handling
    missingInterpolationHandler: !1,
    // function(str, match)
    postProcess: !1,
    // string or array of postProcessor names
    postProcessPassResolved: !1,
    // pass resolved object into 'options.i18nResolved' for postprocessor
    returnNull: !0,
    // allows null value as valid translation
    returnEmptyString: !0,
    // allows empty string value as valid translation
    returnObjects: !1,
    joinArrays: !1,
    // or string to join array
    returnedObjectHandler: !1,
    // function(key, value, options) triggered if key returns object but returnObjects is set to false
    parseMissingKeyHandler: !1,
    // function(key) parsed a key that was not found in t() before returning
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      var t = {};
      if ($i(e[1]) === "object" && (t = e[1]), typeof e[1] == "string" && (t.defaultValue = e[1]), typeof e[2] == "string" && (t.tDescription = e[2]), $i(e[2]) === "object" || $i(e[3]) === "object") {
        var i = e[3] || e[2];
        Object.keys(i).forEach(function(r) {
          t[r] = i[r];
        });
      }
      return t;
    },
    interpolation: {
      escapeValue: !0,
      format: function(e, t, i) {
        return e;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      // prefixEscaped: '{{',
      // suffixEscaped: '}}',
      // unescapeSuffix: '',
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      // nestingPrefixEscaped: '$t(',
      // nestingSuffixEscaped: ')',
      // defaultVariables: undefined // object that can have values to interpolate on - extends passed in interpolation data
      maxReplaces: 1e3
      // max replaces to prevent endless loop
    }
  };
}
function jg(n) {
  return typeof n.ns == "string" && (n.ns = [n.ns]), typeof n.fallbackLng == "string" && (n.fallbackLng = [n.fallbackLng]), typeof n.fallbackNS == "string" && (n.fallbackNS = [n.fallbackNS]), n.whitelist && n.whitelist.indexOf("cimode") < 0 && (n.whitelist = n.whitelist.concat(["cimode"])), n;
}
function uc() {
}
var V7 = /* @__PURE__ */ function(n) {
  tp(e, n);
  function e() {
    var t, i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
    if (Kr(this, e), t = Xu(this, Ao(e).call(this)), Es.call(ha(t)), t.options = jg(i), t.services = {}, t.logger = Mr, t.modules = {
      external: []
    }, r && !t.isInitialized && !i.isClone) {
      if (!t.options.initImmediate)
        return t.init(i, r), Xu(t, ha(t));
      setTimeout(function() {
        t.init(i, r);
      }, 0);
    }
    return t;
  }
  return Wr(e, [{
    key: "init",
    value: function() {
      var i = this, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
      typeof r == "function" && (s = r, r = {}), this.options = Ln({}, U7(), this.options, jg(r)), this.format = this.options.interpolation.format, s || (s = uc);
      function a(b) {
        return b ? typeof b == "function" ? new b() : b : null;
      }
      if (!this.options.isClone) {
        this.modules.logger ? Mr.init(a(this.modules.logger), this.options) : Mr.init(null, this.options);
        var o = new I7(this.options);
        this.store = new P7(this.options.resources, this.options);
        var u = this.services;
        u.logger = Mr, u.resourceStore = this.store, u.languageUtils = o, u.pluralResolver = new D7(o, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), u.interpolator = new $7(this.options), u.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, u.backendConnector = new L7(a(this.modules.backend), u.resourceStore, u, this.options), u.backendConnector.on("*", function(b) {
          for (var A = arguments.length, x = new Array(A > 1 ? A - 1 : 0), w = 1; w < A; w++)
            x[w - 1] = arguments[w];
          i.emit.apply(i, [b].concat(x));
        }), this.modules.languageDetector && (u.languageDetector = a(this.modules.languageDetector), u.languageDetector.init(u, this.options.detection, this.options)), this.modules.i18nFormat && (u.i18nFormat = a(this.modules.i18nFormat), u.i18nFormat.init && u.i18nFormat.init(this)), this.translator = new Vg(this.services, this.options), this.translator.on("*", function(b) {
          for (var A = arguments.length, x = new Array(A > 1 ? A - 1 : 0), w = 1; w < A; w++)
            x[w - 1] = arguments[w];
          i.emit.apply(i, [b].concat(x));
        }), this.modules.external.forEach(function(b) {
          b.init && b.init(i);
        });
      }
      var l = ["getResource", "addResource", "addResources", "addResourceBundle", "removeResourceBundle", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      l.forEach(function(b) {
        i[b] = function() {
          var A;
          return (A = i.store)[b].apply(A, arguments);
        };
      });
      var p = ru(), f = function() {
        i.changeLanguage(i.options.lng, function(A, x) {
          i.isInitialized = !0, i.logger.log("initialized", i.options), i.emit("initialized", i.options), p.resolve(x), s(A, x);
        });
      };
      return this.options.resources || !this.options.initImmediate ? f() : setTimeout(f, 0), p;
    }
    /* eslint consistent-return: 0 */
  }, {
    key: "loadResources",
    value: function() {
      var i = this, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : uc;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (this.language && this.language.toLowerCase() === "cimode")
          return r();
        var s = [], a = function(l) {
          if (l) {
            var p = i.services.languageUtils.toResolveHierarchy(l);
            p.forEach(function(f) {
              s.indexOf(f) < 0 && s.push(f);
            });
          }
        };
        if (this.language)
          a(this.language);
        else {
          var o = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          o.forEach(function(u) {
            return a(u);
          });
        }
        this.options.preload && this.options.preload.forEach(function(u) {
          return a(u);
        }), this.services.backendConnector.load(s, this.options.ns, r);
      } else
        r(null);
    }
  }, {
    key: "reloadResources",
    value: function(i, r, s) {
      var a = ru();
      return i || (i = this.languages), r || (r = this.options.ns), s || (s = uc), this.services.backendConnector.reload(i, r, function(o) {
        a.resolve(), s(o);
      }), a;
    }
  }, {
    key: "use",
    value: function(i) {
      return i.type === "backend" && (this.modules.backend = i), (i.type === "logger" || i.log && i.warn && i.error) && (this.modules.logger = i), i.type === "languageDetector" && (this.modules.languageDetector = i), i.type === "i18nFormat" && (this.modules.i18nFormat = i), i.type === "postProcessor" && i6.addPostProcessor(i), i.type === "3rdParty" && this.modules.external.push(i), this;
    }
  }, {
    key: "changeLanguage",
    value: function(i, r) {
      var s = this, a = ru();
      this.emit("languageChanging", i);
      var o = function(p, f) {
        s.translator.changeLanguage(f), f && (s.emit("languageChanged", f), s.logger.log("languageChanged", f)), a.resolve(function() {
          return s.t.apply(s, arguments);
        }), r && r(p, function() {
          return s.t.apply(s, arguments);
        });
      }, u = function(p) {
        p && (s.language = p, s.languages = s.services.languageUtils.toResolveHierarchy(p), s.translator.language || s.translator.changeLanguage(p), s.services.languageDetector && s.services.languageDetector.cacheUserLanguage(p)), s.loadResources(function(f) {
          o(f, p);
        });
      };
      return !i && this.services.languageDetector && !this.services.languageDetector.async ? u(this.services.languageDetector.detect()) : !i && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(u) : u(i), a;
    }
  }, {
    key: "getFixedT",
    value: function(i, r) {
      var s = this, a = function o(u, l) {
        var p;
        if ($i(l) !== "object") {
          for (var f = arguments.length, b = new Array(f > 2 ? f - 2 : 0), A = 2; A < f; A++)
            b[A - 2] = arguments[A];
          p = s.options.overloadTranslationOptionHandler([u, l].concat(b));
        } else
          p = Ln({}, l);
        return p.lng = p.lng || o.lng, p.lngs = p.lngs || o.lngs, p.ns = p.ns || o.ns, s.t(u, p);
      };
      return typeof i == "string" ? a.lng = i : a.lngs = i, a.ns = r, a;
    }
  }, {
    key: "t",
    value: function() {
      var i;
      return this.translator && (i = this.translator).translate.apply(i, arguments);
    }
  }, {
    key: "exists",
    value: function() {
      var i;
      return this.translator && (i = this.translator).exists.apply(i, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function(i) {
      this.options.defaultNS = i;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function(i) {
      var r = this;
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var s = this.languages[0], a = this.options ? this.options.fallbackLng : !1, o = this.languages[this.languages.length - 1];
      if (s.toLowerCase() === "cimode")
        return !0;
      var u = function(p, f) {
        var b = r.services.backendConnector.state["".concat(p, "|").concat(f)];
        return b === -1 || b === 2;
      };
      return !!(this.hasResourceBundle(s, i) || !this.services.backendConnector.backend || u(s, i) && (!a || u(o, i)));
    }
  }, {
    key: "loadNamespaces",
    value: function(i, r) {
      var s = this, a = ru();
      return this.options.ns ? (typeof i == "string" && (i = [i]), i.forEach(function(o) {
        s.options.ns.indexOf(o) < 0 && s.options.ns.push(o);
      }), this.loadResources(function(o) {
        a.resolve(), r && r(o);
      }), a) : (r && r(), Promise.resolve());
    }
  }, {
    key: "loadLanguages",
    value: function(i, r) {
      var s = ru();
      typeof i == "string" && (i = [i]);
      var a = this.options.preload || [], o = i.filter(function(u) {
        return a.indexOf(u) < 0;
      });
      return o.length ? (this.options.preload = a.concat(o), this.loadResources(function(u) {
        s.resolve(), r && r(u);
      }), s) : (r && r(), Promise.resolve());
    }
  }, {
    key: "dir",
    value: function(i) {
      if (i || (i = this.languages && this.languages.length > 0 ? this.languages[0] : this.language), !i)
        return "rtl";
      var r = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
      return r.indexOf(this.services.languageUtils.getLanguagePartFromCode(i)) >= 0 ? "rtl" : "ltr";
    }
    /* eslint class-methods-use-this: 0 */
  }, {
    key: "createInstance",
    value: function() {
      var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
      return new e(i, r);
    }
  }, {
    key: "cloneInstance",
    value: function() {
      var i = this, r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : uc, a = Ln({}, this.options, r, {
        isClone: !0
      }), o = new e(a), u = ["store", "services", "language"];
      return u.forEach(function(l) {
        o[l] = i[l];
      }), o.translator = new Vg(o.services, o.options), o.translator.on("*", function(l) {
        for (var p = arguments.length, f = new Array(p > 1 ? p - 1 : 0), b = 1; b < p; b++)
          f[b - 1] = arguments[b];
        o.emit.apply(o, [l].concat(f));
      }), o.init(a, s), o.translator.options = o.options, o;
    }
  }]), e;
}(Es);
new V7();
function Bn(n, e, t, i) {
  var r = arguments.length, s = r < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, a;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(n, e, t, i);
  else
    for (var o = n.length - 1; o >= 0; o--)
      (a = n[o]) && (s = (r < 3 ? a(s) : r > 3 ? a(e, t, s) : a(e, t)) || s);
  return r > 3 && s && Object.defineProperty(e, t, s), s;
}
function fs(n, e) {
  return function(t, i) {
    e(t, i, n);
  };
}
var zg;
(function(n) {
  n.I18N_EA_CHANNEL = "i18n:locale:changed", n.I18N_SIGNAL = "aurelia-translation-signal", n.RT_SIGNAL = "aurelia-relativetime-signal";
})(zg || (zg = {}));
var Gg;
(function(n) {
  n.translationValueConverterName = "t", n.dateFormatValueConverterName = "df", n.numberFormatValueConverterName = "nf", n.relativeTimeValueConverterName = "rt";
})(Gg || (Gg = {}));
function t0(n, e) {
  const t = e.ast.expression;
  if (!(t instanceof qu)) {
    const i = new qu(t, n, e.ast.args);
    e.ast.expression = i;
  }
}
let qg = class {
  bind(e, t) {
    t0("df", t);
  }
};
qg = Bn([Kn("df")], qg);
const j7 = ye.createInterface("I18nInitOptions"), z7 = ye.createInterface("I18nextWrapper");
var Hg;
(function(n) {
  n[n.Second = 1e3] = "Second", n[n.Minute = 6e4] = "Minute", n[n.Hour = 36e5] = "Hour", n[n.Day = 864e5] = "Day", n[n.Week = 6048e5] = "Week", n[n.Month = 2592e6] = "Month", n[n.Year = 31536e6] = "Year";
})(Hg || (Hg = {}));
class G7 {
  constructor(e) {
    this.value = void 0;
    const t = /\[([a-z\-, ]*)\]/gi;
    this.attributes = [];
    const i = t.exec(e);
    i && (e = e.replace(i[0], ""), this.attributes = i[1].split(",")), this.key = e;
  }
}
const Na = ye.createInterface("I18N");
let vy = class {
  constructor(e, t, i, r) {
    this.ea = i, this.i = /* @__PURE__ */ new Set(), this.i18next = e.i18next, this.initPromise = this.h(t), this.u = r;
  }
  evaluate(e, t) {
    const i = e.split(";"), r = [];
    for (const s of i) {
      const a = new G7(s), o = a.key, u = this.tr(o, t);
      this.options.skipTranslationOnMissingKey && u === o ? console.warn(`Couldn't find translation for key: ${o}`) : (a.value = u, r.push(a));
    }
    return r;
  }
  tr(e, t) {
    return this.i18next.t(e, t);
  }
  getLocale() {
    return this.i18next.language;
  }
  async setLocale(e) {
    const i = {
      oldLocale: this.getLocale(),
      newLocale: e
    };
    await this.i18next.changeLanguage(e), this.ea.publish("i18n:locale:changed", i), this.i.forEach((r) => r.handleLocaleChange(i)), this.u.dispatchSignal("aurelia-translation-signal");
  }
  createNumberFormat(e, t) {
    return Intl.NumberFormat(t || this.getLocale(), e);
  }
  nf(e, t, i) {
    return this.createNumberFormat(t, i).format(e);
  }
  createDateTimeFormat(e, t) {
    return Intl.DateTimeFormat(t || this.getLocale(), e);
  }
  df(e, t, i) {
    return this.createDateTimeFormat(t, i).format(e);
  }
  uf(e, t) {
    const i = this.nf(3333.3333333333335, void 0, t);
    let r = i[1];
    const s = i[5];
    r === "." && (r = "\\.");
    const a = e.replace(new RegExp(r, "g"), "").replace(/[^\d.,-]/g, "").replace(s, ".");
    return Number(a);
  }
  createRelativeTimeFormat(e, t) {
    return new Intl.RelativeTimeFormat(t || this.getLocale(), e);
  }
  rt(e, t, i) {
    let r = e.getTime() - this.now();
    const s = this.options.rtEpsilon * (r > 0 ? 1 : 0), a = this.createRelativeTimeFormat(t, i);
    let o = r / 31536e6;
    return Math.abs(o + s) >= 1 ? a.format(Math.round(o), "year") : (o = r / 2592e6, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "month") : (o = r / 6048e5, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "week") : (o = r / 864e5, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "day") : (o = r / 36e5, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "hour") : (o = r / 6e4, Math.abs(o + s) >= 1 ? a.format(Math.round(o), "minute") : (r = Math.abs(r) < 1e3 ? 1e3 : r, o = r / 1e3, a.format(Math.round(o), "second")))))));
  }
  subscribeLocaleChange(e) {
    this.i.add(e);
  }
  now() {
    return (/* @__PURE__ */ new Date()).getTime();
  }
  async h(e) {
    const t = {
      lng: "en",
      fallbackLng: ["en"],
      debug: !1,
      plugins: [],
      rtEpsilon: 0.01,
      skipTranslationOnMissingKey: !1
    };
    this.options = {
      ...t,
      ...e
    };
    for (const i of this.options.plugins)
      this.i18next.use(i);
    await this.i18next.init(this.options);
  }
};
Bn([u8], vy.prototype, "i18next", void 0);
vy = Bn([fs(0, z7), fs(1, j7), fs(2, Kd), fs(3, Sh)], vy);
let Kg = class {
  constructor(e) {
    this.i18n = e, this.signals = ["aurelia-translation-signal"];
  }
  toView(e, t, i) {
    if (!e && e !== 0 || typeof e == "string" && e.trim() === "")
      return e;
    if (typeof e == "string") {
      const r = Number(e), s = new Date(Number.isInteger(r) ? r : e);
      if (isNaN(s.getTime()))
        return e;
      e = s;
    }
    return this.i18n.df(e, t, i);
  }
};
Kg = Bn([kl("df"), fs(0, Na)], Kg);
let Wg = class {
  bind(e, t) {
    t0("nf", t);
  }
};
Wg = Bn([Kn("nf")], Wg);
let Jg = class {
  constructor(e) {
    this.i18n = e, this.signals = ["aurelia-translation-signal"];
  }
  toView(e, t, i) {
    return typeof e != "number" ? e : this.i18n.nf(e, t, i);
  }
};
Jg = Bn([kl("nf"), fs(0, Na)], Jg);
let Qg = class {
  bind(e, t) {
    t0("rt", t);
  }
};
Qg = Bn([Kn("rt")], Qg);
let Yg = class {
  constructor(e) {
    this.i18n = e, this.signals = ["aurelia-translation-signal", "aurelia-relativetime-signal"];
  }
  toView(e, t, i) {
    return e instanceof Date ? this.i18n.rt(e, t, i) : e;
  }
};
Yg = Bn([kl("rt"), fs(0, Na)], Yg);
let Xg = class {
  bind(e, t) {
    const i = t.ast.expression;
    if (!(i instanceof qu)) {
      const r = new qu(i, "t", t.ast.args);
      t.ast.expression = r;
    }
  }
};
Xg = Bn([Kn("t")], Xg);
const q7 = ["textContent", "innerHTML", "prepend", "append"], H7 = /* @__PURE__ */ new Map([["text", "textContent"], ["html", "innerHTML"]]), K7 = {
  optional: !0
}, W7 = {
  reusable: !1,
  preempt: !0
};
class $r {
  constructor(e, t, i, r, s) {
    this.isBound = !1, this.T = q7, this.B = null, this.parameter = null, this.boundFn = !1, this.l = t, this.C = e, this.target = s, this.i18n = t.get(Na), this.p = r, this.I = /* @__PURE__ */ new Set(), this.oL = i, this.i18n.subscribeLocaleChange(this), this.P = r.domWriteQueue;
  }
  static create({ parser: e, observerLocator: t, context: i, controller: r, target: s, instruction: a, platform: o, isParameterContext: u }) {
    const l = this.M({
      observerLocator: t,
      context: i,
      controller: r,
      target: s,
      platform: o
    }), p = typeof a.from == "string" ? e.parse(a.from, 16) : a.from;
    if (u)
      l.useParameter(p);
    else {
      const f = p instanceof fh ? e.parse(p.value, 1) : void 0;
      l.ast = f || p;
    }
  }
  static M({ observerLocator: e, context: t, controller: i, target: r, platform: s }) {
    let a = i.bindings && i.bindings.find((o) => o instanceof $r && o.target === r);
    return a || (a = new $r(i, t, e, s, r), i.addBinding(a)), a;
  }
  bind(e) {
    if (!this.isBound) {
      if (!this.ast)
        throw new Error("key expression is missing");
      this.s = e, this.A = this.ast instanceof Ax, this.L = j(this.ast, e, this, this), this.R(), this.parameter?.bind(e), this.updateTranslations(), this.isBound = !0;
    }
  }
  unbind() {
    this.isBound && (fi(this.ast, this.s, this), this.parameter?.unbind(), this.I.clear(), this.B !== null && (this.B.cancel(), this.B = null), this.s = void 0, this.obs.clearAll());
  }
  handleChange(e, t) {
    this.obs.version++, this.L = this.A ? j(this.ast, this.s, this, this) : e, this.obs.clear(), this.R(), this.updateTranslations();
  }
  handleLocaleChange() {
    this.updateTranslations();
  }
  useParameter(e) {
    if (this.parameter != null)
      throw new Error("This translation parameter has already been specified.");
    this.parameter = new n0(this, e, () => this.updateTranslations());
  }
  updateTranslations() {
    const e = this.i18n.evaluate(this.L, this.parameter?.value), t = /* @__PURE__ */ Object.create(null), i = [], r = this.B;
    this.I.clear();
    for (const a of e) {
      const o = a.value, u = this.N(a.attributes);
      for (const l of u)
        if (this.O(l))
          t[l] = o;
        else {
          const p = po.for(this.target, K7), f = p?.viewModel ? this.oL.getAccessor(p.viewModel, l) : this.oL.getAccessor(this.target, l);
          this.C.state !== 1 && (4 & f.type) > 0 ? i.push(new J7(f, o, this.target, l)) : f.setValue(o, this.target, l), this.I.add(f);
        }
    }
    let s = !1;
    Object.keys(t).length > 0 && (s = this.C.state !== 1, s || this.V(t)), (i.length > 0 || s) && (this.B = this.P.queueTask(() => {
      this.B = null;
      for (const a of i)
        a.run();
      s && this.V(t);
    }, W7)), r?.cancel();
  }
  N(e) {
    e.length === 0 && (e = this.target.tagName === "IMG" ? ["src"] : ["textContent"]);
    for (const [t, i] of H7) {
      const r = e.findIndex((s) => s === t);
      r > -1 && e.splice(r, 1, i);
    }
    return e;
  }
  O(e) {
    return this.T.includes(e);
  }
  V(e) {
    const t = Kp(this.target.childNodes), i = [], r = "au-i18n";
    for (const a of t)
      Reflect.get(a, r) || i.push(a);
    const s = this._(e, r, i);
    this.target.innerHTML = "";
    for (const a of Kp(s.content.childNodes))
      this.target.appendChild(a);
  }
  _(e, t, i) {
    const r = this.p.document.createElement("template");
    if (this.F(r, e.prepend, t), !this.F(r, e.innerHTML ?? e.textContent, t))
      for (const s of i)
        r.content.append(s);
    return this.F(r, e.append, t), r;
  }
  F(e, t, i) {
    if (t != null) {
      const r = this.p.document.createElement("div");
      r.innerHTML = t;
      for (const s of Kp(r.childNodes))
        Reflect.set(s, i, !0), e.content.append(s);
      return !0;
    }
    return !1;
  }
  R() {
    const e = this.L ?? (this.L = ""), t = typeof e;
    if (t !== "string")
      throw new Error(`Expected the i18n key to be a string, but got ${e} of type ${t}`);
  }
}
Ui($r);
pr(!0)($r);
Oa($r, () => "updateTranslations");
class J7 {
  constructor(e, t, i, r) {
    this.accessor = e, this.v = t, this.el = i, this.attr = r;
  }
  run() {
    this.accessor.setValue(this.v, this.el, this.attr);
  }
}
class n0 {
  constructor(e, t, i) {
    this.owner = e, this.ast = t, this.updater = i, this.isBound = !1, this.boundFn = !1, this.oL = e.oL, this.l = e.l;
  }
  handleChange(e, t) {
    this.isBound && (this.obs.version++, this.value = j(this.ast, this.s, this, this), this.obs.clear(), this.updater());
  }
  bind(e) {
    this.isBound || (this.s = e, Ni(this.ast, e, this), this.value = j(this.ast, e, this, this), this.isBound = !0);
  }
  unbind() {
    this.isBound && (fi(this.ast, this.s, this), this.s = void 0, this.obs.clearAll());
  }
}
Ui(n0);
pr(!0)(n0);
const r6 = "tpt", Zu = "t-params.bind";
let Zg = class {
  [Zu](e, t, i) {
    return new bi(e, t, "", Zu);
  }
};
Zg = Bn([Gr({
  pattern: Zu,
  symbols: ""
})], Zg);
class Q7 {
  constructor(e, t) {
    this.from = e, this.to = t, this.type = r6, this.mode = 2;
  }
}
let e2 = class {
  constructor() {
    this.type = 0;
  }
  get name() {
    return Zu;
  }
  build(e, t, i) {
    const r = e.attr;
    let s = r.target;
    return e.bindable == null ? s = i.map(e.node, s) ?? ti(s) : s = e.bindable.property, new Q7(t.parse(r.rawValue, 16), s);
  }
};
e2 = Bn([Wn(Zu)], e2);
let t2 = class {
  render(e, t, i, r, s, a) {
    $r.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: i,
      isParameterContext: !0,
      platform: r
    });
  }
};
t2 = Bn([jt(r6)], t2);
const Y7 = "tt";
let n2 = class {
  render(e, t, i, r, s, a) {
    $r.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: i,
      platform: r
    });
  }
};
n2 = Bn([jt(Y7)], n2);
const X7 = "tbt";
let i2 = class {
  render(e, t, i, r, s, a) {
    $r.create({
      parser: s,
      observerLocator: a,
      context: e.container,
      controller: e,
      target: t,
      instruction: i,
      platform: r
    });
  }
};
i2 = Bn([jt(X7)], i2);
let r2 = class {
  constructor(e) {
    this.i18n = e, this.signals = ["aurelia-translation-signal"];
  }
  toView(e, t) {
    return this.i18n.tr(e, t);
  }
};
r2 = Bn([kl("t"), fs(0, Na)], r2);
Array.prototype.sum = function() {
  return this.reduce((n, e) => n + e, 0);
};
const Da = ye.createInterface(), Z7 = {
  authDomain: "kolektivo-36b63.firebaseapp.com",
  projectId: "kolektivo-36b63",
  storageBucket: "kolektivo-36b63.appspot.com",
  messagingSenderId: "324595180464",
  appId: "1:324595180464:web:69e6b83cdba3bf2d30ac75",
  measurementId: "G-7BSHV1Y6VS"
}, Fl = ye.createInterface("CacheService");
class np {
  cache = /* @__PURE__ */ new Map();
  setItem(e, t) {
    this.cache.set(e, t);
  }
  getItem(e) {
    return this.cache.get(e);
  }
  static register(e) {
    fe.singleton(Fl, np).register(e);
  }
}
const mf = (n, e) => {
  const t = n[e];
  return t ? typeof t == "function" ? t() : Promise.resolve(t) : new Promise((i, r) => {
    (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(r.bind(null, new Error("Unknown variable dynamic import: " + e)));
  });
};
function s6(n) {
  return function(e, t, i) {
    const r = `${e.constructor.name}_${t}`, s = i.value;
    return i.value = function(...a) {
      const { storage: o } = n.call(this), u = `${r}_${JSON.stringify(a)}`;
      let l = o.getItem(u);
      return l || (l = s?.apply(this, a), o.setItem(u, l), l);
    }, i;
  };
}
const ip = ye.createInterface(), eS = "https://primedao.mypinata.cloud//", s2 = Number({}.KOL_CHAIN_ID ?? 42220), a2 = {}.KOL_CHAIN_URL ?? "https://forno.celo.org", o2 = {}.KOL_CHAIN ?? "Celo", tS = {}.KOL_SCAN_LINK ?? "https://explorer.celo.org/{type}/{address}", nS = !!({}.KOL_TESTING ?? !0), eo = "testData";
var ls = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Pt(n) {
  if (n.__esModule)
    return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function i() {
      if (this instanceof i) {
        var r = [null];
        r.push.apply(r, arguments);
        var s = Function.bind.apply(e, r);
        return new s();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else
    t = {};
  return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function(i) {
    var r = Object.getOwnPropertyDescriptor(n, i);
    Object.defineProperty(t, i, r.get ? r : {
      enumerable: !0,
      get: function() {
        return n[i];
      }
    });
  }), t;
}
var xy = {}, iS = {
  get exports() {
    return xy;
  },
  set exports(n) {
    xy = n;
  }
};
const rS = {}, sS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: rS
}, Symbol.toStringTag, { value: "Module" })), aS = /* @__PURE__ */ Pt(sS);
(function(n) {
  (function(e, t) {
    function i(M, c) {
      if (!M)
        throw new Error(c || "Assertion failed");
    }
    function r(M, c) {
      M.super_ = c;
      var h = function() {
      };
      h.prototype = c.prototype, M.prototype = new h(), M.prototype.constructor = M;
    }
    function s(M, c, h) {
      if (s.isBN(M))
        return M;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, M !== null && ((c === "le" || c === "be") && (h = c, c = 10), this._init(M || 0, c || 10, h || "be"));
    }
    typeof e == "object" ? e.exports = s : t.BN = s, s.BN = s, s.wordSize = 26;
    var a;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? a = window.Buffer : a = aS.Buffer;
    } catch {
    }
    s.isBN = function(c) {
      return c instanceof s ? !0 : c !== null && typeof c == "object" && c.constructor.wordSize === s.wordSize && Array.isArray(c.words);
    }, s.max = function(c, h) {
      return c.cmp(h) > 0 ? c : h;
    }, s.min = function(c, h) {
      return c.cmp(h) < 0 ? c : h;
    }, s.prototype._init = function(c, h, v) {
      if (typeof c == "number")
        return this._initNumber(c, h, v);
      if (typeof c == "object")
        return this._initArray(c, h, v);
      h === "hex" && (h = 16), i(h === (h | 0) && h >= 2 && h <= 36), c = c.toString().replace(/\s+/g, "");
      var S = 0;
      c[0] === "-" && (S++, this.negative = 1), S < c.length && (h === 16 ? this._parseHex(c, S, v) : (this._parseBase(c, h, S), v === "le" && this._initArray(this.toArray(), h, v)));
    }, s.prototype._initNumber = function(c, h, v) {
      c < 0 && (this.negative = 1, c = -c), c < 67108864 ? (this.words = [c & 67108863], this.length = 1) : c < 4503599627370496 ? (this.words = [
        c & 67108863,
        c / 67108864 & 67108863
      ], this.length = 2) : (i(c < 9007199254740992), this.words = [
        c & 67108863,
        c / 67108864 & 67108863,
        1
      ], this.length = 3), v === "le" && this._initArray(this.toArray(), h, v);
    }, s.prototype._initArray = function(c, h, v) {
      if (i(typeof c.length == "number"), c.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(c.length / 3), this.words = new Array(this.length);
      for (var S = 0; S < this.length; S++)
        this.words[S] = 0;
      var E, C, k = 0;
      if (v === "be")
        for (S = c.length - 1, E = 0; S >= 0; S -= 3)
          C = c[S] | c[S - 1] << 8 | c[S - 2] << 16, this.words[E] |= C << k & 67108863, this.words[E + 1] = C >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, E++);
      else if (v === "le")
        for (S = 0, E = 0; S < c.length; S += 3)
          C = c[S] | c[S + 1] << 8 | c[S + 2] << 16, this.words[E] |= C << k & 67108863, this.words[E + 1] = C >>> 26 - k & 67108863, k += 24, k >= 26 && (k -= 26, E++);
      return this._strip();
    };
    function o(M, c) {
      var h = M.charCodeAt(c);
      if (h >= 48 && h <= 57)
        return h - 48;
      if (h >= 65 && h <= 70)
        return h - 55;
      if (h >= 97 && h <= 102)
        return h - 87;
      i(!1, "Invalid character in " + M);
    }
    function u(M, c, h) {
      var v = o(M, h);
      return h - 1 >= c && (v |= o(M, h - 1) << 4), v;
    }
    s.prototype._parseHex = function(c, h, v) {
      this.length = Math.ceil((c.length - h) / 6), this.words = new Array(this.length);
      for (var S = 0; S < this.length; S++)
        this.words[S] = 0;
      var E = 0, C = 0, k;
      if (v === "be")
        for (S = c.length - 1; S >= h; S -= 2)
          k = u(c, h, S) << E, this.words[C] |= k & 67108863, E >= 18 ? (E -= 18, C += 1, this.words[C] |= k >>> 26) : E += 8;
      else {
        var m = c.length - h;
        for (S = m % 2 === 0 ? h + 1 : h; S < c.length; S += 2)
          k = u(c, h, S) << E, this.words[C] |= k & 67108863, E >= 18 ? (E -= 18, C += 1, this.words[C] |= k >>> 26) : E += 8;
      }
      this._strip();
    };
    function l(M, c, h, v) {
      for (var S = 0, E = 0, C = Math.min(M.length, h), k = c; k < C; k++) {
        var m = M.charCodeAt(k) - 48;
        S *= v, m >= 49 ? E = m - 49 + 10 : m >= 17 ? E = m - 17 + 10 : E = m, i(m >= 0 && E < v, "Invalid character"), S += E;
      }
      return S;
    }
    s.prototype._parseBase = function(c, h, v) {
      this.words = [0], this.length = 1;
      for (var S = 0, E = 1; E <= 67108863; E *= h)
        S++;
      S--, E = E / h | 0;
      for (var C = c.length - v, k = C % S, m = Math.min(C, C - k) + v, d = 0, g = v; g < m; g += S)
        d = l(c, g, g + S, h), this.imuln(E), this.words[0] + d < 67108864 ? this.words[0] += d : this._iaddn(d);
      if (k !== 0) {
        var P = 1;
        for (d = l(c, g, c.length, h), g = 0; g < k; g++)
          P *= h;
        this.imuln(P), this.words[0] + d < 67108864 ? this.words[0] += d : this._iaddn(d);
      }
      this._strip();
    }, s.prototype.copy = function(c) {
      c.words = new Array(this.length);
      for (var h = 0; h < this.length; h++)
        c.words[h] = this.words[h];
      c.length = this.length, c.negative = this.negative, c.red = this.red;
    };
    function p(M, c) {
      M.words = c.words, M.length = c.length, M.negative = c.negative, M.red = c.red;
    }
    if (s.prototype._move = function(c) {
      p(c, this);
    }, s.prototype.clone = function() {
      var c = new s(null);
      return this.copy(c), c;
    }, s.prototype._expand = function(c) {
      for (; this.length < c; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = f;
      } catch {
        s.prototype.inspect = f;
      }
    else
      s.prototype.inspect = f;
    function f() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var b = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], A = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], x = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(c, h) {
      c = c || 10, h = h | 0 || 1;
      var v;
      if (c === 16 || c === "hex") {
        v = "";
        for (var S = 0, E = 0, C = 0; C < this.length; C++) {
          var k = this.words[C], m = ((k << S | E) & 16777215).toString(16);
          E = k >>> 24 - S & 16777215, S += 2, S >= 26 && (S -= 26, C--), E !== 0 || C !== this.length - 1 ? v = b[6 - m.length] + m + v : v = m + v;
        }
        for (E !== 0 && (v = E.toString(16) + v); v.length % h !== 0; )
          v = "0" + v;
        return this.negative !== 0 && (v = "-" + v), v;
      }
      if (c === (c | 0) && c >= 2 && c <= 36) {
        var d = A[c], g = x[c];
        v = "";
        var P = this.clone();
        for (P.negative = 0; !P.isZero(); ) {
          var y = P.modrn(g).toString(c);
          P = P.idivn(g), P.isZero() ? v = y + v : v = b[d - y.length] + y + v;
        }
        for (this.isZero() && (v = "0" + v); v.length % h !== 0; )
          v = "0" + v;
        return this.negative !== 0 && (v = "-" + v), v;
      }
      i(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var c = this.words[0];
      return this.length === 2 ? c += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? c += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && i(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -c : c;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, a && (s.prototype.toBuffer = function(c, h) {
      return this.toArrayLike(a, c, h);
    }), s.prototype.toArray = function(c, h) {
      return this.toArrayLike(Array, c, h);
    };
    var w = function(c, h) {
      return c.allocUnsafe ? c.allocUnsafe(h) : new c(h);
    };
    s.prototype.toArrayLike = function(c, h, v) {
      this._strip();
      var S = this.byteLength(), E = v || Math.max(1, S);
      i(S <= E, "byte array longer than desired length"), i(E > 0, "Requested array length <= 0");
      var C = w(c, E), k = h === "le" ? "LE" : "BE";
      return this["_toArrayLike" + k](C, S), C;
    }, s.prototype._toArrayLikeLE = function(c, h) {
      for (var v = 0, S = 0, E = 0, C = 0; E < this.length; E++) {
        var k = this.words[E] << C | S;
        c[v++] = k & 255, v < c.length && (c[v++] = k >> 8 & 255), v < c.length && (c[v++] = k >> 16 & 255), C === 6 ? (v < c.length && (c[v++] = k >> 24 & 255), S = 0, C = 0) : (S = k >>> 24, C += 2);
      }
      if (v < c.length)
        for (c[v++] = S; v < c.length; )
          c[v++] = 0;
    }, s.prototype._toArrayLikeBE = function(c, h) {
      for (var v = c.length - 1, S = 0, E = 0, C = 0; E < this.length; E++) {
        var k = this.words[E] << C | S;
        c[v--] = k & 255, v >= 0 && (c[v--] = k >> 8 & 255), v >= 0 && (c[v--] = k >> 16 & 255), C === 6 ? (v >= 0 && (c[v--] = k >> 24 & 255), S = 0, C = 0) : (S = k >>> 24, C += 2);
      }
      if (v >= 0)
        for (c[v--] = S; v >= 0; )
          c[v--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(c) {
      return 32 - Math.clz32(c);
    } : s.prototype._countBits = function(c) {
      var h = c, v = 0;
      return h >= 4096 && (v += 13, h >>>= 13), h >= 64 && (v += 7, h >>>= 7), h >= 8 && (v += 4, h >>>= 4), h >= 2 && (v += 2, h >>>= 2), v + h;
    }, s.prototype._zeroBits = function(c) {
      if (c === 0)
        return 26;
      var h = c, v = 0;
      return h & 8191 || (v += 13, h >>>= 13), h & 127 || (v += 7, h >>>= 7), h & 15 || (v += 4, h >>>= 4), h & 3 || (v += 2, h >>>= 2), h & 1 || v++, v;
    }, s.prototype.bitLength = function() {
      var c = this.words[this.length - 1], h = this._countBits(c);
      return (this.length - 1) * 26 + h;
    };
    function T(M) {
      for (var c = new Array(M.bitLength()), h = 0; h < c.length; h++) {
        var v = h / 26 | 0, S = h % 26;
        c[h] = M.words[v] >>> S & 1;
      }
      return c;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var c = 0, h = 0; h < this.length; h++) {
        var v = this._zeroBits(this.words[h]);
        if (c += v, v !== 26)
          break;
      }
      return c;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(c) {
      return this.negative !== 0 ? this.abs().inotn(c).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(c) {
      return this.testn(c - 1) ? this.notn(c).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(c) {
      for (; this.length < c.length; )
        this.words[this.length++] = 0;
      for (var h = 0; h < c.length; h++)
        this.words[h] = this.words[h] | c.words[h];
      return this._strip();
    }, s.prototype.ior = function(c) {
      return i((this.negative | c.negative) === 0), this.iuor(c);
    }, s.prototype.or = function(c) {
      return this.length > c.length ? this.clone().ior(c) : c.clone().ior(this);
    }, s.prototype.uor = function(c) {
      return this.length > c.length ? this.clone().iuor(c) : c.clone().iuor(this);
    }, s.prototype.iuand = function(c) {
      var h;
      this.length > c.length ? h = c : h = this;
      for (var v = 0; v < h.length; v++)
        this.words[v] = this.words[v] & c.words[v];
      return this.length = h.length, this._strip();
    }, s.prototype.iand = function(c) {
      return i((this.negative | c.negative) === 0), this.iuand(c);
    }, s.prototype.and = function(c) {
      return this.length > c.length ? this.clone().iand(c) : c.clone().iand(this);
    }, s.prototype.uand = function(c) {
      return this.length > c.length ? this.clone().iuand(c) : c.clone().iuand(this);
    }, s.prototype.iuxor = function(c) {
      var h, v;
      this.length > c.length ? (h = this, v = c) : (h = c, v = this);
      for (var S = 0; S < v.length; S++)
        this.words[S] = h.words[S] ^ v.words[S];
      if (this !== h)
        for (; S < h.length; S++)
          this.words[S] = h.words[S];
      return this.length = h.length, this._strip();
    }, s.prototype.ixor = function(c) {
      return i((this.negative | c.negative) === 0), this.iuxor(c);
    }, s.prototype.xor = function(c) {
      return this.length > c.length ? this.clone().ixor(c) : c.clone().ixor(this);
    }, s.prototype.uxor = function(c) {
      return this.length > c.length ? this.clone().iuxor(c) : c.clone().iuxor(this);
    }, s.prototype.inotn = function(c) {
      i(typeof c == "number" && c >= 0);
      var h = Math.ceil(c / 26) | 0, v = c % 26;
      this._expand(h), v > 0 && h--;
      for (var S = 0; S < h; S++)
        this.words[S] = ~this.words[S] & 67108863;
      return v > 0 && (this.words[S] = ~this.words[S] & 67108863 >> 26 - v), this._strip();
    }, s.prototype.notn = function(c) {
      return this.clone().inotn(c);
    }, s.prototype.setn = function(c, h) {
      i(typeof c == "number" && c >= 0);
      var v = c / 26 | 0, S = c % 26;
      return this._expand(v + 1), h ? this.words[v] = this.words[v] | 1 << S : this.words[v] = this.words[v] & ~(1 << S), this._strip();
    }, s.prototype.iadd = function(c) {
      var h;
      if (this.negative !== 0 && c.negative === 0)
        return this.negative = 0, h = this.isub(c), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && c.negative !== 0)
        return c.negative = 0, h = this.isub(c), c.negative = 1, h._normSign();
      var v, S;
      this.length > c.length ? (v = this, S = c) : (v = c, S = this);
      for (var E = 0, C = 0; C < S.length; C++)
        h = (v.words[C] | 0) + (S.words[C] | 0) + E, this.words[C] = h & 67108863, E = h >>> 26;
      for (; E !== 0 && C < v.length; C++)
        h = (v.words[C] | 0) + E, this.words[C] = h & 67108863, E = h >>> 26;
      if (this.length = v.length, E !== 0)
        this.words[this.length] = E, this.length++;
      else if (v !== this)
        for (; C < v.length; C++)
          this.words[C] = v.words[C];
      return this;
    }, s.prototype.add = function(c) {
      var h;
      return c.negative !== 0 && this.negative === 0 ? (c.negative = 0, h = this.sub(c), c.negative ^= 1, h) : c.negative === 0 && this.negative !== 0 ? (this.negative = 0, h = c.sub(this), this.negative = 1, h) : this.length > c.length ? this.clone().iadd(c) : c.clone().iadd(this);
    }, s.prototype.isub = function(c) {
      if (c.negative !== 0) {
        c.negative = 0;
        var h = this.iadd(c);
        return c.negative = 1, h._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(c), this.negative = 1, this._normSign();
      var v = this.cmp(c);
      if (v === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var S, E;
      v > 0 ? (S = this, E = c) : (S = c, E = this);
      for (var C = 0, k = 0; k < E.length; k++)
        h = (S.words[k] | 0) - (E.words[k] | 0) + C, C = h >> 26, this.words[k] = h & 67108863;
      for (; C !== 0 && k < S.length; k++)
        h = (S.words[k] | 0) + C, C = h >> 26, this.words[k] = h & 67108863;
      if (C === 0 && k < S.length && S !== this)
        for (; k < S.length; k++)
          this.words[k] = S.words[k];
      return this.length = Math.max(this.length, k), S !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(c) {
      return this.clone().isub(c);
    };
    function _(M, c, h) {
      h.negative = c.negative ^ M.negative;
      var v = M.length + c.length | 0;
      h.length = v, v = v - 1 | 0;
      var S = M.words[0] | 0, E = c.words[0] | 0, C = S * E, k = C & 67108863, m = C / 67108864 | 0;
      h.words[0] = k;
      for (var d = 1; d < v; d++) {
        for (var g = m >>> 26, P = m & 67108863, y = Math.min(d, c.length - 1), R = Math.max(0, d - M.length + 1); R <= y; R++) {
          var F = d - R | 0;
          S = M.words[F] | 0, E = c.words[R] | 0, C = S * E + P, g += C / 67108864 | 0, P = C & 67108863;
        }
        h.words[d] = P | 0, m = g | 0;
      }
      return m !== 0 ? h.words[d] = m | 0 : h.length--, h._strip();
    }
    var I = function(c, h, v) {
      var S = c.words, E = h.words, C = v.words, k = 0, m, d, g, P = S[0] | 0, y = P & 8191, R = P >>> 13, F = S[1] | 0, D = F & 8191, L = F >>> 13, te = S[2] | 0, W = te & 8191, Q = te >>> 13, At = S[3] | 0, ne = At & 8191, de = At >>> 13, Ds = S[4] | 0, je = Ds & 8191, ze = Ds >>> 13, $s = S[5] | 0, Ge = $s & 8191, qe = $s >>> 13, Fs = S[6] | 0, He = Fs & 8191, Ke = Fs >>> 13, Ls = S[7] | 0, We = Ls & 8191, Je = Ls >>> 13, Us = S[8] | 0, Qe = Us & 8191, Ye = Us >>> 13, Vs = S[9] | 0, Xe = Vs & 8191, Ze = Vs >>> 13, js = E[0] | 0, et = js & 8191, tt = js >>> 13, zs = E[1] | 0, nt = zs & 8191, it = zs >>> 13, Gs = E[2] | 0, rt = Gs & 8191, st = Gs >>> 13, qs = E[3] | 0, at = qs & 8191, ot = qs >>> 13, Hs = E[4] | 0, ut = Hs & 8191, lt = Hs >>> 13, Ks = E[5] | 0, ct = Ks & 8191, dt = Ks >>> 13, Ws = E[6] | 0, pt = Ws & 8191, ft = Ws >>> 13, Js = E[7] | 0, yt = Js & 8191, ht = Js >>> 13, Qs = E[8] | 0, mt = Qs & 8191, bt = Qs >>> 13, Ys = E[9] | 0, gt = Ys & 8191, vt = Ys >>> 13;
      v.negative = c.negative ^ h.negative, v.length = 19, m = Math.imul(y, et), d = Math.imul(y, tt), d = d + Math.imul(R, et) | 0, g = Math.imul(R, tt);
      var Yr = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Yr >>> 26) | 0, Yr &= 67108863, m = Math.imul(D, et), d = Math.imul(D, tt), d = d + Math.imul(L, et) | 0, g = Math.imul(L, tt), m = m + Math.imul(y, nt) | 0, d = d + Math.imul(y, it) | 0, d = d + Math.imul(R, nt) | 0, g = g + Math.imul(R, it) | 0;
      var Xr = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Xr >>> 26) | 0, Xr &= 67108863, m = Math.imul(W, et), d = Math.imul(W, tt), d = d + Math.imul(Q, et) | 0, g = Math.imul(Q, tt), m = m + Math.imul(D, nt) | 0, d = d + Math.imul(D, it) | 0, d = d + Math.imul(L, nt) | 0, g = g + Math.imul(L, it) | 0, m = m + Math.imul(y, rt) | 0, d = d + Math.imul(y, st) | 0, d = d + Math.imul(R, rt) | 0, g = g + Math.imul(R, st) | 0;
      var Zr = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Zr >>> 26) | 0, Zr &= 67108863, m = Math.imul(ne, et), d = Math.imul(ne, tt), d = d + Math.imul(de, et) | 0, g = Math.imul(de, tt), m = m + Math.imul(W, nt) | 0, d = d + Math.imul(W, it) | 0, d = d + Math.imul(Q, nt) | 0, g = g + Math.imul(Q, it) | 0, m = m + Math.imul(D, rt) | 0, d = d + Math.imul(D, st) | 0, d = d + Math.imul(L, rt) | 0, g = g + Math.imul(L, st) | 0, m = m + Math.imul(y, at) | 0, d = d + Math.imul(y, ot) | 0, d = d + Math.imul(R, at) | 0, g = g + Math.imul(R, ot) | 0;
      var es = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (es >>> 26) | 0, es &= 67108863, m = Math.imul(je, et), d = Math.imul(je, tt), d = d + Math.imul(ze, et) | 0, g = Math.imul(ze, tt), m = m + Math.imul(ne, nt) | 0, d = d + Math.imul(ne, it) | 0, d = d + Math.imul(de, nt) | 0, g = g + Math.imul(de, it) | 0, m = m + Math.imul(W, rt) | 0, d = d + Math.imul(W, st) | 0, d = d + Math.imul(Q, rt) | 0, g = g + Math.imul(Q, st) | 0, m = m + Math.imul(D, at) | 0, d = d + Math.imul(D, ot) | 0, d = d + Math.imul(L, at) | 0, g = g + Math.imul(L, ot) | 0, m = m + Math.imul(y, ut) | 0, d = d + Math.imul(y, lt) | 0, d = d + Math.imul(R, ut) | 0, g = g + Math.imul(R, lt) | 0;
      var ts = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (ts >>> 26) | 0, ts &= 67108863, m = Math.imul(Ge, et), d = Math.imul(Ge, tt), d = d + Math.imul(qe, et) | 0, g = Math.imul(qe, tt), m = m + Math.imul(je, nt) | 0, d = d + Math.imul(je, it) | 0, d = d + Math.imul(ze, nt) | 0, g = g + Math.imul(ze, it) | 0, m = m + Math.imul(ne, rt) | 0, d = d + Math.imul(ne, st) | 0, d = d + Math.imul(de, rt) | 0, g = g + Math.imul(de, st) | 0, m = m + Math.imul(W, at) | 0, d = d + Math.imul(W, ot) | 0, d = d + Math.imul(Q, at) | 0, g = g + Math.imul(Q, ot) | 0, m = m + Math.imul(D, ut) | 0, d = d + Math.imul(D, lt) | 0, d = d + Math.imul(L, ut) | 0, g = g + Math.imul(L, lt) | 0, m = m + Math.imul(y, ct) | 0, d = d + Math.imul(y, dt) | 0, d = d + Math.imul(R, ct) | 0, g = g + Math.imul(R, dt) | 0;
      var Op = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Op >>> 26) | 0, Op &= 67108863, m = Math.imul(He, et), d = Math.imul(He, tt), d = d + Math.imul(Ke, et) | 0, g = Math.imul(Ke, tt), m = m + Math.imul(Ge, nt) | 0, d = d + Math.imul(Ge, it) | 0, d = d + Math.imul(qe, nt) | 0, g = g + Math.imul(qe, it) | 0, m = m + Math.imul(je, rt) | 0, d = d + Math.imul(je, st) | 0, d = d + Math.imul(ze, rt) | 0, g = g + Math.imul(ze, st) | 0, m = m + Math.imul(ne, at) | 0, d = d + Math.imul(ne, ot) | 0, d = d + Math.imul(de, at) | 0, g = g + Math.imul(de, ot) | 0, m = m + Math.imul(W, ut) | 0, d = d + Math.imul(W, lt) | 0, d = d + Math.imul(Q, ut) | 0, g = g + Math.imul(Q, lt) | 0, m = m + Math.imul(D, ct) | 0, d = d + Math.imul(D, dt) | 0, d = d + Math.imul(L, ct) | 0, g = g + Math.imul(L, dt) | 0, m = m + Math.imul(y, pt) | 0, d = d + Math.imul(y, ft) | 0, d = d + Math.imul(R, pt) | 0, g = g + Math.imul(R, ft) | 0;
      var Bp = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Bp >>> 26) | 0, Bp &= 67108863, m = Math.imul(We, et), d = Math.imul(We, tt), d = d + Math.imul(Je, et) | 0, g = Math.imul(Je, tt), m = m + Math.imul(He, nt) | 0, d = d + Math.imul(He, it) | 0, d = d + Math.imul(Ke, nt) | 0, g = g + Math.imul(Ke, it) | 0, m = m + Math.imul(Ge, rt) | 0, d = d + Math.imul(Ge, st) | 0, d = d + Math.imul(qe, rt) | 0, g = g + Math.imul(qe, st) | 0, m = m + Math.imul(je, at) | 0, d = d + Math.imul(je, ot) | 0, d = d + Math.imul(ze, at) | 0, g = g + Math.imul(ze, ot) | 0, m = m + Math.imul(ne, ut) | 0, d = d + Math.imul(ne, lt) | 0, d = d + Math.imul(de, ut) | 0, g = g + Math.imul(de, lt) | 0, m = m + Math.imul(W, ct) | 0, d = d + Math.imul(W, dt) | 0, d = d + Math.imul(Q, ct) | 0, g = g + Math.imul(Q, dt) | 0, m = m + Math.imul(D, pt) | 0, d = d + Math.imul(D, ft) | 0, d = d + Math.imul(L, pt) | 0, g = g + Math.imul(L, ft) | 0, m = m + Math.imul(y, yt) | 0, d = d + Math.imul(y, ht) | 0, d = d + Math.imul(R, yt) | 0, g = g + Math.imul(R, ht) | 0;
      var Np = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Np >>> 26) | 0, Np &= 67108863, m = Math.imul(Qe, et), d = Math.imul(Qe, tt), d = d + Math.imul(Ye, et) | 0, g = Math.imul(Ye, tt), m = m + Math.imul(We, nt) | 0, d = d + Math.imul(We, it) | 0, d = d + Math.imul(Je, nt) | 0, g = g + Math.imul(Je, it) | 0, m = m + Math.imul(He, rt) | 0, d = d + Math.imul(He, st) | 0, d = d + Math.imul(Ke, rt) | 0, g = g + Math.imul(Ke, st) | 0, m = m + Math.imul(Ge, at) | 0, d = d + Math.imul(Ge, ot) | 0, d = d + Math.imul(qe, at) | 0, g = g + Math.imul(qe, ot) | 0, m = m + Math.imul(je, ut) | 0, d = d + Math.imul(je, lt) | 0, d = d + Math.imul(ze, ut) | 0, g = g + Math.imul(ze, lt) | 0, m = m + Math.imul(ne, ct) | 0, d = d + Math.imul(ne, dt) | 0, d = d + Math.imul(de, ct) | 0, g = g + Math.imul(de, dt) | 0, m = m + Math.imul(W, pt) | 0, d = d + Math.imul(W, ft) | 0, d = d + Math.imul(Q, pt) | 0, g = g + Math.imul(Q, ft) | 0, m = m + Math.imul(D, yt) | 0, d = d + Math.imul(D, ht) | 0, d = d + Math.imul(L, yt) | 0, g = g + Math.imul(L, ht) | 0, m = m + Math.imul(y, mt) | 0, d = d + Math.imul(y, bt) | 0, d = d + Math.imul(R, mt) | 0, g = g + Math.imul(R, bt) | 0;
      var Dp = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Dp >>> 26) | 0, Dp &= 67108863, m = Math.imul(Xe, et), d = Math.imul(Xe, tt), d = d + Math.imul(Ze, et) | 0, g = Math.imul(Ze, tt), m = m + Math.imul(Qe, nt) | 0, d = d + Math.imul(Qe, it) | 0, d = d + Math.imul(Ye, nt) | 0, g = g + Math.imul(Ye, it) | 0, m = m + Math.imul(We, rt) | 0, d = d + Math.imul(We, st) | 0, d = d + Math.imul(Je, rt) | 0, g = g + Math.imul(Je, st) | 0, m = m + Math.imul(He, at) | 0, d = d + Math.imul(He, ot) | 0, d = d + Math.imul(Ke, at) | 0, g = g + Math.imul(Ke, ot) | 0, m = m + Math.imul(Ge, ut) | 0, d = d + Math.imul(Ge, lt) | 0, d = d + Math.imul(qe, ut) | 0, g = g + Math.imul(qe, lt) | 0, m = m + Math.imul(je, ct) | 0, d = d + Math.imul(je, dt) | 0, d = d + Math.imul(ze, ct) | 0, g = g + Math.imul(ze, dt) | 0, m = m + Math.imul(ne, pt) | 0, d = d + Math.imul(ne, ft) | 0, d = d + Math.imul(de, pt) | 0, g = g + Math.imul(de, ft) | 0, m = m + Math.imul(W, yt) | 0, d = d + Math.imul(W, ht) | 0, d = d + Math.imul(Q, yt) | 0, g = g + Math.imul(Q, ht) | 0, m = m + Math.imul(D, mt) | 0, d = d + Math.imul(D, bt) | 0, d = d + Math.imul(L, mt) | 0, g = g + Math.imul(L, bt) | 0, m = m + Math.imul(y, gt) | 0, d = d + Math.imul(y, vt) | 0, d = d + Math.imul(R, gt) | 0, g = g + Math.imul(R, vt) | 0;
      var $p = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + ($p >>> 26) | 0, $p &= 67108863, m = Math.imul(Xe, nt), d = Math.imul(Xe, it), d = d + Math.imul(Ze, nt) | 0, g = Math.imul(Ze, it), m = m + Math.imul(Qe, rt) | 0, d = d + Math.imul(Qe, st) | 0, d = d + Math.imul(Ye, rt) | 0, g = g + Math.imul(Ye, st) | 0, m = m + Math.imul(We, at) | 0, d = d + Math.imul(We, ot) | 0, d = d + Math.imul(Je, at) | 0, g = g + Math.imul(Je, ot) | 0, m = m + Math.imul(He, ut) | 0, d = d + Math.imul(He, lt) | 0, d = d + Math.imul(Ke, ut) | 0, g = g + Math.imul(Ke, lt) | 0, m = m + Math.imul(Ge, ct) | 0, d = d + Math.imul(Ge, dt) | 0, d = d + Math.imul(qe, ct) | 0, g = g + Math.imul(qe, dt) | 0, m = m + Math.imul(je, pt) | 0, d = d + Math.imul(je, ft) | 0, d = d + Math.imul(ze, pt) | 0, g = g + Math.imul(ze, ft) | 0, m = m + Math.imul(ne, yt) | 0, d = d + Math.imul(ne, ht) | 0, d = d + Math.imul(de, yt) | 0, g = g + Math.imul(de, ht) | 0, m = m + Math.imul(W, mt) | 0, d = d + Math.imul(W, bt) | 0, d = d + Math.imul(Q, mt) | 0, g = g + Math.imul(Q, bt) | 0, m = m + Math.imul(D, gt) | 0, d = d + Math.imul(D, vt) | 0, d = d + Math.imul(L, gt) | 0, g = g + Math.imul(L, vt) | 0;
      var Fp = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Fp >>> 26) | 0, Fp &= 67108863, m = Math.imul(Xe, rt), d = Math.imul(Xe, st), d = d + Math.imul(Ze, rt) | 0, g = Math.imul(Ze, st), m = m + Math.imul(Qe, at) | 0, d = d + Math.imul(Qe, ot) | 0, d = d + Math.imul(Ye, at) | 0, g = g + Math.imul(Ye, ot) | 0, m = m + Math.imul(We, ut) | 0, d = d + Math.imul(We, lt) | 0, d = d + Math.imul(Je, ut) | 0, g = g + Math.imul(Je, lt) | 0, m = m + Math.imul(He, ct) | 0, d = d + Math.imul(He, dt) | 0, d = d + Math.imul(Ke, ct) | 0, g = g + Math.imul(Ke, dt) | 0, m = m + Math.imul(Ge, pt) | 0, d = d + Math.imul(Ge, ft) | 0, d = d + Math.imul(qe, pt) | 0, g = g + Math.imul(qe, ft) | 0, m = m + Math.imul(je, yt) | 0, d = d + Math.imul(je, ht) | 0, d = d + Math.imul(ze, yt) | 0, g = g + Math.imul(ze, ht) | 0, m = m + Math.imul(ne, mt) | 0, d = d + Math.imul(ne, bt) | 0, d = d + Math.imul(de, mt) | 0, g = g + Math.imul(de, bt) | 0, m = m + Math.imul(W, gt) | 0, d = d + Math.imul(W, vt) | 0, d = d + Math.imul(Q, gt) | 0, g = g + Math.imul(Q, vt) | 0;
      var Lp = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Lp >>> 26) | 0, Lp &= 67108863, m = Math.imul(Xe, at), d = Math.imul(Xe, ot), d = d + Math.imul(Ze, at) | 0, g = Math.imul(Ze, ot), m = m + Math.imul(Qe, ut) | 0, d = d + Math.imul(Qe, lt) | 0, d = d + Math.imul(Ye, ut) | 0, g = g + Math.imul(Ye, lt) | 0, m = m + Math.imul(We, ct) | 0, d = d + Math.imul(We, dt) | 0, d = d + Math.imul(Je, ct) | 0, g = g + Math.imul(Je, dt) | 0, m = m + Math.imul(He, pt) | 0, d = d + Math.imul(He, ft) | 0, d = d + Math.imul(Ke, pt) | 0, g = g + Math.imul(Ke, ft) | 0, m = m + Math.imul(Ge, yt) | 0, d = d + Math.imul(Ge, ht) | 0, d = d + Math.imul(qe, yt) | 0, g = g + Math.imul(qe, ht) | 0, m = m + Math.imul(je, mt) | 0, d = d + Math.imul(je, bt) | 0, d = d + Math.imul(ze, mt) | 0, g = g + Math.imul(ze, bt) | 0, m = m + Math.imul(ne, gt) | 0, d = d + Math.imul(ne, vt) | 0, d = d + Math.imul(de, gt) | 0, g = g + Math.imul(de, vt) | 0;
      var Up = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Up >>> 26) | 0, Up &= 67108863, m = Math.imul(Xe, ut), d = Math.imul(Xe, lt), d = d + Math.imul(Ze, ut) | 0, g = Math.imul(Ze, lt), m = m + Math.imul(Qe, ct) | 0, d = d + Math.imul(Qe, dt) | 0, d = d + Math.imul(Ye, ct) | 0, g = g + Math.imul(Ye, dt) | 0, m = m + Math.imul(We, pt) | 0, d = d + Math.imul(We, ft) | 0, d = d + Math.imul(Je, pt) | 0, g = g + Math.imul(Je, ft) | 0, m = m + Math.imul(He, yt) | 0, d = d + Math.imul(He, ht) | 0, d = d + Math.imul(Ke, yt) | 0, g = g + Math.imul(Ke, ht) | 0, m = m + Math.imul(Ge, mt) | 0, d = d + Math.imul(Ge, bt) | 0, d = d + Math.imul(qe, mt) | 0, g = g + Math.imul(qe, bt) | 0, m = m + Math.imul(je, gt) | 0, d = d + Math.imul(je, vt) | 0, d = d + Math.imul(ze, gt) | 0, g = g + Math.imul(ze, vt) | 0;
      var Vp = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Vp >>> 26) | 0, Vp &= 67108863, m = Math.imul(Xe, ct), d = Math.imul(Xe, dt), d = d + Math.imul(Ze, ct) | 0, g = Math.imul(Ze, dt), m = m + Math.imul(Qe, pt) | 0, d = d + Math.imul(Qe, ft) | 0, d = d + Math.imul(Ye, pt) | 0, g = g + Math.imul(Ye, ft) | 0, m = m + Math.imul(We, yt) | 0, d = d + Math.imul(We, ht) | 0, d = d + Math.imul(Je, yt) | 0, g = g + Math.imul(Je, ht) | 0, m = m + Math.imul(He, mt) | 0, d = d + Math.imul(He, bt) | 0, d = d + Math.imul(Ke, mt) | 0, g = g + Math.imul(Ke, bt) | 0, m = m + Math.imul(Ge, gt) | 0, d = d + Math.imul(Ge, vt) | 0, d = d + Math.imul(qe, gt) | 0, g = g + Math.imul(qe, vt) | 0;
      var jp = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (jp >>> 26) | 0, jp &= 67108863, m = Math.imul(Xe, pt), d = Math.imul(Xe, ft), d = d + Math.imul(Ze, pt) | 0, g = Math.imul(Ze, ft), m = m + Math.imul(Qe, yt) | 0, d = d + Math.imul(Qe, ht) | 0, d = d + Math.imul(Ye, yt) | 0, g = g + Math.imul(Ye, ht) | 0, m = m + Math.imul(We, mt) | 0, d = d + Math.imul(We, bt) | 0, d = d + Math.imul(Je, mt) | 0, g = g + Math.imul(Je, bt) | 0, m = m + Math.imul(He, gt) | 0, d = d + Math.imul(He, vt) | 0, d = d + Math.imul(Ke, gt) | 0, g = g + Math.imul(Ke, vt) | 0;
      var zp = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (zp >>> 26) | 0, zp &= 67108863, m = Math.imul(Xe, yt), d = Math.imul(Xe, ht), d = d + Math.imul(Ze, yt) | 0, g = Math.imul(Ze, ht), m = m + Math.imul(Qe, mt) | 0, d = d + Math.imul(Qe, bt) | 0, d = d + Math.imul(Ye, mt) | 0, g = g + Math.imul(Ye, bt) | 0, m = m + Math.imul(We, gt) | 0, d = d + Math.imul(We, vt) | 0, d = d + Math.imul(Je, gt) | 0, g = g + Math.imul(Je, vt) | 0;
      var Gp = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (Gp >>> 26) | 0, Gp &= 67108863, m = Math.imul(Xe, mt), d = Math.imul(Xe, bt), d = d + Math.imul(Ze, mt) | 0, g = Math.imul(Ze, bt), m = m + Math.imul(Qe, gt) | 0, d = d + Math.imul(Qe, vt) | 0, d = d + Math.imul(Ye, gt) | 0, g = g + Math.imul(Ye, vt) | 0;
      var qp = (k + m | 0) + ((d & 8191) << 13) | 0;
      k = (g + (d >>> 13) | 0) + (qp >>> 26) | 0, qp &= 67108863, m = Math.imul(Xe, gt), d = Math.imul(Xe, vt), d = d + Math.imul(Ze, gt) | 0, g = Math.imul(Ze, vt);
      var Hp = (k + m | 0) + ((d & 8191) << 13) | 0;
      return k = (g + (d >>> 13) | 0) + (Hp >>> 26) | 0, Hp &= 67108863, C[0] = Yr, C[1] = Xr, C[2] = Zr, C[3] = es, C[4] = ts, C[5] = Op, C[6] = Bp, C[7] = Np, C[8] = Dp, C[9] = $p, C[10] = Fp, C[11] = Lp, C[12] = Up, C[13] = Vp, C[14] = jp, C[15] = zp, C[16] = Gp, C[17] = qp, C[18] = Hp, k !== 0 && (C[19] = k, v.length++), v;
    };
    Math.imul || (I = _);
    function $(M, c, h) {
      h.negative = c.negative ^ M.negative, h.length = M.length + c.length;
      for (var v = 0, S = 0, E = 0; E < h.length - 1; E++) {
        var C = S;
        S = 0;
        for (var k = v & 67108863, m = Math.min(E, c.length - 1), d = Math.max(0, E - M.length + 1); d <= m; d++) {
          var g = E - d, P = M.words[g] | 0, y = c.words[d] | 0, R = P * y, F = R & 67108863;
          C = C + (R / 67108864 | 0) | 0, F = F + k | 0, k = F & 67108863, C = C + (F >>> 26) | 0, S += C >>> 26, C &= 67108863;
        }
        h.words[E] = k, v = C, C = S;
      }
      return v !== 0 ? h.words[E] = v : h.length--, h._strip();
    }
    function N(M, c, h) {
      return $(M, c, h);
    }
    s.prototype.mulTo = function(c, h) {
      var v, S = this.length + c.length;
      return this.length === 10 && c.length === 10 ? v = I(this, c, h) : S < 63 ? v = _(this, c, h) : S < 1024 ? v = $(this, c, h) : v = N(this, c, h), v;
    }, s.prototype.mul = function(c) {
      var h = new s(null);
      return h.words = new Array(this.length + c.length), this.mulTo(c, h);
    }, s.prototype.mulf = function(c) {
      var h = new s(null);
      return h.words = new Array(this.length + c.length), N(this, c, h);
    }, s.prototype.imul = function(c) {
      return this.clone().mulTo(c, this);
    }, s.prototype.imuln = function(c) {
      var h = c < 0;
      h && (c = -c), i(typeof c == "number"), i(c < 67108864);
      for (var v = 0, S = 0; S < this.length; S++) {
        var E = (this.words[S] | 0) * c, C = (E & 67108863) + (v & 67108863);
        v >>= 26, v += E / 67108864 | 0, v += C >>> 26, this.words[S] = C & 67108863;
      }
      return v !== 0 && (this.words[S] = v, this.length++), h ? this.ineg() : this;
    }, s.prototype.muln = function(c) {
      return this.clone().imuln(c);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(c) {
      var h = T(c);
      if (h.length === 0)
        return new s(1);
      for (var v = this, S = 0; S < h.length && h[S] === 0; S++, v = v.sqr())
        ;
      if (++S < h.length)
        for (var E = v.sqr(); S < h.length; S++, E = E.sqr())
          h[S] !== 0 && (v = v.mul(E));
      return v;
    }, s.prototype.iushln = function(c) {
      i(typeof c == "number" && c >= 0);
      var h = c % 26, v = (c - h) / 26, S = 67108863 >>> 26 - h << 26 - h, E;
      if (h !== 0) {
        var C = 0;
        for (E = 0; E < this.length; E++) {
          var k = this.words[E] & S, m = (this.words[E] | 0) - k << h;
          this.words[E] = m | C, C = k >>> 26 - h;
        }
        C && (this.words[E] = C, this.length++);
      }
      if (v !== 0) {
        for (E = this.length - 1; E >= 0; E--)
          this.words[E + v] = this.words[E];
        for (E = 0; E < v; E++)
          this.words[E] = 0;
        this.length += v;
      }
      return this._strip();
    }, s.prototype.ishln = function(c) {
      return i(this.negative === 0), this.iushln(c);
    }, s.prototype.iushrn = function(c, h, v) {
      i(typeof c == "number" && c >= 0);
      var S;
      h ? S = (h - h % 26) / 26 : S = 0;
      var E = c % 26, C = Math.min((c - E) / 26, this.length), k = 67108863 ^ 67108863 >>> E << E, m = v;
      if (S -= C, S = Math.max(0, S), m) {
        for (var d = 0; d < C; d++)
          m.words[d] = this.words[d];
        m.length = C;
      }
      if (C !== 0)
        if (this.length > C)
          for (this.length -= C, d = 0; d < this.length; d++)
            this.words[d] = this.words[d + C];
        else
          this.words[0] = 0, this.length = 1;
      var g = 0;
      for (d = this.length - 1; d >= 0 && (g !== 0 || d >= S); d--) {
        var P = this.words[d] | 0;
        this.words[d] = g << 26 - E | P >>> E, g = P & k;
      }
      return m && g !== 0 && (m.words[m.length++] = g), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(c, h, v) {
      return i(this.negative === 0), this.iushrn(c, h, v);
    }, s.prototype.shln = function(c) {
      return this.clone().ishln(c);
    }, s.prototype.ushln = function(c) {
      return this.clone().iushln(c);
    }, s.prototype.shrn = function(c) {
      return this.clone().ishrn(c);
    }, s.prototype.ushrn = function(c) {
      return this.clone().iushrn(c);
    }, s.prototype.testn = function(c) {
      i(typeof c == "number" && c >= 0);
      var h = c % 26, v = (c - h) / 26, S = 1 << h;
      if (this.length <= v)
        return !1;
      var E = this.words[v];
      return !!(E & S);
    }, s.prototype.imaskn = function(c) {
      i(typeof c == "number" && c >= 0);
      var h = c % 26, v = (c - h) / 26;
      if (i(this.negative === 0, "imaskn works only with positive numbers"), this.length <= v)
        return this;
      if (h !== 0 && v++, this.length = Math.min(v, this.length), h !== 0) {
        var S = 67108863 ^ 67108863 >>> h << h;
        this.words[this.length - 1] &= S;
      }
      return this._strip();
    }, s.prototype.maskn = function(c) {
      return this.clone().imaskn(c);
    }, s.prototype.iaddn = function(c) {
      return i(typeof c == "number"), i(c < 67108864), c < 0 ? this.isubn(-c) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= c ? (this.words[0] = c - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(c), this.negative = 1, this) : this._iaddn(c);
    }, s.prototype._iaddn = function(c) {
      this.words[0] += c;
      for (var h = 0; h < this.length && this.words[h] >= 67108864; h++)
        this.words[h] -= 67108864, h === this.length - 1 ? this.words[h + 1] = 1 : this.words[h + 1]++;
      return this.length = Math.max(this.length, h + 1), this;
    }, s.prototype.isubn = function(c) {
      if (i(typeof c == "number"), i(c < 67108864), c < 0)
        return this.iaddn(-c);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(c), this.negative = 1, this;
      if (this.words[0] -= c, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var h = 0; h < this.length && this.words[h] < 0; h++)
          this.words[h] += 67108864, this.words[h + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(c) {
      return this.clone().iaddn(c);
    }, s.prototype.subn = function(c) {
      return this.clone().isubn(c);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(c, h, v) {
      var S = c.length + v, E;
      this._expand(S);
      var C, k = 0;
      for (E = 0; E < c.length; E++) {
        C = (this.words[E + v] | 0) + k;
        var m = (c.words[E] | 0) * h;
        C -= m & 67108863, k = (C >> 26) - (m / 67108864 | 0), this.words[E + v] = C & 67108863;
      }
      for (; E < this.length - v; E++)
        C = (this.words[E + v] | 0) + k, k = C >> 26, this.words[E + v] = C & 67108863;
      if (k === 0)
        return this._strip();
      for (i(k === -1), k = 0, E = 0; E < this.length; E++)
        C = -(this.words[E] | 0) + k, k = C >> 26, this.words[E] = C & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(c, h) {
      var v = this.length - c.length, S = this.clone(), E = c, C = E.words[E.length - 1] | 0, k = this._countBits(C);
      v = 26 - k, v !== 0 && (E = E.ushln(v), S.iushln(v), C = E.words[E.length - 1] | 0);
      var m = S.length - E.length, d;
      if (h !== "mod") {
        d = new s(null), d.length = m + 1, d.words = new Array(d.length);
        for (var g = 0; g < d.length; g++)
          d.words[g] = 0;
      }
      var P = S.clone()._ishlnsubmul(E, 1, m);
      P.negative === 0 && (S = P, d && (d.words[m] = 1));
      for (var y = m - 1; y >= 0; y--) {
        var R = (S.words[E.length + y] | 0) * 67108864 + (S.words[E.length + y - 1] | 0);
        for (R = Math.min(R / C | 0, 67108863), S._ishlnsubmul(E, R, y); S.negative !== 0; )
          R--, S.negative = 0, S._ishlnsubmul(E, 1, y), S.isZero() || (S.negative ^= 1);
        d && (d.words[y] = R);
      }
      return d && d._strip(), S._strip(), h !== "div" && v !== 0 && S.iushrn(v), {
        div: d || null,
        mod: S
      };
    }, s.prototype.divmod = function(c, h, v) {
      if (i(!c.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var S, E, C;
      return this.negative !== 0 && c.negative === 0 ? (C = this.neg().divmod(c, h), h !== "mod" && (S = C.div.neg()), h !== "div" && (E = C.mod.neg(), v && E.negative !== 0 && E.iadd(c)), {
        div: S,
        mod: E
      }) : this.negative === 0 && c.negative !== 0 ? (C = this.divmod(c.neg(), h), h !== "mod" && (S = C.div.neg()), {
        div: S,
        mod: C.mod
      }) : this.negative & c.negative ? (C = this.neg().divmod(c.neg(), h), h !== "div" && (E = C.mod.neg(), v && E.negative !== 0 && E.isub(c)), {
        div: C.div,
        mod: E
      }) : c.length > this.length || this.cmp(c) < 0 ? {
        div: new s(0),
        mod: this
      } : c.length === 1 ? h === "div" ? {
        div: this.divn(c.words[0]),
        mod: null
      } : h === "mod" ? {
        div: null,
        mod: new s(this.modrn(c.words[0]))
      } : {
        div: this.divn(c.words[0]),
        mod: new s(this.modrn(c.words[0]))
      } : this._wordDiv(c, h);
    }, s.prototype.div = function(c) {
      return this.divmod(c, "div", !1).div;
    }, s.prototype.mod = function(c) {
      return this.divmod(c, "mod", !1).mod;
    }, s.prototype.umod = function(c) {
      return this.divmod(c, "mod", !0).mod;
    }, s.prototype.divRound = function(c) {
      var h = this.divmod(c);
      if (h.mod.isZero())
        return h.div;
      var v = h.div.negative !== 0 ? h.mod.isub(c) : h.mod, S = c.ushrn(1), E = c.andln(1), C = v.cmp(S);
      return C < 0 || E === 1 && C === 0 ? h.div : h.div.negative !== 0 ? h.div.isubn(1) : h.div.iaddn(1);
    }, s.prototype.modrn = function(c) {
      var h = c < 0;
      h && (c = -c), i(c <= 67108863);
      for (var v = (1 << 26) % c, S = 0, E = this.length - 1; E >= 0; E--)
        S = (v * S + (this.words[E] | 0)) % c;
      return h ? -S : S;
    }, s.prototype.modn = function(c) {
      return this.modrn(c);
    }, s.prototype.idivn = function(c) {
      var h = c < 0;
      h && (c = -c), i(c <= 67108863);
      for (var v = 0, S = this.length - 1; S >= 0; S--) {
        var E = (this.words[S] | 0) + v * 67108864;
        this.words[S] = E / c | 0, v = E % c;
      }
      return this._strip(), h ? this.ineg() : this;
    }, s.prototype.divn = function(c) {
      return this.clone().idivn(c);
    }, s.prototype.egcd = function(c) {
      i(c.negative === 0), i(!c.isZero());
      var h = this, v = c.clone();
      h.negative !== 0 ? h = h.umod(c) : h = h.clone();
      for (var S = new s(1), E = new s(0), C = new s(0), k = new s(1), m = 0; h.isEven() && v.isEven(); )
        h.iushrn(1), v.iushrn(1), ++m;
      for (var d = v.clone(), g = h.clone(); !h.isZero(); ) {
        for (var P = 0, y = 1; !(h.words[0] & y) && P < 26; ++P, y <<= 1)
          ;
        if (P > 0)
          for (h.iushrn(P); P-- > 0; )
            (S.isOdd() || E.isOdd()) && (S.iadd(d), E.isub(g)), S.iushrn(1), E.iushrn(1);
        for (var R = 0, F = 1; !(v.words[0] & F) && R < 26; ++R, F <<= 1)
          ;
        if (R > 0)
          for (v.iushrn(R); R-- > 0; )
            (C.isOdd() || k.isOdd()) && (C.iadd(d), k.isub(g)), C.iushrn(1), k.iushrn(1);
        h.cmp(v) >= 0 ? (h.isub(v), S.isub(C), E.isub(k)) : (v.isub(h), C.isub(S), k.isub(E));
      }
      return {
        a: C,
        b: k,
        gcd: v.iushln(m)
      };
    }, s.prototype._invmp = function(c) {
      i(c.negative === 0), i(!c.isZero());
      var h = this, v = c.clone();
      h.negative !== 0 ? h = h.umod(c) : h = h.clone();
      for (var S = new s(1), E = new s(0), C = v.clone(); h.cmpn(1) > 0 && v.cmpn(1) > 0; ) {
        for (var k = 0, m = 1; !(h.words[0] & m) && k < 26; ++k, m <<= 1)
          ;
        if (k > 0)
          for (h.iushrn(k); k-- > 0; )
            S.isOdd() && S.iadd(C), S.iushrn(1);
        for (var d = 0, g = 1; !(v.words[0] & g) && d < 26; ++d, g <<= 1)
          ;
        if (d > 0)
          for (v.iushrn(d); d-- > 0; )
            E.isOdd() && E.iadd(C), E.iushrn(1);
        h.cmp(v) >= 0 ? (h.isub(v), S.isub(E)) : (v.isub(h), E.isub(S));
      }
      var P;
      return h.cmpn(1) === 0 ? P = S : P = E, P.cmpn(0) < 0 && P.iadd(c), P;
    }, s.prototype.gcd = function(c) {
      if (this.isZero())
        return c.abs();
      if (c.isZero())
        return this.abs();
      var h = this.clone(), v = c.clone();
      h.negative = 0, v.negative = 0;
      for (var S = 0; h.isEven() && v.isEven(); S++)
        h.iushrn(1), v.iushrn(1);
      do {
        for (; h.isEven(); )
          h.iushrn(1);
        for (; v.isEven(); )
          v.iushrn(1);
        var E = h.cmp(v);
        if (E < 0) {
          var C = h;
          h = v, v = C;
        } else if (E === 0 || v.cmpn(1) === 0)
          break;
        h.isub(v);
      } while (!0);
      return v.iushln(S);
    }, s.prototype.invm = function(c) {
      return this.egcd(c).a.umod(c);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(c) {
      return this.words[0] & c;
    }, s.prototype.bincn = function(c) {
      i(typeof c == "number");
      var h = c % 26, v = (c - h) / 26, S = 1 << h;
      if (this.length <= v)
        return this._expand(v + 1), this.words[v] |= S, this;
      for (var E = S, C = v; E !== 0 && C < this.length; C++) {
        var k = this.words[C] | 0;
        k += E, E = k >>> 26, k &= 67108863, this.words[C] = k;
      }
      return E !== 0 && (this.words[C] = E, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(c) {
      var h = c < 0;
      if (this.negative !== 0 && !h)
        return -1;
      if (this.negative === 0 && h)
        return 1;
      this._strip();
      var v;
      if (this.length > 1)
        v = 1;
      else {
        h && (c = -c), i(c <= 67108863, "Number is too big");
        var S = this.words[0] | 0;
        v = S === c ? 0 : S < c ? -1 : 1;
      }
      return this.negative !== 0 ? -v | 0 : v;
    }, s.prototype.cmp = function(c) {
      if (this.negative !== 0 && c.negative === 0)
        return -1;
      if (this.negative === 0 && c.negative !== 0)
        return 1;
      var h = this.ucmp(c);
      return this.negative !== 0 ? -h | 0 : h;
    }, s.prototype.ucmp = function(c) {
      if (this.length > c.length)
        return 1;
      if (this.length < c.length)
        return -1;
      for (var h = 0, v = this.length - 1; v >= 0; v--) {
        var S = this.words[v] | 0, E = c.words[v] | 0;
        if (S !== E) {
          S < E ? h = -1 : S > E && (h = 1);
          break;
        }
      }
      return h;
    }, s.prototype.gtn = function(c) {
      return this.cmpn(c) === 1;
    }, s.prototype.gt = function(c) {
      return this.cmp(c) === 1;
    }, s.prototype.gten = function(c) {
      return this.cmpn(c) >= 0;
    }, s.prototype.gte = function(c) {
      return this.cmp(c) >= 0;
    }, s.prototype.ltn = function(c) {
      return this.cmpn(c) === -1;
    }, s.prototype.lt = function(c) {
      return this.cmp(c) === -1;
    }, s.prototype.lten = function(c) {
      return this.cmpn(c) <= 0;
    }, s.prototype.lte = function(c) {
      return this.cmp(c) <= 0;
    }, s.prototype.eqn = function(c) {
      return this.cmpn(c) === 0;
    }, s.prototype.eq = function(c) {
      return this.cmp(c) === 0;
    }, s.red = function(c) {
      return new J(c);
    }, s.prototype.toRed = function(c) {
      return i(!this.red, "Already a number in reduction context"), i(this.negative === 0, "red works only with positives"), c.convertTo(this)._forceRed(c);
    }, s.prototype.fromRed = function() {
      return i(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(c) {
      return this.red = c, this;
    }, s.prototype.forceRed = function(c) {
      return i(!this.red, "Already a number in reduction context"), this._forceRed(c);
    }, s.prototype.redAdd = function(c) {
      return i(this.red, "redAdd works only with red numbers"), this.red.add(this, c);
    }, s.prototype.redIAdd = function(c) {
      return i(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, c);
    }, s.prototype.redSub = function(c) {
      return i(this.red, "redSub works only with red numbers"), this.red.sub(this, c);
    }, s.prototype.redISub = function(c) {
      return i(this.red, "redISub works only with red numbers"), this.red.isub(this, c);
    }, s.prototype.redShl = function(c) {
      return i(this.red, "redShl works only with red numbers"), this.red.shl(this, c);
    }, s.prototype.redMul = function(c) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.mul(this, c);
    }, s.prototype.redIMul = function(c) {
      return i(this.red, "redMul works only with red numbers"), this.red._verify2(this, c), this.red.imul(this, c);
    }, s.prototype.redSqr = function() {
      return i(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return i(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return i(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return i(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return i(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(c) {
      return i(this.red && !c.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, c);
    };
    var B = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function V(M, c) {
      this.name = M, this.p = new s(c, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    V.prototype._tmp = function() {
      var c = new s(null);
      return c.words = new Array(Math.ceil(this.n / 13)), c;
    }, V.prototype.ireduce = function(c) {
      var h = c, v;
      do
        this.split(h, this.tmp), h = this.imulK(h), h = h.iadd(this.tmp), v = h.bitLength();
      while (v > this.n);
      var S = v < this.n ? -1 : h.ucmp(this.p);
      return S === 0 ? (h.words[0] = 0, h.length = 1) : S > 0 ? h.isub(this.p) : h.strip !== void 0 ? h.strip() : h._strip(), h;
    }, V.prototype.split = function(c, h) {
      c.iushrn(this.n, 0, h);
    }, V.prototype.imulK = function(c) {
      return c.imul(this.k);
    };
    function K() {
      V.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    r(K, V), K.prototype.split = function(c, h) {
      for (var v = 4194303, S = Math.min(c.length, 9), E = 0; E < S; E++)
        h.words[E] = c.words[E];
      if (h.length = S, c.length <= 9) {
        c.words[0] = 0, c.length = 1;
        return;
      }
      var C = c.words[9];
      for (h.words[h.length++] = C & v, E = 10; E < c.length; E++) {
        var k = c.words[E] | 0;
        c.words[E - 10] = (k & v) << 4 | C >>> 22, C = k;
      }
      C >>>= 22, c.words[E - 10] = C, C === 0 && c.length > 10 ? c.length -= 10 : c.length -= 9;
    }, K.prototype.imulK = function(c) {
      c.words[c.length] = 0, c.words[c.length + 1] = 0, c.length += 2;
      for (var h = 0, v = 0; v < c.length; v++) {
        var S = c.words[v] | 0;
        h += S * 977, c.words[v] = h & 67108863, h = S * 64 + (h / 67108864 | 0);
      }
      return c.words[c.length - 1] === 0 && (c.length--, c.words[c.length - 1] === 0 && c.length--), c;
    };
    function G() {
      V.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    r(G, V);
    function Y() {
      V.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    r(Y, V);
    function oe() {
      V.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    r(oe, V), oe.prototype.imulK = function(c) {
      for (var h = 0, v = 0; v < c.length; v++) {
        var S = (c.words[v] | 0) * 19 + h, E = S & 67108863;
        S >>>= 26, c.words[v] = E, h = S;
      }
      return h !== 0 && (c.words[c.length++] = h), c;
    }, s._prime = function(c) {
      if (B[c])
        return B[c];
      var h;
      if (c === "k256")
        h = new K();
      else if (c === "p224")
        h = new G();
      else if (c === "p192")
        h = new Y();
      else if (c === "p25519")
        h = new oe();
      else
        throw new Error("Unknown prime " + c);
      return B[c] = h, h;
    };
    function J(M) {
      if (typeof M == "string") {
        var c = s._prime(M);
        this.m = c.p, this.prime = c;
      } else
        i(M.gtn(1), "modulus must be greater than 1"), this.m = M, this.prime = null;
    }
    J.prototype._verify1 = function(c) {
      i(c.negative === 0, "red works only with positives"), i(c.red, "red works only with red numbers");
    }, J.prototype._verify2 = function(c, h) {
      i((c.negative | h.negative) === 0, "red works only with positives"), i(
        c.red && c.red === h.red,
        "red works only with red numbers"
      );
    }, J.prototype.imod = function(c) {
      return this.prime ? this.prime.ireduce(c)._forceRed(this) : (p(c, c.umod(this.m)._forceRed(this)), c);
    }, J.prototype.neg = function(c) {
      return c.isZero() ? c.clone() : this.m.sub(c)._forceRed(this);
    }, J.prototype.add = function(c, h) {
      this._verify2(c, h);
      var v = c.add(h);
      return v.cmp(this.m) >= 0 && v.isub(this.m), v._forceRed(this);
    }, J.prototype.iadd = function(c, h) {
      this._verify2(c, h);
      var v = c.iadd(h);
      return v.cmp(this.m) >= 0 && v.isub(this.m), v;
    }, J.prototype.sub = function(c, h) {
      this._verify2(c, h);
      var v = c.sub(h);
      return v.cmpn(0) < 0 && v.iadd(this.m), v._forceRed(this);
    }, J.prototype.isub = function(c, h) {
      this._verify2(c, h);
      var v = c.isub(h);
      return v.cmpn(0) < 0 && v.iadd(this.m), v;
    }, J.prototype.shl = function(c, h) {
      return this._verify1(c), this.imod(c.ushln(h));
    }, J.prototype.imul = function(c, h) {
      return this._verify2(c, h), this.imod(c.imul(h));
    }, J.prototype.mul = function(c, h) {
      return this._verify2(c, h), this.imod(c.mul(h));
    }, J.prototype.isqr = function(c) {
      return this.imul(c, c.clone());
    }, J.prototype.sqr = function(c) {
      return this.mul(c, c);
    }, J.prototype.sqrt = function(c) {
      if (c.isZero())
        return c.clone();
      var h = this.m.andln(3);
      if (i(h % 2 === 1), h === 3) {
        var v = this.m.add(new s(1)).iushrn(2);
        return this.pow(c, v);
      }
      for (var S = this.m.subn(1), E = 0; !S.isZero() && S.andln(1) === 0; )
        E++, S.iushrn(1);
      i(!S.isZero());
      var C = new s(1).toRed(this), k = C.redNeg(), m = this.m.subn(1).iushrn(1), d = this.m.bitLength();
      for (d = new s(2 * d * d).toRed(this); this.pow(d, m).cmp(k) !== 0; )
        d.redIAdd(k);
      for (var g = this.pow(d, S), P = this.pow(c, S.addn(1).iushrn(1)), y = this.pow(c, S), R = E; y.cmp(C) !== 0; ) {
        for (var F = y, D = 0; F.cmp(C) !== 0; D++)
          F = F.redSqr();
        i(D < R);
        var L = this.pow(g, new s(1).iushln(R - D - 1));
        P = P.redMul(L), g = L.redSqr(), y = y.redMul(g), R = D;
      }
      return P;
    }, J.prototype.invm = function(c) {
      var h = c._invmp(this.m);
      return h.negative !== 0 ? (h.negative = 0, this.imod(h).redNeg()) : this.imod(h);
    }, J.prototype.pow = function(c, h) {
      if (h.isZero())
        return new s(1).toRed(this);
      if (h.cmpn(1) === 0)
        return c.clone();
      var v = 4, S = new Array(1 << v);
      S[0] = new s(1).toRed(this), S[1] = c;
      for (var E = 2; E < S.length; E++)
        S[E] = this.mul(S[E - 1], c);
      var C = S[0], k = 0, m = 0, d = h.bitLength() % 26;
      for (d === 0 && (d = 26), E = h.length - 1; E >= 0; E--) {
        for (var g = h.words[E], P = d - 1; P >= 0; P--) {
          var y = g >> P & 1;
          if (C !== S[0] && (C = this.sqr(C)), y === 0 && k === 0) {
            m = 0;
            continue;
          }
          k <<= 1, k |= y, m++, !(m !== v && (E !== 0 || P !== 0)) && (C = this.mul(C, S[k]), m = 0, k = 0);
        }
        d = 26;
      }
      return C;
    }, J.prototype.convertTo = function(c) {
      var h = c.umod(this.m);
      return h === c ? h.clone() : h;
    }, J.prototype.convertFrom = function(c) {
      var h = c.clone();
      return h.red = null, h;
    }, s.mont = function(c) {
      return new ue(c);
    };
    function ue(M) {
      J.call(this, M), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    r(ue, J), ue.prototype.convertTo = function(c) {
      return this.imod(c.ushln(this.shift));
    }, ue.prototype.convertFrom = function(c) {
      var h = this.imod(c.mul(this.rinv));
      return h.red = null, h;
    }, ue.prototype.imul = function(c, h) {
      if (c.isZero() || h.isZero())
        return c.words[0] = 0, c.length = 1, c;
      var v = c.imul(h), S = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = v.isub(S).iushrn(this.shift), C = E;
      return E.cmp(this.m) >= 0 ? C = E.isub(this.m) : E.cmpn(0) < 0 && (C = E.iadd(this.m)), C._forceRed(this);
    }, ue.prototype.mul = function(c, h) {
      if (c.isZero() || h.isZero())
        return new s(0)._forceRed(this);
      var v = c.mul(h), S = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), E = v.isub(S).iushrn(this.shift), C = E;
      return E.cmp(this.m) >= 0 ? C = E.isub(this.m) : E.cmpn(0) < 0 && (C = E.iadd(this.m)), C._forceRed(this);
    }, ue.prototype.invm = function(c) {
      var h = this.imod(c._invmp(this.m).mul(this.r2));
      return h._forceRed(this);
    };
  })(n, ls);
})(iS);
const pe = xy, oS = "logger/5.7.0";
let u2 = !1, l2 = !1;
const Rc = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let c2 = Rc.default, bf = null;
function uS() {
  try {
    const n = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((e) => {
      try {
        if ("test".normalize(e) !== "test")
          throw new Error("bad normalize");
      } catch {
        n.push(e);
      }
    }), n.length)
      throw new Error("missing " + n.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (n) {
    return n.message;
  }
  return null;
}
const d2 = uS();
var od;
(function(n) {
  n.DEBUG = "DEBUG", n.INFO = "INFO", n.WARNING = "WARNING", n.ERROR = "ERROR", n.OFF = "OFF";
})(od || (od = {}));
var ci;
(function(n) {
  n.UNKNOWN_ERROR = "UNKNOWN_ERROR", n.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", n.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", n.NETWORK_ERROR = "NETWORK_ERROR", n.SERVER_ERROR = "SERVER_ERROR", n.TIMEOUT = "TIMEOUT", n.BUFFER_OVERRUN = "BUFFER_OVERRUN", n.NUMERIC_FAULT = "NUMERIC_FAULT", n.MISSING_NEW = "MISSING_NEW", n.INVALID_ARGUMENT = "INVALID_ARGUMENT", n.MISSING_ARGUMENT = "MISSING_ARGUMENT", n.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", n.CALL_EXCEPTION = "CALL_EXCEPTION", n.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", n.NONCE_EXPIRED = "NONCE_EXPIRED", n.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", n.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", n.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", n.ACTION_REJECTED = "ACTION_REJECTED";
})(ci || (ci = {}));
const p2 = "0123456789abcdef";
let O = class zt {
  constructor(e) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: e,
      writable: !1
    });
  }
  _log(e, t) {
    const i = e.toLowerCase();
    Rc[i] == null && this.throwArgumentError("invalid log level name", "logLevel", e), !(c2 > Rc[i]) && console.log.apply(console, t);
  }
  debug(...e) {
    this._log(zt.levels.DEBUG, e);
  }
  info(...e) {
    this._log(zt.levels.INFO, e);
  }
  warn(...e) {
    this._log(zt.levels.WARNING, e);
  }
  makeError(e, t, i) {
    if (l2)
      return this.makeError("censored error", t, {});
    t || (t = zt.errors.UNKNOWN_ERROR), i || (i = {});
    const r = [];
    Object.keys(i).forEach((u) => {
      const l = i[u];
      try {
        if (l instanceof Uint8Array) {
          let p = "";
          for (let f = 0; f < l.length; f++)
            p += p2[l[f] >> 4], p += p2[l[f] & 15];
          r.push(u + "=Uint8Array(0x" + p + ")");
        } else
          r.push(u + "=" + JSON.stringify(l));
      } catch {
        r.push(u + "=" + JSON.stringify(i[u].toString()));
      }
    }), r.push(`code=${t}`), r.push(`version=${this.version}`);
    const s = e;
    let a = "";
    switch (t) {
      case ci.NUMERIC_FAULT: {
        a = "NUMERIC_FAULT";
        const u = e;
        switch (u) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            a += "-" + u;
            break;
          case "negative-power":
          case "negative-width":
            a += "-unsupported";
            break;
          case "unbound-bitwise-result":
            a += "-unbound-result";
            break;
        }
        break;
      }
      case ci.CALL_EXCEPTION:
      case ci.INSUFFICIENT_FUNDS:
      case ci.MISSING_NEW:
      case ci.NONCE_EXPIRED:
      case ci.REPLACEMENT_UNDERPRICED:
      case ci.TRANSACTION_REPLACED:
      case ci.UNPREDICTABLE_GAS_LIMIT:
        a = t;
        break;
    }
    a && (e += " [ See: https://links.ethers.org/v5-errors-" + a + " ]"), r.length && (e += " (" + r.join(", ") + ")");
    const o = new Error(e);
    return o.reason = s, o.code = t, Object.keys(i).forEach(function(u) {
      o[u] = i[u];
    }), o;
  }
  throwError(e, t, i) {
    throw this.makeError(e, t, i);
  }
  throwArgumentError(e, t, i) {
    return this.throwError(e, zt.errors.INVALID_ARGUMENT, {
      argument: t,
      value: i
    });
  }
  assert(e, t, i, r) {
    e || this.throwError(t, i, r);
  }
  assertArgument(e, t, i, r) {
    e || this.throwArgumentError(t, i, r);
  }
  checkNormalize(e) {
    d2 && this.throwError("platform missing String.prototype.normalize", zt.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: d2
    });
  }
  checkSafeUint53(e, t) {
    typeof e == "number" && (t == null && (t = "value not safe"), (e < 0 || e >= 9007199254740991) && this.throwError(t, zt.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: e
    }), e % 1 && this.throwError(t, zt.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: e
    }));
  }
  checkArgumentCount(e, t, i) {
    i ? i = ": " + i : i = "", e < t && this.throwError("missing argument" + i, zt.errors.MISSING_ARGUMENT, {
      count: e,
      expectedCount: t
    }), e > t && this.throwError("too many arguments" + i, zt.errors.UNEXPECTED_ARGUMENT, {
      count: e,
      expectedCount: t
    });
  }
  checkNew(e, t) {
    (e === Object || e == null) && this.throwError("missing new", zt.errors.MISSING_NEW, { name: t.name });
  }
  checkAbstract(e, t) {
    e === t ? this.throwError("cannot instantiate abstract class " + JSON.stringify(t.name) + " directly; use a sub-class", zt.errors.UNSUPPORTED_OPERATION, { name: e.name, operation: "new" }) : (e === Object || e == null) && this.throwError("missing new", zt.errors.MISSING_NEW, { name: t.name });
  }
  static globalLogger() {
    return bf || (bf = new zt(oS)), bf;
  }
  static setCensorship(e, t) {
    if (!e && t && this.globalLogger().throwError("cannot permanently disable censorship", zt.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), u2) {
      if (!e)
        return;
      this.globalLogger().throwError("error censorship permanent", zt.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    l2 = !!e, u2 = !!t;
  }
  static setLogLevel(e) {
    const t = Rc[e.toLowerCase()];
    if (t == null) {
      zt.globalLogger().warn("invalid log level - " + e);
      return;
    }
    c2 = t;
  }
  static from(e) {
    return new zt(e);
  }
};
O.errors = ci;
O.levels = od;
const lS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get ErrorCode() {
    return ci;
  },
  get LogLevel() {
    return od;
  },
  Logger: O
}, Symbol.toStringTag, { value: "Module" })), cS = "bytes/5.7.0", Ct = new O(cS);
function a6(n) {
  return !!n.toHexString;
}
function fo(n) {
  return n.slice || (n.slice = function() {
    const e = Array.prototype.slice.call(arguments);
    return fo(new Uint8Array(Array.prototype.slice.apply(n, e)));
  }), n;
}
function Ll(n) {
  return Ae(n) && !(n.length % 2) || $a(n);
}
function f2(n) {
  return typeof n == "number" && n == n && n % 1 === 0;
}
function $a(n) {
  if (n == null)
    return !1;
  if (n.constructor === Uint8Array)
    return !0;
  if (typeof n == "string" || !f2(n.length) || n.length < 0)
    return !1;
  for (let e = 0; e < n.length; e++) {
    const t = n[e];
    if (!f2(t) || t < 0 || t >= 256)
      return !1;
  }
  return !0;
}
function q(n, e) {
  if (e || (e = {}), typeof n == "number") {
    Ct.checkSafeUint53(n, "invalid arrayify value");
    const t = [];
    for (; n; )
      t.unshift(n & 255), n = parseInt(String(n / 256));
    return t.length === 0 && t.push(0), fo(new Uint8Array(t));
  }
  if (e.allowMissingPrefix && typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), a6(n) && (n = n.toHexString()), Ae(n)) {
    let t = n.substring(2);
    t.length % 2 && (e.hexPad === "left" ? t = "0" + t : e.hexPad === "right" ? t += "0" : Ct.throwArgumentError("hex data is odd-length", "value", n));
    const i = [];
    for (let r = 0; r < t.length; r += 2)
      i.push(parseInt(t.substring(r, r + 2), 16));
    return fo(new Uint8Array(i));
  }
  return $a(n) ? fo(new Uint8Array(n)) : Ct.throwArgumentError("invalid arrayify value", "value", n);
}
function Ve(n) {
  const e = n.map((r) => q(r)), t = e.reduce((r, s) => r + s.length, 0), i = new Uint8Array(t);
  return e.reduce((r, s) => (i.set(s, r), r + s.length), 0), fo(i);
}
function Zi(n) {
  let e = q(n);
  if (e.length === 0)
    return e;
  let t = 0;
  for (; t < e.length && e[t] === 0; )
    t++;
  return t && (e = e.slice(t)), e;
}
function ku(n, e) {
  n = q(n), n.length > e && Ct.throwArgumentError("value out of range", "value", arguments[0]);
  const t = new Uint8Array(e);
  return t.set(n, e - n.length), fo(t);
}
function Ae(n, e) {
  return !(typeof n != "string" || !n.match(/^0x[0-9A-Fa-f]*$/) || e && n.length !== 2 + 2 * e);
}
const gf = "0123456789abcdef";
function H(n, e) {
  if (e || (e = {}), typeof n == "number") {
    Ct.checkSafeUint53(n, "invalid hexlify value");
    let t = "";
    for (; n; )
      t = gf[n & 15] + t, n = Math.floor(n / 16);
    return t.length ? (t.length % 2 && (t = "0" + t), "0x" + t) : "0x00";
  }
  if (typeof n == "bigint")
    return n = n.toString(16), n.length % 2 ? "0x0" + n : "0x" + n;
  if (e.allowMissingPrefix && typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), a6(n))
    return n.toHexString();
  if (Ae(n))
    return n.length % 2 && (e.hexPad === "left" ? n = "0x0" + n.substring(2) : e.hexPad === "right" ? n += "0" : Ct.throwArgumentError("hex data is odd-length", "value", n)), n.toLowerCase();
  if ($a(n)) {
    let t = "0x";
    for (let i = 0; i < n.length; i++) {
      let r = n[i];
      t += gf[(r & 240) >> 4] + gf[r & 15];
    }
    return t;
  }
  return Ct.throwArgumentError("invalid hexlify value", "value", n);
}
function rr(n) {
  if (typeof n != "string")
    n = H(n);
  else if (!Ae(n) || n.length % 2)
    return null;
  return (n.length - 2) / 2;
}
function Bt(n, e, t) {
  return typeof n != "string" ? n = H(n) : (!Ae(n) || n.length % 2) && Ct.throwArgumentError("invalid hexData", "value", n), e = 2 + 2 * e, t != null ? "0x" + n.substring(e, 2 + 2 * t) : "0x" + n.substring(e);
}
function Cn(n) {
  let e = "0x";
  return n.forEach((t) => {
    e += H(t).substring(2);
  }), e;
}
function rp(n) {
  const e = o6(H(n, { hexPad: "left" }));
  return e === "0x" ? "0x0" : e;
}
function o6(n) {
  typeof n != "string" && (n = H(n)), Ae(n) || Ct.throwArgumentError("invalid hex string", "value", n), n = n.substring(2);
  let e = 0;
  for (; e < n.length && n[e] === "0"; )
    e++;
  return "0x" + n.substring(e);
}
function De(n, e) {
  for (typeof n != "string" ? n = H(n) : Ae(n) || Ct.throwArgumentError("invalid hex string", "value", n), n.length > 2 * e + 2 && Ct.throwArgumentError("value out of range", "value", arguments[1]); n.length < 2 * e + 2; )
    n = "0x0" + n.substring(2);
  return n;
}
function Fa(n) {
  const e = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };
  if (Ll(n)) {
    let t = q(n);
    t.length === 64 ? (e.v = 27 + (t[32] >> 7), t[32] &= 127, e.r = H(t.slice(0, 32)), e.s = H(t.slice(32, 64))) : t.length === 65 ? (e.r = H(t.slice(0, 32)), e.s = H(t.slice(32, 64)), e.v = t[64]) : Ct.throwArgumentError("invalid signature string", "signature", n), e.v < 27 && (e.v === 0 || e.v === 1 ? e.v += 27 : Ct.throwArgumentError("signature invalid v byte", "signature", n)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (t[32] |= 128), e._vs = H(t.slice(32, 64));
  } else {
    if (e.r = n.r, e.s = n.s, e.v = n.v, e.recoveryParam = n.recoveryParam, e._vs = n._vs, e._vs != null) {
      const r = ku(q(e._vs), 32);
      e._vs = H(r);
      const s = r[0] >= 128 ? 1 : 0;
      e.recoveryParam == null ? e.recoveryParam = s : e.recoveryParam !== s && Ct.throwArgumentError("signature recoveryParam mismatch _vs", "signature", n), r[0] &= 127;
      const a = H(r);
      e.s == null ? e.s = a : e.s !== a && Ct.throwArgumentError("signature v mismatch _vs", "signature", n);
    }
    if (e.recoveryParam == null)
      e.v == null ? Ct.throwArgumentError("signature missing v and recoveryParam", "signature", n) : e.v === 0 || e.v === 1 ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;
    else if (e.v == null)
      e.v = 27 + e.recoveryParam;
    else {
      const r = e.v === 0 || e.v === 1 ? e.v : 1 - e.v % 2;
      e.recoveryParam !== r && Ct.throwArgumentError("signature recoveryParam mismatch v", "signature", n);
    }
    e.r == null || !Ae(e.r) ? Ct.throwArgumentError("signature missing or invalid r", "signature", n) : e.r = De(e.r, 32), e.s == null || !Ae(e.s) ? Ct.throwArgumentError("signature missing or invalid s", "signature", n) : e.s = De(e.s, 32);
    const t = q(e.s);
    t[0] >= 128 && Ct.throwArgumentError("signature s out of range", "signature", n), e.recoveryParam && (t[0] |= 128);
    const i = H(t);
    e._vs && (Ae(e._vs) || Ct.throwArgumentError("signature invalid _vs", "signature", n), e._vs = De(e._vs, 32)), e._vs == null ? e._vs = i : e._vs !== i && Ct.throwArgumentError("signature _vs mismatch v and s", "signature", n);
  }
  return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
}
function Ty(n) {
  return n = Fa(n), H(Ve([
    n.r,
    n.s,
    n.recoveryParam ? "0x1c" : "0x1b"
  ]));
}
const dS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  arrayify: q,
  concat: Ve,
  hexConcat: Cn,
  hexDataLength: rr,
  hexDataSlice: Bt,
  hexStripZeros: o6,
  hexValue: rp,
  hexZeroPad: De,
  hexlify: H,
  isBytes: $a,
  isBytesLike: Ll,
  isHexString: Ae,
  joinSignature: Ty,
  splitSignature: Fa,
  stripZeros: Zi,
  zeroPad: ku
}, Symbol.toStringTag, { value: "Module" })), u6 = "bignumber/5.7.0";
var el = pe.BN;
const vr = new O(u6), vf = {}, y2 = 9007199254740991;
function pS(n) {
  return n != null && (z.isBigNumber(n) || typeof n == "number" && n % 1 === 0 || typeof n == "string" && !!n.match(/^-?[0-9]+$/) || Ae(n) || typeof n == "bigint" || $a(n));
}
let h2 = !1;
class z {
  constructor(e, t) {
    e !== vf && vr.throwError("cannot call constructor directly; use BigNumber.from", O.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = t, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(e) {
    return Dn(ge(this).fromTwos(e));
  }
  toTwos(e) {
    return Dn(ge(this).toTwos(e));
  }
  abs() {
    return this._hex[0] === "-" ? z.from(this._hex.substring(1)) : this;
  }
  add(e) {
    return Dn(ge(this).add(ge(e)));
  }
  sub(e) {
    return Dn(ge(this).sub(ge(e)));
  }
  div(e) {
    return z.from(e).isZero() && oi("division-by-zero", "div"), Dn(ge(this).div(ge(e)));
  }
  mul(e) {
    return Dn(ge(this).mul(ge(e)));
  }
  mod(e) {
    const t = ge(e);
    return t.isNeg() && oi("division-by-zero", "mod"), Dn(ge(this).umod(t));
  }
  pow(e) {
    const t = ge(e);
    return t.isNeg() && oi("negative-power", "pow"), Dn(ge(this).pow(t));
  }
  and(e) {
    const t = ge(e);
    return (this.isNegative() || t.isNeg()) && oi("unbound-bitwise-result", "and"), Dn(ge(this).and(t));
  }
  or(e) {
    const t = ge(e);
    return (this.isNegative() || t.isNeg()) && oi("unbound-bitwise-result", "or"), Dn(ge(this).or(t));
  }
  xor(e) {
    const t = ge(e);
    return (this.isNegative() || t.isNeg()) && oi("unbound-bitwise-result", "xor"), Dn(ge(this).xor(t));
  }
  mask(e) {
    return (this.isNegative() || e < 0) && oi("negative-width", "mask"), Dn(ge(this).maskn(e));
  }
  shl(e) {
    return (this.isNegative() || e < 0) && oi("negative-width", "shl"), Dn(ge(this).shln(e));
  }
  shr(e) {
    return (this.isNegative() || e < 0) && oi("negative-width", "shr"), Dn(ge(this).shrn(e));
  }
  eq(e) {
    return ge(this).eq(ge(e));
  }
  lt(e) {
    return ge(this).lt(ge(e));
  }
  lte(e) {
    return ge(this).lte(ge(e));
  }
  gt(e) {
    return ge(this).gt(ge(e));
  }
  gte(e) {
    return ge(this).gte(ge(e));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return ge(this).isZero();
  }
  toNumber() {
    try {
      return ge(this).toNumber();
    } catch {
      oi("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return vr.throwError("this platform does not support BigInt", O.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? h2 || (h2 = !0, vr.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? vr.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", O.errors.UNEXPECTED_ARGUMENT, {}) : vr.throwError("BigNumber.toString does not accept parameters", O.errors.UNEXPECTED_ARGUMENT, {})), ge(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(e) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(e) {
    if (e instanceof z)
      return e;
    if (typeof e == "string")
      return e.match(/^-?0x[0-9a-f]+$/i) ? new z(vf, tl(e)) : e.match(/^-?[0-9]+$/) ? new z(vf, tl(new el(e))) : vr.throwArgumentError("invalid BigNumber string", "value", e);
    if (typeof e == "number")
      return e % 1 && oi("underflow", "BigNumber.from", e), (e >= y2 || e <= -y2) && oi("overflow", "BigNumber.from", e), z.from(String(e));
    const t = e;
    if (typeof t == "bigint")
      return z.from(t.toString());
    if ($a(t))
      return z.from(H(t));
    if (t)
      if (t.toHexString) {
        const i = t.toHexString();
        if (typeof i == "string")
          return z.from(i);
      } else {
        let i = t._hex;
        if (i == null && t.type === "BigNumber" && (i = t.hex), typeof i == "string" && (Ae(i) || i[0] === "-" && Ae(i.substring(1))))
          return z.from(i);
      }
    return vr.throwArgumentError("invalid BigNumber value", "value", e);
  }
  static isBigNumber(e) {
    return !!(e && e._isBigNumber);
  }
}
function tl(n) {
  if (typeof n != "string")
    return tl(n.toString(16));
  if (n[0] === "-")
    return n = n.substring(1), n[0] === "-" && vr.throwArgumentError("invalid hex", "value", n), n = tl(n), n === "0x00" ? n : "-" + n;
  if (n.substring(0, 2) !== "0x" && (n = "0x" + n), n === "0x")
    return "0x00";
  for (n.length % 2 && (n = "0x0" + n.substring(2)); n.length > 4 && n.substring(0, 4) === "0x00"; )
    n = "0x" + n.substring(4);
  return n;
}
function Dn(n) {
  return z.from(tl(n));
}
function ge(n) {
  const e = z.from(n).toHexString();
  return e[0] === "-" ? new el("-" + e.substring(3), 16) : new el(e.substring(2), 16);
}
function oi(n, e, t) {
  const i = { fault: n, operation: e };
  return t != null && (i.value = t), vr.throwError(n, O.errors.NUMERIC_FAULT, i);
}
function fS(n) {
  return new el(n, 36).toString(16);
}
function yS(n) {
  return new el(n, 16).toString(36);
}
const _n = new O(u6), Pu = {}, l6 = z.from(0), c6 = z.from(-1);
function d6(n, e, t, i) {
  const r = { fault: e, operation: t };
  return i !== void 0 && (r.value = i), _n.throwError(n, O.errors.NUMERIC_FAULT, r);
}
let Iu = "0";
for (; Iu.length < 256; )
  Iu += Iu;
function i0(n) {
  if (typeof n != "number")
    try {
      n = z.from(n).toNumber();
    } catch {
    }
  return typeof n == "number" && n >= 0 && n <= 256 && !(n % 1) ? "1" + Iu.substring(0, n) : _n.throwArgumentError("invalid decimal size", "decimals", n);
}
function kc(n, e) {
  e == null && (e = 0);
  const t = i0(e);
  n = z.from(n);
  const i = n.lt(l6);
  i && (n = n.mul(c6));
  let r = n.mod(t).toString();
  for (; r.length < t.length - 1; )
    r = "0" + r;
  r = r.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const s = n.div(t).toString();
  return t.length === 1 ? n = s : n = s + "." + r, i && (n = "-" + n), n;
}
function zi(n, e) {
  e == null && (e = 0);
  const t = i0(e);
  (typeof n != "string" || !n.match(/^-?[0-9.]+$/)) && _n.throwArgumentError("invalid decimal value", "value", n);
  const i = n.substring(0, 1) === "-";
  i && (n = n.substring(1)), n === "." && _n.throwArgumentError("missing value", "value", n);
  const r = n.split(".");
  r.length > 2 && _n.throwArgumentError("too many decimal points", "value", n);
  let s = r[0], a = r[1];
  for (s || (s = "0"), a || (a = "0"); a[a.length - 1] === "0"; )
    a = a.substring(0, a.length - 1);
  for (a.length > t.length - 1 && d6("fractional component exceeds decimals", "underflow", "parseFixed"), a === "" && (a = "0"); a.length < t.length - 1; )
    a += "0";
  const o = z.from(s), u = z.from(a);
  let l = o.mul(t).add(u);
  return i && (l = l.mul(c6)), l;
}
class yo {
  constructor(e, t, i, r) {
    e !== Pu && _n.throwError("cannot use FixedFormat constructor; use FixedFormat.from", O.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.signed = t, this.width = i, this.decimals = r, this.name = (t ? "" : "u") + "fixed" + String(i) + "x" + String(r), this._multiplier = i0(r), Object.freeze(this);
  }
  static from(e) {
    if (e instanceof yo)
      return e;
    typeof e == "number" && (e = `fixed128x${e}`);
    let t = !0, i = 128, r = 18;
    if (typeof e == "string") {
      if (e !== "fixed")
        if (e === "ufixed")
          t = !1;
        else {
          const s = e.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          s || _n.throwArgumentError("invalid fixed format", "format", e), t = s[1] !== "u", i = parseInt(s[2]), r = parseInt(s[3]);
        }
    } else if (e) {
      const s = (a, o, u) => e[a] == null ? u : (typeof e[a] !== o && _n.throwArgumentError("invalid fixed format (" + a + " not " + o + ")", "format." + a, e[a]), e[a]);
      t = s("signed", "boolean", t), i = s("width", "number", i), r = s("decimals", "number", r);
    }
    return i % 8 && _n.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", i), r > 80 && _n.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", r), new yo(Pu, t, i, r);
  }
}
class nn {
  constructor(e, t, i, r) {
    e !== Pu && _n.throwError("cannot use FixedNumber constructor; use FixedNumber.from", O.errors.UNSUPPORTED_OPERATION, {
      operation: "new FixedFormat"
    }), this.format = r, this._hex = t, this._value = i, this._isFixedNumber = !0, Object.freeze(this);
  }
  _checkFormat(e) {
    this.format.name !== e.format.name && _n.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", e);
  }
  addUnsafe(e) {
    this._checkFormat(e);
    const t = zi(this._value, this.format.decimals), i = zi(e._value, e.format.decimals);
    return nn.fromValue(t.add(i), this.format.decimals, this.format);
  }
  subUnsafe(e) {
    this._checkFormat(e);
    const t = zi(this._value, this.format.decimals), i = zi(e._value, e.format.decimals);
    return nn.fromValue(t.sub(i), this.format.decimals, this.format);
  }
  mulUnsafe(e) {
    this._checkFormat(e);
    const t = zi(this._value, this.format.decimals), i = zi(e._value, e.format.decimals);
    return nn.fromValue(t.mul(i).div(this.format._multiplier), this.format.decimals, this.format);
  }
  divUnsafe(e) {
    this._checkFormat(e);
    const t = zi(this._value, this.format.decimals), i = zi(e._value, e.format.decimals);
    return nn.fromValue(t.mul(this.format._multiplier).div(i), this.format.decimals, this.format);
  }
  floor() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let t = nn.from(e[0], this.format);
    const i = !e[1].match(/^(0*)$/);
    return this.isNegative() && i && (t = t.subUnsafe(m2.toFormat(t.format))), t;
  }
  ceiling() {
    const e = this.toString().split(".");
    e.length === 1 && e.push("0");
    let t = nn.from(e[0], this.format);
    const i = !e[1].match(/^(0*)$/);
    return !this.isNegative() && i && (t = t.addUnsafe(m2.toFormat(t.format))), t;
  }
  // @TODO: Support other rounding algorithms
  round(e) {
    e == null && (e = 0);
    const t = this.toString().split(".");
    if (t.length === 1 && t.push("0"), (e < 0 || e > 80 || e % 1) && _n.throwArgumentError("invalid decimal count", "decimals", e), t[1].length <= e)
      return this;
    const i = nn.from("1" + Iu.substring(0, e), this.format), r = hS.toFormat(this.format);
    return this.mulUnsafe(i).addUnsafe(r).floor().divUnsafe(i);
  }
  isZero() {
    return this._value === "0.0" || this._value === "0";
  }
  isNegative() {
    return this._value[0] === "-";
  }
  toString() {
    return this._value;
  }
  toHexString(e) {
    if (e == null)
      return this._hex;
    e % 8 && _n.throwArgumentError("invalid byte width", "width", e);
    const t = z.from(this._hex).fromTwos(this.format.width).toTwos(e).toHexString();
    return De(t, e / 8);
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(e) {
    return nn.fromString(this._value, e);
  }
  static fromValue(e, t, i) {
    return i == null && t != null && !pS(t) && (i = t, t = null), t == null && (t = 0), i == null && (i = "fixed"), nn.fromString(kc(e, t), yo.from(i));
  }
  static fromString(e, t) {
    t == null && (t = "fixed");
    const i = yo.from(t), r = zi(e, i.decimals);
    !i.signed && r.lt(l6) && d6("unsigned value cannot be negative", "overflow", "value", e);
    let s = null;
    i.signed ? s = r.toTwos(i.width).toHexString() : (s = r.toHexString(), s = De(s, i.width / 8));
    const a = kc(r, i.decimals);
    return new nn(Pu, s, a, i);
  }
  static fromBytes(e, t) {
    t == null && (t = "fixed");
    const i = yo.from(t);
    if (q(e).length > i.width / 8)
      throw new Error("overflow");
    let r = z.from(e);
    i.signed && (r = r.fromTwos(i.width));
    const s = r.toTwos((i.signed ? 0 : 1) + i.width).toHexString(), a = kc(r, i.decimals);
    return new nn(Pu, s, a, i);
  }
  static from(e, t) {
    if (typeof e == "string")
      return nn.fromString(e, t);
    if ($a(e))
      return nn.fromBytes(e, t);
    try {
      return nn.fromValue(e, 0, t);
    } catch (i) {
      if (i.code !== O.errors.INVALID_ARGUMENT)
        throw i;
    }
    return _n.throwArgumentError("invalid FixedNumber value", "value", e);
  }
  static isFixedNumber(e) {
    return !!(e && e._isFixedNumber);
  }
}
const m2 = nn.from(1), hS = nn.from("0.5"), mS = "properties/5.7.0";
var bS = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
const ud = new O(mS);
function U(n, e, t) {
  Object.defineProperty(n, e, {
    enumerable: !0,
    value: t,
    writable: !1
  });
}
function Oi(n, e) {
  for (let t = 0; t < 32; t++) {
    if (n[e])
      return n[e];
    if (!n.prototype || typeof n.prototype != "object")
      break;
    n = Object.getPrototypeOf(n.prototype).constructor;
  }
  return null;
}
function _t(n) {
  return bS(this, void 0, void 0, function* () {
    const e = Object.keys(n).map((i) => {
      const r = n[i];
      return Promise.resolve(r).then((s) => ({ key: i, value: s }));
    });
    return (yield Promise.all(e)).reduce((i, r) => (i[r.key] = r.value, i), {});
  });
}
function r0(n, e) {
  (!n || typeof n != "object") && ud.throwArgumentError("invalid object", "object", n), Object.keys(n).forEach((t) => {
    e[t] || ud.throwArgumentError("invalid object key - " + t, "transaction:" + t, n);
  });
}
function Ut(n) {
  const e = {};
  for (const t in n)
    e[t] = n[t];
  return e;
}
const gS = { bigint: !0, boolean: !0, function: !0, number: !0, string: !0 };
function p6(n) {
  if (n == null || gS[typeof n])
    return !0;
  if (Array.isArray(n) || typeof n == "object") {
    if (!Object.isFrozen(n))
      return !1;
    const e = Object.keys(n);
    for (let t = 0; t < e.length; t++) {
      let i = null;
      try {
        i = n[e[t]];
      } catch {
        continue;
      }
      if (!p6(i))
        return !1;
    }
    return !0;
  }
  return ud.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n);
}
function vS(n) {
  if (p6(n))
    return n;
  if (Array.isArray(n))
    return Object.freeze(n.map((e) => Ss(e)));
  if (typeof n == "object") {
    const e = {};
    for (const t in n) {
      const i = n[t];
      i !== void 0 && U(e, t, Ss(i));
    }
    return e;
  }
  return ud.throwArgumentError(`Cannot deepCopy ${typeof n}`, "object", n);
}
function Ss(n) {
  return vS(n);
}
class Ps {
  constructor(e) {
    for (const t in e)
      this[t] = Ss(e[t]);
  }
}
const xS = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Description: Ps,
  checkProperties: r0,
  deepCopy: Ss,
  defineReadOnly: U,
  getStatic: Oi,
  resolveProperties: _t,
  shallowCopy: Ut
}, Symbol.toStringTag, { value: "Module" })), Ul = "abi/5.7.0", Te = new O(Ul), ma = {};
let b2 = { calldata: !0, memory: !0, storage: !0 }, TS = { calldata: !0, memory: !0 };
function lc(n, e) {
  if (n === "bytes" || n === "string") {
    if (b2[e])
      return !0;
  } else if (n === "address") {
    if (e === "payable")
      return !0;
  } else if ((n.indexOf("[") >= 0 || n === "tuple") && TS[e])
    return !0;
  return (b2[e] || e === "payable") && Te.throwArgumentError("invalid modifier", "name", e), !1;
}
function wS(n, e) {
  let t = n;
  function i(o) {
    Te.throwArgumentError(`unexpected character at position ${o}`, "param", n);
  }
  n = n.replace(/\s/g, " ");
  function r(o) {
    let u = { type: "", name: "", parent: o, state: { allowType: !0 } };
    return e && (u.indexed = !1), u;
  }
  let s = { type: "", name: "", state: { allowType: !0 } }, a = s;
  for (let o = 0; o < n.length; o++) {
    let u = n[o];
    switch (u) {
      case "(":
        a.state.allowType && a.type === "" ? a.type = "tuple" : a.state.allowParams || i(o), a.state.allowType = !1, a.type = to(a.type), a.components = [r(a)], a = a.components[0];
        break;
      case ")":
        delete a.state, a.name === "indexed" && (e || i(o), a.indexed = !0, a.name = ""), lc(a.type, a.name) && (a.name = ""), a.type = to(a.type);
        let l = a;
        a = a.parent, a || i(o), delete l.parent, a.state.allowParams = !1, a.state.allowName = !0, a.state.allowArray = !0;
        break;
      case ",":
        delete a.state, a.name === "indexed" && (e || i(o), a.indexed = !0, a.name = ""), lc(a.type, a.name) && (a.name = ""), a.type = to(a.type);
        let p = r(a.parent);
        a.parent.components.push(p), delete a.parent, a = p;
        break;
      case " ":
        a.state.allowType && a.type !== "" && (a.type = to(a.type), delete a.state.allowType, a.state.allowName = !0, a.state.allowParams = !0), a.state.allowName && a.name !== "" && (a.name === "indexed" ? (e || i(o), a.indexed && i(o), a.indexed = !0, a.name = "") : lc(a.type, a.name) ? a.name = "" : a.state.allowName = !1);
        break;
      case "[":
        a.state.allowArray || i(o), a.type += u, a.state.allowArray = !1, a.state.allowName = !1, a.state.readArray = !0;
        break;
      case "]":
        a.state.readArray || i(o), a.type += u, a.state.readArray = !1, a.state.allowArray = !0, a.state.allowName = !0;
        break;
      default:
        a.state.allowType ? (a.type += u, a.state.allowParams = !0, a.state.allowArray = !0) : a.state.allowName ? (a.name += u, delete a.state.allowArray) : a.state.readArray ? a.type += u : i(o);
    }
  }
  return a.parent && Te.throwArgumentError("unexpected eof", "param", n), delete s.state, a.name === "indexed" ? (e || i(t.length - 7), a.indexed && i(t.length - 7), a.indexed = !0, a.name = "") : lc(a.type, a.name) && (a.name = ""), s.type = to(s.type), s;
}
function Pc(n, e) {
  for (let t in e)
    U(n, t, e[t]);
}
const Me = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
}), AS = new RegExp(/^(.*)\[([0-9]*)\]$/);
class qt {
  constructor(e, t) {
    e !== ma && Te.throwError("use fromString", O.errors.UNSUPPORTED_OPERATION, {
      operation: "new ParamType()"
    }), Pc(this, t);
    let i = this.type.match(AS);
    i ? Pc(this, {
      arrayLength: parseInt(i[2] || "-1"),
      arrayChildren: qt.fromObject({
        type: i[1],
        components: this.components
      }),
      baseType: "array"
    }) : Pc(this, {
      arrayLength: null,
      arrayChildren: null,
      baseType: this.components != null ? "tuple" : this.type
    }), this._isParamType = !0, Object.freeze(this);
  }
  // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"
  format(e) {
    if (e || (e = Me.sighash), Me[e] || Te.throwArgumentError("invalid format type", "format", e), e === Me.json) {
      let i = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || void 0
      };
      return typeof this.indexed == "boolean" && (i.indexed = this.indexed), this.components && (i.components = this.components.map((r) => JSON.parse(r.format(e)))), JSON.stringify(i);
    }
    let t = "";
    return this.baseType === "array" ? (t += this.arrayChildren.format(e), t += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : this.baseType === "tuple" ? (e !== Me.sighash && (t += this.type), t += "(" + this.components.map((i) => i.format(e)).join(e === Me.full ? ", " : ",") + ")") : t += this.type, e !== Me.sighash && (this.indexed === !0 && (t += " indexed"), e === Me.full && this.name && (t += " " + this.name)), t;
  }
  static from(e, t) {
    return typeof e == "string" ? qt.fromString(e, t) : qt.fromObject(e);
  }
  static fromObject(e) {
    return qt.isParamType(e) ? e : new qt(ma, {
      name: e.name || null,
      type: to(e.type),
      indexed: e.indexed == null ? null : !!e.indexed,
      components: e.components ? e.components.map(qt.fromObject) : null
    });
  }
  static fromString(e, t) {
    function i(r) {
      return qt.fromObject({
        name: r.name,
        type: r.type,
        indexed: r.indexed,
        components: r.components
      });
    }
    return i(wS(e, !!t));
  }
  static isParamType(e) {
    return !!(e != null && e._isParamType);
  }
}
function nl(n, e) {
  return SS(n).map((t) => qt.fromString(t, e));
}
class Qi {
  constructor(e, t) {
    e !== ma && Te.throwError("use a static from method", O.errors.UNSUPPORTED_OPERATION, {
      operation: "new Fragment()"
    }), Pc(this, t), this._isFragment = !0, Object.freeze(this);
  }
  static from(e) {
    return Qi.isFragment(e) ? e : typeof e == "string" ? Qi.fromString(e) : Qi.fromObject(e);
  }
  static fromObject(e) {
    if (Qi.isFragment(e))
      return e;
    switch (e.type) {
      case "function":
        return Ri.fromObject(e);
      case "event":
        return Ji.fromObject(e);
      case "constructor":
        return _i.fromObject(e);
      case "error":
        return Sr.fromObject(e);
      case "fallback":
      case "receive":
        return null;
    }
    return Te.throwArgumentError("invalid fragment object", "value", e);
  }
  static fromString(e) {
    return e = e.replace(/\s/g, " "), e = e.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " "), e = e.trim(), e.split(" ")[0] === "event" ? Ji.fromString(e.substring(5).trim()) : e.split(" ")[0] === "function" ? Ri.fromString(e.substring(8).trim()) : e.split("(")[0].trim() === "constructor" ? _i.fromString(e.trim()) : e.split(" ")[0] === "error" ? Sr.fromString(e.substring(5).trim()) : Te.throwArgumentError("unsupported fragment", "value", e);
  }
  static isFragment(e) {
    return !!(e && e._isFragment);
  }
}
class Ji extends Qi {
  format(e) {
    if (e || (e = Me.sighash), Me[e] || Te.throwArgumentError("invalid format type", "format", e), e === Me.json)
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e)))
      });
    let t = "";
    return e !== Me.sighash && (t += "event "), t += this.name + "(" + this.inputs.map((i) => i.format(e)).join(e === Me.full ? ", " : ",") + ") ", e !== Me.sighash && this.anonymous && (t += "anonymous "), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? Ji.fromString(e) : Ji.fromObject(e);
  }
  static fromObject(e) {
    if (Ji.isEventFragment(e))
      return e;
    e.type !== "event" && Te.throwArgumentError("invalid event object", "value", e);
    const t = {
      name: il(e.name),
      anonymous: e.anonymous,
      inputs: e.inputs ? e.inputs.map(qt.fromObject) : [],
      type: "event"
    };
    return new Ji(ma, t);
  }
  static fromString(e) {
    let t = e.match(rl);
    t || Te.throwArgumentError("invalid event string", "value", e);
    let i = !1;
    return t[3].split(" ").forEach((r) => {
      switch (r.trim()) {
        case "anonymous":
          i = !0;
          break;
        case "":
          break;
        default:
          Te.warn("unknown modifier: " + r);
      }
    }), Ji.fromObject({
      name: t[1].trim(),
      anonymous: i,
      inputs: nl(t[2], !0),
      type: "event"
    });
  }
  static isEventFragment(e) {
    return e && e._isFragment && e.type === "event";
  }
}
function f6(n, e) {
  e.gas = null;
  let t = n.split("@");
  return t.length !== 1 ? (t.length > 2 && Te.throwArgumentError("invalid human-readable ABI signature", "value", n), t[1].match(/^[0-9]+$/) || Te.throwArgumentError("invalid human-readable ABI signature gas", "value", n), e.gas = z.from(t[1]), t[0]) : n;
}
function y6(n, e) {
  e.constant = !1, e.payable = !1, e.stateMutability = "nonpayable", n.split(" ").forEach((t) => {
    switch (t.trim()) {
      case "constant":
        e.constant = !0;
        break;
      case "payable":
        e.payable = !0, e.stateMutability = "payable";
        break;
      case "nonpayable":
        e.payable = !1, e.stateMutability = "nonpayable";
        break;
      case "pure":
        e.constant = !0, e.stateMutability = "pure";
        break;
      case "view":
        e.constant = !0, e.stateMutability = "view";
        break;
      case "external":
      case "public":
      case "":
        break;
      default:
        console.log("unknown modifier: " + t);
    }
  });
}
function h6(n) {
  let e = {
    constant: !1,
    payable: !0,
    stateMutability: "payable"
  };
  return n.stateMutability != null ? (e.stateMutability = n.stateMutability, e.constant = e.stateMutability === "view" || e.stateMutability === "pure", n.constant != null && !!n.constant !== e.constant && Te.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", n), e.payable = e.stateMutability === "payable", n.payable != null && !!n.payable !== e.payable && Te.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", n)) : n.payable != null ? (e.payable = !!n.payable, n.constant == null && !e.payable && n.type !== "constructor" && Te.throwArgumentError("unable to determine stateMutability", "value", n), e.constant = !!n.constant, e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable", e.payable && e.constant && Te.throwArgumentError("cannot have constant payable function", "value", n)) : n.constant != null ? (e.constant = !!n.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : n.type !== "constructor" && Te.throwArgumentError("unable to determine stateMutability", "value", n), e;
}
class _i extends Qi {
  format(e) {
    if (e || (e = Me.sighash), Me[e] || Te.throwArgumentError("invalid format type", "format", e), e === Me.json)
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e)))
      });
    e === Me.sighash && Te.throwError("cannot format a constructor for sighash", O.errors.UNSUPPORTED_OPERATION, {
      operation: "format(sighash)"
    });
    let t = "constructor(" + this.inputs.map((i) => i.format(e)).join(e === Me.full ? ", " : ",") + ") ";
    return this.stateMutability && this.stateMutability !== "nonpayable" && (t += this.stateMutability + " "), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? _i.fromString(e) : _i.fromObject(e);
  }
  static fromObject(e) {
    if (_i.isConstructorFragment(e))
      return e;
    e.type !== "constructor" && Te.throwArgumentError("invalid constructor object", "value", e);
    let t = h6(e);
    t.constant && Te.throwArgumentError("constructor cannot be constant", "value", e);
    const i = {
      name: null,
      type: e.type,
      inputs: e.inputs ? e.inputs.map(qt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? z.from(e.gas) : null
    };
    return new _i(ma, i);
  }
  static fromString(e) {
    let t = { type: "constructor" };
    e = f6(e, t);
    let i = e.match(rl);
    return (!i || i[1].trim() !== "constructor") && Te.throwArgumentError("invalid constructor string", "value", e), t.inputs = nl(i[2].trim(), !1), y6(i[3].trim(), t), _i.fromObject(t);
  }
  static isConstructorFragment(e) {
    return e && e._isFragment && e.type === "constructor";
  }
}
class Ri extends _i {
  format(e) {
    if (e || (e = Me.sighash), Me[e] || Te.throwArgumentError("invalid format type", "format", e), e === Me.json)
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : void 0,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e))),
        outputs: this.outputs.map((i) => JSON.parse(i.format(e)))
      });
    let t = "";
    return e !== Me.sighash && (t += "function "), t += this.name + "(" + this.inputs.map((i) => i.format(e)).join(e === Me.full ? ", " : ",") + ") ", e !== Me.sighash && (this.stateMutability ? this.stateMutability !== "nonpayable" && (t += this.stateMutability + " ") : this.constant && (t += "view "), this.outputs && this.outputs.length && (t += "returns (" + this.outputs.map((i) => i.format(e)).join(", ") + ") "), this.gas != null && (t += "@" + this.gas.toString() + " ")), t.trim();
  }
  static from(e) {
    return typeof e == "string" ? Ri.fromString(e) : Ri.fromObject(e);
  }
  static fromObject(e) {
    if (Ri.isFunctionFragment(e))
      return e;
    e.type !== "function" && Te.throwArgumentError("invalid function object", "value", e);
    let t = h6(e);
    const i = {
      type: e.type,
      name: il(e.name),
      constant: t.constant,
      inputs: e.inputs ? e.inputs.map(qt.fromObject) : [],
      outputs: e.outputs ? e.outputs.map(qt.fromObject) : [],
      payable: t.payable,
      stateMutability: t.stateMutability,
      gas: e.gas ? z.from(e.gas) : null
    };
    return new Ri(ma, i);
  }
  static fromString(e) {
    let t = { type: "function" };
    e = f6(e, t);
    let i = e.split(" returns ");
    i.length > 2 && Te.throwArgumentError("invalid function string", "value", e);
    let r = i[0].match(rl);
    if (r || Te.throwArgumentError("invalid function signature", "value", e), t.name = r[1].trim(), t.name && il(t.name), t.inputs = nl(r[2], !1), y6(r[3].trim(), t), i.length > 1) {
      let s = i[1].match(rl);
      (s[1].trim() != "" || s[3].trim() != "") && Te.throwArgumentError("unexpected tokens", "value", e), t.outputs = nl(s[2], !1);
    } else
      t.outputs = [];
    return Ri.fromObject(t);
  }
  static isFunctionFragment(e) {
    return e && e._isFragment && e.type === "function";
  }
}
function g2(n) {
  const e = n.format();
  return (e === "Error(string)" || e === "Panic(uint256)") && Te.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", n), n;
}
class Sr extends Qi {
  format(e) {
    if (e || (e = Me.sighash), Me[e] || Te.throwArgumentError("invalid format type", "format", e), e === Me.json)
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(e)))
      });
    let t = "";
    return e !== Me.sighash && (t += "error "), t += this.name + "(" + this.inputs.map((i) => i.format(e)).join(e === Me.full ? ", " : ",") + ") ", t.trim();
  }
  static from(e) {
    return typeof e == "string" ? Sr.fromString(e) : Sr.fromObject(e);
  }
  static fromObject(e) {
    if (Sr.isErrorFragment(e))
      return e;
    e.type !== "error" && Te.throwArgumentError("invalid error object", "value", e);
    const t = {
      type: e.type,
      name: il(e.name),
      inputs: e.inputs ? e.inputs.map(qt.fromObject) : []
    };
    return g2(new Sr(ma, t));
  }
  static fromString(e) {
    let t = { type: "error" }, i = e.match(rl);
    return i || Te.throwArgumentError("invalid error signature", "value", e), t.name = i[1].trim(), t.name && il(t.name), t.inputs = nl(i[2], !1), g2(Sr.fromObject(t));
  }
  static isErrorFragment(e) {
    return e && e._isFragment && e.type === "error";
  }
}
function to(n) {
  return n.match(/^uint($|[^1-9])/) ? n = "uint256" + n.substring(4) : n.match(/^int($|[^1-9])/) && (n = "int256" + n.substring(3)), n;
}
const ES = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function il(n) {
  return (!n || !n.match(ES)) && Te.throwArgumentError(`invalid identifier "${n}"`, "value", n), n;
}
const rl = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function SS(n) {
  n = n.trim();
  let e = [], t = "", i = 0;
  for (let r = 0; r < n.length; r++) {
    let s = n[r];
    s === "," && i === 0 ? (e.push(t), t = "") : (t += s, s === "(" ? i++ : s === ")" && (i--, i === -1 && Te.throwArgumentError("unbalanced parenthesis", "value", n)));
  }
  return t && e.push(t), e;
}
const s0 = new O(Ul);
function m6(n) {
  const e = [], t = function(i, r) {
    if (Array.isArray(r))
      for (let s in r) {
        const a = i.slice();
        a.push(s);
        try {
          t(a, r[s]);
        } catch (o) {
          e.push({ path: a, error: o });
        }
      }
  };
  return t([], n), e;
}
class Jr {
  constructor(e, t, i, r) {
    this.name = e, this.type = t, this.localName = i, this.dynamic = r;
  }
  _throwError(e, t) {
    s0.throwArgumentError(e, this.localName, t);
  }
}
class wy {
  constructor(e) {
    U(this, "wordSize", e || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(e);
  }
  get data() {
    return Cn(this._data);
  }
  get length() {
    return this._dataLength;
  }
  _writeData(e) {
    return this._data.push(e), this._dataLength += e.length, e.length;
  }
  appendWriter(e) {
    return this._writeData(Ve(e._data));
  }
  // Arrayish items; padded on the right to wordSize
  writeBytes(e) {
    let t = q(e);
    const i = t.length % this.wordSize;
    return i && (t = Ve([t, this._padding.slice(i)])), this._writeData(t);
  }
  _getValue(e) {
    let t = q(z.from(e));
    return t.length > this.wordSize && s0.throwError("value out-of-bounds", O.errors.BUFFER_OVERRUN, {
      length: this.wordSize,
      offset: t.length
    }), t.length % this.wordSize && (t = Ve([this._padding.slice(t.length % this.wordSize), t])), t;
  }
  // BigNumberish items; padded on the left to wordSize
  writeValue(e) {
    return this._writeData(this._getValue(e));
  }
  writeUpdatableValue() {
    const e = this._data.length;
    return this._data.push(this._padding), this._dataLength += this.wordSize, (t) => {
      this._data[e] = this._getValue(t);
    };
  }
}
class ld {
  constructor(e, t, i, r) {
    U(this, "_data", q(e)), U(this, "wordSize", t || 32), U(this, "_coerceFunc", i), U(this, "allowLoose", r), this._offset = 0;
  }
  get data() {
    return H(this._data);
  }
  get consumed() {
    return this._offset;
  }
  // The default Coerce function
  static coerce(e, t) {
    let i = e.match("^u?int([0-9]+)$");
    return i && parseInt(i[1]) <= 48 && (t = t.toNumber()), t;
  }
  coerce(e, t) {
    return this._coerceFunc ? this._coerceFunc(e, t) : ld.coerce(e, t);
  }
  _peekBytes(e, t, i) {
    let r = Math.ceil(t / this.wordSize) * this.wordSize;
    return this._offset + r > this._data.length && (this.allowLoose && i && this._offset + t <= this._data.length ? r = t : s0.throwError("data out-of-bounds", O.errors.BUFFER_OVERRUN, {
      length: this._data.length,
      offset: this._offset + r
    })), this._data.slice(this._offset, this._offset + r);
  }
  subReader(e) {
    return new ld(this._data.slice(this._offset + e), this.wordSize, this._coerceFunc, this.allowLoose);
  }
  readBytes(e, t) {
    let i = this._peekBytes(0, e, !!t);
    return this._offset += i.length, i.slice(0, e);
  }
  readValue() {
    return z.from(this.readBytes(this.wordSize));
  }
}
const ba = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
function b6() {
  throw new Error("setTimeout has not been defined");
}
function g6() {
  throw new Error("clearTimeout has not been defined");
}
var as = b6, os = g6;
typeof ba.setTimeout == "function" && (as = setTimeout);
typeof ba.clearTimeout == "function" && (os = clearTimeout);
function v6(n) {
  if (as === setTimeout)
    return setTimeout(n, 0);
  if ((as === b6 || !as) && setTimeout)
    return as = setTimeout, setTimeout(n, 0);
  try {
    return as(n, 0);
  } catch {
    try {
      return as.call(null, n, 0);
    } catch {
      return as.call(this, n, 0);
    }
  }
}
function MS(n) {
  if (os === clearTimeout)
    return clearTimeout(n);
  if ((os === g6 || !os) && clearTimeout)
    return os = clearTimeout, clearTimeout(n);
  try {
    return os(n);
  } catch {
    try {
      return os.call(null, n);
    } catch {
      return os.call(this, n);
    }
  }
}
var Cr = [], ho = !1, aa, Ic = -1;
function CS() {
  !ho || !aa || (ho = !1, aa.length ? Cr = aa.concat(Cr) : Ic = -1, Cr.length && x6());
}
function x6() {
  if (!ho) {
    var n = v6(CS);
    ho = !0;
    for (var e = Cr.length; e; ) {
      for (aa = Cr, Cr = []; ++Ic < e; )
        aa && aa[Ic].run();
      Ic = -1, e = Cr.length;
    }
    aa = null, ho = !1, MS(n);
  }
}
function _S(n) {
  var e = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var t = 1; t < arguments.length; t++)
      e[t - 1] = arguments[t];
  Cr.push(new T6(n, e)), Cr.length === 1 && !ho && v6(x6);
}
function T6(n, e) {
  this.fun = n, this.array = e;
}
T6.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var RS = "browser", kS = "browser", PS = !0, IS = {}, OS = [], BS = "", NS = {}, DS = {}, $S = {};
function La() {
}
var FS = La, LS = La, US = La, VS = La, jS = La, zS = La, GS = La;
function qS(n) {
  throw new Error("process.binding is not supported");
}
function HS() {
  return "/";
}
function KS(n) {
  throw new Error("process.chdir is not supported");
}
function WS() {
  return 0;
}
var no = ba.performance || {}, JS = no.now || no.mozNow || no.msNow || no.oNow || no.webkitNow || function() {
  return (/* @__PURE__ */ new Date()).getTime();
};
function QS(n) {
  var e = JS.call(no) * 1e-3, t = Math.floor(e), i = Math.floor(e % 1 * 1e9);
  return n && (t = t - n[0], i = i - n[1], i < 0 && (t--, i += 1e9)), [t, i];
}
var YS = /* @__PURE__ */ new Date();
function XS() {
  var n = /* @__PURE__ */ new Date(), e = n - YS;
  return e / 1e3;
}
var Oc = {
  nextTick: _S,
  title: RS,
  browser: PS,
  env: IS,
  argv: OS,
  version: BS,
  versions: NS,
  on: FS,
  addListener: LS,
  once: US,
  off: VS,
  removeListener: jS,
  removeAllListeners: zS,
  emit: GS,
  binding: qS,
  cwd: HS,
  chdir: KS,
  umask: WS,
  hrtime: QS,
  platform: kS,
  release: DS,
  config: $S,
  uptime: XS
}, Ay = {}, ZS = {
  get exports() {
    return Ay;
  },
  set exports(n) {
    Ay = n;
  }
};
(function(n) {
  (function() {
    var e = "input is invalid type", t = "finalize already called", i = typeof window == "object", r = i ? window : {};
    r.JS_SHA3_NO_WINDOW && (i = !1);
    var s = !i && typeof self == "object", a = !r.JS_SHA3_NO_NODE_JS && typeof Oc == "object" && Oc.versions && Oc.versions.node;
    a ? r = ls : s && (r = self);
    var o = !r.JS_SHA3_NO_COMMON_JS && !0 && n.exports, u = !r.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer < "u", l = "0123456789abcdef".split(""), p = [31, 7936, 2031616, 520093696], f = [4, 1024, 262144, 67108864], b = [1, 256, 65536, 16777216], A = [6, 1536, 393216, 100663296], x = [0, 8, 16, 24], w = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ], T = [224, 256, 384, 512], _ = [128, 256], I = ["hex", "buffer", "arrayBuffer", "array", "digest"], $ = {
      128: 168,
      256: 136
    };
    (r.JS_SHA3_NO_NODE_JS || !Array.isArray) && (Array.isArray = function(y) {
      return Object.prototype.toString.call(y) === "[object Array]";
    }), u && (r.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView) && (ArrayBuffer.isView = function(y) {
      return typeof y == "object" && y.buffer && y.buffer.constructor === ArrayBuffer;
    });
    for (var N = function(y, R, F) {
      return function(D) {
        return new d(y, R, y).update(D)[F]();
      };
    }, B = function(y, R, F) {
      return function(D, L) {
        return new d(y, R, L).update(D)[F]();
      };
    }, V = function(y, R, F) {
      return function(D, L, te, W) {
        return c["cshake" + y].update(D, L, te, W)[F]();
      };
    }, K = function(y, R, F) {
      return function(D, L, te, W) {
        return c["kmac" + y].update(D, L, te, W)[F]();
      };
    }, G = function(y, R, F, D) {
      for (var L = 0; L < I.length; ++L) {
        var te = I[L];
        y[te] = R(F, D, te);
      }
      return y;
    }, Y = function(y, R) {
      var F = N(y, R, "hex");
      return F.create = function() {
        return new d(y, R, y);
      }, F.update = function(D) {
        return F.create().update(D);
      }, G(F, N, y, R);
    }, oe = function(y, R) {
      var F = B(y, R, "hex");
      return F.create = function(D) {
        return new d(y, R, D);
      }, F.update = function(D, L) {
        return F.create(L).update(D);
      }, G(F, B, y, R);
    }, J = function(y, R) {
      var F = $[y], D = V(y, R, "hex");
      return D.create = function(L, te, W) {
        return !te && !W ? c["shake" + y].create(L) : new d(y, R, L).bytepad([te, W], F);
      }, D.update = function(L, te, W, Q) {
        return D.create(te, W, Q).update(L);
      }, G(D, V, y, R);
    }, ue = function(y, R) {
      var F = $[y], D = K(y, R, "hex");
      return D.create = function(L, te, W) {
        return new g(y, R, te).bytepad(["KMAC", W], F).bytepad([L], F);
      }, D.update = function(L, te, W, Q) {
        return D.create(L, W, Q).update(te);
      }, G(D, K, y, R);
    }, M = [
      { name: "keccak", padding: b, bits: T, createMethod: Y },
      { name: "sha3", padding: A, bits: T, createMethod: Y },
      { name: "shake", padding: p, bits: _, createMethod: oe },
      { name: "cshake", padding: f, bits: _, createMethod: J },
      { name: "kmac", padding: f, bits: _, createMethod: ue }
    ], c = {}, h = [], v = 0; v < M.length; ++v)
      for (var S = M[v], E = S.bits, C = 0; C < E.length; ++C) {
        var k = S.name + "_" + E[C];
        if (h.push(k), c[k] = S.createMethod(E[C], S.padding), S.name !== "sha3") {
          var m = S.name + E[C];
          h.push(m), c[m] = c[k];
        }
      }
    function d(y, R, F) {
      this.blocks = [], this.s = [], this.padding = R, this.outputBits = F, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (y << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = F >> 5, this.extraBytes = (F & 31) >> 3;
      for (var D = 0; D < 50; ++D)
        this.s[D] = 0;
    }
    d.prototype.update = function(y) {
      if (this.finalized)
        throw new Error(t);
      var R, F = typeof y;
      if (F !== "string") {
        if (F === "object") {
          if (y === null)
            throw new Error(e);
          if (u && y.constructor === ArrayBuffer)
            y = new Uint8Array(y);
          else if (!Array.isArray(y) && (!u || !ArrayBuffer.isView(y)))
            throw new Error(e);
        } else
          throw new Error(e);
        R = !0;
      }
      for (var D = this.blocks, L = this.byteCount, te = y.length, W = this.blockCount, Q = 0, At = this.s, ne, de; Q < te; ) {
        if (this.reset)
          for (this.reset = !1, D[0] = this.block, ne = 1; ne < W + 1; ++ne)
            D[ne] = 0;
        if (R)
          for (ne = this.start; Q < te && ne < L; ++Q)
            D[ne >> 2] |= y[Q] << x[ne++ & 3];
        else
          for (ne = this.start; Q < te && ne < L; ++Q)
            de = y.charCodeAt(Q), de < 128 ? D[ne >> 2] |= de << x[ne++ & 3] : de < 2048 ? (D[ne >> 2] |= (192 | de >> 6) << x[ne++ & 3], D[ne >> 2] |= (128 | de & 63) << x[ne++ & 3]) : de < 55296 || de >= 57344 ? (D[ne >> 2] |= (224 | de >> 12) << x[ne++ & 3], D[ne >> 2] |= (128 | de >> 6 & 63) << x[ne++ & 3], D[ne >> 2] |= (128 | de & 63) << x[ne++ & 3]) : (de = 65536 + ((de & 1023) << 10 | y.charCodeAt(++Q) & 1023), D[ne >> 2] |= (240 | de >> 18) << x[ne++ & 3], D[ne >> 2] |= (128 | de >> 12 & 63) << x[ne++ & 3], D[ne >> 2] |= (128 | de >> 6 & 63) << x[ne++ & 3], D[ne >> 2] |= (128 | de & 63) << x[ne++ & 3]);
        if (this.lastByteIndex = ne, ne >= L) {
          for (this.start = ne - L, this.block = D[W], ne = 0; ne < W; ++ne)
            At[ne] ^= D[ne];
          P(At), this.reset = !0;
        } else
          this.start = ne;
      }
      return this;
    }, d.prototype.encode = function(y, R) {
      var F = y & 255, D = 1, L = [F];
      for (y = y >> 8, F = y & 255; F > 0; )
        L.unshift(F), y = y >> 8, F = y & 255, ++D;
      return R ? L.push(D) : L.unshift(D), this.update(L), L.length;
    }, d.prototype.encodeString = function(y) {
      var R, F = typeof y;
      if (F !== "string") {
        if (F === "object") {
          if (y === null)
            throw new Error(e);
          if (u && y.constructor === ArrayBuffer)
            y = new Uint8Array(y);
          else if (!Array.isArray(y) && (!u || !ArrayBuffer.isView(y)))
            throw new Error(e);
        } else
          throw new Error(e);
        R = !0;
      }
      var D = 0, L = y.length;
      if (R)
        D = L;
      else
        for (var te = 0; te < y.length; ++te) {
          var W = y.charCodeAt(te);
          W < 128 ? D += 1 : W < 2048 ? D += 2 : W < 55296 || W >= 57344 ? D += 3 : (W = 65536 + ((W & 1023) << 10 | y.charCodeAt(++te) & 1023), D += 4);
        }
      return D += this.encode(D * 8), this.update(y), D;
    }, d.prototype.bytepad = function(y, R) {
      for (var F = this.encode(R), D = 0; D < y.length; ++D)
        F += this.encodeString(y[D]);
      var L = R - F % R, te = [];
      return te.length = L, this.update(te), this;
    }, d.prototype.finalize = function() {
      if (!this.finalized) {
        this.finalized = !0;
        var y = this.blocks, R = this.lastByteIndex, F = this.blockCount, D = this.s;
        if (y[R >> 2] |= this.padding[R & 3], this.lastByteIndex === this.byteCount)
          for (y[0] = y[F], R = 1; R < F + 1; ++R)
            y[R] = 0;
        for (y[F - 1] |= 2147483648, R = 0; R < F; ++R)
          D[R] ^= y[R];
        P(D);
      }
    }, d.prototype.toString = d.prototype.hex = function() {
      this.finalize();
      for (var y = this.blockCount, R = this.s, F = this.outputBlocks, D = this.extraBytes, L = 0, te = 0, W = "", Q; te < F; ) {
        for (L = 0; L < y && te < F; ++L, ++te)
          Q = R[L], W += l[Q >> 4 & 15] + l[Q & 15] + l[Q >> 12 & 15] + l[Q >> 8 & 15] + l[Q >> 20 & 15] + l[Q >> 16 & 15] + l[Q >> 28 & 15] + l[Q >> 24 & 15];
        te % y === 0 && (P(R), L = 0);
      }
      return D && (Q = R[L], W += l[Q >> 4 & 15] + l[Q & 15], D > 1 && (W += l[Q >> 12 & 15] + l[Q >> 8 & 15]), D > 2 && (W += l[Q >> 20 & 15] + l[Q >> 16 & 15])), W;
    }, d.prototype.arrayBuffer = function() {
      this.finalize();
      var y = this.blockCount, R = this.s, F = this.outputBlocks, D = this.extraBytes, L = 0, te = 0, W = this.outputBits >> 3, Q;
      D ? Q = new ArrayBuffer(F + 1 << 2) : Q = new ArrayBuffer(W);
      for (var At = new Uint32Array(Q); te < F; ) {
        for (L = 0; L < y && te < F; ++L, ++te)
          At[te] = R[L];
        te % y === 0 && P(R);
      }
      return D && (At[L] = R[L], Q = Q.slice(0, W)), Q;
    }, d.prototype.buffer = d.prototype.arrayBuffer, d.prototype.digest = d.prototype.array = function() {
      this.finalize();
      for (var y = this.blockCount, R = this.s, F = this.outputBlocks, D = this.extraBytes, L = 0, te = 0, W = [], Q, At; te < F; ) {
        for (L = 0; L < y && te < F; ++L, ++te)
          Q = te << 2, At = R[L], W[Q] = At & 255, W[Q + 1] = At >> 8 & 255, W[Q + 2] = At >> 16 & 255, W[Q + 3] = At >> 24 & 255;
        te % y === 0 && P(R);
      }
      return D && (Q = te << 2, At = R[L], W[Q] = At & 255, D > 1 && (W[Q + 1] = At >> 8 & 255), D > 2 && (W[Q + 2] = At >> 16 & 255)), W;
    };
    function g(y, R, F) {
      d.call(this, y, R, F);
    }
    g.prototype = new d(), g.prototype.finalize = function() {
      return this.encode(this.outputBits, !0), d.prototype.finalize.call(this);
    };
    var P = function(y) {
      var R, F, D, L, te, W, Q, At, ne, de, Ds, je, ze, $s, Ge, qe, Fs, He, Ke, Ls, We, Je, Us, Qe, Ye, Vs, Xe, Ze, js, et, tt, zs, nt, it, Gs, rt, st, qs, at, ot, Hs, ut, lt, Ks, ct, dt, Ws, pt, ft, Js, yt, ht, Qs, mt, bt, Ys, gt, vt, Yr, Xr, Zr, es, ts;
      for (D = 0; D < 48; D += 2)
        L = y[0] ^ y[10] ^ y[20] ^ y[30] ^ y[40], te = y[1] ^ y[11] ^ y[21] ^ y[31] ^ y[41], W = y[2] ^ y[12] ^ y[22] ^ y[32] ^ y[42], Q = y[3] ^ y[13] ^ y[23] ^ y[33] ^ y[43], At = y[4] ^ y[14] ^ y[24] ^ y[34] ^ y[44], ne = y[5] ^ y[15] ^ y[25] ^ y[35] ^ y[45], de = y[6] ^ y[16] ^ y[26] ^ y[36] ^ y[46], Ds = y[7] ^ y[17] ^ y[27] ^ y[37] ^ y[47], je = y[8] ^ y[18] ^ y[28] ^ y[38] ^ y[48], ze = y[9] ^ y[19] ^ y[29] ^ y[39] ^ y[49], R = je ^ (W << 1 | Q >>> 31), F = ze ^ (Q << 1 | W >>> 31), y[0] ^= R, y[1] ^= F, y[10] ^= R, y[11] ^= F, y[20] ^= R, y[21] ^= F, y[30] ^= R, y[31] ^= F, y[40] ^= R, y[41] ^= F, R = L ^ (At << 1 | ne >>> 31), F = te ^ (ne << 1 | At >>> 31), y[2] ^= R, y[3] ^= F, y[12] ^= R, y[13] ^= F, y[22] ^= R, y[23] ^= F, y[32] ^= R, y[33] ^= F, y[42] ^= R, y[43] ^= F, R = W ^ (de << 1 | Ds >>> 31), F = Q ^ (Ds << 1 | de >>> 31), y[4] ^= R, y[5] ^= F, y[14] ^= R, y[15] ^= F, y[24] ^= R, y[25] ^= F, y[34] ^= R, y[35] ^= F, y[44] ^= R, y[45] ^= F, R = At ^ (je << 1 | ze >>> 31), F = ne ^ (ze << 1 | je >>> 31), y[6] ^= R, y[7] ^= F, y[16] ^= R, y[17] ^= F, y[26] ^= R, y[27] ^= F, y[36] ^= R, y[37] ^= F, y[46] ^= R, y[47] ^= F, R = de ^ (L << 1 | te >>> 31), F = Ds ^ (te << 1 | L >>> 31), y[8] ^= R, y[9] ^= F, y[18] ^= R, y[19] ^= F, y[28] ^= R, y[29] ^= F, y[38] ^= R, y[39] ^= F, y[48] ^= R, y[49] ^= F, $s = y[0], Ge = y[1], dt = y[11] << 4 | y[10] >>> 28, Ws = y[10] << 4 | y[11] >>> 28, Ze = y[20] << 3 | y[21] >>> 29, js = y[21] << 3 | y[20] >>> 29, Xr = y[31] << 9 | y[30] >>> 23, Zr = y[30] << 9 | y[31] >>> 23, ut = y[40] << 18 | y[41] >>> 14, lt = y[41] << 18 | y[40] >>> 14, it = y[2] << 1 | y[3] >>> 31, Gs = y[3] << 1 | y[2] >>> 31, qe = y[13] << 12 | y[12] >>> 20, Fs = y[12] << 12 | y[13] >>> 20, pt = y[22] << 10 | y[23] >>> 22, ft = y[23] << 10 | y[22] >>> 22, et = y[33] << 13 | y[32] >>> 19, tt = y[32] << 13 | y[33] >>> 19, es = y[42] << 2 | y[43] >>> 30, ts = y[43] << 2 | y[42] >>> 30, mt = y[5] << 30 | y[4] >>> 2, bt = y[4] << 30 | y[5] >>> 2, rt = y[14] << 6 | y[15] >>> 26, st = y[15] << 6 | y[14] >>> 26, He = y[25] << 11 | y[24] >>> 21, Ke = y[24] << 11 | y[25] >>> 21, Js = y[34] << 15 | y[35] >>> 17, yt = y[35] << 15 | y[34] >>> 17, zs = y[45] << 29 | y[44] >>> 3, nt = y[44] << 29 | y[45] >>> 3, Qe = y[6] << 28 | y[7] >>> 4, Ye = y[7] << 28 | y[6] >>> 4, Ys = y[17] << 23 | y[16] >>> 9, gt = y[16] << 23 | y[17] >>> 9, qs = y[26] << 25 | y[27] >>> 7, at = y[27] << 25 | y[26] >>> 7, Ls = y[36] << 21 | y[37] >>> 11, We = y[37] << 21 | y[36] >>> 11, ht = y[47] << 24 | y[46] >>> 8, Qs = y[46] << 24 | y[47] >>> 8, Ks = y[8] << 27 | y[9] >>> 5, ct = y[9] << 27 | y[8] >>> 5, Vs = y[18] << 20 | y[19] >>> 12, Xe = y[19] << 20 | y[18] >>> 12, vt = y[29] << 7 | y[28] >>> 25, Yr = y[28] << 7 | y[29] >>> 25, ot = y[38] << 8 | y[39] >>> 24, Hs = y[39] << 8 | y[38] >>> 24, Je = y[48] << 14 | y[49] >>> 18, Us = y[49] << 14 | y[48] >>> 18, y[0] = $s ^ ~qe & He, y[1] = Ge ^ ~Fs & Ke, y[10] = Qe ^ ~Vs & Ze, y[11] = Ye ^ ~Xe & js, y[20] = it ^ ~rt & qs, y[21] = Gs ^ ~st & at, y[30] = Ks ^ ~dt & pt, y[31] = ct ^ ~Ws & ft, y[40] = mt ^ ~Ys & vt, y[41] = bt ^ ~gt & Yr, y[2] = qe ^ ~He & Ls, y[3] = Fs ^ ~Ke & We, y[12] = Vs ^ ~Ze & et, y[13] = Xe ^ ~js & tt, y[22] = rt ^ ~qs & ot, y[23] = st ^ ~at & Hs, y[32] = dt ^ ~pt & Js, y[33] = Ws ^ ~ft & yt, y[42] = Ys ^ ~vt & Xr, y[43] = gt ^ ~Yr & Zr, y[4] = He ^ ~Ls & Je, y[5] = Ke ^ ~We & Us, y[14] = Ze ^ ~et & zs, y[15] = js ^ ~tt & nt, y[24] = qs ^ ~ot & ut, y[25] = at ^ ~Hs & lt, y[34] = pt ^ ~Js & ht, y[35] = ft ^ ~yt & Qs, y[44] = vt ^ ~Xr & es, y[45] = Yr ^ ~Zr & ts, y[6] = Ls ^ ~Je & $s, y[7] = We ^ ~Us & Ge, y[16] = et ^ ~zs & Qe, y[17] = tt ^ ~nt & Ye, y[26] = ot ^ ~ut & it, y[27] = Hs ^ ~lt & Gs, y[36] = Js ^ ~ht & Ks, y[37] = yt ^ ~Qs & ct, y[46] = Xr ^ ~es & mt, y[47] = Zr ^ ~ts & bt, y[8] = Je ^ ~$s & qe, y[9] = Us ^ ~Ge & Fs, y[18] = zs ^ ~Qe & Vs, y[19] = nt ^ ~Ye & Xe, y[28] = ut ^ ~it & rt, y[29] = lt ^ ~Gs & st, y[38] = ht ^ ~Ks & dt, y[39] = Qs ^ ~ct & Ws, y[48] = es ^ ~mt & Ys, y[49] = ts ^ ~bt & gt, y[0] ^= w[D], y[1] ^= w[D + 1];
    };
    if (o)
      n.exports = c;
    else
      for (v = 0; v < h.length; ++v)
        r[h[v]] = c[h[v]];
  })();
})(ZS);
const eM = Ay;
function Ie(n) {
  return "0x" + eM.keccak_256(q(n));
}
const tM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256: Ie
}, Symbol.toStringTag, { value: "Module" })), nM = "rlp/5.7.0", Gi = new O(nM);
function v2(n) {
  const e = [];
  for (; n; )
    e.unshift(n & 255), n >>= 8;
  return e;
}
function x2(n, e, t) {
  let i = 0;
  for (let r = 0; r < t; r++)
    i = i * 256 + n[e + r];
  return i;
}
function w6(n) {
  if (Array.isArray(n)) {
    let i = [];
    if (n.forEach(function(s) {
      i = i.concat(w6(s));
    }), i.length <= 55)
      return i.unshift(192 + i.length), i;
    const r = v2(i.length);
    return r.unshift(247 + r.length), r.concat(i);
  }
  Ll(n) || Gi.throwArgumentError("RLP object must be BytesLike", "object", n);
  const e = Array.prototype.slice.call(q(n));
  if (e.length === 1 && e[0] <= 127)
    return e;
  if (e.length <= 55)
    return e.unshift(128 + e.length), e;
  const t = v2(e.length);
  return t.unshift(183 + t.length), t.concat(e);
}
function Ms(n) {
  return H(w6(n));
}
function T2(n, e, t, i) {
  const r = [];
  for (; t < e + 1 + i; ) {
    const s = A6(n, t);
    r.push(s.result), t += s.consumed, t > e + 1 + i && Gi.throwError("child data too short", O.errors.BUFFER_OVERRUN, {});
  }
  return { consumed: 1 + i, result: r };
}
function A6(n, e) {
  if (n.length === 0 && Gi.throwError("data too short", O.errors.BUFFER_OVERRUN, {}), n[e] >= 248) {
    const t = n[e] - 247;
    e + 1 + t > n.length && Gi.throwError("data short segment too short", O.errors.BUFFER_OVERRUN, {});
    const i = x2(n, e + 1, t);
    return e + 1 + t + i > n.length && Gi.throwError("data long segment too short", O.errors.BUFFER_OVERRUN, {}), T2(n, e, e + 1 + t, t + i);
  } else if (n[e] >= 192) {
    const t = n[e] - 192;
    return e + 1 + t > n.length && Gi.throwError("data array too short", O.errors.BUFFER_OVERRUN, {}), T2(n, e, e + 1, t);
  } else if (n[e] >= 184) {
    const t = n[e] - 183;
    e + 1 + t > n.length && Gi.throwError("data array too short", O.errors.BUFFER_OVERRUN, {});
    const i = x2(n, e + 1, t);
    e + 1 + t + i > n.length && Gi.throwError("data array too short", O.errors.BUFFER_OVERRUN, {});
    const r = H(n.slice(e + 1 + t, e + 1 + t + i));
    return { consumed: 1 + t + i, result: r };
  } else if (n[e] >= 128) {
    const t = n[e] - 128;
    e + 1 + t > n.length && Gi.throwError("data too short", O.errors.BUFFER_OVERRUN, {});
    const i = H(n.slice(e + 1, e + 1 + t));
    return { consumed: 1 + t, result: i };
  }
  return { consumed: 1, result: H(n[e]) };
}
function Vl(n) {
  const e = q(n), t = A6(e, 0);
  return t.consumed !== e.length && Gi.throwArgumentError("invalid rlp data", "data", n), t.result;
}
const iM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Vl,
  encode: Ms
}, Symbol.toStringTag, { value: "Module" })), rM = "address/5.7.0", ys = new O(rM);
function w2(n) {
  Ae(n, 20) || ys.throwArgumentError("invalid address", "address", n), n = n.toLowerCase();
  const e = n.substring(2).split(""), t = new Uint8Array(40);
  for (let r = 0; r < 40; r++)
    t[r] = e[r].charCodeAt(0);
  const i = q(Ie(t));
  for (let r = 0; r < 40; r += 2)
    i[r >> 1] >> 4 >= 8 && (e[r] = e[r].toUpperCase()), (i[r >> 1] & 15) >= 8 && (e[r + 1] = e[r + 1].toUpperCase());
  return "0x" + e.join("");
}
const sM = 9007199254740991;
function aM(n) {
  return Math.log10 ? Math.log10(n) : Math.log(n) / Math.LN10;
}
const a0 = {};
for (let n = 0; n < 10; n++)
  a0[String(n)] = String(n);
for (let n = 0; n < 26; n++)
  a0[String.fromCharCode(65 + n)] = String(10 + n);
const A2 = Math.floor(aM(sM));
function E6(n) {
  n = n.toUpperCase(), n = n.substring(4) + n.substring(0, 2) + "00";
  let e = n.split("").map((i) => a0[i]).join("");
  for (; e.length >= A2; ) {
    let i = e.substring(0, A2);
    e = parseInt(i, 10) % 97 + e.substring(i.length);
  }
  let t = String(98 - parseInt(e, 10) % 97);
  for (; t.length < 2; )
    t = "0" + t;
  return t;
}
function Be(n) {
  let e = null;
  if (typeof n != "string" && ys.throwArgumentError("invalid address", "address", n), n.match(/^(0x)?[0-9a-fA-F]{40}$/))
    n.substring(0, 2) !== "0x" && (n = "0x" + n), e = w2(n), n.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== n && ys.throwArgumentError("bad address checksum", "address", n);
  else if (n.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    for (n.substring(2, 4) !== E6(n) && ys.throwArgumentError("bad icap checksum", "address", n), e = fS(n.substring(4)); e.length < 40; )
      e = "0" + e;
    e = w2("0x" + e);
  } else
    ys.throwArgumentError("invalid address", "address", n);
  return e;
}
function oM(n) {
  try {
    return Be(n), !0;
  } catch {
  }
  return !1;
}
function uM(n) {
  let e = yS(Be(n).substring(2)).toUpperCase();
  for (; e.length < 30; )
    e = "0" + e;
  return "XE" + E6("XE00" + e) + e;
}
function o0(n) {
  let e = null;
  try {
    e = Be(n.from);
  } catch {
    ys.throwArgumentError("missing from address", "transaction", n);
  }
  const t = Zi(q(z.from(n.nonce).toHexString()));
  return Be(Bt(Ie(Ms([e, t])), 12));
}
function lM(n, e, t) {
  return rr(e) !== 32 && ys.throwArgumentError("salt must be 32 bytes", "salt", e), rr(t) !== 32 && ys.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", t), Be(Bt(Ie(Ve(["0xff", Be(n), e, t])), 12));
}
const cM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getAddress: Be,
  getContractAddress: o0,
  getCreate2Address: lM,
  getIcapAddress: uM,
  isAddress: oM
}, Symbol.toStringTag, { value: "Module" }));
class dM extends Jr {
  constructor(e) {
    super("address", "address", e, !1);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(e, t) {
    try {
      t = Be(t);
    } catch (i) {
      this._throwError(i.message, t);
    }
    return e.writeValue(t);
  }
  decode(e) {
    return Be(De(e.readValue().toHexString(), 20));
  }
}
class pM extends Jr {
  constructor(e) {
    super(e.name, e.type, void 0, e.dynamic), this.coder = e;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(e, t) {
    return this.coder.encode(e, t);
  }
  decode(e) {
    return this.coder.decode(e);
  }
}
const oo = new O(Ul);
function S6(n, e, t) {
  let i = null;
  if (Array.isArray(t))
    i = t;
  else if (t && typeof t == "object") {
    let u = {};
    i = e.map((l) => {
      const p = l.localName;
      return p || oo.throwError("cannot encode object for signature with missing names", O.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: l,
        value: t
      }), u[p] && oo.throwError("cannot encode object for signature with duplicate names", O.errors.INVALID_ARGUMENT, {
        argument: "values",
        coder: l,
        value: t
      }), u[p] = !0, t[p];
    });
  } else
    oo.throwArgumentError("invalid tuple value", "tuple", t);
  e.length !== i.length && oo.throwArgumentError("types/value length mismatch", "tuple", t);
  let r = new wy(n.wordSize), s = new wy(n.wordSize), a = [];
  e.forEach((u, l) => {
    let p = i[l];
    if (u.dynamic) {
      let f = s.length;
      u.encode(s, p);
      let b = r.writeUpdatableValue();
      a.push((A) => {
        b(A + f);
      });
    } else
      u.encode(r, p);
  }), a.forEach((u) => {
    u(r.length);
  });
  let o = n.appendWriter(r);
  return o += n.appendWriter(s), o;
}
function M6(n, e) {
  let t = [], i = n.subReader(0);
  e.forEach((s) => {
    let a = null;
    if (s.dynamic) {
      let o = n.readValue(), u = i.subReader(o.toNumber());
      try {
        a = s.decode(u);
      } catch (l) {
        if (l.code === O.errors.BUFFER_OVERRUN)
          throw l;
        a = l, a.baseType = s.name, a.name = s.localName, a.type = s.type;
      }
    } else
      try {
        a = s.decode(n);
      } catch (o) {
        if (o.code === O.errors.BUFFER_OVERRUN)
          throw o;
        a = o, a.baseType = s.name, a.name = s.localName, a.type = s.type;
      }
    a != null && t.push(a);
  });
  const r = e.reduce((s, a) => {
    const o = a.localName;
    return o && (s[o] || (s[o] = 0), s[o]++), s;
  }, {});
  e.forEach((s, a) => {
    let o = s.localName;
    if (!o || r[o] !== 1 || (o === "length" && (o = "_length"), t[o] != null))
      return;
    const u = t[a];
    u instanceof Error ? Object.defineProperty(t, o, {
      enumerable: !0,
      get: () => {
        throw u;
      }
    }) : t[o] = u;
  });
  for (let s = 0; s < t.length; s++) {
    const a = t[s];
    a instanceof Error && Object.defineProperty(t, s, {
      enumerable: !0,
      get: () => {
        throw a;
      }
    });
  }
  return Object.freeze(t);
}
class fM extends Jr {
  constructor(e, t, i) {
    const r = e.type + "[" + (t >= 0 ? t : "") + "]", s = t === -1 || e.dynamic;
    super("array", r, i, s), this.coder = e, this.length = t;
  }
  defaultValue() {
    const e = this.coder.defaultValue(), t = [];
    for (let i = 0; i < this.length; i++)
      t.push(e);
    return t;
  }
  encode(e, t) {
    Array.isArray(t) || this._throwError("expected array value", t);
    let i = this.length;
    i === -1 && (i = t.length, e.writeValue(t.length)), oo.checkArgumentCount(t.length, i, "coder array" + (this.localName ? " " + this.localName : ""));
    let r = [];
    for (let s = 0; s < t.length; s++)
      r.push(this.coder);
    return S6(e, r, t);
  }
  decode(e) {
    let t = this.length;
    t === -1 && (t = e.readValue().toNumber(), t * 32 > e._data.length && oo.throwError("insufficient data length", O.errors.BUFFER_OVERRUN, {
      length: e._data.length,
      count: t
    }));
    let i = [];
    for (let r = 0; r < t; r++)
      i.push(new pM(this.coder));
    return e.coerce(this.name, M6(e, i));
  }
}
class yM extends Jr {
  constructor(e) {
    super("bool", "bool", e, !1);
  }
  defaultValue() {
    return !1;
  }
  encode(e, t) {
    return e.writeValue(t ? 1 : 0);
  }
  decode(e) {
    return e.coerce(this.type, !e.readValue().isZero());
  }
}
class C6 extends Jr {
  constructor(e, t) {
    super(e, e, t, !0);
  }
  defaultValue() {
    return "0x";
  }
  encode(e, t) {
    t = q(t);
    let i = e.writeValue(t.length);
    return i += e.writeBytes(t), i;
  }
  decode(e) {
    return e.readBytes(e.readValue().toNumber(), !0);
  }
}
class hM extends C6 {
  constructor(e) {
    super("bytes", e);
  }
  decode(e) {
    return e.coerce(this.name, H(super.decode(e)));
  }
}
class mM extends Jr {
  constructor(e, t) {
    let i = "bytes" + String(e);
    super(i, i, t, !1), this.size = e;
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(e, t) {
    let i = q(t);
    return i.length !== this.size && this._throwError("incorrect data length", t), e.writeBytes(i);
  }
  decode(e) {
    return e.coerce(this.name, H(e.readBytes(this.size)));
  }
}
class bM extends Jr {
  constructor(e) {
    super("null", "", e, !1);
  }
  defaultValue() {
    return null;
  }
  encode(e, t) {
    return t != null && this._throwError("not null", t), e.writeBytes([]);
  }
  decode(e) {
    return e.readBytes(0), e.coerce(this.name, null);
  }
}
const gM = "0x0000000000000000000000000000000000000000", vM = /* @__PURE__ */ z.from(-1), u0 = /* @__PURE__ */ z.from(0), xM = /* @__PURE__ */ z.from(1), TM = /* @__PURE__ */ z.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), _6 = "0x0000000000000000000000000000000000000000000000000000000000000000";
class wM extends Jr {
  constructor(e, t, i) {
    const r = (t ? "int" : "uint") + e * 8;
    super(r, r, i, !1), this.size = e, this.signed = t;
  }
  defaultValue() {
    return 0;
  }
  encode(e, t) {
    let i = z.from(t), r = TM.mask(e.wordSize * 8);
    if (this.signed) {
      let s = r.mask(this.size * 8 - 1);
      (i.gt(s) || i.lt(s.add(xM).mul(vM))) && this._throwError("value out-of-bounds", t);
    } else
      (i.lt(u0) || i.gt(r.mask(this.size * 8))) && this._throwError("value out-of-bounds", t);
    return i = i.toTwos(this.size * 8).mask(this.size * 8), this.signed && (i = i.fromTwos(this.size * 8).toTwos(8 * e.wordSize)), e.writeValue(i);
  }
  decode(e) {
    let t = e.readValue().mask(this.size * 8);
    return this.signed && (t = t.fromTwos(this.size * 8)), e.coerce(this.name, t);
  }
}
const AM = "strings/5.7.0", R6 = new O(AM);
var sr;
(function(n) {
  n.current = "", n.NFC = "NFC", n.NFD = "NFD", n.NFKC = "NFKC", n.NFKD = "NFKD";
})(sr || (sr = {}));
var Fn;
(function(n) {
  n.UNEXPECTED_CONTINUE = "unexpected continuation byte", n.BAD_PREFIX = "bad codepoint prefix", n.OVERRUN = "string overrun", n.MISSING_CONTINUE = "missing continuation byte", n.OUT_OF_RANGE = "out of UTF-8 range", n.UTF16_SURROGATE = "UTF-16 surrogate", n.OVERLONG = "overlong representation";
})(Fn || (Fn = {}));
function EM(n, e, t, i, r) {
  return R6.throwArgumentError(`invalid codepoint at offset ${e}; ${n}`, "bytes", t);
}
function k6(n, e, t, i, r) {
  if (n === Fn.BAD_PREFIX || n === Fn.UNEXPECTED_CONTINUE) {
    let s = 0;
    for (let a = e + 1; a < t.length && t[a] >> 6 === 2; a++)
      s++;
    return s;
  }
  return n === Fn.OVERRUN ? t.length - e - 1 : 0;
}
function SM(n, e, t, i, r) {
  return n === Fn.OVERLONG ? (i.push(r), 0) : (i.push(65533), k6(n, e, t));
}
const P6 = Object.freeze({
  error: EM,
  ignore: k6,
  replace: SM
});
function l0(n, e) {
  e == null && (e = P6.error), n = q(n);
  const t = [];
  let i = 0;
  for (; i < n.length; ) {
    const r = n[i++];
    if (!(r >> 7)) {
      t.push(r);
      continue;
    }
    let s = null, a = null;
    if ((r & 224) === 192)
      s = 1, a = 127;
    else if ((r & 240) === 224)
      s = 2, a = 2047;
    else if ((r & 248) === 240)
      s = 3, a = 65535;
    else {
      (r & 192) === 128 ? i += e(Fn.UNEXPECTED_CONTINUE, i - 1, n, t) : i += e(Fn.BAD_PREFIX, i - 1, n, t);
      continue;
    }
    if (i - 1 + s >= n.length) {
      i += e(Fn.OVERRUN, i - 1, n, t);
      continue;
    }
    let o = r & (1 << 8 - s - 1) - 1;
    for (let u = 0; u < s; u++) {
      let l = n[i];
      if ((l & 192) != 128) {
        i += e(Fn.MISSING_CONTINUE, i, n, t), o = null;
        break;
      }
      o = o << 6 | l & 63, i++;
    }
    if (o !== null) {
      if (o > 1114111) {
        i += e(Fn.OUT_OF_RANGE, i - 1 - s, n, t, o);
        continue;
      }
      if (o >= 55296 && o <= 57343) {
        i += e(Fn.UTF16_SURROGATE, i - 1 - s, n, t, o);
        continue;
      }
      if (o <= a) {
        i += e(Fn.OVERLONG, i - 1 - s, n, t, o);
        continue;
      }
      t.push(o);
    }
  }
  return t;
}
function Dt(n, e = sr.current) {
  e != sr.current && (R6.checkNormalize(), n = n.normalize(e));
  let t = [];
  for (let i = 0; i < n.length; i++) {
    const r = n.charCodeAt(i);
    if (r < 128)
      t.push(r);
    else if (r < 2048)
      t.push(r >> 6 | 192), t.push(r & 63 | 128);
    else if ((r & 64512) == 55296) {
      i++;
      const s = n.charCodeAt(i);
      if (i >= n.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const a = 65536 + ((r & 1023) << 10) + (s & 1023);
      t.push(a >> 18 | 240), t.push(a >> 12 & 63 | 128), t.push(a >> 6 & 63 | 128), t.push(a & 63 | 128);
    } else
      t.push(r >> 12 | 224), t.push(r >> 6 & 63 | 128), t.push(r & 63 | 128);
  }
  return q(t);
}
function xf(n) {
  const e = "0000" + n.toString(16);
  return "\\u" + e.substring(e.length - 4);
}
function MM(n, e) {
  return '"' + l0(n, e).map((t) => {
    if (t < 256) {
      switch (t) {
        case 8:
          return "\\b";
        case 9:
          return "\\t";
        case 10:
          return "\\n";
        case 13:
          return "\\r";
        case 34:
          return '\\"';
        case 92:
          return "\\\\";
      }
      if (t >= 32 && t < 127)
        return String.fromCharCode(t);
    }
    return t <= 65535 ? xf(t) : (t -= 65536, xf((t >> 10 & 1023) + 55296) + xf((t & 1023) + 56320));
  }).join("") + '"';
}
function Ey(n) {
  return n.map((e) => e <= 65535 ? String.fromCharCode(e) : (e -= 65536, String.fromCharCode((e >> 10 & 1023) + 55296, (e & 1023) + 56320))).join("");
}
function Is(n, e) {
  return Ey(l0(n, e));
}
function cd(n, e = sr.current) {
  return l0(Dt(n, e));
}
function CM(n) {
  const e = Dt(n);
  if (e.length > 31)
    throw new Error("bytes32 string must be less than 32 bytes");
  return H(Ve([e, _6]).slice(0, 32));
}
function _M(n) {
  const e = q(n);
  if (e.length !== 32)
    throw new Error("invalid bytes32 - not 32 bytes long");
  if (e[31] !== 0)
    throw new Error("invalid bytes32 string - no null terminator");
  let t = 31;
  for (; e[t - 1] === 0; )
    t--;
  return Is(e.slice(0, t));
}
function RM(n) {
  if (n.length % 4 !== 0)
    throw new Error("bad data");
  let e = [];
  for (let t = 0; t < n.length; t += 4)
    e.push(parseInt(n.substring(t, t + 4), 16));
  return e;
}
function c0(n, e) {
  e || (e = function(r) {
    return [parseInt(r, 16)];
  });
  let t = 0, i = {};
  return n.split(",").forEach((r) => {
    let s = r.split(":");
    t += parseInt(s[0], 16), i[t] = e(s[1]);
  }), i;
}
function I6(n) {
  let e = 0;
  return n.split(",").map((t) => {
    let i = t.split("-");
    i.length === 1 ? i[1] = "0" : i[1] === "" && (i[1] = "1");
    let r = e + parseInt(i[0], 16);
    return e = parseInt(i[1], 16), { l: r, h: e };
  });
}
function d0(n, e) {
  let t = 0;
  for (let i = 0; i < e.length; i++) {
    let r = e[i];
    if (t += r.l, n >= t && n <= t + r.h && (n - t) % (r.d || 1) === 0) {
      if (r.e && r.e.indexOf(n - t) !== -1)
        continue;
      return r;
    }
  }
  return null;
}
const kM = I6("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"), PM = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((n) => parseInt(n, 16)), IM = [
  { h: 25, s: 32, l: 65 },
  { h: 30, s: 32, e: [23], l: 127 },
  { h: 54, s: 1, e: [48], l: 64, d: 2 },
  { h: 14, s: 1, l: 57, d: 2 },
  { h: 44, s: 1, l: 17, d: 2 },
  { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
  { h: 16, s: 1, l: 68, d: 2 },
  { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
  { h: 26, s: 32, e: [17], l: 435 },
  { h: 22, s: 1, l: 71, d: 2 },
  { h: 15, s: 80, l: 40 },
  { h: 31, s: 32, l: 16 },
  { h: 32, s: 1, l: 80, d: 2 },
  { h: 52, s: 1, l: 42, d: 2 },
  { h: 12, s: 1, l: 55, d: 2 },
  { h: 40, s: 1, e: [38], l: 15, d: 2 },
  { h: 14, s: 1, l: 48, d: 2 },
  { h: 37, s: 48, l: 49 },
  { h: 148, s: 1, l: 6351, d: 2 },
  { h: 88, s: 1, l: 160, d: 2 },
  { h: 15, s: 16, l: 704 },
  { h: 25, s: 26, l: 854 },
  { h: 25, s: 32, l: 55915 },
  { h: 37, s: 40, l: 1247 },
  { h: 25, s: -119711, l: 53248 },
  { h: 25, s: -119763, l: 52 },
  { h: 25, s: -119815, l: 52 },
  { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
  { h: 25, s: -119919, l: 52 },
  { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
  { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
  { h: 25, s: -120075, l: 52 },
  { h: 25, s: -120127, l: 52 },
  { h: 25, s: -120179, l: 52 },
  { h: 25, s: -120231, l: 52 },
  { h: 25, s: -120283, l: 52 },
  { h: 25, s: -120335, l: 52 },
  { h: 24, s: -119543, e: [17], l: 56 },
  { h: 24, s: -119601, e: [17], l: 58 },
  { h: 24, s: -119659, e: [17], l: 58 },
  { h: 24, s: -119717, e: [17], l: 58 },
  { h: 24, s: -119775, e: [17], l: 58 }
], OM = c0("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"), BM = c0("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"), NM = c0("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", RM), DM = I6("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function $M(n) {
  return n.reduce((e, t) => (t.forEach((i) => {
    e.push(i);
  }), e), []);
}
function FM(n) {
  return !!d0(n, kM);
}
function LM(n) {
  let e = d0(n, IM);
  if (e)
    return [n + e.s];
  let t = OM[n];
  if (t)
    return t;
  let i = BM[n];
  if (i)
    return [n + i[0]];
  let r = NM[n];
  return r || null;
}
function UM(n) {
  return !!d0(n, DM);
}
function VM(n) {
  if (n.match(/^[a-z0-9-]*$/i) && n.length <= 59)
    return n.toLowerCase();
  let e = cd(n);
  e = $M(e.map((i) => {
    if (PM.indexOf(i) >= 0)
      return [];
    if (i >= 65024 && i <= 65039)
      return [];
    let r = LM(i);
    return r || [i];
  })), e = cd(Ey(e), sr.NFKC), e.forEach((i) => {
    if (UM(i))
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
  }), e.forEach((i) => {
    if (FM(i))
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
  });
  let t = Ey(e);
  if (t.substring(0, 1) === "-" || t.substring(2, 4) === "--" || t.substring(t.length - 1) === "-")
    throw new Error("invalid hyphen");
  return t;
}
const jM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get UnicodeNormalizationForm() {
    return sr;
  },
  Utf8ErrorFuncs: P6,
  get Utf8ErrorReason() {
    return Fn;
  },
  _toEscapedUtf8String: MM,
  formatBytes32String: CM,
  nameprep: VM,
  parseBytes32String: _M,
  toUtf8Bytes: Dt,
  toUtf8CodePoints: cd,
  toUtf8String: Is
}, Symbol.toStringTag, { value: "Module" }));
class zM extends C6 {
  constructor(e) {
    super("string", e);
  }
  defaultValue() {
    return "";
  }
  encode(e, t) {
    return super.encode(e, Dt(t));
  }
  decode(e) {
    return Is(super.decode(e));
  }
}
class cc extends Jr {
  constructor(e, t) {
    let i = !1;
    const r = [];
    e.forEach((a) => {
      a.dynamic && (i = !0), r.push(a.type);
    });
    const s = "tuple(" + r.join(",") + ")";
    super("tuple", s, t, i), this.coders = e;
  }
  defaultValue() {
    const e = [];
    this.coders.forEach((i) => {
      e.push(i.defaultValue());
    });
    const t = this.coders.reduce((i, r) => {
      const s = r.localName;
      return s && (i[s] || (i[s] = 0), i[s]++), i;
    }, {});
    return this.coders.forEach((i, r) => {
      let s = i.localName;
      !s || t[s] !== 1 || (s === "length" && (s = "_length"), e[s] == null && (e[s] = e[r]));
    }), Object.freeze(e);
  }
  encode(e, t) {
    return S6(e, this.coders, t);
  }
  decode(e) {
    return e.coerce(this.name, M6(e, this.coders));
  }
}
const dc = new O(Ul), GM = new RegExp(/^bytes([0-9]*)$/), qM = new RegExp(/^(u?int)([0-9]*)$/);
class O6 {
  constructor(e) {
    U(this, "coerceFunc", e || null);
  }
  _getCoder(e) {
    switch (e.baseType) {
      case "address":
        return new dM(e.name);
      case "bool":
        return new yM(e.name);
      case "string":
        return new zM(e.name);
      case "bytes":
        return new hM(e.name);
      case "array":
        return new fM(this._getCoder(e.arrayChildren), e.arrayLength, e.name);
      case "tuple":
        return new cc((e.components || []).map((i) => this._getCoder(i)), e.name);
      case "":
        return new bM(e.name);
    }
    let t = e.type.match(qM);
    if (t) {
      let i = parseInt(t[2] || "256");
      return (i === 0 || i > 256 || i % 8 !== 0) && dc.throwArgumentError("invalid " + t[1] + " bit length", "param", e), new wM(i / 8, t[1] === "int", e.name);
    }
    if (t = e.type.match(GM), t) {
      let i = parseInt(t[1]);
      return (i === 0 || i > 32) && dc.throwArgumentError("invalid bytes length", "param", e), new mM(i, e.name);
    }
    return dc.throwArgumentError("invalid type", "type", e.type);
  }
  _getWordSize() {
    return 32;
  }
  _getReader(e, t) {
    return new ld(e, this._getWordSize(), this.coerceFunc, t);
  }
  _getWriter() {
    return new wy(this._getWordSize());
  }
  getDefaultValue(e) {
    const t = e.map((r) => this._getCoder(qt.from(r)));
    return new cc(t, "_").defaultValue();
  }
  encode(e, t) {
    e.length !== t.length && dc.throwError("types/values length mismatch", O.errors.INVALID_ARGUMENT, {
      count: { types: e.length, values: t.length },
      value: { types: e, values: t }
    });
    const i = e.map((a) => this._getCoder(qt.from(a))), r = new cc(i, "_"), s = this._getWriter();
    return r.encode(s, t), s.data;
  }
  decode(e, t, i) {
    const r = e.map((a) => this._getCoder(qt.from(a)));
    return new cc(r, "_").decode(this._getReader(q(t), i));
  }
}
const B6 = new O6();
function hs(n) {
  return Ie(Dt(n));
}
const N6 = "hash/5.7.0";
function p0(n) {
  n = atob(n);
  const e = [];
  for (let t = 0; t < n.length; t++)
    e.push(n.charCodeAt(t));
  return q(e);
}
function f0(n) {
  n = q(n);
  let e = "";
  for (let t = 0; t < n.length; t++)
    e += String.fromCharCode(n[t]);
  return btoa(e);
}
const HM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: p0,
  encode: f0
}, Symbol.toStringTag, { value: "Module" }));
function D6(n, e) {
  e == null && (e = 1);
  const t = [], i = t.forEach, r = function(s, a) {
    i.call(s, function(o) {
      a > 0 && Array.isArray(o) ? r(o, a - 1) : t.push(o);
    });
  };
  return r(n, e), t;
}
function KM(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = n[t];
    e[i[0]] = i[1];
  }
  return e;
}
function WM(n) {
  let e = 0;
  function t() {
    return n[e++] << 8 | n[e++];
  }
  let i = t(), r = 1, s = [0, 1];
  for (let B = 1; B < i; B++)
    s.push(r += t());
  let a = t(), o = e;
  e += a;
  let u = 0, l = 0;
  function p() {
    return u == 0 && (l = l << 8 | n[e++], u = 8), l >> --u & 1;
  }
  const f = 31, b = Math.pow(2, f), A = b >>> 1, x = A >> 1, w = b - 1;
  let T = 0;
  for (let B = 0; B < f; B++)
    T = T << 1 | p();
  let _ = [], I = 0, $ = b;
  for (; ; ) {
    let B = Math.floor(((T - I + 1) * r - 1) / $), V = 0, K = i;
    for (; K - V > 1; ) {
      let oe = V + K >>> 1;
      B < s[oe] ? K = oe : V = oe;
    }
    if (V == 0)
      break;
    _.push(V);
    let G = I + Math.floor($ * s[V] / r), Y = I + Math.floor($ * s[V + 1] / r) - 1;
    for (; !((G ^ Y) & A); )
      T = T << 1 & w | p(), G = G << 1 & w, Y = Y << 1 & w | 1;
    for (; G & ~Y & x; )
      T = T & A | T << 1 & w >>> 1 | p(), G = G << 1 ^ A, Y = (Y ^ A) << 1 | A | 1;
    I = G, $ = 1 + Y - G;
  }
  let N = i - 4;
  return _.map((B) => {
    switch (B - N) {
      case 3:
        return N + 65792 + (n[o++] << 16 | n[o++] << 8 | n[o++]);
      case 2:
        return N + 256 + (n[o++] << 8 | n[o++]);
      case 1:
        return N + n[o++];
      default:
        return B - 1;
    }
  });
}
function JM(n) {
  let e = 0;
  return () => n[e++];
}
function QM(n) {
  return JM(WM(n));
}
function YM(n) {
  return n & 1 ? ~n >> 1 : n >> 1;
}
function XM(n, e) {
  let t = Array(n);
  for (let i = 0; i < n; i++)
    t[i] = 1 + e();
  return t;
}
function E2(n, e) {
  let t = Array(n);
  for (let i = 0, r = -1; i < n; i++)
    t[i] = r += 1 + e();
  return t;
}
function ZM(n, e) {
  let t = Array(n);
  for (let i = 0, r = 0; i < n; i++)
    t[i] = r += YM(e());
  return t;
}
function dd(n, e) {
  let t = E2(n(), n), i = n(), r = E2(i, n), s = XM(i, n);
  for (let a = 0; a < i; a++)
    for (let o = 0; o < s[a]; o++)
      t.push(r[a] + o);
  return e ? t.map((a) => e[a]) : t;
}
function eC(n) {
  let e = [];
  for (; ; ) {
    let t = n();
    if (t == 0)
      break;
    e.push(nC(t, n));
  }
  for (; ; ) {
    let t = n() - 1;
    if (t < 0)
      break;
    e.push(iC(t, n));
  }
  return KM(D6(e));
}
function tC(n) {
  let e = [];
  for (; ; ) {
    let t = n();
    if (t == 0)
      break;
    e.push(t);
  }
  return e;
}
function $6(n, e, t) {
  let i = Array(n).fill(void 0).map(() => []);
  for (let r = 0; r < e; r++)
    ZM(n, t).forEach((s, a) => i[a].push(s));
  return i;
}
function nC(n, e) {
  let t = 1 + e(), i = e(), r = tC(e), s = $6(r.length, 1 + n, e);
  return D6(s.map((a, o) => {
    const u = a[0], l = a.slice(1);
    return Array(r[o]).fill(void 0).map((p, f) => {
      let b = f * i;
      return [u + f * t, l.map((A) => A + b)];
    });
  }));
}
function iC(n, e) {
  let t = 1 + e();
  return $6(t, 1 + n, e).map((r) => [r[0], r.slice(1)]);
}
function rC(n) {
  let e = dd(n).sort((i, r) => i - r);
  return t();
  function t() {
    let i = [];
    for (; ; ) {
      let l = dd(n, e);
      if (l.length == 0)
        break;
      i.push({ set: new Set(l), node: t() });
    }
    i.sort((l, p) => p.set.size - l.set.size);
    let r = n(), s = r % 3;
    r = r / 3 | 0;
    let a = !!(r & 1);
    r >>= 1;
    let o = r == 1, u = r == 2;
    return { branches: i, valid: s, fe0f: a, save: o, check: u };
  }
}
function sC() {
  return QM(p0("AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=="));
}
const sp = sC(), aC = new Set(dd(sp)), oC = new Set(dd(sp)), uC = eC(sp), lC = rC(sp), S2 = 45, M2 = 95;
function F6(n) {
  return cd(n);
}
function cC(n) {
  return n.filter((e) => e != 65039);
}
function L6(n) {
  for (let e of n.split(".")) {
    let t = F6(e);
    try {
      for (let i = t.lastIndexOf(M2) - 1; i >= 0; i--)
        if (t[i] !== M2)
          throw new Error("underscore only allowed at start");
      if (t.length >= 4 && t.every((i) => i < 128) && t[2] === S2 && t[3] === S2)
        throw new Error("invalid label extension");
    } catch (i) {
      throw new Error(`Invalid label "${e}": ${i.message}`);
    }
  }
  return n;
}
function dC(n) {
  return L6(pC(n, cC));
}
function pC(n, e) {
  let t = F6(n).reverse(), i = [];
  for (; t.length; ) {
    let r = yC(t);
    if (r) {
      i.push(...e(r));
      continue;
    }
    let s = t.pop();
    if (aC.has(s)) {
      i.push(s);
      continue;
    }
    if (oC.has(s))
      continue;
    let a = uC[s];
    if (a) {
      i.push(...a);
      continue;
    }
    throw new Error(`Disallowed codepoint: 0x${s.toString(16).toUpperCase()}`);
  }
  return L6(fC(String.fromCodePoint(...i)));
}
function fC(n) {
  return n.normalize("NFC");
}
function yC(n, e) {
  var t;
  let i = lC, r, s, a = [], o = n.length;
  for (e && (e.length = 0); o; ) {
    let u = n[--o];
    if (i = (t = i.branches.find((l) => l.set.has(u))) === null || t === void 0 ? void 0 : t.node, !i)
      break;
    if (i.save)
      s = u;
    else if (i.check && u === s)
      break;
    a.push(u), i.fe0f && (a.push(65039), o > 0 && n[o - 1] == 65039 && o--), i.valid && (r = a.slice(), i.valid == 2 && r.splice(1, 1), e && e.push(...n.slice(o).reverse()), n.length = o);
  }
  return r;
}
const hC = new O(N6), U6 = new Uint8Array(32);
U6.fill(0);
function C2(n) {
  if (n.length === 0)
    throw new Error("invalid ENS name; empty component");
  return n;
}
function ap(n) {
  const e = Dt(dC(n)), t = [];
  if (n.length === 0)
    return t;
  let i = 0;
  for (let r = 0; r < e.length; r++)
    e[r] === 46 && (t.push(C2(e.slice(i, r))), i = r + 1);
  if (i >= e.length)
    throw new Error("invalid ENS name; empty component");
  return t.push(C2(e.slice(i))), t;
}
function mC(n) {
  return ap(n).map((e) => Is(e)).join(".");
}
function bC(n) {
  try {
    return ap(n).length !== 0;
  } catch {
  }
  return !1;
}
function Ou(n) {
  typeof n != "string" && hC.throwArgumentError("invalid ENS name; not a string", "name", n);
  let e = U6;
  const t = ap(n);
  for (; t.length; )
    e = Ie(Ve([e, Ie(t.pop())]));
  return H(e);
}
function V6(n) {
  return H(Ve(ap(n).map((e) => {
    if (e.length > 63)
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    const t = new Uint8Array(e.length + 1);
    return t.set(e, 1), t[0] = t.length - 1, t;
  }))) + "00";
}
const j6 = `Ethereum Signed Message:
`;
function y0(n) {
  return typeof n == "string" && (n = Dt(n)), Ie(Ve([
    Dt(j6),
    Dt(String(n.length)),
    n
  ]));
}
var gC = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
const St = new O(N6), z6 = new Uint8Array(32);
z6.fill(0);
const vC = z.from(-1), G6 = z.from(0), q6 = z.from(1), xC = z.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function TC(n) {
  const e = q(n), t = e.length % 32;
  return t ? Cn([e, z6.slice(t)]) : H(e);
}
const wC = De(q6.toHexString(), 32), AC = De(G6.toHexString(), 32), _2 = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
}, Tf = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
function R2(n) {
  return function(e) {
    return typeof e != "string" && St.throwArgumentError(`invalid domain value for ${JSON.stringify(n)}`, `domain.${n}`, e), e;
  };
}
const EC = {
  name: R2("name"),
  version: R2("version"),
  chainId: function(n) {
    try {
      return z.from(n).toString();
    } catch {
    }
    return St.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", n);
  },
  verifyingContract: function(n) {
    try {
      return Be(n).toLowerCase();
    } catch {
    }
    return St.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", n);
  },
  salt: function(n) {
    try {
      const e = q(n);
      if (e.length !== 32)
        throw new Error("bad length");
      return H(e);
    } catch {
    }
    return St.throwArgumentError('invalid domain value "salt"', "domain.salt", n);
  }
};
function wf(n) {
  {
    const e = n.match(/^(u?)int(\d*)$/);
    if (e) {
      const t = e[1] === "", i = parseInt(e[2] || "256");
      (i % 8 !== 0 || i > 256 || e[2] && e[2] !== String(i)) && St.throwArgumentError("invalid numeric width", "type", n);
      const r = xC.mask(t ? i - 1 : i), s = t ? r.add(q6).mul(vC) : G6;
      return function(a) {
        const o = z.from(a);
        return (o.lt(s) || o.gt(r)) && St.throwArgumentError(`value out-of-bounds for ${n}`, "value", a), De(o.toTwos(256).toHexString(), 32);
      };
    }
  }
  {
    const e = n.match(/^bytes(\d+)$/);
    if (e) {
      const t = parseInt(e[1]);
      return (t === 0 || t > 32 || e[1] !== String(t)) && St.throwArgumentError("invalid bytes width", "type", n), function(i) {
        return q(i).length !== t && St.throwArgumentError(`invalid length for ${n}`, "value", i), TC(i);
      };
    }
  }
  switch (n) {
    case "address":
      return function(e) {
        return De(Be(e), 32);
      };
    case "bool":
      return function(e) {
        return e ? wC : AC;
      };
    case "bytes":
      return function(e) {
        return Ie(e);
      };
    case "string":
      return function(e) {
        return hs(e);
      };
  }
  return null;
}
function k2(n, e) {
  return `${n}(${e.map(({ name: t, type: i }) => i + " " + t).join(",")})`;
}
class rn {
  constructor(e) {
    U(this, "types", Object.freeze(Ss(e))), U(this, "_encoderCache", {}), U(this, "_types", {});
    const t = {}, i = {}, r = {};
    Object.keys(e).forEach((o) => {
      t[o] = {}, i[o] = [], r[o] = {};
    });
    for (const o in e) {
      const u = {};
      e[o].forEach((l) => {
        u[l.name] && St.throwArgumentError(`duplicate variable name ${JSON.stringify(l.name)} in ${JSON.stringify(o)}`, "types", e), u[l.name] = !0;
        const p = l.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
        p === o && St.throwArgumentError(`circular type reference to ${JSON.stringify(p)}`, "types", e), !wf(p) && (i[p] || St.throwArgumentError(`unknown type ${JSON.stringify(p)}`, "types", e), i[p].push(o), t[o][p] = !0);
      });
    }
    const s = Object.keys(i).filter((o) => i[o].length === 0);
    s.length === 0 ? St.throwArgumentError("missing primary type", "types", e) : s.length > 1 && St.throwArgumentError(`ambiguous primary types or unused types: ${s.map((o) => JSON.stringify(o)).join(", ")}`, "types", e), U(this, "primaryType", s[0]);
    function a(o, u) {
      u[o] && St.throwArgumentError(`circular type reference to ${JSON.stringify(o)}`, "types", e), u[o] = !0, Object.keys(t[o]).forEach((l) => {
        i[l] && (a(l, u), Object.keys(u).forEach((p) => {
          r[p][l] = !0;
        }));
      }), delete u[o];
    }
    a(this.primaryType, {});
    for (const o in r) {
      const u = Object.keys(r[o]);
      u.sort(), this._types[o] = k2(o, e[o]) + u.map((l) => k2(l, e[l])).join("");
    }
  }
  getEncoder(e) {
    let t = this._encoderCache[e];
    return t || (t = this._encoderCache[e] = this._getEncoder(e)), t;
  }
  _getEncoder(e) {
    {
      const r = wf(e);
      if (r)
        return r;
    }
    const t = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (t) {
      const r = t[1], s = this.getEncoder(r), a = parseInt(t[3]);
      return (o) => {
        a >= 0 && o.length !== a && St.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", o);
        let u = o.map(s);
        return this._types[r] && (u = u.map(Ie)), Ie(Cn(u));
      };
    }
    const i = this.types[e];
    if (i) {
      const r = hs(this._types[e]);
      return (s) => {
        const a = i.map(({ name: o, type: u }) => {
          const l = this.getEncoder(u)(s[o]);
          return this._types[u] ? Ie(l) : l;
        });
        return a.unshift(r), Cn(a);
      };
    }
    return St.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  encodeType(e) {
    const t = this._types[e];
    return t || St.throwArgumentError(`unknown type: ${JSON.stringify(e)}`, "name", e), t;
  }
  encodeData(e, t) {
    return this.getEncoder(e)(t);
  }
  hashStruct(e, t) {
    return Ie(this.encodeData(e, t));
  }
  encode(e) {
    return this.encodeData(this.primaryType, e);
  }
  hash(e) {
    return this.hashStruct(this.primaryType, e);
  }
  _visit(e, t, i) {
    if (wf(e))
      return i(e, t);
    const r = e.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (r) {
      const a = r[1], o = parseInt(r[3]);
      return o >= 0 && t.length !== o && St.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", t), t.map((u) => this._visit(a, u, i));
    }
    const s = this.types[e];
    return s ? s.reduce((a, { name: o, type: u }) => (a[o] = this._visit(u, t[o], i), a), {}) : St.throwArgumentError(`unknown type: ${e}`, "type", e);
  }
  visit(e, t) {
    return this._visit(this.primaryType, e, t);
  }
  static from(e) {
    return new rn(e);
  }
  static getPrimaryType(e) {
    return rn.from(e).primaryType;
  }
  static hashStruct(e, t, i) {
    return rn.from(t).hashStruct(e, i);
  }
  static hashDomain(e) {
    const t = [];
    for (const i in e) {
      const r = _2[i];
      r || St.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(i)}`, "domain", e), t.push({ name: i, type: r });
    }
    return t.sort((i, r) => Tf.indexOf(i.name) - Tf.indexOf(r.name)), rn.hashStruct("EIP712Domain", { EIP712Domain: t }, e);
  }
  static encode(e, t, i) {
    return Cn([
      "0x1901",
      rn.hashDomain(e),
      rn.from(t).hash(i)
    ]);
  }
  static hash(e, t, i) {
    return Ie(rn.encode(e, t, i));
  }
  // Replaces all address types with ENS names with their looked up address
  static resolveNames(e, t, i, r) {
    return gC(this, void 0, void 0, function* () {
      e = Ut(e);
      const s = {};
      e.verifyingContract && !Ae(e.verifyingContract, 20) && (s[e.verifyingContract] = "0x");
      const a = rn.from(t);
      a.visit(i, (o, u) => (o === "address" && !Ae(u, 20) && (s[u] = "0x"), u));
      for (const o in s)
        s[o] = yield r(o);
      return e.verifyingContract && s[e.verifyingContract] && (e.verifyingContract = s[e.verifyingContract]), i = a.visit(i, (o, u) => o === "address" && s[u] ? s[u] : u), { domain: e, value: i };
    });
  }
  static getPayload(e, t, i) {
    rn.hashDomain(e);
    const r = {}, s = [];
    Tf.forEach((u) => {
      const l = e[u];
      l != null && (r[u] = EC[u](l), s.push({ name: u, type: _2[u] }));
    });
    const a = rn.from(t), o = Ut(t);
    return o.EIP712Domain ? St.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", t) : o.EIP712Domain = s, a.encode(i), {
      types: o,
      domain: r,
      primaryType: a.primaryType,
      message: a.visit(i, (u, l) => {
        if (u.match(/^bytes(\d*)/))
          return H(q(l));
        if (u.match(/^u?int/))
          return z.from(l).toString();
        switch (u) {
          case "address":
            return l.toLowerCase();
          case "bool":
            return !!l;
          case "string":
            return typeof l != "string" && St.throwArgumentError("invalid string", "value", l), l;
        }
        return St.throwArgumentError("unsupported type", "type", u);
      })
    };
  }
}
const SC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _TypedDataEncoder: rn,
  dnsEncode: V6,
  ensNormalize: mC,
  hashMessage: y0,
  id: hs,
  isValidName: bC,
  messagePrefix: j6,
  namehash: Ou
}, Symbol.toStringTag, { value: "Module" })), Et = new O(Ul);
class H6 extends Ps {
}
class K6 extends Ps {
}
class MC extends Ps {
}
class pd extends Ps {
  static isIndexed(e) {
    return !!(e && e._isIndexed);
  }
}
const CC = {
  "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: !0 },
  "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function P2(n, e) {
  const t = new Error(`deferred error during ABI decoding triggered accessing ${n}`);
  return t.error = e, t;
}
class Sy {
  constructor(e) {
    let t = [];
    typeof e == "string" ? t = JSON.parse(e) : t = e, U(this, "fragments", t.map((i) => Qi.from(i)).filter((i) => i != null)), U(this, "_abiCoder", Oi(new.target, "getAbiCoder")()), U(this, "functions", {}), U(this, "errors", {}), U(this, "events", {}), U(this, "structs", {}), this.fragments.forEach((i) => {
      let r = null;
      switch (i.type) {
        case "constructor":
          if (this.deploy) {
            Et.warn("duplicate definition - constructor");
            return;
          }
          U(this, "deploy", i);
          return;
        case "function":
          r = this.functions;
          break;
        case "event":
          r = this.events;
          break;
        case "error":
          r = this.errors;
          break;
        default:
          return;
      }
      let s = i.format();
      if (r[s]) {
        Et.warn("duplicate definition - " + s);
        return;
      }
      r[s] = i;
    }), this.deploy || U(this, "deploy", _i.from({
      payable: !1,
      type: "constructor"
    })), U(this, "_isInterface", !0);
  }
  format(e) {
    e || (e = Me.full), e === Me.sighash && Et.throwArgumentError("interface does not support formatting sighash", "format", e);
    const t = this.fragments.map((i) => i.format(e));
    return e === Me.json ? JSON.stringify(t.map((i) => JSON.parse(i))) : t;
  }
  // Sub-classes can override these to handle other blockchains
  static getAbiCoder() {
    return B6;
  }
  static getAddress(e) {
    return Be(e);
  }
  static getSighash(e) {
    return Bt(hs(e.format()), 0, 4);
  }
  static getEventTopic(e) {
    return hs(e.format());
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getFunction(e) {
    if (Ae(e)) {
      for (const i in this.functions)
        if (e === this.getSighash(i))
          return this.functions[i];
      Et.throwArgumentError("no matching function", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const i = e.trim(), r = Object.keys(this.functions).filter((s) => s.split(
        "("
        /* fix:) */
      )[0] === i);
      return r.length === 0 ? Et.throwArgumentError("no matching function", "name", i) : r.length > 1 && Et.throwArgumentError("multiple matching functions", "name", i), this.functions[r[0]];
    }
    const t = this.functions[Ri.fromString(e).format()];
    return t || Et.throwArgumentError("no matching function", "signature", e), t;
  }
  // Find an event definition by any means necessary (unless it is ambiguous)
  getEvent(e) {
    if (Ae(e)) {
      const i = e.toLowerCase();
      for (const r in this.events)
        if (i === this.getEventTopic(r))
          return this.events[r];
      Et.throwArgumentError("no matching event", "topichash", i);
    }
    if (e.indexOf("(") === -1) {
      const i = e.trim(), r = Object.keys(this.events).filter((s) => s.split(
        "("
        /* fix:) */
      )[0] === i);
      return r.length === 0 ? Et.throwArgumentError("no matching event", "name", i) : r.length > 1 && Et.throwArgumentError("multiple matching events", "name", i), this.events[r[0]];
    }
    const t = this.events[Ji.fromString(e).format()];
    return t || Et.throwArgumentError("no matching event", "signature", e), t;
  }
  // Find a function definition by any means necessary (unless it is ambiguous)
  getError(e) {
    if (Ae(e)) {
      const i = Oi(this.constructor, "getSighash");
      for (const r in this.errors) {
        const s = this.errors[r];
        if (e === i(s))
          return this.errors[r];
      }
      Et.throwArgumentError("no matching error", "sighash", e);
    }
    if (e.indexOf("(") === -1) {
      const i = e.trim(), r = Object.keys(this.errors).filter((s) => s.split(
        "("
        /* fix:) */
      )[0] === i);
      return r.length === 0 ? Et.throwArgumentError("no matching error", "name", i) : r.length > 1 && Et.throwArgumentError("multiple matching errors", "name", i), this.errors[r[0]];
    }
    const t = this.errors[Ri.fromString(e).format()];
    return t || Et.throwArgumentError("no matching error", "signature", e), t;
  }
  // Get the sighash (the bytes4 selector) used by Solidity to identify a function
  getSighash(e) {
    if (typeof e == "string")
      try {
        e = this.getFunction(e);
      } catch (t) {
        try {
          e = this.getError(e);
        } catch {
          throw t;
        }
      }
    return Oi(this.constructor, "getSighash")(e);
  }
  // Get the topic (the bytes32 hash) used by Solidity to identify an event
  getEventTopic(e) {
    return typeof e == "string" && (e = this.getEvent(e)), Oi(this.constructor, "getEventTopic")(e);
  }
  _decodeParams(e, t) {
    return this._abiCoder.decode(e, t);
  }
  _encodeParams(e, t) {
    return this._abiCoder.encode(e, t);
  }
  encodeDeploy(e) {
    return this._encodeParams(this.deploy.inputs, e || []);
  }
  decodeErrorResult(e, t) {
    typeof e == "string" && (e = this.getError(e));
    const i = q(t);
    return H(i.slice(0, 4)) !== this.getSighash(e) && Et.throwArgumentError(`data signature does not match error ${e.name}.`, "data", H(i)), this._decodeParams(e.inputs, i.slice(4));
  }
  encodeErrorResult(e, t) {
    return typeof e == "string" && (e = this.getError(e)), H(Ve([
      this.getSighash(e),
      this._encodeParams(e.inputs, t || [])
    ]));
  }
  // Decode the data for a function call (e.g. tx.data)
  decodeFunctionData(e, t) {
    typeof e == "string" && (e = this.getFunction(e));
    const i = q(t);
    return H(i.slice(0, 4)) !== this.getSighash(e) && Et.throwArgumentError(`data signature does not match function ${e.name}.`, "data", H(i)), this._decodeParams(e.inputs, i.slice(4));
  }
  // Encode the data for a function call (e.g. tx.data)
  encodeFunctionData(e, t) {
    return typeof e == "string" && (e = this.getFunction(e)), H(Ve([
      this.getSighash(e),
      this._encodeParams(e.inputs, t || [])
    ]));
  }
  // Decode the result from a function call (e.g. from eth_call)
  decodeFunctionResult(e, t) {
    typeof e == "string" && (e = this.getFunction(e));
    let i = q(t), r = null, s = "", a = null, o = null, u = null;
    switch (i.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(e.outputs, i);
        } catch {
        }
        break;
      case 4: {
        const l = H(i.slice(0, 4)), p = CC[l];
        if (p)
          a = this._abiCoder.decode(p.inputs, i.slice(4)), o = p.name, u = p.signature, p.reason && (r = a[0]), o === "Error" ? s = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(a[0])}` : o === "Panic" && (s = `; VM Exception while processing transaction: reverted with panic code ${a[0]}`);
        else
          try {
            const f = this.getError(l);
            a = this._abiCoder.decode(f.inputs, i.slice(4)), o = f.name, u = f.format();
          } catch {
          }
        break;
      }
    }
    return Et.throwError("call revert exception" + s, O.errors.CALL_EXCEPTION, {
      method: e.format(),
      data: H(t),
      errorArgs: a,
      errorName: o,
      errorSignature: u,
      reason: r
    });
  }
  // Encode the result for a function call (e.g. for eth_call)
  encodeFunctionResult(e, t) {
    return typeof e == "string" && (e = this.getFunction(e)), H(this._abiCoder.encode(e.outputs, t || []));
  }
  // Create the filter for the event with search criteria (e.g. for eth_filterLog)
  encodeFilterTopics(e, t) {
    typeof e == "string" && (e = this.getEvent(e)), t.length > e.inputs.length && Et.throwError("too many arguments for " + e.format(), O.errors.UNEXPECTED_ARGUMENT, {
      argument: "values",
      value: t
    });
    let i = [];
    e.anonymous || i.push(this.getEventTopic(e));
    const r = (s, a) => s.type === "string" ? hs(a) : s.type === "bytes" ? Ie(H(a)) : (s.type === "bool" && typeof a == "boolean" && (a = a ? "0x01" : "0x00"), s.type.match(/^u?int/) && (a = z.from(a).toHexString()), s.type === "address" && this._abiCoder.encode(["address"], [a]), De(H(a), 32));
    for (t.forEach((s, a) => {
      let o = e.inputs[a];
      if (!o.indexed) {
        s != null && Et.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + o.name, s);
        return;
      }
      s == null ? i.push(null) : o.baseType === "array" || o.baseType === "tuple" ? Et.throwArgumentError("filtering with tuples or arrays not supported", "contract." + o.name, s) : Array.isArray(s) ? i.push(s.map((u) => r(o, u))) : i.push(r(o, s));
    }); i.length && i[i.length - 1] === null; )
      i.pop();
    return i;
  }
  encodeEventLog(e, t) {
    typeof e == "string" && (e = this.getEvent(e));
    const i = [], r = [], s = [];
    return e.anonymous || i.push(this.getEventTopic(e)), t.length !== e.inputs.length && Et.throwArgumentError("event arguments/values mismatch", "values", t), e.inputs.forEach((a, o) => {
      const u = t[o];
      if (a.indexed)
        if (a.type === "string")
          i.push(hs(u));
        else if (a.type === "bytes")
          i.push(Ie(u));
        else {
          if (a.baseType === "tuple" || a.baseType === "array")
            throw new Error("not implemented");
          i.push(this._abiCoder.encode([a.type], [u]));
        }
      else
        r.push(a), s.push(u);
    }), {
      data: this._abiCoder.encode(r, s),
      topics: i
    };
  }
  // Decode a filter for the event and the search criteria
  decodeEventLog(e, t, i) {
    if (typeof e == "string" && (e = this.getEvent(e)), i != null && !e.anonymous) {
      let b = this.getEventTopic(e);
      (!Ae(i[0], 32) || i[0].toLowerCase() !== b) && Et.throwError("fragment/topic mismatch", O.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: b, value: i[0] }), i = i.slice(1);
    }
    let r = [], s = [], a = [];
    e.inputs.forEach((b, A) => {
      b.indexed ? b.type === "string" || b.type === "bytes" || b.baseType === "tuple" || b.baseType === "array" ? (r.push(qt.fromObject({ type: "bytes32", name: b.name })), a.push(!0)) : (r.push(b), a.push(!1)) : (s.push(b), a.push(!1));
    });
    let o = i != null ? this._abiCoder.decode(r, Ve(i)) : null, u = this._abiCoder.decode(s, t, !0), l = [], p = 0, f = 0;
    e.inputs.forEach((b, A) => {
      if (b.indexed)
        if (o == null)
          l[A] = new pd({ _isIndexed: !0, hash: null });
        else if (a[A])
          l[A] = new pd({ _isIndexed: !0, hash: o[f++] });
        else
          try {
            l[A] = o[f++];
          } catch (x) {
            l[A] = x;
          }
      else
        try {
          l[A] = u[p++];
        } catch (x) {
          l[A] = x;
        }
      if (b.name && l[b.name] == null) {
        const x = l[A];
        x instanceof Error ? Object.defineProperty(l, b.name, {
          enumerable: !0,
          get: () => {
            throw P2(`property ${JSON.stringify(b.name)}`, x);
          }
        }) : l[b.name] = x;
      }
    });
    for (let b = 0; b < l.length; b++) {
      const A = l[b];
      A instanceof Error && Object.defineProperty(l, b, {
        enumerable: !0,
        get: () => {
          throw P2(`index ${b}`, A);
        }
      });
    }
    return Object.freeze(l);
  }
  // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters
  parseTransaction(e) {
    let t = this.getFunction(e.data.substring(0, 10).toLowerCase());
    return t ? new K6({
      args: this._abiCoder.decode(t.inputs, "0x" + e.data.substring(10)),
      functionFragment: t,
      name: t.name,
      signature: t.format(),
      sighash: this.getSighash(t),
      value: z.from(e.value || "0")
    }) : null;
  }
  // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values
  parseLog(e) {
    let t = this.getEvent(e.topics[0]);
    return !t || t.anonymous ? null : new H6({
      eventFragment: t,
      name: t.name,
      signature: t.format(),
      topic: this.getEventTopic(t),
      args: this.decodeEventLog(t, e.data, e.topics)
    });
  }
  parseError(e) {
    const t = H(e);
    let i = this.getError(t.substring(0, 10).toLowerCase());
    return i ? new MC({
      args: this._abiCoder.decode(i.inputs, "0x" + t.substring(10)),
      errorFragment: i,
      name: i.name,
      signature: i.format(),
      sighash: this.getSighash(i)
    }) : null;
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */
  static isInterface(e) {
    return !!(e && e._isInterface);
  }
}
const _C = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbiCoder: O6,
  ConstructorFragment: _i,
  ErrorFragment: Sr,
  EventFragment: Ji,
  FormatTypes: Me,
  Fragment: Qi,
  FunctionFragment: Ri,
  Indexed: pd,
  Interface: Sy,
  LogDescription: H6,
  ParamType: qt,
  TransactionDescription: K6,
  checkResultErrors: m6,
  defaultAbiCoder: B6
}, Symbol.toStringTag, { value: "Module" })), RC = "abstract-provider/5.7.0";
var kC = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
const PC = new O(RC);
class IC extends Ps {
  static isForkEvent(e) {
    return !!(e && e._isForkEvent);
  }
}
let h0 = class W6 {
  constructor() {
    PC.checkAbstract(new.target, W6), U(this, "_isProvider", !0);
  }
  getFeeData() {
    return kC(this, void 0, void 0, function* () {
      const { block: e, gasPrice: t } = yield _t({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch((a) => null)
      });
      let i = null, r = null, s = null;
      return e && e.baseFeePerGas && (i = e.baseFeePerGas, s = z.from("1500000000"), r = e.baseFeePerGas.mul(2).add(s)), { lastBaseFeePerGas: i, maxFeePerGas: r, maxPriorityFeePerGas: s, gasPrice: t };
    });
  }
  // Alias for "on"
  addListener(e, t) {
    return this.on(e, t);
  }
  // Alias for "off"
  removeListener(e, t) {
    return this.off(e, t);
  }
  static isProvider(e) {
    return !!(e && e._isProvider);
  }
};
const OC = "abstract-signer/5.7.0";
var Ei = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
const li = new O(OC), BC = [
  "accessList",
  "ccipReadEnabled",
  "chainId",
  "customData",
  "data",
  "from",
  "gasLimit",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "nonce",
  "to",
  "type",
  "value"
], NC = [
  O.errors.INSUFFICIENT_FUNDS,
  O.errors.NONCE_EXPIRED,
  O.errors.REPLACEMENT_UNDERPRICED
];
class Ua {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    li.checkAbstract(new.target, Ua), U(this, "_isSigner", !0);
  }
  ///////////////////
  // Sub-classes MAY override these
  getBalance(e) {
    return Ei(this, void 0, void 0, function* () {
      return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), e);
    });
  }
  getTransactionCount(e) {
    return Ei(this, void 0, void 0, function* () {
      return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), e);
    });
  }
  // Populates "from" if unspecified, and estimates the gas for the transaction
  estimateGas(e) {
    return Ei(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");
      const t = yield _t(this.checkTransaction(e));
      return yield this.provider.estimateGas(t);
    });
  }
  // Populates "from" if unspecified, and calls with the transaction
  call(e, t) {
    return Ei(this, void 0, void 0, function* () {
      this._checkProvider("call");
      const i = yield _t(this.checkTransaction(e));
      return yield this.provider.call(i, t);
    });
  }
  // Populates all fields in a transaction, signs it and sends it to the network
  sendTransaction(e) {
    return Ei(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");
      const t = yield this.populateTransaction(e), i = yield this.signTransaction(t);
      return yield this.provider.sendTransaction(i);
    });
  }
  getChainId() {
    return Ei(this, void 0, void 0, function* () {
      return this._checkProvider("getChainId"), (yield this.provider.getNetwork()).chainId;
    });
  }
  getGasPrice() {
    return Ei(this, void 0, void 0, function* () {
      return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
    });
  }
  getFeeData() {
    return Ei(this, void 0, void 0, function* () {
      return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
    });
  }
  resolveName(e) {
    return Ei(this, void 0, void 0, function* () {
      return this._checkProvider("resolveName"), yield this.provider.resolveName(e);
    });
  }
  // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)
  checkTransaction(e) {
    for (const i in e)
      BC.indexOf(i) === -1 && li.throwArgumentError("invalid transaction key: " + i, "transaction", e);
    const t = Ut(e);
    return t.from == null ? t.from = this.getAddress() : t.from = Promise.all([
      Promise.resolve(t.from),
      this.getAddress()
    ]).then((i) => (i[0].toLowerCase() !== i[1].toLowerCase() && li.throwArgumentError("from address mismatch", "transaction", e), i[0])), t;
  }
  // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
  populateTransaction(e) {
    return Ei(this, void 0, void 0, function* () {
      const t = yield _t(this.checkTransaction(e));
      t.to != null && (t.to = Promise.resolve(t.to).then((r) => Ei(this, void 0, void 0, function* () {
        if (r == null)
          return null;
        const s = yield this.resolveName(r);
        return s == null && li.throwArgumentError("provided ENS name resolves to null", "tx.to", r), s;
      })), t.to.catch((r) => {
      }));
      const i = t.maxFeePerGas != null || t.maxPriorityFeePerGas != null;
      if (t.gasPrice != null && (t.type === 2 || i) ? li.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", e) : (t.type === 0 || t.type === 1) && i && li.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", e), (t.type === 2 || t.type == null) && t.maxFeePerGas != null && t.maxPriorityFeePerGas != null)
        t.type = 2;
      else if (t.type === 0 || t.type === 1)
        t.gasPrice == null && (t.gasPrice = this.getGasPrice());
      else {
        const r = yield this.getFeeData();
        if (t.type == null)
          if (r.maxFeePerGas != null && r.maxPriorityFeePerGas != null)
            if (t.type = 2, t.gasPrice != null) {
              const s = t.gasPrice;
              delete t.gasPrice, t.maxFeePerGas = s, t.maxPriorityFeePerGas = s;
            } else
              t.maxFeePerGas == null && (t.maxFeePerGas = r.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = r.maxPriorityFeePerGas);
          else
            r.gasPrice != null ? (i && li.throwError("network does not support EIP-1559", O.errors.UNSUPPORTED_OPERATION, {
              operation: "populateTransaction"
            }), t.gasPrice == null && (t.gasPrice = r.gasPrice), t.type = 0) : li.throwError("failed to get consistent fee data", O.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
        else
          t.type === 2 && (t.maxFeePerGas == null && (t.maxFeePerGas = r.maxFeePerGas), t.maxPriorityFeePerGas == null && (t.maxPriorityFeePerGas = r.maxPriorityFeePerGas));
      }
      return t.nonce == null && (t.nonce = this.getTransactionCount("pending")), t.gasLimit == null && (t.gasLimit = this.estimateGas(t).catch((r) => {
        if (NC.indexOf(r.code) >= 0)
          throw r;
        return li.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", O.errors.UNPREDICTABLE_GAS_LIMIT, {
          error: r,
          tx: t
        });
      })), t.chainId == null ? t.chainId = this.getChainId() : t.chainId = Promise.all([
        Promise.resolve(t.chainId),
        this.getChainId()
      ]).then((r) => (r[1] !== 0 && r[0] !== r[1] && li.throwArgumentError("chainId address mismatch", "transaction", e), r[0])), yield _t(t);
    });
  }
  ///////////////////
  // Sub-classes SHOULD leave these alone
  _checkProvider(e) {
    this.provider || li.throwError("missing provider", O.errors.UNSUPPORTED_OPERATION, {
      operation: e || "_checkProvider"
    });
  }
  static isSigner(e) {
    return !!(e && e._isSigner);
  }
}
class m0 extends Ua {
  constructor(e, t) {
    super(), U(this, "address", e), U(this, "provider", t || null);
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  _fail(e, t) {
    return Promise.resolve().then(() => {
      li.throwError(e, O.errors.UNSUPPORTED_OPERATION, { operation: t });
    });
  }
  signMessage(e) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }
  signTransaction(e) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }
  _signTypedData(e, t, i) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }
  connect(e) {
    return new m0(this.address, e);
  }
}
var Mn = {}, xe = {}, jl = J6;
function J6(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
J6.equal = function(e, t, i) {
  if (e != t)
    throw new Error(i || "Assertion failed: " + e + " != " + t);
};
var My = {}, I2 = {
  get exports() {
    return My;
  },
  set exports(n) {
    My = n;
  }
};
typeof Object.create == "function" ? I2.exports = function(e, t) {
  t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : I2.exports = function(e, t) {
  if (t) {
    e.super_ = t;
    var i = function() {
    };
    i.prototype = t.prototype, e.prototype = new i(), e.prototype.constructor = e;
  }
};
var DC = jl, $C = My;
xe.inherits = $C;
function FC(n, e) {
  return (n.charCodeAt(e) & 64512) !== 55296 || e < 0 || e + 1 >= n.length ? !1 : (n.charCodeAt(e + 1) & 64512) === 56320;
}
function LC(n, e) {
  if (Array.isArray(n))
    return n.slice();
  if (!n)
    return [];
  var t = [];
  if (typeof n == "string")
    if (e) {
      if (e === "hex")
        for (n = n.replace(/[^a-z0-9]+/ig, ""), n.length % 2 !== 0 && (n = "0" + n), r = 0; r < n.length; r += 2)
          t.push(parseInt(n[r] + n[r + 1], 16));
    } else
      for (var i = 0, r = 0; r < n.length; r++) {
        var s = n.charCodeAt(r);
        s < 128 ? t[i++] = s : s < 2048 ? (t[i++] = s >> 6 | 192, t[i++] = s & 63 | 128) : FC(n, r) ? (s = 65536 + ((s & 1023) << 10) + (n.charCodeAt(++r) & 1023), t[i++] = s >> 18 | 240, t[i++] = s >> 12 & 63 | 128, t[i++] = s >> 6 & 63 | 128, t[i++] = s & 63 | 128) : (t[i++] = s >> 12 | 224, t[i++] = s >> 6 & 63 | 128, t[i++] = s & 63 | 128);
      }
  else
    for (r = 0; r < n.length; r++)
      t[r] = n[r] | 0;
  return t;
}
xe.toArray = LC;
function UC(n) {
  for (var e = "", t = 0; t < n.length; t++)
    e += Y6(n[t].toString(16));
  return e;
}
xe.toHex = UC;
function Q6(n) {
  var e = n >>> 24 | n >>> 8 & 65280 | n << 8 & 16711680 | (n & 255) << 24;
  return e >>> 0;
}
xe.htonl = Q6;
function VC(n, e) {
  for (var t = "", i = 0; i < n.length; i++) {
    var r = n[i];
    e === "little" && (r = Q6(r)), t += X6(r.toString(16));
  }
  return t;
}
xe.toHex32 = VC;
function Y6(n) {
  return n.length === 1 ? "0" + n : n;
}
xe.zero2 = Y6;
function X6(n) {
  return n.length === 7 ? "0" + n : n.length === 6 ? "00" + n : n.length === 5 ? "000" + n : n.length === 4 ? "0000" + n : n.length === 3 ? "00000" + n : n.length === 2 ? "000000" + n : n.length === 1 ? "0000000" + n : n;
}
xe.zero8 = X6;
function jC(n, e, t, i) {
  var r = t - e;
  DC(r % 4 === 0);
  for (var s = new Array(r / 4), a = 0, o = e; a < s.length; a++, o += 4) {
    var u;
    i === "big" ? u = n[o] << 24 | n[o + 1] << 16 | n[o + 2] << 8 | n[o + 3] : u = n[o + 3] << 24 | n[o + 2] << 16 | n[o + 1] << 8 | n[o], s[a] = u >>> 0;
  }
  return s;
}
xe.join32 = jC;
function zC(n, e) {
  for (var t = new Array(n.length * 4), i = 0, r = 0; i < n.length; i++, r += 4) {
    var s = n[i];
    e === "big" ? (t[r] = s >>> 24, t[r + 1] = s >>> 16 & 255, t[r + 2] = s >>> 8 & 255, t[r + 3] = s & 255) : (t[r + 3] = s >>> 24, t[r + 2] = s >>> 16 & 255, t[r + 1] = s >>> 8 & 255, t[r] = s & 255);
  }
  return t;
}
xe.split32 = zC;
function GC(n, e) {
  return n >>> e | n << 32 - e;
}
xe.rotr32 = GC;
function qC(n, e) {
  return n << e | n >>> 32 - e;
}
xe.rotl32 = qC;
function HC(n, e) {
  return n + e >>> 0;
}
xe.sum32 = HC;
function KC(n, e, t) {
  return n + e + t >>> 0;
}
xe.sum32_3 = KC;
function WC(n, e, t, i) {
  return n + e + t + i >>> 0;
}
xe.sum32_4 = WC;
function JC(n, e, t, i, r) {
  return n + e + t + i + r >>> 0;
}
xe.sum32_5 = JC;
function QC(n, e, t, i) {
  var r = n[e], s = n[e + 1], a = i + s >>> 0, o = (a < i ? 1 : 0) + t + r;
  n[e] = o >>> 0, n[e + 1] = a;
}
xe.sum64 = QC;
function YC(n, e, t, i) {
  var r = e + i >>> 0, s = (r < e ? 1 : 0) + n + t;
  return s >>> 0;
}
xe.sum64_hi = YC;
function XC(n, e, t, i) {
  var r = e + i;
  return r >>> 0;
}
xe.sum64_lo = XC;
function ZC(n, e, t, i, r, s, a, o) {
  var u = 0, l = e;
  l = l + i >>> 0, u += l < e ? 1 : 0, l = l + s >>> 0, u += l < s ? 1 : 0, l = l + o >>> 0, u += l < o ? 1 : 0;
  var p = n + t + r + a + u;
  return p >>> 0;
}
xe.sum64_4_hi = ZC;
function e_(n, e, t, i, r, s, a, o) {
  var u = e + i + s + o;
  return u >>> 0;
}
xe.sum64_4_lo = e_;
function t_(n, e, t, i, r, s, a, o, u, l) {
  var p = 0, f = e;
  f = f + i >>> 0, p += f < e ? 1 : 0, f = f + s >>> 0, p += f < s ? 1 : 0, f = f + o >>> 0, p += f < o ? 1 : 0, f = f + l >>> 0, p += f < l ? 1 : 0;
  var b = n + t + r + a + u + p;
  return b >>> 0;
}
xe.sum64_5_hi = t_;
function n_(n, e, t, i, r, s, a, o, u, l) {
  var p = e + i + s + o + l;
  return p >>> 0;
}
xe.sum64_5_lo = n_;
function i_(n, e, t) {
  var i = e << 32 - t | n >>> t;
  return i >>> 0;
}
xe.rotr64_hi = i_;
function r_(n, e, t) {
  var i = n << 32 - t | e >>> t;
  return i >>> 0;
}
xe.rotr64_lo = r_;
function s_(n, e, t) {
  return n >>> t;
}
xe.shr64_hi = s_;
function a_(n, e, t) {
  var i = n << 32 - t | e >>> t;
  return i >>> 0;
}
xe.shr64_lo = a_;
var Go = {}, O2 = xe, o_ = jl;
function op() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
Go.BlockHash = op;
op.prototype.update = function(e, t) {
  if (e = O2.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var i = e.length % this._delta8;
    this.pending = e.slice(e.length - i, e.length), this.pending.length === 0 && (this.pending = null), e = O2.join32(e, 0, e.length - i, this.endian);
    for (var r = 0; r < e.length; r += this._delta32)
      this._update(e, r, r + this._delta32);
  }
  return this;
};
op.prototype.digest = function(e) {
  return this.update(this._pad()), o_(this.pending === null), this._digest(e);
};
op.prototype._pad = function() {
  var e = this.pendingTotal, t = this._delta8, i = t - (e + this.padLength) % t, r = new Array(i + this.padLength);
  r[0] = 128;
  for (var s = 1; s < i; s++)
    r[s] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var a = 8; a < this.padLength; a++)
      r[s++] = 0;
    r[s++] = 0, r[s++] = 0, r[s++] = 0, r[s++] = 0, r[s++] = e >>> 24 & 255, r[s++] = e >>> 16 & 255, r[s++] = e >>> 8 & 255, r[s++] = e & 255;
  } else
    for (r[s++] = e & 255, r[s++] = e >>> 8 & 255, r[s++] = e >>> 16 & 255, r[s++] = e >>> 24 & 255, r[s++] = 0, r[s++] = 0, r[s++] = 0, r[s++] = 0, a = 8; a < this.padLength; a++)
      r[s++] = 0;
  return r;
};
var qo = {}, fr = {}, u_ = xe, er = u_.rotr32;
function l_(n, e, t, i) {
  if (n === 0)
    return Z6(e, t, i);
  if (n === 1 || n === 3)
    return t5(e, t, i);
  if (n === 2)
    return e5(e, t, i);
}
fr.ft_1 = l_;
function Z6(n, e, t) {
  return n & e ^ ~n & t;
}
fr.ch32 = Z6;
function e5(n, e, t) {
  return n & e ^ n & t ^ e & t;
}
fr.maj32 = e5;
function t5(n, e, t) {
  return n ^ e ^ t;
}
fr.p32 = t5;
function c_(n) {
  return er(n, 2) ^ er(n, 13) ^ er(n, 22);
}
fr.s0_256 = c_;
function d_(n) {
  return er(n, 6) ^ er(n, 11) ^ er(n, 25);
}
fr.s1_256 = d_;
function p_(n) {
  return er(n, 7) ^ er(n, 18) ^ n >>> 3;
}
fr.g0_256 = p_;
function f_(n) {
  return er(n, 17) ^ er(n, 19) ^ n >>> 10;
}
fr.g1_256 = f_;
var Eo = xe, y_ = Go, h_ = fr, Af = Eo.rotl32, su = Eo.sum32, m_ = Eo.sum32_5, b_ = h_.ft_1, n5 = y_.BlockHash, g_ = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function ar() {
  if (!(this instanceof ar))
    return new ar();
  n5.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
Eo.inherits(ar, n5);
var v_ = ar;
ar.blockSize = 512;
ar.outSize = 160;
ar.hmacStrength = 80;
ar.padLength = 64;
ar.prototype._update = function(e, t) {
  for (var i = this.W, r = 0; r < 16; r++)
    i[r] = e[t + r];
  for (; r < i.length; r++)
    i[r] = Af(i[r - 3] ^ i[r - 8] ^ i[r - 14] ^ i[r - 16], 1);
  var s = this.h[0], a = this.h[1], o = this.h[2], u = this.h[3], l = this.h[4];
  for (r = 0; r < i.length; r++) {
    var p = ~~(r / 20), f = m_(Af(s, 5), b_(p, a, o, u), l, i[r], g_[p]);
    l = u, u = o, o = Af(a, 30), a = s, s = f;
  }
  this.h[0] = su(this.h[0], s), this.h[1] = su(this.h[1], a), this.h[2] = su(this.h[2], o), this.h[3] = su(this.h[3], u), this.h[4] = su(this.h[4], l);
};
ar.prototype._digest = function(e) {
  return e === "hex" ? Eo.toHex32(this.h, "big") : Eo.split32(this.h, "big");
};
var So = xe, x_ = Go, Ho = fr, T_ = jl, Si = So.sum32, w_ = So.sum32_4, A_ = So.sum32_5, E_ = Ho.ch32, S_ = Ho.maj32, M_ = Ho.s0_256, C_ = Ho.s1_256, __ = Ho.g0_256, R_ = Ho.g1_256, i5 = x_.BlockHash, k_ = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function or() {
  if (!(this instanceof or))
    return new or();
  i5.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = k_, this.W = new Array(64);
}
So.inherits(or, i5);
var r5 = or;
or.blockSize = 512;
or.outSize = 256;
or.hmacStrength = 192;
or.padLength = 64;
or.prototype._update = function(e, t) {
  for (var i = this.W, r = 0; r < 16; r++)
    i[r] = e[t + r];
  for (; r < i.length; r++)
    i[r] = w_(R_(i[r - 2]), i[r - 7], __(i[r - 15]), i[r - 16]);
  var s = this.h[0], a = this.h[1], o = this.h[2], u = this.h[3], l = this.h[4], p = this.h[5], f = this.h[6], b = this.h[7];
  for (T_(this.k.length === i.length), r = 0; r < i.length; r++) {
    var A = A_(b, C_(l), E_(l, p, f), this.k[r], i[r]), x = Si(M_(s), S_(s, a, o));
    b = f, f = p, p = l, l = Si(u, A), u = o, o = a, a = s, s = Si(A, x);
  }
  this.h[0] = Si(this.h[0], s), this.h[1] = Si(this.h[1], a), this.h[2] = Si(this.h[2], o), this.h[3] = Si(this.h[3], u), this.h[4] = Si(this.h[4], l), this.h[5] = Si(this.h[5], p), this.h[6] = Si(this.h[6], f), this.h[7] = Si(this.h[7], b);
};
or.prototype._digest = function(e) {
  return e === "hex" ? So.toHex32(this.h, "big") : So.split32(this.h, "big");
};
var Cy = xe, s5 = r5;
function Fr() {
  if (!(this instanceof Fr))
    return new Fr();
  s5.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
Cy.inherits(Fr, s5);
var P_ = Fr;
Fr.blockSize = 512;
Fr.outSize = 224;
Fr.hmacStrength = 192;
Fr.padLength = 64;
Fr.prototype._digest = function(e) {
  return e === "hex" ? Cy.toHex32(this.h.slice(0, 7), "big") : Cy.split32(this.h.slice(0, 7), "big");
};
var Gn = xe, I_ = Go, O_ = jl, tr = Gn.rotr64_hi, nr = Gn.rotr64_lo, a5 = Gn.shr64_hi, o5 = Gn.shr64_lo, is = Gn.sum64, Ef = Gn.sum64_hi, Sf = Gn.sum64_lo, B_ = Gn.sum64_4_hi, N_ = Gn.sum64_4_lo, D_ = Gn.sum64_5_hi, $_ = Gn.sum64_5_lo, u5 = I_.BlockHash, F_ = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function Li() {
  if (!(this instanceof Li))
    return new Li();
  u5.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = F_, this.W = new Array(160);
}
Gn.inherits(Li, u5);
var l5 = Li;
Li.blockSize = 1024;
Li.outSize = 512;
Li.hmacStrength = 192;
Li.padLength = 128;
Li.prototype._prepareBlock = function(e, t) {
  for (var i = this.W, r = 0; r < 32; r++)
    i[r] = e[t + r];
  for (; r < i.length; r += 2) {
    var s = J_(i[r - 4], i[r - 3]), a = Q_(i[r - 4], i[r - 3]), o = i[r - 14], u = i[r - 13], l = K_(i[r - 30], i[r - 29]), p = W_(i[r - 30], i[r - 29]), f = i[r - 32], b = i[r - 31];
    i[r] = B_(
      s,
      a,
      o,
      u,
      l,
      p,
      f,
      b
    ), i[r + 1] = N_(
      s,
      a,
      o,
      u,
      l,
      p,
      f,
      b
    );
  }
};
Li.prototype._update = function(e, t) {
  this._prepareBlock(e, t);
  var i = this.W, r = this.h[0], s = this.h[1], a = this.h[2], o = this.h[3], u = this.h[4], l = this.h[5], p = this.h[6], f = this.h[7], b = this.h[8], A = this.h[9], x = this.h[10], w = this.h[11], T = this.h[12], _ = this.h[13], I = this.h[14], $ = this.h[15];
  O_(this.k.length === i.length);
  for (var N = 0; N < i.length; N += 2) {
    var B = I, V = $, K = q_(b, A), G = H_(b, A), Y = L_(b, A, x, w, T), oe = U_(b, A, x, w, T, _), J = this.k[N], ue = this.k[N + 1], M = i[N], c = i[N + 1], h = D_(
      B,
      V,
      K,
      G,
      Y,
      oe,
      J,
      ue,
      M,
      c
    ), v = $_(
      B,
      V,
      K,
      G,
      Y,
      oe,
      J,
      ue,
      M,
      c
    );
    B = z_(r, s), V = G_(r, s), K = V_(r, s, a, o, u), G = j_(r, s, a, o, u, l);
    var S = Ef(B, V, K, G), E = Sf(B, V, K, G);
    I = T, $ = _, T = x, _ = w, x = b, w = A, b = Ef(p, f, h, v), A = Sf(f, f, h, v), p = u, f = l, u = a, l = o, a = r, o = s, r = Ef(h, v, S, E), s = Sf(h, v, S, E);
  }
  is(this.h, 0, r, s), is(this.h, 2, a, o), is(this.h, 4, u, l), is(this.h, 6, p, f), is(this.h, 8, b, A), is(this.h, 10, x, w), is(this.h, 12, T, _), is(this.h, 14, I, $);
};
Li.prototype._digest = function(e) {
  return e === "hex" ? Gn.toHex32(this.h, "big") : Gn.split32(this.h, "big");
};
function L_(n, e, t, i, r) {
  var s = n & t ^ ~n & r;
  return s < 0 && (s += 4294967296), s;
}
function U_(n, e, t, i, r, s) {
  var a = e & i ^ ~e & s;
  return a < 0 && (a += 4294967296), a;
}
function V_(n, e, t, i, r) {
  var s = n & t ^ n & r ^ t & r;
  return s < 0 && (s += 4294967296), s;
}
function j_(n, e, t, i, r, s) {
  var a = e & i ^ e & s ^ i & s;
  return a < 0 && (a += 4294967296), a;
}
function z_(n, e) {
  var t = tr(n, e, 28), i = tr(e, n, 2), r = tr(e, n, 7), s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function G_(n, e) {
  var t = nr(n, e, 28), i = nr(e, n, 2), r = nr(e, n, 7), s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function q_(n, e) {
  var t = tr(n, e, 14), i = tr(n, e, 18), r = tr(e, n, 9), s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function H_(n, e) {
  var t = nr(n, e, 14), i = nr(n, e, 18), r = nr(e, n, 9), s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function K_(n, e) {
  var t = tr(n, e, 1), i = tr(n, e, 8), r = a5(n, e, 7), s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function W_(n, e) {
  var t = nr(n, e, 1), i = nr(n, e, 8), r = o5(n, e, 7), s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function J_(n, e) {
  var t = tr(n, e, 19), i = tr(e, n, 29), r = a5(n, e, 6), s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
function Q_(n, e) {
  var t = nr(n, e, 19), i = nr(e, n, 29), r = o5(n, e, 6), s = t ^ i ^ r;
  return s < 0 && (s += 4294967296), s;
}
var _y = xe, c5 = l5;
function Lr() {
  if (!(this instanceof Lr))
    return new Lr();
  c5.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
_y.inherits(Lr, c5);
var Y_ = Lr;
Lr.blockSize = 1024;
Lr.outSize = 384;
Lr.hmacStrength = 192;
Lr.padLength = 128;
Lr.prototype._digest = function(e) {
  return e === "hex" ? _y.toHex32(this.h.slice(0, 12), "big") : _y.split32(this.h.slice(0, 12), "big");
};
qo.sha1 = v_;
qo.sha224 = P_;
qo.sha256 = r5;
qo.sha384 = Y_;
qo.sha512 = l5;
var d5 = {}, ga = xe, X_ = Go, pc = ga.rotl32, B2 = ga.sum32, au = ga.sum32_3, N2 = ga.sum32_4, p5 = X_.BlockHash;
function ur() {
  if (!(this instanceof ur))
    return new ur();
  p5.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
ga.inherits(ur, p5);
d5.ripemd160 = ur;
ur.blockSize = 512;
ur.outSize = 160;
ur.hmacStrength = 192;
ur.padLength = 64;
ur.prototype._update = function(e, t) {
  for (var i = this.h[0], r = this.h[1], s = this.h[2], a = this.h[3], o = this.h[4], u = i, l = r, p = s, f = a, b = o, A = 0; A < 80; A++) {
    var x = B2(
      pc(
        N2(i, D2(A, r, s, a), e[tR[A] + t], Z_(A)),
        iR[A]
      ),
      o
    );
    i = o, o = a, a = pc(s, 10), s = r, r = x, x = B2(
      pc(
        N2(u, D2(79 - A, l, p, f), e[nR[A] + t], eR(A)),
        rR[A]
      ),
      b
    ), u = b, b = f, f = pc(p, 10), p = l, l = x;
  }
  x = au(this.h[1], s, f), this.h[1] = au(this.h[2], a, b), this.h[2] = au(this.h[3], o, u), this.h[3] = au(this.h[4], i, l), this.h[4] = au(this.h[0], r, p), this.h[0] = x;
};
ur.prototype._digest = function(e) {
  return e === "hex" ? ga.toHex32(this.h, "little") : ga.split32(this.h, "little");
};
function D2(n, e, t, i) {
  return n <= 15 ? e ^ t ^ i : n <= 31 ? e & t | ~e & i : n <= 47 ? (e | ~t) ^ i : n <= 63 ? e & i | t & ~i : e ^ (t | ~i);
}
function Z_(n) {
  return n <= 15 ? 0 : n <= 31 ? 1518500249 : n <= 47 ? 1859775393 : n <= 63 ? 2400959708 : 2840853838;
}
function eR(n) {
  return n <= 15 ? 1352829926 : n <= 31 ? 1548603684 : n <= 47 ? 1836072691 : n <= 63 ? 2053994217 : 0;
}
var tR = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], nR = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], iR = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], rR = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], sR = xe, aR = jl;
function Mo(n, e, t) {
  if (!(this instanceof Mo))
    return new Mo(n, e, t);
  this.Hash = n, this.blockSize = n.blockSize / 8, this.outSize = n.outSize / 8, this.inner = null, this.outer = null, this._init(sR.toArray(e, t));
}
var oR = Mo;
Mo.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), aR(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++)
    e.push(0);
  for (t = 0; t < e.length; t++)
    e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++)
    e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
Mo.prototype.update = function(e, t) {
  return this.inner.update(e, t), this;
};
Mo.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(n) {
  var e = n;
  e.utils = xe, e.common = Go, e.sha = qo, e.ripemd = d5, e.hmac = oR, e.sha1 = e.sha.sha1, e.sha256 = e.sha.sha256, e.sha224 = e.sha.sha224, e.sha384 = e.sha.sha384, e.sha512 = e.sha.sha512, e.ripemd160 = e.ripemd.ripemd160;
})(Mn);
function Ko(n, e, t) {
  return t = {
    path: e,
    exports: {},
    require: function(i, r) {
      return uR(i, r ?? t.path);
    }
  }, n(t, t.exports), t.exports;
}
function uR() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var b0 = f5;
function f5(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
f5.equal = function(e, t, i) {
  if (e != t)
    throw new Error(i || "Assertion failed: " + e + " != " + t);
};
var Bi = Ko(function(n, e) {
  var t = e;
  function i(a, o) {
    if (Array.isArray(a))
      return a.slice();
    if (!a)
      return [];
    var u = [];
    if (typeof a != "string") {
      for (var l = 0; l < a.length; l++)
        u[l] = a[l] | 0;
      return u;
    }
    if (o === "hex") {
      a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a);
      for (var l = 0; l < a.length; l += 2)
        u.push(parseInt(a[l] + a[l + 1], 16));
    } else
      for (var l = 0; l < a.length; l++) {
        var p = a.charCodeAt(l), f = p >> 8, b = p & 255;
        f ? u.push(f, b) : u.push(b);
      }
    return u;
  }
  t.toArray = i;
  function r(a) {
    return a.length === 1 ? "0" + a : a;
  }
  t.zero2 = r;
  function s(a) {
    for (var o = "", u = 0; u < a.length; u++)
      o += r(a[u].toString(16));
    return o;
  }
  t.toHex = s, t.encode = function(o, u) {
    return u === "hex" ? s(o) : o;
  };
}), ri = Ko(function(n, e) {
  var t = e;
  t.assert = b0, t.toArray = Bi.toArray, t.zero2 = Bi.zero2, t.toHex = Bi.toHex, t.encode = Bi.encode;
  function i(u, l, p) {
    var f = new Array(Math.max(u.bitLength(), p) + 1);
    f.fill(0);
    for (var b = 1 << l + 1, A = u.clone(), x = 0; x < f.length; x++) {
      var w, T = A.andln(b - 1);
      A.isOdd() ? (T > (b >> 1) - 1 ? w = (b >> 1) - T : w = T, A.isubn(w)) : w = 0, f[x] = w, A.iushrn(1);
    }
    return f;
  }
  t.getNAF = i;
  function r(u, l) {
    var p = [
      [],
      []
    ];
    u = u.clone(), l = l.clone();
    for (var f = 0, b = 0, A; u.cmpn(-f) > 0 || l.cmpn(-b) > 0; ) {
      var x = u.andln(3) + f & 3, w = l.andln(3) + b & 3;
      x === 3 && (x = -1), w === 3 && (w = -1);
      var T;
      x & 1 ? (A = u.andln(7) + f & 7, (A === 3 || A === 5) && w === 2 ? T = -x : T = x) : T = 0, p[0].push(T);
      var _;
      w & 1 ? (A = l.andln(7) + b & 7, (A === 3 || A === 5) && x === 2 ? _ = -w : _ = w) : _ = 0, p[1].push(_), 2 * f === T + 1 && (f = 1 - f), 2 * b === _ + 1 && (b = 1 - b), u.iushrn(1), l.iushrn(1);
    }
    return p;
  }
  t.getJSF = r;
  function s(u, l, p) {
    var f = "_" + l;
    u.prototype[l] = function() {
      return this[f] !== void 0 ? this[f] : this[f] = p.call(this);
    };
  }
  t.cachedProperty = s;
  function a(u) {
    return typeof u == "string" ? t.toArray(u, "hex") : u;
  }
  t.parseBytes = a;
  function o(u) {
    return new pe(u, "hex", "le");
  }
  t.intFromLE = o;
}), fd = ri.getNAF, lR = ri.getJSF, yd = ri.assert;
function Os(n, e) {
  this.type = n, this.p = new pe(e.p, 16), this.red = e.prime ? pe.red(e.prime) : pe.mont(this.p), this.zero = new pe(0).toRed(this.red), this.one = new pe(1).toRed(this.red), this.two = new pe(2).toRed(this.red), this.n = e.n && new pe(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var t = this.n && this.p.div(this.n);
  !t || t.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var Va = Os;
Os.prototype.point = function() {
  throw new Error("Not implemented");
};
Os.prototype.validate = function() {
  throw new Error("Not implemented");
};
Os.prototype._fixedNafMul = function(e, t) {
  yd(e.precomputed);
  var i = e._getDoubles(), r = fd(t, 1, this._bitLength), s = (1 << i.step + 1) - (i.step % 2 === 0 ? 2 : 1);
  s /= 3;
  var a = [], o, u;
  for (o = 0; o < r.length; o += i.step) {
    u = 0;
    for (var l = o + i.step - 1; l >= o; l--)
      u = (u << 1) + r[l];
    a.push(u);
  }
  for (var p = this.jpoint(null, null, null), f = this.jpoint(null, null, null), b = s; b > 0; b--) {
    for (o = 0; o < a.length; o++)
      u = a[o], u === b ? f = f.mixedAdd(i.points[o]) : u === -b && (f = f.mixedAdd(i.points[o].neg()));
    p = p.add(f);
  }
  return p.toP();
};
Os.prototype._wnafMul = function(e, t) {
  var i = 4, r = e._getNAFPoints(i);
  i = r.wnd;
  for (var s = r.points, a = fd(t, i, this._bitLength), o = this.jpoint(null, null, null), u = a.length - 1; u >= 0; u--) {
    for (var l = 0; u >= 0 && a[u] === 0; u--)
      l++;
    if (u >= 0 && l++, o = o.dblp(l), u < 0)
      break;
    var p = a[u];
    yd(p !== 0), e.type === "affine" ? p > 0 ? o = o.mixedAdd(s[p - 1 >> 1]) : o = o.mixedAdd(s[-p - 1 >> 1].neg()) : p > 0 ? o = o.add(s[p - 1 >> 1]) : o = o.add(s[-p - 1 >> 1].neg());
  }
  return e.type === "affine" ? o.toP() : o;
};
Os.prototype._wnafMulAdd = function(e, t, i, r, s) {
  var a = this._wnafT1, o = this._wnafT2, u = this._wnafT3, l = 0, p, f, b;
  for (p = 0; p < r; p++) {
    b = t[p];
    var A = b._getNAFPoints(e);
    a[p] = A.wnd, o[p] = A.points;
  }
  for (p = r - 1; p >= 1; p -= 2) {
    var x = p - 1, w = p;
    if (a[x] !== 1 || a[w] !== 1) {
      u[x] = fd(i[x], a[x], this._bitLength), u[w] = fd(i[w], a[w], this._bitLength), l = Math.max(u[x].length, l), l = Math.max(u[w].length, l);
      continue;
    }
    var T = [
      t[x],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      t[w]
      /* 7 */
    ];
    t[x].y.cmp(t[w].y) === 0 ? (T[1] = t[x].add(t[w]), T[2] = t[x].toJ().mixedAdd(t[w].neg())) : t[x].y.cmp(t[w].y.redNeg()) === 0 ? (T[1] = t[x].toJ().mixedAdd(t[w]), T[2] = t[x].add(t[w].neg())) : (T[1] = t[x].toJ().mixedAdd(t[w]), T[2] = t[x].toJ().mixedAdd(t[w].neg()));
    var _ = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], I = lR(i[x], i[w]);
    for (l = Math.max(I[0].length, l), u[x] = new Array(l), u[w] = new Array(l), f = 0; f < l; f++) {
      var $ = I[0][f] | 0, N = I[1][f] | 0;
      u[x][f] = _[($ + 1) * 3 + (N + 1)], u[w][f] = 0, o[x] = T;
    }
  }
  var B = this.jpoint(null, null, null), V = this._wnafT4;
  for (p = l; p >= 0; p--) {
    for (var K = 0; p >= 0; ) {
      var G = !0;
      for (f = 0; f < r; f++)
        V[f] = u[f][p] | 0, V[f] !== 0 && (G = !1);
      if (!G)
        break;
      K++, p--;
    }
    if (p >= 0 && K++, B = B.dblp(K), p < 0)
      break;
    for (f = 0; f < r; f++) {
      var Y = V[f];
      Y !== 0 && (Y > 0 ? b = o[f][Y - 1 >> 1] : Y < 0 && (b = o[f][-Y - 1 >> 1].neg()), b.type === "affine" ? B = B.mixedAdd(b) : B = B.add(b));
    }
  }
  for (p = 0; p < r; p++)
    o[p] = null;
  return s ? B : B.toP();
};
function xi(n, e) {
  this.curve = n, this.type = e, this.precomputed = null;
}
Os.BasePoint = xi;
xi.prototype.eq = function() {
  throw new Error("Not implemented");
};
xi.prototype.validate = function() {
  return this.curve.validate(this);
};
Os.prototype.decodePoint = function(e, t) {
  e = ri.toArray(e, t);
  var i = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * i) {
    e[0] === 6 ? yd(e[e.length - 1] % 2 === 0) : e[0] === 7 && yd(e[e.length - 1] % 2 === 1);
    var r = this.point(
      e.slice(1, 1 + i),
      e.slice(1 + i, 1 + 2 * i)
    );
    return r;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === i)
    return this.pointFromX(e.slice(1, 1 + i), e[0] === 3);
  throw new Error("Unknown point format");
};
xi.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
xi.prototype._encode = function(e) {
  var t = this.curve.p.byteLength(), i = this.getX().toArray("be", t);
  return e ? [this.getY().isEven() ? 2 : 3].concat(i) : [4].concat(i, this.getY().toArray("be", t));
};
xi.prototype.encode = function(e, t) {
  return ri.encode(this._encode(t), e);
};
xi.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var t = {
    doubles: null,
    naf: null,
    beta: null
  };
  return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this;
};
xi.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
xi.prototype._getDoubles = function(e, t) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var i = [this], r = this, s = 0; s < t; s += e) {
    for (var a = 0; a < e; a++)
      r = r.dbl();
    i.push(r);
  }
  return {
    step: e,
    points: i
  };
};
xi.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var t = [this], i = (1 << e) - 1, r = i === 1 ? null : this.dbl(), s = 1; s < i; s++)
    t[s] = t[s - 1].add(r);
  return {
    wnd: e,
    points: t
  };
};
xi.prototype._getBeta = function() {
  return null;
};
xi.prototype.dblp = function(e) {
  for (var t = this, i = 0; i < e; i++)
    t = t.dbl();
  return t;
};
var g0 = Ko(function(n) {
  typeof Object.create == "function" ? n.exports = function(t, i) {
    i && (t.super_ = i, t.prototype = Object.create(i.prototype, {
      constructor: {
        value: t,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : n.exports = function(t, i) {
    if (i) {
      t.super_ = i;
      var r = function() {
      };
      r.prototype = i.prototype, t.prototype = new r(), t.prototype.constructor = t;
    }
  };
}), cR = ri.assert;
function Ti(n) {
  Va.call(this, "short", n), this.a = new pe(n.a, 16).toRed(this.red), this.b = new pe(n.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(n), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
g0(Ti, Va);
var dR = Ti;
Ti.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, i;
    if (e.beta)
      t = new pe(e.beta, 16).toRed(this.red);
    else {
      var r = this._getEndoRoots(this.p);
      t = r[0].cmp(r[1]) < 0 ? r[0] : r[1], t = t.toRed(this.red);
    }
    if (e.lambda)
      i = new pe(e.lambda, 16);
    else {
      var s = this._getEndoRoots(this.n);
      this.g.mul(s[0]).x.cmp(this.g.x.redMul(t)) === 0 ? i = s[0] : (i = s[1], cR(this.g.mul(i).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var a;
    return e.basis ? a = e.basis.map(function(o) {
      return {
        a: new pe(o.a, 16),
        b: new pe(o.b, 16)
      };
    }) : a = this._getEndoBasis(i), {
      beta: t,
      lambda: i,
      basis: a
    };
  }
};
Ti.prototype._getEndoRoots = function(e) {
  var t = e === this.p ? this.red : pe.mont(e), i = new pe(2).toRed(t).redInvm(), r = i.redNeg(), s = new pe(3).toRed(t).redNeg().redSqrt().redMul(i), a = r.redAdd(s).fromRed(), o = r.redSub(s).fromRed();
  return [a, o];
};
Ti.prototype._getEndoBasis = function(e) {
  for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), i = e, r = this.n.clone(), s = new pe(1), a = new pe(0), o = new pe(0), u = new pe(1), l, p, f, b, A, x, w, T = 0, _, I; i.cmpn(0) !== 0; ) {
    var $ = r.div(i);
    _ = r.sub($.mul(i)), I = o.sub($.mul(s));
    var N = u.sub($.mul(a));
    if (!f && _.cmp(t) < 0)
      l = w.neg(), p = s, f = _.neg(), b = I;
    else if (f && ++T === 2)
      break;
    w = _, r = i, i = _, o = s, s = I, u = a, a = N;
  }
  A = _.neg(), x = I;
  var B = f.sqr().add(b.sqr()), V = A.sqr().add(x.sqr());
  return V.cmp(B) >= 0 && (A = l, x = p), f.negative && (f = f.neg(), b = b.neg()), A.negative && (A = A.neg(), x = x.neg()), [
    { a: f, b },
    { a: A, b: x }
  ];
};
Ti.prototype._endoSplit = function(e) {
  var t = this.endo.basis, i = t[0], r = t[1], s = r.b.mul(e).divRound(this.n), a = i.b.neg().mul(e).divRound(this.n), o = s.mul(i.a), u = a.mul(r.a), l = s.mul(i.b), p = a.mul(r.b), f = e.sub(o).sub(u), b = l.add(p).neg();
  return { k1: f, k2: b };
};
Ti.prototype.pointFromX = function(e, t) {
  e = new pe(e, 16), e.red || (e = e.toRed(this.red));
  var i = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), r = i.redSqrt();
  if (r.redSqr().redSub(i).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var s = r.fromRed().isOdd();
  return (t && !s || !t && s) && (r = r.redNeg()), this.point(e, r);
};
Ti.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var t = e.x, i = e.y, r = this.a.redMul(t), s = t.redSqr().redMul(t).redIAdd(r).redIAdd(this.b);
  return i.redSqr().redISub(s).cmpn(0) === 0;
};
Ti.prototype._endoWnafMulAdd = function(e, t, i) {
  for (var r = this._endoWnafT1, s = this._endoWnafT2, a = 0; a < e.length; a++) {
    var o = this._endoSplit(t[a]), u = e[a], l = u._getBeta();
    o.k1.negative && (o.k1.ineg(), u = u.neg(!0)), o.k2.negative && (o.k2.ineg(), l = l.neg(!0)), r[a * 2] = u, r[a * 2 + 1] = l, s[a * 2] = o.k1, s[a * 2 + 1] = o.k2;
  }
  for (var p = this._wnafMulAdd(1, r, s, a * 2, i), f = 0; f < a * 2; f++)
    r[f] = null, s[f] = null;
  return p;
};
function tn(n, e, t, i) {
  Va.BasePoint.call(this, n, "affine"), e === null && t === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new pe(e, 16), this.y = new pe(t, 16), i && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
g0(tn, Va.BasePoint);
Ti.prototype.point = function(e, t, i) {
  return new tn(this, e, t, i);
};
Ti.prototype.pointFromJSON = function(e, t) {
  return tn.fromJSON(this, e, t);
};
tn.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var i = this.curve, r = function(s) {
        return i.point(s.x.redMul(i.endo.beta), s.y);
      };
      e.beta = t, t.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(r)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(r)
        }
      };
    }
    return t;
  }
};
tn.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
tn.fromJSON = function(e, t, i) {
  typeof t == "string" && (t = JSON.parse(t));
  var r = e.point(t[0], t[1], i);
  if (!t[2])
    return r;
  function s(o) {
    return e.point(o[0], o[1], i);
  }
  var a = t[2];
  return r.precomputed = {
    beta: null,
    doubles: a.doubles && {
      step: a.doubles.step,
      points: [r].concat(a.doubles.points.map(s))
    },
    naf: a.naf && {
      wnd: a.naf.wnd,
      points: [r].concat(a.naf.points.map(s))
    }
  }, r;
};
tn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
tn.prototype.isInfinity = function() {
  return this.inf;
};
tn.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var i = t.redSqr().redISub(this.x).redISub(e.x), r = t.redMul(this.x.redSub(i)).redISub(this.y);
  return this.curve.point(i, r);
};
tn.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var t = this.curve.a, i = this.x.redSqr(), r = e.redInvm(), s = i.redAdd(i).redIAdd(i).redIAdd(t).redMul(r), a = s.redSqr().redISub(this.x.redAdd(this.x)), o = s.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, o);
};
tn.prototype.getX = function() {
  return this.x.fromRed();
};
tn.prototype.getY = function() {
  return this.y.fromRed();
};
tn.prototype.mul = function(e) {
  return e = new pe(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
tn.prototype.mulAdd = function(e, t, i) {
  var r = [this, t], s = [e, i];
  return this.curve.endo ? this.curve._endoWnafMulAdd(r, s) : this.curve._wnafMulAdd(1, r, s, 2);
};
tn.prototype.jmulAdd = function(e, t, i) {
  var r = [this, t], s = [e, i];
  return this.curve.endo ? this.curve._endoWnafMulAdd(r, s, !0) : this.curve._wnafMulAdd(1, r, s, 2, !0);
};
tn.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
tn.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var i = this.precomputed, r = function(s) {
      return s.neg();
    };
    t.precomputed = {
      naf: i.naf && {
        wnd: i.naf.wnd,
        points: i.naf.points.map(r)
      },
      doubles: i.doubles && {
        step: i.doubles.step,
        points: i.doubles.points.map(r)
      }
    };
  }
  return t;
};
tn.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function cn(n, e, t, i) {
  Va.BasePoint.call(this, n, "jacobian"), e === null && t === null && i === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new pe(0)) : (this.x = new pe(e, 16), this.y = new pe(t, 16), this.z = new pe(i, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
g0(cn, Va.BasePoint);
Ti.prototype.jpoint = function(e, t, i) {
  return new cn(this, e, t, i);
};
cn.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), t = e.redSqr(), i = this.x.redMul(t), r = this.y.redMul(t).redMul(e);
  return this.curve.point(i, r);
};
cn.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
cn.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var t = e.z.redSqr(), i = this.z.redSqr(), r = this.x.redMul(t), s = e.x.redMul(i), a = this.y.redMul(t.redMul(e.z)), o = e.y.redMul(i.redMul(this.z)), u = r.redSub(s), l = a.redSub(o);
  if (u.cmpn(0) === 0)
    return l.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var p = u.redSqr(), f = p.redMul(u), b = r.redMul(p), A = l.redSqr().redIAdd(f).redISub(b).redISub(b), x = l.redMul(b.redISub(A)).redISub(a.redMul(f)), w = this.z.redMul(e.z).redMul(u);
  return this.curve.jpoint(A, x, w);
};
cn.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var t = this.z.redSqr(), i = this.x, r = e.x.redMul(t), s = this.y, a = e.y.redMul(t).redMul(this.z), o = i.redSub(r), u = s.redSub(a);
  if (o.cmpn(0) === 0)
    return u.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var l = o.redSqr(), p = l.redMul(o), f = i.redMul(l), b = u.redSqr().redIAdd(p).redISub(f).redISub(f), A = u.redMul(f.redISub(b)).redISub(s.redMul(p)), x = this.z.redMul(o);
  return this.curve.jpoint(b, A, x);
};
cn.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var i = this;
    for (t = 0; t < e; t++)
      i = i.dbl();
    return i;
  }
  var r = this.curve.a, s = this.curve.tinv, a = this.x, o = this.y, u = this.z, l = u.redSqr().redSqr(), p = o.redAdd(o);
  for (t = 0; t < e; t++) {
    var f = a.redSqr(), b = p.redSqr(), A = b.redSqr(), x = f.redAdd(f).redIAdd(f).redIAdd(r.redMul(l)), w = a.redMul(b), T = x.redSqr().redISub(w.redAdd(w)), _ = w.redISub(T), I = x.redMul(_);
    I = I.redIAdd(I).redISub(A);
    var $ = p.redMul(u);
    t + 1 < e && (l = l.redMul(A)), a = T, u = $, p = I;
  }
  return this.curve.jpoint(a, p.redMul(s), u);
};
cn.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
cn.prototype._zeroDbl = function() {
  var e, t, i;
  if (this.zOne) {
    var r = this.x.redSqr(), s = this.y.redSqr(), a = s.redSqr(), o = this.x.redAdd(s).redSqr().redISub(r).redISub(a);
    o = o.redIAdd(o);
    var u = r.redAdd(r).redIAdd(r), l = u.redSqr().redISub(o).redISub(o), p = a.redIAdd(a);
    p = p.redIAdd(p), p = p.redIAdd(p), e = l, t = u.redMul(o.redISub(l)).redISub(p), i = this.y.redAdd(this.y);
  } else {
    var f = this.x.redSqr(), b = this.y.redSqr(), A = b.redSqr(), x = this.x.redAdd(b).redSqr().redISub(f).redISub(A);
    x = x.redIAdd(x);
    var w = f.redAdd(f).redIAdd(f), T = w.redSqr(), _ = A.redIAdd(A);
    _ = _.redIAdd(_), _ = _.redIAdd(_), e = T.redISub(x).redISub(x), t = w.redMul(x.redISub(e)).redISub(_), i = this.y.redMul(this.z), i = i.redIAdd(i);
  }
  return this.curve.jpoint(e, t, i);
};
cn.prototype._threeDbl = function() {
  var e, t, i;
  if (this.zOne) {
    var r = this.x.redSqr(), s = this.y.redSqr(), a = s.redSqr(), o = this.x.redAdd(s).redSqr().redISub(r).redISub(a);
    o = o.redIAdd(o);
    var u = r.redAdd(r).redIAdd(r).redIAdd(this.curve.a), l = u.redSqr().redISub(o).redISub(o);
    e = l;
    var p = a.redIAdd(a);
    p = p.redIAdd(p), p = p.redIAdd(p), t = u.redMul(o.redISub(l)).redISub(p), i = this.y.redAdd(this.y);
  } else {
    var f = this.z.redSqr(), b = this.y.redSqr(), A = this.x.redMul(b), x = this.x.redSub(f).redMul(this.x.redAdd(f));
    x = x.redAdd(x).redIAdd(x);
    var w = A.redIAdd(A);
    w = w.redIAdd(w);
    var T = w.redAdd(w);
    e = x.redSqr().redISub(T), i = this.y.redAdd(this.z).redSqr().redISub(b).redISub(f);
    var _ = b.redSqr();
    _ = _.redIAdd(_), _ = _.redIAdd(_), _ = _.redIAdd(_), t = x.redMul(w.redISub(e)).redISub(_);
  }
  return this.curve.jpoint(e, t, i);
};
cn.prototype._dbl = function() {
  var e = this.curve.a, t = this.x, i = this.y, r = this.z, s = r.redSqr().redSqr(), a = t.redSqr(), o = i.redSqr(), u = a.redAdd(a).redIAdd(a).redIAdd(e.redMul(s)), l = t.redAdd(t);
  l = l.redIAdd(l);
  var p = l.redMul(o), f = u.redSqr().redISub(p.redAdd(p)), b = p.redISub(f), A = o.redSqr();
  A = A.redIAdd(A), A = A.redIAdd(A), A = A.redIAdd(A);
  var x = u.redMul(b).redISub(A), w = i.redAdd(i).redMul(r);
  return this.curve.jpoint(f, x, w);
};
cn.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), t = this.y.redSqr(), i = this.z.redSqr(), r = t.redSqr(), s = e.redAdd(e).redIAdd(e), a = s.redSqr(), o = this.x.redAdd(t).redSqr().redISub(e).redISub(r);
  o = o.redIAdd(o), o = o.redAdd(o).redIAdd(o), o = o.redISub(a);
  var u = o.redSqr(), l = r.redIAdd(r);
  l = l.redIAdd(l), l = l.redIAdd(l), l = l.redIAdd(l);
  var p = s.redIAdd(o).redSqr().redISub(a).redISub(u).redISub(l), f = t.redMul(p);
  f = f.redIAdd(f), f = f.redIAdd(f);
  var b = this.x.redMul(u).redISub(f);
  b = b.redIAdd(b), b = b.redIAdd(b);
  var A = this.y.redMul(p.redMul(l.redISub(p)).redISub(o.redMul(u)));
  A = A.redIAdd(A), A = A.redIAdd(A), A = A.redIAdd(A);
  var x = this.z.redAdd(o).redSqr().redISub(i).redISub(u);
  return this.curve.jpoint(b, A, x);
};
cn.prototype.mul = function(e, t) {
  return e = new pe(e, t), this.curve._wnafMul(this, e);
};
cn.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var t = this.z.redSqr(), i = e.z.redSqr();
  if (this.x.redMul(i).redISub(e.x.redMul(t)).cmpn(0) !== 0)
    return !1;
  var r = t.redMul(this.z), s = i.redMul(e.z);
  return this.y.redMul(s).redISub(e.y.redMul(r)).cmpn(0) === 0;
};
cn.prototype.eqXToP = function(e) {
  var t = this.z.redSqr(), i = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(i) === 0)
    return !0;
  for (var r = e.clone(), s = this.curve.redN.redMul(t); ; ) {
    if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0)
      return !1;
    if (i.redIAdd(s), this.x.cmp(i) === 0)
      return !0;
  }
};
cn.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
cn.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var Bc = Ko(function(n, e) {
  var t = e;
  t.base = Va, t.short = dR, t.mont = /*RicMoo:ethers:require(./mont)*/
  null, t.edwards = /*RicMoo:ethers:require(./edwards)*/
  null;
}), Nc = Ko(function(n, e) {
  var t = e, i = ri.assert;
  function r(o) {
    o.type === "short" ? this.curve = new Bc.short(o) : o.type === "edwards" ? this.curve = new Bc.edwards(o) : this.curve = new Bc.mont(o), this.g = this.curve.g, this.n = this.curve.n, this.hash = o.hash, i(this.g.validate(), "Invalid curve"), i(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = r;
  function s(o, u) {
    Object.defineProperty(t, o, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var l = new r(u);
        return Object.defineProperty(t, o, {
          configurable: !0,
          enumerable: !0,
          value: l
        }), l;
      }
    });
  }
  s("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: Mn.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), s("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: Mn.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), s("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: Mn.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), s("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: Mn.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), s("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: Mn.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), s("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Mn.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), s("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: Mn.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var a;
  try {
    a = /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch {
    a = void 0;
  }
  s("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: Mn.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      a
    ]
  });
});
function Cs(n) {
  if (!(this instanceof Cs))
    return new Cs(n);
  this.hash = n.hash, this.predResist = !!n.predResist, this.outLen = this.hash.outSize, this.minEntropy = n.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var e = Bi.toArray(n.entropy, n.entropyEnc || "hex"), t = Bi.toArray(n.nonce, n.nonceEnc || "hex"), i = Bi.toArray(n.pers, n.persEnc || "hex");
  b0(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(e, t, i);
}
var y5 = Cs;
Cs.prototype._init = function(e, t, i) {
  var r = e.concat(t).concat(i);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var s = 0; s < this.V.length; s++)
    this.K[s] = 0, this.V[s] = 1;
  this._update(r), this._reseed = 1, this.reseedInterval = 281474976710656;
};
Cs.prototype._hmac = function() {
  return new Mn.hmac(this.hash, this.K);
};
Cs.prototype._update = function(e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
Cs.prototype.reseed = function(e, t, i, r) {
  typeof t != "string" && (r = i, i = t, t = null), e = Bi.toArray(e, t), i = Bi.toArray(i, r), b0(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(i || [])), this._reseed = 1;
};
Cs.prototype.generate = function(e, t, i, r) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof t != "string" && (r = i, i = t, t = null), i && (i = Bi.toArray(i, r || "hex"), this._update(i));
  for (var s = []; s.length < e; )
    this.V = this._hmac().update(this.V).digest(), s = s.concat(this.V);
  var a = s.slice(0, e);
  return this._update(i), this._reseed++, Bi.encode(a, t);
};
var Ry = ri.assert;
function Tn(n, e) {
  this.ec = n, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
}
var v0 = Tn;
Tn.fromPublic = function(e, t, i) {
  return t instanceof Tn ? t : new Tn(e, {
    pub: t,
    pubEnc: i
  });
};
Tn.fromPrivate = function(e, t, i) {
  return t instanceof Tn ? t : new Tn(e, {
    priv: t,
    privEnc: i
  });
};
Tn.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
Tn.prototype.getPublic = function(e, t) {
  return typeof e == "string" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;
};
Tn.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
Tn.prototype._importPrivate = function(e, t) {
  this.priv = new pe(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
Tn.prototype._importPublic = function(e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? Ry(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && Ry(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
Tn.prototype.derive = function(e) {
  return e.validate() || Ry(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
Tn.prototype.sign = function(e, t, i) {
  return this.ec.sign(e, this, t, i);
};
Tn.prototype.verify = function(e, t) {
  return this.ec.verify(e, t, this);
};
Tn.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var pR = ri.assert;
function up(n, e) {
  if (n instanceof up)
    return n;
  this._importDER(n, e) || (pR(n.r && n.s, "Signature without r or s"), this.r = new pe(n.r, 16), this.s = new pe(n.s, 16), n.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = n.recoveryParam);
}
var lp = up;
function fR() {
  this.place = 0;
}
function Mf(n, e) {
  var t = n[e.place++];
  if (!(t & 128))
    return t;
  var i = t & 15;
  if (i === 0 || i > 4)
    return !1;
  for (var r = 0, s = 0, a = e.place; s < i; s++, a++)
    r <<= 8, r |= n[a], r >>>= 0;
  return r <= 127 ? !1 : (e.place = a, r);
}
function $2(n) {
  for (var e = 0, t = n.length - 1; !n[e] && !(n[e + 1] & 128) && e < t; )
    e++;
  return e === 0 ? n : n.slice(e);
}
up.prototype._importDER = function(e, t) {
  e = ri.toArray(e, t);
  var i = new fR();
  if (e[i.place++] !== 48)
    return !1;
  var r = Mf(e, i);
  if (r === !1 || r + i.place !== e.length || e[i.place++] !== 2)
    return !1;
  var s = Mf(e, i);
  if (s === !1)
    return !1;
  var a = e.slice(i.place, s + i.place);
  if (i.place += s, e[i.place++] !== 2)
    return !1;
  var o = Mf(e, i);
  if (o === !1 || e.length !== o + i.place)
    return !1;
  var u = e.slice(i.place, o + i.place);
  if (a[0] === 0)
    if (a[1] & 128)
      a = a.slice(1);
    else
      return !1;
  if (u[0] === 0)
    if (u[1] & 128)
      u = u.slice(1);
    else
      return !1;
  return this.r = new pe(a), this.s = new pe(u), this.recoveryParam = null, !0;
};
function Cf(n, e) {
  if (e < 128) {
    n.push(e);
    return;
  }
  var t = 1 + (Math.log(e) / Math.LN2 >>> 3);
  for (n.push(t | 128); --t; )
    n.push(e >>> (t << 3) & 255);
  n.push(e);
}
up.prototype.toDER = function(e) {
  var t = this.r.toArray(), i = this.s.toArray();
  for (t[0] & 128 && (t = [0].concat(t)), i[0] & 128 && (i = [0].concat(i)), t = $2(t), i = $2(i); !i[0] && !(i[1] & 128); )
    i = i.slice(1);
  var r = [2];
  Cf(r, t.length), r = r.concat(t), r.push(2), Cf(r, i.length);
  var s = r.concat(i), a = [48];
  return Cf(a, s.length), a = a.concat(s), ri.encode(a, e);
};
var yR = (
  /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }
), h5 = ri.assert;
function gi(n) {
  if (!(this instanceof gi))
    return new gi(n);
  typeof n == "string" && (h5(
    Object.prototype.hasOwnProperty.call(Nc, n),
    "Unknown curve " + n
  ), n = Nc[n]), n instanceof Nc.PresetCurve && (n = { curve: n }), this.curve = n.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = n.curve.g, this.g.precompute(n.curve.n.bitLength() + 1), this.hash = n.hash || n.curve.hash;
}
var hR = gi;
gi.prototype.keyPair = function(e) {
  return new v0(this, e);
};
gi.prototype.keyFromPrivate = function(e, t) {
  return v0.fromPrivate(this, e, t);
};
gi.prototype.keyFromPublic = function(e, t) {
  return v0.fromPublic(this, e, t);
};
gi.prototype.genKeyPair = function(e) {
  e || (e = {});
  for (var t = new y5({
    hash: this.hash,
    pers: e.pers,
    persEnc: e.persEnc || "utf8",
    entropy: e.entropy || yR(this.hash.hmacStrength),
    entropyEnc: e.entropy && e.entropyEnc || "utf8",
    nonce: this.n.toArray()
  }), i = this.n.byteLength(), r = this.n.sub(new pe(2)); ; ) {
    var s = new pe(t.generate(i));
    if (!(s.cmp(r) > 0))
      return s.iaddn(1), this.keyFromPrivate(s);
  }
};
gi.prototype._truncateToN = function(e, t) {
  var i = e.byteLength() * 8 - this.n.bitLength();
  return i > 0 && (e = e.ushrn(i)), !t && e.cmp(this.n) >= 0 ? e.sub(this.n) : e;
};
gi.prototype.sign = function(e, t, i, r) {
  typeof i == "object" && (r = i, i = null), r || (r = {}), t = this.keyFromPrivate(t, i), e = this._truncateToN(new pe(e, 16));
  for (var s = this.n.byteLength(), a = t.getPrivate().toArray("be", s), o = e.toArray("be", s), u = new y5({
    hash: this.hash,
    entropy: a,
    nonce: o,
    pers: r.pers,
    persEnc: r.persEnc || "utf8"
  }), l = this.n.sub(new pe(1)), p = 0; ; p++) {
    var f = r.k ? r.k(p) : new pe(u.generate(this.n.byteLength()));
    if (f = this._truncateToN(f, !0), !(f.cmpn(1) <= 0 || f.cmp(l) >= 0)) {
      var b = this.g.mul(f);
      if (!b.isInfinity()) {
        var A = b.getX(), x = A.umod(this.n);
        if (x.cmpn(0) !== 0) {
          var w = f.invm(this.n).mul(x.mul(t.getPrivate()).iadd(e));
          if (w = w.umod(this.n), w.cmpn(0) !== 0) {
            var T = (b.getY().isOdd() ? 1 : 0) | (A.cmp(x) !== 0 ? 2 : 0);
            return r.canonical && w.cmp(this.nh) > 0 && (w = this.n.sub(w), T ^= 1), new lp({ r: x, s: w, recoveryParam: T });
          }
        }
      }
    }
  }
};
gi.prototype.verify = function(e, t, i, r) {
  e = this._truncateToN(new pe(e, 16)), i = this.keyFromPublic(i, r), t = new lp(t, "hex");
  var s = t.r, a = t.s;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0 || a.cmpn(1) < 0 || a.cmp(this.n) >= 0)
    return !1;
  var o = a.invm(this.n), u = o.mul(e).umod(this.n), l = o.mul(s).umod(this.n), p;
  return this.curve._maxwellTrick ? (p = this.g.jmulAdd(u, i.getPublic(), l), p.isInfinity() ? !1 : p.eqXToP(s)) : (p = this.g.mulAdd(u, i.getPublic(), l), p.isInfinity() ? !1 : p.getX().umod(this.n).cmp(s) === 0);
};
gi.prototype.recoverPubKey = function(n, e, t, i) {
  h5((3 & t) === t, "The recovery param is more than two bits"), e = new lp(e, i);
  var r = this.n, s = new pe(n), a = e.r, o = e.s, u = t & 1, l = t >> 1;
  if (a.cmp(this.curve.p.umod(this.curve.n)) >= 0 && l)
    throw new Error("Unable to find sencond key candinate");
  l ? a = this.curve.pointFromX(a.add(this.curve.n), u) : a = this.curve.pointFromX(a, u);
  var p = e.r.invm(r), f = r.sub(s).mul(p).umod(r), b = o.mul(p).umod(r);
  return this.g.mulAdd(f, a, b);
};
gi.prototype.getKeyRecoveryParam = function(n, e, t, i) {
  if (e = new lp(e, i), e.recoveryParam !== null)
    return e.recoveryParam;
  for (var r = 0; r < 4; r++) {
    var s;
    try {
      s = this.recoverPubKey(n, e, r);
    } catch {
      continue;
    }
    if (s.eq(t))
      return r;
  }
  throw new Error("Unable to find valid recovery factor");
};
var mR = Ko(function(n, e) {
  var t = e;
  t.version = "6.5.4", t.utils = ri, t.rand = /*RicMoo:ethers:require(brorand)*/
  function() {
    throw new Error("unsupported");
  }, t.curve = Bc, t.curves = Nc, t.ec = hR, t.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
}), bR = mR.ec;
const gR = "signing-key/5.7.0", ky = new O(gR);
let _f = null;
function qi() {
  return _f || (_f = new bR("secp256k1")), _f;
}
class ca {
  constructor(e) {
    U(this, "curve", "secp256k1"), U(this, "privateKey", H(e)), rr(this.privateKey) !== 32 && ky.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    const t = qi().keyFromPrivate(q(this.privateKey));
    U(this, "publicKey", "0x" + t.getPublic(!1, "hex")), U(this, "compressedPublicKey", "0x" + t.getPublic(!0, "hex")), U(this, "_isSigningKey", !0);
  }
  _addPoint(e) {
    const t = qi().keyFromPublic(q(this.publicKey)), i = qi().keyFromPublic(q(e));
    return "0x" + t.pub.add(i.pub).encodeCompressed("hex");
  }
  signDigest(e) {
    const t = qi().keyFromPrivate(q(this.privateKey)), i = q(e);
    i.length !== 32 && ky.throwArgumentError("bad digest length", "digest", e);
    const r = t.sign(i, { canonical: !0 });
    return Fa({
      recoveryParam: r.recoveryParam,
      r: De("0x" + r.r.toString(16), 32),
      s: De("0x" + r.s.toString(16), 32)
    });
  }
  computeSharedSecret(e) {
    const t = qi().keyFromPrivate(q(this.privateKey)), i = qi().keyFromPublic(q(x0(e)));
    return De("0x" + t.derive(i.getPublic()).toString(16), 32);
  }
  static isSigningKey(e) {
    return !!(e && e._isSigningKey);
  }
}
function m5(n, e) {
  const t = Fa(e), i = { r: q(t.r), s: q(t.s) };
  return "0x" + qi().recoverPubKey(q(n), i, t.recoveryParam).encode("hex", !1);
}
function x0(n, e) {
  const t = q(n);
  if (t.length === 32) {
    const i = new ca(t);
    return e ? "0x" + qi().keyFromPrivate(t).getPublic(!0, "hex") : i.publicKey;
  } else {
    if (t.length === 33)
      return e ? H(t) : "0x" + qi().keyFromPublic(t).getPublic(!1, "hex");
    if (t.length === 65)
      return e ? "0x" + qi().keyFromPublic(t).getPublic(!0, "hex") : H(t);
  }
  return ky.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
const vR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SigningKey: ca,
  computePublicKey: x0,
  recoverPublicKey: m5
}, Symbol.toStringTag, { value: "Module" })), xR = "transactions/5.7.0", gn = new O(xR);
var Py;
(function(n) {
  n[n.legacy = 0] = "legacy", n[n.eip2930 = 1] = "eip2930", n[n.eip1559 = 2] = "eip1559";
})(Py || (Py = {}));
function T0(n) {
  return n === "0x" ? null : Be(n);
}
function mn(n) {
  return n === "0x" ? u0 : z.from(n);
}
const TR = [
  { name: "nonce", maxLength: 32, numeric: !0 },
  { name: "gasPrice", maxLength: 32, numeric: !0 },
  { name: "gasLimit", maxLength: 32, numeric: !0 },
  { name: "to", length: 20 },
  { name: "value", maxLength: 32, numeric: !0 },
  { name: "data" }
], wR = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  type: !0,
  value: !0
};
function vs(n) {
  const e = x0(n);
  return Be(Bt(Ie(Bt(e, 1)), 12));
}
function Wo(n, e) {
  return vs(m5(q(n), e));
}
function Qn(n, e) {
  const t = Zi(z.from(n).toHexString());
  return t.length > 32 && gn.throwArgumentError("invalid length for " + e, "transaction:" + e, n), t;
}
function Rf(n, e) {
  return {
    address: Be(n),
    storageKeys: (e || []).map((t, i) => (rr(t) !== 32 && gn.throwArgumentError("invalid access list storageKey", `accessList[${n}:${i}]`, t), t.toLowerCase()))
  };
}
function ja(n) {
  if (Array.isArray(n))
    return n.map((t, i) => Array.isArray(t) ? (t.length > 2 && gn.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${i}]`, t), Rf(t[0], t[1])) : Rf(t.address, t.storageKeys));
  const e = Object.keys(n).map((t) => {
    const i = n[t].reduce((r, s) => (r[s] = !0, r), {});
    return Rf(t, Object.keys(i).sort());
  });
  return e.sort((t, i) => t.address.localeCompare(i.address)), e;
}
function b5(n) {
  return ja(n).map((e) => [e.address, e.storageKeys]);
}
function g5(n, e) {
  if (n.gasPrice != null) {
    const i = z.from(n.gasPrice), r = z.from(n.maxFeePerGas || 0);
    i.eq(r) || gn.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
      gasPrice: i,
      maxFeePerGas: r
    });
  }
  const t = [
    Qn(n.chainId || 0, "chainId"),
    Qn(n.nonce || 0, "nonce"),
    Qn(n.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    Qn(n.maxFeePerGas || 0, "maxFeePerGas"),
    Qn(n.gasLimit || 0, "gasLimit"),
    n.to != null ? Be(n.to) : "0x",
    Qn(n.value || 0, "value"),
    n.data || "0x",
    b5(n.accessList || [])
  ];
  if (e) {
    const i = Fa(e);
    t.push(Qn(i.recoveryParam, "recoveryParam")), t.push(Zi(i.r)), t.push(Zi(i.s));
  }
  return Cn(["0x02", Ms(t)]);
}
function v5(n, e) {
  const t = [
    Qn(n.chainId || 0, "chainId"),
    Qn(n.nonce || 0, "nonce"),
    Qn(n.gasPrice || 0, "gasPrice"),
    Qn(n.gasLimit || 0, "gasLimit"),
    n.to != null ? Be(n.to) : "0x",
    Qn(n.value || 0, "value"),
    n.data || "0x",
    b5(n.accessList || [])
  ];
  if (e) {
    const i = Fa(e);
    t.push(Qn(i.recoveryParam, "recoveryParam")), t.push(Zi(i.r)), t.push(Zi(i.s));
  }
  return Cn(["0x01", Ms(t)]);
}
function AR(n, e) {
  r0(n, wR);
  const t = [];
  TR.forEach(function(a) {
    let o = n[a.name] || [];
    const u = {};
    a.numeric && (u.hexPad = "left"), o = q(H(o, u)), a.length && o.length !== a.length && o.length > 0 && gn.throwArgumentError("invalid length for " + a.name, "transaction:" + a.name, o), a.maxLength && (o = Zi(o), o.length > a.maxLength && gn.throwArgumentError("invalid length for " + a.name, "transaction:" + a.name, o)), t.push(H(o));
  });
  let i = 0;
  if (n.chainId != null ? (i = n.chainId, typeof i != "number" && gn.throwArgumentError("invalid transaction.chainId", "transaction", n)) : e && !Ll(e) && e.v > 28 && (i = Math.floor((e.v - 35) / 2)), i !== 0 && (t.push(H(i)), t.push("0x"), t.push("0x")), !e)
    return Ms(t);
  const r = Fa(e);
  let s = 27 + r.recoveryParam;
  return i !== 0 ? (t.pop(), t.pop(), t.pop(), s += i * 2 + 8, r.v > 28 && r.v !== s && gn.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e)) : r.v !== s && gn.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e), t.push(H(s)), t.push(Zi(q(r.r))), t.push(Zi(q(r.s))), Ms(t);
}
function Iy(n, e) {
  if (n.type == null || n.type === 0)
    return n.accessList != null && gn.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", n), AR(n, e);
  switch (n.type) {
    case 1:
      return v5(n, e);
    case 2:
      return g5(n, e);
  }
  return gn.throwError(`unsupported transaction type: ${n.type}`, O.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: n.type
  });
}
function x5(n, e, t) {
  try {
    const i = mn(e[0]).toNumber();
    if (i !== 0 && i !== 1)
      throw new Error("bad recid");
    n.v = i;
  } catch {
    gn.throwArgumentError("invalid v for transaction type: 1", "v", e[0]);
  }
  n.r = De(e[1], 32), n.s = De(e[2], 32);
  try {
    const i = Ie(t(n));
    n.from = Wo(i, { r: n.r, s: n.s, recoveryParam: n.v });
  } catch {
  }
}
function ER(n) {
  const e = Vl(n.slice(1));
  e.length !== 9 && e.length !== 12 && gn.throwArgumentError("invalid component count for transaction type: 2", "payload", H(n));
  const t = mn(e[2]), i = mn(e[3]), r = {
    type: 2,
    chainId: mn(e[0]).toNumber(),
    nonce: mn(e[1]).toNumber(),
    maxPriorityFeePerGas: t,
    maxFeePerGas: i,
    gasPrice: null,
    gasLimit: mn(e[4]),
    to: T0(e[5]),
    value: mn(e[6]),
    data: e[7],
    accessList: ja(e[8])
  };
  return e.length === 9 || (r.hash = Ie(n), x5(r, e.slice(9), g5)), r;
}
function SR(n) {
  const e = Vl(n.slice(1));
  e.length !== 8 && e.length !== 11 && gn.throwArgumentError("invalid component count for transaction type: 1", "payload", H(n));
  const t = {
    type: 1,
    chainId: mn(e[0]).toNumber(),
    nonce: mn(e[1]).toNumber(),
    gasPrice: mn(e[2]),
    gasLimit: mn(e[3]),
    to: T0(e[4]),
    value: mn(e[5]),
    data: e[6],
    accessList: ja(e[7])
  };
  return e.length === 8 || (t.hash = Ie(n), x5(t, e.slice(8), v5)), t;
}
function MR(n) {
  const e = Vl(n);
  e.length !== 9 && e.length !== 6 && gn.throwArgumentError("invalid raw transaction", "rawTransaction", n);
  const t = {
    nonce: mn(e[0]).toNumber(),
    gasPrice: mn(e[1]),
    gasLimit: mn(e[2]),
    to: T0(e[3]),
    value: mn(e[4]),
    data: e[5],
    chainId: 0
  };
  if (e.length === 6)
    return t;
  try {
    t.v = z.from(e[6]).toNumber();
  } catch {
    return t;
  }
  if (t.r = De(e[7], 32), t.s = De(e[8], 32), z.from(t.r).isZero() && z.from(t.s).isZero())
    t.chainId = t.v, t.v = 0;
  else {
    t.chainId = Math.floor((t.v - 35) / 2), t.chainId < 0 && (t.chainId = 0);
    let i = t.v - 27;
    const r = e.slice(0, 6);
    t.chainId !== 0 && (r.push(H(t.chainId)), r.push("0x"), r.push("0x"), i -= t.chainId * 2 + 8);
    const s = Ie(Ms(r));
    try {
      t.from = Wo(s, { r: H(t.r), s: H(t.s), recoveryParam: i });
    } catch {
    }
    t.hash = Ie(n);
  }
  return t.type = null, t;
}
function T5(n) {
  const e = q(n);
  if (e[0] > 127)
    return MR(e);
  switch (e[0]) {
    case 1:
      return SR(e);
    case 2:
      return ER(e);
  }
  return gn.throwError(`unsupported transaction type: ${e[0]}`, O.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: e[0]
  });
}
const CR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get TransactionTypes() {
    return Py;
  },
  accessListify: ja,
  computeAddress: vs,
  parse: T5,
  recoverAddress: Wo,
  serialize: Iy
}, Symbol.toStringTag, { value: "Module" })), _R = "contracts/5.7.0";
var va = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
const It = new O(_R);
function hd(n, e) {
  return va(this, void 0, void 0, function* () {
    const t = yield e;
    typeof t != "string" && It.throwArgumentError("invalid address or ENS name", "name", t);
    try {
      return Be(t);
    } catch {
    }
    n || It.throwError("a provider or signer is needed to resolve ENS names", O.errors.UNSUPPORTED_OPERATION, {
      operation: "resolveName"
    });
    const i = yield n.resolveName(t);
    return i == null && It.throwArgumentError("resolver or addr is not configured for ENS name", "name", t), i;
  });
}
function Dc(n, e, t) {
  return va(this, void 0, void 0, function* () {
    return Array.isArray(t) ? yield Promise.all(t.map((i, r) => Dc(n, Array.isArray(e) ? e[r] : e[i.name], i))) : t.type === "address" ? yield hd(n, e) : t.type === "tuple" ? yield Dc(n, e, t.components) : t.baseType === "array" ? Array.isArray(e) ? yield Promise.all(e.map((i) => Dc(n, i, t.arrayChildren))) : Promise.reject(It.makeError("invalid value for array", O.errors.INVALID_ARGUMENT, {
      argument: "value",
      value: e
    })) : e;
  });
}
function cp(n, e, t) {
  return va(this, void 0, void 0, function* () {
    let i = {};
    t.length === e.inputs.length + 1 && typeof t[t.length - 1] == "object" && (i = Ut(t.pop())), It.checkArgumentCount(t.length, e.inputs.length, "passed to contract"), n.signer ? i.from ? i.from = _t({
      override: hd(n.signer, i.from),
      signer: n.signer.getAddress()
    }).then((l) => va(this, void 0, void 0, function* () {
      return Be(l.signer) !== l.override && It.throwError("Contract with a Signer cannot override from", O.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.from"
      }), l.override;
    })) : i.from = n.signer.getAddress() : i.from && (i.from = hd(n.provider, i.from));
    const r = yield _t({
      args: Dc(n.signer || n.provider, t, e.inputs),
      address: n.resolvedAddress,
      overrides: _t(i) || {}
    }), s = n.interface.encodeFunctionData(e, r.args), a = {
      data: s,
      to: r.address
    }, o = r.overrides;
    if (o.nonce != null && (a.nonce = z.from(o.nonce).toNumber()), o.gasLimit != null && (a.gasLimit = z.from(o.gasLimit)), o.gasPrice != null && (a.gasPrice = z.from(o.gasPrice)), o.maxFeePerGas != null && (a.maxFeePerGas = z.from(o.maxFeePerGas)), o.maxPriorityFeePerGas != null && (a.maxPriorityFeePerGas = z.from(o.maxPriorityFeePerGas)), o.from != null && (a.from = o.from), o.type != null && (a.type = o.type), o.accessList != null && (a.accessList = ja(o.accessList)), a.gasLimit == null && e.gas != null) {
      let l = 21e3;
      const p = q(s);
      for (let f = 0; f < p.length; f++)
        l += 4, p[f] && (l += 64);
      a.gasLimit = z.from(e.gas).add(l);
    }
    if (o.value) {
      const l = z.from(o.value);
      !l.isZero() && !e.payable && It.throwError("non-payable method cannot override value", O.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides.value",
        value: i.value
      }), a.value = l;
    }
    o.customData && (a.customData = Ut(o.customData)), o.ccipReadEnabled && (a.ccipReadEnabled = !!o.ccipReadEnabled), delete i.nonce, delete i.gasLimit, delete i.gasPrice, delete i.from, delete i.value, delete i.type, delete i.accessList, delete i.maxFeePerGas, delete i.maxPriorityFeePerGas, delete i.customData, delete i.ccipReadEnabled;
    const u = Object.keys(i).filter((l) => i[l] != null);
    return u.length && It.throwError(`cannot override ${u.map((l) => JSON.stringify(l)).join(",")}`, O.errors.UNSUPPORTED_OPERATION, {
      operation: "overrides",
      overrides: u
    }), a;
  });
}
function RR(n, e) {
  return function(...t) {
    return cp(n, e, t);
  };
}
function kR(n, e) {
  const t = n.signer || n.provider;
  return function(...i) {
    return va(this, void 0, void 0, function* () {
      t || It.throwError("estimate require a provider or signer", O.errors.UNSUPPORTED_OPERATION, {
        operation: "estimateGas"
      });
      const r = yield cp(n, e, i);
      return yield t.estimateGas(r);
    });
  };
}
function PR(n, e) {
  const t = e.wait.bind(e);
  e.wait = (i) => t(i).then((r) => (r.events = r.logs.map((s) => {
    let a = Ss(s), o = null;
    try {
      o = n.interface.parseLog(s);
    } catch {
    }
    return o && (a.args = o.args, a.decode = (u, l) => n.interface.decodeEventLog(o.eventFragment, u, l), a.event = o.name, a.eventSignature = o.signature), a.removeListener = () => n.provider, a.getBlock = () => n.provider.getBlock(r.blockHash), a.getTransaction = () => n.provider.getTransaction(r.transactionHash), a.getTransactionReceipt = () => Promise.resolve(r), a;
  }), r));
}
function w5(n, e, t) {
  const i = n.signer || n.provider;
  return function(...r) {
    return va(this, void 0, void 0, function* () {
      let s;
      if (r.length === e.inputs.length + 1 && typeof r[r.length - 1] == "object") {
        const u = Ut(r.pop());
        u.blockTag != null && (s = yield u.blockTag), delete u.blockTag, r.push(u);
      }
      n.deployTransaction != null && (yield n._deployed(s));
      const a = yield cp(n, e, r), o = yield i.call(a, s);
      try {
        let u = n.interface.decodeFunctionResult(e, o);
        return t && e.outputs.length === 1 && (u = u[0]), u;
      } catch (u) {
        throw u.code === O.errors.CALL_EXCEPTION && (u.address = n.address, u.args = r, u.transaction = a), u;
      }
    });
  };
}
function IR(n, e) {
  return function(...t) {
    return va(this, void 0, void 0, function* () {
      n.signer || It.throwError("sending a transaction requires a signer", O.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction"
      }), n.deployTransaction != null && (yield n._deployed());
      const i = yield cp(n, e, t), r = yield n.signer.sendTransaction(i);
      return PR(n, r), r;
    });
  };
}
function F2(n, e, t) {
  return e.constant ? w5(n, e, t) : IR(n, e);
}
function A5(n) {
  return n.address && (n.topics == null || n.topics.length === 0) ? "*" : (n.address || "*") + "@" + (n.topics ? n.topics.map((e) => Array.isArray(e) ? e.join("|") : e).join(":") : "");
}
class sl {
  constructor(e, t) {
    U(this, "tag", e), U(this, "filter", t), this._listeners = [];
  }
  addListener(e, t) {
    this._listeners.push({ listener: e, once: t });
  }
  removeListener(e) {
    let t = !1;
    this._listeners = this._listeners.filter((i) => t || i.listener !== e ? !0 : (t = !0, !1));
  }
  removeAllListeners() {
    this._listeners = [];
  }
  listeners() {
    return this._listeners.map((e) => e.listener);
  }
  listenerCount() {
    return this._listeners.length;
  }
  run(e) {
    const t = this.listenerCount();
    return this._listeners = this._listeners.filter((i) => {
      const r = e.slice();
      return setTimeout(() => {
        i.listener.apply(this, r);
      }, 0), !i.once;
    }), t;
  }
  prepareEvent(e) {
  }
  // Returns the array that will be applied to an emit
  getEmit(e) {
    return [e];
  }
}
class OR extends sl {
  constructor() {
    super("error", null);
  }
}
class L2 extends sl {
  constructor(e, t, i, r) {
    const s = {
      address: e
    };
    let a = t.getEventTopic(i);
    r ? (a !== r[0] && It.throwArgumentError("topic mismatch", "topics", r), s.topics = r.slice()) : s.topics = [a], super(A5(s), s), U(this, "address", e), U(this, "interface", t), U(this, "fragment", i);
  }
  prepareEvent(e) {
    super.prepareEvent(e), e.event = this.fragment.name, e.eventSignature = this.fragment.format(), e.decode = (t, i) => this.interface.decodeEventLog(this.fragment, t, i);
    try {
      e.args = this.interface.decodeEventLog(this.fragment, e.data, e.topics);
    } catch (t) {
      e.args = null, e.decodeError = t;
    }
  }
  getEmit(e) {
    const t = m6(e.args);
    if (t.length)
      throw t[0].error;
    const i = (e.args || []).slice();
    return i.push(e), i;
  }
}
class U2 extends sl {
  constructor(e, t) {
    super("*", { address: e }), U(this, "address", e), U(this, "interface", t);
  }
  prepareEvent(e) {
    super.prepareEvent(e);
    try {
      const t = this.interface.parseLog(e);
      e.event = t.name, e.eventSignature = t.signature, e.decode = (i, r) => this.interface.decodeEventLog(t.eventFragment, i, r), e.args = t.args;
    } catch {
    }
  }
}
class BR {
  constructor(e, t, i) {
    U(this, "interface", Oi(new.target, "getInterface")(t)), i == null ? (U(this, "provider", null), U(this, "signer", null)) : Ua.isSigner(i) ? (U(this, "provider", i.provider || null), U(this, "signer", i)) : h0.isProvider(i) ? (U(this, "provider", i), U(this, "signer", null)) : It.throwArgumentError("invalid signer or provider", "signerOrProvider", i), U(this, "callStatic", {}), U(this, "estimateGas", {}), U(this, "functions", {}), U(this, "populateTransaction", {}), U(this, "filters", {});
    {
      const a = {};
      Object.keys(this.interface.events).forEach((o) => {
        const u = this.interface.events[o];
        U(this.filters, o, (...l) => ({
          address: this.address,
          topics: this.interface.encodeFilterTopics(u, l)
        })), a[u.name] || (a[u.name] = []), a[u.name].push(o);
      }), Object.keys(a).forEach((o) => {
        const u = a[o];
        u.length === 1 ? U(this.filters, o, this.filters[u[0]]) : It.warn(`Duplicate definition of ${o} (${u.join(", ")})`);
      });
    }
    if (U(this, "_runningEvents", {}), U(this, "_wrappedEmits", {}), e == null && It.throwArgumentError("invalid contract address or ENS name", "addressOrName", e), U(this, "address", e), this.provider)
      U(this, "resolvedAddress", hd(this.provider, e));
    else
      try {
        U(this, "resolvedAddress", Promise.resolve(Be(e)));
      } catch {
        It.throwError("provider is required to use ENS name as contract address", O.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    this.resolvedAddress.catch((a) => {
    });
    const r = {}, s = {};
    Object.keys(this.interface.functions).forEach((a) => {
      const o = this.interface.functions[a];
      if (s[a]) {
        It.warn(`Duplicate ABI entry for ${JSON.stringify(a)}`);
        return;
      }
      s[a] = !0;
      {
        const u = o.name;
        r[`%${u}`] || (r[`%${u}`] = []), r[`%${u}`].push(a);
      }
      this[a] == null && U(this, a, F2(this, o, !0)), this.functions[a] == null && U(this.functions, a, F2(this, o, !1)), this.callStatic[a] == null && U(this.callStatic, a, w5(this, o, !0)), this.populateTransaction[a] == null && U(this.populateTransaction, a, RR(this, o)), this.estimateGas[a] == null && U(this.estimateGas, a, kR(this, o));
    }), Object.keys(r).forEach((a) => {
      const o = r[a];
      if (o.length > 1)
        return;
      a = a.substring(1);
      const u = o[0];
      try {
        this[a] == null && U(this, a, this[u]);
      } catch {
      }
      this.functions[a] == null && U(this.functions, a, this.functions[u]), this.callStatic[a] == null && U(this.callStatic, a, this.callStatic[u]), this.populateTransaction[a] == null && U(this.populateTransaction, a, this.populateTransaction[u]), this.estimateGas[a] == null && U(this.estimateGas, a, this.estimateGas[u]);
    });
  }
  static getContractAddress(e) {
    return o0(e);
  }
  static getInterface(e) {
    return Sy.isInterface(e) ? e : new Sy(e);
  }
  // @TODO: Allow timeout?
  deployed() {
    return this._deployed();
  }
  _deployed(e) {
    return this._deployedPromise || (this.deployTransaction ? this._deployedPromise = this.deployTransaction.wait().then(() => this) : this._deployedPromise = this.provider.getCode(this.address, e).then((t) => (t === "0x" && It.throwError("contract not deployed", O.errors.UNSUPPORTED_OPERATION, {
      contractAddress: this.address,
      operation: "getDeployed"
    }), this))), this._deployedPromise;
  }
  // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
  fallback(e) {
    this.signer || It.throwError("sending a transactions require a signer", O.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
    const t = Ut(e || {});
    return ["from", "to"].forEach(function(i) {
      t[i] != null && It.throwError("cannot override " + i, O.errors.UNSUPPORTED_OPERATION, { operation: i });
    }), t.to = this.resolvedAddress, this.deployed().then(() => this.signer.sendTransaction(t));
  }
  // Reconnect to a different signer or provider
  connect(e) {
    typeof e == "string" && (e = new m0(e, this.provider));
    const t = new this.constructor(this.address, this.interface, e);
    return this.deployTransaction && U(t, "deployTransaction", this.deployTransaction), t;
  }
  // Re-attach to a different on-chain instance of this contract
  attach(e) {
    return new this.constructor(e, this.interface, this.signer || this.provider);
  }
  static isIndexed(e) {
    return pd.isIndexed(e);
  }
  _normalizeRunningEvent(e) {
    return this._runningEvents[e.tag] ? this._runningEvents[e.tag] : e;
  }
  _getRunningEvent(e) {
    if (typeof e == "string") {
      if (e === "error")
        return this._normalizeRunningEvent(new OR());
      if (e === "event")
        return this._normalizeRunningEvent(new sl("event", null));
      if (e === "*")
        return this._normalizeRunningEvent(new U2(this.address, this.interface));
      const t = this.interface.getEvent(e);
      return this._normalizeRunningEvent(new L2(this.address, this.interface, t));
    }
    if (e.topics && e.topics.length > 0) {
      try {
        const i = e.topics[0];
        if (typeof i != "string")
          throw new Error("invalid topic");
        const r = this.interface.getEvent(i);
        return this._normalizeRunningEvent(new L2(this.address, this.interface, r, e.topics));
      } catch {
      }
      const t = {
        address: this.address,
        topics: e.topics
      };
      return this._normalizeRunningEvent(new sl(A5(t), t));
    }
    return this._normalizeRunningEvent(new U2(this.address, this.interface));
  }
  _checkRunningEvents(e) {
    if (e.listenerCount() === 0) {
      delete this._runningEvents[e.tag];
      const t = this._wrappedEmits[e.tag];
      t && e.filter && (this.provider.off(e.filter, t), delete this._wrappedEmits[e.tag]);
    }
  }
  // Subclasses can override this to gracefully recover
  // from parse errors if they wish
  _wrapEvent(e, t, i) {
    const r = Ss(t);
    return r.removeListener = () => {
      i && (e.removeListener(i), this._checkRunningEvents(e));
    }, r.getBlock = () => this.provider.getBlock(t.blockHash), r.getTransaction = () => this.provider.getTransaction(t.transactionHash), r.getTransactionReceipt = () => this.provider.getTransactionReceipt(t.transactionHash), e.prepareEvent(r), r;
  }
  _addEventListener(e, t, i) {
    if (this.provider || It.throwError("events require a provider or a signer with a provider", O.errors.UNSUPPORTED_OPERATION, { operation: "once" }), e.addListener(t, i), this._runningEvents[e.tag] = e, !this._wrappedEmits[e.tag]) {
      const r = (s) => {
        let a = this._wrapEvent(e, s, t);
        if (a.decodeError == null)
          try {
            const o = e.getEmit(a);
            this.emit(e.filter, ...o);
          } catch (o) {
            a.decodeError = o.error;
          }
        e.filter != null && this.emit("event", a), a.decodeError != null && this.emit("error", a.decodeError, a);
      };
      this._wrappedEmits[e.tag] = r, e.filter != null && this.provider.on(e.filter, r);
    }
  }
  queryFilter(e, t, i) {
    const r = this._getRunningEvent(e), s = Ut(r.filter);
    return typeof t == "string" && Ae(t, 32) ? (i != null && It.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", i), s.blockHash = t) : (s.fromBlock = t ?? 0, s.toBlock = i ?? "latest"), this.provider.getLogs(s).then((a) => a.map((o) => this._wrapEvent(r, o, null)));
  }
  on(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !1), this;
  }
  once(e, t) {
    return this._addEventListener(this._getRunningEvent(e), t, !0), this;
  }
  emit(e, ...t) {
    if (!this.provider)
      return !1;
    const i = this._getRunningEvent(e), r = i.run(t) > 0;
    return this._checkRunningEvents(i), r;
  }
  listenerCount(e) {
    return this.provider ? e == null ? Object.keys(this._runningEvents).reduce((t, i) => t + this._runningEvents[i].listenerCount(), 0) : this._getRunningEvent(e).listenerCount() : 0;
  }
  listeners(e) {
    if (!this.provider)
      return [];
    if (e == null) {
      const t = [];
      for (let i in this._runningEvents)
        this._runningEvents[i].listeners().forEach((r) => {
          t.push(r);
        });
      return t;
    }
    return this._getRunningEvent(e).listeners();
  }
  removeAllListeners(e) {
    if (!this.provider)
      return this;
    if (e == null) {
      for (const i in this._runningEvents) {
        const r = this._runningEvents[i];
        r.removeAllListeners(), this._checkRunningEvents(r);
      }
      return this;
    }
    const t = this._getRunningEvent(e);
    return t.removeAllListeners(), this._checkRunningEvents(t), this;
  }
  off(e, t) {
    if (!this.provider)
      return this;
    const i = this._getRunningEvent(e);
    return i.removeListener(t), this._checkRunningEvents(i), this;
  }
  removeListener(e, t) {
    return this.off(e, t);
  }
}
class E5 extends BR {
}
var NR = Object.defineProperty, DR = Object.getOwnPropertyDescriptor, S5 = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? DR(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && NR(e, t, r), r;
}, V2 = (n, e) => (t, i) => e(t, i, n);
const Jo = ye.createInterface();
let Co = class {
  constructor(n, e) {
    this.cacheService = n, this.readOnlyProvider = e;
  }
  static register(n) {
    fe.singleton(Jo, Co).register(n);
  }
  /**
   * get a Promise of a PopulatedTransaction that can be used to sign
   * and manually send transactions.
   * Uses the `populateTransaction` method supplied by ethers.js.
   *
   * @param contract
   * @param subFunctionName the name of the contract function
   * @param params
   * @returns
   */
  callPopulateTransaction(n, e, ...t) {
    return n.populateTransaction[e].call(t);
  }
  async getContract(n, e, t, i) {
    const a = (nS ? await mf(/* @__PURE__ */ Object.assign({ "../../contracts/governance/celo-test.json": () => Promise.resolve().then(() => hN), "../../contracts/monetary/celo-test.json": () => Promise.resolve().then(() => bN) }), `../../contracts/${n}/celo-test.json`) : await mf(/* @__PURE__ */ Object.assign({ "../../contracts/governance/celo.json": () => Promise.resolve().then(() => vN), "../../contracts/map/celo.json": () => Promise.resolve().then(() => TN), "../../contracts/monetary/celo.json": () => Promise.resolve().then(() => AN) }), `../../contracts/${n}/celo.json`)).contracts[e];
    let o = a.abi;
    if (typeof o == "string") {
      const u = o;
      o = await this.getSharedAbi(n, u);
    }
    if (t = t ?? a.address, !t)
      throw new Error(`ContractService: requested contract has no address: ${e}`);
    return new E5(t, o, i ?? this.readOnlyProvider);
  }
  async getSharedAbi(n, e) {
    return (await mf(/* @__PURE__ */ Object.assign({ "../../contracts/governance/sharedAbis.json": () => Promise.resolve().then(() => SN), "../../contracts/map/sharedAbis.json": () => Promise.resolve().then(() => CN), "../../contracts/monetary/sharedAbis.json": () => Promise.resolve().then(() => RN) }), `../../contracts/${n}/sharedAbis.json`))[e];
  }
};
S5([
  s6(function() {
    return { storage: this.cacheService };
  })
], Co.prototype, "getContract", 1);
Co = S5([
  V2(0, Fl),
  V2(1, ip)
], Co);
const M5 = ye.createInterface(), $R = "https://raw.githubusercontent.com/Kolektivo/tokenlists/main/tokenlist.json", FR = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  globalThis.fetch !== void 0 ? await fetch($R, {
    method: "GET",
    headers: { accept: "application/json" }
  }).then(async (n) => await n.json()).then((n) => n.tokens) : []
);
var LR = Object.defineProperty, UR = Object.getOwnPropertyDescriptor, VR = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? UR(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && LR(e, t, r), r;
}, jR = (n, e) => (t, i) => e(t, i, n);
const C5 = ye.createInterface(), w0 = ye.createInterface();
let al = class {
  constructor(n) {
    this.container = n;
  }
  static register(n) {
    n.register(fe.singleton(w0, al));
  }
  fireStore;
  async connect() {
    const { getFirestore: n } = await Promise.resolve().then(() => Uv);
    return this.fireStore ??= n(await this.container.get(C5)), this.fireStore;
  }
  async getDocs(n, e, t, i) {
    const { getDocs: r, query: s, collection: a, where: o, orderBy: u } = await Promise.resolve().then(() => Uv);
    return (await r(s(a(await this.connect(), n), o(i.fieldPath, i.opStr, i.value), u(e, t)))).docs.map((p) => p.data());
  }
};
al = VR([
  jR(0, Do)
], al);
var zR = Object.defineProperty, GR = Object.getOwnPropertyDescriptor, qR = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? GR(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && zR(e, t, r), r;
}, HR = (n, e) => (t, i) => e(t, i, n);
const zl = ye.createInterface("NumberService");
let ol = class {
  constructor(n) {
    this.i18n = n;
  }
  static register(n) {
    n.register(fe.singleton(zl, ol));
  }
  /**
   * Returns a string from a number or BigNumber.
   * @param value
   * @param format
   */
  toString(n, e) {
    if (n === null || typeof n > "u" || typeof n == "string")
      return n;
    if (z.isBigNumber(n) && (n = n.toNumber()), Number.isNaN(n))
      return "NaN";
    const t = e?.useGrouping ?? !0, i = e?.isPercentage ?? !1, r = e?.isCurrency ?? !1;
    let s = this.fromString(e?.fractionDigits);
    isNaN(s) && (s = 2);
    const a = r ? { style: "currency", currency: "USD" } : i ? { style: "percent" } : { style: "decimal" };
    return this.i18n.nf(
      n,
      Object.assign(a, {
        useGrouping: t,
        minimumFractionDigits: s,
        maximumFractionDigits: s
      })
    );
  }
  /**
   * returns number from string.
   * @param value the value
   */
  fromString(n) {
    return n === null || typeof n > "u" ? NaN : typeof n == "number" ? n : this.i18n.uf(n);
  }
};
ol = qR([
  HR(0, Na)
], ol);
var KR = Object.defineProperty, WR = Object.getOwnPropertyDescriptor, _5 = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? WR(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && KR(e, t, r), r;
}, kf = (n, e) => (t, i) => e(t, i, n);
const A0 = ye.createInterface();
let _o = class {
  constructor(n, e, t) {
    this.cacheService = n, this.contractService = e, this.readonlyProvider = t;
  }
  static register(n) {
    fe.singleton(A0, _o).register(n);
  }
  async getTokenContract(n, e, t) {
    const i = e ? await this.contractService.getSharedAbi("monetary", "ERC721") : await this.contractService.getSharedAbi("monetary", "ERC20");
    return new E5(n, i, t ?? this.readonlyProvider);
  }
};
_5([
  s6(function() {
    return { storage: this.cacheService };
  })
], _o.prototype, "getTokenContract", 1);
_o = _5([
  kf(0, Fl),
  kf(1, Jo),
  kf(2, ip)
], _o);
var cs = /* @__PURE__ */ ((n) => (n[n.NonStablecoin = 0] = "NonStablecoin", n[n.Stablecoin = 1] = "Stablecoin", n[n.Ecological = 2] = "Ecological", n))(cs || {});
const JR = ye.createInterface();
var QR = Object.defineProperty, YR = Object.getOwnPropertyDescriptor, XR = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? YR(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && QR(e, t, r), r;
}, ZR = (n, e) => (t, i) => e(t, i, n);
const E0 = ye.createInterface();
let md = class {
  constructor(n) {
    this.client = n;
  }
  static register(n) {
    n.register(fe.singleton(E0, md));
  }
  async all(n) {
    const e = [];
    for await (const t of n)
      e.push(t);
    return e;
  }
  save(n, e = !0) {
    return typeof n == "string" ? this.client.add(
      { content: n },
      {
        pin: e
      }
    ).then((t) => t.cid) : this.client.dag.put(n, {
      pin: e
    });
  }
  async get(n, e = !1, t) {
    const i = (await Promise.resolve().then(() => MD)).CID.asCID(n);
    if (i) {
      if (!e) {
        const r = this.client.cat(n), s = (await Promise.resolve().then(() => _D)).concat(await this.all(r));
        return (await Promise.resolve().then(() => n$)).toString(s);
      }
      return JSON.stringify((await this.client.dag.get(i, { path: t })).value);
    }
  }
};
md = XR([
  ZR(0, JR)
], md);
const e9 = "@kolektivo/dapp", t9 = "A collection of institutional technologies that open up new opportunities for local communities to govern and finance their own regenerative economies.", n9 = "1.0.0", i9 = {
  type: "git",
  url: "https://github.com/Kolektivo/dapp"
}, r9 = "CL Cybernetix GmbH", s9 = "./", a9 = "MIT", o9 = {
  node: ">=16.0.0"
}, u9 = {
  http: !1
}, l9 = {
  "lint:js": "eslint src --ext .js,.ts",
  "lint:fix": "eslint src  --fix",
  "lint:scss:fix": 'stylelint "src/**/*.scss" --fix',
  "lint:scss": 'stylelint "src/**/*.scss"',
  "lint:html": "htmlhint -c .htmlhintrc src design-system ",
  lint: "npm run lint:js && npm run lint:html",
  clean: "npx -y rimraf node_modules package-lock.json && npm i",
  dev: "vite",
  start: "vite",
  typecheck: "tsc",
  build: "tsc && vite build",
  "build:chart-data-script": "vite build --config vite.config-lib.ts",
  "build:dev:chart-data-script": "vite build --config vite.config-lib.ts --mode development",
  "build:dev": "vite build --mode development",
  "preview-build": "vite preview --open",
  postinstall: "node build/postinstall/index.mjs",
  test: "exit 0",
  "test:ui": "vitest --ui",
  coverage: "vitest run --coverage",
  e2e: "playwright test",
  "e2e:watch": "playwright test --watch",
  "e2e:ci": "URL=$npm_config_url playwright test",
  "vercel:deploy": "vercel --token $npm_config_token",
  "vercel:deploy:production": "vercel --prod --token $npm_config_token",
  "vercel:alias": "vercel alias set $npm_config_deployment $npm_config_branch --token $npm_config_token --scope $npm_config_scope"
}, c9 = {
  aurelia: "dev",
  "@aurelia/i18n": "dev",
  "@aurelia/router": "dev",
  "@aurelia/validation-html": "dev",
  "@celo-tools/celo-ethers-wrapper": "^0.4.0",
  "@dethcrypto/eth-sdk": "^0.3.3",
  "@dethcrypto/eth-sdk-client": "^0.1.6",
  "@lottiefiles/lottie-player": "^1.7.1",
  "@material-design-icons/svg": "^0.14.3",
  "@metamask/detect-provider": "^2.0.0",
  "@metamask/providers": "^10.2.1",
  "@walletconnect/web3-provider": "^1.8.0",
  "browserify-zlib": "^0.2.0",
  buffer: "^6.0.3",
  "chart.js": "^4.2.1",
  cids: "^1.1.9",
  ethers: "^5",
  events: "^3.3.0",
  firebase: "^9.17.2",
  "i18next-chained-backend": "^4.2.0",
  "i18next-http-backend": "^2.2.0",
  "i18next-intervalplural-postprocessor": "^3.0.0",
  "i18next-localstorage-backend": "^4.1.0",
  "ipfs-core": "^0.18.0",
  "ipfs-http-client": "^60.0.0",
  "lit-js-sdk": "^1.2.17",
  process: "^0.11.10",
  "stream-browserify": "^3.0.0",
  uint8arrays: "^4.0.3",
  util: "^0.12.5",
  web3modal: "^1.9.12"
}, d9 = {
  "stylelint-config-standard-scss": "^7.0.1",
  "@aurelia/plugin-conventions": "dev",
  "@aurelia/testing": "dev",
  "@esbuild-plugins/node-globals-polyfill": "^0.2.3",
  "@playwright/test": "^1.31.2",
  "@rollup/plugin-inject": "^5.0.3",
  "@typechain/ethers-v5": "^10.2.0",
  "@types/node": "^18.15.3",
  "@typescript-eslint/eslint-plugin": "^5.55.0",
  "@typescript-eslint/parser": "^5.55.0",
  "@vitest/ui": "^0.29.3",
  "cross-env": "^7.0.3",
  eslint: "^8.36.0",
  "eslint-config-prettier": "^8.7.0",
  "eslint-import-resolver-typescript": "^3.5.3",
  "eslint-plugin-cypress": "^2.12.1",
  "eslint-plugin-import": "^2.27.5",
  "eslint-plugin-prettier": "^4.2.1",
  "eslint-plugin-simple-import-sort": "^10.0.0",
  "eslint-plugin-unused-imports": "^2.0.0",
  "fs-extra": "^11.1.0",
  glob: "^9.3.0",
  "happy-dom": "^8.9.0",
  "html-loader": "^4.2.0",
  htmlhint: "^1.1.4",
  "http-browserify": "1.7.0",
  "https-browserify": "^1.0.0",
  postcss: "^8.4.21",
  "postcss-loader": "^7.1.0",
  "rollup-plugin-html": "^0.2.1",
  "rollup-plugin-polyfill-node": "^0.12.0",
  "rollup-plugin-swc": "^0.2.1",
  "rollup-plugin-visualizer": "^5.9.0",
  "rollup-pluginutils": "^2.8.2",
  sass: "^1.59.3",
  stylelint: "^15.2.0",
  "stylelint-config-standard": "^30.0.1",
  "stylelint-prettier": "^3.0.0",
  tslib: "^2.5.0",
  typescript: "~4.9.5",
  vercel: "latest",
  vite: "^4.2.0",
  vitest: "^0.29.3",
  "vitest-mock-extended": "^1.1.0"
}, p9 = {
  terser: "npm:@swc/core"
}, f9 = {
  name: e9,
  description: t9,
  version: n9,
  repository: i9,
  author: r9,
  homepage: s9,
  license: a9,
  engines: o9,
  browser: u9,
  scripts: l9,
  dependencies: c9,
  devDependencies: d9,
  resolutions: p9
}, S0 = ye.createInterface("BrowserStorageService");
class M0 {
  addVersion(e, t) {
    return {
      data: e,
      _version: t
    };
  }
  getKey(e) {
    return `${f9.name}.${e}`;
  }
  set(e, t, i, r) {
    const s = typeof r == "string" ? this.addVersion(i, r) : i;
    e.setItem(this.getKey(t), JSON.stringify(s));
  }
  get(e, t, i, r) {
    const s = e.getItem(this.getKey(t));
    if (typeof s == "string")
      try {
        const a = JSON.parse(s);
        if (typeof r == "string") {
          const o = a;
          return o._version === r ? o.data : i;
        } else
          return a;
      } catch {
        return i;
      }
    return i;
  }
  remove(e, t) {
    e.removeItem(this.getKey(t));
  }
  lsSet(e, t, i) {
    this.set(localStorage, e, t, i);
  }
  lsGet(e, t, i) {
    return this.get(localStorage, e, t, i);
  }
  lsRemove(e) {
    this.remove(localStorage, e);
  }
  ssSet(e, t, i) {
    this.set(sessionStorage, e, t, i);
  }
  ssGet(e, t, i) {
    return this.get(sessionStorage, e, t, i);
  }
  ssRemove(e) {
    this.remove(sessionStorage, e);
  }
  static register(e) {
    fe.singleton(S0, M0).register(e);
  }
}
var Oy = /* @__PURE__ */ ((n) => (n[n.MONETARY_CONTROLLER = 1] = "MONETARY_CONTROLLER", n[n.RESERVE_DELEGATE = 2] = "RESERVE_DELEGATE", n[n.RESERVE_VETO_DELEGATE = 3] = "RESERVE_VETO_DELEGATE", n[n.TOPOLOGY_DELEGATE = 4] = "TOPOLOGY_DELEGATE", n[n.ECOLOGY_DELEGATE = 5] = "ECOLOGY_DELEGATE", n[n.ECOLOGY_DELEGATE_PROPOSER = 6] = "ECOLOGY_DELEGATE_PROPOSER", n[n.RESERVE_ARBITRAGEUR = 7] = "RESERVE_ARBITRAGEUR", n[n.LOCAL_MULTI_SIG_MEMBER = 8] = "LOCAL_MULTI_SIG_MEMBER", n[n.TREASURY_DELEGATE = 101] = "TREASURY_DELEGATE", n[n.TREASURY_VETO_DELEGATE = 102] = "TREASURY_VETO_DELEGATE", n[n.TREASURY_ARBITRAGEUR = 103] = "TREASURY_ARBITRAGEUR", n[n.KOLEKTIVO_MULTI_SIG_MEMBER = 104] = "KOLEKTIVO_MULTI_SIG_MEMBER", n))(Oy || {});
const y9 = ye.createInterface();
var h9 = Object.defineProperty, m9 = Object.getOwnPropertyDescriptor, b9 = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? m9(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && h9(e, t, r), r;
}, Pf = (n, e) => (t, i) => e(t, i, n);
const R5 = ye.createInterface("EncryptionService");
let bd = class {
  constructor(n, e, t) {
    this.logger = n, this.container = e, this.config = t, this.logger.scopeTo("EncryptionService");
  }
  client;
  static register(n) {
    fe.singleton(R5, bd).register(n);
  }
  authSig;
  encryptedSymmetricKey;
  get chain() {
    return this.config.chain.toLowerCase();
  }
  getAccessControlConditions(n) {
    return [
      {
        contractAddress: n,
        standardContractType: "ERC1155",
        chain: this.chain,
        method: "balanceOfBatch",
        parameters: [":userAddress,:userAddress", `${Oy.RESERVE_DELEGATE},${Oy.ECOLOGY_DELEGATE_PROPOSER}`],
        returnValueTest: {
          comparator: ">",
          value: "0"
        }
      }
    ];
  }
  async connect() {
    if (this.client)
      return;
    const n = await this.container.get(y9);
    return this.client = n, await this.client.connect();
  }
  async encrypt(n, e, t, i) {
    if (await this.connect(), !this.client)
      return;
    const r = {
      web3: e,
      account: t.toLowerCase(),
      chainId: this.config.chainId,
      expiration: new Date(Date.now() + 3e5)
      // 5 minutes
    };
    this.authSig = await this.client.getAuthSig(r);
    const { encryptedString: s, symmetricKey: a } = await this.client.encryptString(n);
    return this.encryptedSymmetricKey = this.client.uint8arrayToString(
      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
      await this.client.saveEncryptionKey({
        accessControlConditions: this.getAccessControlConditions(i),
        symmetricKey: a,
        authSig: this.authSig,
        chain: this.chain
      }),
      "base16"
    ), { encryptedString: s, symmetricKey: a };
  }
  async decryptAs(n, e) {
    if (await this.connect(), !this.client)
      throw new Error("No encryption client connected");
    const t = await this.client.getEncryptionKey({
      accessControlConditions: this.getAccessControlConditions(e),
      toDecrypt: this.encryptedSymmetricKey,
      chain: this.chain,
      authSig: this.authSig
    }), i = await this.client.decryptString(n, t);
    try {
      return JSON.parse(i);
    } catch {
      this.logger.info("Failed to parse data from LIT");
    }
    return i;
  }
};
bd = b9([
  Pf(0, Ra),
  Pf(1, Do),
  Pf(2, Da)
], bd);
var ki = /* @__PURE__ */ ((n) => (n[n["1h"] = 0] = "1h", n[n["1d"] = 1] = "1d", n[n["1w"] = 2] = "1w", n[n["1m"] = 3] = "1m", n[n["1y"] = 4] = "1y", n))(ki || {}), C0 = {};
const g9 = /* @__PURE__ */ Pt(_C), v9 = /* @__PURE__ */ Pt(cM), x9 = /* @__PURE__ */ Pt(HM);
class _0 {
  constructor(e) {
    U(this, "alphabet", e), U(this, "base", e.length), U(this, "_alphabetMap", {}), U(this, "_leader", e.charAt(0));
    for (let t = 0; t < e.length; t++)
      this._alphabetMap[e.charAt(t)] = t;
  }
  encode(e) {
    let t = q(e);
    if (t.length === 0)
      return "";
    let i = [0];
    for (let s = 0; s < t.length; ++s) {
      let a = t[s];
      for (let o = 0; o < i.length; ++o)
        a += i[o] << 8, i[o] = a % this.base, a = a / this.base | 0;
      for (; a > 0; )
        i.push(a % this.base), a = a / this.base | 0;
    }
    let r = "";
    for (let s = 0; t[s] === 0 && s < t.length - 1; ++s)
      r += this._leader;
    for (let s = i.length - 1; s >= 0; --s)
      r += this.alphabet[i[s]];
    return r;
  }
  decode(e) {
    if (typeof e != "string")
      throw new TypeError("Expected String");
    let t = [];
    if (e.length === 0)
      return new Uint8Array(t);
    t.push(0);
    for (let i = 0; i < e.length; i++) {
      let r = this._alphabetMap[e[i]];
      if (r === void 0)
        throw new Error("Non-base" + this.base + " character");
      let s = r;
      for (let a = 0; a < t.length; ++a)
        s += t[a] * this.base, t[a] = s & 255, s >>= 8;
      for (; s > 0; )
        t.push(s & 255), s >>= 8;
    }
    for (let i = 0; e[i] === this._leader && i < e.length - 1; ++i)
      t.push(0);
    return q(new Uint8Array(t.reverse()));
  }
}
const T9 = new _0("abcdefghijklmnopqrstuvwxyz234567"), Ro = new _0("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), w9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Base32: T9,
  Base58: Ro,
  BaseX: _0
}, Symbol.toStringTag, { value: "Module" })), A9 = /* @__PURE__ */ Pt(w9), E9 = /* @__PURE__ */ Pt(dS), S9 = /* @__PURE__ */ Pt(SC);
var ko;
(function(n) {
  n.sha256 = "sha256", n.sha512 = "sha512";
})(ko || (ko = {}));
const M9 = "sha2/5.7.0", C9 = new O(M9);
function k5(n) {
  return "0x" + Mn.ripemd160().update(q(n)).digest("hex");
}
function Ur(n) {
  return "0x" + Mn.sha256().update(q(n)).digest("hex");
}
function _9(n) {
  return "0x" + Mn.sha512().update(q(n)).digest("hex");
}
function ul(n, e, t) {
  return ko[n] || C9.throwError("unsupported algorithm " + n, O.errors.UNSUPPORTED_OPERATION, {
    operation: "hmac",
    algorithm: n
  }), "0x" + Mn.hmac(Mn[n], q(e)).update(q(t)).digest("hex");
}
const R9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get SupportedAlgorithm() {
    return ko;
  },
  computeHmac: ul,
  ripemd160: k5,
  sha256: Ur,
  sha512: _9
}, Symbol.toStringTag, { value: "Module" }));
function R0(n, e, t, i, r) {
  n = q(n), e = q(e);
  let s, a = 1;
  const o = new Uint8Array(i), u = new Uint8Array(e.length + 4);
  u.set(e);
  let l, p;
  for (let f = 1; f <= a; f++) {
    u[e.length] = f >> 24 & 255, u[e.length + 1] = f >> 16 & 255, u[e.length + 2] = f >> 8 & 255, u[e.length + 3] = f & 255;
    let b = q(ul(r, n, u));
    s || (s = b.length, p = new Uint8Array(s), a = Math.ceil(i / s), l = i - (a - 1) * s), p.set(b);
    for (let w = 1; w < t; w++) {
      b = q(ul(r, n, b));
      for (let T = 0; T < s; T++)
        p[T] ^= b[T];
    }
    const A = (f - 1) * s, x = f === a ? l : s;
    o.set(q(p).slice(0, x), A);
  }
  return H(o);
}
const k9 = "wordlists/5.7.0", P9 = new O(k9);
class Gl {
  constructor(e) {
    P9.checkAbstract(new.target, Gl), U(this, "locale", e);
  }
  // Subclasses may override this
  split(e) {
    return e.toLowerCase().split(/ +/g);
  }
  // Subclasses may override this
  join(e) {
    return e.join(" ");
  }
  static check(e) {
    const t = [];
    for (let i = 0; i < 2048; i++) {
      const r = e.getWord(i);
      if (i !== e.getWordIndex(r))
        return "0x";
      t.push(r);
    }
    return hs(t.join(`
`) + `
`);
  }
  static register(e, t) {
    t || (t = e.locale);
  }
}
const I9 = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let Bu = null;
function j2(n) {
  if (Bu == null && (Bu = I9.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), Gl.check(n) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60"))
    throw Bu = null, new Error("BIP39 Wordlist for en (English) FAILED");
}
class O9 extends Gl {
  constructor() {
    super("en");
  }
  getWord(e) {
    return j2(this), Bu[e];
  }
  getWordIndex(e) {
    return j2(this), Bu.indexOf(e);
  }
}
const P5 = new O9();
Gl.register(P5);
const z2 = {
  en: P5
}, B9 = "hdnode/5.7.0", ll = new O(B9), N9 = z.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), D9 = Dt("Bitcoin seed"), io = 2147483648;
function I5(n) {
  return (1 << n) - 1 << 8 - n;
}
function $9(n) {
  return (1 << n) - 1;
}
function fc(n) {
  return De(H(n), 32);
}
function G2(n) {
  return Ro.encode(Ve([n, Bt(Ur(Ur(n)), 0, 4)]));
}
function k0(n) {
  if (n == null)
    return z2.en;
  if (typeof n == "string") {
    const e = z2[n];
    return e == null && ll.throwArgumentError("unknown locale", "wordlist", n), e;
  }
  return n;
}
const Ja = {}, Po = "m/44'/60'/0'/0/0";
class Yn {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(e, t, i, r, s, a, o, u) {
    if (e !== Ja)
      throw new Error("HDNode constructor cannot be called directly");
    if (t) {
      const l = new ca(t);
      U(this, "privateKey", l.privateKey), U(this, "publicKey", l.compressedPublicKey);
    } else
      U(this, "privateKey", null), U(this, "publicKey", H(i));
    U(this, "parentFingerprint", r), U(this, "fingerprint", Bt(k5(Ur(this.publicKey)), 0, 4)), U(this, "address", vs(this.publicKey)), U(this, "chainCode", s), U(this, "index", a), U(this, "depth", o), u == null ? (U(this, "mnemonic", null), U(this, "path", null)) : typeof u == "string" ? (U(this, "mnemonic", null), U(this, "path", u)) : (U(this, "mnemonic", u), U(this, "path", u.path));
  }
  get extendedKey() {
    if (this.depth >= 256)
      throw new Error("Depth too large!");
    return G2(Ve([
      this.privateKey != null ? "0x0488ADE4" : "0x0488B21E",
      H(this.depth),
      this.parentFingerprint,
      De(H(this.index), 4),
      this.chainCode,
      this.privateKey != null ? Ve(["0x00", this.privateKey]) : this.publicKey
    ]));
  }
  neuter() {
    return new Yn(Ja, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }
  _derive(e) {
    if (e > 4294967295)
      throw new Error("invalid index - " + String(e));
    let t = this.path;
    t && (t += "/" + (e & ~io));
    const i = new Uint8Array(37);
    if (e & io) {
      if (!this.privateKey)
        throw new Error("cannot derive child of neutered node");
      i.set(q(this.privateKey), 1), t && (t += "'");
    } else
      i.set(q(this.publicKey));
    for (let f = 24; f >= 0; f -= 8)
      i[33 + (f >> 3)] = e >> 24 - f & 255;
    const r = q(ul(ko.sha512, this.chainCode, i)), s = r.slice(0, 32), a = r.slice(32);
    let o = null, u = null;
    this.privateKey ? o = fc(z.from(s).add(this.privateKey).mod(N9)) : u = new ca(H(s))._addPoint(this.publicKey);
    let l = t;
    const p = this.mnemonic;
    return p && (l = Object.freeze({
      phrase: p.phrase,
      path: t,
      locale: p.locale || "en"
    })), new Yn(Ja, o, u, this.fingerprint, fc(a), e, this.depth + 1, l);
  }
  derivePath(e) {
    const t = e.split("/");
    if (t.length === 0 || t[0] === "m" && this.depth !== 0)
      throw new Error("invalid path - " + e);
    t[0] === "m" && t.shift();
    let i = this;
    for (let r = 0; r < t.length; r++) {
      const s = t[r];
      if (s.match(/^[0-9]+'$/)) {
        const a = parseInt(s.substring(0, s.length - 1));
        if (a >= io)
          throw new Error("invalid path index - " + s);
        i = i._derive(io + a);
      } else if (s.match(/^[0-9]+$/)) {
        const a = parseInt(s);
        if (a >= io)
          throw new Error("invalid path index - " + s);
        i = i._derive(a);
      } else
        throw new Error("invalid path component - " + s);
    }
    return i;
  }
  static _fromSeed(e, t) {
    const i = q(e);
    if (i.length < 16 || i.length > 64)
      throw new Error("invalid seed");
    const r = q(ul(ko.sha512, D9, i));
    return new Yn(Ja, fc(r.slice(0, 32)), null, "0x00000000", fc(r.slice(32)), 0, 0, t);
  }
  static fromMnemonic(e, t, i) {
    return i = k0(i), e = pp(dp(e, i), i), Yn._fromSeed(O5(e, t), {
      phrase: e,
      path: "m",
      locale: i.locale
    });
  }
  static fromSeed(e) {
    return Yn._fromSeed(e, null);
  }
  static fromExtendedKey(e) {
    const t = Ro.decode(e);
    (t.length !== 82 || G2(t.slice(0, 78)) !== e) && ll.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    const i = t[4], r = H(t.slice(5, 9)), s = parseInt(H(t.slice(9, 13)).substring(2), 16), a = H(t.slice(13, 45)), o = t.slice(45, 78);
    switch (H(t.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf":
        return new Yn(Ja, null, H(o), r, a, s, i, null);
      case "0x0488ade4":
      case "0x04358394 ":
        if (o[0] !== 0)
          break;
        return new Yn(Ja, H(o.slice(1)), null, r, a, s, i, null);
    }
    return ll.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }
}
function O5(n, e) {
  e || (e = "");
  const t = Dt("mnemonic" + e, sr.NFKD);
  return R0(Dt(n, sr.NFKD), t, 2048, 64, "sha512");
}
function dp(n, e) {
  e = k0(e), ll.checkNormalize();
  const t = e.split(n);
  if (t.length % 3 !== 0)
    throw new Error("invalid mnemonic");
  const i = q(new Uint8Array(Math.ceil(11 * t.length / 8)));
  let r = 0;
  for (let l = 0; l < t.length; l++) {
    let p = e.getWordIndex(t[l].normalize("NFKD"));
    if (p === -1)
      throw new Error("invalid mnemonic");
    for (let f = 0; f < 11; f++)
      p & 1 << 10 - f && (i[r >> 3] |= 1 << 7 - r % 8), r++;
  }
  const s = 32 * t.length / 3, a = t.length / 3, o = I5(a);
  if ((q(Ur(i.slice(0, s / 8)))[0] & o) !== (i[i.length - 1] & o))
    throw new Error("invalid checksum");
  return H(i.slice(0, s / 8));
}
function pp(n, e) {
  if (e = k0(e), n = q(n), n.length % 4 !== 0 || n.length < 16 || n.length > 32)
    throw new Error("invalid entropy");
  const t = [0];
  let i = 11;
  for (let a = 0; a < n.length; a++)
    i > 8 ? (t[t.length - 1] <<= 8, t[t.length - 1] |= n[a], i -= 8) : (t[t.length - 1] <<= i, t[t.length - 1] |= n[a] >> 8 - i, t.push(n[a] & $9(8 - i)), i += 3);
  const r = n.length / 4, s = q(Ur(n))[0] & I5(r);
  return t[t.length - 1] <<= r, t[t.length - 1] |= s >> 8 - r, e.join(t.map((a) => e.getWord(a)));
}
function F9(n, e) {
  try {
    return dp(n, e), !0;
  } catch {
  }
  return !1;
}
function L9(n) {
  return (typeof n != "number" || n < 0 || n >= io || n % 1) && ll.throwArgumentError("invalid account index", "index", n), `m/44'/60'/${n}'/0/0`;
}
const U9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HDNode: Yn,
  defaultPath: Po,
  entropyToMnemonic: pp,
  getAccountPath: L9,
  isValidMnemonic: F9,
  mnemonicToEntropy: dp,
  mnemonicToSeed: O5
}, Symbol.toStringTag, { value: "Module" })), V9 = /* @__PURE__ */ Pt(U9);
var By = {}, j9 = {
  get exports() {
    return By;
  },
  set exports(n) {
    By = n;
  }
};
(function(n, e) {
  (function(t) {
    function i(m) {
      return parseInt(m) === m;
    }
    function r(m) {
      if (!i(m.length))
        return !1;
      for (var d = 0; d < m.length; d++)
        if (!i(m[d]) || m[d] < 0 || m[d] > 255)
          return !1;
      return !0;
    }
    function s(m, d) {
      if (m.buffer && ArrayBuffer.isView(m) && m.name === "Uint8Array")
        return d && (m.slice ? m = m.slice() : m = Array.prototype.slice.call(m)), m;
      if (Array.isArray(m)) {
        if (!r(m))
          throw new Error("Array contains invalid value: " + m);
        return new Uint8Array(m);
      }
      if (i(m.length) && r(m))
        return new Uint8Array(m);
      throw new Error("unsupported array-like object");
    }
    function a(m) {
      return new Uint8Array(m);
    }
    function o(m, d, g, P, y) {
      (P != null || y != null) && (m.slice ? m = m.slice(P, y) : m = Array.prototype.slice.call(m, P, y)), d.set(m, g);
    }
    var u = function() {
      function m(g) {
        var P = [], y = 0;
        for (g = encodeURI(g); y < g.length; ) {
          var R = g.charCodeAt(y++);
          R === 37 ? (P.push(parseInt(g.substr(y, 2), 16)), y += 2) : P.push(R);
        }
        return s(P);
      }
      function d(g) {
        for (var P = [], y = 0; y < g.length; ) {
          var R = g[y];
          R < 128 ? (P.push(String.fromCharCode(R)), y++) : R > 191 && R < 224 ? (P.push(String.fromCharCode((R & 31) << 6 | g[y + 1] & 63)), y += 2) : (P.push(String.fromCharCode((R & 15) << 12 | (g[y + 1] & 63) << 6 | g[y + 2] & 63)), y += 3);
        }
        return P.join("");
      }
      return {
        toBytes: m,
        fromBytes: d
      };
    }(), l = function() {
      function m(P) {
        for (var y = [], R = 0; R < P.length; R += 2)
          y.push(parseInt(P.substr(R, 2), 16));
        return y;
      }
      var d = "0123456789abcdef";
      function g(P) {
        for (var y = [], R = 0; R < P.length; R++) {
          var F = P[R];
          y.push(d[(F & 240) >> 4] + d[F & 15]);
        }
        return y.join("");
      }
      return {
        toBytes: m,
        fromBytes: g
      };
    }(), p = { 16: 10, 24: 12, 32: 14 }, f = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145], b = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22], A = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125], x = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986], w = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766], T = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126], _ = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436], I = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890], $ = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935], N = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600], B = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480], V = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795], K = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855], G = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150], Y = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function oe(m) {
      for (var d = [], g = 0; g < m.length; g += 4)
        d.push(
          m[g] << 24 | m[g + 1] << 16 | m[g + 2] << 8 | m[g + 3]
        );
      return d;
    }
    var J = function(m) {
      if (!(this instanceof J))
        throw Error("AES must be instanitated with `new`");
      Object.defineProperty(this, "key", {
        value: s(m, !0)
      }), this._prepare();
    };
    J.prototype._prepare = function() {
      var m = p[this.key.length];
      if (m == null)
        throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
      this._Ke = [], this._Kd = [];
      for (var d = 0; d <= m; d++)
        this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);
      for (var g = (m + 1) * 4, P = this.key.length / 4, y = oe(this.key), R, d = 0; d < P; d++)
        R = d >> 2, this._Ke[R][d % 4] = y[d], this._Kd[m - R][d % 4] = y[d];
      for (var F = 0, D = P, L; D < g; ) {
        if (L = y[P - 1], y[0] ^= b[L >> 16 & 255] << 24 ^ b[L >> 8 & 255] << 16 ^ b[L & 255] << 8 ^ b[L >> 24 & 255] ^ f[F] << 24, F += 1, P != 8)
          for (var d = 1; d < P; d++)
            y[d] ^= y[d - 1];
        else {
          for (var d = 1; d < P / 2; d++)
            y[d] ^= y[d - 1];
          L = y[P / 2 - 1], y[P / 2] ^= b[L & 255] ^ b[L >> 8 & 255] << 8 ^ b[L >> 16 & 255] << 16 ^ b[L >> 24 & 255] << 24;
          for (var d = P / 2 + 1; d < P; d++)
            y[d] ^= y[d - 1];
        }
        for (var d = 0, te, W; d < P && D < g; )
          te = D >> 2, W = D % 4, this._Ke[te][W] = y[d], this._Kd[m - te][W] = y[d++], D++;
      }
      for (var te = 1; te < m; te++)
        for (var W = 0; W < 4; W++)
          L = this._Kd[te][W], this._Kd[te][W] = V[L >> 24 & 255] ^ K[L >> 16 & 255] ^ G[L >> 8 & 255] ^ Y[L & 255];
    }, J.prototype.encrypt = function(m) {
      if (m.length != 16)
        throw new Error("invalid plaintext size (must be 16 bytes)");
      for (var d = this._Ke.length - 1, g = [0, 0, 0, 0], P = oe(m), y = 0; y < 4; y++)
        P[y] ^= this._Ke[0][y];
      for (var R = 1; R < d; R++) {
        for (var y = 0; y < 4; y++)
          g[y] = x[P[y] >> 24 & 255] ^ w[P[(y + 1) % 4] >> 16 & 255] ^ T[P[(y + 2) % 4] >> 8 & 255] ^ _[P[(y + 3) % 4] & 255] ^ this._Ke[R][y];
        P = g.slice();
      }
      for (var F = a(16), D, y = 0; y < 4; y++)
        D = this._Ke[d][y], F[4 * y] = (b[P[y] >> 24 & 255] ^ D >> 24) & 255, F[4 * y + 1] = (b[P[(y + 1) % 4] >> 16 & 255] ^ D >> 16) & 255, F[4 * y + 2] = (b[P[(y + 2) % 4] >> 8 & 255] ^ D >> 8) & 255, F[4 * y + 3] = (b[P[(y + 3) % 4] & 255] ^ D) & 255;
      return F;
    }, J.prototype.decrypt = function(m) {
      if (m.length != 16)
        throw new Error("invalid ciphertext size (must be 16 bytes)");
      for (var d = this._Kd.length - 1, g = [0, 0, 0, 0], P = oe(m), y = 0; y < 4; y++)
        P[y] ^= this._Kd[0][y];
      for (var R = 1; R < d; R++) {
        for (var y = 0; y < 4; y++)
          g[y] = I[P[y] >> 24 & 255] ^ $[P[(y + 3) % 4] >> 16 & 255] ^ N[P[(y + 2) % 4] >> 8 & 255] ^ B[P[(y + 1) % 4] & 255] ^ this._Kd[R][y];
        P = g.slice();
      }
      for (var F = a(16), D, y = 0; y < 4; y++)
        D = this._Kd[d][y], F[4 * y] = (A[P[y] >> 24 & 255] ^ D >> 24) & 255, F[4 * y + 1] = (A[P[(y + 3) % 4] >> 16 & 255] ^ D >> 16) & 255, F[4 * y + 2] = (A[P[(y + 2) % 4] >> 8 & 255] ^ D >> 8) & 255, F[4 * y + 3] = (A[P[(y + 1) % 4] & 255] ^ D) & 255;
      return F;
    };
    var ue = function(m) {
      if (!(this instanceof ue))
        throw Error("AES must be instanitated with `new`");
      this.description = "Electronic Code Block", this.name = "ecb", this._aes = new J(m);
    };
    ue.prototype.encrypt = function(m) {
      if (m = s(m), m.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var d = a(m.length), g = a(16), P = 0; P < m.length; P += 16)
        o(m, g, 0, P, P + 16), g = this._aes.encrypt(g), o(g, d, P);
      return d;
    }, ue.prototype.decrypt = function(m) {
      if (m = s(m), m.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var d = a(m.length), g = a(16), P = 0; P < m.length; P += 16)
        o(m, g, 0, P, P + 16), g = this._aes.decrypt(g), o(g, d, P);
      return d;
    };
    var M = function(m, d) {
      if (!(this instanceof M))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Block Chaining", this.name = "cbc", !d)
        d = a(16);
      else if (d.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastCipherblock = s(d, !0), this._aes = new J(m);
    };
    M.prototype.encrypt = function(m) {
      if (m = s(m), m.length % 16 !== 0)
        throw new Error("invalid plaintext size (must be multiple of 16 bytes)");
      for (var d = a(m.length), g = a(16), P = 0; P < m.length; P += 16) {
        o(m, g, 0, P, P + 16);
        for (var y = 0; y < 16; y++)
          g[y] ^= this._lastCipherblock[y];
        this._lastCipherblock = this._aes.encrypt(g), o(this._lastCipherblock, d, P);
      }
      return d;
    }, M.prototype.decrypt = function(m) {
      if (m = s(m), m.length % 16 !== 0)
        throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");
      for (var d = a(m.length), g = a(16), P = 0; P < m.length; P += 16) {
        o(m, g, 0, P, P + 16), g = this._aes.decrypt(g);
        for (var y = 0; y < 16; y++)
          d[P + y] = g[y] ^ this._lastCipherblock[y];
        o(m, this._lastCipherblock, 0, P, P + 16);
      }
      return d;
    };
    var c = function(m, d, g) {
      if (!(this instanceof c))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Cipher Feedback", this.name = "cfb", !d)
        d = a(16);
      else if (d.length != 16)
        throw new Error("invalid initialation vector size (must be 16 size)");
      g || (g = 1), this.segmentSize = g, this._shiftRegister = s(d, !0), this._aes = new J(m);
    };
    c.prototype.encrypt = function(m) {
      if (m.length % this.segmentSize != 0)
        throw new Error("invalid plaintext size (must be segmentSize bytes)");
      for (var d = s(m, !0), g, P = 0; P < d.length; P += this.segmentSize) {
        g = this._aes.encrypt(this._shiftRegister);
        for (var y = 0; y < this.segmentSize; y++)
          d[P + y] ^= g[y];
        o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(d, this._shiftRegister, 16 - this.segmentSize, P, P + this.segmentSize);
      }
      return d;
    }, c.prototype.decrypt = function(m) {
      if (m.length % this.segmentSize != 0)
        throw new Error("invalid ciphertext size (must be segmentSize bytes)");
      for (var d = s(m, !0), g, P = 0; P < d.length; P += this.segmentSize) {
        g = this._aes.encrypt(this._shiftRegister);
        for (var y = 0; y < this.segmentSize; y++)
          d[P + y] ^= g[y];
        o(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), o(m, this._shiftRegister, 16 - this.segmentSize, P, P + this.segmentSize);
      }
      return d;
    };
    var h = function(m, d) {
      if (!(this instanceof h))
        throw Error("AES must be instanitated with `new`");
      if (this.description = "Output Feedback", this.name = "ofb", !d)
        d = a(16);
      else if (d.length != 16)
        throw new Error("invalid initialation vector size (must be 16 bytes)");
      this._lastPrecipher = s(d, !0), this._lastPrecipherIndex = 16, this._aes = new J(m);
    };
    h.prototype.encrypt = function(m) {
      for (var d = s(m, !0), g = 0; g < d.length; g++)
        this._lastPrecipherIndex === 16 && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), d[g] ^= this._lastPrecipher[this._lastPrecipherIndex++];
      return d;
    }, h.prototype.decrypt = h.prototype.encrypt;
    var v = function(m) {
      if (!(this instanceof v))
        throw Error("Counter must be instanitated with `new`");
      m !== 0 && !m && (m = 1), typeof m == "number" ? (this._counter = a(16), this.setValue(m)) : this.setBytes(m);
    };
    v.prototype.setValue = function(m) {
      if (typeof m != "number" || parseInt(m) != m)
        throw new Error("invalid counter value (must be an integer)");
      for (var d = 15; d >= 0; --d)
        this._counter[d] = m % 256, m = m >> 8;
    }, v.prototype.setBytes = function(m) {
      if (m = s(m, !0), m.length != 16)
        throw new Error("invalid counter bytes size (must be 16 bytes)");
      this._counter = m;
    }, v.prototype.increment = function() {
      for (var m = 15; m >= 0; m--)
        if (this._counter[m] === 255)
          this._counter[m] = 0;
        else {
          this._counter[m]++;
          break;
        }
    };
    var S = function(m, d) {
      if (!(this instanceof S))
        throw Error("AES must be instanitated with `new`");
      this.description = "Counter", this.name = "ctr", d instanceof v || (d = new v(d)), this._counter = d, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new J(m);
    };
    S.prototype.encrypt = function(m) {
      for (var d = s(m, !0), g = 0; g < d.length; g++)
        this._remainingCounterIndex === 16 && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), d[g] ^= this._remainingCounter[this._remainingCounterIndex++];
      return d;
    }, S.prototype.decrypt = S.prototype.encrypt;
    function E(m) {
      m = s(m, !0);
      var d = 16 - m.length % 16, g = a(m.length + d);
      o(m, g);
      for (var P = m.length; P < g.length; P++)
        g[P] = d;
      return g;
    }
    function C(m) {
      if (m = s(m, !0), m.length < 16)
        throw new Error("PKCS#7 invalid length");
      var d = m[m.length - 1];
      if (d > 16)
        throw new Error("PKCS#7 padding byte out of range");
      for (var g = m.length - d, P = 0; P < d; P++)
        if (m[g + P] !== d)
          throw new Error("PKCS#7 invalid padding byte");
      var y = a(g);
      return o(m, y, 0, 0, g), y;
    }
    var k = {
      AES: J,
      Counter: v,
      ModeOfOperation: {
        ecb: ue,
        cbc: M,
        cfb: c,
        ofb: h,
        ctr: S
      },
      utils: {
        hex: l,
        utf8: u
      },
      padding: {
        pkcs7: {
          pad: E,
          strip: C
        }
      },
      _arrayTest: {
        coerceArray: s,
        createArray: a,
        copyArray: o
      }
    };
    n.exports = k;
  })();
})(j9);
const Yi = By, B5 = "json-wallets/5.7.0";
function da(n) {
  return typeof n == "string" && n.substring(0, 2) !== "0x" && (n = "0x" + n), q(n);
}
function ou(n, e) {
  for (n = String(n); n.length < e; )
    n = "0" + n;
  return n;
}
function P0(n) {
  return typeof n == "string" ? Dt(n, sr.NFKC) : q(n);
}
function Ot(n, e) {
  let t = n;
  const i = e.toLowerCase().split("/");
  for (let r = 0; r < i.length; r++) {
    let s = null;
    for (const a in t)
      if (a.toLowerCase() === i[r]) {
        s = t[a];
        break;
      }
    if (s === null)
      return null;
    t = s;
  }
  return t;
}
function z9(n) {
  const e = q(n);
  e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
  const t = H(e);
  return [
    t.substring(2, 10),
    t.substring(10, 14),
    t.substring(14, 18),
    t.substring(18, 22),
    t.substring(22, 34)
  ].join("-");
}
const G9 = new O(B5);
class q9 extends Ps {
  isCrowdsaleAccount(e) {
    return !!(e && e._isCrowdsaleAccount);
  }
}
function I0(n, e) {
  const t = JSON.parse(n);
  e = P0(e);
  const i = Be(Ot(t, "ethaddr")), r = da(Ot(t, "encseed"));
  (!r || r.length % 16 !== 0) && G9.throwArgumentError("invalid encseed", "json", n);
  const s = q(R0(e, e, 2e3, 32, "sha256")).slice(0, 16), a = r.slice(0, 16), o = r.slice(16), u = new Yi.ModeOfOperation.cbc(s, a), l = Yi.padding.pkcs7.strip(q(u.decrypt(o)));
  let p = "";
  for (let A = 0; A < l.length; A++)
    p += String.fromCharCode(l[A]);
  const f = Dt(p), b = Ie(f);
  return new q9({
    _isCrowdsaleAccount: !0,
    address: i,
    privateKey: b
  });
}
function fp(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return e.encseed && e.ethaddr;
}
function yp(n) {
  let e = null;
  try {
    e = JSON.parse(n);
  } catch {
    return !1;
  }
  return !(!e.version || parseInt(e.version) !== e.version || parseInt(e.version) !== 3);
}
function H9(n) {
  if (fp(n))
    try {
      return Be(JSON.parse(n).ethaddr);
    } catch {
      return null;
    }
  if (yp(n))
    try {
      return Be(JSON.parse(n).address);
    } catch {
      return null;
    }
  return null;
}
var Ny = {}, K9 = {
  get exports() {
    return Ny;
  },
  set exports(n) {
    Ny = n;
  }
};
(function(n, e) {
  (function(t) {
    function r(w) {
      const T = new Uint32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      let _ = 1779033703, I = 3144134277, $ = 1013904242, N = 2773480762, B = 1359893119, V = 2600822924, K = 528734635, G = 1541459225;
      const Y = new Uint32Array(64);
      function oe(S) {
        let E = 0, C = S.length;
        for (; C >= 64; ) {
          let k = _, m = I, d = $, g = N, P = B, y = V, R = K, F = G, D, L, te, W, Q;
          for (L = 0; L < 16; L++)
            te = E + L * 4, Y[L] = (S[te] & 255) << 24 | (S[te + 1] & 255) << 16 | (S[te + 2] & 255) << 8 | S[te + 3] & 255;
          for (L = 16; L < 64; L++)
            D = Y[L - 2], W = (D >>> 17 | D << 32 - 17) ^ (D >>> 19 | D << 32 - 19) ^ D >>> 10, D = Y[L - 15], Q = (D >>> 7 | D << 32 - 7) ^ (D >>> 18 | D << 32 - 18) ^ D >>> 3, Y[L] = (W + Y[L - 7] | 0) + (Q + Y[L - 16] | 0) | 0;
          for (L = 0; L < 64; L++)
            W = (((P >>> 6 | P << 32 - 6) ^ (P >>> 11 | P << 32 - 11) ^ (P >>> 25 | P << 32 - 25)) + (P & y ^ ~P & R) | 0) + (F + (T[L] + Y[L] | 0) | 0) | 0, Q = ((k >>> 2 | k << 32 - 2) ^ (k >>> 13 | k << 32 - 13) ^ (k >>> 22 | k << 32 - 22)) + (k & m ^ k & d ^ m & d) | 0, F = R, R = y, y = P, P = g + W | 0, g = d, d = m, m = k, k = W + Q | 0;
          _ = _ + k | 0, I = I + m | 0, $ = $ + d | 0, N = N + g | 0, B = B + P | 0, V = V + y | 0, K = K + R | 0, G = G + F | 0, E += 64, C -= 64;
        }
      }
      oe(w);
      let J, ue = w.length % 64, M = w.length / 536870912 | 0, c = w.length << 3, h = ue < 56 ? 56 : 120, v = w.slice(w.length - ue, w.length);
      for (v.push(128), J = ue + 1; J < h; J++)
        v.push(0);
      return v.push(M >>> 24 & 255), v.push(M >>> 16 & 255), v.push(M >>> 8 & 255), v.push(M >>> 0 & 255), v.push(c >>> 24 & 255), v.push(c >>> 16 & 255), v.push(c >>> 8 & 255), v.push(c >>> 0 & 255), oe(v), [
        _ >>> 24 & 255,
        _ >>> 16 & 255,
        _ >>> 8 & 255,
        _ >>> 0 & 255,
        I >>> 24 & 255,
        I >>> 16 & 255,
        I >>> 8 & 255,
        I >>> 0 & 255,
        $ >>> 24 & 255,
        $ >>> 16 & 255,
        $ >>> 8 & 255,
        $ >>> 0 & 255,
        N >>> 24 & 255,
        N >>> 16 & 255,
        N >>> 8 & 255,
        N >>> 0 & 255,
        B >>> 24 & 255,
        B >>> 16 & 255,
        B >>> 8 & 255,
        B >>> 0 & 255,
        V >>> 24 & 255,
        V >>> 16 & 255,
        V >>> 8 & 255,
        V >>> 0 & 255,
        K >>> 24 & 255,
        K >>> 16 & 255,
        K >>> 8 & 255,
        K >>> 0 & 255,
        G >>> 24 & 255,
        G >>> 16 & 255,
        G >>> 8 & 255,
        G >>> 0 & 255
      ];
    }
    function s(w, T, _) {
      w = w.length <= 64 ? w : r(w);
      const I = 64 + T.length + 4, $ = new Array(I), N = new Array(64);
      let B, V = [];
      for (B = 0; B < 64; B++)
        $[B] = 54;
      for (B = 0; B < w.length; B++)
        $[B] ^= w[B];
      for (B = 0; B < T.length; B++)
        $[64 + B] = T[B];
      for (B = I - 4; B < I; B++)
        $[B] = 0;
      for (B = 0; B < 64; B++)
        N[B] = 92;
      for (B = 0; B < w.length; B++)
        N[B] ^= w[B];
      function K() {
        for (let G = I - 1; G >= I - 4; G--) {
          if ($[G]++, $[G] <= 255)
            return;
          $[G] = 0;
        }
      }
      for (; _ >= 32; )
        K(), V = V.concat(r(N.concat(r($)))), _ -= 32;
      return _ > 0 && (K(), V = V.concat(r(N.concat(r($))).slice(0, _))), V;
    }
    function a(w, T, _, I, $) {
      let N;
      for (p(w, (2 * _ - 1) * 16, $, 0, 16), N = 0; N < 2 * _; N++)
        l(w, N * 16, $, 16), u($, I), p($, 0, w, T + N * 16, 16);
      for (N = 0; N < _; N++)
        p(w, T + N * 2 * 16, w, N * 16, 16);
      for (N = 0; N < _; N++)
        p(w, T + (N * 2 + 1) * 16, w, (N + _) * 16, 16);
    }
    function o(w, T) {
      return w << T | w >>> 32 - T;
    }
    function u(w, T) {
      p(w, 0, T, 0, 16);
      for (let _ = 8; _ > 0; _ -= 2)
        T[4] ^= o(T[0] + T[12], 7), T[8] ^= o(T[4] + T[0], 9), T[12] ^= o(T[8] + T[4], 13), T[0] ^= o(T[12] + T[8], 18), T[9] ^= o(T[5] + T[1], 7), T[13] ^= o(T[9] + T[5], 9), T[1] ^= o(T[13] + T[9], 13), T[5] ^= o(T[1] + T[13], 18), T[14] ^= o(T[10] + T[6], 7), T[2] ^= o(T[14] + T[10], 9), T[6] ^= o(T[2] + T[14], 13), T[10] ^= o(T[6] + T[2], 18), T[3] ^= o(T[15] + T[11], 7), T[7] ^= o(T[3] + T[15], 9), T[11] ^= o(T[7] + T[3], 13), T[15] ^= o(T[11] + T[7], 18), T[1] ^= o(T[0] + T[3], 7), T[2] ^= o(T[1] + T[0], 9), T[3] ^= o(T[2] + T[1], 13), T[0] ^= o(T[3] + T[2], 18), T[6] ^= o(T[5] + T[4], 7), T[7] ^= o(T[6] + T[5], 9), T[4] ^= o(T[7] + T[6], 13), T[5] ^= o(T[4] + T[7], 18), T[11] ^= o(T[10] + T[9], 7), T[8] ^= o(T[11] + T[10], 9), T[9] ^= o(T[8] + T[11], 13), T[10] ^= o(T[9] + T[8], 18), T[12] ^= o(T[15] + T[14], 7), T[13] ^= o(T[12] + T[15], 9), T[14] ^= o(T[13] + T[12], 13), T[15] ^= o(T[14] + T[13], 18);
      for (let _ = 0; _ < 16; ++_)
        w[_] += T[_];
    }
    function l(w, T, _, I) {
      for (let $ = 0; $ < I; $++)
        _[$] ^= w[T + $];
    }
    function p(w, T, _, I, $) {
      for (; $--; )
        _[I++] = w[T++];
    }
    function f(w) {
      if (!w || typeof w.length != "number")
        return !1;
      for (let T = 0; T < w.length; T++) {
        const _ = w[T];
        if (typeof _ != "number" || _ % 1 || _ < 0 || _ >= 256)
          return !1;
      }
      return !0;
    }
    function b(w, T) {
      if (typeof w != "number" || w % 1)
        throw new Error("invalid " + T);
      return w;
    }
    function A(w, T, _, I, $, N, B) {
      if (_ = b(_, "N"), I = b(I, "r"), $ = b($, "p"), N = b(N, "dkLen"), _ === 0 || _ & _ - 1)
        throw new Error("N must be power of 2");
      if (_ > 2147483647 / 128 / I)
        throw new Error("N too large");
      if (I > 2147483647 / 128 / $)
        throw new Error("r too large");
      if (!f(w))
        throw new Error("password must be an array or buffer");
      if (w = Array.prototype.slice.call(w), !f(T))
        throw new Error("salt must be an array or buffer");
      T = Array.prototype.slice.call(T);
      let V = s(w, T, $ * 128 * I);
      const K = new Uint32Array($ * 32 * I);
      for (let P = 0; P < K.length; P++) {
        const y = P * 4;
        K[P] = (V[y + 3] & 255) << 24 | (V[y + 2] & 255) << 16 | (V[y + 1] & 255) << 8 | (V[y + 0] & 255) << 0;
      }
      const G = new Uint32Array(64 * I), Y = new Uint32Array(32 * I * _), oe = 32 * I, J = new Uint32Array(16), ue = new Uint32Array(16), M = $ * _ * 2;
      let c = 0, h = null, v = !1, S = 0, E = 0, C, k;
      const m = B ? parseInt(1e3 / I) : 4294967295, d = typeof setImmediate < "u" ? setImmediate : setTimeout, g = function() {
        if (v)
          return B(new Error("cancelled"), c / M);
        let P;
        switch (S) {
          case 0:
            k = E * 32 * I, p(K, k, G, 0, oe), S = 1, C = 0;
          case 1:
            P = _ - C, P > m && (P = m);
            for (let R = 0; R < P; R++)
              p(G, 0, Y, (C + R) * oe, oe), a(G, oe, I, J, ue);
            if (C += P, c += P, B) {
              const R = parseInt(1e3 * c / M);
              if (R !== h) {
                if (v = B(null, c / M), v)
                  break;
                h = R;
              }
            }
            if (C < _)
              break;
            C = 0, S = 2;
          case 2:
            P = _ - C, P > m && (P = m);
            for (let R = 0; R < P; R++) {
              const F = (2 * I - 1) * 16, D = G[F] & _ - 1;
              l(Y, D * oe, G, oe), a(G, oe, I, J, ue);
            }
            if (C += P, c += P, B) {
              const R = parseInt(1e3 * c / M);
              if (R !== h) {
                if (v = B(null, c / M), v)
                  break;
                h = R;
              }
            }
            if (C < _)
              break;
            if (p(G, 0, K, k, oe), E++, E < $) {
              S = 0;
              break;
            }
            V = [];
            for (let R = 0; R < K.length; R++)
              V.push(K[R] >> 0 & 255), V.push(K[R] >> 8 & 255), V.push(K[R] >> 16 & 255), V.push(K[R] >> 24 & 255);
            const y = s(w, V, N);
            return B && B(null, 1, y), y;
        }
        B && d(g);
      };
      if (!B)
        for (; ; ) {
          const P = g();
          if (P != null)
            return P;
        }
      g();
    }
    const x = {
      scrypt: function(w, T, _, I, $, N, B) {
        return new Promise(function(V, K) {
          let G = 0;
          B && B(0), A(w, T, _, I, $, N, function(Y, oe, J) {
            if (Y)
              K(Y);
            else if (J)
              B && G !== 1 && B(1), V(new Uint8Array(J));
            else if (B && oe !== G)
              return G = oe, B(oe);
          });
        });
      },
      syncScrypt: function(w, T, _, I, $, N) {
        return new Uint8Array(A(w, T, _, I, $, N));
      }
    };
    n.exports = x;
  })();
})(K9);
const O0 = Ny, W9 = "random/5.7.0", Dy = new O(W9);
function J9() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof ba < "u")
    return ba;
  throw new Error("unable to locate global object");
}
const q2 = J9();
let $c = q2.crypto || q2.msCrypto;
(!$c || !$c.getRandomValues) && (Dy.warn("WARNING: Missing strong random number source"), $c = {
  getRandomValues: function(n) {
    return Dy.throwError("no secure random source avaialble", O.errors.UNSUPPORTED_OPERATION, {
      operation: "crypto.getRandomValues"
    });
  }
});
function uo(n) {
  (n <= 0 || n > 1024 || n % 1 || n != n) && Dy.throwArgumentError("invalid length", "length", n);
  const e = new Uint8Array(n);
  return $c.getRandomValues(e), q(e);
}
function Q9(n) {
  n = n.slice();
  for (let e = n.length - 1; e > 0; e--) {
    const t = Math.floor(Math.random() * (e + 1)), i = n[e];
    n[e] = n[t], n[t] = i;
  }
  return n;
}
const Y9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  randomBytes: uo,
  shuffled: Q9
}, Symbol.toStringTag, { value: "Module" }));
var X9 = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
const $y = new O(B5);
function H2(n) {
  return n != null && n.mnemonic && n.mnemonic.phrase;
}
class Z9 extends Ps {
  isKeystoreAccount(e) {
    return !!(e && e._isKeystoreAccount);
  }
}
function ek(n, e, t) {
  if (Ot(n, "crypto/cipher") === "aes-128-ctr") {
    const r = da(Ot(n, "crypto/cipherparams/iv")), s = new Yi.Counter(r), a = new Yi.ModeOfOperation.ctr(e, s);
    return q(a.decrypt(t));
  }
  return null;
}
function N5(n, e) {
  const t = da(Ot(n, "crypto/ciphertext"));
  if (H(Ie(Ve([e.slice(16, 32), t]))).substring(2) !== Ot(n, "crypto/mac").toLowerCase())
    throw new Error("invalid password");
  const r = ek(n, e.slice(0, 16), t);
  r || $y.throwError("unsupported cipher", O.errors.UNSUPPORTED_OPERATION, {
    operation: "decrypt"
  });
  const s = e.slice(32, 64), a = vs(r);
  if (n.address) {
    let u = n.address.toLowerCase();
    if (u.substring(0, 2) !== "0x" && (u = "0x" + u), Be(u) !== a)
      throw new Error("address mismatch");
  }
  const o = {
    _isKeystoreAccount: !0,
    address: a,
    privateKey: H(r)
  };
  if (Ot(n, "x-ethers/version") === "0.1") {
    const u = da(Ot(n, "x-ethers/mnemonicCiphertext")), l = da(Ot(n, "x-ethers/mnemonicCounter")), p = new Yi.Counter(l), f = new Yi.ModeOfOperation.ctr(s, p), b = Ot(n, "x-ethers/path") || Po, A = Ot(n, "x-ethers/locale") || "en", x = q(f.decrypt(u));
    try {
      const w = pp(x, A), T = Yn.fromMnemonic(w, null, A).derivePath(b);
      if (T.privateKey != o.privateKey)
        throw new Error("mnemonic mismatch");
      o.mnemonic = T.mnemonic;
    } catch (w) {
      if (w.code !== O.errors.INVALID_ARGUMENT || w.argument !== "wordlist")
        throw w;
    }
  }
  return new Z9(o);
}
function D5(n, e, t, i, r) {
  return q(R0(n, e, t, i, r));
}
function tk(n, e, t, i, r) {
  return Promise.resolve(D5(n, e, t, i, r));
}
function $5(n, e, t, i, r) {
  const s = P0(e), a = Ot(n, "crypto/kdf");
  if (a && typeof a == "string") {
    const o = function(u, l) {
      return $y.throwArgumentError("invalid key-derivation function parameters", u, l);
    };
    if (a.toLowerCase() === "scrypt") {
      const u = da(Ot(n, "crypto/kdfparams/salt")), l = parseInt(Ot(n, "crypto/kdfparams/n")), p = parseInt(Ot(n, "crypto/kdfparams/r")), f = parseInt(Ot(n, "crypto/kdfparams/p"));
      (!l || !p || !f) && o("kdf", a), l & l - 1 && o("N", l);
      const b = parseInt(Ot(n, "crypto/kdfparams/dklen"));
      return b !== 32 && o("dklen", b), i(s, u, l, p, f, 64, r);
    } else if (a.toLowerCase() === "pbkdf2") {
      const u = da(Ot(n, "crypto/kdfparams/salt"));
      let l = null;
      const p = Ot(n, "crypto/kdfparams/prf");
      p === "hmac-sha256" ? l = "sha256" : p === "hmac-sha512" ? l = "sha512" : o("prf", p);
      const f = parseInt(Ot(n, "crypto/kdfparams/c")), b = parseInt(Ot(n, "crypto/kdfparams/dklen"));
      return b !== 32 && o("dklen", b), t(s, u, f, b, l);
    }
  }
  return $y.throwArgumentError("unsupported key-derivation function", "kdf", a);
}
function F5(n, e) {
  const t = JSON.parse(n), i = $5(t, e, D5, O0.syncScrypt);
  return N5(t, i);
}
function L5(n, e, t) {
  return X9(this, void 0, void 0, function* () {
    const i = JSON.parse(n), r = yield $5(i, e, tk, O0.scrypt, t);
    return N5(i, r);
  });
}
function U5(n, e, t, i) {
  try {
    if (Be(n.address) !== vs(n.privateKey))
      throw new Error("address/privateKey mismatch");
    if (H2(n)) {
      const T = n.mnemonic;
      if (Yn.fromMnemonic(T.phrase, null, T.locale).derivePath(T.path || Po).privateKey != n.privateKey)
        throw new Error("mnemonic mismatch");
    }
  } catch (T) {
    return Promise.reject(T);
  }
  typeof t == "function" && !i && (i = t, t = {}), t || (t = {});
  const r = q(n.privateKey), s = P0(e);
  let a = null, o = null, u = null;
  if (H2(n)) {
    const T = n.mnemonic;
    a = q(dp(T.phrase, T.locale || "en")), o = T.path || Po, u = T.locale || "en";
  }
  let l = t.client;
  l || (l = "ethers.js");
  let p = null;
  t.salt ? p = q(t.salt) : p = uo(32);
  let f = null;
  if (t.iv) {
    if (f = q(t.iv), f.length !== 16)
      throw new Error("invalid iv");
  } else
    f = uo(16);
  let b = null;
  if (t.uuid) {
    if (b = q(t.uuid), b.length !== 16)
      throw new Error("invalid uuid");
  } else
    b = uo(16);
  let A = 1 << 17, x = 8, w = 1;
  return t.scrypt && (t.scrypt.N && (A = t.scrypt.N), t.scrypt.r && (x = t.scrypt.r), t.scrypt.p && (w = t.scrypt.p)), O0.scrypt(s, p, A, x, w, 64, i).then((T) => {
    T = q(T);
    const _ = T.slice(0, 16), I = T.slice(16, 32), $ = T.slice(32, 64), N = new Yi.Counter(f), B = new Yi.ModeOfOperation.ctr(_, N), V = q(B.encrypt(r)), K = Ie(Ve([I, V])), G = {
      address: n.address.substring(2).toLowerCase(),
      id: z9(b),
      version: 3,
      crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: H(f).substring(2)
        },
        ciphertext: H(V).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: H(p).substring(2),
          n: A,
          dklen: 32,
          p: w,
          r: x
        },
        mac: K.substring(2)
      }
    };
    if (a) {
      const Y = uo(16), oe = new Yi.Counter(Y), J = new Yi.ModeOfOperation.ctr($, oe), ue = q(J.encrypt(a)), M = /* @__PURE__ */ new Date(), c = M.getUTCFullYear() + "-" + ou(M.getUTCMonth() + 1, 2) + "-" + ou(M.getUTCDate(), 2) + "T" + ou(M.getUTCHours(), 2) + "-" + ou(M.getUTCMinutes(), 2) + "-" + ou(M.getUTCSeconds(), 2) + ".0Z";
      G["x-ethers"] = {
        client: l,
        gethFilename: "UTC--" + c + "--" + G.address,
        mnemonicCounter: H(Y).substring(2),
        mnemonicCiphertext: H(ue).substring(2),
        path: o,
        locale: u,
        version: "0.1"
      };
    }
    return JSON.stringify(G);
  });
}
function V5(n, e, t) {
  if (fp(n)) {
    t && t(0);
    const i = I0(n, e);
    return t && t(1), Promise.resolve(i);
  }
  return yp(n) ? L5(n, e, t) : Promise.reject(new Error("invalid JSON wallet"));
}
function j5(n, e) {
  if (fp(n))
    return I0(n, e);
  if (yp(n))
    return F5(n, e);
  throw new Error("invalid JSON wallet");
}
const nk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decryptCrowdsale: I0,
  decryptJsonWallet: V5,
  decryptJsonWalletSync: j5,
  decryptKeystore: L5,
  decryptKeystoreSync: F5,
  encryptKeystore: U5,
  getJsonWalletAddress: H9,
  isCrowdsaleWallet: fp,
  isKeystoreWallet: yp
}, Symbol.toStringTag, { value: "Module" })), ik = /* @__PURE__ */ Pt(nk), rk = /* @__PURE__ */ Pt(tM), sk = /* @__PURE__ */ Pt(lS), K2 = /* @__PURE__ */ Pt(R9), ak = "solidity/5.7.0", ok = new RegExp("^bytes([0-9]+)$"), uk = new RegExp("^(u?int)([0-9]*)$"), lk = new RegExp("^(.*)\\[([0-9]*)\\]$"), ck = "0000000000000000000000000000000000000000000000000000000000000000", ro = new O(ak);
function z5(n, e, t) {
  switch (n) {
    case "address":
      return t ? ku(e, 32) : q(e);
    case "string":
      return Dt(e);
    case "bytes":
      return q(e);
    case "bool":
      return e = e ? "0x01" : "0x00", t ? ku(e, 32) : q(e);
  }
  let i = n.match(uk);
  if (i) {
    let r = parseInt(i[2] || "256");
    return (i[2] && String(r) !== i[2] || r % 8 !== 0 || r === 0 || r > 256) && ro.throwArgumentError("invalid number type", "type", n), t && (r = 256), e = z.from(e).toTwos(r), ku(e, r / 8);
  }
  if (i = n.match(ok), i) {
    const r = parseInt(i[1]);
    return (String(r) !== i[1] || r === 0 || r > 32) && ro.throwArgumentError("invalid bytes type", "type", n), q(e).byteLength !== r && ro.throwArgumentError(`invalid value for ${n}`, "value", e), t ? q((e + ck).substring(0, 66)) : e;
  }
  if (i = n.match(lk), i && Array.isArray(e)) {
    const r = i[1];
    parseInt(i[2] || String(e.length)) != e.length && ro.throwArgumentError(`invalid array length for ${n}`, "value", e);
    const a = [];
    return e.forEach(function(o) {
      a.push(z5(r, o, !0));
    }), Ve(a);
  }
  return ro.throwArgumentError("invalid type", "type", n);
}
function B0(n, e) {
  n.length != e.length && ro.throwArgumentError("wrong number of values; expected ${ types.length }", "values", e);
  const t = [];
  return n.forEach(function(i, r) {
    t.push(z5(i, e[r]));
  }), H(Ve(t));
}
function dk(n, e) {
  return Ie(B0(n, e));
}
function pk(n, e) {
  return Ur(B0(n, e));
}
const fk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  keccak256: dk,
  pack: B0,
  sha256: pk
}, Symbol.toStringTag, { value: "Module" })), yk = /* @__PURE__ */ Pt(fk), hk = /* @__PURE__ */ Pt(Y9), mk = /* @__PURE__ */ Pt(xS), bk = /* @__PURE__ */ Pt(iM), gk = /* @__PURE__ */ Pt(vR), W2 = /* @__PURE__ */ Pt(jM), vk = /* @__PURE__ */ Pt(CR), xk = "units/5.7.0", G5 = new O(xk), q5 = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
function Tk(n) {
  const e = String(n).split(".");
  (e.length > 2 || !e[0].match(/^-?[0-9]*$/) || e[1] && !e[1].match(/^[0-9]*$/) || n === "." || n === "-.") && G5.throwArgumentError("invalid value", "value", n);
  let t = e[0], i = "";
  for (t.substring(0, 1) === "-" && (i = "-", t = t.substring(1)); t.substring(0, 1) === "0"; )
    t = t.substring(1);
  t === "" && (t = "0");
  let r = "";
  for (e.length === 2 && (r = "." + (e[1] || "0")); r.length > 2 && r[r.length - 1] === "0"; )
    r = r.substring(0, r.length - 1);
  const s = [];
  for (; t.length; )
    if (t.length <= 3) {
      s.unshift(t);
      break;
    } else {
      const a = t.length - 3;
      s.unshift(t.substring(a)), t = t.substring(0, a);
    }
  return i + s.join(",") + r;
}
function H5(n, e) {
  if (typeof e == "string") {
    const t = q5.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return kc(n, e ?? 18);
}
function K5(n, e) {
  if (typeof n != "string" && G5.throwArgumentError("value must be a string", "value", n), typeof e == "string") {
    const t = q5.indexOf(e);
    t !== -1 && (e = 3 * t);
  }
  return zi(n, e ?? 18);
}
function wk(n) {
  return H5(n, 18);
}
function Ak(n) {
  return K5(n, 18);
}
const Ek = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  commify: Tk,
  formatEther: wk,
  formatUnits: H5,
  parseEther: Ak,
  parseUnits: K5
}, Symbol.toStringTag, { value: "Module" })), Sk = /* @__PURE__ */ Pt(Ek), Mk = "wallet/5.7.0";
var J2 = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
const Qa = new O(Mk);
function Ck(n) {
  return n != null && Ae(n.privateKey, 32) && n.address != null;
}
function _k(n) {
  const e = n.mnemonic;
  return e && e.phrase;
}
class sa extends Ua {
  constructor(e, t) {
    if (super(), Ck(e)) {
      const i = new ca(e.privateKey);
      if (U(this, "_signingKey", () => i), U(this, "address", vs(this.publicKey)), this.address !== Be(e.address) && Qa.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), _k(e)) {
        const r = e.mnemonic;
        U(this, "_mnemonic", () => ({
          phrase: r.phrase,
          path: r.path || Po,
          locale: r.locale || "en"
        }));
        const s = this.mnemonic, a = Yn.fromMnemonic(s.phrase, null, s.locale).derivePath(s.path);
        vs(a.privateKey) !== this.address && Qa.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
      } else
        U(this, "_mnemonic", () => null);
    } else {
      if (ca.isSigningKey(e))
        e.curve !== "secp256k1" && Qa.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), U(this, "_signingKey", () => e);
      else {
        typeof e == "string" && e.match(/^[0-9a-f]*$/i) && e.length === 64 && (e = "0x" + e);
        const i = new ca(e);
        U(this, "_signingKey", () => i);
      }
      U(this, "_mnemonic", () => null), U(this, "address", vs(this.publicKey));
    }
    t && !h0.isProvider(t) && Qa.throwArgumentError("invalid provider", "provider", t), U(this, "provider", t || null);
  }
  get mnemonic() {
    return this._mnemonic();
  }
  get privateKey() {
    return this._signingKey().privateKey;
  }
  get publicKey() {
    return this._signingKey().publicKey;
  }
  getAddress() {
    return Promise.resolve(this.address);
  }
  connect(e) {
    return new sa(this, e);
  }
  signTransaction(e) {
    return _t(e).then((t) => {
      t.from != null && (Be(t.from) !== this.address && Qa.throwArgumentError("transaction from address mismatch", "transaction.from", e.from), delete t.from);
      const i = this._signingKey().signDigest(Ie(Iy(t)));
      return Iy(t, i);
    });
  }
  signMessage(e) {
    return J2(this, void 0, void 0, function* () {
      return Ty(this._signingKey().signDigest(y0(e)));
    });
  }
  _signTypedData(e, t, i) {
    return J2(this, void 0, void 0, function* () {
      const r = yield rn.resolveNames(e, t, i, (s) => (this.provider == null && Qa.throwError("cannot resolve ENS names without a provider", O.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName",
        value: s
      }), this.provider.resolveName(s)));
      return Ty(this._signingKey().signDigest(rn.hash(r.domain, t, r.value)));
    });
  }
  encrypt(e, t, i) {
    if (typeof t == "function" && !i && (i = t, t = {}), i && typeof i != "function")
      throw new Error("invalid callback");
    return t || (t = {}), U5(this, e, t, i);
  }
  /**
   *  Static methods to create Wallet instances.
   */
  static createRandom(e) {
    let t = uo(16);
    e || (e = {}), e.extraEntropy && (t = q(Bt(Ie(Ve([t, e.extraEntropy])), 0, 16)));
    const i = pp(t, e.locale);
    return sa.fromMnemonic(i, e.path, e.locale);
  }
  static fromEncryptedJson(e, t, i) {
    return V5(e, t, i).then((r) => new sa(r));
  }
  static fromEncryptedJsonSync(e, t) {
    return new sa(j5(e, t));
  }
  static fromMnemonic(e, t, i) {
    return t || (t = Po), new sa(Yn.fromMnemonic(e, null, i).derivePath(t));
  }
}
function Rk(n, e) {
  return Wo(y0(n), e);
}
function kk(n, e, t, i) {
  return Wo(rn.hash(n, e, t), i);
}
const Pk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Wallet: sa,
  verifyMessage: Rk,
  verifyTypedData: kk
}, Symbol.toStringTag, { value: "Module" })), Ik = /* @__PURE__ */ Pt(Pk), Ok = "web/5.7.1";
var Bk = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
function Nk(n, e) {
  return Bk(this, void 0, void 0, function* () {
    e == null && (e = {});
    const t = {
      method: e.method || "GET",
      headers: e.headers || {},
      body: e.body || void 0
    };
    if (e.skipFetchSetup !== !0 && (t.mode = "cors", t.cache = "no-cache", t.credentials = "same-origin", t.redirect = "follow", t.referrer = "client"), e.fetchOptions != null) {
      const a = e.fetchOptions;
      a.mode && (t.mode = a.mode), a.cache && (t.cache = a.cache), a.credentials && (t.credentials = a.credentials), a.redirect && (t.redirect = a.redirect), a.referrer && (t.referrer = a.referrer);
    }
    const i = yield fetch(n, t), r = yield i.arrayBuffer(), s = {};
    return i.headers.forEach ? i.headers.forEach((a, o) => {
      s[o.toLowerCase()] = a;
    }) : i.headers.keys().forEach((a) => {
      s[a.toLowerCase()] = i.headers.get(a);
    }), {
      headers: s,
      statusCode: i.status,
      statusMessage: i.statusText,
      body: q(new Uint8Array(r))
    };
  });
}
var Dk = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
const Mi = new O(Ok);
function Q2(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
function rs(n, e) {
  if (n == null)
    return null;
  if (typeof n == "string")
    return n;
  if (Ll(n)) {
    if (e && (e.split("/")[0] === "text" || e.split(";")[0].trim() === "application/json"))
      try {
        return Is(n);
      } catch {
      }
    return H(n);
  }
  return n;
}
function $k(n) {
  return Dt(n.replace(/%([0-9a-f][0-9a-f])/gi, (e, t) => String.fromCharCode(parseInt(t, 16))));
}
function W5(n, e, t) {
  const i = typeof n == "object" && n.throttleLimit != null ? n.throttleLimit : 12;
  Mi.assertArgument(i > 0 && i % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", i);
  const r = typeof n == "object" ? n.throttleCallback : null, s = typeof n == "object" && typeof n.throttleSlotInterval == "number" ? n.throttleSlotInterval : 100;
  Mi.assertArgument(s > 0 && s % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
  const a = typeof n == "object" ? !!n.errorPassThrough : !1, o = {};
  let u = null;
  const l = {
    method: "GET"
  };
  let p = !1, f = 2 * 60 * 1e3;
  if (typeof n == "string")
    u = n;
  else if (typeof n == "object") {
    if ((n == null || n.url == null) && Mi.throwArgumentError("missing URL", "connection.url", n), u = n.url, typeof n.timeout == "number" && n.timeout > 0 && (f = n.timeout), n.headers)
      for (const _ in n.headers)
        o[_.toLowerCase()] = { key: _, value: String(n.headers[_]) }, ["if-none-match", "if-modified-since"].indexOf(_.toLowerCase()) >= 0 && (p = !0);
    if (l.allowGzip = !!n.allowGzip, n.user != null && n.password != null) {
      u.substring(0, 6) !== "https:" && n.allowInsecureAuthentication !== !0 && Mi.throwError("basic authentication requires a secure https url", O.errors.INVALID_ARGUMENT, { argument: "url", url: u, user: n.user, password: "[REDACTED]" });
      const _ = n.user + ":" + n.password;
      o.authorization = {
        key: "Authorization",
        value: "Basic " + f0(Dt(_))
      };
    }
    n.skipFetchSetup != null && (l.skipFetchSetup = !!n.skipFetchSetup), n.fetchOptions != null && (l.fetchOptions = Ut(n.fetchOptions));
  }
  const b = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i"), A = u ? u.match(b) : null;
  if (A)
    try {
      const _ = {
        statusCode: 200,
        statusMessage: "OK",
        headers: { "content-type": A[1] || "text/plain" },
        body: A[2] ? p0(A[3]) : $k(A[3])
      };
      let I = _.body;
      return t && (I = t(_.body, _)), Promise.resolve(I);
    } catch (_) {
      Mi.throwError("processing response error", O.errors.SERVER_ERROR, {
        body: rs(A[1], A[2]),
        error: _,
        requestBody: null,
        requestMethod: "GET",
        url: u
      });
    }
  e && (l.method = "POST", l.body = e, o["content-type"] == null && (o["content-type"] = { key: "Content-Type", value: "application/octet-stream" }), o["content-length"] == null && (o["content-length"] = { key: "Content-Length", value: String(e.length) }));
  const x = {};
  Object.keys(o).forEach((_) => {
    const I = o[_];
    x[I.key] = I.value;
  }), l.headers = x;
  const w = function() {
    let _ = null;
    return { promise: new Promise(function(N, B) {
      f && (_ = setTimeout(() => {
        _ != null && (_ = null, B(Mi.makeError("timeout", O.errors.TIMEOUT, {
          requestBody: rs(l.body, x["content-type"]),
          requestMethod: l.method,
          timeout: f,
          url: u
        })));
      }, f));
    }), cancel: function() {
      _ != null && (clearTimeout(_), _ = null);
    } };
  }(), T = function() {
    return Dk(this, void 0, void 0, function* () {
      for (let _ = 0; _ < i; _++) {
        let I = null;
        try {
          if (I = yield Nk(u, l), _ < i) {
            if (I.statusCode === 301 || I.statusCode === 302) {
              const N = I.headers.location || "";
              if (l.method === "GET" && N.match(/^https:/)) {
                u = I.headers.location;
                continue;
              }
            } else if (I.statusCode === 429) {
              let N = !0;
              if (r && (N = yield r(_, u)), N) {
                let B = 0;
                const V = I.headers["retry-after"];
                typeof V == "string" && V.match(/^[1-9][0-9]*$/) ? B = parseInt(V) * 1e3 : B = s * parseInt(String(Math.random() * Math.pow(2, _))), yield Q2(B);
                continue;
              }
            }
          }
        } catch (N) {
          I = N.response, I == null && (w.cancel(), Mi.throwError("missing response", O.errors.SERVER_ERROR, {
            requestBody: rs(l.body, x["content-type"]),
            requestMethod: l.method,
            serverError: N,
            url: u
          }));
        }
        let $ = I.body;
        if (p && I.statusCode === 304 ? $ = null : !a && (I.statusCode < 200 || I.statusCode >= 300) && (w.cancel(), Mi.throwError("bad response", O.errors.SERVER_ERROR, {
          status: I.statusCode,
          headers: I.headers,
          body: rs($, I.headers ? I.headers["content-type"] : null),
          requestBody: rs(l.body, x["content-type"]),
          requestMethod: l.method,
          url: u
        })), t)
          try {
            const N = yield t($, I);
            return w.cancel(), N;
          } catch (N) {
            if (N.throttleRetry && _ < i) {
              let B = !0;
              if (r && (B = yield r(_, u)), B) {
                const V = s * parseInt(String(Math.random() * Math.pow(2, _)));
                yield Q2(V);
                continue;
              }
            }
            w.cancel(), Mi.throwError("processing response error", O.errors.SERVER_ERROR, {
              body: rs($, I.headers ? I.headers["content-type"] : null),
              error: N,
              requestBody: rs(l.body, x["content-type"]),
              requestMethod: l.method,
              url: u
            });
          }
        return w.cancel(), $;
      }
      return Mi.throwError("failed response", O.errors.SERVER_ERROR, {
        requestBody: rs(l.body, x["content-type"]),
        requestMethod: l.method,
        url: u
      });
    });
  }();
  return Promise.race([w.promise, T]);
}
function hp(n, e, t) {
  let i = (s, a) => {
    let o = null;
    if (s != null)
      try {
        o = JSON.parse(Is(s));
      } catch (u) {
        Mi.throwError("invalid JSON", O.errors.SERVER_ERROR, {
          body: s,
          error: u
        });
      }
    return t && (o = t(o, a)), o;
  }, r = null;
  if (e != null) {
    r = Dt(e);
    const s = typeof n == "string" ? { url: n } : Ut(n);
    s.headers ? Object.keys(s.headers).filter((o) => o.toLowerCase() === "content-type").length !== 0 || (s.headers = Ut(s.headers), s.headers["content-type"] = "application/json") : s.headers = { "content-type": "application/json" }, n = s;
  }
  return W5(n, r, i);
}
function lo(n, e) {
  return e || (e = {}), e = Ut(e), e.floor == null && (e.floor = 0), e.ceiling == null && (e.ceiling = 1e4), e.interval == null && (e.interval = 250), new Promise(function(t, i) {
    let r = null, s = !1;
    const a = () => s ? !1 : (s = !0, r && clearTimeout(r), !0);
    e.timeout && (r = setTimeout(() => {
      a() && i(new Error("timeout"));
    }, e.timeout));
    const o = e.retryLimit;
    let u = 0;
    function l() {
      return n().then(function(p) {
        if (p !== void 0)
          a() && t(p);
        else if (e.oncePoll)
          e.oncePoll.once("poll", l);
        else if (e.onceBlock)
          e.onceBlock.once("block", l);
        else if (!s) {
          if (u++, u > o) {
            a() && i(new Error("retry limit reached"));
            return;
          }
          let f = e.interval * parseInt(String(Math.random() * Math.pow(2, u)));
          f < e.floor && (f = e.floor), f > e.ceiling && (f = e.ceiling), setTimeout(l, f);
        }
        return null;
      }, function(p) {
        a() && i(p);
      });
    }
    l();
  });
}
const Fk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _fetchData: W5,
  fetchJson: hp,
  poll: lo
}, Symbol.toStringTag, { value: "Module" })), Lk = /* @__PURE__ */ Pt(Fk);
(function(n) {
  var e = ls && ls.__createBinding || (Object.create ? function(J, ue, M, c) {
    c === void 0 && (c = M), Object.defineProperty(J, c, { enumerable: !0, get: function() {
      return ue[M];
    } });
  } : function(J, ue, M, c) {
    c === void 0 && (c = M), J[c] = ue[M];
  }), t = ls && ls.__setModuleDefault || (Object.create ? function(J, ue) {
    Object.defineProperty(J, "default", { enumerable: !0, value: ue });
  } : function(J, ue) {
    J.default = ue;
  }), i = ls && ls.__importStar || function(J) {
    if (J && J.__esModule)
      return J;
    var ue = {};
    if (J != null)
      for (var M in J)
        M !== "default" && Object.prototype.hasOwnProperty.call(J, M) && e(ue, J, M);
    return t(ue, J), ue;
  };
  Object.defineProperty(n, "__esModule", { value: !0 }), n.formatBytes32String = n.Utf8ErrorFuncs = n.toUtf8String = n.toUtf8CodePoints = n.toUtf8Bytes = n._toEscapedUtf8String = n.nameprep = n.hexDataSlice = n.hexDataLength = n.hexZeroPad = n.hexValue = n.hexStripZeros = n.hexConcat = n.isHexString = n.hexlify = n.base64 = n.base58 = n.TransactionDescription = n.LogDescription = n.Interface = n.SigningKey = n.HDNode = n.defaultPath = n.isBytesLike = n.isBytes = n.zeroPad = n.stripZeros = n.concat = n.arrayify = n.shallowCopy = n.resolveProperties = n.getStatic = n.defineReadOnly = n.deepCopy = n.checkProperties = n.poll = n.fetchJson = n._fetchData = n.RLP = n.Logger = n.checkResultErrors = n.FormatTypes = n.ParamType = n.FunctionFragment = n.EventFragment = n.ErrorFragment = n.ConstructorFragment = n.Fragment = n.defaultAbiCoder = n.AbiCoder = void 0, n.Indexed = n.Utf8ErrorReason = n.UnicodeNormalizationForm = n.SupportedAlgorithm = n.mnemonicToSeed = n.isValidMnemonic = n.entropyToMnemonic = n.mnemonicToEntropy = n.getAccountPath = n.verifyTypedData = n.verifyMessage = n.recoverPublicKey = n.computePublicKey = n.recoverAddress = n.computeAddress = n.getJsonWalletAddress = n.TransactionTypes = n.serializeTransaction = n.parseTransaction = n.accessListify = n.joinSignature = n.splitSignature = n.soliditySha256 = n.solidityKeccak256 = n.solidityPack = n.shuffled = n.randomBytes = n.sha512 = n.sha256 = n.ripemd160 = n.keccak256 = n.computeHmac = n.commify = n.parseUnits = n.formatUnits = n.parseEther = n.formatEther = n.isAddress = n.getCreate2Address = n.getContractAddress = n.getIcapAddress = n.getAddress = n._TypedDataEncoder = n.id = n.isValidName = n.namehash = n.hashMessage = n.dnsEncode = n.parseBytes32String = void 0;
  var r = g9;
  Object.defineProperty(n, "AbiCoder", { enumerable: !0, get: function() {
    return r.AbiCoder;
  } }), Object.defineProperty(n, "checkResultErrors", { enumerable: !0, get: function() {
    return r.checkResultErrors;
  } }), Object.defineProperty(n, "ConstructorFragment", { enumerable: !0, get: function() {
    return r.ConstructorFragment;
  } }), Object.defineProperty(n, "defaultAbiCoder", { enumerable: !0, get: function() {
    return r.defaultAbiCoder;
  } }), Object.defineProperty(n, "ErrorFragment", { enumerable: !0, get: function() {
    return r.ErrorFragment;
  } }), Object.defineProperty(n, "EventFragment", { enumerable: !0, get: function() {
    return r.EventFragment;
  } }), Object.defineProperty(n, "FormatTypes", { enumerable: !0, get: function() {
    return r.FormatTypes;
  } }), Object.defineProperty(n, "Fragment", { enumerable: !0, get: function() {
    return r.Fragment;
  } }), Object.defineProperty(n, "FunctionFragment", { enumerable: !0, get: function() {
    return r.FunctionFragment;
  } }), Object.defineProperty(n, "Indexed", { enumerable: !0, get: function() {
    return r.Indexed;
  } }), Object.defineProperty(n, "Interface", { enumerable: !0, get: function() {
    return r.Interface;
  } }), Object.defineProperty(n, "LogDescription", { enumerable: !0, get: function() {
    return r.LogDescription;
  } }), Object.defineProperty(n, "ParamType", { enumerable: !0, get: function() {
    return r.ParamType;
  } }), Object.defineProperty(n, "TransactionDescription", { enumerable: !0, get: function() {
    return r.TransactionDescription;
  } });
  var s = v9;
  Object.defineProperty(n, "getAddress", { enumerable: !0, get: function() {
    return s.getAddress;
  } }), Object.defineProperty(n, "getCreate2Address", { enumerable: !0, get: function() {
    return s.getCreate2Address;
  } }), Object.defineProperty(n, "getContractAddress", { enumerable: !0, get: function() {
    return s.getContractAddress;
  } }), Object.defineProperty(n, "getIcapAddress", { enumerable: !0, get: function() {
    return s.getIcapAddress;
  } }), Object.defineProperty(n, "isAddress", { enumerable: !0, get: function() {
    return s.isAddress;
  } });
  var a = i(x9);
  n.base64 = a;
  var o = A9;
  Object.defineProperty(n, "base58", { enumerable: !0, get: function() {
    return o.Base58;
  } });
  var u = E9;
  Object.defineProperty(n, "arrayify", { enumerable: !0, get: function() {
    return u.arrayify;
  } }), Object.defineProperty(n, "concat", { enumerable: !0, get: function() {
    return u.concat;
  } }), Object.defineProperty(n, "hexConcat", { enumerable: !0, get: function() {
    return u.hexConcat;
  } }), Object.defineProperty(n, "hexDataSlice", { enumerable: !0, get: function() {
    return u.hexDataSlice;
  } }), Object.defineProperty(n, "hexDataLength", { enumerable: !0, get: function() {
    return u.hexDataLength;
  } }), Object.defineProperty(n, "hexlify", { enumerable: !0, get: function() {
    return u.hexlify;
  } }), Object.defineProperty(n, "hexStripZeros", { enumerable: !0, get: function() {
    return u.hexStripZeros;
  } }), Object.defineProperty(n, "hexValue", { enumerable: !0, get: function() {
    return u.hexValue;
  } }), Object.defineProperty(n, "hexZeroPad", { enumerable: !0, get: function() {
    return u.hexZeroPad;
  } }), Object.defineProperty(n, "isBytes", { enumerable: !0, get: function() {
    return u.isBytes;
  } }), Object.defineProperty(n, "isBytesLike", { enumerable: !0, get: function() {
    return u.isBytesLike;
  } }), Object.defineProperty(n, "isHexString", { enumerable: !0, get: function() {
    return u.isHexString;
  } }), Object.defineProperty(n, "joinSignature", { enumerable: !0, get: function() {
    return u.joinSignature;
  } }), Object.defineProperty(n, "zeroPad", { enumerable: !0, get: function() {
    return u.zeroPad;
  } }), Object.defineProperty(n, "splitSignature", { enumerable: !0, get: function() {
    return u.splitSignature;
  } }), Object.defineProperty(n, "stripZeros", { enumerable: !0, get: function() {
    return u.stripZeros;
  } });
  var l = S9;
  Object.defineProperty(n, "_TypedDataEncoder", { enumerable: !0, get: function() {
    return l._TypedDataEncoder;
  } }), Object.defineProperty(n, "dnsEncode", { enumerable: !0, get: function() {
    return l.dnsEncode;
  } }), Object.defineProperty(n, "hashMessage", { enumerable: !0, get: function() {
    return l.hashMessage;
  } }), Object.defineProperty(n, "id", { enumerable: !0, get: function() {
    return l.id;
  } }), Object.defineProperty(n, "isValidName", { enumerable: !0, get: function() {
    return l.isValidName;
  } }), Object.defineProperty(n, "namehash", { enumerable: !0, get: function() {
    return l.namehash;
  } });
  var p = V9;
  Object.defineProperty(n, "defaultPath", { enumerable: !0, get: function() {
    return p.defaultPath;
  } }), Object.defineProperty(n, "entropyToMnemonic", { enumerable: !0, get: function() {
    return p.entropyToMnemonic;
  } }), Object.defineProperty(n, "getAccountPath", { enumerable: !0, get: function() {
    return p.getAccountPath;
  } }), Object.defineProperty(n, "HDNode", { enumerable: !0, get: function() {
    return p.HDNode;
  } }), Object.defineProperty(n, "isValidMnemonic", { enumerable: !0, get: function() {
    return p.isValidMnemonic;
  } }), Object.defineProperty(n, "mnemonicToEntropy", { enumerable: !0, get: function() {
    return p.mnemonicToEntropy;
  } }), Object.defineProperty(n, "mnemonicToSeed", { enumerable: !0, get: function() {
    return p.mnemonicToSeed;
  } });
  var f = ik;
  Object.defineProperty(n, "getJsonWalletAddress", { enumerable: !0, get: function() {
    return f.getJsonWalletAddress;
  } });
  var b = rk;
  Object.defineProperty(n, "keccak256", { enumerable: !0, get: function() {
    return b.keccak256;
  } });
  var A = sk;
  Object.defineProperty(n, "Logger", { enumerable: !0, get: function() {
    return A.Logger;
  } });
  var x = K2;
  Object.defineProperty(n, "computeHmac", { enumerable: !0, get: function() {
    return x.computeHmac;
  } }), Object.defineProperty(n, "ripemd160", { enumerable: !0, get: function() {
    return x.ripemd160;
  } }), Object.defineProperty(n, "sha256", { enumerable: !0, get: function() {
    return x.sha256;
  } }), Object.defineProperty(n, "sha512", { enumerable: !0, get: function() {
    return x.sha512;
  } });
  var w = yk;
  Object.defineProperty(n, "solidityKeccak256", { enumerable: !0, get: function() {
    return w.keccak256;
  } }), Object.defineProperty(n, "solidityPack", { enumerable: !0, get: function() {
    return w.pack;
  } }), Object.defineProperty(n, "soliditySha256", { enumerable: !0, get: function() {
    return w.sha256;
  } });
  var T = hk;
  Object.defineProperty(n, "randomBytes", { enumerable: !0, get: function() {
    return T.randomBytes;
  } }), Object.defineProperty(n, "shuffled", { enumerable: !0, get: function() {
    return T.shuffled;
  } });
  var _ = mk;
  Object.defineProperty(n, "checkProperties", { enumerable: !0, get: function() {
    return _.checkProperties;
  } }), Object.defineProperty(n, "deepCopy", { enumerable: !0, get: function() {
    return _.deepCopy;
  } }), Object.defineProperty(n, "defineReadOnly", { enumerable: !0, get: function() {
    return _.defineReadOnly;
  } }), Object.defineProperty(n, "getStatic", { enumerable: !0, get: function() {
    return _.getStatic;
  } }), Object.defineProperty(n, "resolveProperties", { enumerable: !0, get: function() {
    return _.resolveProperties;
  } }), Object.defineProperty(n, "shallowCopy", { enumerable: !0, get: function() {
    return _.shallowCopy;
  } });
  var I = i(bk);
  n.RLP = I;
  var $ = gk;
  Object.defineProperty(n, "computePublicKey", { enumerable: !0, get: function() {
    return $.computePublicKey;
  } }), Object.defineProperty(n, "recoverPublicKey", { enumerable: !0, get: function() {
    return $.recoverPublicKey;
  } }), Object.defineProperty(n, "SigningKey", { enumerable: !0, get: function() {
    return $.SigningKey;
  } });
  var N = W2;
  Object.defineProperty(n, "formatBytes32String", { enumerable: !0, get: function() {
    return N.formatBytes32String;
  } }), Object.defineProperty(n, "nameprep", { enumerable: !0, get: function() {
    return N.nameprep;
  } }), Object.defineProperty(n, "parseBytes32String", { enumerable: !0, get: function() {
    return N.parseBytes32String;
  } }), Object.defineProperty(n, "_toEscapedUtf8String", { enumerable: !0, get: function() {
    return N._toEscapedUtf8String;
  } }), Object.defineProperty(n, "toUtf8Bytes", { enumerable: !0, get: function() {
    return N.toUtf8Bytes;
  } }), Object.defineProperty(n, "toUtf8CodePoints", { enumerable: !0, get: function() {
    return N.toUtf8CodePoints;
  } }), Object.defineProperty(n, "toUtf8String", { enumerable: !0, get: function() {
    return N.toUtf8String;
  } }), Object.defineProperty(n, "Utf8ErrorFuncs", { enumerable: !0, get: function() {
    return N.Utf8ErrorFuncs;
  } });
  var B = vk;
  Object.defineProperty(n, "accessListify", { enumerable: !0, get: function() {
    return B.accessListify;
  } }), Object.defineProperty(n, "computeAddress", { enumerable: !0, get: function() {
    return B.computeAddress;
  } }), Object.defineProperty(n, "parseTransaction", { enumerable: !0, get: function() {
    return B.parse;
  } }), Object.defineProperty(n, "recoverAddress", { enumerable: !0, get: function() {
    return B.recoverAddress;
  } }), Object.defineProperty(n, "serializeTransaction", { enumerable: !0, get: function() {
    return B.serialize;
  } }), Object.defineProperty(n, "TransactionTypes", { enumerable: !0, get: function() {
    return B.TransactionTypes;
  } });
  var V = Sk;
  Object.defineProperty(n, "commify", { enumerable: !0, get: function() {
    return V.commify;
  } }), Object.defineProperty(n, "formatEther", { enumerable: !0, get: function() {
    return V.formatEther;
  } }), Object.defineProperty(n, "parseEther", { enumerable: !0, get: function() {
    return V.parseEther;
  } }), Object.defineProperty(n, "formatUnits", { enumerable: !0, get: function() {
    return V.formatUnits;
  } }), Object.defineProperty(n, "parseUnits", { enumerable: !0, get: function() {
    return V.parseUnits;
  } });
  var K = Ik;
  Object.defineProperty(n, "verifyMessage", { enumerable: !0, get: function() {
    return K.verifyMessage;
  } }), Object.defineProperty(n, "verifyTypedData", { enumerable: !0, get: function() {
    return K.verifyTypedData;
  } });
  var G = Lk;
  Object.defineProperty(n, "_fetchData", { enumerable: !0, get: function() {
    return G._fetchData;
  } }), Object.defineProperty(n, "fetchJson", { enumerable: !0, get: function() {
    return G.fetchJson;
  } }), Object.defineProperty(n, "poll", { enumerable: !0, get: function() {
    return G.poll;
  } });
  var Y = K2;
  Object.defineProperty(n, "SupportedAlgorithm", { enumerable: !0, get: function() {
    return Y.SupportedAlgorithm;
  } });
  var oe = W2;
  Object.defineProperty(n, "UnicodeNormalizationForm", { enumerable: !0, get: function() {
    return oe.UnicodeNormalizationForm;
  } }), Object.defineProperty(n, "Utf8ErrorReason", { enumerable: !0, get: function() {
    return oe.Utf8ErrorReason;
  } });
})(C0);
function Uk(n, e) {
  if (typeof n != "number" || Number.isInteger(n) || isNaN(n))
    return n;
  const t = n.toString().split(".");
  return +`${t[0]}.${t[1].slice(0, e)}`;
}
function J5(n) {
  switch (n) {
    case ki["1d"]:
      return "hour";
    case ki["1h"]:
      return "minute";
    case ki["1m"]:
    case ki["1w"]:
    case ki["1y"]:
      return "day";
  }
}
function Q5(n) {
  const e = /* @__PURE__ */ new Date();
  switch (n) {
    case ki["1h"]:
      e.setMinutes(e.getMinutes() - 60);
      break;
    case ki["1d"]:
      e.setHours(e.getHours() - 24);
      break;
    case ki["1w"]:
      e.setDate(e.getDate() - 7);
      break;
    case ki["1m"]:
      e.setMonth(e.getMonth() - 1);
      break;
    case ki["1y"]:
      e.setFullYear(e.getFullYear() - 1);
      break;
  }
  return e.getTime();
}
const Vk = (n, e) => {
  for (const t in e) {
    const i = new RegExp("{" + t + "}", "gm");
    n = n.replace(i, e[t]);
  }
  return n;
}, Y2 = (n, e) => {
  const t = typeof n;
  return (t === "string" || t === "number") && (n = Uk(Number(n), Number(e))), C0.parseUnits(n.toString(), e);
}, Xt = (n, e) => C0.formatUnits(n.toString(), e), N0 = ye.createInterface();
function jk({ mustBeMetaMask: n = !1, silent: e = !1, timeout: t = 3e3 } = {}) {
  r();
  let i = !1;
  return new Promise((s) => {
    window.ethereum ? a() : (window.addEventListener("ethereum#initialized", a, { once: !0 }), setTimeout(() => {
      a();
    }, t));
    function a() {
      if (i)
        return;
      i = !0, window.removeEventListener("ethereum#initialized", a);
      const { ethereum: o } = window;
      o && (!n || o.isMetaMask) ? s(o) : (!e && console.error("@metamask/detect-provider:", n && o ? "Non-MetaMask window.ethereum detected." : "Unable to detect window.ethereum."), s(null));
    }
  });
  function r() {
    if (typeof n != "boolean")
      throw new Error("@metamask/detect-provider: Expected option 'mustBeMetaMask' to be a boolean.");
    if (typeof e != "boolean")
      throw new Error("@metamask/detect-provider: Expected option 'silent' to be a boolean.");
    if (typeof t != "number")
      throw new Error("@metamask/detect-provider: Expected option 'timeout' to be a number.");
  }
}
var zk = jk;
const Gk = "networks/5.7.1", X2 = new O(Gk);
function qk(n) {
  return n && typeof n.renetwork == "function";
}
function Tr(n) {
  const e = function(t, i) {
    i == null && (i = {});
    const r = [];
    if (t.InfuraProvider && i.infura !== "-")
      try {
        r.push(new t.InfuraProvider(n, i.infura));
      } catch {
      }
    if (t.EtherscanProvider && i.etherscan !== "-")
      try {
        r.push(new t.EtherscanProvider(n, i.etherscan));
      } catch {
      }
    if (t.AlchemyProvider && i.alchemy !== "-")
      try {
        r.push(new t.AlchemyProvider(n, i.alchemy));
      } catch {
      }
    if (t.PocketProvider && i.pocket !== "-") {
      const s = ["goerli", "ropsten", "rinkeby", "sepolia"];
      try {
        const a = new t.PocketProvider(n, i.pocket);
        a.network && s.indexOf(a.network.name) === -1 && r.push(a);
      } catch {
      }
    }
    if (t.CloudflareProvider && i.cloudflare !== "-")
      try {
        r.push(new t.CloudflareProvider(n));
      } catch {
      }
    if (t.AnkrProvider && i.ankr !== "-")
      try {
        const s = ["ropsten"], a = new t.AnkrProvider(n, i.ankr);
        a.network && s.indexOf(a.network.name) === -1 && r.push(a);
      } catch {
      }
    if (r.length === 0)
      return null;
    if (t.FallbackProvider) {
      let s = 1;
      return i.quorum != null ? s = i.quorum : n === "homestead" && (s = 2), new t.FallbackProvider(r, s);
    }
    return r[0];
  };
  return e.renetwork = function(t) {
    return Tr(t);
  }, e;
}
function gd(n, e) {
  const t = function(i, r) {
    return i.JsonRpcProvider ? new i.JsonRpcProvider(n, e) : null;
  };
  return t.renetwork = function(i) {
    return gd(n, i);
  }, t;
}
const Z2 = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: Tr("homestead")
}, ev = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: Tr("ropsten")
}, tv = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: gd("https://www.ethercluster.com/mordor", "classicMordor")
}, yc = {
  unspecified: { chainId: 0, name: "unspecified" },
  homestead: Z2,
  mainnet: Z2,
  morden: { chainId: 2, name: "morden" },
  ropsten: ev,
  testnet: ev,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: Tr("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: Tr("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: Tr("goerli")
  },
  kintsugi: { chainId: 1337702, name: "kintsugi" },
  sepolia: {
    chainId: 11155111,
    name: "sepolia",
    _defaultProvider: Tr("sepolia")
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: gd("https://www.ethercluster.com/etc", "classic")
  },
  classicMorden: { chainId: 62, name: "classicMorden" },
  classicMordor: tv,
  classicTestnet: tv,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: gd("https://www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: { chainId: 100, name: "xdai" },
  matic: {
    chainId: 137,
    name: "matic",
    _defaultProvider: Tr("matic")
  },
  maticmum: { chainId: 80001, name: "maticmum" },
  optimism: {
    chainId: 10,
    name: "optimism",
    _defaultProvider: Tr("optimism")
  },
  "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
  "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
  arbitrum: { chainId: 42161, name: "arbitrum" },
  "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
  "arbitrum-goerli": { chainId: 421613, name: "arbitrum-goerli" },
  bnb: { chainId: 56, name: "bnb" },
  bnbt: { chainId: 97, name: "bnbt" }
};
function Hk(n) {
  if (n == null)
    return null;
  if (typeof n == "number") {
    for (const i in yc) {
      const r = yc[i];
      if (r.chainId === n)
        return {
          name: r.name,
          chainId: r.chainId,
          ensAddress: r.ensAddress || null,
          _defaultProvider: r._defaultProvider || null
        };
    }
    return {
      chainId: n,
      name: "unknown"
    };
  }
  if (typeof n == "string") {
    const i = yc[n];
    return i == null ? null : {
      name: i.name,
      chainId: i.chainId,
      ensAddress: i.ensAddress,
      _defaultProvider: i._defaultProvider || null
    };
  }
  const e = yc[n.name];
  if (!e)
    return typeof n.chainId != "number" && X2.throwArgumentError("invalid network chainId", "network", n), n;
  n.chainId !== 0 && n.chainId !== e.chainId && X2.throwArgumentError("network chainId mismatch", "network", n);
  let t = n._defaultProvider || null;
  return t == null && e._defaultProvider && (qk(e._defaultProvider) ? t = e._defaultProvider.renetwork(n) : t = e._defaultProvider), {
    name: n.name,
    chainId: e.chainId,
    ensAddress: n.ensAddress || e.ensAddress || null,
    _defaultProvider: t
  };
}
var vd = "qpzry9x8gf2tvdw0s3jn54khce6mua7l", Fy = {};
for (var hc = 0; hc < vd.length; hc++) {
  var If = vd.charAt(hc);
  if (Fy[If] !== void 0)
    throw new TypeError(If + " is ambiguous");
  Fy[If] = hc;
}
function mo(n) {
  var e = n >> 25;
  return (n & 33554431) << 5 ^ -(e >> 0 & 1) & 996825010 ^ -(e >> 1 & 1) & 642813549 ^ -(e >> 2 & 1) & 513874426 ^ -(e >> 3 & 1) & 1027748829 ^ -(e >> 4 & 1) & 705979059;
}
function Y5(n) {
  for (var e = 1, t = 0; t < n.length; ++t) {
    var i = n.charCodeAt(t);
    if (i < 33 || i > 126)
      return "Invalid prefix (" + n + ")";
    e = mo(e) ^ i >> 5;
  }
  for (e = mo(e), t = 0; t < n.length; ++t) {
    var r = n.charCodeAt(t);
    e = mo(e) ^ r & 31;
  }
  return e;
}
function Kk(n, e, t) {
  if (t = t || 90, n.length + 7 + e.length > t)
    throw new TypeError("Exceeds length limit");
  n = n.toLowerCase();
  var i = Y5(n);
  if (typeof i == "string")
    throw new Error(i);
  for (var r = n + "1", s = 0; s < e.length; ++s) {
    var a = e[s];
    if (a >> 5)
      throw new Error("Non 5-bit word");
    i = mo(i) ^ a, r += vd.charAt(a);
  }
  for (s = 0; s < 6; ++s)
    i = mo(i);
  for (i ^= 1, s = 0; s < 6; ++s) {
    var o = i >> (5 - s) * 5 & 31;
    r += vd.charAt(o);
  }
  return r;
}
function X5(n, e) {
  if (e = e || 90, n.length < 8)
    return n + " too short";
  if (n.length > e)
    return "Exceeds length limit";
  var t = n.toLowerCase(), i = n.toUpperCase();
  if (n !== t && n !== i)
    return "Mixed-case string " + n;
  n = t;
  var r = n.lastIndexOf("1");
  if (r === -1)
    return "No separator character for " + n;
  if (r === 0)
    return "Missing prefix for " + n;
  var s = n.slice(0, r), a = n.slice(r + 1);
  if (a.length < 6)
    return "Data too short";
  var o = Y5(s);
  if (typeof o == "string")
    return o;
  for (var u = [], l = 0; l < a.length; ++l) {
    var p = a.charAt(l), f = Fy[p];
    if (f === void 0)
      return "Unknown character " + p;
    o = mo(o) ^ f, !(l + 6 >= a.length) && u.push(f);
  }
  return o !== 1 ? "Invalid checksum for " + n : { prefix: s, words: u };
}
function Wk() {
  var n = X5.apply(null, arguments);
  if (typeof n == "object")
    return n;
}
function Jk(n) {
  var e = X5.apply(null, arguments);
  if (typeof e == "object")
    return e;
  throw new Error(e);
}
function mp(n, e, t, i) {
  for (var r = 0, s = 0, a = (1 << t) - 1, o = [], u = 0; u < n.length; ++u)
    for (r = r << e | n[u], s += e; s >= t; )
      s -= t, o.push(r >> s & a);
  if (i)
    s > 0 && o.push(r << t - s & a);
  else {
    if (s >= e)
      return "Excess padding";
    if (r << t - s & a)
      return "Non-zero padding";
  }
  return o;
}
function Qk(n) {
  var e = mp(n, 8, 5, !0);
  if (Array.isArray(e))
    return e;
}
function Yk(n) {
  var e = mp(n, 8, 5, !0);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
function Xk(n) {
  var e = mp(n, 5, 8, !1);
  if (Array.isArray(e))
    return e;
}
function Zk(n) {
  var e = mp(n, 5, 8, !1);
  if (Array.isArray(e))
    return e;
  throw new Error(e);
}
var nv = {
  decodeUnsafe: Wk,
  decode: Jk,
  encode: Kk,
  toWordsUnsafe: Qk,
  toWords: Yk,
  fromWordsUnsafe: Xk,
  fromWords: Zk
};
const D0 = "providers/5.7.2", uu = new O(D0);
class ie {
  constructor() {
    this.formats = this.getDefaultFormats();
  }
  getDefaultFormats() {
    const e = {}, t = this.address.bind(this), i = this.bigNumber.bind(this), r = this.blockTag.bind(this), s = this.data.bind(this), a = this.hash.bind(this), o = this.hex.bind(this), u = this.number.bind(this), l = this.type.bind(this), p = (f) => this.data(f, !0);
    return e.transaction = {
      hash: a,
      type: l,
      accessList: ie.allowNull(this.accessList.bind(this), null),
      blockHash: ie.allowNull(a, null),
      blockNumber: ie.allowNull(u, null),
      transactionIndex: ie.allowNull(u, null),
      confirmations: ie.allowNull(u, null),
      from: t,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: ie.allowNull(i),
      maxPriorityFeePerGas: ie.allowNull(i),
      maxFeePerGas: ie.allowNull(i),
      gasLimit: i,
      to: ie.allowNull(t, null),
      value: i,
      nonce: u,
      data: s,
      r: ie.allowNull(this.uint256),
      s: ie.allowNull(this.uint256),
      v: ie.allowNull(u),
      creates: ie.allowNull(t, null),
      raw: ie.allowNull(s)
    }, e.transactionRequest = {
      from: ie.allowNull(t),
      nonce: ie.allowNull(u),
      gasLimit: ie.allowNull(i),
      gasPrice: ie.allowNull(i),
      maxPriorityFeePerGas: ie.allowNull(i),
      maxFeePerGas: ie.allowNull(i),
      to: ie.allowNull(t),
      value: ie.allowNull(i),
      data: ie.allowNull(p),
      type: ie.allowNull(u),
      accessList: ie.allowNull(this.accessList.bind(this), null)
    }, e.receiptLog = {
      transactionIndex: u,
      blockNumber: u,
      transactionHash: a,
      address: t,
      topics: ie.arrayOf(a),
      data: s,
      logIndex: u,
      blockHash: a
    }, e.receipt = {
      to: ie.allowNull(this.address, null),
      from: ie.allowNull(this.address, null),
      contractAddress: ie.allowNull(t, null),
      transactionIndex: u,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: ie.allowNull(o),
      gasUsed: i,
      logsBloom: ie.allowNull(s),
      blockHash: a,
      transactionHash: a,
      logs: ie.arrayOf(this.receiptLog.bind(this)),
      blockNumber: u,
      confirmations: ie.allowNull(u, null),
      cumulativeGasUsed: i,
      effectiveGasPrice: ie.allowNull(i),
      status: ie.allowNull(u),
      type: l
    }, e.block = {
      hash: ie.allowNull(a),
      parentHash: a,
      number: u,
      timestamp: u,
      nonce: ie.allowNull(o),
      difficulty: this.difficulty.bind(this),
      gasLimit: i,
      gasUsed: i,
      miner: ie.allowNull(t),
      extraData: s,
      transactions: ie.allowNull(ie.arrayOf(a)),
      baseFeePerGas: ie.allowNull(i)
    }, e.blockWithTransactions = Ut(e.block), e.blockWithTransactions.transactions = ie.allowNull(ie.arrayOf(this.transactionResponse.bind(this))), e.filter = {
      fromBlock: ie.allowNull(r, void 0),
      toBlock: ie.allowNull(r, void 0),
      blockHash: ie.allowNull(a, void 0),
      address: ie.allowNull(t, void 0),
      topics: ie.allowNull(this.topics.bind(this), void 0)
    }, e.filterLog = {
      blockNumber: ie.allowNull(u),
      blockHash: ie.allowNull(a),
      transactionIndex: u,
      removed: ie.allowNull(this.boolean.bind(this)),
      address: t,
      data: ie.allowFalsish(s, "0x"),
      topics: ie.arrayOf(a),
      transactionHash: a,
      logIndex: u
    }, e;
  }
  accessList(e) {
    return ja(e || []);
  }
  // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.
  number(e) {
    return e === "0x" ? 0 : z.from(e).toNumber();
  }
  type(e) {
    return e === "0x" || e == null ? 0 : z.from(e).toNumber();
  }
  // Strict! Used on input.
  bigNumber(e) {
    return z.from(e);
  }
  // Requires a boolean, "true" or  "false"; returns a boolean
  boolean(e) {
    if (typeof e == "boolean")
      return e;
    if (typeof e == "string") {
      if (e = e.toLowerCase(), e === "true")
        return !0;
      if (e === "false")
        return !1;
    }
    throw new Error("invalid boolean - " + e);
  }
  hex(e, t) {
    return typeof e == "string" && (!t && e.substring(0, 2) !== "0x" && (e = "0x" + e), Ae(e)) ? e.toLowerCase() : uu.throwArgumentError("invalid hash", "value", e);
  }
  data(e, t) {
    const i = this.hex(e, t);
    if (i.length % 2 !== 0)
      throw new Error("invalid data; odd-length - " + e);
    return i;
  }
  // Requires an address
  // Strict! Used on input.
  address(e) {
    return Be(e);
  }
  callAddress(e) {
    if (!Ae(e, 32))
      return null;
    const t = Be(Bt(e, 12));
    return t === gM ? null : t;
  }
  contractAddress(e) {
    return o0(e);
  }
  // Strict! Used on input.
  blockTag(e) {
    if (e == null)
      return "latest";
    if (e === "earliest")
      return "0x0";
    switch (e) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return e;
    }
    if (typeof e == "number" || Ae(e))
      return rp(e);
    throw new Error("invalid blockTag");
  }
  // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
  hash(e, t) {
    const i = this.hex(e, t);
    return rr(i) !== 32 ? uu.throwArgumentError("invalid hash", "value", e) : i;
  }
  // Returns the difficulty as a number, or if too large (i.e. PoA network) null
  difficulty(e) {
    if (e == null)
      return null;
    const t = z.from(e);
    try {
      return t.toNumber();
    } catch {
    }
    return null;
  }
  uint256(e) {
    if (!Ae(e))
      throw new Error("invalid uint256");
    return De(e, 32);
  }
  _block(e, t) {
    e.author != null && e.miner == null && (e.miner = e.author);
    const i = e._difficulty != null ? e._difficulty : e.difficulty, r = ie.check(t, e);
    return r._difficulty = i == null ? null : z.from(i), r;
  }
  block(e) {
    return this._block(e, this.formats.block);
  }
  blockWithTransactions(e) {
    return this._block(e, this.formats.blockWithTransactions);
  }
  // Strict! Used on input.
  transactionRequest(e) {
    return ie.check(this.formats.transactionRequest, e);
  }
  transactionResponse(e) {
    e.gas != null && e.gasLimit == null && (e.gasLimit = e.gas), e.to && z.from(e.to).isZero() && (e.to = "0x0000000000000000000000000000000000000000"), e.input != null && e.data == null && (e.data = e.input), e.to == null && e.creates == null && (e.creates = this.contractAddress(e)), (e.type === 1 || e.type === 2) && e.accessList == null && (e.accessList = []);
    const t = ie.check(this.formats.transaction, e);
    if (e.chainId != null) {
      let i = e.chainId;
      Ae(i) && (i = z.from(i).toNumber()), t.chainId = i;
    } else {
      let i = e.networkId;
      i == null && t.v == null && (i = e.chainId), Ae(i) && (i = z.from(i).toNumber()), typeof i != "number" && t.v != null && (i = (t.v - 35) / 2, i < 0 && (i = 0), i = parseInt(i)), typeof i != "number" && (i = 0), t.chainId = i;
    }
    return t.blockHash && t.blockHash.replace(/0/g, "") === "x" && (t.blockHash = null), t;
  }
  transaction(e) {
    return T5(e);
  }
  receiptLog(e) {
    return ie.check(this.formats.receiptLog, e);
  }
  receipt(e) {
    const t = ie.check(this.formats.receipt, e);
    if (t.root != null)
      if (t.root.length <= 4) {
        const i = z.from(t.root).toNumber();
        i === 0 || i === 1 ? (t.status != null && t.status !== i && uu.throwArgumentError("alt-root-status/status mismatch", "value", { root: t.root, status: t.status }), t.status = i, delete t.root) : uu.throwArgumentError("invalid alt-root-status", "value.root", t.root);
      } else
        t.root.length !== 66 && uu.throwArgumentError("invalid root hash", "value.root", t.root);
    return t.status != null && (t.byzantium = !0), t;
  }
  topics(e) {
    return Array.isArray(e) ? e.map((t) => this.topics(t)) : e != null ? this.hash(e, !0) : null;
  }
  filter(e) {
    return ie.check(this.formats.filter, e);
  }
  filterLog(e) {
    return ie.check(this.formats.filterLog, e);
  }
  static check(e, t) {
    const i = {};
    for (const r in e)
      try {
        const s = e[r](t[r]);
        s !== void 0 && (i[r] = s);
      } catch (s) {
        throw s.checkKey = r, s.checkValue = t[r], s;
      }
    return i;
  }
  // if value is null-ish, nullValue is returned
  static allowNull(e, t) {
    return function(i) {
      return i == null ? t : e(i);
    };
  }
  // If value is false-ish, replaceValue is returned
  static allowFalsish(e, t) {
    return function(i) {
      return i ? e(i) : t;
    };
  }
  // Requires an Array satisfying check
  static arrayOf(e) {
    return function(t) {
      if (!Array.isArray(t))
        throw new Error("not an array");
      const i = [];
      return t.forEach(function(r) {
        i.push(e(r));
      }), i;
    };
  }
}
var ce = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
const he = new O(D0), eP = 10;
function iv(n) {
  return n == null ? "null" : (rr(n) !== 32 && he.throwArgumentError("invalid topic", "topic", n), n.toLowerCase());
}
function rv(n) {
  for (n = n.slice(); n.length > 0 && n[n.length - 1] == null; )
    n.pop();
  return n.map((e) => {
    if (Array.isArray(e)) {
      const t = {};
      e.forEach((r) => {
        t[iv(r)] = !0;
      });
      const i = Object.keys(t);
      return i.sort(), i.join("|");
    } else
      return iv(e);
  }).join("&");
}
function tP(n) {
  return n === "" ? [] : n.split(/&/g).map((e) => {
    if (e === "")
      return [];
    const t = e.split("|").map((i) => i === "null" ? null : i);
    return t.length === 1 ? t[0] : t;
  });
}
function Ya(n) {
  if (typeof n == "string") {
    if (n = n.toLowerCase(), rr(n) === 32)
      return "tx:" + n;
    if (n.indexOf(":") === -1)
      return n;
  } else {
    if (Array.isArray(n))
      return "filter:*:" + rv(n);
    if (IC.isForkEvent(n))
      throw he.warn("not implemented"), new Error("not implemented");
    if (n && typeof n == "object")
      return "filter:" + (n.address || "*") + ":" + rv(n.topics || []);
  }
  throw new Error("invalid event - " + n);
}
function lu() {
  return (/* @__PURE__ */ new Date()).getTime();
}
function sv(n) {
  return new Promise((e) => {
    setTimeout(e, n);
  });
}
const nP = ["block", "network", "pending", "poll"];
class iP {
  constructor(e, t, i) {
    U(this, "tag", e), U(this, "listener", t), U(this, "once", i), this._lastBlockNumber = -2, this._inflight = !1;
  }
  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;
      case "filter":
        return this.filter;
    }
    return this.tag;
  }
  get type() {
    return this.tag.split(":")[0];
  }
  get hash() {
    const e = this.tag.split(":");
    return e[0] !== "tx" ? null : e[1];
  }
  get filter() {
    const e = this.tag.split(":");
    if (e[0] !== "filter")
      return null;
    const t = e[1], i = tP(e[2]), r = {};
    return i.length > 0 && (r.topics = i), t && t !== "*" && (r.address = t), r;
  }
  pollable() {
    return this.tag.indexOf(":") >= 0 || nP.indexOf(this.tag) >= 0;
  }
}
const rP = {
  0: { symbol: "btc", p2pkh: 0, p2sh: 5, prefix: "bc" },
  2: { symbol: "ltc", p2pkh: 48, p2sh: 50, prefix: "ltc" },
  3: { symbol: "doge", p2pkh: 30, p2sh: 22 },
  60: { symbol: "eth", ilk: "eth" },
  61: { symbol: "etc", ilk: "eth" },
  700: { symbol: "xdai", ilk: "eth" }
};
function Of(n) {
  return De(z.from(n).toHexString(), 32);
}
function av(n) {
  return Ro.encode(Ve([n, Bt(Ur(Ur(n)), 0, 4)]));
}
const Z5 = new RegExp("^(ipfs)://(.*)$", "i"), ov = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  Z5,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];
function Fc(n, e) {
  try {
    return Is(cl(n, e));
  } catch {
  }
  return null;
}
function cl(n, e) {
  if (n === "0x")
    return null;
  const t = z.from(Bt(n, e, e + 32)).toNumber(), i = z.from(Bt(n, t, t + 32)).toNumber();
  return Bt(n, t + 32, t + 32 + i);
}
function Bf(n) {
  return n.match(/^ipfs:\/\/ipfs\//i) ? n = n.substring(12) : n.match(/^ipfs:\/\//i) ? n = n.substring(7) : he.throwArgumentError("unsupported IPFS format", "link", n), `https://gateway.ipfs.io/ipfs/${n}`;
}
function uv(n) {
  const e = q(n);
  if (e.length > 32)
    throw new Error("internal; should not happen");
  const t = new Uint8Array(32);
  return t.set(e, 32 - e.length), t;
}
function sP(n) {
  if (n.length % 32 === 0)
    return n;
  const e = new Uint8Array(Math.ceil(n.length / 32) * 32);
  return e.set(n), e;
}
function eT(n) {
  const e = [];
  let t = 0;
  for (let i = 0; i < n.length; i++)
    e.push(null), t += 32;
  for (let i = 0; i < n.length; i++) {
    const r = q(n[i]);
    e[i] = uv(t), e.push(uv(r.length)), e.push(sP(r)), t += 32 + Math.ceil(r.length / 32) * 32;
  }
  return Cn(e);
}
class lv {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(e, t, i, r) {
    U(this, "provider", e), U(this, "name", i), U(this, "address", e.formatter.address(t)), U(this, "_resolvedAddress", r);
  }
  supportsWildcard() {
    return this._supportsEip2544 || (this._supportsEip2544 = this.provider.call({
      to: this.address,
      data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
    }).then((e) => z.from(e).eq(1)).catch((e) => {
      if (e.code === O.errors.CALL_EXCEPTION)
        return !1;
      throw this._supportsEip2544 = null, e;
    })), this._supportsEip2544;
  }
  _fetch(e, t) {
    return ce(this, void 0, void 0, function* () {
      const i = {
        to: this.address,
        ccipReadEnabled: !0,
        data: Cn([e, Ou(this.name), t || "0x"])
      };
      let r = !1;
      (yield this.supportsWildcard()) && (r = !0, i.data = Cn(["0x9061b923", eT([V6(this.name), i.data])]));
      try {
        let s = yield this.provider.call(i);
        return q(s).length % 32 === 4 && he.throwError("resolver threw error", O.errors.CALL_EXCEPTION, {
          transaction: i,
          data: s
        }), r && (s = cl(s, 0)), s;
      } catch (s) {
        if (s.code === O.errors.CALL_EXCEPTION)
          return null;
        throw s;
      }
    });
  }
  _fetchBytes(e, t) {
    return ce(this, void 0, void 0, function* () {
      const i = yield this._fetch(e, t);
      return i != null ? cl(i, 0) : null;
    });
  }
  _getAddress(e, t) {
    const i = rP[String(e)];
    if (i == null && he.throwError(`unsupported coin type: ${e}`, O.errors.UNSUPPORTED_OPERATION, {
      operation: `getAddress(${e})`
    }), i.ilk === "eth")
      return this.provider.formatter.address(t);
    const r = q(t);
    if (i.p2pkh != null) {
      const s = t.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75)
          return av(Ve([[i.p2pkh], "0x" + s[2]]));
      }
    }
    if (i.p2sh != null) {
      const s = t.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
      if (s) {
        const a = parseInt(s[1], 16);
        if (s[2].length === a * 2 && a >= 1 && a <= 75)
          return av(Ve([[i.p2sh], "0x" + s[2]]));
      }
    }
    if (i.prefix != null) {
      const s = r[1];
      let a = r[0];
      if (a === 0 ? s !== 20 && s !== 32 && (a = -1) : a = -1, a >= 0 && r.length === 2 + s && s >= 1 && s <= 75) {
        const o = nv.toWords(r.slice(2));
        return o.unshift(a), nv.encode(i.prefix, o);
      }
    }
    return null;
  }
  getAddress(e) {
    return ce(this, void 0, void 0, function* () {
      if (e == null && (e = 60), e === 60)
        try {
          const r = yield this._fetch("0x3b3b57de");
          return r === "0x" || r === _6 ? null : this.provider.formatter.callAddress(r);
        } catch (r) {
          if (r.code === O.errors.CALL_EXCEPTION)
            return null;
          throw r;
        }
      const t = yield this._fetchBytes("0xf1cb7e06", Of(e));
      if (t == null || t === "0x")
        return null;
      const i = this._getAddress(e, t);
      return i == null && he.throwError("invalid or unsupported coin data", O.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${e})`,
        coinType: e,
        data: t
      }), i;
    });
  }
  getAvatar() {
    return ce(this, void 0, void 0, function* () {
      const e = [{ type: "name", content: this.name }];
      try {
        const t = yield this.getText("avatar");
        if (t == null)
          return null;
        for (let i = 0; i < ov.length; i++) {
          const r = t.match(ov[i]);
          if (r == null)
            continue;
          const s = r[1].toLowerCase();
          switch (s) {
            case "https":
              return e.push({ type: "url", content: t }), { linkage: e, url: t };
            case "data":
              return e.push({ type: "data", content: t }), { linkage: e, url: t };
            case "ipfs":
              return e.push({ type: "ipfs", content: t }), { linkage: e, url: Bf(t) };
            case "erc721":
            case "erc1155": {
              const a = s === "erc721" ? "0xc87b56dd" : "0x0e89341c";
              e.push({ type: s, content: t });
              const o = this._resolvedAddress || (yield this.getAddress()), u = (r[2] || "").split("/");
              if (u.length !== 2)
                return null;
              const l = yield this.provider.formatter.address(u[0]), p = De(z.from(u[1]).toHexString(), 32);
              if (s === "erc721") {
                const w = this.provider.formatter.callAddress(yield this.provider.call({
                  to: l,
                  data: Cn(["0x6352211e", p])
                }));
                if (o !== w)
                  return null;
                e.push({ type: "owner", content: w });
              } else if (s === "erc1155") {
                const w = z.from(yield this.provider.call({
                  to: l,
                  data: Cn(["0x00fdd58e", De(o, 32), p])
                }));
                if (w.isZero())
                  return null;
                e.push({ type: "balance", content: w.toString() });
              }
              const f = {
                to: this.provider.formatter.address(u[0]),
                data: Cn([a, p])
              };
              let b = Fc(yield this.provider.call(f), 0);
              if (b == null)
                return null;
              e.push({ type: "metadata-url-base", content: b }), s === "erc1155" && (b = b.replace("{id}", p.substring(2)), e.push({ type: "metadata-url-expanded", content: b })), b.match(/^ipfs:/i) && (b = Bf(b)), e.push({ type: "metadata-url", content: b });
              const A = yield hp(b);
              if (!A)
                return null;
              e.push({ type: "metadata", content: JSON.stringify(A) });
              let x = A.image;
              if (typeof x != "string")
                return null;
              if (!x.match(/^(https:\/\/|data:)/i)) {
                if (x.match(Z5) == null)
                  return null;
                e.push({ type: "url-ipfs", content: x }), x = Bf(x);
              }
              return e.push({ type: "url", content: x }), { linkage: e, url: x };
            }
          }
        }
      } catch {
      }
      return null;
    });
  }
  getContentHash() {
    return ce(this, void 0, void 0, function* () {
      const e = yield this._fetchBytes("0xbc1c58d1");
      if (e == null || e === "0x")
        return null;
      const t = e.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (t) {
        const a = parseInt(t[3], 16);
        if (t[4].length === a * 2)
          return "ipfs://" + Ro.encode("0x" + t[1]);
      }
      const i = e.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
      if (i) {
        const a = parseInt(i[3], 16);
        if (i[4].length === a * 2)
          return "ipns://" + Ro.encode("0x" + i[1]);
      }
      const r = e.match(/^0xe40101fa011b20([0-9a-f]*)$/);
      if (r && r[1].length === 32 * 2)
        return "bzz://" + r[1];
      const s = e.match(/^0x90b2c605([0-9a-f]*)$/);
      if (s && s[1].length === 34 * 2) {
        const a = { "=": "", "+": "-", "/": "_" };
        return "sia://" + f0("0x" + s[1]).replace(/[=+\/]/g, (u) => a[u]);
      }
      return he.throwError("invalid or unsupported content hash data", O.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: e
      });
    });
  }
  getText(e) {
    return ce(this, void 0, void 0, function* () {
      let t = Dt(e);
      t = Ve([Of(64), Of(t.length), t]), t.length % 32 !== 0 && (t = Ve([t, De("0x", 32 - e.length % 32)]));
      const i = yield this._fetchBytes("0x59d1d43c", H(t));
      return i == null || i === "0x" ? null : Is(i);
    });
  }
}
let Nf = null, aP = 1;
class oP extends h0 {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(e) {
    if (super(), this._events = [], this._emitted = { block: -2 }, this.disableCcipRead = !1, this.formatter = new.target.getFormatter(), U(this, "anyNetwork", e === "any"), this.anyNetwork && (e = this.detectNetwork()), e instanceof Promise)
      this._networkPromise = e, e.catch((t) => {
      }), this._ready().catch((t) => {
      });
    else {
      const t = Oi(new.target, "getNetwork")(e);
      t ? (U(this, "_network", t), this.emit("network", t, null)) : he.throwArgumentError("invalid network", "network", e);
    }
    this._maxInternalBlockNumber = -1024, this._lastBlockNumber = -2, this._maxFilterBlockRange = 10, this._pollingInterval = 4e3, this._fastQueryDate = 0;
  }
  _ready() {
    return ce(this, void 0, void 0, function* () {
      if (this._network == null) {
        let e = null;
        if (this._networkPromise)
          try {
            e = yield this._networkPromise;
          } catch {
          }
        e == null && (e = yield this.detectNetwork()), e || he.throwError("no network detected", O.errors.UNKNOWN_ERROR, {}), this._network == null && (this.anyNetwork ? this._network = e : U(this, "_network", e), this.emit("network", e, null));
      }
      return this._network;
    });
  }
  // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change
  get ready() {
    return lo(() => this._ready().then((e) => e, (e) => {
      if (!(e.code === O.errors.NETWORK_ERROR && e.event === "noNetwork"))
        throw e;
    }));
  }
  // @TODO: Remove this and just create a singleton formatter
  static getFormatter() {
    return Nf == null && (Nf = new ie()), Nf;
  }
  // @TODO: Remove this and just use getNetwork
  static getNetwork(e) {
    return Hk(e ?? "homestead");
  }
  ccipReadFetch(e, t, i) {
    return ce(this, void 0, void 0, function* () {
      if (this.disableCcipRead || i.length === 0)
        return null;
      const r = e.to.toLowerCase(), s = t.toLowerCase(), a = [];
      for (let o = 0; o < i.length; o++) {
        const u = i[o], l = u.replace("{sender}", r).replace("{data}", s), p = u.indexOf("{data}") >= 0 ? null : JSON.stringify({ data: s, sender: r }), f = yield hp({ url: l, errorPassThrough: !0 }, p, (A, x) => (A.status = x.statusCode, A));
        if (f.data)
          return f.data;
        const b = f.message || "unknown error";
        if (f.status >= 400 && f.status < 500)
          return he.throwError(`response not found during CCIP fetch: ${b}`, O.errors.SERVER_ERROR, { url: u, errorMessage: b });
        a.push(b);
      }
      return he.throwError(`error encountered during CCIP fetch: ${a.map((o) => JSON.stringify(o)).join(", ")}`, O.errors.SERVER_ERROR, {
        urls: i,
        errorMessages: a
      });
    });
  }
  // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request
  _getInternalBlockNumber(e) {
    return ce(this, void 0, void 0, function* () {
      if (yield this._ready(), e > 0)
        for (; this._internalBlockNumber; ) {
          const r = this._internalBlockNumber;
          try {
            const s = yield r;
            if (lu() - s.respTime <= e)
              return s.blockNumber;
            break;
          } catch {
            if (this._internalBlockNumber === r)
              break;
          }
        }
      const t = lu(), i = _t({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then((r) => null, (r) => r)
      }).then(({ blockNumber: r, networkError: s }) => {
        if (s)
          throw this._internalBlockNumber === i && (this._internalBlockNumber = null), s;
        const a = lu();
        return r = z.from(r).toNumber(), r < this._maxInternalBlockNumber && (r = this._maxInternalBlockNumber), this._maxInternalBlockNumber = r, this._setFastBlockNumber(r), { blockNumber: r, reqTime: t, respTime: a };
      });
      return this._internalBlockNumber = i, i.catch((r) => {
        this._internalBlockNumber === i && (this._internalBlockNumber = null);
      }), (yield i).blockNumber;
    });
  }
  poll() {
    return ce(this, void 0, void 0, function* () {
      const e = aP++, t = [];
      let i = null;
      try {
        i = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (r) {
        this.emit("error", r);
        return;
      }
      if (this._setFastBlockNumber(i), this.emit("poll", e, i), i === this._lastBlockNumber) {
        this.emit("didPoll", e);
        return;
      }
      if (this._emitted.block === -2 && (this._emitted.block = i - 1), Math.abs(this._emitted.block - i) > 1e3)
        he.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${i})`), this.emit("error", he.makeError("network block skew detected", O.errors.NETWORK_ERROR, {
          blockNumber: i,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        })), this.emit("block", i);
      else
        for (let r = this._emitted.block + 1; r <= i; r++)
          this.emit("block", r);
      this._emitted.block !== i && (this._emitted.block = i, Object.keys(this._emitted).forEach((r) => {
        if (r === "block")
          return;
        const s = this._emitted[r];
        s !== "pending" && i - s > 12 && delete this._emitted[r];
      })), this._lastBlockNumber === -2 && (this._lastBlockNumber = i - 1), this._events.forEach((r) => {
        switch (r.type) {
          case "tx": {
            const s = r.hash;
            let a = this.getTransactionReceipt(s).then((o) => (!o || o.blockNumber == null || (this._emitted["t:" + s] = o.blockNumber, this.emit(s, o)), null)).catch((o) => {
              this.emit("error", o);
            });
            t.push(a);
            break;
          }
          case "filter": {
            if (!r._inflight) {
              r._inflight = !0, r._lastBlockNumber === -2 && (r._lastBlockNumber = i - 1);
              const s = r.filter;
              s.fromBlock = r._lastBlockNumber + 1, s.toBlock = i;
              const a = s.toBlock - this._maxFilterBlockRange;
              a > s.fromBlock && (s.fromBlock = a), s.fromBlock < 0 && (s.fromBlock = 0);
              const o = this.getLogs(s).then((u) => {
                r._inflight = !1, u.length !== 0 && u.forEach((l) => {
                  l.blockNumber > r._lastBlockNumber && (r._lastBlockNumber = l.blockNumber), this._emitted["b:" + l.blockHash] = l.blockNumber, this._emitted["t:" + l.transactionHash] = l.blockNumber, this.emit(s, l);
                });
              }).catch((u) => {
                this.emit("error", u), r._inflight = !1;
              });
              t.push(o);
            }
            break;
          }
        }
      }), this._lastBlockNumber = i, Promise.all(t).then(() => {
        this.emit("didPoll", e);
      }).catch((r) => {
        this.emit("error", r);
      });
    });
  }
  // Deprecated; do not use this
  resetEventsBlock(e) {
    this._lastBlockNumber = e - 1, this.polling && this.poll();
  }
  get network() {
    return this._network;
  }
  // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend
  detectNetwork() {
    return ce(this, void 0, void 0, function* () {
      return he.throwError("provider does not support network detection", O.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }
  getNetwork() {
    return ce(this, void 0, void 0, function* () {
      const e = yield this._ready(), t = yield this.detectNetwork();
      if (e.chainId !== t.chainId) {
        if (this.anyNetwork)
          return this._network = t, this._lastBlockNumber = -2, this._fastBlockNumber = null, this._fastBlockNumberPromise = null, this._fastQueryDate = 0, this._emitted.block = -2, this._maxInternalBlockNumber = -1024, this._internalBlockNumber = null, this.emit("network", t, e), yield sv(0), this._network;
        const i = he.makeError("underlying network changed", O.errors.NETWORK_ERROR, {
          event: "changed",
          network: e,
          detectedNetwork: t
        });
        throw this.emit("error", i), i;
      }
      return e;
    });
  }
  get blockNumber() {
    return this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((e) => {
      this._setFastBlockNumber(e);
    }, (e) => {
    }), this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }
  get polling() {
    return this._poller != null;
  }
  set polling(e) {
    e && !this._poller ? (this._poller = setInterval(() => {
      this.poll();
    }, this.pollingInterval), this._bootstrapPoll || (this._bootstrapPoll = setTimeout(() => {
      this.poll(), this._bootstrapPoll = setTimeout(() => {
        this._poller || this.poll(), this._bootstrapPoll = null;
      }, this.pollingInterval);
    }, 0))) : !e && this._poller && (clearInterval(this._poller), this._poller = null);
  }
  get pollingInterval() {
    return this._pollingInterval;
  }
  set pollingInterval(e) {
    if (typeof e != "number" || e <= 0 || parseInt(String(e)) != e)
      throw new Error("invalid polling interval");
    this._pollingInterval = e, this._poller && (clearInterval(this._poller), this._poller = setInterval(() => {
      this.poll();
    }, this._pollingInterval));
  }
  _getFastBlockNumber() {
    const e = lu();
    return e - this._fastQueryDate > 2 * this._pollingInterval && (this._fastQueryDate = e, this._fastBlockNumberPromise = this.getBlockNumber().then((t) => ((this._fastBlockNumber == null || t > this._fastBlockNumber) && (this._fastBlockNumber = t), this._fastBlockNumber))), this._fastBlockNumberPromise;
  }
  _setFastBlockNumber(e) {
    this._fastBlockNumber != null && e < this._fastBlockNumber || (this._fastQueryDate = lu(), (this._fastBlockNumber == null || e > this._fastBlockNumber) && (this._fastBlockNumber = e, this._fastBlockNumberPromise = Promise.resolve(e)));
  }
  waitForTransaction(e, t, i) {
    return ce(this, void 0, void 0, function* () {
      return this._waitForTransaction(e, t ?? 1, i || 0, null);
    });
  }
  _waitForTransaction(e, t, i, r) {
    return ce(this, void 0, void 0, function* () {
      const s = yield this.getTransactionReceipt(e);
      return (s ? s.confirmations : 0) >= t ? s : new Promise((a, o) => {
        const u = [];
        let l = !1;
        const p = function() {
          return l ? !0 : (l = !0, u.forEach((b) => {
            b();
          }), !1);
        }, f = (b) => {
          b.confirmations < t || p() || a(b);
        };
        if (this.on(e, f), u.push(() => {
          this.removeListener(e, f);
        }), r) {
          let b = r.startBlock, A = null;
          const x = (w) => ce(this, void 0, void 0, function* () {
            l || (yield sv(1e3), this.getTransactionCount(r.from).then((T) => ce(this, void 0, void 0, function* () {
              if (!l) {
                if (T <= r.nonce)
                  b = w;
                else {
                  {
                    const _ = yield this.getTransaction(e);
                    if (_ && _.blockNumber != null)
                      return;
                  }
                  for (A == null && (A = b - 3, A < r.startBlock && (A = r.startBlock)); A <= w; ) {
                    if (l)
                      return;
                    const _ = yield this.getBlockWithTransactions(A);
                    for (let I = 0; I < _.transactions.length; I++) {
                      const $ = _.transactions[I];
                      if ($.hash === e)
                        return;
                      if ($.from === r.from && $.nonce === r.nonce) {
                        if (l)
                          return;
                        const N = yield this.waitForTransaction($.hash, t);
                        if (p())
                          return;
                        let B = "replaced";
                        $.data === r.data && $.to === r.to && $.value.eq(r.value) ? B = "repriced" : $.data === "0x" && $.from === $.to && $.value.isZero() && (B = "cancelled"), o(he.makeError("transaction was replaced", O.errors.TRANSACTION_REPLACED, {
                          cancelled: B === "replaced" || B === "cancelled",
                          reason: B,
                          replacement: this._wrapTransaction($),
                          hash: e,
                          receipt: N
                        }));
                        return;
                      }
                    }
                    A++;
                  }
                }
                l || this.once("block", x);
              }
            }), (T) => {
              l || this.once("block", x);
            }));
          });
          if (l)
            return;
          this.once("block", x), u.push(() => {
            this.removeListener("block", x);
          });
        }
        if (typeof i == "number" && i > 0) {
          const b = setTimeout(() => {
            p() || o(he.makeError("timeout exceeded", O.errors.TIMEOUT, { timeout: i }));
          }, i);
          b.unref && b.unref(), u.push(() => {
            clearTimeout(b);
          });
        }
      });
    });
  }
  getBlockNumber() {
    return ce(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }
  getGasPrice() {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const e = yield this.perform("getGasPrice", {});
      try {
        return z.from(e);
      } catch (t) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result: e,
          error: t
        });
      }
    });
  }
  getBalance(e, t) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield _t({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(t)
      }), r = yield this.perform("getBalance", i);
      try {
        return z.from(r);
      } catch (s) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "getBalance",
          params: i,
          result: r,
          error: s
        });
      }
    });
  }
  getTransactionCount(e, t) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield _t({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(t)
      }), r = yield this.perform("getTransactionCount", i);
      try {
        return z.from(r).toNumber();
      } catch (s) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params: i,
          result: r,
          error: s
        });
      }
    });
  }
  getCode(e, t) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield _t({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(t)
      }), r = yield this.perform("getCode", i);
      try {
        return H(r);
      } catch (s) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "getCode",
          params: i,
          result: r,
          error: s
        });
      }
    });
  }
  getStorageAt(e, t, i) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const r = yield _t({
        address: this._getAddress(e),
        blockTag: this._getBlockTag(i),
        position: Promise.resolve(t).then((a) => rp(a))
      }), s = yield this.perform("getStorageAt", r);
      try {
        return H(s);
      } catch (a) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params: r,
          result: s,
          error: a
        });
      }
    });
  }
  // This should be called by any subclass wrapping a TransactionResponse
  _wrapTransaction(e, t, i) {
    if (t != null && rr(t) !== 32)
      throw new Error("invalid response - sendTransaction");
    const r = e;
    return t != null && e.hash !== t && he.throwError("Transaction hash mismatch from Provider.sendTransaction.", O.errors.UNKNOWN_ERROR, { expectedHash: e.hash, returnedHash: t }), r.wait = (s, a) => ce(this, void 0, void 0, function* () {
      s == null && (s = 1), a == null && (a = 0);
      let o;
      s !== 0 && i != null && (o = {
        data: e.data,
        from: e.from,
        nonce: e.nonce,
        to: e.to,
        value: e.value,
        startBlock: i
      });
      const u = yield this._waitForTransaction(e.hash, s, a, o);
      return u == null && s === 0 ? null : (this._emitted["t:" + e.hash] = u.blockNumber, u.status === 0 && he.throwError("transaction failed", O.errors.CALL_EXCEPTION, {
        transactionHash: e.hash,
        transaction: e,
        receipt: u
      }), u);
    }), r;
  }
  sendTransaction(e) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield Promise.resolve(e).then((s) => H(s)), i = this.formatter.transaction(e);
      i.confirmations == null && (i.confirmations = 0);
      const r = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
      try {
        const s = yield this.perform("sendTransaction", { signedTransaction: t });
        return this._wrapTransaction(i, s, r);
      } catch (s) {
        throw s.transaction = i, s.transactionHash = i.hash, s;
      }
    });
  }
  _getTransactionRequest(e) {
    return ce(this, void 0, void 0, function* () {
      const t = yield e, i = {};
      return ["from", "to"].forEach((r) => {
        t[r] != null && (i[r] = Promise.resolve(t[r]).then((s) => s ? this._getAddress(s) : null));
      }), ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((r) => {
        t[r] != null && (i[r] = Promise.resolve(t[r]).then((s) => s ? z.from(s) : null));
      }), ["type"].forEach((r) => {
        t[r] != null && (i[r] = Promise.resolve(t[r]).then((s) => s ?? null));
      }), t.accessList && (i.accessList = this.formatter.accessList(t.accessList)), ["data"].forEach((r) => {
        t[r] != null && (i[r] = Promise.resolve(t[r]).then((s) => s ? H(s) : null));
      }), this.formatter.transactionRequest(yield _t(i));
    });
  }
  _getFilter(e) {
    return ce(this, void 0, void 0, function* () {
      e = yield e;
      const t = {};
      return e.address != null && (t.address = this._getAddress(e.address)), ["blockHash", "topics"].forEach((i) => {
        e[i] != null && (t[i] = e[i]);
      }), ["fromBlock", "toBlock"].forEach((i) => {
        e[i] != null && (t[i] = this._getBlockTag(e[i]));
      }), this.formatter.filter(yield _t(t));
    });
  }
  _call(e, t, i) {
    return ce(this, void 0, void 0, function* () {
      i >= eP && he.throwError("CCIP read exceeded maximum redirections", O.errors.SERVER_ERROR, {
        redirects: i,
        transaction: e
      });
      const r = e.to, s = yield this.perform("call", { transaction: e, blockTag: t });
      if (i >= 0 && t === "latest" && r != null && s.substring(0, 10) === "0x556f1830" && rr(s) % 32 === 4)
        try {
          const a = Bt(s, 4), o = Bt(a, 0, 32);
          z.from(o).eq(r) || he.throwError("CCIP Read sender did not match", O.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const u = [], l = z.from(Bt(a, 32, 64)).toNumber(), p = z.from(Bt(a, l, l + 32)).toNumber(), f = Bt(a, l + 32);
          for (let _ = 0; _ < p; _++) {
            const I = Fc(f, _ * 32);
            I == null && he.throwError("CCIP Read contained corrupt URL string", O.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction: e,
              data: s
            }), u.push(I);
          }
          const b = cl(a, 64);
          z.from(Bt(a, 100, 128)).isZero() || he.throwError("CCIP Read callback selector included junk", O.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const A = Bt(a, 96, 100), x = cl(a, 128), w = yield this.ccipReadFetch(e, b, u);
          w == null && he.throwError("CCIP Read disabled or provided no URLs", O.errors.CALL_EXCEPTION, {
            name: "OffchainLookup",
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            transaction: e,
            data: s
          });
          const T = {
            to: r,
            data: Cn([A, eT([w, x])])
          };
          return this._call(T, t, i + 1);
        } catch (a) {
          if (a.code === O.errors.SERVER_ERROR)
            throw a;
        }
      try {
        return H(s);
      } catch (a) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "call",
          params: { transaction: e, blockTag: t },
          result: s,
          error: a
        });
      }
    });
  }
  call(e, t) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const i = yield _t({
        transaction: this._getTransactionRequest(e),
        blockTag: this._getBlockTag(t),
        ccipReadEnabled: Promise.resolve(e.ccipReadEnabled)
      });
      return this._call(i.transaction, i.blockTag, i.ccipReadEnabled ? 0 : -1);
    });
  }
  estimateGas(e) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield _t({
        transaction: this._getTransactionRequest(e)
      }), i = yield this.perform("estimateGas", t);
      try {
        return z.from(i);
      } catch (r) {
        return he.throwError("bad result from backend", O.errors.SERVER_ERROR, {
          method: "estimateGas",
          params: t,
          result: i,
          error: r
        });
      }
    });
  }
  _getAddress(e) {
    return ce(this, void 0, void 0, function* () {
      e = yield e, typeof e != "string" && he.throwArgumentError("invalid address or ENS name", "name", e);
      const t = yield this.resolveName(e);
      return t == null && he.throwError("ENS name not configured", O.errors.UNSUPPORTED_OPERATION, {
        operation: `resolveName(${JSON.stringify(e)})`
      }), t;
    });
  }
  _getBlock(e, t) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork(), e = yield e;
      let i = -128;
      const r = {
        includeTransactions: !!t
      };
      if (Ae(e, 32))
        r.blockHash = e;
      else
        try {
          r.blockTag = yield this._getBlockTag(e), Ae(r.blockTag) && (i = parseInt(r.blockTag.substring(2), 16));
        } catch {
          he.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", e);
        }
      return lo(() => ce(this, void 0, void 0, function* () {
        const s = yield this.perform("getBlock", r);
        if (s == null)
          return r.blockHash != null && this._emitted["b:" + r.blockHash] == null || r.blockTag != null && i > this._emitted.block ? null : void 0;
        if (t) {
          let a = null;
          for (let u = 0; u < s.transactions.length; u++) {
            const l = s.transactions[u];
            if (l.blockNumber == null)
              l.confirmations = 0;
            else if (l.confirmations == null) {
              a == null && (a = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval));
              let p = a - l.blockNumber + 1;
              p <= 0 && (p = 1), l.confirmations = p;
            }
          }
          const o = this.formatter.blockWithTransactions(s);
          return o.transactions = o.transactions.map((u) => this._wrapTransaction(u)), o;
        }
        return this.formatter.block(s);
      }), { oncePoll: this });
    });
  }
  getBlock(e) {
    return this._getBlock(e, !1);
  }
  getBlockWithTransactions(e) {
    return this._getBlock(e, !0);
  }
  getTransaction(e) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork(), e = yield e;
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return lo(() => ce(this, void 0, void 0, function* () {
        const i = yield this.perform("getTransaction", t);
        if (i == null)
          return this._emitted["t:" + e] == null ? null : void 0;
        const r = this.formatter.transactionResponse(i);
        if (r.blockNumber == null)
          r.confirmations = 0;
        else if (r.confirmations == null) {
          let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - r.blockNumber + 1;
          a <= 0 && (a = 1), r.confirmations = a;
        }
        return this._wrapTransaction(r);
      }), { oncePoll: this });
    });
  }
  getTransactionReceipt(e) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork(), e = yield e;
      const t = { transactionHash: this.formatter.hash(e, !0) };
      return lo(() => ce(this, void 0, void 0, function* () {
        const i = yield this.perform("getTransactionReceipt", t);
        if (i == null)
          return this._emitted["t:" + e] == null ? null : void 0;
        if (i.blockHash == null)
          return;
        const r = this.formatter.receipt(i);
        if (r.blockNumber == null)
          r.confirmations = 0;
        else if (r.confirmations == null) {
          let a = (yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval)) - r.blockNumber + 1;
          a <= 0 && (a = 1), r.confirmations = a;
        }
        return r;
      }), { oncePoll: this });
    });
  }
  getLogs(e) {
    return ce(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const t = yield _t({ filter: this._getFilter(e) }), i = yield this.perform("getLogs", t);
      return i.forEach((r) => {
        r.removed == null && (r.removed = !1);
      }), ie.arrayOf(this.formatter.filterLog.bind(this.formatter))(i);
    });
  }
  getEtherPrice() {
    return ce(this, void 0, void 0, function* () {
      return yield this.getNetwork(), this.perform("getEtherPrice", {});
    });
  }
  _getBlockTag(e) {
    return ce(this, void 0, void 0, function* () {
      if (e = yield e, typeof e == "number" && e < 0) {
        e % 1 && he.throwArgumentError("invalid BlockTag", "blockTag", e);
        let t = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        return t += e, t < 0 && (t = 0), this.formatter.blockTag(t);
      }
      return this.formatter.blockTag(e);
    });
  }
  getResolver(e) {
    return ce(this, void 0, void 0, function* () {
      let t = e;
      for (; ; ) {
        if (t === "" || t === "." || e !== "eth" && t === "eth")
          return null;
        const i = yield this._getResolver(t, "getResolver");
        if (i != null) {
          const r = new lv(this, i, e);
          return t !== e && !(yield r.supportsWildcard()) ? null : r;
        }
        t = t.split(".").slice(1).join(".");
      }
    });
  }
  _getResolver(e, t) {
    return ce(this, void 0, void 0, function* () {
      t == null && (t = "ENS");
      const i = yield this.getNetwork();
      i.ensAddress || he.throwError("network does not support ENS", O.errors.UNSUPPORTED_OPERATION, { operation: t, network: i.name });
      try {
        const r = yield this.call({
          to: i.ensAddress,
          data: "0x0178b8bf" + Ou(e).substring(2)
        });
        return this.formatter.callAddress(r);
      } catch {
      }
      return null;
    });
  }
  resolveName(e) {
    return ce(this, void 0, void 0, function* () {
      e = yield e;
      try {
        return Promise.resolve(this.formatter.address(e));
      } catch (i) {
        if (Ae(e))
          throw i;
      }
      typeof e != "string" && he.throwArgumentError("invalid ENS name", "name", e);
      const t = yield this.getResolver(e);
      return t ? yield t.getAddress() : null;
    });
  }
  lookupAddress(e) {
    return ce(this, void 0, void 0, function* () {
      e = yield e, e = this.formatter.address(e);
      const t = e.substring(2).toLowerCase() + ".addr.reverse", i = yield this._getResolver(t, "lookupAddress");
      if (i == null)
        return null;
      const r = Fc(yield this.call({
        to: i,
        data: "0x691f3431" + Ou(t).substring(2)
      }), 0);
      return (yield this.resolveName(r)) != e ? null : r;
    });
  }
  getAvatar(e) {
    return ce(this, void 0, void 0, function* () {
      let t = null;
      if (Ae(e)) {
        const s = this.formatter.address(e).substring(2).toLowerCase() + ".addr.reverse", a = yield this._getResolver(s, "getAvatar");
        if (!a)
          return null;
        t = new lv(this, a, s);
        try {
          const o = yield t.getAvatar();
          if (o)
            return o.url;
        } catch (o) {
          if (o.code !== O.errors.CALL_EXCEPTION)
            throw o;
        }
        try {
          const o = Fc(yield this.call({
            to: a,
            data: "0x691f3431" + Ou(s).substring(2)
          }), 0);
          t = yield this.getResolver(o);
        } catch (o) {
          if (o.code !== O.errors.CALL_EXCEPTION)
            throw o;
          return null;
        }
      } else if (t = yield this.getResolver(e), !t)
        return null;
      const i = yield t.getAvatar();
      return i == null ? null : i.url;
    });
  }
  perform(e, t) {
    return he.throwError(e + " not implemented", O.errors.NOT_IMPLEMENTED, { operation: e });
  }
  _startEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _stopEvent(e) {
    this.polling = this._events.filter((t) => t.pollable()).length > 0;
  }
  _addEventListener(e, t, i) {
    const r = new iP(Ya(e), t, i);
    return this._events.push(r), this._startEvent(r), this;
  }
  on(e, t) {
    return this._addEventListener(e, t, !1);
  }
  once(e, t) {
    return this._addEventListener(e, t, !0);
  }
  emit(e, ...t) {
    let i = !1, r = [], s = Ya(e);
    return this._events = this._events.filter((a) => a.tag !== s ? !0 : (setTimeout(() => {
      a.listener.apply(this, t);
    }, 0), i = !0, a.once ? (r.push(a), !1) : !0)), r.forEach((a) => {
      this._stopEvent(a);
    }), i;
  }
  listenerCount(e) {
    if (!e)
      return this._events.length;
    let t = Ya(e);
    return this._events.filter((i) => i.tag === t).length;
  }
  listeners(e) {
    if (e == null)
      return this._events.map((i) => i.listener);
    let t = Ya(e);
    return this._events.filter((i) => i.tag === t).map((i) => i.listener);
  }
  off(e, t) {
    if (t == null)
      return this.removeAllListeners(e);
    const i = [];
    let r = !1, s = Ya(e);
    return this._events = this._events.filter((a) => a.tag !== s || a.listener != t || r ? !0 : (r = !0, i.push(a), !1)), i.forEach((a) => {
      this._stopEvent(a);
    }), this;
  }
  removeAllListeners(e) {
    let t = [];
    if (e == null)
      t = this._events, this._events = [];
    else {
      const i = Ya(e);
      this._events = this._events.filter((r) => r.tag !== i ? !0 : (t.push(r), !1));
    }
    return t.forEach((i) => {
      this._stopEvent(i);
    }), this;
  }
}
var xr = globalThis && globalThis.__awaiter || function(n, e, t, i) {
  function r(s) {
    return s instanceof t ? s : new t(function(a) {
      a(s);
    });
  }
  return new (t || (t = Promise))(function(s, a) {
    function o(p) {
      try {
        l(i.next(p));
      } catch (f) {
        a(f);
      }
    }
    function u(p) {
      try {
        l(i.throw(p));
      } catch (f) {
        a(f);
      }
    }
    function l(p) {
      p.done ? s(p.value) : r(p.value).then(o, u);
    }
    l((i = i.apply(n, e || [])).next());
  });
};
const Ft = new O(D0), uP = ["call", "estimateGas"];
function Nu(n, e) {
  if (n == null)
    return null;
  if (typeof n.message == "string" && n.message.match("reverted")) {
    const t = Ae(n.data) ? n.data : null;
    if (!e || t)
      return { message: n.message, data: t };
  }
  if (typeof n == "object") {
    for (const t in n) {
      const i = Nu(n[t], e);
      if (i)
        return i;
    }
    return null;
  }
  if (typeof n == "string")
    try {
      return Nu(JSON.parse(n), e);
    } catch {
    }
  return null;
}
function tT(n, e, t) {
  const i = t.transaction || t.signedTransaction;
  if (n === "call") {
    const s = Nu(e, !0);
    if (s)
      return s.data;
    Ft.throwError("missing revert data in call exception; Transaction reverted without a reason string", O.errors.CALL_EXCEPTION, {
      data: "0x",
      transaction: i,
      error: e
    });
  }
  if (n === "estimateGas") {
    let s = Nu(e.body, !1);
    s == null && (s = Nu(e, !1)), s && Ft.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", O.errors.UNPREDICTABLE_GAS_LIMIT, {
      reason: s.message,
      method: n,
      transaction: i,
      error: e
    });
  }
  let r = e.message;
  throw e.code === O.errors.SERVER_ERROR && e.error && typeof e.error.message == "string" ? r = e.error.message : typeof e.body == "string" ? r = e.body : typeof e.responseText == "string" && (r = e.responseText), r = (r || "").toLowerCase(), r.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i) && Ft.throwError("insufficient funds for intrinsic transaction cost", O.errors.INSUFFICIENT_FUNDS, {
    error: e,
    method: n,
    transaction: i
  }), r.match(/nonce (is )?too low/i) && Ft.throwError("nonce has already been used", O.errors.NONCE_EXPIRED, {
    error: e,
    method: n,
    transaction: i
  }), r.match(/replacement transaction underpriced|transaction gas price.*too low/i) && Ft.throwError("replacement fee too low", O.errors.REPLACEMENT_UNDERPRICED, {
    error: e,
    method: n,
    transaction: i
  }), r.match(/only replay-protected/i) && Ft.throwError("legacy pre-eip-155 transactions not supported", O.errors.UNSUPPORTED_OPERATION, {
    error: e,
    method: n,
    transaction: i
  }), uP.indexOf(n) >= 0 && r.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/) && Ft.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", O.errors.UNPREDICTABLE_GAS_LIMIT, {
    error: e,
    method: n,
    transaction: i
  }), e;
}
function cv(n) {
  return new Promise(function(e) {
    setTimeout(e, n);
  });
}
function lP(n) {
  if (n.error) {
    const e = new Error(n.error.message);
    throw e.code = n.error.code, e.data = n.error.data, e;
  }
  return n.result;
}
function cu(n) {
  return n && n.toLowerCase();
}
const Ly = {};
class nT extends Ua {
  constructor(e, t, i) {
    if (super(), e !== Ly)
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    U(this, "provider", t), i == null && (i = 0), typeof i == "string" ? (U(this, "_address", this.provider.formatter.address(i)), U(this, "_index", null)) : typeof i == "number" ? (U(this, "_index", i), U(this, "_address", null)) : Ft.throwArgumentError("invalid address or index", "addressOrIndex", i);
  }
  connect(e) {
    return Ft.throwError("cannot alter JSON-RPC Signer connection", O.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }
  connectUnchecked() {
    return new cP(Ly, this.provider, this._address || this._index);
  }
  getAddress() {
    return this._address ? Promise.resolve(this._address) : this.provider.send("eth_accounts", []).then((e) => (e.length <= this._index && Ft.throwError("unknown account #" + this._index, O.errors.UNSUPPORTED_OPERATION, {
      operation: "getAddress"
    }), this.provider.formatter.address(e[this._index])));
  }
  sendUncheckedTransaction(e) {
    e = Ut(e);
    const t = this.getAddress().then((i) => (i && (i = i.toLowerCase()), i));
    if (e.gasLimit == null) {
      const i = Ut(e);
      i.from = t, e.gasLimit = this.provider.estimateGas(i);
    }
    return e.to != null && (e.to = Promise.resolve(e.to).then((i) => xr(this, void 0, void 0, function* () {
      if (i == null)
        return null;
      const r = yield this.provider.resolveName(i);
      return r == null && Ft.throwArgumentError("provided ENS name resolves to null", "tx.to", i), r;
    }))), _t({
      tx: _t(e),
      sender: t
    }).then(({ tx: i, sender: r }) => {
      i.from != null ? i.from.toLowerCase() !== r && Ft.throwArgumentError("from address mismatch", "transaction", e) : i.from = r;
      const s = this.provider.constructor.hexlifyTransaction(i, { from: !0 });
      return this.provider.send("eth_sendTransaction", [s]).then((a) => a, (a) => (typeof a.message == "string" && a.message.match(/user denied/i) && Ft.throwError("user rejected transaction", O.errors.ACTION_REJECTED, {
        action: "sendTransaction",
        transaction: i
      }), tT("sendTransaction", a, s)));
    });
  }
  signTransaction(e) {
    return Ft.throwError("signing transactions is unsupported", O.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }
  sendTransaction(e) {
    return xr(this, void 0, void 0, function* () {
      const t = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval), i = yield this.sendUncheckedTransaction(e);
      try {
        return yield lo(() => xr(this, void 0, void 0, function* () {
          const r = yield this.provider.getTransaction(i);
          if (r !== null)
            return this.provider._wrapTransaction(r, i, t);
        }), { oncePoll: this.provider });
      } catch (r) {
        throw r.transactionHash = i, r;
      }
    });
  }
  signMessage(e) {
    return xr(this, void 0, void 0, function* () {
      const t = typeof e == "string" ? Dt(e) : e, i = yield this.getAddress();
      try {
        return yield this.provider.send("personal_sign", [H(t), i.toLowerCase()]);
      } catch (r) {
        throw typeof r.message == "string" && r.message.match(/user denied/i) && Ft.throwError("user rejected signing", O.errors.ACTION_REJECTED, {
          action: "signMessage",
          from: i,
          messageData: e
        }), r;
      }
    });
  }
  _legacySignMessage(e) {
    return xr(this, void 0, void 0, function* () {
      const t = typeof e == "string" ? Dt(e) : e, i = yield this.getAddress();
      try {
        return yield this.provider.send("eth_sign", [i.toLowerCase(), H(t)]);
      } catch (r) {
        throw typeof r.message == "string" && r.message.match(/user denied/i) && Ft.throwError("user rejected signing", O.errors.ACTION_REJECTED, {
          action: "_legacySignMessage",
          from: i,
          messageData: e
        }), r;
      }
    });
  }
  _signTypedData(e, t, i) {
    return xr(this, void 0, void 0, function* () {
      const r = yield rn.resolveNames(e, t, i, (a) => this.provider.resolveName(a)), s = yield this.getAddress();
      try {
        return yield this.provider.send("eth_signTypedData_v4", [
          s.toLowerCase(),
          JSON.stringify(rn.getPayload(r.domain, t, r.value))
        ]);
      } catch (a) {
        throw typeof a.message == "string" && a.message.match(/user denied/i) && Ft.throwError("user rejected signing", O.errors.ACTION_REJECTED, {
          action: "_signTypedData",
          from: s,
          messageData: { domain: r.domain, types: t, value: r.value }
        }), a;
      }
    });
  }
  unlock(e) {
    return xr(this, void 0, void 0, function* () {
      const t = this.provider, i = yield this.getAddress();
      return t.send("personal_unlockAccount", [i.toLowerCase(), e, null]);
    });
  }
}
class cP extends nT {
  sendTransaction(e) {
    return this.sendUncheckedTransaction(e).then((t) => ({
      hash: t,
      nonce: null,
      gasLimit: null,
      gasPrice: null,
      data: null,
      value: null,
      chainId: null,
      confirmations: 0,
      from: null,
      wait: (i) => this.provider.waitForTransaction(t, i)
    }));
  }
}
const dP = {
  chainId: !0,
  data: !0,
  gasLimit: !0,
  gasPrice: !0,
  nonce: !0,
  to: !0,
  value: !0,
  type: !0,
  accessList: !0,
  maxFeePerGas: !0,
  maxPriorityFeePerGas: !0
};
class pP extends oP {
  constructor(e, t) {
    let i = t;
    i == null && (i = new Promise((r, s) => {
      setTimeout(() => {
        this.detectNetwork().then((a) => {
          r(a);
        }, (a) => {
          s(a);
        });
      }, 0);
    })), super(i), e || (e = Oi(this.constructor, "defaultUrl")()), typeof e == "string" ? U(this, "connection", Object.freeze({
      url: e
    })) : U(this, "connection", Object.freeze(Ut(e))), this._nextId = 42;
  }
  get _cache() {
    return this._eventLoopCache == null && (this._eventLoopCache = {}), this._eventLoopCache;
  }
  static defaultUrl() {
    return "http://localhost:8545";
  }
  detectNetwork() {
    return this._cache.detectNetwork || (this._cache.detectNetwork = this._uncachedDetectNetwork(), setTimeout(() => {
      this._cache.detectNetwork = null;
    }, 0)), this._cache.detectNetwork;
  }
  _uncachedDetectNetwork() {
    return xr(this, void 0, void 0, function* () {
      yield cv(0);
      let e = null;
      try {
        e = yield this.send("eth_chainId", []);
      } catch {
        try {
          e = yield this.send("net_version", []);
        } catch {
        }
      }
      if (e != null) {
        const t = Oi(this.constructor, "getNetwork");
        try {
          return t(z.from(e).toNumber());
        } catch (i) {
          return Ft.throwError("could not detect network", O.errors.NETWORK_ERROR, {
            chainId: e,
            event: "invalidNetwork",
            serverError: i
          });
        }
      }
      return Ft.throwError("could not detect network", O.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }
  getSigner(e) {
    return new nT(Ly, this, e);
  }
  getUncheckedSigner(e) {
    return this.getSigner(e).connectUnchecked();
  }
  listAccounts() {
    return this.send("eth_accounts", []).then((e) => e.map((t) => this.formatter.address(t)));
  }
  send(e, t) {
    const i = {
      method: e,
      params: t,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: Ss(i),
      provider: this
    });
    const r = ["eth_chainId", "eth_blockNumber"].indexOf(e) >= 0;
    if (r && this._cache[e])
      return this._cache[e];
    const s = hp(this.connection, JSON.stringify(i), lP).then((a) => (this.emit("debug", {
      action: "response",
      request: i,
      response: a,
      provider: this
    }), a), (a) => {
      throw this.emit("debug", {
        action: "response",
        error: a,
        request: i,
        provider: this
      }), a;
    });
    return r && (this._cache[e] = s, setTimeout(() => {
      this._cache[e] = null;
    }, 0)), s;
  }
  prepareRequest(e, t) {
    switch (e) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];
      case "getGasPrice":
        return ["eth_gasPrice", []];
      case "getBalance":
        return ["eth_getBalance", [cu(t.address), t.blockTag]];
      case "getTransactionCount":
        return ["eth_getTransactionCount", [cu(t.address), t.blockTag]];
      case "getCode":
        return ["eth_getCode", [cu(t.address), t.blockTag]];
      case "getStorageAt":
        return ["eth_getStorageAt", [cu(t.address), De(t.position, 32), t.blockTag]];
      case "sendTransaction":
        return ["eth_sendRawTransaction", [t.signedTransaction]];
      case "getBlock":
        return t.blockTag ? ["eth_getBlockByNumber", [t.blockTag, !!t.includeTransactions]] : t.blockHash ? ["eth_getBlockByHash", [t.blockHash, !!t.includeTransactions]] : null;
      case "getTransaction":
        return ["eth_getTransactionByHash", [t.transactionHash]];
      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [t.transactionHash]];
      case "call":
        return ["eth_call", [Oi(this.constructor, "hexlifyTransaction")(t.transaction, { from: !0 }), t.blockTag]];
      case "estimateGas":
        return ["eth_estimateGas", [Oi(this.constructor, "hexlifyTransaction")(t.transaction, { from: !0 })]];
      case "getLogs":
        return t.filter && t.filter.address != null && (t.filter.address = cu(t.filter.address)), ["eth_getLogs", [t.filter]];
    }
    return null;
  }
  perform(e, t) {
    return xr(this, void 0, void 0, function* () {
      if (e === "call" || e === "estimateGas") {
        const r = t.transaction;
        if (r && r.type != null && z.from(r.type).isZero() && r.maxFeePerGas == null && r.maxPriorityFeePerGas == null) {
          const s = yield this.getFeeData();
          s.maxFeePerGas == null && s.maxPriorityFeePerGas == null && (t = Ut(t), t.transaction = Ut(r), delete t.transaction.type);
        }
      }
      const i = this.prepareRequest(e, t);
      i == null && Ft.throwError(e + " not implemented", O.errors.NOT_IMPLEMENTED, { operation: e });
      try {
        return yield this.send(i[0], i[1]);
      } catch (r) {
        return tT(e, r, t);
      }
    });
  }
  _startEvent(e) {
    e.tag === "pending" && this._startPending(), super._startEvent(e);
  }
  _startPending() {
    if (this._pendingFilter != null)
      return;
    const e = this, t = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = t, t.then(function(i) {
      function r() {
        e.send("eth_getFilterChanges", [i]).then(function(s) {
          if (e._pendingFilter != t)
            return null;
          let a = Promise.resolve();
          return s.forEach(function(o) {
            e._emitted["t:" + o.toLowerCase()] = "pending", a = a.then(function() {
              return e.getTransaction(o).then(function(u) {
                return e.emit("pending", u), null;
              });
            });
          }), a.then(function() {
            return cv(1e3);
          });
        }).then(function() {
          if (e._pendingFilter != t) {
            e.send("eth_uninstallFilter", [i]);
            return;
          }
          return setTimeout(function() {
            r();
          }, 0), null;
        }).catch((s) => {
        });
      }
      return r(), i;
    }).catch((i) => {
    });
  }
  _stopEvent(e) {
    e.tag === "pending" && this.listenerCount("pending") === 0 && (this._pendingFilter = null), super._stopEvent(e);
  }
  // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.
  static hexlifyTransaction(e, t) {
    const i = Ut(dP);
    if (t)
      for (const s in t)
        t[s] && (i[s] = !0);
    r0(e, i);
    const r = {};
    return ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function(s) {
      if (e[s] == null)
        return;
      const a = rp(z.from(e[s]));
      s === "gasLimit" && (s = "gas"), r[s] = a;
    }), ["from", "to", "data"].forEach(function(s) {
      e[s] != null && (r[s] = H(e[s]));
    }), e.accessList && (r.accessList = ja(e.accessList)), r;
  }
}
var fP = Object.defineProperty, yP = Object.getOwnPropertyDescriptor, hP = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? yP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && fP(e, t, r), r;
}, du = (n, e) => (t, i) => e(t, i, n);
const iT = ye.createInterface("EthereumService");
let dl = class {
  constructor(n, e, t, i, r) {
    this.eventAggregator = n, this.logger = e, this.configuration = t, this.readOnlyProvider = i, this.walletConnector = r, this.logger = e.scopeTo("EthereumService");
  }
  static register(n) {
    fe.singleton(iT, dl).register(n);
  }
  get targetedChainId() {
    return this.configuration.chainId;
  }
  lastBlock;
  async connect(n) {
    return n ? await this.walletConnector.connectTo(n) : await this.walletConnector.connect();
  }
  async getMetaMaskProvider() {
    const n = await zk({ mustBeMetaMask: !0 });
    if (!n)
      return null;
    if (await n._metamask.isUnlocked() && (await n.request({ method: "eth_accounts" })).length)
      return n;
  }
  async getAccountsForProvider(n) {
    return Ua.isSigner(n) ? [await n.getAddress()] : await n.listAccounts();
  }
  /**
   *
   * @param web3ModalProvider should be a Web3Provider
   * @returns
   */
  async switchToTargetedNetwork(n) {
    try {
      return await n.provider.request?.({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: `0x${this.targetedChainId.toString(16)}` }]
      }), n.provider;
    } catch (e) {
      if (e.code !== 4902)
        return;
      throw new Error(`The ${this.configuration.chain} network is not installed in your Metamask configuration`);
    }
  }
  async addTokenToMetamask(n, e, t, i, r) {
    try {
      await n.request({
        method: "wallet_watchAsset",
        params: {
          type: "ERC20",
          // Initially only supports ERC20, but eventually more!
          options: {
            address: e,
            // The address that the token is at.
            symbol: t,
            // A ticker symbol or shorthand, up to 5 chars.
            decimals: i,
            // The number of decimals in the token
            image: r
            // A string url of the token logo
          }
        }
      });
    } catch (s) {
      this.logger.error(s);
    }
  }
  async getBlock(n) {
    const e = await this.readOnlyProvider.getBlock(n);
    return e.blockDate = new Date(e.timestamp * 1e3), e;
  }
  getEtherscanLink(n, e = !1) {
    return Vk(this.configuration.scanLink, { type: e ? "tx" : "address", address: n });
  }
};
dl = hP([
  du(0, Kd),
  du(1, Ra),
  du(2, Da),
  du(3, ip),
  du(4, N0)
], dl);
var mP = Object.defineProperty, bP = Object.getOwnPropertyDescriptor, gP = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? bP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && mP(e, t, r), r;
}, vP = (n, e) => (t, i) => e(t, i, n);
const rT = ye.createInterface("HttpService"), sT = { accept: "application/json" }, xP = { "content-type": "application/json", ...sT };
let xd = class {
  constructor(n) {
    this.logger = n, this.logger = n.scopeTo("HttpService");
  }
  static register(n) {
    n.register(fe.singleton(rT, xd));
  }
  async call(n, e, t) {
    const i = await fetch(n, {
      body: e,
      method: e ? "POST" : "GET",
      headers: e ? xP : sT,
      ...t
    });
    if (i.ok)
      return await i.json();
    const r = new Error(await i.text());
    return this.logger.error({ response: i, error: r }), Promise.reject(r);
  }
};
xd = gP([
  vP(0, Ra)
], xd);
var TP = Object.defineProperty, wP = Object.getOwnPropertyDescriptor, AP = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? wP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && TP(e, t, r), r;
}, dv = (n, e) => (t, i) => e(t, i, n);
const aT = ye.createInterface("ObserverService");
let Td = class {
  constructor(n, e) {
    this.locator = n, this.cacheService = e;
  }
  static register(n) {
    n.register(fe.singleton(aT, Td));
  }
  /**
   * Make a object property observable and subscribe to changes in its value.
   * Viewmodels should use @watch.
   * @param obj object having the property to observe
   * @param property property to observe
   * @param method ISubscriber, handles changes in the property's values
   * @returns method to unsubscribe.  Singletons, such as services, don't need to call this.
   */
  // @cache<ObserverService>(function () {
  //   return { storage: this.cacheService };
  // })
  listen(n, e, t) {
    const i = this.locator.getObserver(n, e), r = {
      handleChange: t
    };
    return i.subscribe(r), () => i.unsubscribe(r);
  }
};
Td = AP([
  dv(0, ka),
  dv(1, Fl)
], Td);
var EP = Object.defineProperty, SP = Object.getOwnPropertyDescriptor, MP = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? SP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && EP(e, t, r), r;
}, CP = (n, e) => (t, i) => e(t, i, n);
const oT = ye.createInterface("TimingService");
let wd = class {
  constructor(n) {
    this.config = n;
  }
  static register(n) {
    fe.singleton(oT, wd).register(n);
  }
  startTimer(n) {
    this.config.isDevelopment && console.time(n);
  }
  endTimer(n) {
    this.config.isDevelopment && console.timeEnd(n);
  }
};
wd = MP([
  CP(0, Da)
], wd);
var _P = Object.defineProperty, RP = Object.getOwnPropertyDescriptor, kP = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? RP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && _P(e, t, r), r;
}, ui = (n, e) => (t, i) => e(t, i, n);
const PP = ye.createInterface();
let Uy = class {
  constructor(n, e, t, i, r, s, a, o, u, l, p, f) {
    this.httpService = n, this.numberService = e, this.ethereumService = t, this.browserStorageService = i, this.timingService = r, this.cacheService = s, this.observerService = a, this.encryptionService = o, this.contractService = u, this.tokenService = l, this.ipfsService = p, this.configuration = f;
  }
  static register(n) {
    n.register(fe.singleton(PP, Uy)).register(Td).register(wd).register(np).register(al).register(xd).register(ol).register(dl).register(bd).register(M0).register(md).register(Co).register(_o);
  }
};
Uy = kP([
  ui(0, rT),
  ui(1, zl),
  ui(2, iT),
  ui(3, S0),
  ui(4, oT),
  ui(5, Fl),
  ui(6, aT),
  ui(7, R5),
  ui(8, Jo),
  ui(9, A0),
  ui(10, E0),
  ui(11, Da)
], Uy);
ye.createInterface("DateServiceIntl");
var IP = Object.defineProperty, OP = Object.getOwnPropertyDescriptor, BP = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? OP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && IP(e, t, r), r;
};
let pv = class {
  disposables;
  constructor() {
    this.disposables = new Array();
  }
  push(n) {
    return this.disposables.push(n);
  }
  dispose(n) {
    if (n)
      this._dispose(n);
    else {
      for (n of this.disposables)
        n.dispose();
      this.disposables.length = 0;
    }
  }
  _dispose(n) {
    n.dispose(), this.disposables.splice(this.disposables.indexOf(n), 1);
  }
};
pv = BP([
  yx()
], pv);
var NP = Object.defineProperty, DP = Object.getOwnPropertyDescriptor, $P = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? DP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && NP(e, t, r), r;
}, FP = (n, e) => (t, i) => e(t, i, n);
const LP = ye.createInterface("TransactionsService");
let Ad = class {
  constructor(n) {
    this.eventAggregator = n;
  }
  static blocksToConfirm = 1;
  static register(n) {
    fe.singleton(LP, Ad).register(n);
  }
  async send(n) {
    let e;
    try {
      this.eventAggregator.publish("transaction.sending");
      const t = await n();
      return this.eventAggregator.publish("transaction.sent", t), e = await t.wait(1), this.eventAggregator.publish("transaction.mined", { message: "Transaction was mined", receipt: e }), e = await t.wait(Ad.blocksToConfirm), this.eventAggregator.publish("transaction.confirmed", { message: "Transaction was confirmed", receipt: e }), e;
    } catch (t) {
      return this.eventAggregator.publish("transaction.failed", t), null;
    }
  }
};
Ad = $P([
  FP(0, Kd)
], Ad);
var UP = Object.defineProperty, VP = Object.getOwnPropertyDescriptor, jP = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? VP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && UP(e, t, r), r;
}, pu = (n, e) => (t, i) => e(t, i, n);
const $0 = ye.createInterface("IContractStore");
let Ed = class {
  constructor(n, e, t, i, r) {
    this.contractService = n, this.tokenService = e, this.logger = t, this.numberService = i, this.tokenInfo = r;
  }
  static register(n) {
    n.register(fe.singleton($0, Ed));
  }
  async getAsset(n, e, t, i, r, s) {
    let a;
    e && (a = Number(e));
    const o = await this.tokenInfo.tokens;
    console.log("Address", n), console.log("Token Infos", o);
    const u = o.find((T) => T.address === n && T.id == a);
    if (!u) {
      this.logger.error(`No token info was found for ${n}`);
      return;
    }
    const l = await this.tokenService.getTokenContract(n, u.id);
    if (s || (u.id ? s = await t.oraclePerERC721Id(n, u.id) : s = await t.oraclePerERC20(n)), !s || z.from(s).isZero())
      return;
    const f = await (await this.contractService.getContract("monetary", "Oracle", s)).getData();
    if (!f[1])
      return;
    u.price = this.numberService.fromString(Xt(f[0], 18));
    let b = Y2(1, 18), A;
    u.id || (A = await l.totalSupply(), b = await l.balanceOf(i));
    let x;
    u.id ? x = cs.Ecological : x = await t.assetTypeOfERC20(n), r && this.populateTransactionsForAsset(r, l, i, u);
    const w = {
      quantity: b,
      token: u,
      total: 0,
      type: x,
      totalSupply: A
    };
    return w.total = u.id ? u.price : this.numberService.fromString(Xt(w.quantity, 18)) * u.price, w;
  }
  async populateTransactionsForAsset(n, e, t, i) {
    const r = await e.queryFilter(e.filters.Transfer(void 0, t)), s = await this.mapTransactions(r, "deposit", i);
    n.push(...s);
    const a = await e.queryFilter(e.filters.Transfer(t)), o = await this.mapTransactions(a, "withdrawl", i);
    n.push(...o);
  }
  async mapTransactions(n, e, t) {
    return await Promise.all(
      n.map(async (i) => {
        const r = await i.getBlock();
        return {
          address: e === "deposit" ? i.args.from : i.args.to,
          amount: "amount" in i.args ? i.args.amount : Y2(1, 18),
          date: r.timestamp,
          id: i.transactionHash,
          token: t,
          type: e
        };
      })
    );
  }
};
Ed = jP([
  pu(0, Jo),
  pu(1, A0),
  pu(2, Ra),
  pu(3, zl),
  pu(4, M5)
], Ed);
var zP = Object.defineProperty, GP = Object.getOwnPropertyDescriptor, qP = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? GP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && zP(e, t, r), r;
}, HP = (n, e) => (t, i) => e(t, i, n);
const F0 = ye.createInterface("DataStore");
let Sd = class {
  constructor(n) {
    this.firebaseService = n;
  }
  static register(n) {
    n.register(fe.singleton(F0, Sd));
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async getDocs(...n) {
    return this.firebaseService.getDocs(...n);
  }
};
Sd = qP([
  HP(0, w0)
], Sd);
function bp(n = "") {
  const e = /* @__PURE__ */ new WeakMap();
  return function(t, i, r) {
    const s = t[i];
    if (typeof s != "function")
      throw new Error(`ER: @callOnce: > ${String(i)}`);
    r.value = function(...a) {
      if (e.has(this))
        return e.get(this);
      const o = s.apply(this, a);
      return e.set(this, o), o;
    };
  };
}
var Lc = /* @__PURE__ */ ((n) => (n.low = "Low Risk", n.moderate = "Moderate Risk", n.high = "High Risk", n))(Lc || {}), KP = Object.defineProperty, WP = Object.getOwnPropertyDescriptor, gp = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? WP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && KP(e, t, r), r;
}, fu = (n, e) => (t, i) => e(t, i, n);
const uT = ye.createInterface("ReserveStore");
let xa = class {
  constructor(n, e, t, i, r) {
    this.contractStore = n, this.contractService = e, this.numberService = t, this.configuration = i, this.dataStore = r;
  }
  reserveValue;
  kCurMarketCap;
  backing;
  kCurPrice;
  kCurSupply;
  transactions = [];
  reserveAssets = [];
  kCurReserveDistribution;
  kCurMentoDistribution;
  kCurPrimaryPoolDistribution;
  minBacking;
  kGuilderCurrentPrice;
  kGuilderTotalSupply;
  kGuilderSpread;
  kGuilderInflationRate;
  kGuilderTobinTax;
  static register(n) {
    n.register(fe.singleton(uT, xa));
  }
  get kCurCirculatingDistribution() {
    return !this.kCurReserveDistribution || !this.kCurMentoDistribution || !this.kCurPrimaryPoolDistribution ? 0 : 1 - (this.kCurReserveDistribution + this.kCurMentoDistribution + this.kCurPrimaryPoolDistribution);
  }
  get currentCollateralizationRatio() {
    return this.numberService.fromString(Xt(this.backing ?? 0, 2));
  }
  get currentLeverageRatio() {
    return this.backing ? this.calculateLeverage(this.backing) : 0;
  }
  get maxLeverageRatio() {
    return 1 / this.numberService.fromString(Xt(this.minBacking ?? 0, 4)) * 100;
  }
  get minCollateralizationRatio() {
    return this.numberService.fromString(Xt(this.minBacking ?? 0, 4));
  }
  get minCollateralizationValue() {
    return this.kCurMarketCap ? this.minCollateralizationRatio * this.numberService.fromString(Xt(this.kCurMarketCap, 18)) : 0;
  }
  get maxLeverageMultiplier() {
    return `${Math.round(this.maxLeverageRatio / 100 * 100) / 100}x`;
  }
  get kCurTotalValue() {
    return this.numberService.fromString(Xt(this.kCurMarketCap ?? 0, 18));
  }
  get kGuilderMarketCap() {
    return this.kGuilderCurrentPrice ? this.kGuilderCurrentPrice * this.numberService.fromString(Xt(this.kGuilderTotalSupply ?? 0, 18)) : 0;
  }
  get kCurPriceFloor() {
    return !this.reserveValue || !this.kCurSupply ? 0 : this.numberService.fromString(Xt(this.reserveValue, 18)) / this.numberService.fromString(Xt(this.kCurSupply, 18));
  }
  get kCurPriceCeiling() {
    return !this.reserveValue || !this.kCurSupply ? 0 : this.kCurPriceFloor * 1.9;
  }
  get lowRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === cs.Stablecoin) ?? [];
  }
  get moderateRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === cs.NonStablecoin) ?? [];
  }
  get highRiskAssets() {
    return this.reserveAssets?.filter((n) => n.type === cs.Ecological) ?? [];
  }
  get kGuilderValueRatio() {
    return this.kCurPrice ? 4 / this.kCurPrice : 0;
  }
  getRiskClass(n) {
    switch (n) {
      case cs.Ecological:
        return Lc.high;
      case cs.NonStablecoin:
        return Lc.moderate;
      case cs.Stablecoin:
        return Lc.low;
    }
  }
  async loadAssets() {
    const n = await this.getReserveContract(), e = n.address;
    if (!e)
      return;
    const t = (await Promise.all([
      n.allRegisteredERC20s().then((r) => r.map((s) => ({ tokenId: void 0, address: s }))),
      n.allRegisteredERC721Ids().then((r) => r.map((s) => ({ tokenId: s.id, address: s.erc721 })))
    ])).flatMap((r) => r);
    console.log("Assets in reserve", t), this.reserveAssets = (await Promise.all(t.map((r) => this.contractStore.getAsset(r.address, r.tokenId, n, e, this.transactions).catch()))).filter(Boolean), this.loadkCurData();
    const i = await n.reserveStatus();
    this.reserveValue = i[0], this.kCurMarketCap = i[1], this.backing = i[2], this.minBacking = await n.minBacking();
  }
  async loadkCur() {
    await this.loadkCurData();
    const n = await this.getReserveContract();
    if (!this.kCurSupply)
      return;
    const t = await (await this.contractService.getContract("monetary", "Kolektivo Curacao Reserve Token")).balanceOf(n.address);
    this.kCurReserveDistribution = this.numberService.fromString(Xt(t, 18)) / this.numberService.fromString(Xt(this.kCurSupply, 18)), this.kCurMentoDistribution = 0, this.kCurPrimaryPoolDistribution = 0;
  }
  async loadkGuilder() {
    (await this.getReserveContract()).address && (this.kGuilderCurrentPrice = 4, this.kGuilderTotalSupply = z.from(1934223345231232342413213n), this.kGuilderSpread = 0.2, this.kGuilderInflationRate = 0.01, this.kGuilderTobinTax = 0.05);
  }
  async loadkCurData() {
    if (this.kCurPrice || this.kCurSupply)
      return;
    const n = await this.getReserveContract(), e = await n.token();
    if (!e)
      return;
    const t = n.address;
    if (!t)
      return;
    const i = await n.tokenOracle();
    if (!i)
      return;
    const r = await this.contractStore.getAsset(e, void 0, n, t, void 0, i);
    this.kCurPrice = r?.token.price, this.kCurSupply = r?.totalSupply;
  }
  getReserveContract() {
    return this.contractService.getContract("monetary", "Reserve");
  }
  async getReserveValueOverTime(n) {
    const [e, t] = await Promise.all([this.getData("reserve", n), this.getReserveContract().then((i) => i.reserveStatus())]);
    return e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      value: t[0]
    }), e;
  }
  async getkGuilderValueRatioOverTime(n) {
    const [e] = await Promise.all([this.getData("kGuilder", n), this.loadkCurData()]);
    return e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      value: this.kGuilderValueRatio
    }), e;
  }
  async getLeverageRatioValueOverTime(n) {
    const [e, [t, i]] = await Promise.all([
      this.getData("kCurRatio", n),
      this.getReserveContract().then((r) => Promise.all([r.reserveStatus(), r.minBacking()]))
    ]);
    return e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      currentLeverageRatio: this.calculateLeverage(t[2]),
      maxLeverageRatio: 1 / (this.numberService.fromString(Xt(i, 2)) / 100) * 100
    }), e;
  }
  async getkCurSupplyData(n) {
    const [e] = await Promise.all([this.getData("kCurSupply", n), this.loadkCur()]);
    return e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      kCurCirculatingDistribution: this.kCurCirculatingDistribution,
      kCurMentoDistribution: this.kCurMentoDistribution,
      kCurPrimaryPoolDistribution: this.kCurPrimaryPoolDistribution,
      kCurReserveDistribution: this.kCurReserveDistribution
    }), e;
  }
  async getkCurPriceOverTime(n) {
    const [e] = await Promise.all([this.getData("kCurPrice", n), this.loadkCurData(), this.loadAssets()]);
    return e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      kCurPrice: this.kCurPrice,
      kCurPriceCeiling: this.kCurPriceCeiling,
      kCurPriceFloor: this.kCurPriceFloor
    }), e;
  }
  async getRiskOverTime(n) {
    const [e, [t, i]] = await Promise.all([
      this.getData("risk", n),
      this.getReserveContract().then((r) => Promise.all([r.reserveStatus(), r.minBacking()])),
      this.loadAssets()
    ]);
    return this.kCurMarketCap = t[1], this.minBacking = i, e.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      minCollateralValue: this.minCollateralizationValue,
      marketCap: this.kCurTotalValue,
      lowRisk: this.lowRiskAssets.map((r) => r.total).sum(),
      moderateRisk: this.moderateRiskAssets.map((r) => r.total).sum(),
      highRisk: this.highRiskAssets.map((r) => r.total).sum()
    }), e;
  }
  async getData(n, e) {
    const t = Q5(e), i = await this.dataStore.getDocs(`${this.configuration.firebaseCollection}/${n}/${J5(e)}`, "createdAt", "desc", {
      fieldPath: "createdAt",
      opStr: ">=",
      value: t
    });
    return i.sort((r, s) => new Date(r.createdAt).getTime() - new Date(s.createdAt).getTime()), i;
  }
  calculateLeverage(n) {
    return 1 / this.numberService.fromString(Xt(n, 4)) * 100;
  }
};
gp([
  bp()
], xa.prototype, "loadAssets", 1);
gp([
  bp()
], xa.prototype, "loadkCur", 1);
gp([
  bp()
], xa.prototype, "loadkGuilder", 1);
xa = gp([
  fu(0, $0),
  fu(1, Jo),
  fu(2, zl),
  fu(3, Da),
  fu(4, F0)
], xa);
var JP = Object.defineProperty, QP = Object.getOwnPropertyDescriptor, lT = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? QP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && JP(e, t, r), r;
}, yu = (n, e) => (t, i) => e(t, i, n);
const cT = ye.createInterface("TreasuryStore");
let pl = class {
  constructor(n, e, t, i, r) {
    this.numberService = n, this.contractStore = e, this.contractService = t, this.configuration = i, this.dataStore = r;
  }
  totalSupply;
  totalValuation;
  treasuryDistribution;
  reservesDistribution;
  treasuryContract;
  lastRebaseTime;
  treasuryAssets = [];
  transactions = [];
  static register(n) {
    n.register(fe.singleton(cT, pl));
  }
  get treasuryValue() {
    return this.treasuryAssets?.length === 0 ? 0 : this.treasuryAssets?.map((n) => n?.total ?? 0).sum() ?? 0;
  }
  async loadTokenData() {
    if (this.totalValuation && this.totalSupply)
      return;
    const n = await this.getTreasuryContract();
    this.totalValuation = await n.totalValuation(), this.totalSupply = await n.totalSupply(), this.treasuryDistribution = (await this.getDistributionPercentage("Treasury")).toNumber(), this.reservesDistribution = (await this.getDistributionPercentage("Reserve")).toNumber();
  }
  async loadAssets() {
    const n = await this.getTreasuryContract(), e = n.address;
    if (!e)
      return;
    const t = (await Promise.all([
      n.allRegisteredERC20s().then((i) => i.map((r) => ({ tokenId: void 0, address: r }))),
      n.allRegisteredERC721Ids().then((i) => i.map((r) => ({ tokenId: r.id, address: r.erc721 })))
    ])).flatMap((i) => i);
    this.treasuryAssets = (await Promise.all(t.map((i) => this.contractStore.getAsset(i.address, i.tokenId, n, e, this.transactions).catch()))).filter(Boolean);
  }
  async getValueOverTime(n) {
    const e = Q5(n), i = (await this.dataStore.getDocs(`${this.configuration.firebaseCollection}/ktt/${J5(n)}`, "createdAt", "desc", {
      fieldPath: "createdAt",
      opStr: ">=",
      value: e
    })).map((a) => ({
      createdAt: Number(new Date(a.createdAt)),
      value: this.numberService.fromString(Xt(a.value, 18))
    }));
    i.sort((a, o) => new Date(a.createdAt).getTime() - new Date(o.createdAt).getTime());
    const s = await (await this.getTreasuryContract()).totalValuation();
    return i.push({
      createdAt: Number(/* @__PURE__ */ new Date()),
      value: this.numberService.fromString(Xt(s, 18))
    }), i;
  }
  async getLastRebaseTime() {
    const n = await this.getTreasuryContract(), e = await n.queryFilter(n.filters.Rebase());
    e.sort((t, i) => i.blockNumber - t.blockNumber), this.lastRebaseTime = e[0] && new Date((await e[0].getBlock()).timestamp * 1e3);
  }
  get circulatingDistribution() {
    return this.treasuryDistribution == null || this.reservesDistribution == null ? 0 : 1 - (this.treasuryDistribution + this.reservesDistribution);
  }
  get currentPrice() {
    return !this.totalSupply || !this.totalValuation ? 0 : Number(Xt(this.totalSupply, 18)) / Number(Xt(this.totalValuation, 18));
  }
  async getTreasuryContract() {
    return this.treasuryContract ? this.treasuryContract : (this.treasuryContract = await this.contractService.getContract("monetary", "Treasury"), this.treasuryContract);
  }
  async getDistributionPercentage(n) {
    const e = (await this.contractService.getContract("monetary", n)).address;
    return !e || !this.totalSupply ? z.from(0) : (await (await this.getTreasuryContract()).balanceOf(e)).div(this.totalSupply);
  }
};
lT([
  bp()
], pl.prototype, "loadAssets", 1);
pl = lT([
  yu(0, zl),
  yu(1, $0),
  yu(2, Jo),
  yu(3, Da),
  yu(4, F0)
], pl);
var YP = Object.defineProperty, XP = Object.getOwnPropertyDescriptor, ZP = (n, e, t, i) => {
  for (var r = i > 1 ? void 0 : i ? XP(e, t) : e, s = n.length - 1, a; s >= 0; s--)
    (a = n[s]) && (r = (i ? a(e, t, r) : a(r)) || r);
  return i && r && YP(e, t, r), r;
}, eI = (n, e) => (t, i) => e(t, i, n);
const tI = ye.createInterface();
let fv = class {
  constructor(n) {
    this.walletConnector = n;
  }
  provider;
  async connect(n) {
    this.provider = n ? await this.walletConnector.connectTo(n) : await this.walletConnector.connect();
  }
};
fv = ZP([
  eI(0, N0)
], fv);
const nI = new O("CeloNetworks"), yv = [
  {
    name: "celo",
    chainId: 42220
  },
  {
    name: "alfajores",
    chainId: 44787
  },
  {
    name: "baklava",
    chainId: 62320
  }
];
function Vy(n) {
  {
    if (n == null)
      return null;
    if (typeof n == "number") {
      const e = yv.filter((t) => t.chainId === n);
      return e.length ? { name: e[0].name, chainId: e[0].chainId } : {
        name: "unknown",
        chainId: n
      };
    }
    if (typeof n == "string") {
      const e = yv.filter((t) => t.name === n);
      return e.length ? { name: e[0].name, chainId: e[0].chainId } : null;
    }
    if (typeof n.name == "string" && typeof n.chainId == "number") {
      const e = Vy(n.name), t = Vy(n.chainId);
      if (e == null && t == null)
        return {
          name: n.name,
          chainId: n.chainId
        };
      if (e && t && e.name === t.name && e.chainId === t.chainId)
        return e;
    }
    return nI.throwArgumentError("network chainId mismatch", "network", n);
  }
}
const iI = new O("celo/transactions");
function rI(n) {
  const e = Vl(n);
  e.length !== 12 && e.length !== 9 && iI.throwArgumentError("invalid raw transaction", "rawTransaction", n);
  const t = {
    nonce: hu(e[0]).toNumber(),
    gasPrice: hu(e[1]),
    gasLimit: hu(e[2]),
    feeCurrency: Df(e[3]),
    gatewayFeeRecipient: Df(e[4]),
    gatewayFee: hu(e[5]),
    to: Df(e[6]),
    value: hu(e[7]),
    data: e[8],
    chainId: 0
  };
  if (e.length === 9)
    return t;
  try {
    t.v = z.from(e[9]).toNumber();
  } catch (i) {
    return console.log(i), t;
  }
  if (t.r = De(e[10], 32), t.s = De(e[11], 32), z.from(t.r).isZero() && z.from(t.s).isZero())
    t.chainId = t.v, t.v = 0;
  else {
    t.chainId = Math.floor((t.v - 35) / 2), t.chainId < 0 && (t.chainId = 0);
    let i = t.v - 27;
    const r = e.slice(0, 6);
    t.chainId !== 0 && (r.push(H(t.chainId)), r.push("0x"), r.push("0x"), i -= t.chainId * 2 + 8);
    const s = Ie(Ms(r));
    try {
      t.from = Wo(s, {
        r: H(t.r),
        s: H(t.s),
        recoveryParam: i
      });
    } catch (a) {
      console.log(a);
    }
    t.hash = Ie(n);
  }
  return t;
}
function Df(n) {
  if (n !== "0x")
    try {
      return Be(n);
    } catch {
      return n;
    }
}
function hu(n) {
  return n === "0x" ? u0 : z.from(n);
}
const sI = new O("CeloProvider");
class aI extends pP {
  constructor(e, t) {
    super(e, t);
    const i = this.formatter.formats.block;
    i.gasLimit = () => z.from(0), i.nonce = () => "", i.difficulty = () => 0;
    const r = this.formatter.formats.blockWithTransactions;
    r.gasLimit = () => z.from(0), r.nonce = () => "", r.difficulty = () => 0;
  }
  /**
   * Override to parse transaction correctly
   * https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/base-provider.ts
   */
  async sendTransaction(e) {
    await this.getNetwork();
    const t = await Promise.resolve(e), i = H(t), r = rI(t);
    try {
      const s = await this.perform("sendTransaction", {
        signedTransaction: i
      });
      return this._wrapTransaction(r, s);
    } catch (s) {
      throw s.transaction = r, s.transactionHash = r.hash, s;
    }
  }
  /**
   * Override to handle alternative gas currencies
   * getGasPrice in https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/base-provider.ts
   */
  async getGasPrice(e) {
    await this.getNetwork();
    const t = e ? { feeCurrencyAddress: e } : {};
    return z.from(await this.perform("getGasPrice", t));
  }
  /**
   * Override to handle alternative gas currencies
   * prepareRequest in https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts
   */
  prepareRequest(e, t) {
    return e === "getGasPrice" ? ["eth_gasPrice", t.feeCurrencyAddress ? [t.feeCurrencyAddress] : []] : super.prepareRequest(e, t);
  }
  static getNetwork(e) {
    const t = Vy(e ?? "celo");
    return t ?? sI.throwError(`unknown network: ${JSON.stringify(t)}`, O.errors.UNSUPPORTED_OPERATION, {
      operation: "getNetwork",
      value: e
    });
  }
}
O.errors.INSUFFICIENT_FUNDS, O.errors.NONCE_EXPIRED, O.errors.REPLACEMENT_UNDERPRICED;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dT = function(n) {
  const e = [];
  let t = 0;
  for (let i = 0; i < n.length; i++) {
    let r = n.charCodeAt(i);
    r < 128 ? e[t++] = r : r < 2048 ? (e[t++] = r >> 6 | 192, e[t++] = r & 63 | 128) : (r & 64512) === 55296 && i + 1 < n.length && (n.charCodeAt(i + 1) & 64512) === 56320 ? (r = 65536 + ((r & 1023) << 10) + (n.charCodeAt(++i) & 1023), e[t++] = r >> 18 | 240, e[t++] = r >> 12 & 63 | 128, e[t++] = r >> 6 & 63 | 128, e[t++] = r & 63 | 128) : (e[t++] = r >> 12 | 224, e[t++] = r >> 6 & 63 | 128, e[t++] = r & 63 | 128);
  }
  return e;
}, oI = function(n) {
  const e = [];
  let t = 0, i = 0;
  for (; t < n.length; ) {
    const r = n[t++];
    if (r < 128)
      e[i++] = String.fromCharCode(r);
    else if (r > 191 && r < 224) {
      const s = n[t++];
      e[i++] = String.fromCharCode((r & 31) << 6 | s & 63);
    } else if (r > 239 && r < 365) {
      const s = n[t++], a = n[t++], o = n[t++], u = ((r & 7) << 18 | (s & 63) << 12 | (a & 63) << 6 | o & 63) - 65536;
      e[i++] = String.fromCharCode(55296 + (u >> 10)), e[i++] = String.fromCharCode(56320 + (u & 1023));
    } else {
      const s = n[t++], a = n[t++];
      e[i++] = String.fromCharCode((r & 15) << 12 | (s & 63) << 6 | a & 63);
    }
  }
  return e.join("");
}, pT = {
  /**
   * Maps bytes to characters.
   */
  byteToCharMap_: null,
  /**
   * Maps characters to bytes.
   */
  charToByteMap_: null,
  /**
   * Maps bytes to websafe characters.
   * @private
   */
  byteToCharMapWebSafe_: null,
  /**
   * Maps websafe characters to bytes.
   * @private
   */
  charToByteMapWebSafe_: null,
  /**
   * Our default alphabet, shared between
   * ENCODED_VALS and ENCODED_VALS_WEBSAFE
   */
  ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
  /**
   * Our default alphabet. Value 64 (=) is special; it means "nothing."
   */
  get ENCODED_VALS() {
    return this.ENCODED_VALS_BASE + "+/=";
  },
  /**
   * Our websafe alphabet.
   */
  get ENCODED_VALS_WEBSAFE() {
    return this.ENCODED_VALS_BASE + "-_.";
  },
  /**
   * Whether this browser supports the atob and btoa functions. This extension
   * started at Mozilla but is now implemented by many browsers. We use the
   * ASSUME_* variables to avoid pulling in the full useragent detection library
   * but still allowing the standard per-browser compilations.
   *
   */
  HAS_NATIVE_SUPPORT: typeof atob == "function",
  /**
   * Base64-encode an array of bytes.
   *
   * @param input An array of bytes (numbers with
   *     value in [0, 255]) to encode.
   * @param webSafe Boolean indicating we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeByteArray(n, e) {
    if (!Array.isArray(n))
      throw Error("encodeByteArray takes an array as a parameter");
    this.init_();
    const t = e ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, i = [];
    for (let r = 0; r < n.length; r += 3) {
      const s = n[r], a = r + 1 < n.length, o = a ? n[r + 1] : 0, u = r + 2 < n.length, l = u ? n[r + 2] : 0, p = s >> 2, f = (s & 3) << 4 | o >> 4;
      let b = (o & 15) << 2 | l >> 6, A = l & 63;
      u || (A = 64, a || (b = 64)), i.push(t[p], t[f], t[b], t[A]);
    }
    return i.join("");
  },
  /**
   * Base64-encode a string.
   *
   * @param input A string to encode.
   * @param webSafe If true, we should use the
   *     alternative alphabet.
   * @return The base64 encoded string.
   */
  encodeString(n, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? btoa(n) : this.encodeByteArray(dT(n), e);
  },
  /**
   * Base64-decode a string.
   *
   * @param input to decode.
   * @param webSafe True if we should use the
   *     alternative alphabet.
   * @return string representing the decoded value.
   */
  decodeString(n, e) {
    return this.HAS_NATIVE_SUPPORT && !e ? atob(n) : oI(this.decodeStringToByteArray(n, e));
  },
  /**
   * Base64-decode a string.
   *
   * In base-64 decoding, groups of four characters are converted into three
   * bytes.  If the encoder did not apply padding, the input length may not
   * be a multiple of 4.
   *
   * In this case, the last group will have fewer than 4 characters, and
   * padding will be inferred.  If the group has one or two characters, it decodes
   * to one byte.  If the group has three characters, it decodes to two bytes.
   *
   * @param input Input to decode.
   * @param webSafe True if we should use the web-safe alphabet.
   * @return bytes representing the decoded value.
   */
  decodeStringToByteArray(n, e) {
    this.init_();
    const t = e ? this.charToByteMapWebSafe_ : this.charToByteMap_, i = [];
    for (let r = 0; r < n.length; ) {
      const s = t[n.charAt(r++)], o = r < n.length ? t[n.charAt(r)] : 0;
      ++r;
      const l = r < n.length ? t[n.charAt(r)] : 64;
      ++r;
      const f = r < n.length ? t[n.charAt(r)] : 64;
      if (++r, s == null || o == null || l == null || f == null)
        throw new uI();
      const b = s << 2 | o >> 4;
      if (i.push(b), l !== 64) {
        const A = o << 4 & 240 | l >> 2;
        if (i.push(A), f !== 64) {
          const x = l << 6 & 192 | f;
          i.push(x);
        }
      }
    }
    return i;
  },
  /**
   * Lazy static initialization function. Called before
   * accessing any of the static map variables.
   * @private
   */
  init_() {
    if (!this.byteToCharMap_) {
      this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {};
      for (let n = 0; n < this.ENCODED_VALS.length; n++)
        this.byteToCharMap_[n] = this.ENCODED_VALS.charAt(n), this.charToByteMap_[this.byteToCharMap_[n]] = n, this.byteToCharMapWebSafe_[n] = this.ENCODED_VALS_WEBSAFE.charAt(n), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[n]] = n, n >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(n)] = n, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(n)] = n);
    }
  }
};
class uI extends Error {
  constructor() {
    super(...arguments), this.name = "DecodeBase64StringError";
  }
}
const lI = function(n) {
  const e = dT(n);
  return pT.encodeByteArray(e, !0);
}, Md = function(n) {
  return lI(n).replace(/\./g, "");
}, cI = function(n) {
  try {
    return pT.decodeString(n, !0);
  } catch (e) {
    console.error("base64Decode failed: ", e);
  }
  return null;
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function dI() {
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof ba < "u")
    return ba;
  throw new Error("Unable to locate global object.");
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pI = () => dI().__FIREBASE_DEFAULTS__, fI = () => {
  if (typeof Oc > "u" || typeof { ALLUSERSPROFILE: "C:\\ProgramData", APPDATA: "C:\\Users\\viper\\AppData\\Roaming", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_67280_IYMAGMGUJGLXPKLQ", COLOR: "1", COLORTERM: "truecolor", CommonProgramFiles: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "ULTIMATEPC", ComSpec: "C:\\Windows\\system32\\cmd.exe", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\Windows\\notepad.exe", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", GIT_ASKPASS: "c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", HOME: "C:\\Users\\viper", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\viper", INIT_CWD: "C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp", LANG: "en_US.UTF-8", LOCALAPPDATA: "C:\\Users\\viper\\AppData\\Local", LOGONSERVER: "\\\\ULTIMATEPC", NODE: "C:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NODE_EXE: "C:\\Program Files\\nodejs\\\\node.exe", NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", npm_command: "run-script", npm_config_cache: "C:\\Users\\viper\\AppData\\Local\\npm-cache", npm_config_globalconfig: "C:\\Program Files\\nodejs\\etc\\npmrc", npm_config_global_prefix: "C:\\Program Files\\nodejs", npm_config_init_module: "C:\\Users\\viper\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp", npm_config_metrics_registry: "https://registry.npmjs.org/", npm_config_node_gyp: "C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_prefix: "C:\\Program Files\\nodejs", npm_config_shamefully_hoist: "true", npm_config_userconfig: "C:\\Users\\viper\\.npmrc", npm_config_user_agent: "npm/9.5.1 node/v19.8.1 win32 x64 workspaces/false", npm_execpath: "C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build:dev:chart-data-script", npm_lifecycle_script: "vite build --config vite.config-lib.ts --mode development", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_engines_node: ">=16.0.0", npm_package_json: "C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\package.json", npm_package_name: "@kolektivo/dapp", npm_package_version: "1.0.0", NPM_PREFIX_NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", NUMBER_OF_PROCESSORS: "24", NVM_HOME: "C:\\Users\\viper\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", OculusBase: "C:\\Program Files\\Oculus\\", OneDrive: "C:\\Users\\viper\\OneDrive", OneDriveConsumer: "C:\\Users\\viper\\OneDrive", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", Path: "C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\node_modules\\.bin;C:\\Users\\viper\\source\\node_modules\\.bin;C:\\Users\\viper\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Oculus\\Support\\oculus-runtime;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Users\\viper\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Git\\cmd;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\DTS\\Binn\\;C:\\Program Files (x86)\\Microsoft SQL Server\\160\\DTS\\Binn\\;C:\\Program Files\\Azure Data Studio\\bin;C:\\Program Files (x86)\\GnuWin32\\bin;C:\\Program Files\\dotnet\\;C:\\Users\\viper\\.cargo\\bin;C:\\Users\\viper\\AppData\\Local\\Microsoft\\PowerAppsCLI\\;C:\\Users\\viper\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\viper\\.dotnet\\tools;C:\\Users\\viper\\AppData\\Local\\Programs\\Fiddler;C:\\Users\\viper\\.dotnet\\tools", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "Intel64 Family 6 Model 151 Stepping 2, GenuineIntel", PROCESSOR_LEVEL: "6", PROCESSOR_REVISION: "9702", ProgramData: "C:\\ProgramData", ProgramFiles: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROMPT: "$P$G", PSModulePath: "C:\\Users\\viper\\OneDrive\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\PowerShell\\Modules\\", PUBLIC: "C:\\Users\\Public", SystemDrive: "C:", SystemRoot: "C:\\Windows", TEMP: "C:\\Users\\viper\\AppData\\Local\\Temp", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.71.2", TMP: "C:\\Users\\viper\\AppData\\Local\\Temp", USERDOMAIN: "ULTIMATEPC", USERDOMAIN_ROAMINGPROFILE: "ULTIMATEPC", USERNAME: "viper", USERPROFILE: "C:\\Users\\viper", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node", VSCODE_GIT_ASKPASS_MAIN: "c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-860c0d3dad-sock", windir: "C:\\Windows" } > "u")
    return;
  const n = { ALLUSERSPROFILE: "C:\\ProgramData", APPDATA: "C:\\Users\\viper\\AppData\\Roaming", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_67280_IYMAGMGUJGLXPKLQ", COLOR: "1", COLORTERM: "truecolor", CommonProgramFiles: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "ULTIMATEPC", ComSpec: "C:\\Windows\\system32\\cmd.exe", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EDITOR: "C:\\Windows\\notepad.exe", FPS_BROWSER_APP_PROFILE_STRING: "Internet Explorer", FPS_BROWSER_USER_PROFILE_STRING: "Default", GIT_ASKPASS: "c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", HOME: "C:\\Users\\viper", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\viper", INIT_CWD: "C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp", LANG: "en_US.UTF-8", LOCALAPPDATA: "C:\\Users\\viper\\AppData\\Local", LOGONSERVER: "\\\\ULTIMATEPC", NODE: "C:\\Program Files\\nodejs\\node.exe", NODE_ENV: "production", NODE_EXE: "C:\\Program Files\\nodejs\\\\node.exe", NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", npm_command: "run-script", npm_config_cache: "C:\\Users\\viper\\AppData\\Local\\npm-cache", npm_config_globalconfig: "C:\\Program Files\\nodejs\\etc\\npmrc", npm_config_global_prefix: "C:\\Program Files\\nodejs", npm_config_init_module: "C:\\Users\\viper\\.npm-init.js", npm_config_local_prefix: "C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp", npm_config_metrics_registry: "https://registry.npmjs.org/", npm_config_node_gyp: "C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\node-gyp\\bin\\node-gyp.js", npm_config_noproxy: "", npm_config_prefix: "C:\\Program Files\\nodejs", npm_config_shamefully_hoist: "true", npm_config_userconfig: "C:\\Users\\viper\\.npmrc", npm_config_user_agent: "npm/9.5.1 node/v19.8.1 win32 x64 workspaces/false", npm_execpath: "C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\bin\\npm-cli.js", npm_lifecycle_event: "build:dev:chart-data-script", npm_lifecycle_script: "vite build --config vite.config-lib.ts --mode development", npm_node_execpath: "C:\\Program Files\\nodejs\\node.exe", npm_package_engines_node: ">=16.0.0", npm_package_json: "C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\package.json", npm_package_name: "@kolektivo/dapp", npm_package_version: "1.0.0", NPM_PREFIX_NPM_CLI_JS: "C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js", NUMBER_OF_PROCESSORS: "24", NVM_HOME: "C:\\Users\\viper\\AppData\\Roaming\\nvm", NVM_SYMLINK: "C:\\Program Files\\nodejs", OculusBase: "C:\\Program Files\\Oculus\\", OneDrive: "C:\\Users\\viper\\OneDrive", OneDriveConsumer: "C:\\Users\\viper\\OneDrive", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", Path: "C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\dapp\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\Kolektivo\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\CurveLabs\\node_modules\\.bin;C:\\Users\\viper\\source\\repos\\node_modules\\.bin;C:\\Users\\viper\\source\\node_modules\\.bin;C:\\Users\\viper\\node_modules\\.bin;C:\\Users\\node_modules\\.bin;C:\\node_modules\\.bin;C:\\Users\\viper\\AppData\\Roaming\\nvm\\v19.8.1\\node_modules\\npm\\node_modules\\@npmcli\\run-script\\lib\\node-gyp-bin;C:\\Program Files\\Oculus\\Support\\oculus-runtime;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Users\\viper\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files\\Microsoft SQL Server\\Client SDK\\ODBC\\170\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Git\\cmd;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\Binn\\;C:\\Program Files\\Microsoft SQL Server\\150\\DTS\\Binn\\;C:\\Program Files (x86)\\Microsoft SQL Server\\160\\DTS\\Binn\\;C:\\Program Files\\Azure Data Studio\\bin;C:\\Program Files (x86)\\GnuWin32\\bin;C:\\Program Files\\dotnet\\;C:\\Users\\viper\\.cargo\\bin;C:\\Users\\viper\\AppData\\Local\\Microsoft\\PowerAppsCLI\\;C:\\Users\\viper\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\viper\\.dotnet\\tools;C:\\Users\\viper\\AppData\\Local\\Programs\\Fiddler;C:\\Users\\viper\\.dotnet\\tools", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.CPL", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "Intel64 Family 6 Model 151 Stepping 2, GenuineIntel", PROCESSOR_LEVEL: "6", PROCESSOR_REVISION: "9702", ProgramData: "C:\\ProgramData", ProgramFiles: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROMPT: "$P$G", PSModulePath: "C:\\Users\\viper\\OneDrive\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files (x86)\\Microsoft SQL Server\\150\\Tools\\PowerShell\\Modules\\", PUBLIC: "C:\\Users\\Public", SystemDrive: "C:", SystemRoot: "C:\\Windows", TEMP: "C:\\Users\\viper\\AppData\\Local\\Temp", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.71.2", TMP: "C:\\Users\\viper\\AppData\\Local\\Temp", USERDOMAIN: "ULTIMATEPC", USERDOMAIN_ROAMINGPROFILE: "ULTIMATEPC", USERNAME: "viper", USERPROFILE: "C:\\Users\\viper", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "--ms-enable-electron-run-as-node", VSCODE_GIT_ASKPASS_MAIN: "c:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "C:\\Users\\viper\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-860c0d3dad-sock", windir: "C:\\Windows" }.__FIREBASE_DEFAULTS__;
  if (n)
    return JSON.parse(n);
}, yI = () => {
  if (typeof document > "u")
    return;
  let n;
  try {
    n = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
  } catch {
    return;
  }
  const e = n && cI(n[1]);
  return e && JSON.parse(e);
}, fT = () => {
  try {
    return pI() || fI() || yI();
  } catch (n) {
    console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${n}`);
    return;
  }
}, hI = (n) => {
  var e, t;
  return (t = (e = fT()) === null || e === void 0 ? void 0 : e.emulatorHosts) === null || t === void 0 ? void 0 : t[n];
}, mI = (n) => {
  const e = hI(n);
  if (!e)
    return;
  const t = e.lastIndexOf(":");
  if (t <= 0 || t + 1 === e.length)
    throw new Error(`Invalid host ${e} with no separate hostname and port!`);
  const i = parseInt(e.substring(t + 1), 10);
  return e[0] === "[" ? [e.substring(1, t - 1), i] : [e.substring(0, t), i];
}, bI = () => {
  var n;
  return (n = fT()) === null || n === void 0 ? void 0 : n.config;
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class gI {
  constructor() {
    this.reject = () => {
    }, this.resolve = () => {
    }, this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
  /**
   * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
   * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
   * and returns a node-style callback which will resolve or reject the Deferred's promise.
   */
  wrapCallback(e) {
    return (t, i) => {
      t ? this.reject(t) : this.resolve(i), typeof e == "function" && (this.promise.catch(() => {
      }), e.length === 1 ? e(t) : e(t, i));
    };
  }
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function vI(n, e) {
  if (n.uid)
    throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
  const t = {
    alg: "none",
    type: "JWT"
  }, i = e || "demo-project", r = n.iat || 0, s = n.sub || n.user_id;
  if (!s)
    throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
  const a = Object.assign({
    // Set all required fields to decent defaults
    iss: `https://securetoken.google.com/${i}`,
    aud: i,
    iat: r,
    exp: r + 3600,
    auth_time: r,
    sub: s,
    user_id: s,
    firebase: {
      sign_in_provider: "custom",
      identities: {}
    }
  }, n), o = "";
  return [
    Md(JSON.stringify(t)),
    Md(JSON.stringify(a)),
    o
  ].join(".");
}
function xI() {
  try {
    return typeof indexedDB == "object";
  } catch {
    return !1;
  }
}
function TI() {
  return new Promise((n, e) => {
    try {
      let t = !0;
      const i = "validate-browser-context-for-indexeddb-analytics-module", r = self.indexedDB.open(i);
      r.onsuccess = () => {
        r.result.close(), t || self.indexedDB.deleteDatabase(i), n(!0);
      }, r.onupgradeneeded = () => {
        t = !1;
      }, r.onerror = () => {
        var s;
        e(((s = r.error) === null || s === void 0 ? void 0 : s.message) || "");
      };
    } catch (t) {
      e(t);
    }
  });
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wI = "FirebaseError";
class Qo extends Error {
  constructor(e, t, i) {
    super(t), this.code = e, this.customData = i, this.name = wI, Object.setPrototypeOf(this, Qo.prototype), Error.captureStackTrace && Error.captureStackTrace(this, yT.prototype.create);
  }
}
class yT {
  constructor(e, t, i) {
    this.service = e, this.serviceName = t, this.errors = i;
  }
  create(e, ...t) {
    const i = t[0] || {}, r = `${this.service}/${e}`, s = this.errors[e], a = s ? AI(s, i) : "Error", o = `${this.serviceName}: ${a} (${r}).`;
    return new Qo(r, o, i);
  }
}
function AI(n, e) {
  return n.replace(EI, (t, i) => {
    const r = e[i];
    return r != null ? String(r) : `<${i}?>`;
  });
}
const EI = /\{\$([^}]+)}/g;
function Cd(n, e) {
  if (n === e)
    return !0;
  const t = Object.keys(n), i = Object.keys(e);
  for (const r of t) {
    if (!i.includes(r))
      return !1;
    const s = n[r], a = e[r];
    if (hv(s) && hv(a)) {
      if (!Cd(s, a))
        return !1;
    } else if (s !== a)
      return !1;
  }
  for (const r of i)
    if (!t.includes(r))
      return !1;
  return !0;
}
function hv(n) {
  return n !== null && typeof n == "object";
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Wt(n) {
  return n && n._delegate ? n._delegate : n;
}
class fl {
  /**
   *
   * @param name The public service name, e.g. app, auth, firestore, database
   * @param instanceFactory Service factory responsible for creating the public interface
   * @param type whether the service provided by the component is public or private
   */
  constructor(e, t, i) {
    this.name = e, this.instanceFactory = t, this.type = i, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null;
  }
  setInstantiationMode(e) {
    return this.instantiationMode = e, this;
  }
  setMultipleInstances(e) {
    return this.multipleInstances = e, this;
  }
  setServiceProps(e) {
    return this.serviceProps = e, this;
  }
  setInstanceCreatedCallback(e) {
    return this.onInstanceCreated = e, this;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ia = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SI {
  constructor(e, t) {
    this.name = e, this.container = t, this.component = null, this.instances = /* @__PURE__ */ new Map(), this.instancesDeferred = /* @__PURE__ */ new Map(), this.instancesOptions = /* @__PURE__ */ new Map(), this.onInitCallbacks = /* @__PURE__ */ new Map();
  }
  /**
   * @param identifier A provider can provide mulitple instances of a service
   * if this.component.multipleInstances is true.
   */
  get(e) {
    const t = this.normalizeInstanceIdentifier(e);
    if (!this.instancesDeferred.has(t)) {
      const i = new gI();
      if (this.instancesDeferred.set(t, i), this.isInitialized(t) || this.shouldAutoInitialize())
        try {
          const r = this.getOrInitializeService({
            instanceIdentifier: t
          });
          r && i.resolve(r);
        } catch {
        }
    }
    return this.instancesDeferred.get(t).promise;
  }
  getImmediate(e) {
    var t;
    const i = this.normalizeInstanceIdentifier(e?.identifier), r = (t = e?.optional) !== null && t !== void 0 ? t : !1;
    if (this.isInitialized(i) || this.shouldAutoInitialize())
      try {
        return this.getOrInitializeService({
          instanceIdentifier: i
        });
      } catch (s) {
        if (r)
          return null;
        throw s;
      }
    else {
      if (r)
        return null;
      throw Error(`Service ${this.name} is not available`);
    }
  }
  getComponent() {
    return this.component;
  }
  setComponent(e) {
    if (e.name !== this.name)
      throw Error(`Mismatching Component ${e.name} for Provider ${this.name}.`);
    if (this.component)
      throw Error(`Component for ${this.name} has already been provided`);
    if (this.component = e, !!this.shouldAutoInitialize()) {
      if (CI(e))
        try {
          this.getOrInitializeService({ instanceIdentifier: ia });
        } catch {
        }
      for (const [t, i] of this.instancesDeferred.entries()) {
        const r = this.normalizeInstanceIdentifier(t);
        try {
          const s = this.getOrInitializeService({
            instanceIdentifier: r
          });
          i.resolve(s);
        } catch {
        }
      }
    }
  }
  clearInstance(e = ia) {
    this.instancesDeferred.delete(e), this.instancesOptions.delete(e), this.instances.delete(e);
  }
  // app.delete() will call this method on every provider to delete the services
  // TODO: should we mark the provider as deleted?
  async delete() {
    const e = Array.from(this.instances.values());
    await Promise.all([
      ...e.filter((t) => "INTERNAL" in t).map((t) => t.INTERNAL.delete()),
      ...e.filter((t) => "_delete" in t).map((t) => t._delete())
    ]);
  }
  isComponentSet() {
    return this.component != null;
  }
  isInitialized(e = ia) {
    return this.instances.has(e);
  }
  getOptions(e = ia) {
    return this.instancesOptions.get(e) || {};
  }
  initialize(e = {}) {
    const { options: t = {} } = e, i = this.normalizeInstanceIdentifier(e.instanceIdentifier);
    if (this.isInitialized(i))
      throw Error(`${this.name}(${i}) has already been initialized`);
    if (!this.isComponentSet())
      throw Error(`Component ${this.name} has not been registered yet`);
    const r = this.getOrInitializeService({
      instanceIdentifier: i,
      options: t
    });
    for (const [s, a] of this.instancesDeferred.entries()) {
      const o = this.normalizeInstanceIdentifier(s);
      i === o && a.resolve(r);
    }
    return r;
  }
  /**
   *
   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
   *
   * @param identifier An optional instance identifier
   * @returns a function to unregister the callback
   */
  onInit(e, t) {
    var i;
    const r = this.normalizeInstanceIdentifier(t), s = (i = this.onInitCallbacks.get(r)) !== null && i !== void 0 ? i : /* @__PURE__ */ new Set();
    s.add(e), this.onInitCallbacks.set(r, s);
    const a = this.instances.get(r);
    return a && e(a, r), () => {
      s.delete(e);
    };
  }
  /**
   * Invoke onInit callbacks synchronously
   * @param instance the service instance`
   */
  invokeOnInitCallbacks(e, t) {
    const i = this.onInitCallbacks.get(t);
    if (i)
      for (const r of i)
        try {
          r(e, t);
        } catch {
        }
  }
  getOrInitializeService({ instanceIdentifier: e, options: t = {} }) {
    let i = this.instances.get(e);
    if (!i && this.component && (i = this.component.instanceFactory(this.container, {
      instanceIdentifier: MI(e),
      options: t
    }), this.instances.set(e, i), this.instancesOptions.set(e, t), this.invokeOnInitCallbacks(i, e), this.component.onInstanceCreated))
      try {
        this.component.onInstanceCreated(this.container, e, i);
      } catch {
      }
    return i || null;
  }
  normalizeInstanceIdentifier(e = ia) {
    return this.component ? this.component.multipleInstances ? e : ia : e;
  }
  shouldAutoInitialize() {
    return !!this.component && this.component.instantiationMode !== "EXPLICIT";
  }
}
function MI(n) {
  return n === ia ? void 0 : n;
}
function CI(n) {
  return n.instantiationMode === "EAGER";
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _I {
  constructor(e) {
    this.name = e, this.providers = /* @__PURE__ */ new Map();
  }
  /**
   *
   * @param component Component being added
   * @param overwrite When a component with the same name has already been registered,
   * if overwrite is true: overwrite the existing component with the new component and create a new
   * provider with the new component. It can be useful in tests where you want to use different mocks
   * for different tests.
   * if overwrite is false: throw an exception
   */
  addComponent(e) {
    const t = this.getProvider(e.name);
    if (t.isComponentSet())
      throw new Error(`Component ${e.name} has already been registered with ${this.name}`);
    t.setComponent(e);
  }
  addOrOverwriteComponent(e) {
    this.getProvider(e.name).isComponentSet() && this.providers.delete(e.name), this.addComponent(e);
  }
  /**
   * getProvider provides a type safe interface where it can only be called with a field name
   * present in NameServiceMapping interface.
   *
   * Firebase SDKs providing services should extend NameServiceMapping interface to register
   * themselves.
   */
  getProvider(e) {
    if (this.providers.has(e))
      return this.providers.get(e);
    const t = new SI(e, this);
    return this.providers.set(e, t), t;
  }
  getProviders() {
    return Array.from(this.providers.values());
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var $e;
(function(n) {
  n[n.DEBUG = 0] = "DEBUG", n[n.VERBOSE = 1] = "VERBOSE", n[n.INFO = 2] = "INFO", n[n.WARN = 3] = "WARN", n[n.ERROR = 4] = "ERROR", n[n.SILENT = 5] = "SILENT";
})($e || ($e = {}));
const RI = {
  debug: $e.DEBUG,
  verbose: $e.VERBOSE,
  info: $e.INFO,
  warn: $e.WARN,
  error: $e.ERROR,
  silent: $e.SILENT
}, kI = $e.INFO, PI = {
  [$e.DEBUG]: "log",
  [$e.VERBOSE]: "log",
  [$e.INFO]: "info",
  [$e.WARN]: "warn",
  [$e.ERROR]: "error"
}, II = (n, e, ...t) => {
  if (e < n.logLevel)
    return;
  const i = (/* @__PURE__ */ new Date()).toISOString(), r = PI[e];
  if (r)
    console[r](`[${i}]  ${n.name}:`, ...t);
  else
    throw new Error(`Attempted to log a message with an invalid logType (value: ${e})`);
};
class hT {
  /**
   * Gives you an instance of a Logger to capture messages according to
   * Firebase's logging scheme.
   *
   * @param name The name that the logs will be associated with
   */
  constructor(e) {
    this.name = e, this._logLevel = kI, this._logHandler = II, this._userLogHandler = null;
  }
  get logLevel() {
    return this._logLevel;
  }
  set logLevel(e) {
    if (!(e in $e))
      throw new TypeError(`Invalid value "${e}" assigned to \`logLevel\``);
    this._logLevel = e;
  }
  // Workaround for setter/getter having to be the same type.
  setLogLevel(e) {
    this._logLevel = typeof e == "string" ? RI[e] : e;
  }
  get logHandler() {
    return this._logHandler;
  }
  set logHandler(e) {
    if (typeof e != "function")
      throw new TypeError("Value assigned to `logHandler` must be a function");
    this._logHandler = e;
  }
  get userLogHandler() {
    return this._userLogHandler;
  }
  set userLogHandler(e) {
    this._userLogHandler = e;
  }
  /**
   * The functions below are all based on the `console` interface
   */
  debug(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.DEBUG, ...e), this._logHandler(this, $e.DEBUG, ...e);
  }
  log(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.VERBOSE, ...e), this._logHandler(this, $e.VERBOSE, ...e);
  }
  info(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.INFO, ...e), this._logHandler(this, $e.INFO, ...e);
  }
  warn(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.WARN, ...e), this._logHandler(this, $e.WARN, ...e);
  }
  error(...e) {
    this._userLogHandler && this._userLogHandler(this, $e.ERROR, ...e), this._logHandler(this, $e.ERROR, ...e);
  }
}
const OI = (n, e) => e.some((t) => n instanceof t);
let mv, bv;
function BI() {
  return mv || (mv = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function NI() {
  return bv || (bv = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const mT = /* @__PURE__ */ new WeakMap(), jy = /* @__PURE__ */ new WeakMap(), bT = /* @__PURE__ */ new WeakMap(), $f = /* @__PURE__ */ new WeakMap(), L0 = /* @__PURE__ */ new WeakMap();
function DI(n) {
  const e = new Promise((t, i) => {
    const r = () => {
      n.removeEventListener("success", s), n.removeEventListener("error", a);
    }, s = () => {
      t(xs(n.result)), r();
    }, a = () => {
      i(n.error), r();
    };
    n.addEventListener("success", s), n.addEventListener("error", a);
  });
  return e.then((t) => {
    t instanceof IDBCursor && mT.set(t, n);
  }).catch(() => {
  }), L0.set(e, n), e;
}
function $I(n) {
  if (jy.has(n))
    return;
  const e = new Promise((t, i) => {
    const r = () => {
      n.removeEventListener("complete", s), n.removeEventListener("error", a), n.removeEventListener("abort", a);
    }, s = () => {
      t(), r();
    }, a = () => {
      i(n.error || new DOMException("AbortError", "AbortError")), r();
    };
    n.addEventListener("complete", s), n.addEventListener("error", a), n.addEventListener("abort", a);
  });
  jy.set(n, e);
}
let zy = {
  get(n, e, t) {
    if (n instanceof IDBTransaction) {
      if (e === "done")
        return jy.get(n);
      if (e === "objectStoreNames")
        return n.objectStoreNames || bT.get(n);
      if (e === "store")
        return t.objectStoreNames[1] ? void 0 : t.objectStore(t.objectStoreNames[0]);
    }
    return xs(n[e]);
  },
  set(n, e, t) {
    return n[e] = t, !0;
  },
  has(n, e) {
    return n instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in n;
  }
};
function FI(n) {
  zy = n(zy);
}
function LI(n) {
  return n === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...t) {
    const i = n.call(Ff(this), e, ...t);
    return bT.set(i, e.sort ? e.sort() : [e]), xs(i);
  } : NI().includes(n) ? function(...e) {
    return n.apply(Ff(this), e), xs(mT.get(this));
  } : function(...e) {
    return xs(n.apply(Ff(this), e));
  };
}
function UI(n) {
  return typeof n == "function" ? LI(n) : (n instanceof IDBTransaction && $I(n), OI(n, BI()) ? new Proxy(n, zy) : n);
}
function xs(n) {
  if (n instanceof IDBRequest)
    return DI(n);
  if ($f.has(n))
    return $f.get(n);
  const e = UI(n);
  return e !== n && ($f.set(n, e), L0.set(e, n)), e;
}
const Ff = (n) => L0.get(n);
function VI(n, e, { blocked: t, upgrade: i, blocking: r, terminated: s } = {}) {
  const a = indexedDB.open(n, e), o = xs(a);
  return i && a.addEventListener("upgradeneeded", (u) => {
    i(xs(a.result), u.oldVersion, u.newVersion, xs(a.transaction));
  }), t && a.addEventListener("blocked", () => t()), o.then((u) => {
    s && u.addEventListener("close", () => s()), r && u.addEventListener("versionchange", () => r());
  }).catch(() => {
  }), o;
}
const jI = ["get", "getKey", "getAll", "getAllKeys", "count"], zI = ["put", "add", "delete", "clear"], Lf = /* @__PURE__ */ new Map();
function gv(n, e) {
  if (!(n instanceof IDBDatabase && !(e in n) && typeof e == "string"))
    return;
  if (Lf.get(e))
    return Lf.get(e);
  const t = e.replace(/FromIndex$/, ""), i = e !== t, r = zI.includes(t);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(t in (i ? IDBIndex : IDBObjectStore).prototype) || !(r || jI.includes(t))
  )
    return;
  const s = async function(a, ...o) {
    const u = this.transaction(a, r ? "readwrite" : "readonly");
    let l = u.store;
    return i && (l = l.index(o.shift())), (await Promise.all([
      l[t](...o),
      r && u.done
    ]))[0];
  };
  return Lf.set(e, s), s;
}
FI((n) => ({
  ...n,
  get: (e, t, i) => gv(e, t) || n.get(e, t, i),
  has: (e, t) => !!gv(e, t) || n.has(e, t)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GI {
  constructor(e) {
    this.container = e;
  }
  // In initial implementation, this will be called by installations on
  // auth token refresh, and installations will send this string.
  getPlatformInfoString() {
    return this.container.getProviders().map((t) => {
      if (qI(t)) {
        const i = t.getImmediate();
        return `${i.library}/${i.version}`;
      } else
        return null;
    }).filter((t) => t).join(" ");
  }
}
function qI(n) {
  const e = n.getComponent();
  return e?.type === "VERSION";
}
const Gy = "@firebase/app", vv = "0.9.5";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Ta = new hT("@firebase/app"), HI = "@firebase/app-compat", KI = "@firebase/analytics-compat", WI = "@firebase/analytics", JI = "@firebase/app-check-compat", QI = "@firebase/app-check", YI = "@firebase/auth", XI = "@firebase/auth-compat", ZI = "@firebase/database", eO = "@firebase/database-compat", tO = "@firebase/functions", nO = "@firebase/functions-compat", iO = "@firebase/installations", rO = "@firebase/installations-compat", sO = "@firebase/messaging", aO = "@firebase/messaging-compat", oO = "@firebase/performance", uO = "@firebase/performance-compat", lO = "@firebase/remote-config", cO = "@firebase/remote-config-compat", dO = "@firebase/storage", pO = "@firebase/storage-compat", fO = "@firebase/firestore", yO = "@firebase/firestore-compat", hO = "firebase", mO = "9.18.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _d = "[DEFAULT]", bO = {
  [Gy]: "fire-core",
  [HI]: "fire-core-compat",
  [WI]: "fire-analytics",
  [KI]: "fire-analytics-compat",
  [QI]: "fire-app-check",
  [JI]: "fire-app-check-compat",
  [YI]: "fire-auth",
  [XI]: "fire-auth-compat",
  [ZI]: "fire-rtdb",
  [eO]: "fire-rtdb-compat",
  [tO]: "fire-fn",
  [nO]: "fire-fn-compat",
  [iO]: "fire-iid",
  [rO]: "fire-iid-compat",
  [sO]: "fire-fcm",
  [aO]: "fire-fcm-compat",
  [oO]: "fire-perf",
  [uO]: "fire-perf-compat",
  [lO]: "fire-rc",
  [cO]: "fire-rc-compat",
  [dO]: "fire-gcs",
  [pO]: "fire-gcs-compat",
  [fO]: "fire-fst",
  [yO]: "fire-fst-compat",
  "fire-js": "fire-js",
  [hO]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Rd = /* @__PURE__ */ new Map(), qy = /* @__PURE__ */ new Map();
function gO(n, e) {
  try {
    n.container.addComponent(e);
  } catch (t) {
    Ta.debug(`Component ${e.name} failed to register with FirebaseApp ${n.name}`, t);
  }
}
function kd(n) {
  const e = n.name;
  if (qy.has(e))
    return Ta.debug(`There were multiple attempts to register component ${e}.`), !1;
  qy.set(e, n);
  for (const t of Rd.values())
    gO(t, n);
  return !0;
}
function U0(n, e) {
  const t = n.container.getProvider("heartbeat").getImmediate({ optional: !0 });
  return t && t.triggerHeartbeat(), n.container.getProvider(e);
}
function vO(n, e, t = _d) {
  U0(n, e).clearInstance(t);
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const xO = {
  [
    "no-app"
    /* AppError.NO_APP */
  ]: "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()",
  [
    "bad-app-name"
    /* AppError.BAD_APP_NAME */
  ]: "Illegal App name: '{$appName}",
  [
    "duplicate-app"
    /* AppError.DUPLICATE_APP */
  ]: "Firebase App named '{$appName}' already exists with different options or config",
  [
    "app-deleted"
    /* AppError.APP_DELETED */
  ]: "Firebase App named '{$appName}' already deleted",
  [
    "no-options"
    /* AppError.NO_OPTIONS */
  ]: "Need to provide options, when not being deployed to hosting via source.",
  [
    "invalid-app-argument"
    /* AppError.INVALID_APP_ARGUMENT */
  ]: "firebase.{$appName}() takes either no argument or a Firebase App instance.",
  [
    "invalid-log-argument"
    /* AppError.INVALID_LOG_ARGUMENT */
  ]: "First argument to `onLog` must be null or a function.",
  [
    "idb-open"
    /* AppError.IDB_OPEN */
  ]: "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-get"
    /* AppError.IDB_GET */
  ]: "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-set"
    /* AppError.IDB_WRITE */
  ]: "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
  [
    "idb-delete"
    /* AppError.IDB_DELETE */
  ]: "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
}, Ts = new yT("app", "Firebase", xO);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TO {
  constructor(e, t, i) {
    this._isDeleted = !1, this._options = Object.assign({}, e), this._config = Object.assign({}, t), this._name = t.name, this._automaticDataCollectionEnabled = t.automaticDataCollectionEnabled, this._container = i, this.container.addComponent(new fl(
      "app",
      () => this,
      "PUBLIC"
      /* ComponentType.PUBLIC */
    ));
  }
  get automaticDataCollectionEnabled() {
    return this.checkDestroyed(), this._automaticDataCollectionEnabled;
  }
  set automaticDataCollectionEnabled(e) {
    this.checkDestroyed(), this._automaticDataCollectionEnabled = e;
  }
  get name() {
    return this.checkDestroyed(), this._name;
  }
  get options() {
    return this.checkDestroyed(), this._options;
  }
  get config() {
    return this.checkDestroyed(), this._config;
  }
  get container() {
    return this._container;
  }
  get isDeleted() {
    return this._isDeleted;
  }
  set isDeleted(e) {
    this._isDeleted = e;
  }
  /**
   * This function will throw an Error if the App has already been deleted -
   * use before performing API actions on the App.
   */
  checkDestroyed() {
    if (this.isDeleted)
      throw Ts.create("app-deleted", { appName: this._name });
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wO = mO;
function gT(n, e = {}) {
  let t = n;
  typeof e != "object" && (e = { name: e });
  const i = Object.assign({ name: _d, automaticDataCollectionEnabled: !1 }, e), r = i.name;
  if (typeof r != "string" || !r)
    throw Ts.create("bad-app-name", {
      appName: String(r)
    });
  if (t || (t = bI()), !t)
    throw Ts.create(
      "no-options"
      /* AppError.NO_OPTIONS */
    );
  const s = Rd.get(r);
  if (s) {
    if (Cd(t, s.options) && Cd(i, s.config))
      return s;
    throw Ts.create("duplicate-app", { appName: r });
  }
  const a = new _I(r);
  for (const u of qy.values())
    a.addComponent(u);
  const o = new TO(t, i, a);
  return Rd.set(r, o), o;
}
function AO(n = _d) {
  const e = Rd.get(n);
  if (!e && n === _d)
    return gT();
  if (!e)
    throw Ts.create("no-app", { appName: n });
  return e;
}
function bo(n, e, t) {
  var i;
  let r = (i = bO[n]) !== null && i !== void 0 ? i : n;
  t && (r += `-${t}`);
  const s = r.match(/\s|\//), a = e.match(/\s|\//);
  if (s || a) {
    const o = [
      `Unable to register library "${r}" with version "${e}":`
    ];
    s && o.push(`library name "${r}" contains illegal characters (whitespace or "/")`), s && a && o.push("and"), a && o.push(`version name "${e}" contains illegal characters (whitespace or "/")`), Ta.warn(o.join(" "));
    return;
  }
  kd(new fl(
    `${r}-version`,
    () => ({ library: r, version: e }),
    "VERSION"
    /* ComponentType.VERSION */
  ));
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EO = "firebase-heartbeat-database", SO = 1, yl = "firebase-heartbeat-store";
let Uf = null;
function vT() {
  return Uf || (Uf = VI(EO, SO, {
    upgrade: (n, e) => {
      switch (e) {
        case 0:
          n.createObjectStore(yl);
      }
    }
  }).catch((n) => {
    throw Ts.create("idb-open", {
      originalErrorMessage: n.message
    });
  })), Uf;
}
async function MO(n) {
  try {
    return (await vT()).transaction(yl).objectStore(yl).get(xT(n));
  } catch (e) {
    if (e instanceof Qo)
      Ta.warn(e.message);
    else {
      const t = Ts.create("idb-get", {
        originalErrorMessage: e?.message
      });
      Ta.warn(t.message);
    }
  }
}
async function xv(n, e) {
  try {
    const i = (await vT()).transaction(yl, "readwrite");
    return await i.objectStore(yl).put(e, xT(n)), i.done;
  } catch (t) {
    if (t instanceof Qo)
      Ta.warn(t.message);
    else {
      const i = Ts.create("idb-set", {
        originalErrorMessage: t?.message
      });
      Ta.warn(i.message);
    }
  }
}
function xT(n) {
  return `${n.name}!${n.options.appId}`;
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CO = 1024, _O = 30 * 24 * 60 * 60 * 1e3;
class RO {
  constructor(e) {
    this.container = e, this._heartbeatsCache = null;
    const t = this.container.getProvider("app").getImmediate();
    this._storage = new PO(t), this._heartbeatsCachePromise = this._storage.read().then((i) => (this._heartbeatsCache = i, i));
  }
  /**
   * Called to report a heartbeat. The function will generate
   * a HeartbeatsByUserAgent object, update heartbeatsCache, and persist it
   * to IndexedDB.
   * Note that we only store one heartbeat per day. So if a heartbeat for today is
   * already logged, subsequent calls to this function in the same day will be ignored.
   */
  async triggerHeartbeat() {
    const t = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), i = Tv();
    if (this._heartbeatsCache === null && (this._heartbeatsCache = await this._heartbeatsCachePromise), !(this._heartbeatsCache.lastSentHeartbeatDate === i || this._heartbeatsCache.heartbeats.some((r) => r.date === i)))
      return this._heartbeatsCache.heartbeats.push({ date: i, agent: t }), this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter((r) => {
        const s = new Date(r.date).valueOf();
        return Date.now() - s <= _O;
      }), this._storage.overwrite(this._heartbeatsCache);
  }
  /**
   * Returns a base64 encoded string which can be attached to the heartbeat-specific header directly.
   * It also clears all heartbeats from memory as well as in IndexedDB.
   *
   * NOTE: Consuming product SDKs should not send the header if this method
   * returns an empty string.
   */
  async getHeartbeatsHeader() {
    if (this._heartbeatsCache === null && await this._heartbeatsCachePromise, this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0)
      return "";
    const e = Tv(), { heartbeatsToSend: t, unsentEntries: i } = kO(this._heartbeatsCache.heartbeats), r = Md(JSON.stringify({ version: 2, heartbeats: t }));
    return this._heartbeatsCache.lastSentHeartbeatDate = e, i.length > 0 ? (this._heartbeatsCache.heartbeats = i, await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [], this._storage.overwrite(this._heartbeatsCache)), r;
  }
}
function Tv() {
  return (/* @__PURE__ */ new Date()).toISOString().substring(0, 10);
}
function kO(n, e = CO) {
  const t = [];
  let i = n.slice();
  for (const r of n) {
    const s = t.find((a) => a.agent === r.agent);
    if (s) {
      if (s.dates.push(r.date), wv(t) > e) {
        s.dates.pop();
        break;
      }
    } else if (t.push({
      agent: r.agent,
      dates: [r.date]
    }), wv(t) > e) {
      t.pop();
      break;
    }
    i = i.slice(1);
  }
  return {
    heartbeatsToSend: t,
    unsentEntries: i
  };
}
class PO {
  constructor(e) {
    this.app = e, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck();
  }
  async runIndexedDBEnvironmentCheck() {
    return xI() ? TI().then(() => !0).catch(() => !1) : !1;
  }
  /**
   * Read all heartbeats.
   */
  async read() {
    return await this._canUseIndexedDBPromise ? await MO(this.app) || { heartbeats: [] } : { heartbeats: [] };
  }
  // overwrite the storage with the provided heartbeats
  async overwrite(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return xv(this.app, {
        lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : r.lastSentHeartbeatDate,
        heartbeats: e.heartbeats
      });
    } else
      return;
  }
  // add heartbeats
  async add(e) {
    var t;
    if (await this._canUseIndexedDBPromise) {
      const r = await this.read();
      return xv(this.app, {
        lastSentHeartbeatDate: (t = e.lastSentHeartbeatDate) !== null && t !== void 0 ? t : r.lastSentHeartbeatDate,
        heartbeats: [
          ...r.heartbeats,
          ...e.heartbeats
        ]
      });
    } else
      return;
  }
}
function wv(n) {
  return Md(
    // heartbeatsCache wrapper properties
    JSON.stringify({ version: 2, heartbeats: n })
  ).length;
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function IO(n) {
  kd(new fl(
    "platform-logger",
    (e) => new GI(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), kd(new fl(
    "heartbeat",
    (e) => new RO(e),
    "PRIVATE"
    /* ComponentType.PRIVATE */
  )), bo(Gy, vv, n), bo(Gy, vv, "esm2017"), bo("fire-js", "");
}
IO("");
var OO = "firebase", BO = "9.18.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
bo(OO, BO, "app");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $n {
  constructor(e) {
    this.uid = e;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  /**
   * Returns a key representing this user, suitable for inclusion in a
   * dictionary.
   */
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(e) {
    return e.uid === this.uid;
  }
}
$n.UNAUTHENTICATED = new $n(null), // TODO(mikelehen): Look into getting a proper uid-equivalent for
// non-FirebaseAuth providers.
$n.GOOGLE_CREDENTIALS = new $n("google-credentials-uid"), $n.FIRST_PARTY = new $n("first-party-uid"), $n.MOCK_USER = new $n("mock-user");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let Yo = "9.18.0";
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const wa = new hT("@firebase/firestore");
function NO(n) {
  wa.setLogLevel(n);
}
function Aa(n, ...e) {
  if (wa.logLevel <= $e.DEBUG) {
    const t = e.map(V0);
    wa.debug(`Firestore (${Yo}): ${n}`, ...t);
  }
}
function vp(n, ...e) {
  if (wa.logLevel <= $e.ERROR) {
    const t = e.map(V0);
    wa.error(`Firestore (${Yo}): ${n}`, ...t);
  }
}
function TT(n, ...e) {
  if (wa.logLevel <= $e.WARN) {
    const t = e.map(V0);
    wa.warn(`Firestore (${Yo}): ${n}`, ...t);
  }
}
function V0(n) {
  if (typeof n == "string")
    return n;
  try {
    return e = n, JSON.stringify(e);
  } catch {
    return n;
  }
  /**
  * @license
  * Copyright 2020 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  var e;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Ne(n = "Unexpected state") {
  const e = `FIRESTORE (${Yo}) INTERNAL ASSERTION FAILED: ` + n;
  throw vp(e), new Error(e);
}
function Rn(n, e) {
  n || Ne();
}
function Xo(n, e) {
  return n;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Av = "ok", j0 = "cancelled", go = "unknown", se = "invalid-argument", wT = "deadline-exceeded", z0 = "not-found", DO = "already-exists", AT = "permission-denied", Pd = "unauthenticated", ET = "resource-exhausted", Vr = "failed-precondition", G0 = "aborted", ST = "out-of-range", q0 = "unimplemented", MT = "internal", CT = "unavailable", $O = "data-loss";
class Z extends Qo {
  /** @hideconstructor */
  constructor(e, t) {
    super(e, t), this.code = e, this.message = t, // HACK: We write a toString property directly because Error is not a real
    // class and so inheritance does not work correctly. We could alternatively
    // do the same "back-door inheritance" trick that FirebaseError does.
    this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class H0 {
  constructor() {
    this.promise = new Promise((e, t) => {
      this.resolve = e, this.reject = t;
    });
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _T {
  constructor(e, t) {
    this.user = t, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${e}`);
  }
}
class FO {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
    e.enqueueRetryable(() => t($n.UNAUTHENTICATED));
  }
  shutdown() {
  }
}
class LO {
  constructor(e) {
    this.token = e, /**
     * Stores the listener registered with setChangeListener()
     * This isn't actually necessary since the UID never changes, but we use this
     * to verify the listen contract is adhered to in tests.
     */
    this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(e, t) {
    this.changeListener = t, // Fire with initial user.
    e.enqueueRetryable(() => t(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
}
class UO {
  constructor(e) {
    this.auth = null, e.onInit((t) => {
      this.auth = t;
    });
  }
  getToken() {
    return this.auth ? this.auth.getToken().then((e) => e ? (Rn(typeof e.accessToken == "string"), new _T(e.accessToken, new $n(this.auth.getUid()))) : null) : Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
  }
  shutdown() {
  }
}
class VO {
  constructor(e, t, i, r) {
    this.t = e, this.i = t, this.o = i, this.u = r, this.type = "FirstParty", this.user = $n.FIRST_PARTY, this.h = /* @__PURE__ */ new Map();
  }
  /** Gets an authorization token, using a provided factory function, or falling back to First Party GAPI. */
  l() {
    return this.u ? this.u() : (
      // Make sure this really is a Gapi client.
      (Rn(!(typeof this.t != "object" || this.t === null || !this.t.auth || !this.t.auth.getAuthHeaderValueForFirstParty)), this.t.auth.getAuthHeaderValueForFirstParty([]))
    );
  }
  get headers() {
    this.h.set("X-Goog-AuthUser", this.i);
    const e = this.l();
    return e && this.h.set("Authorization", e), this.o && this.h.set("X-Goog-Iam-Authorization-Token", this.o), this.h;
  }
}
class jO {
  constructor(e, t, i, r) {
    this.t = e, this.i = t, this.o = i, this.u = r;
  }
  getToken() {
    return Promise.resolve(new VO(this.t, this.i, this.o, this.u));
  }
  start(e, t) {
    e.enqueueRetryable(() => t($n.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
}
class zO {
  constructor(e) {
    this.value = e, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
}
class GO {
  constructor(e) {
    this.m = e, this.appCheck = null, e.onInit((t) => {
      this.appCheck = t;
    });
  }
  getToken() {
    return this.appCheck ? this.appCheck.getToken().then((e) => e ? (Rn(typeof e.token == "string"), new zO(e.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(e, t) {
  }
  shutdown() {
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class qO {
  /**
   * Constructs a DatabaseInfo using the provided host, databaseId and
   * persistenceKey.
   *
   * @param databaseId - The database to use.
   * @param appId - The Firebase App Id.
   * @param persistenceKey - A unique identifier for this Firestore's local
   * storage (used in conjunction with the databaseId).
   * @param host - The Firestore backend host to connect to.
   * @param ssl - Whether to use SSL when connecting.
   * @param forceLongPolling - Whether to use the forceLongPolling option
   * when using WebChannel as the network transport.
   * @param autoDetectLongPolling - Whether to use the detectBufferingProxy
   * option when using WebChannel as the network transport.
   * @param useFetchStreams Whether to use the Fetch API instead of
   * XMLHTTPRequest
   */
  constructor(e, t, i, r, s, a, o, u) {
    this.databaseId = e, this.appId = t, this.persistenceKey = i, this.host = r, this.ssl = s, this.forceLongPolling = a, this.autoDetectLongPolling = o, this.useFetchStreams = u;
  }
}
class hl {
  constructor(e, t) {
    this.projectId = e, this.database = t || "(default)";
  }
  static empty() {
    return new hl("", "");
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(e) {
    return e instanceof hl && e.projectId === this.projectId && e.database === this.database;
  }
}
class ml {
  constructor(e, t, i) {
    t === void 0 ? t = 0 : t > e.length && Ne(), i === void 0 ? i = e.length - t : i > e.length - t && Ne(), this.segments = e, this.offset = t, this.len = i;
  }
  get length() {
    return this.len;
  }
  isEqual(e) {
    return ml.comparator(this, e) === 0;
  }
  child(e) {
    const t = this.segments.slice(this.offset, this.limit());
    return e instanceof ml ? e.forEach((i) => {
      t.push(i);
    }) : t.push(e), this.construct(t);
  }
  /** The index of one past the last segment of the path. */
  limit() {
    return this.offset + this.length;
  }
  popFirst(e) {
    return e = e === void 0 ? 1 : e, this.construct(this.segments, this.offset + e, this.length - e);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(e) {
    return this.segments[this.offset + e];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(e) {
    if (e.length < this.length)
      return !1;
    for (let t = 0; t < this.length; t++)
      if (this.get(t) !== e.get(t))
        return !1;
    return !0;
  }
  isImmediateParentOf(e) {
    if (this.length + 1 !== e.length)
      return !1;
    for (let t = 0; t < this.length; t++)
      if (this.get(t) !== e.get(t))
        return !1;
    return !0;
  }
  forEach(e) {
    for (let t = this.offset, i = this.limit(); t < i; t++)
      e(this.segments[t]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(e, t) {
    const i = Math.min(e.length, t.length);
    for (let r = 0; r < i; r++) {
      const s = e.get(r), a = t.get(r);
      if (s < a)
        return -1;
      if (s > a)
        return 1;
    }
    return e.length < t.length ? -1 : e.length > t.length ? 1 : 0;
  }
}
class Nt extends ml {
  construct(e, t, i) {
    return new Nt(e, t, i);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Creates a resource path from the given slash-delimited string. If multiple
   * arguments are provided, all components are combined. Leading and trailing
   * slashes from all components are ignored.
   */
  static fromString(...e) {
    const t = [];
    for (const i of e) {
      if (i.indexOf("//") >= 0)
        throw new Z(se, `Invalid segment (${i}). Paths must not contain // in them.`);
      t.push(...i.split("/").filter((r) => r.length > 0));
    }
    return new Nt(t);
  }
  static emptyPath() {
    return new Nt([]);
  }
}
const HO = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
class Zn extends ml {
  construct(e, t, i) {
    return new Zn(e, t, i);
  }
  /**
   * Returns true if the string could be used as a segment in a field path
   * without escaping.
   */
  static isValidIdentifier(e) {
    return HO.test(e);
  }
  canonicalString() {
    return this.toArray().map((e) => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), Zn.isValidIdentifier(e) || (e = "`" + e + "`"), e)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  /**
   * Returns true if this field references the key of a document.
   */
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  /**
   * The field designating the key of a document.
   */
  static keyField() {
    return new Zn(["__name__"]);
  }
  /**
   * Parses a field string from the given server-formatted string.
   *
   * - Splitting the empty string is not allowed (for now at least).
   * - Empty segments within the string (e.g. if there are two consecutive
   *   separators) are not allowed.
   *
   * TODO(b/37244157): we should make this more strict. Right now, it allows
   * non-identifier path components, even if they aren't escaped.
   */
  static fromServerFormat(e) {
    const t = [];
    let i = "", r = 0;
    const s = () => {
      if (i.length === 0)
        throw new Z(se, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      t.push(i), i = "";
    };
    let a = !1;
    for (; r < e.length; ) {
      const o = e[r];
      if (o === "\\") {
        if (r + 1 === e.length)
          throw new Z(se, "Path has trailing escape character: " + e);
        const u = e[r + 1];
        if (u !== "\\" && u !== "." && u !== "`")
          throw new Z(se, "Path has invalid escape sequence: " + e);
        i += u, r += 2;
      } else
        o === "`" ? (a = !a, r++) : o !== "." || a ? (i += o, r++) : (s(), r++);
    }
    if (s(), a)
      throw new Z(se, "Unterminated ` in path: " + e);
    return new Zn(t);
  }
  static emptyPath() {
    return new Zn([]);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Vt {
  constructor(e) {
    this.path = e;
  }
  static fromPath(e) {
    return new Vt(Nt.fromString(e));
  }
  static fromName(e) {
    return new Vt(Nt.fromString(e).popFirst(5));
  }
  static empty() {
    return new Vt(Nt.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  /** Returns true if the document is in the specified collectionId. */
  hasCollectionId(e) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === e;
  }
  /** Returns the collection group (i.e. the name of the parent collection) for this key. */
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  /** Returns the fully qualified path to the parent collection. */
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(e) {
    return e !== null && Nt.comparator(this.path, e.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(e, t) {
    return Nt.comparator(e.path, t.path);
  }
  static isDocumentKey(e) {
    return e.length % 2 == 0;
  }
  /**
   * Creates and returns a new document key with the given segments.
   *
   * @param segments - The segments of the path to the document
   * @returns A new instance of DocumentKey
   */
  static fromSegments(e) {
    return new Vt(new Nt(e.slice()));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function K0(n, e, t) {
  if (!t)
    throw new Z(se, `Function ${n}() cannot be called with an empty ${e}.`);
}
function Ev(n) {
  if (!Vt.isDocumentKey(n))
    throw new Z(se, `Invalid document reference. Document references must have an even number of segments, but ${n} has ${n.length}.`);
}
function Sv(n) {
  if (Vt.isDocumentKey(n))
    throw new Z(se, `Invalid collection reference. Collection references must have an odd number of segments, but ${n} has ${n.length}.`);
}
function xp(n) {
  if (n === void 0)
    return "undefined";
  if (n === null)
    return "null";
  if (typeof n == "string")
    return n.length > 20 && (n = `${n.substring(0, 20)}...`), JSON.stringify(n);
  if (typeof n == "number" || typeof n == "boolean")
    return "" + n;
  if (typeof n == "object") {
    if (n instanceof Array)
      return "an array";
    {
      const e = (
        /** try to get the constructor name for an object. */
        function(t) {
          return t.constructor ? t.constructor.name : null;
        }(n)
      );
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof n == "function" ? "a function" : Ne();
}
function wi(n, e) {
  if ("_delegate" in n && // Unwrap Compat types
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  (n = n._delegate), !(n instanceof e)) {
    if (e.name === n.constructor.name)
      throw new Z(se, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const t = xp(n);
      throw new Z(se, `Expected type '${e.name}', but it was: ${t}`);
    }
  }
  return n;
}
function RT(n, e) {
  if (e <= 0)
    throw new Z(se, `Function ${n}() requires a positive number, but it was: ${e}.`);
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let mc = null;
function KO() {
  return mc === null ? mc = 268435456 + Math.round(2147483648 * Math.random()) : mc++, "0x" + mc.toString(16);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function kT(n) {
  return n == null;
}
function Id(n) {
  return n === 0 && 1 / n == -1 / 0;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WO = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery",
  RunAggregationQuery: "runAggregationQuery"
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Mv, we;
function Cv(n) {
  if (n === void 0)
    return vp("RPC_ERROR", "HTTP error has no status"), go;
  switch (n) {
    case 200:
      return Av;
    case 400:
      return Vr;
    case 401:
      return Pd;
    case 403:
      return AT;
    case 404:
      return z0;
    case 409:
      return G0;
    case 416:
      return ST;
    case 429:
      return ET;
    case 499:
      return j0;
    case 500:
      return go;
    case 501:
      return q0;
    case 503:
      return CT;
    case 504:
      return wT;
    default:
      return n >= 200 && n < 300 ? Av : n >= 400 && n < 500 ? Vr : n >= 500 && n < 600 ? MT : go;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
(we = Mv || (Mv = {}))[we.OK = 0] = "OK", we[we.CANCELLED = 1] = "CANCELLED", we[we.UNKNOWN = 2] = "UNKNOWN", we[we.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", we[we.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", we[we.NOT_FOUND = 5] = "NOT_FOUND", we[we.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", we[we.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", we[we.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", we[we.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", we[we.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", we[we.ABORTED = 10] = "ABORTED", we[we.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", we[we.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", we[we.INTERNAL = 13] = "INTERNAL", we[we.UNAVAILABLE = 14] = "UNAVAILABLE", we[we.DATA_LOSS = 15] = "DATA_LOSS";
class JO extends /**
 * Base class for all Rest-based connections to the backend (WebChannel and
 * HTTP).
 */
class {
  constructor(e) {
    this.databaseInfo = e, this.databaseId = e.databaseId;
    const t = e.ssl ? "https" : "http";
    this.p = t + "://" + e.host, this.g = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  get v() {
    return !1;
  }
  A(e, t, i, r, s) {
    const a = KO(), o = this.I(e, t);
    Aa("RestConnection", `Sending RPC '${e}' ${a}:`, o, i);
    const u = {};
    return this.T(u, r, s), this.R(e, o, u, i).then((l) => (Aa("RestConnection", `Received RPC '${e}' ${a}: `, l), l), (l) => {
      throw TT("RestConnection", `RPC '${e}' ${a} failed with error: `, l, "url: ", o, "request:", i), l;
    });
  }
  P(e, t, i, r, s, a) {
    return this.A(e, t, i, r, s);
  }
  /**
   * Modifies the headers for a request, adding any authorization token if
   * present and any additional headers for the request.
   */
  T(e, t, i) {
    e["X-Goog-Api-Client"] = "gl-js/ fire/" + Yo, // Content-Type: text/plain will avoid preflight requests which might
    // mess with CORS and redirects by proxies. If we add custom headers
    // we will need to change this code to potentially use the $httpOverwrite
    // parameter supported by ESF to avoid triggering preflight requests.
    e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), t && t.headers.forEach((r, s) => e[s] = r), i && i.headers.forEach((r, s) => e[s] = r);
  }
  I(e, t) {
    const i = WO[e];
    return `${this.p}/v1/${t}:${i}`;
  }
} {
  /**
   * @param databaseInfo - The connection info.
   * @param fetchImpl - `fetch` or a Polyfill that implements the fetch API.
   */
  constructor(e, t) {
    super(e), this.V = t;
  }
  $(e, t) {
    throw new Error("Not supported by FetchConnection");
  }
  async R(e, t, i, r) {
    var s;
    const a = JSON.stringify(r);
    let o;
    try {
      o = await this.V(t, {
        method: "POST",
        headers: i,
        body: a
      });
    } catch (u) {
      const l = u;
      throw new Z(Cv(l.status), "Request failed with error: " + l.statusText);
    }
    if (!o.ok) {
      let u = await o.json();
      Array.isArray(u) && (u = u[0]);
      const l = (s = u?.error) === null || s === void 0 ? void 0 : s.message;
      throw new Z(Cv(o.status), `Request failed with error: ${l ?? o.statusText}`);
    }
    return o.json();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const QO = /^[_a-zA-Z][_a-zA-Z0-9]*(?:\.[_a-zA-Z][_a-zA-Z0-9]*)*$/;
class W0 {
  /**
   * @internal
   * @param alias Un-escaped alias representation
   */
  constructor(e) {
    this.alias = e;
  }
  /**
   * Returns true if the string could be used as an alias.
   */
  static D(e) {
    return QO.test(e);
  }
  /**
   * Return an escaped and quoted string representation of the alias.
   */
  canonicalString() {
    let e = this.alias.replace(/\\/g, "\\\\").replace(/`/g, "\\`");
    return W0.D(e) || (e = "`" + e + "`"), e;
  }
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class YO {
  constructor(e, t, i) {
    this.alias = e, this.N = t, this.fieldPath = i;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function XO(n) {
  const e = (
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof self < "u" && (self.crypto || self.msCrypto)
  ), t = new Uint8Array(n);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(t);
  else
    for (let i = 0; i < n; i++)
      t[i] = Math.floor(256 * Math.random());
  return t;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ZO {
  static F() {
    const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", t = Math.floor(256 / e.length) * e.length;
    let i = "";
    for (; i.length < 20; ) {
      const r = XO(40);
      for (let s = 0; s < r.length; ++s)
        i.length < 20 && r[s] < t && (i += e.charAt(r[s] % e.length));
    }
    return i;
  }
}
function Zt(n, e) {
  return n < e ? -1 : n > e ? 1 : 0;
}
function J0(n, e, t) {
  return n.length === e.length && n.every((i, r) => t(i, e[r]));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _v(n) {
  let e = 0;
  for (const t in n)
    Object.prototype.hasOwnProperty.call(n, t) && e++;
  return e;
}
function ql(n, e) {
  for (const t in n)
    Object.prototype.hasOwnProperty.call(n, t) && e(t, n[t]);
}
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class eB extends Error {
  constructor() {
    super(...arguments), this.name = "Base64DecodeError";
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jr {
  constructor(e) {
    this.binaryString = e;
  }
  static fromBase64String(e) {
    const t = function(i) {
      try {
        return atob(i);
      } catch (r) {
        throw r instanceof DOMException ? new eB("Invalid base64 string: " + r) : r;
      }
    }(e);
    return new jr(t);
  }
  static fromUint8Array(e) {
    const t = (
      /**
      * Helper function to convert an Uint8array to a binary string.
      */
      function(i) {
        let r = "";
        for (let s = 0; s < i.length; ++s)
          r += String.fromCharCode(i[s]);
        return r;
      }(e)
    );
    return new jr(t);
  }
  [Symbol.iterator]() {
    let e = 0;
    return {
      next: () => e < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(e++),
        done: !1
      } : {
        value: void 0,
        done: !0
      }
    };
  }
  toBase64() {
    return e = this.binaryString, btoa(e);
    var e;
  }
  toUint8Array() {
    return function(e) {
      const t = new Uint8Array(e.length);
      for (let i = 0; i < e.length; i++)
        t[i] = e.charCodeAt(i);
      return t;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(e) {
    return Zt(this.binaryString, e.binaryString);
  }
  isEqual(e) {
    return this.binaryString === e.binaryString;
  }
}
jr.EMPTY_BYTE_STRING = new jr("");
const tB = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Ea(n) {
  if (Rn(!!n), typeof n == "string") {
    let e = 0;
    const t = tB.exec(n);
    if (Rn(!!t), t[1]) {
      let r = t[1];
      r = (r + "000000000").substr(0, 9), e = Number(r);
    }
    const i = new Date(n);
    return {
      seconds: Math.floor(i.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Gt(n.seconds),
    nanos: Gt(n.nanos)
  };
}
function Gt(n) {
  return typeof n == "number" ? n : typeof n == "string" ? Number(n) : 0;
}
function bl(n) {
  return typeof n == "string" ? jr.fromBase64String(n) : jr.fromUint8Array(n);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class jn {
  /**
   * Creates a new timestamp.
   *
   * @param seconds - The number of seconds of UTC time since Unix epoch
   *     1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
   *     9999-12-31T23:59:59Z inclusive.
   * @param nanoseconds - The non-negative fractions of a second at nanosecond
   *     resolution. Negative second values with fractions must still have
   *     non-negative nanoseconds values that count forward in time. Must be
   *     from 0 to 999,999,999 inclusive.
   */
  constructor(e, t) {
    if (this.seconds = e, this.nanoseconds = t, t < 0)
      throw new Z(se, "Timestamp nanoseconds out of range: " + t);
    if (t >= 1e9)
      throw new Z(se, "Timestamp nanoseconds out of range: " + t);
    if (e < -62135596800)
      throw new Z(se, "Timestamp seconds out of range: " + e);
    if (e >= 253402300800)
      throw new Z(se, "Timestamp seconds out of range: " + e);
  }
  /**
   * Creates a new timestamp with the current date, with millisecond precision.
   *
   * @returns a new timestamp representing the current date.
   */
  static now() {
    return jn.fromMillis(Date.now());
  }
  /**
   * Creates a new timestamp from the given date.
   *
   * @param date - The date to initialize the `Timestamp` from.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     date.
   */
  static fromDate(e) {
    return jn.fromMillis(e.getTime());
  }
  /**
   * Creates a new timestamp from the given number of milliseconds.
   *
   * @param milliseconds - Number of milliseconds since Unix epoch
   *     1970-01-01T00:00:00Z.
   * @returns A new `Timestamp` representing the same point in time as the given
   *     number of milliseconds.
   */
  static fromMillis(e) {
    const t = Math.floor(e / 1e3), i = Math.floor(1e6 * (e - 1e3 * t));
    return new jn(t, i);
  }
  /**
   * Converts a `Timestamp` to a JavaScript `Date` object. This conversion
   * causes a loss of precision since `Date` objects only support millisecond
   * precision.
   *
   * @returns JavaScript `Date` object representing the same point in time as
   *     this `Timestamp`, with millisecond precision.
   */
  toDate() {
    return new Date(this.toMillis());
  }
  /**
   * Converts a `Timestamp` to a numeric timestamp (in milliseconds since
   * epoch). This operation causes a loss of precision.
   *
   * @returns The point in time corresponding to this timestamp, represented as
   *     the number of milliseconds since Unix epoch 1970-01-01T00:00:00Z.
   */
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(e) {
    return this.seconds === e.seconds ? Zt(this.nanoseconds, e.nanoseconds) : Zt(this.seconds, e.seconds);
  }
  /**
   * Returns true if this `Timestamp` is equal to the provided one.
   *
   * @param other - The `Timestamp` to compare against.
   * @returns true if this `Timestamp` is equal to the provided one.
   */
  isEqual(e) {
    return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds;
  }
  /** Returns a textual representation of this `Timestamp`. */
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  /** Returns a JSON-serializable representation of this `Timestamp`. */
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  /**
   * Converts this object to a primitive string, which allows `Timestamp` objects
   * to be compared using the `>`, `<=`, `>=` and `>` operators.
   */
  valueOf() {
    const e = this.seconds - -62135596800;
    return String(e).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function Q0(n) {
  var e, t;
  return ((t = (((e = n?.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || t === void 0 ? void 0 : t.stringValue) === "server_timestamp";
}
function PT(n) {
  const e = n.mapValue.fields.__previous_value__;
  return Q0(e) ? PT(e) : e;
}
function gl(n) {
  const e = Ea(n.mapValue.fields.__local_write_time__.timestampValue);
  return new jn(e.seconds, e.nanos);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const bc = {
  fields: {
    __type__: {
      stringValue: "__max__"
    }
  }
};
function Sa(n) {
  return "nullValue" in n ? 0 : "booleanValue" in n ? 1 : "integerValue" in n || "doubleValue" in n ? 2 : "timestampValue" in n ? 3 : "stringValue" in n ? 5 : "bytesValue" in n ? 6 : "referenceValue" in n ? 7 : "geoPointValue" in n ? 8 : "arrayValue" in n ? 9 : "mapValue" in n ? Q0(n) ? 4 : (
    /** Returns true if the Value represents the canonical {@link #MAX_VALUE} . */
    function(e) {
      return (((e.mapValue || {}).fields || {}).__type__ || {}).stringValue === "__max__";
    }(n) ? 9007199254740991 : 10
  ) : Ne();
}
function Io(n, e) {
  if (n === e)
    return !0;
  const t = Sa(n);
  if (t !== Sa(e))
    return !1;
  switch (t) {
    case 0:
    case 9007199254740991:
      return !0;
    case 1:
      return n.booleanValue === e.booleanValue;
    case 4:
      return gl(n).isEqual(gl(e));
    case 3:
      return function(i, r) {
        if (typeof i.timestampValue == "string" && typeof r.timestampValue == "string" && i.timestampValue.length === r.timestampValue.length)
          return i.timestampValue === r.timestampValue;
        const s = Ea(i.timestampValue), a = Ea(r.timestampValue);
        return s.seconds === a.seconds && s.nanos === a.nanos;
      }(n, e);
    case 5:
      return n.stringValue === e.stringValue;
    case 6:
      return function(i, r) {
        return bl(i.bytesValue).isEqual(bl(r.bytesValue));
      }(n, e);
    case 7:
      return n.referenceValue === e.referenceValue;
    case 8:
      return function(i, r) {
        return Gt(i.geoPointValue.latitude) === Gt(r.geoPointValue.latitude) && Gt(i.geoPointValue.longitude) === Gt(r.geoPointValue.longitude);
      }(n, e);
    case 2:
      return function(i, r) {
        if ("integerValue" in i && "integerValue" in r)
          return Gt(i.integerValue) === Gt(r.integerValue);
        if ("doubleValue" in i && "doubleValue" in r) {
          const s = Gt(i.doubleValue), a = Gt(r.doubleValue);
          return s === a ? Id(s) === Id(a) : isNaN(s) && isNaN(a);
        }
        return !1;
      }(n, e);
    case 9:
      return J0(n.arrayValue.values || [], e.arrayValue.values || [], Io);
    case 10:
      return function(i, r) {
        const s = i.mapValue.fields || {}, a = r.mapValue.fields || {};
        if (_v(s) !== _v(a))
          return !1;
        for (const o in s)
          if (s.hasOwnProperty(o) && (a[o] === void 0 || !Io(s[o], a[o])))
            return !1;
        return !0;
      }(n, e);
    default:
      return Ne();
  }
}
function vl(n, e) {
  return (n.values || []).find((t) => Io(t, e)) !== void 0;
}
function Od(n, e) {
  if (n === e)
    return 0;
  const t = Sa(n), i = Sa(e);
  if (t !== i)
    return Zt(t, i);
  switch (t) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return Zt(n.booleanValue, e.booleanValue);
    case 2:
      return function(r, s) {
        const a = Gt(r.integerValue || r.doubleValue), o = Gt(s.integerValue || s.doubleValue);
        return a < o ? -1 : a > o ? 1 : a === o ? 0 : (
          // one or both are NaN.
          isNaN(a) ? isNaN(o) ? 0 : -1 : 1
        );
      }(n, e);
    case 3:
      return Rv(n.timestampValue, e.timestampValue);
    case 4:
      return Rv(gl(n), gl(e));
    case 5:
      return Zt(n.stringValue, e.stringValue);
    case 6:
      return function(r, s) {
        const a = bl(r), o = bl(s);
        return a.compareTo(o);
      }(n.bytesValue, e.bytesValue);
    case 7:
      return function(r, s) {
        const a = r.split("/"), o = s.split("/");
        for (let u = 0; u < a.length && u < o.length; u++) {
          const l = Zt(a[u], o[u]);
          if (l !== 0)
            return l;
        }
        return Zt(a.length, o.length);
      }(n.referenceValue, e.referenceValue);
    case 8:
      return function(r, s) {
        const a = Zt(Gt(r.latitude), Gt(s.latitude));
        return a !== 0 ? a : Zt(Gt(r.longitude), Gt(s.longitude));
      }(n.geoPointValue, e.geoPointValue);
    case 9:
      return function(r, s) {
        const a = r.values || [], o = s.values || [];
        for (let u = 0; u < a.length && u < o.length; ++u) {
          const l = Od(a[u], o[u]);
          if (l)
            return l;
        }
        return Zt(a.length, o.length);
      }(n.arrayValue, e.arrayValue);
    case 10:
      return function(r, s) {
        if (r === bc && s === bc)
          return 0;
        if (r === bc)
          return 1;
        if (s === bc)
          return -1;
        const a = r.fields || {}, o = Object.keys(a), u = s.fields || {}, l = Object.keys(u);
        o.sort(), l.sort();
        for (let p = 0; p < o.length && p < l.length; ++p) {
          const f = Zt(o[p], l[p]);
          if (f !== 0)
            return f;
          const b = Od(a[o[p]], u[l[p]]);
          if (b !== 0)
            return b;
        }
        return Zt(o.length, l.length);
      }(n.mapValue, e.mapValue);
    default:
      throw Ne();
  }
}
function Rv(n, e) {
  if (typeof n == "string" && typeof e == "string" && n.length === e.length)
    return Zt(n, e);
  const t = Ea(n), i = Ea(e), r = Zt(t.seconds, i.seconds);
  return r !== 0 ? r : Zt(t.nanos, i.nanos);
}
function Bd(n, e) {
  return {
    referenceValue: `projects/${n.projectId}/databases/${n.database}/documents/${e.path.canonicalString()}`
  };
}
function IT(n) {
  return !!n && "arrayValue" in n;
}
function kv(n) {
  return !!n && "nullValue" in n;
}
function Pv(n) {
  return !!n && "doubleValue" in n && isNaN(Number(n.doubleValue));
}
function Vf(n) {
  return !!n && "mapValue" in n;
}
function Du(n) {
  if (n.geoPointValue)
    return {
      geoPointValue: Object.assign({}, n.geoPointValue)
    };
  if (n.timestampValue && typeof n.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, n.timestampValue)
    };
  if (n.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return ql(n.mapValue.fields, (t, i) => e.mapValue.fields[t] = Du(i)), e;
  }
  if (n.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let t = 0; t < (n.arrayValue.values || []).length; ++t)
      e.arrayValue.values[t] = Du(n.arrayValue.values[t]);
    return e;
  }
  return Object.assign({}, n);
}
class Nd {
  constructor(e, t) {
    this.position = e, this.inclusive = t;
  }
}
function Iv(n, e) {
  if (n === null)
    return e === null;
  if (e === null || n.inclusive !== e.inclusive || n.position.length !== e.position.length)
    return !1;
  for (let t = 0; t < n.position.length; t++)
    if (!Io(n.position[t], e.position[t]))
      return !1;
  return !0;
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OT {
}
class ni extends OT {
  constructor(e, t, i) {
    super(), this.field = e, this.op = t, this.value = i;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, t, i) {
    return e.isKeyField() ? t === "in" || t === "not-in" ? this.createKeyFieldInFilter(e, t, i) : new nB(e, t, i) : t === "array-contains" ? new sB(e, i) : t === "in" ? new aB(e, i) : t === "not-in" ? new oB(e, i) : t === "array-contains-any" ? new uB(e, i) : new ni(e, t, i);
  }
  static createKeyFieldInFilter(e, t, i) {
    return t === "in" ? new iB(e, i) : new rB(e, i);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return this.op === "!=" ? t !== null && this.matchesComparison(Od(t, this.value)) : t !== null && Sa(this.value) === Sa(t) && this.matchesComparison(Od(t, this.value));
  }
  matchesComparison(e) {
    switch (this.op) {
      case "<":
        return e < 0;
      case "<=":
        return e <= 0;
      case "==":
        return e === 0;
      case "!=":
        return e !== 0;
      case ">":
        return e > 0;
      case ">=":
        return e >= 0;
      default:
        return Ne();
    }
  }
  isInequality() {
    return [
      "<",
      "<=",
      ">",
      ">=",
      "!=",
      "not-in"
      /* Operator.NOT_IN */
    ].indexOf(this.op) >= 0;
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
  getFirstInequalityField() {
    return this.isInequality() ? this.field : null;
  }
}
class Ma extends OT {
  constructor(e, t) {
    super(), this.filters = e, this.op = t, this.S = null;
  }
  /**
   * Creates a filter based on the provided arguments.
   */
  static create(e, t) {
    return new Ma(e, t);
  }
  matches(e) {
    return this.op === "and" ? this.filters.find((t) => !t.matches(e)) === void 0 : this.filters.find((t) => t.matches(e)) !== void 0;
  }
  getFlattenedFilters() {
    return this.S !== null || (this.S = this.filters.reduce((e, t) => e.concat(t.getFlattenedFilters()), [])), this.S;
  }
  // Returns a mutable copy of `this.filters`
  getFilters() {
    return Object.assign([], this.filters);
  }
  getFirstInequalityField() {
    const e = this.q((t) => t.isInequality());
    return e !== null ? e.field : null;
  }
  // Performs a depth-first search to find and return the first FieldFilter in the composite filter
  // that satisfies the predicate. Returns `null` if none of the FieldFilters satisfy the
  // predicate.
  q(e) {
    for (const t of this.getFlattenedFilters())
      if (e(t))
        return t;
    return null;
  }
}
function BT(n, e) {
  return n instanceof ni ? function(t, i) {
    return i instanceof ni && t.op === i.op && t.field.isEqual(i.field) && Io(t.value, i.value);
  }(n, e) : n instanceof Ma ? function(t, i) {
    return i instanceof Ma && t.op === i.op && t.filters.length === i.filters.length ? t.filters.reduce((r, s, a) => r && BT(s, i.filters[a]), !0) : !1;
  }(n, e) : void Ne();
}
class nB extends ni {
  constructor(e, t, i) {
    super(e, t, i), this.key = Vt.fromName(i.referenceValue);
  }
  matches(e) {
    const t = Vt.comparator(e.key, this.key);
    return this.matchesComparison(t);
  }
}
class iB extends ni {
  constructor(e, t) {
    super(e, "in", t), this.keys = NT("in", t);
  }
  matches(e) {
    return this.keys.some((t) => t.isEqual(e.key));
  }
}
class rB extends ni {
  constructor(e, t) {
    super(e, "not-in", t), this.keys = NT("not-in", t);
  }
  matches(e) {
    return !this.keys.some((t) => t.isEqual(e.key));
  }
}
function NT(n, e) {
  var t;
  return (((t = e.arrayValue) === null || t === void 0 ? void 0 : t.values) || []).map((i) => Vt.fromName(i.referenceValue));
}
class sB extends ni {
  constructor(e, t) {
    super(e, "array-contains", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return IT(t) && vl(t.arrayValue, this.value);
  }
}
class aB extends ni {
  constructor(e, t) {
    super(e, "in", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return t !== null && vl(this.value.arrayValue, t);
  }
}
class oB extends ni {
  constructor(e, t) {
    super(e, "not-in", t);
  }
  matches(e) {
    if (vl(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return !1;
    const t = e.data.field(this.field);
    return t !== null && !vl(this.value.arrayValue, t);
  }
}
class uB extends ni {
  constructor(e, t) {
    super(e, "array-contains-any", t);
  }
  matches(e) {
    const t = e.data.field(this.field);
    return !(!IT(t) || !t.arrayValue.values) && t.arrayValue.values.some((i) => vl(this.value.arrayValue, i));
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $u {
  constructor(e, t = "asc") {
    this.field = e, this.dir = t;
  }
}
function lB(n, e) {
  return n.dir === e.dir && n.field.isEqual(e.field);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Lt {
  constructor(e) {
    this.timestamp = e;
  }
  static fromTimestamp(e) {
    return new Lt(e);
  }
  static min() {
    return new Lt(new jn(0, 0));
  }
  static max() {
    return new Lt(new jn(253402300799, 999999999));
  }
  compareTo(e) {
    return this.timestamp._compareTo(e.timestamp);
  }
  isEqual(e) {
    return this.timestamp.isEqual(e.timestamp);
  }
  /** Returns a number representation of the version for use in spec tests. */
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Dd {
  constructor(e, t) {
    this.comparator = e, this.root = t || sn.EMPTY;
  }
  // Returns a copy of the map, with the specified key/value added or replaced.
  insert(e, t) {
    return new Dd(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, sn.BLACK, null, null));
  }
  // Returns a copy of the map, with the specified key removed.
  remove(e) {
    return new Dd(this.comparator, this.root.remove(e, this.comparator).copy(null, null, sn.BLACK, null, null));
  }
  // Returns the value of the node with the given key, or null.
  get(e) {
    let t = this.root;
    for (; !t.isEmpty(); ) {
      const i = this.comparator(e, t.key);
      if (i === 0)
        return t.value;
      i < 0 ? t = t.left : i > 0 && (t = t.right);
    }
    return null;
  }
  // Returns the index of the element in this sorted map, or -1 if it doesn't
  // exist.
  indexOf(e) {
    let t = 0, i = this.root;
    for (; !i.isEmpty(); ) {
      const r = this.comparator(e, i.key);
      if (r === 0)
        return t + i.left.size;
      r < 0 ? i = i.left : (
        // Count all nodes left of the node plus the node itself
        (t += i.left.size + 1, i = i.right)
      );
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  // Returns the total number of nodes in the map.
  get size() {
    return this.root.size;
  }
  // Returns the minimum key in the map.
  minKey() {
    return this.root.minKey();
  }
  // Returns the maximum key in the map.
  maxKey() {
    return this.root.maxKey();
  }
  // Traverses the map in key order and calls the specified action function
  // for each key/value pair. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.root.inorderTraversal(e);
  }
  forEach(e) {
    this.inorderTraversal((t, i) => (e(t, i), !1));
  }
  toString() {
    const e = [];
    return this.inorderTraversal((t, i) => (e.push(`${t}:${i}`), !1)), `{${e.join(", ")}}`;
  }
  // Traverses the map in reverse key order and calls the specified action
  // function for each key/value pair. If action returns true, traversal is
  // aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.root.reverseTraversal(e);
  }
  // Returns an iterator over the SortedMap.
  getIterator() {
    return new gc(this.root, null, this.comparator, !1);
  }
  getIteratorFrom(e) {
    return new gc(this.root, e, this.comparator, !1);
  }
  getReverseIterator() {
    return new gc(this.root, null, this.comparator, !0);
  }
  getReverseIteratorFrom(e) {
    return new gc(this.root, e, this.comparator, !0);
  }
}
class gc {
  constructor(e, t, i, r) {
    this.isReverse = r, this.nodeStack = [];
    let s = 1;
    for (; !e.isEmpty(); )
      if (s = t ? i(e.key, t) : 1, // flip the comparison if we're going in reverse
      t && r && (s *= -1), s < 0)
        e = this.isReverse ? e.left : e.right;
      else {
        if (s === 0) {
          this.nodeStack.push(e);
          break;
        }
        this.nodeStack.push(e), e = this.isReverse ? e.right : e.left;
      }
  }
  getNext() {
    let e = this.nodeStack.pop();
    const t = {
      key: e.key,
      value: e.value
    };
    if (this.isReverse)
      for (e = e.left; !e.isEmpty(); )
        this.nodeStack.push(e), e = e.right;
    else
      for (e = e.right; !e.isEmpty(); )
        this.nodeStack.push(e), e = e.left;
    return t;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const e = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: e.key,
      value: e.value
    };
  }
}
class sn {
  constructor(e, t, i, r, s) {
    this.key = e, this.value = t, this.color = i ?? sn.RED, this.left = r ?? sn.EMPTY, this.right = s ?? sn.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  // Returns a copy of the current node, optionally replacing pieces of it.
  copy(e, t, i, r, s) {
    return new sn(e ?? this.key, t ?? this.value, i ?? this.color, r ?? this.left, s ?? this.right);
  }
  isEmpty() {
    return !1;
  }
  // Traverses the tree in key order and calls the specified action function
  // for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  inorderTraversal(e) {
    return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e);
  }
  // Traverses the tree in reverse key order and calls the specified action
  // function for each node. If action returns true, traversal is aborted.
  // Returns the first truthy value returned by action, or the last falsey
  // value returned by action.
  reverseTraversal(e) {
    return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e);
  }
  // Returns the minimum node in the tree.
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  // Returns the maximum key in the tree.
  minKey() {
    return this.min().key;
  }
  // Returns the maximum key in the tree.
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  // Returns new tree, with the key/value added.
  insert(e, t, i) {
    let r = this;
    const s = i(e, r.key);
    return r = s < 0 ? r.copy(null, null, null, r.left.insert(e, t, i), null) : s === 0 ? r.copy(null, t, null, null, null) : r.copy(null, null, null, null, r.right.insert(e, t, i)), r.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return sn.EMPTY;
    let e = this;
    return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp();
  }
  // Returns new tree, with the specified item removed.
  remove(e, t) {
    let i, r = this;
    if (t(e, r.key) < 0)
      r.left.isEmpty() || r.left.isRed() || r.left.left.isRed() || (r = r.moveRedLeft()), r = r.copy(null, null, null, r.left.remove(e, t), null);
    else {
      if (r.left.isRed() && (r = r.rotateRight()), r.right.isEmpty() || r.right.isRed() || r.right.left.isRed() || (r = r.moveRedRight()), t(e, r.key) === 0) {
        if (r.right.isEmpty())
          return sn.EMPTY;
        i = r.right.min(), r = r.copy(i.key, i.value, null, null, r.right.removeMin());
      }
      r = r.copy(null, null, null, null, r.right.remove(e, t));
    }
    return r.fixUp();
  }
  isRed() {
    return this.color;
  }
  // Returns new tree after performing any needed rotations.
  fixUp() {
    let e = this;
    return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e;
  }
  moveRedLeft() {
    let e = this.colorFlip();
    return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e;
  }
  moveRedRight() {
    let e = this.colorFlip();
    return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e;
  }
  rotateLeft() {
    const e = this.copy(null, null, sn.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, e, null);
  }
  rotateRight() {
    const e = this.copy(null, null, sn.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, e);
  }
  colorFlip() {
    const e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, e, t);
  }
  // For testing.
  checkMaxDepth() {
    const e = this.check();
    return Math.pow(2, e) <= this.size + 1;
  }
  // In a balanced RB tree, the black-depth (number of black nodes) from root to
  // leaves is equal on both sides.  This function verifies that or asserts.
  check() {
    if (this.isRed() && this.left.isRed() || this.right.isRed())
      throw Ne();
    const e = this.left.check();
    if (e !== this.right.check())
      throw Ne();
    return e + (this.isRed() ? 0 : 1);
  }
}
sn.EMPTY = null, sn.RED = !0, sn.BLACK = !1;
sn.EMPTY = new // Represents an empty node (a leaf node in the Red-Black Tree).
class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw Ne();
  }
  get value() {
    throw Ne();
  }
  get color() {
    throw Ne();
  }
  get left() {
    throw Ne();
  }
  get right() {
    throw Ne();
  }
  // Returns a copy of the current node.
  copy(n, e, t, i, r) {
    return this;
  }
  // Returns a copy of the tree, with the specified key/value added.
  insert(n, e, t) {
    return new sn(n, e);
  }
  // Returns a copy of the tree, with the specified key removed.
  remove(n, e) {
    return this;
  }
  isEmpty() {
    return !0;
  }
  inorderTraversal(n) {
    return !1;
  }
  reverseTraversal(n) {
    return !1;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return !1;
  }
  // For testing.
  checkMaxDepth() {
    return !0;
  }
  check() {
    return 0;
  }
}();
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class $d {
  constructor(e) {
    this.comparator = e, this.data = new Dd(this.comparator);
  }
  has(e) {
    return this.data.get(e) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(e) {
    return this.data.indexOf(e);
  }
  /** Iterates elements in order defined by "comparator" */
  forEach(e) {
    this.data.inorderTraversal((t, i) => (e(t), !1));
  }
  /** Iterates over `elem`s such that: range[0] &lt;= elem &lt; range[1]. */
  forEachInRange(e, t) {
    const i = this.data.getIteratorFrom(e[0]);
    for (; i.hasNext(); ) {
      const r = i.getNext();
      if (this.comparator(r.key, e[1]) >= 0)
        return;
      t(r.key);
    }
  }
  /**
   * Iterates over `elem`s such that: start &lt;= elem until false is returned.
   */
  forEachWhile(e, t) {
    let i;
    for (i = t !== void 0 ? this.data.getIteratorFrom(t) : this.data.getIterator(); i.hasNext(); )
      if (!e(i.getNext().key))
        return;
  }
  /** Finds the least element greater than or equal to `elem`. */
  firstAfterOrEqual(e) {
    const t = this.data.getIteratorFrom(e);
    return t.hasNext() ? t.getNext().key : null;
  }
  getIterator() {
    return new Ov(this.data.getIterator());
  }
  getIteratorFrom(e) {
    return new Ov(this.data.getIteratorFrom(e));
  }
  /** Inserts or updates an element */
  add(e) {
    return this.copy(this.data.remove(e).insert(e, !0));
  }
  /** Deletes an element */
  delete(e) {
    return this.has(e) ? this.copy(this.data.remove(e)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(e) {
    let t = this;
    return t.size < e.size && (t = e, e = this), e.forEach((i) => {
      t = t.add(i);
    }), t;
  }
  isEqual(e) {
    if (!(e instanceof $d) || this.size !== e.size)
      return !1;
    const t = this.data.getIterator(), i = e.data.getIterator();
    for (; t.hasNext(); ) {
      const r = t.getNext().key, s = i.getNext().key;
      if (this.comparator(r, s) !== 0)
        return !1;
    }
    return !0;
  }
  toArray() {
    const e = [];
    return this.forEach((t) => {
      e.push(t);
    }), e;
  }
  toString() {
    const e = [];
    return this.forEach((t) => e.push(t)), "SortedSet(" + e.toString() + ")";
  }
  copy(e) {
    const t = new $d(this.comparator);
    return t.data = e, t;
  }
}
class Ov {
  constructor(e) {
    this.iter = e;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ca {
  constructor(e) {
    this.fields = e, // TODO(dimond): validation of FieldMask
    // Sort the field mask to support `FieldMask.isEqual()` and assert below.
    e.sort(Zn.comparator);
  }
  static empty() {
    return new Ca([]);
  }
  /**
   * Returns a new FieldMask object that is the result of adding all the given
   * fields paths to this field mask.
   */
  unionWith(e) {
    let t = new $d(Zn.comparator);
    for (const i of this.fields)
      t = t.add(i);
    for (const i of e)
      t = t.add(i);
    return new Ca(t.toArray());
  }
  /**
   * Verifies that `fieldPath` is included by at least one field in this field
   * mask.
   *
   * This is an O(n) operation, where `n` is the size of the field mask.
   */
  covers(e) {
    for (const t of this.fields)
      if (t.isPrefixOf(e))
        return !0;
    return !1;
  }
  isEqual(e) {
    return J0(this.fields, e.fields, (t, i) => t.isEqual(i));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Un {
  constructor(e) {
    this.value = e;
  }
  static empty() {
    return new Un({
      mapValue: {}
    });
  }
  /**
   * Returns the value at the given path or null.
   *
   * @param path - the path to search
   * @returns The value at the path or null if the path is not set.
   */
  field(e) {
    if (e.isEmpty())
      return this.value;
    {
      let t = this.value;
      for (let i = 0; i < e.length - 1; ++i)
        if (t = (t.mapValue.fields || {})[e.get(i)], !Vf(t))
          return null;
      return t = (t.mapValue.fields || {})[e.lastSegment()], t || null;
    }
  }
  /**
   * Sets the field to the provided value.
   *
   * @param path - The field path to set.
   * @param value - The value to set.
   */
  set(e, t) {
    this.getFieldsMap(e.popLast())[e.lastSegment()] = Du(t);
  }
  /**
   * Sets the provided fields to the provided values.
   *
   * @param data - A map of fields to values (or null for deletes).
   */
  setAll(e) {
    let t = Zn.emptyPath(), i = {}, r = [];
    e.forEach((a, o) => {
      if (!t.isImmediateParentOf(o)) {
        const u = this.getFieldsMap(t);
        this.applyChanges(u, i, r), i = {}, r = [], t = o.popLast();
      }
      a ? i[o.lastSegment()] = Du(a) : r.push(o.lastSegment());
    });
    const s = this.getFieldsMap(t);
    this.applyChanges(s, i, r);
  }
  /**
   * Removes the field at the specified path. If there is no field at the
   * specified path, nothing is changed.
   *
   * @param path - The field path to remove.
   */
  delete(e) {
    const t = this.field(e.popLast());
    Vf(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()];
  }
  isEqual(e) {
    return Io(this.value, e.value);
  }
  /**
   * Returns the map that contains the leaf element of `path`. If the parent
   * entry does not yet exist, or if it is not a map, a new map will be created.
   */
  getFieldsMap(e) {
    let t = this.value;
    t.mapValue.fields || (t.mapValue = {
      fields: {}
    });
    for (let i = 0; i < e.length; ++i) {
      let r = t.mapValue.fields[e.get(i)];
      Vf(r) && r.mapValue.fields || (r = {
        mapValue: {
          fields: {}
        }
      }, t.mapValue.fields[e.get(i)] = r), t = r;
    }
    return t.mapValue.fields;
  }
  /**
   * Modifies `fieldsMap` by adding, replacing or deleting the specified
   * entries.
   */
  applyChanges(e, t, i) {
    ql(t, (r, s) => e[r] = s);
    for (const r of i)
      delete e[r];
  }
  clone() {
    return new Un(Du(this.value));
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Hi {
  constructor(e, t, i, r, s, a, o) {
    this.key = e, this.documentType = t, this.version = i, this.readTime = r, this.createTime = s, this.data = a, this.documentState = o;
  }
  /**
   * Creates a document with no known version or data, but which can serve as
   * base document for mutations.
   */
  static newInvalidDocument(e) {
    return new Hi(
      e,
      0,
      /* version */
      Lt.min(),
      /* readTime */
      Lt.min(),
      /* createTime */
      Lt.min(),
      Un.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist with the given data at the
   * given version.
   */
  static newFoundDocument(e, t, i, r) {
    return new Hi(
      e,
      1,
      /* version */
      t,
      /* readTime */
      Lt.min(),
      /* createTime */
      i,
      r,
      0
      /* DocumentState.SYNCED */
    );
  }
  /** Creates a new document that is known to not exist at the given version. */
  static newNoDocument(e, t) {
    return new Hi(
      e,
      2,
      /* version */
      t,
      /* readTime */
      Lt.min(),
      /* createTime */
      Lt.min(),
      Un.empty(),
      0
      /* DocumentState.SYNCED */
    );
  }
  /**
   * Creates a new document that is known to exist at the given version but
   * whose data is not known (e.g. a document that was updated without a known
   * base document).
   */
  static newUnknownDocument(e, t) {
    return new Hi(
      e,
      3,
      /* version */
      t,
      /* readTime */
      Lt.min(),
      /* createTime */
      Lt.min(),
      Un.empty(),
      2
      /* DocumentState.HAS_COMMITTED_MUTATIONS */
    );
  }
  /**
   * Changes the document type to indicate that it exists and that its version
   * and data are known.
   */
  convertToFoundDocument(e, t) {
    return !this.createTime.isEqual(Lt.min()) || this.documentType !== 2 && this.documentType !== 0 || (this.createTime = e), this.version = e, this.documentType = 1, this.data = t, this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it doesn't exist at the given
   * version.
   */
  convertToNoDocument(e) {
    return this.version = e, this.documentType = 2, this.data = Un.empty(), this.documentState = 0, this;
  }
  /**
   * Changes the document type to indicate that it exists at a given version but
   * that its data is not known (e.g. a document that was updated without a known
   * base document).
   */
  convertToUnknownDocument(e) {
    return this.version = e, this.documentType = 3, this.data = Un.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = Lt.min(), this;
  }
  setReadTime(e) {
    return this.readTime = e, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(e) {
    return e instanceof Hi && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data);
  }
  mutableCopy() {
    return new Hi(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cB {
  constructor(e, t = null, i = [], r = [], s = null, a = null, o = null) {
    this.path = e, this.collectionGroup = t, this.orderBy = i, this.filters = r, this.limit = s, this.startAt = a, this.endAt = o, this.O = null;
  }
}
function Bv(n, e = null, t = [], i = [], r = null, s = null, a = null) {
  return new cB(n, e, t, i, r, s, a);
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class za {
  /**
   * Initializes a Query with a path and optional additional query constraints.
   * Path must currently be empty if this is a collection group query.
   */
  constructor(e, t = null, i = [], r = [], s = null, a = "F", o = null, u = null) {
    this.path = e, this.collectionGroup = t, this.explicitOrderBy = i, this.filters = r, this.limit = s, this.limitType = a, this.startAt = o, this.endAt = u, this.k = null, // The corresponding `Target` of this `Query` instance.
    this.C = null, this.startAt, this.endAt;
  }
}
function Y0(n) {
  return n.explicitOrderBy.length > 0 ? n.explicitOrderBy[0].field : null;
}
function Tp(n) {
  for (const e of n.filters) {
    const t = e.getFirstInequalityField();
    if (t !== null)
      return t;
  }
  return null;
}
function DT(n) {
  return n.collectionGroup !== null;
}
function Hy(n) {
  const e = Xo(n);
  if (e.k === null) {
    e.k = [];
    const t = Tp(e), i = Y0(e);
    if (t !== null && i === null)
      t.isKeyField() || e.k.push(new $u(t)), e.k.push(new $u(
        Zn.keyField(),
        "asc"
        /* Direction.ASCENDING */
      ));
    else {
      let r = !1;
      for (const s of e.explicitOrderBy)
        e.k.push(s), s.field.isKeyField() && (r = !0);
      if (!r) {
        const s = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.k.push(new $u(Zn.keyField(), s));
      }
    }
  }
  return e.k;
}
function Fd(n) {
  const e = Xo(n);
  if (!e.C)
    if (e.limitType === "F")
      e.C = Bv(e.path, e.collectionGroup, Hy(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t = [];
      for (const s of Hy(e)) {
        const a = s.dir === "desc" ? "asc" : "desc";
        t.push(new $u(s.field, a));
      }
      const i = e.endAt ? new Nd(e.endAt.position, e.endAt.inclusive) : null, r = e.startAt ? new Nd(e.startAt.position, e.startAt.inclusive) : null;
      e.C = Bv(e.path, e.collectionGroup, t, e.filters, e.limit, i, r);
    }
  return e.C;
}
function Ky(n, e) {
  e.getFirstInequalityField(), Tp(n);
  const t = n.filters.concat([e]);
  return new za(n.path, n.collectionGroup, n.explicitOrderBy.slice(), t, n.limit, n.limitType, n.startAt, n.endAt);
}
function dB(n, e) {
  return function(t, i) {
    if (t.limit !== i.limit || t.orderBy.length !== i.orderBy.length)
      return !1;
    for (let r = 0; r < t.orderBy.length; r++)
      if (!lB(t.orderBy[r], i.orderBy[r]))
        return !1;
    if (t.filters.length !== i.filters.length)
      return !1;
    for (let r = 0; r < t.filters.length; r++)
      if (!BT(t.filters[r], i.filters[r]))
        return !1;
    return t.collectionGroup === i.collectionGroup && !!t.path.isEqual(i.path) && !!Iv(t.startAt, i.startAt) && Iv(t.endAt, i.endAt);
  }(Fd(n), Fd(e)) && n.limitType === e.limitType;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function $T(n, e) {
  return function(t) {
    return typeof t == "number" && Number.isInteger(t) && !Id(t) && t <= Number.MAX_SAFE_INTEGER && t >= Number.MIN_SAFE_INTEGER;
  }(e) ? (
    /**
    * Returns an IntegerValue for `value`.
    */
    function(t) {
      return {
        integerValue: "" + t
      };
    }(e)
  ) : function(t, i) {
    if (t.L) {
      if (isNaN(i))
        return {
          doubleValue: "NaN"
        };
      if (i === 1 / 0)
        return {
          doubleValue: "Infinity"
        };
      if (i === -1 / 0)
        return {
          doubleValue: "-Infinity"
        };
    }
    return {
      doubleValue: Id(i) ? "-0" : i
    };
  }(n, e);
}
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class wp {
  constructor() {
    this._ = void 0;
  }
}
class FT extends wp {
}
class LT extends wp {
  constructor(e) {
    super(), this.elements = e;
  }
}
class UT extends wp {
  constructor(e) {
    super(), this.elements = e;
  }
}
class VT extends wp {
  constructor(e, t) {
    super(), this.M = e, this.U = t;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ap {
  constructor(e, t) {
    this.field = e, this.transform = t;
  }
}
class vn {
  constructor(e, t) {
    this.updateTime = e, this.exists = t;
  }
  /** Creates a new empty Precondition. */
  static none() {
    return new vn();
  }
  /** Creates a new Precondition with an exists flag. */
  static exists(e) {
    return new vn(void 0, e);
  }
  /** Creates a new Precondition based on a version a document exists at. */
  static updateTime(e) {
    return new vn(e);
  }
  /** Returns whether this Precondition is empty. */
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(e) {
    return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime);
  }
}
class Ep {
}
class jT extends Ep {
  constructor(e, t, i, r = []) {
    super(), this.key = e, this.value = t, this.precondition = i, this.fieldTransforms = r, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
}
class X0 extends Ep {
  constructor(e, t, i, r, s = []) {
    super(), this.key = e, this.data = t, this.fieldMask = i, this.precondition = r, this.fieldTransforms = s, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
}
class Sp extends Ep {
  constructor(e, t) {
    super(), this.key = e, this.precondition = t, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
class zT extends Ep {
  constructor(e, t) {
    super(), this.key = e, this.precondition = t, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const pB = (() => ({
  asc: "ASCENDING",
  desc: "DESCENDING"
}))(), fB = (() => ({
  "<": "LESS_THAN",
  "<=": "LESS_THAN_OR_EQUAL",
  ">": "GREATER_THAN",
  ">=": "GREATER_THAN_OR_EQUAL",
  "==": "EQUAL",
  "!=": "NOT_EQUAL",
  "array-contains": "ARRAY_CONTAINS",
  in: "IN",
  "not-in": "NOT_IN",
  "array-contains-any": "ARRAY_CONTAINS_ANY"
}))(), yB = (() => ({
  and: "AND",
  or: "OR"
}))();
class hB {
  constructor(e, t) {
    this.databaseId = e, this.L = t;
  }
}
function Wy(n, e) {
  return n.L ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z` : {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function mB(n, e) {
  return n.L ? e.toBase64() : e.toUint8Array();
}
function bB(n, e) {
  return Wy(n, e.toTimestamp());
}
function Fu(n) {
  return Rn(!!n), Lt.fromTimestamp(function(e) {
    const t = Ea(e);
    return new jn(t.seconds, t.nanos);
  }(n));
}
function Z0(n, e) {
  return function(t) {
    return new Nt(["projects", t.projectId, "databases", t.database]);
  }(n).child("documents").child(e).canonicalString();
}
function Ld(n, e) {
  return Z0(n.databaseId, e.path);
}
function Jy(n, e) {
  const t = function(r) {
    const s = Nt.fromString(r);
    return Rn(KT(s)), s;
  }(e);
  if (t.get(1) !== n.databaseId.projectId)
    throw new Z(se, "Tried to deserialize key from different project: " + t.get(1) + " vs " + n.databaseId.projectId);
  if (t.get(3) !== n.databaseId.database)
    throw new Z(se, "Tried to deserialize key from different database: " + t.get(3) + " vs " + n.databaseId.database);
  return new Vt((Rn((i = t).length > 4 && i.get(4) === "documents"), i.popFirst(5)));
  var i;
}
function Nv(n, e) {
  return Z0(n.databaseId, e);
}
function GT(n) {
  return new Nt(["projects", n.databaseId.projectId, "databases", n.databaseId.database]).canonicalString();
}
function Dv(n, e, t) {
  return {
    name: Ld(n, e),
    fields: t.value.mapValue.fields
  };
}
function gB(n, e) {
  return "found" in e ? function(t, i) {
    Rn(!!i.found), i.found.name, i.found.updateTime;
    const r = Jy(t, i.found.name), s = Fu(i.found.updateTime), a = i.found.createTime ? Fu(i.found.createTime) : Lt.min(), o = new Un({
      mapValue: {
        fields: i.found.fields
      }
    });
    return Hi.newFoundDocument(r, s, a, o);
  }(n, e) : "missing" in e ? function(t, i) {
    Rn(!!i.missing), Rn(!!i.readTime);
    const r = Jy(t, i.missing), s = Fu(i.readTime);
    return Hi.newNoDocument(r, s);
  }(n, e) : Ne();
}
function vB(n, e) {
  let t;
  if (e instanceof jT)
    t = {
      update: Dv(n, e.key, e.value)
    };
  else if (e instanceof Sp)
    t = {
      delete: Ld(n, e.key)
    };
  else if (e instanceof X0)
    t = {
      update: Dv(n, e.key, e.data),
      updateMask: AB(e.fieldMask)
    };
  else {
    if (!(e instanceof zT))
      return Ne();
    t = {
      verify: Ld(n, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (t.updateTransforms = e.fieldTransforms.map((i) => function(r, s) {
    const a = s.transform;
    if (a instanceof FT)
      return {
        fieldPath: s.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (a instanceof LT)
      return {
        fieldPath: s.field.canonicalString(),
        appendMissingElements: {
          values: a.elements
        }
      };
    if (a instanceof UT)
      return {
        fieldPath: s.field.canonicalString(),
        removeAllFromArray: {
          values: a.elements
        }
      };
    if (a instanceof VT)
      return {
        fieldPath: s.field.canonicalString(),
        increment: a.U
      };
    throw Ne();
  }(0, i))), e.precondition.isNone || (t.currentDocument = function(i, r) {
    return r.updateTime !== void 0 ? {
      updateTime: bB(i, r.updateTime)
    } : r.exists !== void 0 ? {
      exists: r.exists
    } : Ne();
  }(n, e.precondition)), t;
}
function qT(n, e) {
  const t = {
    structuredQuery: {}
  }, i = e.path;
  e.collectionGroup !== null ? (t.parent = Nv(n, i), t.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: !0
  }]) : (t.parent = Nv(n, i.popLast()), t.structuredQuery.from = [{
    collectionId: i.lastSegment()
  }]);
  const r = function(u) {
    if (u.length !== 0)
      return HT(Ma.create(
        u,
        "and"
        /* CompositeOperator.AND */
      ));
  }(e.filters);
  r && (t.structuredQuery.where = r);
  const s = function(u) {
    if (u.length !== 0)
      return u.map((l) => (
        // visible for testing
        function(p) {
          return {
            field: ps(p.field),
            direction: xB(p.dir)
          };
        }(l)
      ));
  }(e.orderBy);
  s && (t.structuredQuery.orderBy = s);
  const a = function(u, l) {
    return u.L || kT(l) ? l : {
      value: l
    };
  }(n, e.limit);
  var o;
  return a !== null && (t.structuredQuery.limit = a), e.startAt && (t.structuredQuery.startAt = {
    before: (o = e.startAt).inclusive,
    values: o.position
  }), e.endAt && (t.structuredQuery.endAt = function(u) {
    return {
      before: !u.inclusive,
      values: u.position
    };
  }(e.endAt)), t;
}
function xB(n) {
  return pB[n];
}
function TB(n) {
  return fB[n];
}
function wB(n) {
  return yB[n];
}
function ps(n) {
  return {
    fieldPath: n.canonicalString()
  };
}
function HT(n) {
  return n instanceof ni ? function(e) {
    if (e.op === "==") {
      if (Pv(e.value))
        return {
          unaryFilter: {
            field: ps(e.field),
            op: "IS_NAN"
          }
        };
      if (kv(e.value))
        return {
          unaryFilter: {
            field: ps(e.field),
            op: "IS_NULL"
          }
        };
    } else if (e.op === "!=") {
      if (Pv(e.value))
        return {
          unaryFilter: {
            field: ps(e.field),
            op: "IS_NOT_NAN"
          }
        };
      if (kv(e.value))
        return {
          unaryFilter: {
            field: ps(e.field),
            op: "IS_NOT_NULL"
          }
        };
    }
    return {
      fieldFilter: {
        field: ps(e.field),
        op: TB(e.op),
        value: e.value
      }
    };
  }(n) : n instanceof Ma ? function(e) {
    const t = e.getFilters().map((i) => HT(i));
    return t.length === 1 ? t[0] : {
      compositeFilter: {
        op: wB(e.op),
        filters: t
      }
    };
  }(n) : Ne();
}
function AB(n) {
  const e = [];
  return n.fields.forEach((t) => e.push(t.canonicalString())), {
    fieldPaths: e
  };
}
function KT(n) {
  return n.length >= 4 && n.get(0) === "projects" && n.get(2) === "databases";
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function em(n) {
  return new hB(
    n,
    /* useProto3Json= */
    !0
  );
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WT {
  constructor(e, t, i = 1e3, r = 1.5, s = 6e4) {
    this.j = e, this.timerId = t, this.B = i, this.W = r, this.G = s, this.K = 0, this.Y = null, /** The last backoff attempt, as epoch milliseconds. */
    this.H = Date.now(), this.reset();
  }
  /**
   * Resets the backoff delay.
   *
   * The very next backoffAndWait() will have no delay. If it is called again
   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
   * subsequent ones will increase according to the backoffFactor.
   */
  reset() {
    this.K = 0;
  }
  /**
   * Resets the backoff delay to the maximum delay (e.g. for use after a
   * RESOURCE_EXHAUSTED error).
   */
  Z() {
    this.K = this.G;
  }
  /**
   * Returns a promise that resolves after currentDelayMs, and increases the
   * delay for any subsequent attempts. If there was a pending backoff operation
   * already, it will be canceled.
   */
  J(e) {
    this.cancel();
    const t = Math.floor(this.K + this.X()), i = Math.max(0, Date.now() - this.H), r = Math.max(0, t - i);
    r > 0 && Aa("ExponentialBackoff", `Backing off for ${r} ms (base delay: ${this.K} ms, delay with jitter: ${t} ms, last attempt: ${i} ms ago)`), this.Y = this.j.enqueueAfterDelay(this.timerId, r, () => (this.H = Date.now(), e())), // Apply backoff factor to determine next delay and ensure it is within
    // bounds.
    this.K *= this.W, this.K < this.B && (this.K = this.B), this.K > this.G && (this.K = this.G);
  }
  tt() {
    this.Y !== null && (this.Y.skipDelay(), this.Y = null);
  }
  cancel() {
    this.Y !== null && (this.Y.cancel(), this.Y = null);
  }
  /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
  X() {
    return (Math.random() - 0.5) * this.K;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EB extends class {
} {
  constructor(e, t, i, r) {
    super(), this.authCredentials = e, this.appCheckCredentials = t, this.connection = i, this.M = r, this.et = !1;
  }
  nt() {
    if (this.et)
      throw new Z(Vr, "The client has already been terminated.");
  }
  /** Invokes the provided RPC with auth and AppCheck tokens. */
  A(e, t, i) {
    return this.nt(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([r, s]) => this.connection.A(e, t, i, r, s)).catch((r) => {
      throw r.name === "FirebaseError" ? (r.code === Pd && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), r) : new Z(go, r.toString());
    });
  }
  /** Invokes the provided RPC with streamed results with auth and AppCheck tokens. */
  P(e, t, i, r) {
    return this.nt(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, a]) => this.connection.P(e, t, i, s, a, r)).catch((s) => {
      throw s.name === "FirebaseError" ? (s.code === Pd && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), s) : new Z(go, s.toString());
    });
  }
  terminate() {
    this.et = !0;
  }
}
async function Zo(n, e) {
  const t = Xo(n), i = GT(t.M) + "/documents", r = {
    writes: e.map((s) => vB(t.M, s))
  };
  await t.A("Commit", i, r);
}
async function JT(n, e) {
  const t = Xo(n), i = GT(t.M) + "/documents", r = {
    documents: e.map((u) => Ld(t.M, u))
  }, s = await t.P("BatchGetDocuments", i, r, e.length), a = /* @__PURE__ */ new Map();
  s.forEach((u) => {
    const l = gB(t.M, u);
    a.set(l.key.toString(), l);
  });
  const o = [];
  return e.forEach((u) => {
    const l = a.get(u.toString());
    Rn(!!l), o.push(l);
  }), o;
}
async function SB(n, e) {
  const t = Xo(n), i = qT(t.M, Fd(e));
  return (await t.P("RunQuery", i.parent, {
    structuredQuery: i.structuredQuery
  })).filter((r) => !!r.document).map((r) => function(s, a, o) {
    const u = Jy(s, a.name), l = Fu(a.updateTime), p = a.createTime ? Fu(a.createTime) : Lt.min(), f = new Un({
      mapValue: {
        fields: a.fields
      }
    }), b = Hi.newFoundDocument(u, l, p, f);
    return o && b.setHasCommittedMutations(), o ? b.setHasCommittedMutations() : b;
  }(t.M, r.document, void 0));
}
async function MB(n, e, t) {
  const i = Xo(n), r = function(l, p, f) {
    const b = qT(l, p), A = [];
    return f.forEach((x) => {
      x.N === "count" ? A.push({
        alias: x.alias.canonicalString(),
        count: {}
      }) : x.N === "avg" ? A.push({
        alias: x.alias.canonicalString(),
        avg: {
          field: ps(x.fieldPath)
        }
      }) : x.N === "sum" && A.push({
        alias: x.alias.canonicalString(),
        sum: {
          field: ps(x.fieldPath)
        }
      });
    }), {
      structuredAggregationQuery: {
        aggregations: A,
        structuredQuery: b.structuredQuery
      },
      parent: b.parent
    };
  }(i.M, Fd(e), t), s = r.parent;
  i.connection.v || delete r.parent;
  const a = (await i.P(
    "RunAggregationQuery",
    s,
    r,
    /*expectedResponseCount=*/
    1
  )).filter((l) => !!l.result);
  return Rn(a.length === 1), (o = a[0]).result, o.result.aggregateFields, new Un({
    mapValue: {
      fields: (u = o.result) === null || u === void 0 ? void 0 : u.aggregateFields
    }
  });
  var o, u;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const Lu = /* @__PURE__ */ new Map();
function Qr(n) {
  if (n._terminated)
    throw new Z(Vr, "The client has already been terminated.");
  if (!Lu.has(n)) {
    Aa("ComponentProvider", "Initializing Datastore");
    const s = function(u) {
      return new JO(u, fetch.bind(null));
    }((e = n._databaseId, t = n.app.options.appId || "", i = n._persistenceKey, r = n._freezeSettings(), new qO(e, t, i, r.host, r.ssl, r.experimentalForceLongPolling, r.experimentalAutoDetectLongPolling, r.useFetchStreams))), a = em(n._databaseId), o = function(u, l, p, f) {
      return new EB(u, l, p, f);
    }(n._authCredentials, n._appCheckCredentials, s, a);
    Lu.set(n, o);
  }
  var e, t, i, r;
  /**
  * @license
  * Copyright 2018 Google LLC
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
  *   http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
  return Lu.get(n);
}
class $v {
  constructor(e) {
    var t;
    if (e.host === void 0) {
      if (e.ssl !== void 0)
        throw new Z(se, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = !0;
    } else
      this.host = e.host, this.ssl = (t = e.ssl) === null || t === void 0 || t;
    if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, e.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (e.cacheSizeBytes !== -1 && e.cacheSizeBytes < 1048576)
        throw new Z(se, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = e.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!e.experimentalAutoDetectLongPolling, this.useFetchStreams = !!e.useFetchStreams, function(i, r, s, a) {
      if (r === !0 && a === !0)
        throw new Z(se, `${i} and ${s} cannot be used together.`);
    }("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling);
  }
  isEqual(e) {
    return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class yr {
  /** @hideconstructor */
  constructor(e, t, i, r) {
    this._authCredentials = e, this._appCheckCredentials = t, this._databaseId = i, this._app = r, /**
     * Whether it's a Firestore or Firestore Lite instance.
     */
    this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new $v({}), this._settingsFrozen = !1;
  }
  /**
   * The {@link @firebase/app#FirebaseApp} associated with this `Firestore` service
   * instance.
   */
  get app() {
    if (!this._app)
      throw new Z(Vr, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(e) {
    if (this._settingsFrozen)
      throw new Z(Vr, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new $v(e), e.credentials !== void 0 && (this._authCredentials = function(t) {
      if (!t)
        return new FO();
      switch (t.type) {
        case "gapi":
          const i = t.client;
          return new jO(i, t.sessionIndex || "0", t.iamToken || null, t.authTokenFactory || null);
        case "provider":
          return t.client;
        default:
          throw new Z(se, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(e.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = !0, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  /** Returns a JSON-serializable representation of this `Firestore` instance. */
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  /**
   * Terminates all components used by this client. Subclasses can override
   * this method to clean up their own dependencies, but must also call this
   * method.
   *
   * Only ever called once.
   */
  _terminate() {
    return function(e) {
      const t = Lu.get(e);
      t && (Aa("ComponentProvider", "Removing Datastore"), Lu.delete(e), t.terminate());
    }(this), Promise.resolve();
  }
}
function CB(n, e, t) {
  t || (t = "(default)");
  const i = U0(n, "firestore/lite");
  if (i.isInitialized(t))
    throw new Z(Vr, "Firestore can only be initialized once per app.");
  return i.initialize({
    options: e,
    instanceIdentifier: t
  });
}
function _B(n, e) {
  const t = typeof n == "object" ? n : AO(), i = typeof n == "string" ? n : e || "(default)", r = U0(t, "firestore/lite").getImmediate({
    identifier: i
  });
  if (!r._initialized) {
    const s = mI("firestore");
    s && QT(r, ...s);
  }
  return r;
}
function QT(n, e, t, i = {}) {
  var r;
  const s = (n = wi(n, yr))._getSettings();
  if (s.host !== "firestore.googleapis.com" && s.host !== e && TT("Host has been set in both settings() and useEmulator(), emulator host will be used"), n._setSettings(Object.assign(Object.assign({}, s), {
    host: `${e}:${t}`,
    ssl: !1
  })), i.mockUserToken) {
    let a, o;
    if (typeof i.mockUserToken == "string")
      a = i.mockUserToken, o = $n.MOCK_USER;
    else {
      a = vI(i.mockUserToken, (r = n._app) === null || r === void 0 ? void 0 : r.options.projectId);
      const u = i.mockUserToken.sub || i.mockUserToken.user_id;
      if (!u)
        throw new Z(se, "mockUserToken must contain 'sub' or 'user_id' field!");
      o = new $n(u);
    }
    n._authCredentials = new LO(new _T(a, o));
  }
}
function RB(n) {
  return n = wi(n, yr), vO(n.app, "firestore/lite"), n._delete();
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Oo {
  /**
   * Create a new AggregateField<T>
   * @param _aggregateType Specifies the type of aggregation operation to perform.
   * @param _internalFieldPath Optionally specifies the field that is aggregated.
   * @internal
   */
  constructor(e = "count", t) {
    this._aggregateType = e, this._internalFieldPath = t, /** A type string to uniquely identify instances of this class. */
    this.type = "AggregateField";
  }
}
class YT {
  /** @hideconstructor */
  constructor(e, t, i) {
    this._userDataWriter = t, this._data = i, /** A type string to uniquely identify instances of this class. */
    this.type = "AggregateQuerySnapshot", this.query = e;
  }
  /**
   * Returns the results of the aggregations performed over the underlying
   * query.
   *
   * The keys of the returned object will be the same as those of the
   * `AggregateSpec` object specified to the aggregation method, and the values
   * will be the corresponding aggregation result.
   *
   * @returns The results of the aggregations performed over the underlying
   * query.
   */
  data() {
    return this._userDataWriter.convertValue(this._data.value);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ht {
  /** @hideconstructor */
  constructor(e, t, i) {
    this.converter = t, this._key = i, /** The type of this Firestore reference. */
    this.type = "document", this.firestore = e;
  }
  get _path() {
    return this._key.path;
  }
  /**
   * The document's identifier within its collection.
   */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced document (relative
   * to the root of the database).
   */
  get path() {
    return this._key.path.canonicalString();
  }
  /**
   * The collection this `DocumentReference` belongs to.
   */
  get parent() {
    return new yi(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(e) {
    return new Ht(this.firestore, e, this._key);
  }
}
class qn {
  // This is the lite version of the Query class in the main SDK.
  /** @hideconstructor protected */
  constructor(e, t, i) {
    this.converter = t, this._query = i, /** The type of this Firestore reference. */
    this.type = "query", this.firestore = e;
  }
  withConverter(e) {
    return new qn(this.firestore, e, this._query);
  }
}
class yi extends qn {
  /** @hideconstructor */
  constructor(e, t, i) {
    super(e, t, new za(i)), this._path = i, /** The type of this Firestore reference. */
    this.type = "collection";
  }
  /** The collection's identifier. */
  get id() {
    return this._query.path.lastSegment();
  }
  /**
   * A string representing the path of the referenced collection (relative
   * to the root of the database).
   */
  get path() {
    return this._query.path.canonicalString();
  }
  /**
   * A reference to the containing `DocumentReference` if this is a
   * subcollection. If this isn't a subcollection, the reference is null.
   */
  get parent() {
    const e = this._path.popLast();
    return e.isEmpty() ? null : new Ht(
      this.firestore,
      /* converter= */
      null,
      new Vt(e)
    );
  }
  withConverter(e) {
    return new yi(this.firestore, e, this._path);
  }
}
function Qy(n, e, ...t) {
  if (n = Wt(n), K0("collection", "path", e), n instanceof yr) {
    const i = Nt.fromString(e, ...t);
    return Sv(i), new yi(
      n,
      /* converter= */
      null,
      i
    );
  }
  {
    if (!(n instanceof Ht || n instanceof yi))
      throw new Z(se, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const i = n._path.child(Nt.fromString(e, ...t));
    return Sv(i), new yi(
      n.firestore,
      /* converter= */
      null,
      i
    );
  }
}
function kB(n, e) {
  if (n = wi(n, yr), K0("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new Z(se, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new qn(
    n,
    /* converter= */
    null,
    function(t) {
      return new za(Nt.emptyPath(), t);
    }(e)
  );
}
function Uu(n, e, ...t) {
  if (n = Wt(n), // We allow omission of 'pathString' but explicitly prohibit passing in both
  // 'undefined' and 'null'.
  arguments.length === 1 && (e = ZO.F()), K0("doc", "path", e), n instanceof yr) {
    const i = Nt.fromString(e, ...t);
    return Ev(i), new Ht(
      n,
      /* converter= */
      null,
      new Vt(i)
    );
  }
  {
    if (!(n instanceof Ht || n instanceof yi))
      throw new Z(se, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const i = n._path.child(Nt.fromString(e, ...t));
    return Ev(i), new Ht(n.firestore, n instanceof yi ? n.converter : null, new Vt(i));
  }
}
function PB(n, e) {
  return n = Wt(n), e = Wt(e), (n instanceof Ht || n instanceof yi) && (e instanceof Ht || e instanceof yi) && n.firestore === e.firestore && n.path === e.path && n.converter === e.converter;
}
function tm(n, e) {
  return n = Wt(n), e = Wt(e), n instanceof qn && e instanceof qn && n.firestore === e.firestore && dB(n._query, e._query) && n.converter === e.converter;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _a {
  /** @hideconstructor */
  constructor(e) {
    this._byteString = e;
  }
  /**
   * Creates a new `Bytes` object from the given Base64 string, converting it to
   * bytes.
   *
   * @param base64 - The Base64 string used to create the `Bytes` object.
   */
  static fromBase64String(e) {
    try {
      return new _a(jr.fromBase64String(e));
    } catch (t) {
      throw new Z(se, "Failed to construct data from Base64 string: " + t);
    }
  }
  /**
   * Creates a new `Bytes` object from the given Uint8Array.
   *
   * @param array - The Uint8Array used to create the `Bytes` object.
   */
  static fromUint8Array(e) {
    return new _a(jr.fromUint8Array(e));
  }
  /**
   * Returns the underlying bytes as a Base64-encoded string.
   *
   * @returns The Base64-encoded string created from the `Bytes` object.
   */
  toBase64() {
    return this._byteString.toBase64();
  }
  /**
   * Returns the underlying bytes in a new `Uint8Array`.
   *
   * @returns The Uint8Array created from the `Bytes` object.
   */
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  /**
   * Returns a string representation of the `Bytes` object.
   *
   * @returns A string representation of the `Bytes` object.
   */
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  /**
   * Returns true if this `Bytes` object is equal to the provided one.
   *
   * @param other - The `Bytes` object to compare against.
   * @returns true if this `Bytes` object is equal to the provided one.
   */
  isEqual(e) {
    return this._byteString.isEqual(e._byteString);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Bs {
  /**
   * Creates a `FieldPath` from the provided field names. If more than one field
   * name is provided, the path will point to a nested field in a document.
   *
   * @param fieldNames - A list of field names.
   */
  constructor(...e) {
    for (let t = 0; t < e.length; ++t)
      if (e[t].length === 0)
        throw new Z(se, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new Zn(e);
  }
  /**
   * Returns true if this `FieldPath` is equal to the provided one.
   *
   * @param other - The `FieldPath` to compare against.
   * @returns true if this `FieldPath` is equal to the provided one.
   */
  isEqual(e) {
    return this._internalPath.isEqual(e._internalPath);
  }
}
function IB() {
  return new Bs("__name__");
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Ns {
  /**
   * @param _methodName - The public API endpoint that returns this class.
   * @hideconstructor
   */
  constructor(e) {
    this._methodName = e;
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Mp {
  /**
   * Creates a new immutable `GeoPoint` object with the provided latitude and
   * longitude values.
   * @param latitude - The latitude as number between -90 and 90.
   * @param longitude - The longitude as number between -180 and 180.
   */
  constructor(e, t) {
    if (!isFinite(e) || e < -90 || e > 90)
      throw new Z(se, "Latitude must be a number between -90 and 90, but was: " + e);
    if (!isFinite(t) || t < -180 || t > 180)
      throw new Z(se, "Longitude must be a number between -180 and 180, but was: " + t);
    this._lat = e, this._long = t;
  }
  /**
   * The latitude of this `GeoPoint` instance.
   */
  get latitude() {
    return this._lat;
  }
  /**
   * The longitude of this `GeoPoint` instance.
   */
  get longitude() {
    return this._long;
  }
  /**
   * Returns true if this `GeoPoint` is equal to the provided one.
   *
   * @param other - The `GeoPoint` to compare against.
   * @returns true if this `GeoPoint` is equal to the provided one.
   */
  isEqual(e) {
    return this._lat === e._lat && this._long === e._long;
  }
  /** Returns a JSON-serializable representation of this GeoPoint. */
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  /**
   * Actually private to JS consumers of our API, so this function is prefixed
   * with an underscore.
   */
  _compareTo(e) {
    return Zt(this._lat, e._lat) || Zt(this._long, e._long);
  }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const OB = /^__.*__$/;
class BB {
  constructor(e, t, i) {
    this.data = e, this.fieldMask = t, this.fieldTransforms = i;
  }
  toMutation(e, t) {
    return this.fieldMask !== null ? new X0(e, this.data, this.fieldMask, t, this.fieldTransforms) : new jT(e, this.data, t, this.fieldTransforms);
  }
}
class XT {
  constructor(e, t, i) {
    this.data = e, this.fieldMask = t, this.fieldTransforms = i;
  }
  toMutation(e, t) {
    return new X0(e, this.data, this.fieldMask, t, this.fieldTransforms);
  }
}
function ZT(n) {
  switch (n) {
    case 0:
    case 2:
    case 1:
      return !0;
    case 3:
    case 4:
      return !1;
    default:
      throw Ne();
  }
}
class Cp {
  /**
   * Initializes a ParseContext with the given source and path.
   *
   * @param settings - The settings for the parser.
   * @param databaseId - The database ID of the Firestore instance.
   * @param serializer - The serializer to use to generate the Value proto.
   * @param ignoreUndefinedProperties - Whether to ignore undefined properties
   * rather than throw.
   * @param fieldTransforms - A mutable list of field transforms encountered
   * while parsing the data.
   * @param fieldMask - A mutable list of field paths encountered while parsing
   * the data.
   *
   * TODO(b/34871131): We don't support array paths right now, so path can be
   * null to indicate the context represents any location within an array (in
   * which case certain features will not work and errors will be somewhat
   * compromised).
   */
  constructor(e, t, i, r, s, a) {
    this.settings = e, this.databaseId = t, this.M = i, this.ignoreUndefinedProperties = r, // Minor hack: If fieldTransforms is undefined, we assume this is an
    // external call and we need to validate the entire path.
    s === void 0 && this.rt(), this.fieldTransforms = s || [], this.fieldMask = a || [];
  }
  get path() {
    return this.settings.path;
  }
  get st() {
    return this.settings.st;
  }
  /** Returns a new context with the specified settings overwritten. */
  it(e) {
    return new Cp(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.M, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  ot(e) {
    var t;
    const i = (t = this.path) === null || t === void 0 ? void 0 : t.child(e), r = this.it({
      path: i,
      ut: !1
    });
    return r.ct(e), r;
  }
  at(e) {
    var t;
    const i = (t = this.path) === null || t === void 0 ? void 0 : t.child(e), r = this.it({
      path: i,
      ut: !1
    });
    return r.rt(), r;
  }
  ht(e) {
    return this.it({
      path: void 0,
      ut: !0
    });
  }
  lt(e) {
    return Ud(e, this.settings.methodName, this.settings.ft || !1, this.path, this.settings.dt);
  }
  /** Returns 'true' if 'fieldPath' was traversed when creating this context. */
  contains(e) {
    return this.fieldMask.find((t) => e.isPrefixOf(t)) !== void 0 || this.fieldTransforms.find((t) => e.isPrefixOf(t.field)) !== void 0;
  }
  rt() {
    if (this.path)
      for (let e = 0; e < this.path.length; e++)
        this.ct(this.path.get(e));
  }
  ct(e) {
    if (e.length === 0)
      throw this.lt("Document fields must not be empty");
    if (ZT(this.st) && OB.test(e))
      throw this.lt('Document fields cannot begin and end with "__"');
  }
}
class NB {
  constructor(e, t, i) {
    this.databaseId = e, this.ignoreUndefinedProperties = t, this.M = i || em(e);
  }
  /** Creates a new top-level parse context. */
  wt(e, t, i, r = !1) {
    return new Cp({
      st: e,
      methodName: t,
      dt: i,
      path: Zn.emptyPath(),
      ut: !1,
      ft: r
    }, this.databaseId, this.M, this.ignoreUndefinedProperties);
  }
}
function Ga(n) {
  const e = n._freezeSettings(), t = em(n._databaseId);
  return new NB(n._databaseId, !!e.ignoreUndefinedProperties, t);
}
function _p(n, e, t, i, r, s = {}) {
  const a = n.wt(s.merge || s.mergeFields ? 2 : 0, e, t, r);
  sm("Data must be an object, but it was:", a, i);
  const o = nw(i, a);
  let u, l;
  if (s.merge)
    u = new Ca(a.fieldMask), l = a.fieldTransforms;
  else if (s.mergeFields) {
    const p = [];
    for (const f of s.mergeFields) {
      const b = xl(e, f, t);
      if (!a.contains(b))
        throw new Z(se, `Field '${b}' is specified in your field mask but missing from your input data.`);
      rw(p, b) || p.push(b);
    }
    u = new Ca(p), l = a.fieldTransforms.filter((f) => u.covers(f.field));
  } else
    u = null, l = a.fieldTransforms;
  return new BB(new Un(o), u, l);
}
class Hl extends Ns {
  _toFieldTransform(e) {
    if (e.st !== 2)
      throw e.st === 1 ? e.lt(`${this._methodName}() can only appear at the top level of your update data`) : e.lt(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return e.fieldMask.push(e.path), null;
  }
  isEqual(e) {
    return e instanceof Hl;
  }
}
function ew(n, e, t) {
  return new Cp({
    st: 3,
    dt: e.settings.dt,
    methodName: n._methodName,
    ut: t
  }, e.databaseId, e.M, e.ignoreUndefinedProperties);
}
class nm extends Ns {
  _toFieldTransform(e) {
    return new Ap(e.path, new FT());
  }
  isEqual(e) {
    return e instanceof nm;
  }
}
class DB extends Ns {
  constructor(e, t) {
    super(e), this.yt = t;
  }
  _toFieldTransform(e) {
    const t = ew(
      this,
      e,
      /*array=*/
      !0
    ), i = this.yt.map((s) => qa(s, t)), r = new LT(i);
    return new Ap(e.path, r);
  }
  isEqual(e) {
    return this === e;
  }
}
class $B extends Ns {
  constructor(e, t) {
    super(e), this.yt = t;
  }
  _toFieldTransform(e) {
    const t = ew(
      this,
      e,
      /*array=*/
      !0
    ), i = this.yt.map((s) => qa(s, t)), r = new UT(i);
    return new Ap(e.path, r);
  }
  isEqual(e) {
    return this === e;
  }
}
class FB extends Ns {
  constructor(e, t) {
    super(e), this.gt = t;
  }
  _toFieldTransform(e) {
    const t = new VT(e.M, $T(e.M, this.gt));
    return new Ap(e.path, t);
  }
  isEqual(e) {
    return this === e;
  }
}
function im(n, e, t, i) {
  const r = n.wt(1, e, t);
  sm("Data must be an object, but it was:", r, i);
  const s = [], a = Un.empty();
  ql(i, (u, l) => {
    const p = am(e, u, t);
    l = Wt(l);
    const f = r.at(p);
    if (l instanceof Hl)
      s.push(p);
    else {
      const b = qa(l, f);
      b != null && (s.push(p), a.set(p, b));
    }
  });
  const o = new Ca(s);
  return new XT(a, o, r.fieldTransforms);
}
function rm(n, e, t, i, r, s) {
  const a = n.wt(1, e, t), o = [xl(e, i, t)], u = [r];
  if (s.length % 2 != 0)
    throw new Z(se, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let b = 0; b < s.length; b += 2)
    o.push(xl(e, s[b])), u.push(s[b + 1]);
  const l = [], p = Un.empty();
  for (let b = o.length - 1; b >= 0; --b)
    if (!rw(l, o[b])) {
      const A = o[b];
      let x = u[b];
      x = Wt(x);
      const w = a.at(A);
      if (x instanceof Hl)
        l.push(A);
      else {
        const T = qa(x, w);
        T != null && (l.push(A), p.set(A, T));
      }
    }
  const f = new Ca(l);
  return new XT(p, f, a.fieldTransforms);
}
function tw(n, e, t, i = !1) {
  return qa(t, n.wt(i ? 4 : 3, e));
}
function qa(n, e) {
  if (iw(
    // Unwrap the API type from the Compat SDK. This will return the API type
    // from firestore-exp.
    n = Wt(n)
  ))
    return sm("Unsupported field value:", e, n), nw(n, e);
  if (n instanceof Ns)
    return function(t, i) {
      if (!ZT(i.st))
        throw i.lt(`${t._methodName}() can only be used with update() and set()`);
      if (!i.path)
        throw i.lt(`${t._methodName}() is not currently supported inside arrays`);
      const r = t._toFieldTransform(i);
      r && i.fieldTransforms.push(r);
    }(n, e), null;
  if (n === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (
    // If context.path is null we are inside an array and we don't support
    // field mask paths more granular than the top-level array.
    e.path && e.fieldMask.push(e.path), n instanceof Array
  ) {
    if (e.settings.ut && e.st !== 4)
      throw e.lt("Nested arrays are not supported");
    return function(t, i) {
      const r = [];
      let s = 0;
      for (const a of t) {
        let o = qa(a, i.ht(s));
        o == null && // Just include nulls in the array for fields being replaced with a
        // sentinel.
        (o = {
          nullValue: "NULL_VALUE"
        }), r.push(o), s++;
      }
      return {
        arrayValue: {
          values: r
        }
      };
    }(n, e);
  }
  return function(t, i) {
    if ((t = Wt(t)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t == "number")
      return $T(i.M, t);
    if (typeof t == "boolean")
      return {
        booleanValue: t
      };
    if (typeof t == "string")
      return {
        stringValue: t
      };
    if (t instanceof Date) {
      const r = jn.fromDate(t);
      return {
        timestampValue: Wy(i.M, r)
      };
    }
    if (t instanceof jn) {
      const r = new jn(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3));
      return {
        timestampValue: Wy(i.M, r)
      };
    }
    if (t instanceof Mp)
      return {
        geoPointValue: {
          latitude: t.latitude,
          longitude: t.longitude
        }
      };
    if (t instanceof _a)
      return {
        bytesValue: mB(i.M, t._byteString)
      };
    if (t instanceof Ht) {
      const r = i.databaseId, s = t.firestore._databaseId;
      if (!s.isEqual(r))
        throw i.lt(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${r.projectId}/${r.database}`);
      return {
        referenceValue: Z0(t.firestore._databaseId || i.databaseId, t._key.path)
      };
    }
    throw i.lt(`Unsupported field value: ${xp(t)}`);
  }(n, e);
}
function nw(n, e) {
  const t = {};
  return function(i) {
    for (const r in i)
      if (Object.prototype.hasOwnProperty.call(i, r))
        return !1;
    return !0;
  }(n) ? (
    // If we encounter an empty object, we explicitly add it to the update
    // mask to ensure that the server creates a map entry.
    e.path && e.path.length > 0 && e.fieldMask.push(e.path)
  ) : ql(n, (i, r) => {
    const s = qa(r, e.ot(i));
    s != null && (t[i] = s);
  }), {
    mapValue: {
      fields: t
    }
  };
}
function iw(n) {
  return !(typeof n != "object" || n === null || n instanceof Array || n instanceof Date || n instanceof jn || n instanceof Mp || n instanceof _a || n instanceof Ht || n instanceof Ns);
}
function sm(n, e, t) {
  if (!iw(t) || !function(i) {
    return typeof i == "object" && i !== null && (Object.getPrototypeOf(i) === Object.prototype || Object.getPrototypeOf(i) === null);
  }(t)) {
    const i = xp(t);
    throw i === "an object" ? e.lt(n + " a custom object") : e.lt(n + " " + i);
  }
}
function xl(n, e, t) {
  if (
    // If required, replace the FieldPath Compat class with with the firestore-exp
    // FieldPath.
    (e = Wt(e)) instanceof Bs
  )
    return e._internalPath;
  if (typeof e == "string")
    return am(n, e);
  throw Ud(
    "Field path arguments must be of type string or ",
    n,
    /* hasConverter= */
    !1,
    /* path= */
    void 0,
    t
  );
}
const LB = new RegExp("[~\\*/\\[\\]]");
function am(n, e, t) {
  if (e.search(LB) >= 0)
    throw Ud(
      `Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,
      n,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      t
    );
  try {
    return new Bs(...e.split("."))._internalPath;
  } catch {
    throw Ud(
      `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      n,
      /* hasConverter= */
      !1,
      /* path= */
      void 0,
      t
    );
  }
}
function Ud(n, e, t, i, r) {
  const s = i && !i.isEmpty(), a = r !== void 0;
  let o = `Function ${e}() called with invalid data`;
  t && (o += " (via `toFirestore()`)"), o += ". ";
  let u = "";
  return (s || a) && (u += " (found", s && (u += ` in field ${i}`), a && (u += ` in document ${r}`), u += ")"), new Z(se, o + n + u);
}
function rw(n, e) {
  return n.some((t) => t.isEqual(e));
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class _s {
  // Note: This class is stripped down version of the DocumentSnapshot in
  // the legacy SDK. The changes are:
  // - No support for SnapshotMetadata.
  // - No support for SnapshotOptions.
  /** @hideconstructor protected */
  constructor(e, t, i, r, s) {
    this._firestore = e, this._userDataWriter = t, this._key = i, this._document = r, this._converter = s;
  }
  /** Property of the `DocumentSnapshot` that provides the document's ID. */
  get id() {
    return this._key.path.lastSegment();
  }
  /**
   * The `DocumentReference` for the document included in the `DocumentSnapshot`.
   */
  get ref() {
    return new Ht(this._firestore, this._converter, this._key);
  }
  /**
   * Signals whether or not the document at the snapshot's location exists.
   *
   * @returns true if the document exists.
   */
  exists() {
    return this._document !== null;
  }
  /**
   * Retrieves all fields in the document as an `Object`. Returns `undefined` if
   * the document doesn't exist.
   *
   * @returns An `Object` containing all fields in the document or `undefined`
   * if the document doesn't exist.
   */
  data() {
    if (this._document) {
      if (this._converter) {
        const e = new om(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          /* converter= */
          null
        );
        return this._converter.fromFirestore(e);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  /**
   * Retrieves the field specified by `fieldPath`. Returns `undefined` if the
   * document or field doesn't exist.
   *
   * @param fieldPath - The path (for example 'foo' or 'foo.bar') to a specific
   * field.
   * @returns The data at the specified field location or undefined if no such
   * field exists in the document.
   */
  // We are using `any` here to avoid an explicit cast by our users.
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  get(e) {
    if (this._document) {
      const t = this._document.data.field(um("DocumentSnapshot.get", e));
      if (t !== null)
        return this._userDataWriter.convertValue(t);
    }
  }
}
class om extends _s {
  /**
   * Retrieves all fields in the document as an `Object`.
   *
   * @override
   * @returns An `Object` containing all fields in the document.
   */
  data() {
    return super.data();
  }
}
class Vd {
  /** @hideconstructor */
  constructor(e, t) {
    this._docs = t, this.query = e;
  }
  /** An array of all the documents in the `QuerySnapshot`. */
  get docs() {
    return [...this._docs];
  }
  /** The number of documents in the `QuerySnapshot`. */
  get size() {
    return this.docs.length;
  }
  /** True if there are no documents in the `QuerySnapshot`. */
  get empty() {
    return this.docs.length === 0;
  }
  /**
   * Enumerates all of the documents in the `QuerySnapshot`.
   *
   * @param callback - A callback to be called with a `QueryDocumentSnapshot` for
   * each document in the snapshot.
   * @param thisArg - The `this` binding for the callback.
   */
  forEach(e, t) {
    this._docs.forEach(e, t);
  }
}
function sw(n, e) {
  return n = Wt(n), e = Wt(e), n instanceof _s && e instanceof _s ? n._firestore === e._firestore && n._key.isEqual(e._key) && (n._document === null ? e._document === null : n._document.isEqual(e._document)) && n._converter === e._converter : n instanceof Vd && e instanceof Vd && tm(n.query, e.query) && J0(n.docs, e.docs, sw);
}
function um(n, e) {
  return typeof e == "string" ? am(n, e) : e instanceof Bs ? e._internalPath : e._delegate._internalPath;
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class lm {
}
class eu extends lm {
}
function aw(n, e, ...t) {
  let i = [];
  e instanceof lm && i.push(e), i = i.concat(t), function(r) {
    const s = r.filter((o) => o instanceof Ha).length, a = r.filter((o) => o instanceof tu).length;
    if (s > 1 || s > 0 && a > 0)
      throw new Z(se, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.");
  }(i);
  for (const r of i)
    n = r._apply(n);
  return n;
}
class tu extends eu {
  /**
   * @internal
   */
  constructor(e, t, i) {
    super(), this._field = e, this._op = t, this._value = i, /** The type of this query constraint */
    this.type = "where";
  }
  static _create(e, t, i) {
    return new tu(e, t, i);
  }
  _apply(e) {
    const t = this._parse(e);
    return lw(e._query, t), new qn(e.firestore, e.converter, Ky(e._query, t));
  }
  _parse(e) {
    const t = Ga(e.firestore);
    return function(r, s, a, o, u, l, p) {
      let f;
      if (u.isKeyField()) {
        if (l === "array-contains" || l === "array-contains-any")
          throw new Z(se, `Invalid Query. You can't perform '${l}' queries on documentId().`);
        if (l === "in" || l === "not-in") {
          Lv(p, l);
          const b = [];
          for (const A of p)
            b.push(Fv(o, r, A));
          f = {
            arrayValue: {
              values: b
            }
          };
        } else
          f = Fv(o, r, p);
      } else
        l !== "in" && l !== "not-in" && l !== "array-contains-any" || Lv(p, l), f = tw(
          a,
          s,
          p,
          /* allowArrays= */
          l === "in" || l === "not-in"
        );
      return ni.create(u, l, f);
    }(e._query, "where", t, e.firestore._databaseId, this._field, this._op, this._value);
  }
}
function ow(n, e, t) {
  const i = e, r = um("where", n);
  return tu._create(r, i, t);
}
class Ha extends lm {
  /**
   * @internal
   */
  constructor(e, t) {
    super(), this.type = e, this._queryConstraints = t;
  }
  static _create(e, t) {
    return new Ha(e, t);
  }
  _parse(e) {
    const t = this._queryConstraints.map((i) => i._parse(e)).filter((i) => i.getFilters().length > 0);
    return t.length === 1 ? t[0] : Ma.create(t, this._getOperator());
  }
  _apply(e) {
    const t = this._parse(e);
    return t.getFilters().length === 0 ? e : (function(i, r) {
      let s = i;
      const a = r.getFlattenedFilters();
      for (const o of a)
        lw(s, o), s = Ky(s, o);
    }(e._query, t), new qn(e.firestore, e.converter, Ky(e._query, t)));
  }
  _getQueryConstraints() {
    return this._queryConstraints;
  }
  _getOperator() {
    return this.type === "and" ? "and" : "or";
  }
}
function UB(...n) {
  return n.forEach((e) => dw("or", e)), Ha._create("or", n);
}
function VB(...n) {
  return n.forEach((e) => dw("and", e)), Ha._create("and", n);
}
class Rp extends eu {
  /**
   * @internal
   */
  constructor(e, t) {
    super(), this._field = e, this._direction = t, /** The type of this query constraint */
    this.type = "orderBy";
  }
  static _create(e, t) {
    return new Rp(e, t);
  }
  _apply(e) {
    const t = function(i, r, s) {
      if (i.startAt !== null)
        throw new Z(se, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (i.endAt !== null)
        throw new Z(se, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const a = new $u(r, s);
      return function(o, u) {
        if (Y0(o) === null) {
          const l = Tp(o);
          l !== null && cw(o, l, u.field);
        }
      }(i, a), a;
    }(e._query, this._field, this._direction);
    return new qn(e.firestore, e.converter, function(i, r) {
      const s = i.explicitOrderBy.concat([r]);
      return new za(i.path, i.collectionGroup, s, i.filters.slice(), i.limit, i.limitType, i.startAt, i.endAt);
    }(e._query, t));
  }
}
function jB(n, e = "asc") {
  const t = e, i = um("orderBy", n);
  return Rp._create(i, t);
}
class Kl extends eu {
  /**
   * @internal
   */
  constructor(e, t, i) {
    super(), this.type = e, this._limit = t, this._limitType = i;
  }
  static _create(e, t, i) {
    return new Kl(e, t, i);
  }
  _apply(e) {
    return new qn(e.firestore, e.converter, function(t, i, r) {
      return new za(t.path, t.collectionGroup, t.explicitOrderBy.slice(), t.filters.slice(), i, r, t.startAt, t.endAt);
    }(e._query, this._limit, this._limitType));
  }
}
function zB(n) {
  return RT("limit", n), Kl._create(
    "limit",
    n,
    "F"
    /* LimitType.First */
  );
}
function GB(n) {
  return RT("limitToLast", n), Kl._create(
    "limitToLast",
    n,
    "L"
    /* LimitType.Last */
  );
}
class Wl extends eu {
  /**
   * @internal
   */
  constructor(e, t, i) {
    super(), this.type = e, this._docOrFields = t, this._inclusive = i;
  }
  static _create(e, t, i) {
    return new Wl(e, t, i);
  }
  _apply(e) {
    const t = uw(e, this.type, this._docOrFields, this._inclusive);
    return new qn(e.firestore, e.converter, function(i, r) {
      return new za(i.path, i.collectionGroup, i.explicitOrderBy.slice(), i.filters.slice(), i.limit, i.limitType, r, i.endAt);
    }(e._query, t));
  }
}
function qB(...n) {
  return Wl._create(
    "startAt",
    n,
    /*inclusive=*/
    !0
  );
}
function HB(...n) {
  return Wl._create(
    "startAfter",
    n,
    /*inclusive=*/
    !1
  );
}
class Jl extends eu {
  /**
   * @internal
   */
  constructor(e, t, i) {
    super(), this.type = e, this._docOrFields = t, this._inclusive = i;
  }
  static _create(e, t, i) {
    return new Jl(e, t, i);
  }
  _apply(e) {
    const t = uw(e, this.type, this._docOrFields, this._inclusive);
    return new qn(e.firestore, e.converter, function(i, r) {
      return new za(i.path, i.collectionGroup, i.explicitOrderBy.slice(), i.filters.slice(), i.limit, i.limitType, i.startAt, r);
    }(e._query, t));
  }
}
function KB(...n) {
  return Jl._create(
    "endBefore",
    n,
    /*inclusive=*/
    !1
  );
}
function WB(...n) {
  return Jl._create(
    "endAt",
    n,
    /*inclusive=*/
    !0
  );
}
function uw(n, e, t, i) {
  if (t[0] = Wt(t[0]), t[0] instanceof _s)
    return function(r, s, a, o, u) {
      if (!o)
        throw new Z(z0, `Can't use a DocumentSnapshot that doesn't exist for ${a}().`);
      const l = [];
      for (const p of Hy(r))
        if (p.field.isKeyField())
          l.push(Bd(s, o.key));
        else {
          const f = o.data.field(p.field);
          if (Q0(f))
            throw new Z(se, 'Invalid query. You are trying to start or end a query using a document for which the field "' + p.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (f === null) {
            const b = p.field.canonicalString();
            throw new Z(se, `Invalid query. You are trying to start or end a query using a document for which the field '${b}' (used as the orderBy) does not exist.`);
          }
          l.push(f);
        }
      return new Nd(l, u);
    }(n._query, n.firestore._databaseId, e, t[0]._document, i);
  {
    const r = Ga(n.firestore);
    return function(s, a, o, u, l, p) {
      const f = s.explicitOrderBy;
      if (l.length > f.length)
        throw new Z(se, `Too many arguments provided to ${u}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const b = [];
      for (let A = 0; A < l.length; A++) {
        const x = l[A];
        if (f[A].field.isKeyField()) {
          if (typeof x != "string")
            throw new Z(se, `Invalid query. Expected a string for document ID in ${u}(), but got a ${typeof x}`);
          if (!DT(s) && x.indexOf("/") !== -1)
            throw new Z(se, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${u}() must be a plain document ID, but '${x}' contains a slash.`);
          const w = s.path.child(Nt.fromString(x));
          if (!Vt.isDocumentKey(w))
            throw new Z(se, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${u}() must result in a valid document path, but '${w}' is not because it contains an odd number of segments.`);
          const T = new Vt(w);
          b.push(Bd(a, T));
        } else {
          const w = tw(o, u, x);
          b.push(w);
        }
      }
      return new Nd(b, p);
    }(n._query, n.firestore._databaseId, r, e, t, i);
  }
}
function Fv(n, e, t) {
  if (typeof (t = Wt(t)) == "string") {
    if (t === "")
      throw new Z(se, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!DT(e) && t.indexOf("/") !== -1)
      throw new Z(se, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${t}' contains a '/' character.`);
    const i = e.path.child(Nt.fromString(t));
    if (!Vt.isDocumentKey(i))
      throw new Z(se, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${i}' is not because it has an odd number of segments (${i.length}).`);
    return Bd(n, new Vt(i));
  }
  if (t instanceof Ht)
    return Bd(n, t._key);
  throw new Z(se, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${xp(t)}.`);
}
function Lv(n, e) {
  if (!Array.isArray(n) || n.length === 0)
    throw new Z(se, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
}
function lw(n, e) {
  if (e.isInequality()) {
    const i = Tp(n), r = e.field;
    if (i !== null && !i.isEqual(r))
      throw new Z(se, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${i.toString()}' and '${r.toString()}'`);
    const s = Y0(n);
    s !== null && cw(n, r, s);
  }
  const t = function(i, r) {
    for (const s of i)
      for (const a of s.getFlattenedFilters())
        if (r.indexOf(a.op) >= 0)
          return a.op;
    return null;
  }(n.filters, function(i) {
    switch (i) {
      case "!=":
        return [
          "!=",
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "array-contains-any":
      case "in":
        return [
          "not-in"
          /* Operator.NOT_IN */
        ];
      case "not-in":
        return [
          "array-contains-any",
          "in",
          "not-in",
          "!="
          /* Operator.NOT_EQUAL */
        ];
      default:
        return [];
    }
  }(e.op));
  if (t !== null)
    throw t === e.op ? new Z(se, `Invalid query. You cannot use more than one '${e.op.toString()}' filter.`) : new Z(se, `Invalid query. You cannot use '${e.op.toString()}' filters with '${t.toString()}' filters.`);
}
function cw(n, e, t) {
  if (!t.isEqual(e))
    throw new Z(se, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${t.toString()}' instead.`);
}
function dw(n, e) {
  if (!(e instanceof tu || e instanceof Ha))
    throw new Z(se, `Function ${n}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function kp(n, e, t) {
  let i;
  return i = n ? t && (t.merge || t.mergeFields) ? n.toFirestore(e, t) : n.toFirestore(e) : e, i;
}
class Pp extends class {
  convertValue(e, t = "none") {
    switch (Sa(e)) {
      case 0:
        return null;
      case 1:
        return e.booleanValue;
      case 2:
        return Gt(e.integerValue || e.doubleValue);
      case 3:
        return this.convertTimestamp(e.timestampValue);
      case 4:
        return this.convertServerTimestamp(e, t);
      case 5:
        return e.stringValue;
      case 6:
        return this.convertBytes(bl(e.bytesValue));
      case 7:
        return this.convertReference(e.referenceValue);
      case 8:
        return this.convertGeoPoint(e.geoPointValue);
      case 9:
        return this.convertArray(e.arrayValue, t);
      case 10:
        return this.convertObject(e.mapValue, t);
      default:
        throw Ne();
    }
  }
  convertObject(e, t) {
    const i = {};
    return ql(e.fields, (r, s) => {
      i[r] = this.convertValue(s, t);
    }), i;
  }
  convertGeoPoint(e) {
    return new Mp(Gt(e.latitude), Gt(e.longitude));
  }
  convertArray(e, t) {
    return (e.values || []).map((i) => this.convertValue(i, t));
  }
  convertServerTimestamp(e, t) {
    switch (t) {
      case "previous":
        const i = PT(e);
        return i == null ? null : this.convertValue(i, t);
      case "estimate":
        return this.convertTimestamp(gl(e));
      default:
        return null;
    }
  }
  convertTimestamp(e) {
    const t = Ea(e);
    return new jn(t.seconds, t.nanos);
  }
  convertDocumentKey(e, t) {
    const i = Nt.fromString(e);
    Rn(KT(i));
    const r = new hl(i.get(1), i.get(3)), s = new Vt(i.popFirst(5));
    return r.isEqual(t) || // TODO(b/64130202): Somehow support foreign references.
    vp(`Document ${s} contains a document reference within a different database (${r.projectId}/${r.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`), s;
  }
} {
  constructor(e) {
    super(), this.firestore = e;
  }
  convertBytes(e) {
    return new _a(e);
  }
  convertReference(e) {
    const t = this.convertDocumentKey(e, this.firestore._databaseId);
    return new Ht(
      this.firestore,
      /* converter= */
      null,
      t
    );
  }
}
function JB(n) {
  const e = Qr((n = wi(n, Ht)).firestore), t = new Pp(n.firestore);
  return JT(e, [n._key]).then((i) => {
    Rn(i.length === 1);
    const r = i[0];
    return new _s(n.firestore, t, n._key, r.isFoundDocument() ? r : null, n.converter);
  });
}
function Yy(n) {
  (function(i) {
    if (i.limitType === "L" && i.explicitOrderBy.length === 0)
      throw new Z(q0, "limitToLast() queries require specifying at least one orderBy() clause");
  })((n = wi(n, qn))._query);
  const e = Qr(n.firestore), t = new Pp(n.firestore);
  return SB(e, n._query).then((i) => {
    const r = i.map((s) => new om(n.firestore, t, s.key, s, n.converter));
    return n._query.limitType === "L" && // Limit to last queries reverse the orderBy constraint that was
    // specified by the user. As such, we need to reverse the order of the
    // results to return the documents in the expected order.
    r.reverse(), new Vd(n, r);
  });
}
function Xy(n, e, t) {
  const i = kp((n = wi(n, Ht)).converter, e, t), r = _p(Ga(n.firestore), "setDoc", n._key, i, n.converter !== null, t);
  return Zo(Qr(n.firestore), [r.toMutation(n._key, vn.none())]);
}
function QB(n, e, t, ...i) {
  const r = Ga((n = wi(n, Ht)).firestore);
  let s;
  return s = typeof (e = Wt(e)) == "string" || e instanceof Bs ? rm(r, "updateDoc", n._key, e, t, i) : im(r, "updateDoc", n._key, e), Zo(Qr(n.firestore), [s.toMutation(n._key, vn.exists(!0))]);
}
function pw(n) {
  return Zo(Qr((n = wi(n, Ht)).firestore), [new Sp(n._key, vn.none())]);
}
function YB(n, e) {
  const t = Uu(n = wi(n, yi)), i = kp(n.converter, e), r = _p(Ga(n.firestore), "addDoc", t._key, i, t.converter !== null, {});
  return Zo(Qr(n.firestore), [r.toMutation(t._key, vn.exists(!1))]).then(() => t);
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function XB(n) {
  return fw(n, {
    count: yw()
  });
}
function fw(n, e) {
  const t = wi(n.firestore, yr), i = Qr(t), r = function(s, a) {
    const o = [];
    for (const u in s)
      Object.prototype.hasOwnProperty.call(s, u) && o.push(a(s[u], u, s));
    return o;
  }(e, (s, a) => new YO(new W0(a), s._aggregateType, s._internalFieldPath));
  return MB(i, n._query, r).then((s) => function(a, o, u) {
    const l = new Pp(a);
    return new YT(o, l, u);
  }(t, n, s));
}
function ZB(n) {
  return new Oo("sum", xl("sum", n));
}
function eN(n) {
  return new Oo("avg", xl("average", n));
}
function yw() {
  return new Oo("count");
}
function tN(n, e) {
  var t, i;
  return n instanceof Oo && e instanceof Oo && n._aggregateType === e._aggregateType && ((t = n._internalFieldPath) === null || t === void 0 ? void 0 : t.canonicalString()) === ((i = e._internalFieldPath) === null || i === void 0 ? void 0 : i.canonicalString());
}
function nN(n, e) {
  return tm(n.query, e.query) && Cd(n.data(), e.data());
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function iN() {
  return new Hl("deleteField");
}
function rN() {
  return new nm("serverTimestamp");
}
function sN(...n) {
  return new DB("arrayUnion", n);
}
function aN(...n) {
  return new $B("arrayRemove", n);
}
function oN(n) {
  return new FB("increment", n);
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class hw {
  /** @hideconstructor */
  constructor(e, t) {
    this._firestore = e, this._commitHandler = t, this._mutations = [], this._committed = !1, this._dataReader = Ga(e);
  }
  set(e, t, i) {
    this._verifyNotCommitted();
    const r = oa(e, this._firestore), s = kp(r.converter, t, i), a = _p(this._dataReader, "WriteBatch.set", r._key, s, r.converter !== null, i);
    return this._mutations.push(a.toMutation(r._key, vn.none())), this;
  }
  update(e, t, i, ...r) {
    this._verifyNotCommitted();
    const s = oa(e, this._firestore);
    let a;
    return a = typeof (t = Wt(t)) == "string" || t instanceof Bs ? rm(this._dataReader, "WriteBatch.update", s._key, t, i, r) : im(this._dataReader, "WriteBatch.update", s._key, t), this._mutations.push(a.toMutation(s._key, vn.exists(!0))), this;
  }
  /**
   * Deletes the document referred to by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be deleted.
   * @returns This `WriteBatch` instance. Used for chaining method calls.
   */
  delete(e) {
    this._verifyNotCommitted();
    const t = oa(e, this._firestore);
    return this._mutations = this._mutations.concat(new Sp(t._key, vn.none())), this;
  }
  /**
   * Commits all of the writes in this write batch as a single atomic unit.
   *
   * The result of these writes will only be reflected in document reads that
   * occur after the returned promise resolves. If the client is offline, the
   * write fails. If you would like to see local modifications or buffer writes
   * until the client is online, use the full Firestore SDK.
   *
   * @returns A `Promise` resolved once all of the writes in the batch have been
   * successfully written to the backend as an atomic unit (note that it won't
   * resolve while you're offline).
   */
  commit() {
    return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new Z(Vr, "A write batch can no longer be used after commit() has been called.");
  }
}
function oa(n, e) {
  if ((n = Wt(n)).firestore !== e)
    throw new Z(se, "Provided document reference is from a different Firestore instance.");
  return n;
}
function mw(n) {
  const e = Qr(n = wi(n, yr));
  return new hw(n, (t) => Zo(e, t));
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class uN {
  constructor(e) {
    this.datastore = e, // The version of each document that was read during this transaction.
    this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = !1, /**
     * A deferred usage error that occurred previously in this transaction that
     * will cause the transaction to fail once it actually commits.
     */
    this.lastWriteError = null, /**
     * Set of documents that have been written in the transaction.
     *
     * When there's more than one write to the same key in a transaction, any
     * writes after the first are handled differently.
     */
    this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(e) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new Z(se, "Firestore transactions require all reads to be executed before all writes.");
    const t = await JT(this.datastore, e);
    return t.forEach((i) => this.recordVersion(i)), t;
  }
  set(e, t) {
    this.write(t.toMutation(e, this.precondition(e))), this.writtenDocs.add(e.toString());
  }
  update(e, t) {
    try {
      this.write(t.toMutation(e, this.preconditionForUpdate(e)));
    } catch (i) {
      this.lastWriteError = i;
    }
    this.writtenDocs.add(e.toString());
  }
  delete(e) {
    this.write(new Sp(e, this.precondition(e))), this.writtenDocs.add(e.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const e = this.readVersions;
    this.mutations.forEach((t) => {
      e.delete(t.key.toString());
    }), // For each document that was read but not written to, we want to perform
    // a `verify` operation.
    e.forEach((t, i) => {
      const r = Vt.fromPath(i);
      this.mutations.push(new zT(r, this.precondition(r)));
    }), await Zo(this.datastore, this.mutations), this.committed = !0;
  }
  recordVersion(e) {
    let t;
    if (e.isFoundDocument())
      t = e.version;
    else {
      if (!e.isNoDocument())
        throw Ne();
      t = Lt.min();
    }
    const i = this.readVersions.get(e.key.toString());
    if (i) {
      if (!t.isEqual(i))
        throw new Z(G0, "Document version changed between two reads.");
    } else
      this.readVersions.set(e.key.toString(), t);
  }
  /**
   * Returns the version of this document when it was read in this transaction,
   * as a precondition, or no precondition if it was not read.
   */
  precondition(e) {
    const t = this.readVersions.get(e.toString());
    return !this.writtenDocs.has(e.toString()) && t ? t.isEqual(Lt.min()) ? vn.exists(!1) : vn.updateTime(t) : vn.none();
  }
  /**
   * Returns the precondition for a document if the operation is an update.
   */
  preconditionForUpdate(e) {
    const t = this.readVersions.get(e.toString());
    if (!this.writtenDocs.has(e.toString()) && t) {
      if (t.isEqual(Lt.min()))
        throw new Z(se, "Can't update a document that doesn't exist.");
      return vn.updateTime(t);
    }
    return vn.exists(!0);
  }
  write(e) {
    this.ensureCommitNotCalled(), this.mutations.push(e);
  }
  ensureCommitNotCalled() {
  }
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const lN = {
  maxAttempts: 5
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cN {
  constructor(e, t, i, r, s) {
    this.asyncQueue = e, this.datastore = t, this.options = i, this.updateFunction = r, this.deferred = s, this._t = i.maxAttempts, this.vt = new WT(
      this.asyncQueue,
      "transaction_retry"
      /* TimerId.TransactionRetry */
    );
  }
  /** Runs the transaction and sets the result on deferred. */
  run() {
    this._t -= 1, this.bt();
  }
  bt() {
    this.vt.J(async () => {
      const e = new uN(this.datastore), t = this.Et(e);
      t && t.then((i) => {
        this.asyncQueue.enqueueAndForget(() => e.commit().then(() => {
          this.deferred.resolve(i);
        }).catch((r) => {
          this.At(r);
        }));
      }).catch((i) => {
        this.At(i);
      });
    });
  }
  Et(e) {
    try {
      const t = this.updateFunction(e);
      return !kT(t) && t.catch && t.then ? t : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t) {
      return this.deferred.reject(t), null;
    }
  }
  At(e) {
    this._t > 0 && this.It(e) ? (this._t -= 1, this.asyncQueue.enqueueAndForget(() => (this.bt(), Promise.resolve()))) : this.deferred.reject(e);
  }
  It(e) {
    if (e.name === "FirebaseError") {
      const t = e.code;
      return t === "aborted" || t === "failed-precondition" || t === "already-exists" || !/**
      * Determines whether an error code represents a permanent error when received
      * in response to a non-write operation.
      *
      * See isPermanentWriteError for classifying write errors.
      */
      function(i) {
        switch (i) {
          default:
            return Ne();
          case j0:
          case go:
          case wT:
          case ET:
          case MT:
          case CT:
          case Pd:
            return !1;
          case se:
          case z0:
          case DO:
          case AT:
          case Vr:
          case G0:
          case ST:
          case q0:
          case $O:
            return !0;
        }
      }(t);
    }
    return !1;
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function jf() {
  return typeof document < "u" ? document : null;
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class cm {
  constructor(e, t, i, r, s) {
    this.asyncQueue = e, this.timerId = t, this.targetTimeMs = i, this.op = r, this.removalCallback = s, this.deferred = new H0(), this.then = this.deferred.promise.then.bind(this.deferred.promise), // It's normal for the deferred promise to be canceled (due to cancellation)
    // and so we attach a dummy catch callback to avoid
    // 'UnhandledPromiseRejectionWarning' log spam.
    this.deferred.promise.catch((a) => {
    });
  }
  /**
   * Creates and returns a DelayedOperation that has been scheduled to be
   * executed on the provided asyncQueue after the provided delayMs.
   *
   * @param asyncQueue - The queue to schedule the operation on.
   * @param id - A Timer ID identifying the type of operation this is.
   * @param delayMs - The delay (ms) before the operation should be scheduled.
   * @param op - The operation to run.
   * @param removalCallback - A callback to be called synchronously once the
   *   operation is executed or canceled, notifying the AsyncQueue to remove it
   *   from its delayedOperations list.
   *   PORTING NOTE: This exists to prevent making removeDelayedOperation() and
   *   the DelayedOperation class public.
   */
  static createAndSchedule(e, t, i, r, s) {
    const a = Date.now() + i, o = new cm(e, t, a, r, s);
    return o.start(i), o;
  }
  /**
   * Starts the timer. This is called immediately after construction by
   * createAndSchedule().
   */
  start(e) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e);
  }
  /**
   * Queues the operation to run immediately (if it hasn't already been run or
   * canceled).
   */
  skipDelay() {
    return this.handleDelayElapsed();
  }
  /**
   * Cancels the operation if it hasn't already been executed or canceled. The
   * promise will be rejected.
   *
   * As long as the operation has not yet been run, calling cancel() provides a
   * guarantee that the operation will not be run.
   */
  cancel(e) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new Z(j0, "Operation cancelled" + (e ? ": " + e : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((e) => this.deferred.resolve(e))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class dN {
  constructor() {
    this.Tt = Promise.resolve(), // A list of retryable operations. Retryable operations are run in order and
    // retried with backoff.
    this.Rt = [], // Is this AsyncQueue being shut down? Once it is set to true, it will not
    // be changed again.
    this.Pt = !1, // Operations scheduled to be queued in the future. Operations are
    // automatically removed after they are run or canceled.
    this.Vt = [], // visible for testing
    this.$t = null, // Flag set while there's an outstanding AsyncQueue operation, used for
    // assertion sanity-checks.
    this.Dt = !1, // Enabled during shutdown on Safari to prevent future access to IndexedDB.
    this.Nt = !1, // List of TimerIds to fast-forward delays for.
    this.Ft = [], // Backoff timer used to schedule retries for retryable operations
    this.vt = new WT(
      this,
      "async_queue_retry"
      /* TimerId.AsyncQueueRetry */
    ), // Visibility handler that triggers an immediate retry of all retryable
    // operations. Meant to speed up recovery when we regain file system access
    // after page comes into foreground.
    this.xt = () => {
      const t = jf();
      t && Aa("AsyncQueue", "Visibility state changed to " + t.visibilityState), this.vt.tt();
    };
    const e = jf();
    e && typeof e.addEventListener == "function" && e.addEventListener("visibilitychange", this.xt);
  }
  get isShuttingDown() {
    return this.Pt;
  }
  /**
   * Adds a new operation to the queue without waiting for it to complete (i.e.
   * we ignore the Promise result).
   */
  enqueueAndForget(e) {
    this.enqueue(e);
  }
  enqueueAndForgetEvenWhileRestricted(e) {
    this.St(), // eslint-disable-next-line @typescript-eslint/no-floating-promises
    this.qt(e);
  }
  enterRestrictedMode(e) {
    if (!this.Pt) {
      this.Pt = !0, this.Nt = e || !1;
      const t = jf();
      t && typeof t.removeEventListener == "function" && t.removeEventListener("visibilitychange", this.xt);
    }
  }
  enqueue(e) {
    if (this.St(), this.Pt)
      return new Promise(() => {
      });
    const t = new H0();
    return this.qt(() => this.Pt && this.Nt ? Promise.resolve() : (e().then(t.resolve, t.reject), t.promise)).then(() => t.promise);
  }
  enqueueRetryable(e) {
    this.enqueueAndForget(() => (this.Rt.push(e), this.Ot()));
  }
  /**
   * Runs the next operation from the retryable queue. If the operation fails,
   * reschedules with backoff.
   */
  async Ot() {
    if (this.Rt.length !== 0) {
      try {
        await this.Rt[0](), this.Rt.shift(), this.vt.reset();
      } catch (e) {
        if (!/**
        * @license
        * Copyright 2017 Google LLC
        *
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        *   http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        */
        /** Verifies whether `e` is an IndexedDbTransactionError. */
        function(t) {
          return t.name === "IndexedDbTransactionError";
        }(e))
          throw e;
        Aa("AsyncQueue", "Operation failed with retryable error: " + e);
      }
      this.Rt.length > 0 && // If there are additional operations, we re-schedule `retryNextOp()`.
      // This is necessary to run retryable operations that failed during
      // their initial attempt since we don't know whether they are already
      // enqueued. If, for example, `op1`, `op2`, `op3` are enqueued and `op1`
      // needs to  be re-run, we will run `op1`, `op1`, `op2` using the
      // already enqueued calls to `retryNextOp()`. `op3()` will then run in the
      // call scheduled here.
      // Since `backoffAndRun()` cancels an existing backoff and schedules a
      // new backoff on every call, there is only ever a single additional
      // operation in the queue.
      this.vt.J(() => this.Ot());
    }
  }
  qt(e) {
    const t = this.Tt.then(() => (this.Dt = !0, e().catch((i) => {
      this.$t = i, this.Dt = !1;
      const r = (
        /**
        * Chrome includes Error.message in Error.stack. Other browsers do not.
        * This returns expected output of message + stack when available.
        * @param error - Error or FirestoreError
        */
        function(s) {
          let a = s.message || "";
          return s.stack && (a = s.stack.includes(s.message) ? s.stack : s.message + `
` + s.stack), a;
        }(i)
      );
      throw vp("INTERNAL UNHANDLED ERROR: ", r), i;
    }).then((i) => (this.Dt = !1, i))));
    return this.Tt = t, t;
  }
  enqueueAfterDelay(e, t, i) {
    this.St(), // Fast-forward delays for timerIds that have been overriden.
    this.Ft.indexOf(e) > -1 && (t = 0);
    const r = cm.createAndSchedule(this, e, t, i, (s) => this.kt(s));
    return this.Vt.push(r), r;
  }
  St() {
    this.$t && Ne();
  }
  verifyOperationInProgress() {
  }
  /**
   * Waits until all currently queued tasks are finished executing. Delayed
   * operations are not run.
   */
  async Ct() {
    let e;
    do
      e = this.Tt, await e;
    while (e !== this.Tt);
  }
  /**
   * For Tests: Determine if a delayed operation with a particular TimerId
   * exists.
   */
  Lt(e) {
    for (const t of this.Vt)
      if (t.timerId === e)
        return !0;
    return !1;
  }
  /**
   * For Tests: Runs some or all delayed operations early.
   *
   * @param lastTimerId - Delayed operations up to and including this TimerId
   * will be drained. Pass TimerId.All to run all delayed operations.
   * @returns a Promise that resolves once all operations have been run.
   */
  Mt(e) {
    return this.Ct().then(() => {
      this.Vt.sort((t, i) => t.targetTimeMs - i.targetTimeMs);
      for (const t of this.Vt)
        if (t.skipDelay(), e !== "all" && t.timerId === e)
          break;
      return this.Ct();
    });
  }
  /**
   * For Tests: Skip all subsequent delays for a timer id.
   */
  Ut(e) {
    this.Ft.push(e);
  }
  /** Called once a DelayedOperation is run or canceled. */
  kt(e) {
    const t = this.Vt.indexOf(e);
    this.Vt.splice(t, 1);
  }
}
class bw {
  /** @hideconstructor */
  constructor(e, t) {
    this._firestore = e, this._transaction = t, this._dataReader = Ga(e);
  }
  /**
   * Reads the document referenced by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be read.
   * @returns A `DocumentSnapshot` with the read data.
   */
  get(e) {
    const t = oa(e, this._firestore), i = new Pp(this._firestore);
    return this._transaction.lookup([t._key]).then((r) => {
      if (!r || r.length !== 1)
        return Ne();
      const s = r[0];
      if (s.isFoundDocument())
        return new _s(this._firestore, i, s.key, s, t.converter);
      if (s.isNoDocument())
        return new _s(this._firestore, i, t._key, null, t.converter);
      throw Ne();
    });
  }
  set(e, t, i) {
    const r = oa(e, this._firestore), s = kp(r.converter, t, i), a = _p(this._dataReader, "Transaction.set", r._key, s, r.converter !== null, i);
    return this._transaction.set(r._key, a), this;
  }
  update(e, t, i, ...r) {
    const s = oa(e, this._firestore);
    let a;
    return a = typeof (t = Wt(t)) == "string" || t instanceof Bs ? rm(this._dataReader, "Transaction.update", s._key, t, i, r) : im(this._dataReader, "Transaction.update", s._key, t), this._transaction.update(s._key, a), this;
  }
  /**
   * Deletes the document referred to by the provided {@link DocumentReference}.
   *
   * @param documentRef - A reference to the document to be deleted.
   * @returns This `Transaction` instance. Used for chaining method calls.
   */
  delete(e) {
    const t = oa(e, this._firestore);
    return this._transaction.delete(t._key), this;
  }
}
function pN(n, e, t) {
  const i = Qr(n = wi(n, yr)), r = Object.assign(Object.assign({}, lN), t);
  (function(a) {
    if (a.maxAttempts < 1)
      throw new Z(se, "Max attempts must be at least 1");
  })(r);
  const s = new H0();
  return new cN(new dN(), i, r, (a) => e(new bw(n, a)), s).run(), s.promise;
}
(function(n) {
  Yo = n;
})(`${wO}_lite`), kd(new fl("firestore/lite", (n, { instanceIdentifier: e, options: t }) => {
  const i = n.getProvider("app").getImmediate(), r = new yr(new UO(n.getProvider("auth-internal")), new GO(n.getProvider("app-check-internal")), function(s, a) {
    if (!Object.prototype.hasOwnProperty.apply(s.options, ["projectId"]))
      throw new Z(se, '"projectId" not provided in firebase.initializeApp.');
    return new hl(s.options.projectId, a);
  }(i, e), i);
  return t && r._setSettings(t), r;
}, "PUBLIC").setMultipleInstances(!0)), // RUNTIME_ENV and BUILD_TARGET are replaced by real values during the compilation
bo("firestore-lite", "3.9.0", ""), bo("firestore-lite", "3.9.0", "esm2017");
const Uv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AggregateField: Oo,
  AggregateQuerySnapshot: YT,
  Bytes: _a,
  CollectionReference: yi,
  DocumentReference: Ht,
  DocumentSnapshot: _s,
  FieldPath: Bs,
  FieldValue: Ns,
  Firestore: yr,
  FirestoreError: Z,
  GeoPoint: Mp,
  Query: qn,
  QueryCompositeFilterConstraint: Ha,
  QueryConstraint: eu,
  QueryDocumentSnapshot: om,
  QueryEndAtConstraint: Jl,
  QueryFieldFilterConstraint: tu,
  QueryLimitConstraint: Kl,
  QueryOrderByConstraint: Rp,
  QuerySnapshot: Vd,
  QueryStartAtConstraint: Wl,
  Timestamp: jn,
  Transaction: bw,
  WriteBatch: hw,
  addDoc: YB,
  aggregateFieldEqual: tN,
  aggregateQuerySnapshotEqual: nN,
  and: VB,
  arrayRemove: aN,
  arrayUnion: sN,
  average: eN,
  collection: Qy,
  collectionGroup: kB,
  connectFirestoreEmulator: QT,
  count: yw,
  deleteDoc: pw,
  deleteField: iN,
  doc: Uu,
  documentId: IB,
  endAt: WB,
  endBefore: KB,
  getAggregate: fw,
  getCount: XB,
  getDoc: JB,
  getDocs: Yy,
  getFirestore: _B,
  increment: oN,
  initializeFirestore: CB,
  limit: zB,
  limitToLast: GB,
  or: UB,
  orderBy: jB,
  query: aw,
  queryEqual: tm,
  refEqual: PB,
  runTransaction: pN,
  serverTimestamp: rN,
  setDoc: Xy,
  setLogLevel: NO,
  snapshotEqual: sw,
  startAfter: HB,
  startAt: qB,
  sum: ZB,
  terminate: RB,
  updateDoc: QB,
  where: ow,
  writeBatch: mw
}, Symbol.toStringTag, { value: "Module" }));
var Jt = /* @__PURE__ */ ((n) => (n[n.minute = 0] = "minute", n[n.hour = 1] = "hour", n[n.day = 2] = "day", n))(Jt || {});
const zf = ye.createContainer().register(fe.instance(C5, gT({ ...Z7, apiKey: globalThis.process.env.FIREBASE_API_KEY }))).register(fe.instance(E0, {})).register(Co).register(dl).register(fe.instance(tI, {})).register(fe.instance(N0, {})).register(fe.instance(S0, { lsGet: () => "", lsSet: () => "" })).register(al).register(Ed).register(_o).register(Sd).register(
  fe.instance(
    ip,
    new aI(
      { url: a2, skipFetchSetup: !0 },
      {
        name: o2.toLowerCase(),
        chainId: s2
      }
    )
  )
).register(
  fe.instance(Da, {
    chainId: s2,
    ipfsGateway: eS,
    chainUrl: a2,
    chain: o2,
    isDevelopment: !1,
    scanLink: tS,
    firebaseCollection: eo
  })
).register(np).register(pl).register(xa).register(
  fe.instance(M5, {
    tokens: FR
  })
).register(ol).register(fe.instance(Na, { uf: (n) => Number(n) })).register(
  fe.instance(ka, {}),
  fe.instance(Kd, {}),
  fe.instance(Ra, {
    scopeTo: () => {
    }
  })
), fN = async () => {
  let n = !1;
  const e = 5, t = 1, i = 1;
  let r = "";
  const s = zf.get(uT);
  let a = "", o = 0, u = 0, l = 0, p = 0, f = 0, b = 0, A = 0, x = 0, w = 0, T = 0, _, I = 0, $ = 0, N = 0, B = 0, V = 0;
  const G = await zf.get(w0).connect(), Y = Object.values(Jt).filter((E) => typeof E == "number").map((E) => E), oe = async (E) => {
    const C = Qy(G, `${eo}/lastSync/${E}`);
    return (await Yy(C)).docs[0]?.id;
  }, J = async (E, C, k) => {
    k && await pw(Uu(G, `${eo}/lastSync/${E}/${k}`)), await Xy(Uu(G, `${eo}/lastSync/${E}`, C.toString()), {});
  }, ue = async (E, C, k, m) => {
    let d = m;
    typeof d != "object" && (d = { value: m }), d.createdAt = k, await Xy(Uu(G, `${eo}/${E}/${C}`, k.toString()), d);
  }, M = async (E, C, k) => {
    const m = mw(G);
    (await Yy(aw(Qy(G, `${eo}/${E}/${C}`), ow("createdAt", "<", k)))).forEach((g) => m.delete(g.ref)), await m.commit();
  }, c = async () => (await (await zf.get(cT).getTreasuryContract()).totalValuation()).toHexString(), h = async () => {
    await s.loadAssets(), await s.loadkCur();
  }, v = (E) => {
    const C = /* @__PURE__ */ new Date();
    switch (E) {
      case 0:
        C.setMinutes(C.getMinutes() - 60, 0, 0);
        break;
      case 1:
        C.setHours(C.getHours() - 24, 0, 0, 0);
        break;
      case 2:
        return Number.MIN_VALUE;
    }
    return C.getTime();
  }, S = async () => {
    r = await c(), await h(), a = s.reserveValue?.toHexString() ?? "", o = s.currentLeverageRatio, u = s.maxLeverageRatio, l = s.kCurPrice ?? 0, p = s.kCurPriceCeiling, f = s.kCurPriceFloor, b = s.kCurReserveDistribution ?? 0, A = s.kCurMentoDistribution ?? 0, x = s.kCurPrimaryPoolDistribution ?? 0, w = s.kCurCirculatingDistribution, I = s.minCollateralizationValue, $ = s.kCurTotalValue, N = s.lowRiskAssets.map((E) => E.total).sum(), B = s.moderateRiskAssets.map((E) => E.total).sum(), V = s.highRiskAssets.map((E) => E.total).sum(), T = s.kGuilderValueRatio;
  };
  await Promise.all(
    Y.map(async (E) => {
      const C = await oe(Jt[E]), k = /* @__PURE__ */ new Date();
      let m = /* @__PURE__ */ new Date();
      if (C && (m = new Date(Number(C))), E === 0 ? (m.setUTCMinutes(m.getUTCMinutes() + e), m.setUTCSeconds(0, 0)) : E === 1 ? (m.setUTCHours(m.getUTCHours() + t), m.setUTCMinutes(0, 0, 0)) : (m.setUTCDate(m.getUTCDate() + i), m.setUTCHours(0, 0, 0, 0)), k >= m || !C) {
        let d = /* @__PURE__ */ new Date();
        if (E === 0) {
          const g = 6e4 * e;
          d = new Date(Math.floor(k.getTime() / g) * g);
        } else
          E === 1 ? d.setUTCMinutes(0, 0, 0) : d.setUTCHours(0, 0, 0, 0);
        n || (n = !0, _ = S()), _?.then(async () => {
          await ue("kCurPrice", Jt[E], d.getTime(), { kCurPrice: l, kCurPriceCeiling: p, kCurPriceFloor: f }), await ue("kCurRatio", Jt[E], d.getTime(), { currentLeverageRatio: o, maxLeverageRatio: u }), await ue("kCurSupply", Jt[E], d.getTime(), {
            kCurReserveDistribution: b,
            kCurMentoDistribution: A,
            kCurPrimaryPoolDistribution: x,
            kCurCirculatingDistribution: w
          }), await ue("ktt", Jt[E], d.getTime(), r), await ue("reserve", Jt[E], d.getTime(), a), await ue("risk", Jt[E], d.getTime(), {
            minCollateralValue: I,
            marketCap: $,
            lowRisk: N,
            moderateRisk: B,
            highRisk: V
          }), await ue("kGuilder", Jt[E], d.getTime(), T), await J(Jt[E], d.getTime(), C);
          const g = v(E);
          await M("kCurPrice", Jt[E], g), await M("kCurRatio", Jt[E], g), await M("kCurSupply", Jt[E], g), await M("ktt", Jt[E], g), await M("reserve", Jt[E], g), await M("risk", Jt[E], g), await M("kGuilder", Jt[E], g);
        });
      }
    })
  );
};
await fN();
const gw = "celo", vw = 42220, xw = {
  monetaryBadger: {
    abi: "Badger",
    address: "0x391002f0b25Fb2AdAFeDcD1EA1C97834FCD59CDD"
  },
  kolektivoBadger: {
    abi: "Badger",
    address: "0x203EFD61908cA90bF0A5984f6754DB0e58162B88"
  },
  bacMD: {
    abi: "BACRoles",
    address: "0x34886b875E588c412574426a9675e33b64d5Dd59"
  },
  bacFFD: {
    abi: "BACRoles",
    address: "0x9D5C5a439E6edDb34562087D83f0A58DCC5672d7"
  },
  bacMC: {
    abi: "BACRoles",
    address: "0xF3Fd37f7F54BFeF2cdA043B57e132006b6a44E47"
  },
  bacK: {
    abi: "BACRoles",
    address: "0x659248bc8f8Ee7937a0e9f018dc5e8fFEe3A68Fd"
  },
  reserveDelegateScope: {
    abi: "ScopeGuard",
    address: "0x2a016330C0e5169FA5C44A4f5C73E76B2543CFBa"
  },
  foodForestDelegateScope: {
    abi: "ScopeGuard",
    address: "0xF22d9617d2B4d8DacDD708aF6615c5Af72b6a861"
  },
  monetaryMultisigScope: {
    abi: "ScopeGuard",
    address: "0x06E26e99470462B0a75760B50685cf4bE084005B"
  },
  monetaryDelay: {
    abi: "SecretDelay",
    address: "0x5bfD3A6c4a579A1F20d2652633cCAce90d9db62F"
  },
  foodForestDelay: {
    abi: "SecretDelay",
    address: "0x28DD09637872D94b9Bac33041B3A9482E1904A4B"
  },
  kolektivoDelay: {
    abi: "SecretDelay",
    address: "0xb846c1B4A959be7a666f3882Fd3F70019ccFA408"
  }
}, yN = {
  name: gw,
  chainId: vw,
  contracts: xw
}, hN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  chainId: vw,
  contracts: xw,
  default: yN,
  name: gw
}, Symbol.toStringTag, { value: "Module" })), Tw = "celo", ww = "42220", Aw = {
  GeoNFT: {
    address: "0x9fC5461A1e6CF567C7E19Befa7c0351C9C6CB719",
    abi: [
      {
        inputs: [
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidIdentifier",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidLatitude",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidLongitude",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidTokenId",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "TokenModified",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "int32",
            name: "latitude",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "longitude",
            type: "int32"
          },
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "int32",
            name: "latitude",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "longitude",
            type: "int32"
          },
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "modify",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "tokenData",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "int32",
            name: "",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "",
            type: "int32"
          },
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Oracle: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "uint256",
            name: "reportExpirationTime_",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "reportDelay_",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumProviders_",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "invalidProvider",
            type: "address"
          }
        ],
        name: "Oracle__InvalidProvider",
        type: "error"
      },
      {
        inputs: [],
        name: "Oracle__NewReportTooSoonAfterPastReport",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldMinimumProviders",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newMinimumProviders",
            type: "uint256"
          }
        ],
        name: "MinimumProvidersChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [],
        name: "OracleMarkedAsInvalid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [],
        name: "OracleMarkedAsValid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          }
        ],
        name: "ProviderReportPushed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "purger",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderReportsPurged",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "addProvider",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getData",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "isValid",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "minimumProviders",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "providerReports",
        outputs: [
          {
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "providers",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "providersSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "purgeReports",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "purgeReportsFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          }
        ],
        name: "pushReport",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "removeProvider",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "reportDelay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "reportExpirationTime",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "isValid_",
            type: "bool"
          }
        ],
        name: "setIsValid",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "minimumProviders_",
            type: "uint256"
          }
        ],
        name: "setMinimumProviders",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Reserve: {
    address: "0x9F2D87bEb5ead48FBf9c39Ada853C79DB6D0781f",
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "token_",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOracle_",
            type: "address"
          },
          {
            internalType: "address",
            name: "vestingVault_",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minBacking_",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20BalanceNotSufficient",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20BondingLimitExceeded",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotBondable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotRedeemable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotRegistered",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20RedeemLimitExceeded",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotBondable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotRedeemable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotRegistered",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidOracle",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__MinimumBackingLimitExceeded",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldBacking",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newBacking",
            type: "uint256"
          }
        ],
        name: "BackingUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sBonded",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensMinted",
            type: "uint256"
          }
        ],
        name: "BondedERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensMinted",
            type: "uint256"
          }
        ],
        name: "BondedERC721",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "DebtIncurred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "DebtPaid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20Deregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum IReserve.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            indexed: !1,
            internalType: "enum IReserve.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "ERC20Registered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDeregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sRedeemed",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensBurned",
            type: "uint256"
          }
        ],
        name: "RedeemedERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensBurned",
            type: "uint256"
          }
        ],
        name: "RedeemedERC721Id",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldDiscount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newDiscount",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingDiscount",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldtimeLockDuration",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newtimeLockDuration",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingTimeLock",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetERC20Oracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20RedeemLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldDiscount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newDiscount",
            type: "uint256"
          }
        ],
        name: "SetERC721IdBondingDiscount",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldtimeLockDuration",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newtimeLockDuration",
            type: "uint256"
          }
        ],
        name: "SetERC721IdBondingTimeLock",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetERC721IdOracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldMinBacking",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newMinBacking",
            type: "uint256"
          }
        ],
        name: "SetMinBacking",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "oldTimeLockVault",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newTimeLockVault",
            type: "address"
          }
        ],
        name: "SetTimeLockVault",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetTokenOracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sWithdrawn",
            type: "uint256"
          }
        ],
        name: "WithdrewERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "WithdrewERC721Id",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC20s",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC721Ids",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "erc721",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "id",
                type: "uint256"
              }
            ],
            internalType: "struct IReserve.ERC721Id[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "assetTypeOfERC20",
        outputs: [
          {
            internalType: "enum IReserve.AssetType",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "bondERC20All",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "bondERC20AllFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC20AllFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC20AllTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20From",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20FromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20To",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "bondERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "bondERC721IdFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC721IdFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC721IdTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingDiscountPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "bondingDiscountPerERC721Id",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingTimeLockDurationPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "bondingTimeLockDurationPerERC721Id",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "deregisterERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "deregisterERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "executeTx",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "incurDebt",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Bondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Redeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdBondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdRedeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "minBacking",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "oraclePerERC20",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "oraclePerERC721Id",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "payDebt",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "redeemERC20All",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "redeemERC20AllFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC20AllFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC20AllTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20From",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20FromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20To",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "redeemERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "redeemERC721IdFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC721IdFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC721IdTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "redeemLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "enum IReserve.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            internalType: "enum IReserve.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "registerERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "registerERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC20s",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC721Ids",
        outputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "reserveStatus",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "riskLevelOfERC20",
        outputs: [
          {
            internalType: "enum IReserve.RiskLevel",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          }
        ],
        name: "setBondingDiscountForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          }
        ],
        name: "setBondingDiscountForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "timeLockDuration",
            type: "uint256"
          }
        ],
        name: "setBondingTimeLockForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "timeLockDuration",
            type: "uint256"
          }
        ],
        name: "setBondingTimeLockForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20BondingLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20RedeemLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "minBacking_",
            type: "uint256"
          }
        ],
        name: "setMinBacking",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "timeLockVault_",
            type: "address"
          }
        ],
        name: "setTimeLockVault",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "tokenOracle_",
            type: "address"
          }
        ],
        name: "setTokenOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "timeLockDuration",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Bond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Redemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "timeLockDuration",
            type: "uint256"
          }
        ],
        name: "setupAndListERC721IdBond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "setupAndListERC721IdRedemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "timeLockVault",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "token",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tokenOracle",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateOracleForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateOracleForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "withdrawERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  CuracaoReserveToken: {
    address: "0xeB22fD1Dc0F480faA0D5cce673364b31E5f1e772",
    abi: "ERC20"
  },
  Treasury: {
    address: "0x74b06277Cd1efaA9f6595D25AdB54b4530d15BF5",
    abi: [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "MaxSupplyReached",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20BondingLimitExceeded",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotBondable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotRedeemable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotRegistered",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20RedeemLimitExceeded",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotBondable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotRedeemable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotRegistered",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "Treasury__StaleERC20PriceDeliveredByOracle",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "Treasury__StaleERC721IdPriceDeliveredByOracle",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20Deregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "ERC20OracleUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldPrice",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newPrice",
            type: "uint256"
          }
        ],
        name: "ERC20PriceUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum Treasury.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            indexed: !1,
            internalType: "enum Treasury.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "ERC20Registered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sWithdrawn",
            type: "uint256"
          }
        ],
        name: "ERC20Withdrawn",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsMinted",
            type: "uint256"
          }
        ],
        name: "ERC20sBonded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsBurned",
            type: "uint256"
          }
        ],
        name: "ERC20sRedeemed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDeregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "ERC721IdOracleUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldPrice",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newPrice",
            type: "uint256"
          }
        ],
        name: "ERC721IdPriceUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "ERC721IdRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "ERC721IdWithdrawn",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsMinted",
            type: "uint256"
          }
        ],
        name: "ERC721IdsBonded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsBurned",
            type: "uint256"
          }
        ],
        name: "ERC721IdsRedeemed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "uint256",
            name: "epoch",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newScalar",
            type: "uint256"
          }
        ],
        name: "Rebase",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20RedeemLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "EIP712_DOMAIN",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "EIP712_REVISION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PERMIT_TYPEHASH",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC20s",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC721Ids",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "erc721",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "id",
                type: "uint256"
              }
            ],
            internalType: "struct Treasury.ERC721Id[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner_",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "assetTypeOfERC20",
        outputs: [
          {
            internalType: "enum Treasury.AssetType",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "bondERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "bondERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "deregisterERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "deregisterERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "executeTx",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Bondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Redeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdBondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdRedeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "lastRebase",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "oraclePerERC20",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "oraclePerERC721Id",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "rebase",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "kttWad",
            type: "uint256"
          }
        ],
        name: "redeemERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "redeemERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "redeemLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "enum Treasury.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            internalType: "enum Treasury.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "registerERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "registerERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC20s",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC721Ids",
        outputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "riskLevelOfERC20",
        outputs: [
          {
            internalType: "enum Treasury.RiskLevel",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "scaledBalanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "scaledTotalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20BondingLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20RedeemLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Bond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Redemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalValuation",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "transferAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "transferAllFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateERC20Oracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateERC721IdOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "withdrawERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "Kolektivo Treasury Token": {
    address: "0x74b06277Cd1efaA9f6595D25AdB54b4530d15BF5",
    abi: "ERC20"
  },
  "Mento Exchange": {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "test",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "goldBucket",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "stableBucket",
            type: "uint256"
          }
        ],
        name: "BucketsUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchanger",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "bool",
            name: "soldGold",
            type: "bool"
          }
        ],
        name: "Exchanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "minSupplyForStableBucketCap",
            type: "uint256"
          }
        ],
        name: "MinSupplyForStableBucketCapSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "minimumReports",
            type: "uint256"
          }
        ],
        name: "MinimumReportsSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "reserveFraction",
            type: "uint256"
          }
        ],
        name: "ReserveFractionSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "spread",
            type: "uint256"
          }
        ],
        name: "SpreadSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "stableBucketMaxFraction",
            type: "uint256"
          }
        ],
        name: "StableBucketMaxFractionSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "stable",
            type: "address"
          }
        ],
        name: "StableTokenSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "updateFrequency",
            type: "uint256"
          }
        ],
        name: "UpdateFrequencySet",
        type: "event"
      },
      {
        constant: !1,
        inputs: [],
        name: "activateStable",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxSellAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "buyGold",
            type: "bool"
          }
        ],
        name: "buy",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minBuyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "exchange",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getBuyAndSellBuckets",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getBuyTokenAmount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getSellTokenAmount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getStableBucketCap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "goldBucket",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "string",
            name: "stableTokenIdentifier",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "_spread",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_reserveFraction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_updateFrequency",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_minimumReports",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_minSupplyForStableBucketCap",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_stableBucketMaxFraction",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "initialized",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "lastBucketUpdate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "minSupplyForStableBucketCap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "minimumReports",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "reserveFraction",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minBuyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "sell",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newMinSupplyForStableBucketCap",
            type: "uint256"
          }
        ],
        name: "setMinSupplyForStableBucketCap",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newMininumReports",
            type: "uint256"
          }
        ],
        name: "setMinimumReports",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newReserveFraction",
            type: "uint256"
          }
        ],
        name: "setReserveFraction",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newSpread",
            type: "uint256"
          }
        ],
        name: "setSpread",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newStableBucketMaxFraction",
            type: "uint256"
          }
        ],
        name: "setStableBucketMaxFraction",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "newStableToken",
            type: "address"
          }
        ],
        name: "setStableToken",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newUpdateFrequency",
            type: "uint256"
          }
        ],
        name: "setUpdateFrequency",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "spread",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "stable",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "stableBucket",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "stableBucketMaxFraction",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "stableTokenRegistryId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "updateFrequency",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  "Mento Reserve": {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "test",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bytes32[]",
            name: "symbols",
            type: "bytes32[]"
          },
          {
            indexed: !1,
            internalType: "uint256[]",
            name: "weights",
            type: "uint256[]"
          }
        ],
        name: "AssetAllocationSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "ratio",
            type: "uint256"
          }
        ],
        name: "DailySpendingRatioSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchangeSpender",
            type: "address"
          }
        ],
        name: "ExchangeSpenderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchangeSpender",
            type: "address"
          }
        ],
        name: "ExchangeSpenderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "otherReserveAddress",
            type: "address"
          }
        ],
        name: "OtherReserveAddressAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "otherReserveAddress",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "OtherReserveAddressRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "ReserveGoldTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "SpenderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "SpenderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxReserveRatioSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxStalenessThresholdSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "TokenAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "TokenRemoved",
        type: "event"
      },
      {
        payable: !0,
        stateMutability: "payable",
        type: "fallback"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "addExchangeSpender",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "reserveAddress",
            type: "address"
          }
        ],
        name: "addOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "addSpender",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "addToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "assetAllocationSymbols",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "assetAllocationWeights",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "exchangeSpenderAddresses",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "frozenReserveGoldDays",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "frozenReserveGoldStartBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "frozenReserveGoldStartDay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getAssetAllocationSymbols",
        outputs: [
          {
            internalType: "bytes32[]",
            name: "",
            type: "bytes32[]"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getAssetAllocationWeights",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getDailySpendingRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getExchangeSpenders",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getFrozenReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [],
        name: "getOrComputeTobinTax",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getOtherReserveAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getOtherReserveAddressesGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getReserveRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getTokens",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getUnfrozenBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getUnfrozenReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_tobinTaxStalenessThreshold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_spendingRatio",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_frozenGold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_frozenDays",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "_assetAllocationSymbols",
            type: "bytes32[]"
          },
          {
            internalType: "uint256[]",
            name: "_assetAllocationWeights",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "_tobinTax",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_tobinTaxReserveRatio",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "initialized",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isExchangeSpender",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isSpender",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "lastSpendingDay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "otherReserveAddresses",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeExchangeSpender",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "reserveAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "removeSpender",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "bytes32[]",
            name: "symbols",
            type: "bytes32[]"
          },
          {
            internalType: "uint256[]",
            name: "weights",
            type: "uint256[]"
          }
        ],
        name: "setAssetAllocations",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "ratio",
            type: "uint256"
          }
        ],
        name: "setDailySpendingRatio",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "frozenGold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "frozenDays",
            type: "uint256"
          }
        ],
        name: "setFrozenGold",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTax",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTaxReserveRatio",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTaxStalenessThreshold",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "spendingLimit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "tobinTax",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "tobinTaxCache",
        outputs: [
          {
            internalType: "uint128",
            name: "numerator",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "timestamp",
            type: "uint128"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "tobinTaxReserveRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "tobinTaxStalenessThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address payable",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferExchangeGold",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address payable",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferGold",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "Kolektivo Curacao Guilder Token": {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "test",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "factor",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "lastUpdated",
            type: "uint256"
          }
        ],
        name: "InflationFactorUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "rate",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "updatePeriod",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "lastUpdated",
            type: "uint256"
          }
        ],
        name: "InflationParametersUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "string",
            name: "comment",
            type: "string"
          }
        ],
        name: "TransferComment",
        type: "event"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "accountOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "accountOwner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "blsKey",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "blsPop",
            type: "bytes"
          }
        ],
        name: "checkProofOfPossession",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "feeRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "gatewayFeeRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "communityFund",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "refund",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tipTxFee",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gatewayFee",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseTxFee",
            type: "uint256"
          }
        ],
        name: "creditGasFees",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "debitGasFees",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "aNumerator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "aDenominator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bNumerator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bDenominator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "exponent",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_decimals",
            type: "uint256"
          }
        ],
        name: "fractionMulExp",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "getBlockNumberFromHeader",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getEpochNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getEpochNumberOfBlock",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getEpochSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getExchangeRegistryId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getInflationParameters",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getParentSealBitmap",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "getVerifiedSealBitmapFromHeader",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "hashHeader",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "uint8",
            name: "_decimals",
            type: "uint8"
          },
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "inflationRate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "inflationFactorUpdatePeriod",
            type: "uint256"
          },
          {
            internalType: "address[]",
            name: "initialBalanceAddresses",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "initialBalanceValues",
            type: "uint256[]"
          },
          {
            internalType: "string",
            name: "exchangeIdentifier",
            type: "string"
          }
        ],
        name: "initialize",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "initialized",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "minQuorumSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "minQuorumSizeInCurrentSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "mint",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "numberValidatorsInCurrentSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "numberValidatorsInSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "rate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "updatePeriod",
            type: "uint256"
          }
        ],
        name: "setInflationParameters",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "comment",
            type: "string"
          }
        ],
        name: "transferWithComment",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "units",
            type: "uint256"
          }
        ],
        name: "unitsToValue",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "validatorSignerAddressFromCurrentSet",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "validatorSignerAddressFromSet",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "valueToUnits",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  Vault: {
    address: "0xD25E02047E76b688445ab154785F2642c6fe3f73",
    abi: [
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "liquidityProvider",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            indexed: !1,
            internalType: "int256[]",
            name: "deltas",
            type: "int256[]"
          },
          {
            indexed: !1,
            internalType: "uint256[]",
            name: "protocolFeeAmounts",
            type: "uint256[]"
          }
        ],
        name: "PoolBalanceChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "assetManager",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "int256",
            name: "cashDelta",
            type: "int256"
          },
          {
            indexed: !1,
            internalType: "int256",
            name: "managedDelta",
            type: "int256"
          }
        ],
        name: "PoolBalanceManaged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "poolAddress",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum IVault.PoolSpecialization",
            name: "specialization",
            type: "uint8"
          }
        ],
        name: "PoolRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
          }
        ],
        name: "Swap",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !1,
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          }
        ],
        name: "TokensDeregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !1,
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            indexed: !1,
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          }
        ],
        name: "TokensRegistered",
        type: "event"
      },
      {
        inputs: [],
        name: "WETH",
        outputs: [
          {
            internalType: "contract IWETH",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "assetInIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "assetOutIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.BatchSwapStep[]",
            name: "swaps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          },
          {
            internalType: "int256[]",
            name: "limits",
            type: "int256[]"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        name: "batchSwap",
        outputs: [
          {
            internalType: "int256[]",
            name: "",
            type: "int256[]"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          }
        ],
        name: "deregisterTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            components: [
              {
                internalType: "contract IAsset[]",
                name: "assets",
                type: "address[]"
              },
              {
                internalType: "uint256[]",
                name: "minAmountsOut",
                type: "uint256[]"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.ExitPoolRequest",
            name: "request",
            type: "tuple"
          }
        ],
        name: "exitPool",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          }
        ],
        name: "getPool",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "enum IVault.PoolSpecialization",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          }
        ],
        name: "getPoolTokenInfo",
        outputs: [
          {
            internalType: "uint256",
            name: "cash",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "managed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "assetManager",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          }
        ],
        name: "getPoolTokens",
        outputs: [
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            components: [
              {
                internalType: "contract IAsset[]",
                name: "assets",
                type: "address[]"
              },
              {
                internalType: "uint256[]",
                name: "maxAmountsIn",
                type: "uint256[]"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.JoinPoolRequest",
            name: "request",
            type: "tuple"
          }
        ],
        name: "joinPool",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.PoolBalanceOpKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "contract IERC20",
                name: "token",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              }
            ],
            internalType: "struct IVault.PoolBalanceOp[]",
            name: "ops",
            type: "tuple[]"
          }
        ],
        name: "managePoolBalance",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "assetInIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "assetOutIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.BatchSwapStep[]",
            name: "swaps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          }
        ],
        name: "queryBatchSwap",
        outputs: [
          {
            internalType: "int256[]",
            name: "assetDeltas",
            type: "int256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IVault.PoolSpecialization",
            name: "specialization",
            type: "uint8"
          }
        ],
        name: "registerPool",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          }
        ],
        name: "registerTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IAsset",
                name: "assetIn",
                type: "address"
              },
              {
                internalType: "contract IAsset",
                name: "assetOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.SingleSwap",
            name: "singleSwap",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        name: "swap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      }
    ]
  },
  "Test Token #1": {
    address: "0x4cB13ED364bd2c212B694921CdAca979DCA76054",
    abi: "ERC20"
  },
  cUSD: {
    address: "0x765DE816845861e75A25fCA122bb6898B8B1282a",
    abi: "ERC20"
  },
  "Test Token #2": {
    address: "0x5bFE78b0d15eF0cdcA4077336e0bEbEc15CFb142",
    abi: "ERC20"
  },
  "Test Token #3": {
    address: "0xd312bCeA257799a39e0C85d7EC45031612e4dd50",
    abi: "ERC20"
  },
  "GeoNFT #1": {
    address: "0x9fC5461A1e6CF567C7E19Befa7c0351C9C6CB719",
    id: 1,
    abi: "ERC721"
  },
  "GeoNFT #2": {
    address: "0x9fC5461A1e6CF567C7E19Befa7c0351C9C6CB719",
    id: 2,
    abi: "ERC721"
  },
  "kGuilder Pool": {
    address: "0x637A8Dc2343ef517451bE63f1D5164AD7fF53FC9",
    abi: [
      {
        inputs: [
          {
            internalType: "contract IVault",
            name: "vault",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "amplificationParameter",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pauseWindowDuration",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodDuration",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "startValue",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "endValue",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "startTime",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          }
        ],
        name: "AmpUpdateStarted",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "currentValue",
            type: "uint256"
          }
        ],
        name: "AmpUpdateStopped",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "PausedStateChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "SwapFeePercentageChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "selector",
            type: "bytes4"
          }
        ],
        name: "getActionId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAmplificationParameter",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isUpdating",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "precision",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAuthorizer",
        outputs: [
          {
            internalType: "contract IAuthorizer",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getLastInvariant",
        outputs: [
          {
            internalType: "uint256",
            name: "lastInvariant",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "lastInvariantAmp",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPausedState",
        outputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "pauseWindowEndTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodEndTime",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPoolId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getRate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getScalingFactors",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getSwapFeePercentage",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVault",
        outputs: [
          {
            internalType: "contract IVault",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "addedValue",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onExitPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onJoinPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IERC20",
                name: "tokenIn",
                type: "address"
              },
              {
                internalType: "contract IERC20",
                name: "tokenOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "lastChangeBlock",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "from",
                type: "address"
              },
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IPoolSwapStructs.SwapRequest",
            name: "swapRequest",
            type: "tuple"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "indexIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "indexOut",
            type: "uint256"
          }
        ],
        name: "onSwap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IERC20",
                name: "tokenIn",
                type: "address"
              },
              {
                internalType: "contract IERC20",
                name: "tokenOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "lastChangeBlock",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "from",
                type: "address"
              },
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IPoolSwapStructs.SwapRequest",
            name: "request",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "balanceTokenIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "balanceTokenOut",
            type: "uint256"
          }
        ],
        name: "onSwap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryExit",
        outputs: [
          {
            internalType: "uint256",
            name: "bptIn",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsOut",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryJoin",
        outputs: [
          {
            internalType: "uint256",
            name: "bptOut",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsIn",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "poolConfig",
            type: "bytes"
          }
        ],
        name: "setAssetManagerPoolConfig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "setPaused",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "setSwapFeePercentage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "rawEndValue",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          }
        ],
        name: "startAmplificationParameterUpdate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "stopAmplificationParameterUpdate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "kCur Pool": {
    address: "0xfe4a8b11fd4735e96454b056cf6422aacad1c880",
    abi: [
      {
        inputs: [
          {
            internalType: "contract IVault",
            name: "vault",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "normalizedWeights",
            type: "uint256[]"
          },
          {
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pauseWindowDuration",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodDuration",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "PausedStateChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "SwapFeePercentageChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "selector",
            type: "bytes4"
          }
        ],
        name: "getActionId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAuthorizer",
        outputs: [
          {
            internalType: "contract IAuthorizer",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getInvariant",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getLastInvariant",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getNormalizedWeights",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPausedState",
        outputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "pauseWindowEndTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodEndTime",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPoolId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getRate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getScalingFactors",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getSwapFeePercentage",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVault",
        outputs: [
          {
            internalType: "contract IVault",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "addedValue",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onExitPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onJoinPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IERC20",
                name: "tokenIn",
                type: "address"
              },
              {
                internalType: "contract IERC20",
                name: "tokenOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "lastChangeBlock",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "from",
                type: "address"
              },
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IPoolSwapStructs.SwapRequest",
            name: "request",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "balanceTokenIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "balanceTokenOut",
            type: "uint256"
          }
        ],
        name: "onSwap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryExit",
        outputs: [
          {
            internalType: "uint256",
            name: "bptIn",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsOut",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryJoin",
        outputs: [
          {
            internalType: "uint256",
            name: "bptOut",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsIn",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "poolConfig",
            type: "bytes"
          }
        ],
        name: "setAssetManagerPoolConfig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "setPaused",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "setSwapFeePercentage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  TimeLockVault: {
    address: "0xFcAb95D9577bBA5c3203852DE98dD2730ce17452",
    abi: [
      {
        inputs: [],
        name: "InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidDuration",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "SenderCantLock",
        type: "error"
      },
      {
        inputs: [],
        name: "UserHasNoLocks",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "Claimed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "unlockAt",
            type: "uint256"
          }
        ],
        name: "Locked",
        type: "event"
      },
      {
        inputs: [],
        name: "claim",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "claimAt",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "claimToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          }
        ],
        name: "getLocksOf",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "token",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "unlockAt",
                type: "uint256"
              }
            ],
            internalType: "struct TimeLockVault.Lock[]",
            name: "locks",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "locker",
            type: "address"
          }
        ],
        name: "isLocker",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "receiver",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "duration",
            type: "uint256"
          }
        ],
        name: "lock",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  SortedOracles: {
    address: "0x48c501A5D2cb50f4F6F6181F6e59Fa2bA7510a84",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "newBreakerBox",
            type: "address"
          }
        ],
        name: "BreakerBoxUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "MedianUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracleAddress",
            type: "address"
          }
        ],
        name: "OracleAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracleAddress",
            type: "address"
          }
        ],
        name: "OracleRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "OracleReportRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "OracleReported",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "reportExpiry",
            type: "uint256"
          }
        ],
        name: "ReportExpirySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "reportExpiry",
            type: "uint256"
          }
        ],
        name: "TokenReportExpirySet",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracleAddress",
            type: "address"
          }
        ],
        name: "addOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "breakerBox",
        outputs: [
          {
            internalType: "contract IBreakerBox",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "getOracles",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "getRates",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "enum SortedLinkedListWithMedian.MedianRelation[]",
            name: "",
            type: "uint8[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "getTimestamps",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "enum SortedLinkedListWithMedian.MedianRelation[]",
            name: "",
            type: "uint8[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "getTokenReportExpirySeconds",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_reportExpirySeconds",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "isOldestReportExpired",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isOracle",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "medianRate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "medianTimestamp",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "numRates",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "numTimestamps",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "oracles",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "n",
            type: "uint256"
          }
        ],
        name: "removeExpiredReports",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracleAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "lesserKey",
            type: "address"
          },
          {
            internalType: "address",
            name: "greaterKey",
            type: "address"
          }
        ],
        name: "report",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "reportExpirySeconds",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IBreakerBox",
            name: "newBreakerBox",
            type: "address"
          }
        ],
        name: "setBreakerBox",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "_reportExpirySeconds",
            type: "uint256"
          }
        ],
        name: "setReportExpiry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "_token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_reportExpirySeconds",
            type: "uint256"
          }
        ],
        name: "setTokenReportExpiry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "tokenReportExpirySeconds",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  KolektivoGuilder: {
    address: "0xA7631e5770B7c8B5BD02dEbfb0f3B0f70045C70F",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bytes32",
            name: "oldId",
            type: "bytes32"
          },
          {
            indexed: !1,
            internalType: "bytes32",
            name: "newId",
            type: "bytes32"
          }
        ],
        name: "ExchangeIdentifierUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "factor",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "lastUpdated",
            type: "uint256"
          }
        ],
        name: "InflationFactorUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "rate",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "updatePeriod",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "lastUpdated",
            type: "uint256"
          }
        ],
        name: "InflationParametersUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "string",
            name: "comment",
            type: "string"
          }
        ],
        name: "TransferComment",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "accountOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "accountOwner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "blsKey",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "blsPop",
            type: "bytes"
          }
        ],
        name: "checkProofOfPossession",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "feeRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "gatewayFeeRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "communityFund",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "refund",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tipTxFee",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gatewayFee",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseTxFee",
            type: "uint256"
          }
        ],
        name: "creditGasFees",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "debitGasFees",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "aNumerator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "aDenominator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bNumerator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bDenominator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "exponent",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_decimals",
            type: "uint256"
          }
        ],
        name: "fractionMulExp",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "getBlockNumberFromHeader",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getEpochNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getEpochNumberOfBlock",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getEpochSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getExchangeRegistryId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getInflationParameters",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getParentSealBitmap",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "getVerifiedSealBitmapFromHeader",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "hashHeader",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "uint8",
            name: "_decimals",
            type: "uint8"
          },
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "inflationRate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "inflationFactorUpdatePeriod",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "exchangeIdentifier",
            type: "string"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "minQuorumSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "minQuorumSizeInCurrentSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "mint",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "numberValidatorsInCurrentSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "numberValidatorsInSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "exchangeIdentifier",
            type: "string"
          }
        ],
        name: "setExchangeRegistryId",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "rate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "updatePeriod",
            type: "uint256"
          }
        ],
        name: "setInflationParameters",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "comment",
            type: "string"
          }
        ],
        name: "transferWithComment",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "units",
            type: "uint256"
          }
        ],
        name: "unitsToValue",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "validatorSignerAddressFromCurrentSet",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "validatorSignerAddressFromSet",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "valueToUnits",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  MentoExchange: {
    address: "0x1f09b9a17Bb3FAaB096a5517E3d007CEea0ab86b",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "goldBucket",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "stableBucket",
            type: "uint256"
          }
        ],
        name: "BucketsUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchanger",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "bool",
            name: "soldGold",
            type: "bool"
          }
        ],
        name: "Exchanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "minimumReports",
            type: "uint256"
          }
        ],
        name: "MinimumReportsSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "reserveFraction",
            type: "uint256"
          }
        ],
        name: "ReserveFractionSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "spread",
            type: "uint256"
          }
        ],
        name: "SpreadSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "stable",
            type: "address"
          }
        ],
        name: "StableTokenSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "updateFrequency",
            type: "uint256"
          }
        ],
        name: "UpdateFrequencySet",
        type: "event"
      },
      {
        inputs: [],
        name: "activateStable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxSellAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "buyGold",
            type: "bool"
          }
        ],
        name: "buy",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minBuyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "exchange",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getBuyAndSellBuckets",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getBuyTokenAmount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getSellTokenAmount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [],
        name: "goldBucket",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "string",
            name: "stableTokenIdentifier",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "_spread",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_reserveFraction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_updateFrequency",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_minimumReports",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "lastBucketUpdate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "minimumReports",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "reserveFraction",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minBuyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "sell",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newMininumReports",
            type: "uint256"
          }
        ],
        name: "setMinimumReports",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newReserveFraction",
            type: "uint256"
          }
        ],
        name: "setReserveFraction",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newSpread",
            type: "uint256"
          }
        ],
        name: "setSpread",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newStableToken",
            type: "address"
          }
        ],
        name: "setStableToken",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "newUpdateFrequency",
            type: "uint256"
          }
        ],
        name: "setUpdateFrequency",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "spread",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "stable",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "stableBucket",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "stableTokenRegistryId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "updateFrequency",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  MentoReserve: {
    address: "0xD182A31EAbb71776BCE5000A2714a5451177815C",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bytes32[]",
            name: "symbols",
            type: "bytes32[]"
          },
          {
            indexed: !1,
            internalType: "uint256[]",
            name: "weights",
            type: "uint256[]"
          }
        ],
        name: "AssetAllocationSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "ratio",
            type: "uint256"
          }
        ],
        name: "DailySpendingRatioSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchangeSpender",
            type: "address"
          }
        ],
        name: "ExchangeSpenderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchangeSpender",
            type: "address"
          }
        ],
        name: "ExchangeSpenderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "otherReserveAddress",
            type: "address"
          }
        ],
        name: "OtherReserveAddressAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "otherReserveAddress",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "OtherReserveAddressRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "ReserveGoldTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "SpenderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "SpenderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxReserveRatioSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxStalenessThresholdSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "TokenAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "TokenRemoved",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "addExchangeSpender",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "reserveAddress",
            type: "address"
          }
        ],
        name: "addOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "addSpender",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "addToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "assetAllocationSymbols",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "assetAllocationWeights",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "exchangeSpenderAddresses",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "frozenReserveGoldDays",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "frozenReserveGoldStartBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "frozenReserveGoldStartDay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAssetAllocationSymbols",
        outputs: [
          {
            internalType: "bytes32[]",
            name: "",
            type: "bytes32[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAssetAllocationWeights",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getDailySpendingRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getExchangeSpenders",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getFrozenReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOrComputeTobinTax",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getOtherReserveAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOtherReserveAddressesGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getReserveRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getTokens",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getUnfrozenBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getUnfrozenReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_tobinTaxStalenessThreshold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_spendingRatio",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_frozenGold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_frozenDays",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "_assetAllocationSymbols",
            type: "bytes32[]"
          },
          {
            internalType: "uint256[]",
            name: "_assetAllocationWeights",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "_tobinTax",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_tobinTaxReserveRatio",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isExchangeSpender",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isSpender",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "lastSpendingDay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "otherReserveAddresses",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeExchangeSpender",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "reserveAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "removeSpender",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32[]",
            name: "symbols",
            type: "bytes32[]"
          },
          {
            internalType: "uint256[]",
            name: "weights",
            type: "uint256[]"
          }
        ],
        name: "setAssetAllocations",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "ratio",
            type: "uint256"
          }
        ],
        name: "setDailySpendingRatio",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "frozenGold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "frozenDays",
            type: "uint256"
          }
        ],
        name: "setFrozenGold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTax",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTaxReserveRatio",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTaxStalenessThreshold",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "spendingLimit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tobinTax",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tobinTaxCache",
        outputs: [
          {
            internalType: "uint128",
            name: "numerator",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "timestamp",
            type: "uint128"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tobinTaxReserveRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tobinTaxStalenessThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferExchangeGold",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address payable",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferGold",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  MentoRegistry: {
    address: "0x8c6f30915DB8DC01Dfc0De5e829781F611DDBc30",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "string",
            name: "identifier",
            type: "string"
          },
          {
            indexed: !0,
            internalType: "bytes32",
            name: "identifierHash",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "addr",
            type: "address"
          }
        ],
        name: "RegistryUpdated",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "identifierHash",
            type: "bytes32"
          }
        ],
        name: "getAddressFor",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "identifierHash",
            type: "bytes32"
          }
        ],
        name: "getAddressForOrDie",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "getAddressForString",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "getAddressForStringOrDie",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32[]",
            name: "identifierHashes",
            type: "bytes32[]"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          }
        ],
        name: "isOneOf",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "registry",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          },
          {
            internalType: "address",
            name: "addr",
            type: "address"
          }
        ],
        name: "setAddressFor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Freezer: {
    address: "0x5f81cfAFe84E2148B216c221651ED21d60075E99",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "isImplementation",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint8",
            name: "version",
            type: "uint8"
          }
        ],
        name: "Initialized",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          }
        ],
        name: "freeze",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isFrozen",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          }
        ],
        name: "unfreeze",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  }
}, mN = {
  name: Tw,
  chainId: ww,
  contracts: Aw
}, bN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  chainId: ww,
  contracts: Aw,
  default: mN,
  name: Tw
}, Symbol.toStringTag, { value: "Module" })), Ew = "celo", Sw = 42220, Mw = {}, gN = {
  name: Ew,
  chainId: Sw,
  contracts: Mw
}, vN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  chainId: Sw,
  contracts: Mw,
  default: gN,
  name: Ew
}, Symbol.toStringTag, { value: "Module" })), Cw = "celo", _w = "42220", Rw = {}, xN = {
  name: Cw,
  chainId: _w,
  contracts: Rw
}, TN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  chainId: _w,
  contracts: Rw,
  default: xN,
  name: Cw
}, Symbol.toStringTag, { value: "Module" })), kw = "celo", Pw = "42220", Iw = {
  GeoNFT: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidIdentifier",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidLatitude",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidLongitude",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "GeoNFT__InvalidTokenId",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "ApprovalForAll",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "TokenModified",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "getApproved",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isApprovedForAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "int32",
            name: "latitude",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "longitude",
            type: "int32"
          },
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "mint",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "int32",
            name: "latitude",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "longitude",
            type: "int32"
          },
          {
            internalType: "string",
            name: "identifier",
            type: "string"
          }
        ],
        name: "modify",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ownerOf",
        outputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "safeTransferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "operator",
            type: "address"
          },
          {
            internalType: "bool",
            name: "approved",
            type: "bool"
          }
        ],
        name: "setApprovalForAll",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "interfaceId",
            type: "bytes4"
          }
        ],
        name: "supportsInterface",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "tokenData",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "int32",
            name: "",
            type: "int32"
          },
          {
            internalType: "int32",
            name: "",
            type: "int32"
          },
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "tokenURI",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Oracle: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "uint256",
            name: "reportExpirationTime_",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "reportDelay_",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minimumProviders_",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "invalidProvider",
            type: "address"
          }
        ],
        name: "Oracle__InvalidProvider",
        type: "error"
      },
      {
        inputs: [],
        name: "Oracle__NewReportTooSoonAfterPastReport",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldMinimumProviders",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newMinimumProviders",
            type: "uint256"
          }
        ],
        name: "MinimumProvidersChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [],
        name: "OracleMarkedAsInvalid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [],
        name: "OracleMarkedAsValid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          }
        ],
        name: "ProviderReportPushed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "purger",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "ProviderReportsPurged",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "addProvider",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "getData",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "isValid",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "minimumProviders",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "providerReports",
        outputs: [
          {
            internalType: "uint256",
            name: "timestamp",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "providers",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "providersSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "purgeReports",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "purgeReportsFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "payload",
            type: "uint256"
          }
        ],
        name: "pushReport",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "provider",
            type: "address"
          }
        ],
        name: "removeProvider",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "reportDelay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "reportExpirationTime",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "isValid_",
            type: "bool"
          }
        ],
        name: "setIsValid",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "minimumProviders_",
            type: "uint256"
          }
        ],
        name: "setMinimumProviders",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  Reserve: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "address",
            name: "token_",
            type: "address"
          },
          {
            internalType: "address",
            name: "tokenOracle_",
            type: "address"
          },
          {
            internalType: "address",
            name: "vestingVault_",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "minBacking_",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20BalanceNotSufficient",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20BondingLimitExceeded",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotBondable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotRedeemable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20NotRegistered",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC20RedeemLimitExceeded",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotBondable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotRedeemable",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__ERC721IdNotRegistered",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidOracle",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "Reserve__MinimumBackingLimitExceeded",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldBacking",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newBacking",
            type: "uint256"
          }
        ],
        name: "BackingUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sBonded",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensMinted",
            type: "uint256"
          }
        ],
        name: "BondedERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensMinted",
            type: "uint256"
          }
        ],
        name: "BondedERC721",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "DebtIncurred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "DebtPaid",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20Deregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum IReserve.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            indexed: !1,
            internalType: "enum IReserve.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "ERC20Registered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDeregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sRedeemed",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensBurned",
            type: "uint256"
          }
        ],
        name: "RedeemedERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "tokensBurned",
            type: "uint256"
          }
        ],
        name: "RedeemedERC721Id",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldDiscount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newDiscount",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingDiscount",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldVestingDuration",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newVestingDuration",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingVesting",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetERC20Oracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20RedeemLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldDiscount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newDiscount",
            type: "uint256"
          }
        ],
        name: "SetERC721IdBondingDiscount",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldVestingDuration",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newVestingDuration",
            type: "uint256"
          }
        ],
        name: "SetERC721IdBondingVesting",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetERC721IdOracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldMinBacking",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newMinBacking",
            type: "uint256"
          }
        ],
        name: "SetMinBacking",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "SetTokenOracle",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "oldVestingVault",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newVestingVault",
            type: "address"
          }
        ],
        name: "SetVestingVault",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sWithdrawn",
            type: "uint256"
          }
        ],
        name: "WithdrewERC20",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "WithdrewERC721Id",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC20s",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC721Ids",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "erc721",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "id",
                type: "uint256"
              }
            ],
            internalType: "struct IReserve.ERC721Id[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "assetTypeOfERC20",
        outputs: [
          {
            internalType: "enum IReserve.AssetType",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "bondERC20All",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "bondERC20AllFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC20AllFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC20AllTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20From",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20FromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "erc20Amount",
            type: "uint256"
          }
        ],
        name: "bondERC20To",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "bondERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "bondERC721IdFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC721IdFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "bondERC721IdTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingDiscountPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "bondingDiscountPerERC721Id",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingVestingDurationPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "bondingVestingDurationPerERC721Id",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "deregisterERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "deregisterERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "executeTx",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "incurDebt",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Bondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Redeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdBondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdRedeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "minBacking",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "oraclePerERC20",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "oraclePerERC721Id",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "payDebt",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "redeemERC20All",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "redeemERC20AllFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC20AllFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC20AllTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20From",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20FromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokenAmount",
            type: "uint256"
          }
        ],
        name: "redeemERC20To",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "redeemERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          }
        ],
        name: "redeemERC721IdFrom",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC721IdFromTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "redeemERC721IdTo",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "redeemLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "enum IReserve.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            internalType: "enum IReserve.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "registerERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "registerERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC20s",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC721Ids",
        outputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "reserveStatus",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "riskLevelOfERC20",
        outputs: [
          {
            internalType: "enum IReserve.RiskLevel",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          }
        ],
        name: "setBondingDiscountForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          }
        ],
        name: "setBondingDiscountForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "vestingDuration",
            type: "uint256"
          }
        ],
        name: "setBondingVestingForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "vestingDuration",
            type: "uint256"
          }
        ],
        name: "setBondingVestingForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20BondingLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20RedeemLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "minBacking_",
            type: "uint256"
          }
        ],
        name: "setMinBacking",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "tokenOracle_",
            type: "address"
          }
        ],
        name: "setTokenOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "vestingVault_",
            type: "address"
          }
        ],
        name: "setVestingVault",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "vestingDuration",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Bond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Redemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "discount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "vestingDuration",
            type: "uint256"
          }
        ],
        name: "setupAndListERC721IdBond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "setupAndListERC721IdRedemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "token",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "tokenOracle",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateOracleForERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateOracleForERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "vestingVault",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "withdrawERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "Kolektivo Curacao Reserve Token": {
    address: "0x0000000000000000000000000000000000000000",
    abi: "ERC20"
  },
  Treasury: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        inputs: [],
        name: "InvalidAmount",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "InvalidRecipient",
        type: "error"
      },
      {
        inputs: [],
        name: "MaxSupplyReached",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20BondingLimitExceeded",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotBondable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotRedeemable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20IsNotRegistered",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "Treasury__ERC20RedeemLimitExceeded",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotBondable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotRedeemable",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "Treasury__ERC721IdIsNotRegistered",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "Treasury__StaleERC20PriceDeliveredByOracle",
        type: "error"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "Treasury__StaleERC721IdPriceDeliveredByOracle",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20DelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20Deregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "ERC20ListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "ERC20OracleUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldPrice",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newPrice",
            type: "uint256"
          }
        ],
        name: "ERC20PriceUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum Treasury.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            indexed: !1,
            internalType: "enum Treasury.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "ERC20Registered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "erc20sWithdrawn",
            type: "uint256"
          }
        ],
        name: "ERC20Withdrawn",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsMinted",
            type: "uint256"
          }
        ],
        name: "ERC20sBonded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsBurned",
            type: "uint256"
          }
        ],
        name: "ERC20sRedeemed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDelistedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdDeregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsBondable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "ERC721IdListedAsRedeemable",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "oldOracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "address",
            name: "newOracle",
            type: "address"
          }
        ],
        name: "ERC721IdOracleUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldPrice",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newPrice",
            type: "uint256"
          }
        ],
        name: "ERC721IdPriceUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "ERC721IdRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "ERC721IdWithdrawn",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsMinted",
            type: "uint256"
          }
        ],
        name: "ERC721IdsBonded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "who",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "kttsBurned",
            type: "uint256"
          }
        ],
        name: "ERC721IdsRedeemed",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "uint256",
            name: "epoch",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newScalar",
            type: "uint256"
          }
        ],
        name: "Rebase",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20BondingLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "oldLimit",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "newLimit",
            type: "uint256"
          }
        ],
        name: "SetERC20RedeemLimit",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "EIP712_DOMAIN",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "EIP712_REVISION",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "PERMIT_TYPEHASH",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC20s",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "allRegisteredERC721Ids",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "erc721",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "id",
                type: "uint256"
              }
            ],
            internalType: "struct Treasury.ERC721Id[]",
            name: "",
            type: "tuple[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner_",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "assetTypeOfERC20",
        outputs: [
          {
            internalType: "enum Treasury.AssetType",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "bondERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "bondERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "bondingLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "delistERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "delistERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "deregisterERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "deregisterERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "target",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "data",
            type: "bytes"
          }
        ],
        name: "executeTx",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Bondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isERC20Redeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdBondable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "isERC721IdRedeemable",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "lastRebase",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          }
        ],
        name: "listERC20AsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsBondable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "listERC721IdAsRedeemable",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "",
            type: "bytes"
          }
        ],
        name: "onERC721Received",
        outputs: [
          {
            internalType: "bytes4",
            name: "",
            type: "bytes4"
          }
        ],
        stateMutability: "pure",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "oraclePerERC20",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "oraclePerERC721Id",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "rebase",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "kttWad",
            type: "uint256"
          }
        ],
        name: "redeemERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        name: "redeemERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "redeemLimitPerERC20",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          },
          {
            internalType: "enum Treasury.AssetType",
            name: "assetType",
            type: "uint8"
          },
          {
            internalType: "enum Treasury.RiskLevel",
            name: "riskLevel",
            type: "uint8"
          }
        ],
        name: "registerERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "registerERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC20s",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "registeredERC721Ids",
        outputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "riskLevelOfERC20",
        outputs: [
          {
            internalType: "enum Treasury.RiskLevel",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "who",
            type: "address"
          }
        ],
        name: "scaledBalanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "scaledTotalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20BondingLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setERC20RedeemLimit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Bond",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          }
        ],
        name: "setupAndListERC20Redemption",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalValuation",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "transferAll",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          }
        ],
        name: "transferAllFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "tokens",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateERC20Oracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "oracle",
            type: "address"
          }
        ],
        name: "updateERC721IdOracle",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc20",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "withdrawERC20",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "erc721",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "withdrawERC721Id",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "Kolektivo Treasury Token": {
    address: "0x0000000000000000000000000000000000000000",
    abi: "ERC20"
  },
  "Mento Exchange": {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "test",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "goldBucket",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "stableBucket",
            type: "uint256"
          }
        ],
        name: "BucketsUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchanger",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "bool",
            name: "soldGold",
            type: "bool"
          }
        ],
        name: "Exchanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "minSupplyForStableBucketCap",
            type: "uint256"
          }
        ],
        name: "MinSupplyForStableBucketCapSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "minimumReports",
            type: "uint256"
          }
        ],
        name: "MinimumReportsSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "reserveFraction",
            type: "uint256"
          }
        ],
        name: "ReserveFractionSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "spread",
            type: "uint256"
          }
        ],
        name: "SpreadSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "stableBucketMaxFraction",
            type: "uint256"
          }
        ],
        name: "StableBucketMaxFractionSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "stable",
            type: "address"
          }
        ],
        name: "StableTokenSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "updateFrequency",
            type: "uint256"
          }
        ],
        name: "UpdateFrequencySet",
        type: "event"
      },
      {
        constant: !1,
        inputs: [],
        name: "activateStable",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "maxSellAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "buyGold",
            type: "bool"
          }
        ],
        name: "buy",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minBuyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "exchange",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getBuyAndSellBuckets",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getBuyTokenAmount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "buyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "getSellTokenAmount",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getStableBucketCap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "goldBucket",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "string",
            name: "stableTokenIdentifier",
            type: "string"
          },
          {
            internalType: "uint256",
            name: "_spread",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_reserveFraction",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_updateFrequency",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_minimumReports",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_minSupplyForStableBucketCap",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_stableBucketMaxFraction",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "initialized",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "lastBucketUpdate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "minSupplyForStableBucketCap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "minimumReports",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "reserveFraction",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "sellAmount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "minBuyAmount",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "sellGold",
            type: "bool"
          }
        ],
        name: "sell",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newMinSupplyForStableBucketCap",
            type: "uint256"
          }
        ],
        name: "setMinSupplyForStableBucketCap",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newMininumReports",
            type: "uint256"
          }
        ],
        name: "setMinimumReports",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newReserveFraction",
            type: "uint256"
          }
        ],
        name: "setReserveFraction",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newSpread",
            type: "uint256"
          }
        ],
        name: "setSpread",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newStableBucketMaxFraction",
            type: "uint256"
          }
        ],
        name: "setStableBucketMaxFraction",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "newStableToken",
            type: "address"
          }
        ],
        name: "setStableToken",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "newUpdateFrequency",
            type: "uint256"
          }
        ],
        name: "setUpdateFrequency",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "spread",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "stable",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "stableBucket",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "stableBucketMaxFraction",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "stableTokenRegistryId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "updateFrequency",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  "Mento Reserve": {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "test",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bytes32[]",
            name: "symbols",
            type: "bytes32[]"
          },
          {
            indexed: !1,
            internalType: "uint256[]",
            name: "weights",
            type: "uint256[]"
          }
        ],
        name: "AssetAllocationSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "ratio",
            type: "uint256"
          }
        ],
        name: "DailySpendingRatioSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchangeSpender",
            type: "address"
          }
        ],
        name: "ExchangeSpenderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "exchangeSpender",
            type: "address"
          }
        ],
        name: "ExchangeSpenderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "otherReserveAddress",
            type: "address"
          }
        ],
        name: "OtherReserveAddressAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "otherReserveAddress",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "OtherReserveAddressRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "ReserveGoldTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "SpenderAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "SpenderRemoved",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxReserveRatioSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "TobinTaxStalenessThresholdSet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "TokenAdded",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "TokenRemoved",
        type: "event"
      },
      {
        payable: !0,
        stateMutability: "payable",
        type: "fallback"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "addExchangeSpender",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "reserveAddress",
            type: "address"
          }
        ],
        name: "addOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "addSpender",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          }
        ],
        name: "addToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "assetAllocationSymbols",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        name: "assetAllocationWeights",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "exchangeSpenderAddresses",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "frozenReserveGoldDays",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "frozenReserveGoldStartBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "frozenReserveGoldStartDay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getAssetAllocationSymbols",
        outputs: [
          {
            internalType: "bytes32[]",
            name: "",
            type: "bytes32[]"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getAssetAllocationWeights",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getDailySpendingRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getExchangeSpenders",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getFrozenReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [],
        name: "getOrComputeTobinTax",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getOtherReserveAddresses",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getOtherReserveAddressesGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getReserveRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getTokens",
        outputs: [
          {
            internalType: "address[]",
            name: "",
            type: "address[]"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getUnfrozenBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getUnfrozenReserveGoldBalance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "_tobinTaxStalenessThreshold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_spendingRatio",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_frozenGold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_frozenDays",
            type: "uint256"
          },
          {
            internalType: "bytes32[]",
            name: "_assetAllocationSymbols",
            type: "bytes32[]"
          },
          {
            internalType: "uint256[]",
            name: "_assetAllocationWeights",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "_tobinTax",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_tobinTaxReserveRatio",
            type: "uint256"
          }
        ],
        name: "initialize",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "initialized",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isExchangeSpender",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isSpender",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        name: "isToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "lastSpendingDay",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        name: "otherReserveAddresses",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeExchangeSpender",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "reserveAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeOtherReserveAddress",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "removeSpender",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "token",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "removeToken",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "bytes32[]",
            name: "symbols",
            type: "bytes32[]"
          },
          {
            internalType: "uint256[]",
            name: "weights",
            type: "uint256[]"
          }
        ],
        name: "setAssetAllocations",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "ratio",
            type: "uint256"
          }
        ],
        name: "setDailySpendingRatio",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "frozenGold",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "frozenDays",
            type: "uint256"
          }
        ],
        name: "setFrozenGold",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTax",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTaxReserveRatio",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "setTobinTaxStalenessThreshold",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "spendingLimit",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "tobinTax",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "tobinTaxCache",
        outputs: [
          {
            internalType: "uint128",
            name: "numerator",
            type: "uint128"
          },
          {
            internalType: "uint128",
            name: "timestamp",
            type: "uint128"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "tobinTaxReserveRatio",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "tobinTaxStalenessThreshold",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address payable",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferExchangeGold",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address payable",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferGold",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "Kolektivo Curacao Guilder Token": {
    address: "0x9E1ACEF9AA38b42f2C413f32d440f0F1Db53EDEc",
    abi: [
      {
        inputs: [
          {
            internalType: "bool",
            name: "test",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "factor",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "lastUpdated",
            type: "uint256"
          }
        ],
        name: "InflationFactorUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "rate",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "updatePeriod",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "lastUpdated",
            type: "uint256"
          }
        ],
        name: "InflationParametersUpdated",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "RegistrySet",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "string",
            name: "comment",
            type: "string"
          }
        ],
        name: "TransferComment",
        type: "event"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "accountOwner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "accountOwner",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "burn",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "blsKey",
            type: "bytes"
          },
          {
            internalType: "bytes",
            name: "blsPop",
            type: "bytes"
          }
        ],
        name: "checkProofOfPossession",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "feeRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "gatewayFeeRecipient",
            type: "address"
          },
          {
            internalType: "address",
            name: "communityFund",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "refund",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "tipTxFee",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "gatewayFee",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "baseTxFee",
            type: "uint256"
          }
        ],
        name: "creditGasFees",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "debitGasFees",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "aNumerator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "aDenominator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bNumerator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bDenominator",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "exponent",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "_decimals",
            type: "uint256"
          }
        ],
        name: "fractionMulExp",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "getBlockNumberFromHeader",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getEpochNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getEpochNumberOfBlock",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getEpochSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getExchangeRegistryId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getInflationParameters",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "getParentSealBitmap",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "getVerifiedSealBitmapFromHeader",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "getVersionNumber",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "pure",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "bytes",
            name: "header",
            type: "bytes"
          }
        ],
        name: "hashHeader",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "string",
            name: "_name",
            type: "string"
          },
          {
            internalType: "string",
            name: "_symbol",
            type: "string"
          },
          {
            internalType: "uint8",
            name: "_decimals",
            type: "uint8"
          },
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "inflationRate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "inflationFactorUpdatePeriod",
            type: "uint256"
          },
          {
            internalType: "address[]",
            name: "initialBalanceAddresses",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "initialBalanceValues",
            type: "uint256[]"
          },
          {
            internalType: "string",
            name: "exchangeIdentifier",
            type: "string"
          }
        ],
        name: "initialize",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "initialized",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "isOwner",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "minQuorumSize",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "minQuorumSizeInCurrentSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "mint",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "numberValidatorsInCurrentSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "numberValidatorsInSet",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "registry",
        outputs: [
          {
            internalType: "contract IRegistry",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "uint256",
            name: "rate",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "updatePeriod",
            type: "uint256"
          }
        ],
        name: "setInflationParameters",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "registryAddress",
            type: "address"
          }
        ],
        name: "setRegistry",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !1,
        inputs: [
          {
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "string",
            name: "comment",
            type: "string"
          }
        ],
        name: "transferWithComment",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        payable: !1,
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "units",
            type: "uint256"
          }
        ],
        name: "unitsToValue",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          }
        ],
        name: "validatorSignerAddressFromCurrentSet",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "index",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "blockNumber",
            type: "uint256"
          }
        ],
        name: "validatorSignerAddressFromSet",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      },
      {
        constant: !0,
        inputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "valueToUnits",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        payable: !1,
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  "Symmetric-Vault": {
    address: "0xD25E02047E76b688445ab154785F2642c6fe3f73",
    abi: [
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "liquidityProvider",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            indexed: !1,
            internalType: "int256[]",
            name: "deltas",
            type: "int256[]"
          },
          {
            indexed: !1,
            internalType: "uint256[]",
            name: "protocolFeeAmounts",
            type: "uint256[]"
          }
        ],
        name: "PoolBalanceChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "assetManager",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "int256",
            name: "cashDelta",
            type: "int256"
          },
          {
            indexed: !1,
            internalType: "int256",
            name: "managedDelta",
            type: "int256"
          }
        ],
        name: "PoolBalanceManaged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "poolAddress",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "enum IVault.PoolSpecialization",
            name: "specialization",
            type: "uint8"
          }
        ],
        name: "PoolRegistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !0,
            internalType: "contract IERC20",
            name: "tokenIn",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "contract IERC20",
            name: "tokenOut",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amountIn",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "amountOut",
            type: "uint256"
          }
        ],
        name: "Swap",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !1,
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          }
        ],
        name: "TokensDeregistered",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            indexed: !1,
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            indexed: !1,
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          }
        ],
        name: "TokensRegistered",
        type: "event"
      },
      {
        inputs: [],
        name: "WETH",
        outputs: [
          {
            internalType: "contract IWETH",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "assetInIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "assetOutIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.BatchSwapStep[]",
            name: "swaps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          },
          {
            internalType: "int256[]",
            name: "limits",
            type: "int256[]"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        name: "batchSwap",
        outputs: [
          {
            internalType: "int256[]",
            name: "",
            type: "int256[]"
          }
        ],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          }
        ],
        name: "deregisterTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address payable",
            name: "recipient",
            type: "address"
          },
          {
            components: [
              {
                internalType: "contract IAsset[]",
                name: "assets",
                type: "address[]"
              },
              {
                internalType: "uint256[]",
                name: "minAmountsOut",
                type: "uint256[]"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.ExitPoolRequest",
            name: "request",
            type: "tuple"
          }
        ],
        name: "exitPool",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          }
        ],
        name: "getPool",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          },
          {
            internalType: "enum IVault.PoolSpecialization",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          }
        ],
        name: "getPoolTokenInfo",
        outputs: [
          {
            internalType: "uint256",
            name: "cash",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "managed",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "assetManager",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          }
        ],
        name: "getPoolTokens",
        outputs: [
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            components: [
              {
                internalType: "contract IAsset[]",
                name: "assets",
                type: "address[]"
              },
              {
                internalType: "uint256[]",
                name: "maxAmountsIn",
                type: "uint256[]"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.JoinPoolRequest",
            name: "request",
            type: "tuple"
          }
        ],
        name: "joinPool",
        outputs: [],
        stateMutability: "payable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.PoolBalanceOpKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "contract IERC20",
                name: "token",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              }
            ],
            internalType: "struct IVault.PoolBalanceOp[]",
            name: "ops",
            type: "tuple[]"
          }
        ],
        name: "managePoolBalance",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IVault.SwapKind",
            name: "kind",
            type: "uint8"
          },
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "assetInIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "assetOutIndex",
                type: "uint256"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.BatchSwapStep[]",
            name: "swaps",
            type: "tuple[]"
          },
          {
            internalType: "contract IAsset[]",
            name: "assets",
            type: "address[]"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          }
        ],
        name: "queryBatchSwap",
        outputs: [
          {
            internalType: "int256[]",
            name: "assetDeltas",
            type: "int256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "enum IVault.PoolSpecialization",
            name: "specialization",
            type: "uint8"
          }
        ],
        name: "registerPool",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          }
        ],
        name: "registerTokens",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IAsset",
                name: "assetIn",
                type: "address"
              },
              {
                internalType: "contract IAsset",
                name: "assetOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IVault.SingleSwap",
            name: "singleSwap",
            type: "tuple"
          },
          {
            components: [
              {
                internalType: "address",
                name: "sender",
                type: "address"
              },
              {
                internalType: "bool",
                name: "fromInternalBalance",
                type: "bool"
              },
              {
                internalType: "address payable",
                name: "recipient",
                type: "address"
              },
              {
                internalType: "bool",
                name: "toInternalBalance",
                type: "bool"
              }
            ],
            internalType: "struct IVault.FundManagement",
            name: "funds",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "limit",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          }
        ],
        name: "swap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "payable",
        type: "function"
      }
    ]
  },
  VestingVault: {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [],
        name: "InvalidPendingOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByOwner",
        type: "error"
      },
      {
        inputs: [],
        name: "OnlyCallableByPendingOwner",
        type: "error"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newOwner",
            type: "address"
          }
        ],
        name: "NewOwner",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "previousPendingOwner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "newPendingOwner",
            type: "address"
          }
        ],
        name: "NewPendingOwner",
        type: "event"
      },
      {
        inputs: [],
        name: "acceptOwnership",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "claim",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "vestingDuration",
            type: "uint256"
          }
        ],
        name: "depositFor",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "owner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "pendingOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "pendingOwner_",
            type: "address"
          }
        ],
        name: "setPendingOwner",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "token",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "unvestedFor",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          }
        ],
        name: "vestedFor",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      }
    ]
  },
  "kGuilder Pool": {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "contract IVault",
            name: "vault",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "amplificationParameter",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pauseWindowDuration",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodDuration",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "startValue",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "endValue",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "startTime",
            type: "uint256"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          }
        ],
        name: "AmpUpdateStarted",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "currentValue",
            type: "uint256"
          }
        ],
        name: "AmpUpdateStopped",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "PausedStateChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "SwapFeePercentageChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "selector",
            type: "bytes4"
          }
        ],
        name: "getActionId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAmplificationParameter",
        outputs: [
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isUpdating",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "precision",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAuthorizer",
        outputs: [
          {
            internalType: "contract IAuthorizer",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getLastInvariant",
        outputs: [
          {
            internalType: "uint256",
            name: "lastInvariant",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "lastInvariantAmp",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPausedState",
        outputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "pauseWindowEndTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodEndTime",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPoolId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getRate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getScalingFactors",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getSwapFeePercentage",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVault",
        outputs: [
          {
            internalType: "contract IVault",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "addedValue",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onExitPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onJoinPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IERC20",
                name: "tokenIn",
                type: "address"
              },
              {
                internalType: "contract IERC20",
                name: "tokenOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "lastChangeBlock",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "from",
                type: "address"
              },
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IPoolSwapStructs.SwapRequest",
            name: "swapRequest",
            type: "tuple"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "indexIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "indexOut",
            type: "uint256"
          }
        ],
        name: "onSwap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IERC20",
                name: "tokenIn",
                type: "address"
              },
              {
                internalType: "contract IERC20",
                name: "tokenOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "lastChangeBlock",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "from",
                type: "address"
              },
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IPoolSwapStructs.SwapRequest",
            name: "request",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "balanceTokenIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "balanceTokenOut",
            type: "uint256"
          }
        ],
        name: "onSwap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryExit",
        outputs: [
          {
            internalType: "uint256",
            name: "bptIn",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsOut",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryJoin",
        outputs: [
          {
            internalType: "uint256",
            name: "bptOut",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsIn",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "poolConfig",
            type: "bytes"
          }
        ],
        name: "setAssetManagerPoolConfig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "setPaused",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "setSwapFeePercentage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "rawEndValue",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "endTime",
            type: "uint256"
          }
        ],
        name: "startAmplificationParameterUpdate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "stopAmplificationParameterUpdate",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  "kCur Pool": {
    address: "0x0000000000000000000000000000000000000000",
    abi: [
      {
        inputs: [
          {
            internalType: "contract IVault",
            name: "vault",
            type: "address"
          },
          {
            internalType: "string",
            name: "name",
            type: "string"
          },
          {
            internalType: "string",
            name: "symbol",
            type: "string"
          },
          {
            internalType: "contract IERC20[]",
            name: "tokens",
            type: "address[]"
          },
          {
            internalType: "uint256[]",
            name: "normalizedWeights",
            type: "uint256[]"
          },
          {
            internalType: "address[]",
            name: "assetManagers",
            type: "address[]"
          },
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "pauseWindowDuration",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodDuration",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        stateMutability: "nonpayable",
        type: "constructor"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Approval",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "PausedStateChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !1,
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "SwapFeePercentageChanged",
        type: "event"
      },
      {
        anonymous: !1,
        inputs: [
          {
            indexed: !0,
            internalType: "address",
            name: "from",
            type: "address"
          },
          {
            indexed: !0,
            internalType: "address",
            name: "to",
            type: "address"
          },
          {
            indexed: !1,
            internalType: "uint256",
            name: "value",
            type: "uint256"
          }
        ],
        name: "Transfer",
        type: "event"
      },
      {
        inputs: [],
        name: "DOMAIN_SEPARATOR",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          }
        ],
        name: "allowance",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            internalType: "uint8",
            name: "",
            type: "uint8"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes4",
            name: "selector",
            type: "bytes4"
          }
        ],
        name: "getActionId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getAuthorizer",
        outputs: [
          {
            internalType: "contract IAuthorizer",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getInvariant",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getLastInvariant",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getNormalizedWeights",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getOwner",
        outputs: [
          {
            internalType: "address",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPausedState",
        outputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          },
          {
            internalType: "uint256",
            name: "pauseWindowEndTime",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "bufferPeriodEndTime",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getPoolId",
        outputs: [
          {
            internalType: "bytes32",
            name: "",
            type: "bytes32"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getRate",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getScalingFactors",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getSwapFeePercentage",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getVault",
        outputs: [
          {
            internalType: "contract IVault",
            name: "",
            type: "address"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "addedValue",
            type: "uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          }
        ],
        name: "nonces",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onExitPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "onJoinPool",
        outputs: [
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          },
          {
            internalType: "uint256[]",
            name: "",
            type: "uint256[]"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            components: [
              {
                internalType: "enum IVault.SwapKind",
                name: "kind",
                type: "uint8"
              },
              {
                internalType: "contract IERC20",
                name: "tokenIn",
                type: "address"
              },
              {
                internalType: "contract IERC20",
                name: "tokenOut",
                type: "address"
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256"
              },
              {
                internalType: "bytes32",
                name: "poolId",
                type: "bytes32"
              },
              {
                internalType: "uint256",
                name: "lastChangeBlock",
                type: "uint256"
              },
              {
                internalType: "address",
                name: "from",
                type: "address"
              },
              {
                internalType: "address",
                name: "to",
                type: "address"
              },
              {
                internalType: "bytes",
                name: "userData",
                type: "bytes"
              }
            ],
            internalType: "struct IPoolSwapStructs.SwapRequest",
            name: "request",
            type: "tuple"
          },
          {
            internalType: "uint256",
            name: "balanceTokenIn",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "balanceTokenOut",
            type: "uint256"
          }
        ],
        name: "onSwap",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "owner",
            type: "address"
          },
          {
            internalType: "address",
            name: "spender",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "value",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "deadline",
            type: "uint256"
          },
          {
            internalType: "uint8",
            name: "v",
            type: "uint8"
          },
          {
            internalType: "bytes32",
            name: "r",
            type: "bytes32"
          },
          {
            internalType: "bytes32",
            name: "s",
            type: "bytes32"
          }
        ],
        name: "permit",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryExit",
        outputs: [
          {
            internalType: "uint256",
            name: "bptIn",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsOut",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bytes32",
            name: "poolId",
            type: "bytes32"
          },
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256[]",
            name: "balances",
            type: "uint256[]"
          },
          {
            internalType: "uint256",
            name: "lastChangeBlock",
            type: "uint256"
          },
          {
            internalType: "uint256",
            name: "protocolSwapFeePercentage",
            type: "uint256"
          },
          {
            internalType: "bytes",
            name: "userData",
            type: "bytes"
          }
        ],
        name: "queryJoin",
        outputs: [
          {
            internalType: "uint256",
            name: "bptOut",
            type: "uint256"
          },
          {
            internalType: "uint256[]",
            name: "amountsIn",
            type: "uint256[]"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "contract IERC20",
            name: "token",
            type: "address"
          },
          {
            internalType: "bytes",
            name: "poolConfig",
            type: "bytes"
          }
        ],
        name: "setAssetManagerPoolConfig",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "bool",
            name: "paused",
            type: "bool"
          }
        ],
        name: "setPaused",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "swapFeePercentage",
            type: "uint256"
          }
        ],
        name: "setSwapFeePercentage",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "sender",
            type: "address"
          },
          {
            internalType: "address",
            name: "recipient",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool"
          }
        ],
        stateMutability: "nonpayable",
        type: "function"
      }
    ]
  },
  cUSD: {
    address: "0x765DE816845861e75A25fCA122bb6898B8B1282a",
    abi: "ERC20"
  }
}, wN = {
  name: kw,
  chainId: Pw,
  contracts: Iw
}, AN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  chainId: Pw,
  contracts: Iw,
  default: wN,
  name: kw
}, Symbol.toStringTag, { value: "Module" })), Ow = [
  {
    inputs: [
      {
        internalType: "string",
        name: "_baseUri",
        type: "string"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "TransferDisabled",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "TokenUriUpdated",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: !1,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "string",
        name: "value",
        type: "string"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      }
    ],
    name: "balanceOfBatch",
    outputs: [
      {
        internalType: "uint256[]",
        name: "",
        type: "uint256[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "burn",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      }
    ],
    name: "burnFromMultiple",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "mint",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address[]",
        name: "accounts",
        type: "address[]"
      },
      {
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      }
    ],
    name: "mintToMultiple",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "baseUri",
        type: "string"
      }
    ],
    name: "setBaseUri",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "string",
        name: "newUri",
        type: "string"
      }
    ],
    name: "setUri",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "tokenUris",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
], Bw = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      },
      {
        internalType: "address",
        name: "_target",
        type: "address"
      },
      {
        internalType: "address",
        name: "_badger",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [],
    name: "ArraysDifferentLength",
    type: "error"
  },
  {
    inputs: [],
    name: "ModuleTransactionFailed",
    type: "error"
  },
  {
    inputs: [],
    name: "NoMembership",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guard_",
        type: "address"
      }
    ],
    name: "NotIERC165Compliant",
    type: "error"
  },
  {
    inputs: [],
    name: "RedundantUpdateOfState",
    type: "error"
  },
  {
    inputs: [],
    name: "SetUpModulesAlreadyCalled",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousAvatar",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newAvatar",
        type: "address"
      }
    ],
    name: "AvatarSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "badgerAddress",
        type: "address"
      }
    ],
    name: "BadgerUpdated",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "guard",
        type: "address"
      }
    ],
    name: "ChangedGuard",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "avatar",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "RolesModSetup",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "multisendAddress",
        type: "address"
      }
    ],
    name: "SetMultisendAddress",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousTarget",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newTarget",
        type: "address"
      }
    ],
    name: "TargetSet",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "allowTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "avatar",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "badger",
    outputs: [
      {
        internalType: "contract IBadger",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      }
    ],
    name: "execTransactionFromModule",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      }
    ],
    name: "execTransactionFromModuleReturnData",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getGuard",
    outputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "guard",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "multisend",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      }
    ],
    name: "revokeTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "scopeAllowFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "bool[]",
        name: "isParamScoped",
        type: "bool[]"
      },
      {
        internalType: "enum ParameterType[]",
        name: "paramType",
        type: "uint8[]"
      },
      {
        internalType: "enum Comparison[]",
        name: "paramComp",
        type: "uint8[]"
      },
      {
        internalType: "bytes[]",
        name: "compValue",
        type: "bytes[]"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "scopeFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "enum ExecutionOptions",
        name: "options",
        type: "uint8"
      }
    ],
    name: "scopeFunctionExecutionOptions",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "uint256",
        name: "paramIndex",
        type: "uint256"
      },
      {
        internalType: "enum ParameterType",
        name: "paramType",
        type: "uint8"
      },
      {
        internalType: "enum Comparison",
        name: "paramComp",
        type: "uint8"
      },
      {
        internalType: "bytes",
        name: "compValue",
        type: "bytes"
      }
    ],
    name: "scopeParameter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "uint256",
        name: "paramIndex",
        type: "uint256"
      },
      {
        internalType: "enum ParameterType",
        name: "paramType",
        type: "uint8"
      },
      {
        internalType: "bytes[]",
        name: "compValues",
        type: "bytes[]"
      }
    ],
    name: "scopeParameterAsOneOf",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      }
    ],
    name: "scopeRevokeFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      }
    ],
    name: "scopeTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      }
    ],
    name: "setAvatar",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    name: "setGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_multisend",
        type: "address"
      }
    ],
    name: "setMultisend",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_target",
        type: "address"
      }
    ],
    name: "setTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initParams",
        type: "bytes"
      }
    ],
    name: "setUp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "target",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "badgeId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "targetAddress",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "uint8",
        name: "paramIndex",
        type: "uint8"
      }
    ],
    name: "unscopeParameter",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_newBadger",
        type: "address"
      }
    ],
    name: "updateBadger",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], Nw = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "ScopeGuardSetup",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetDelegateCallAllowedOnTarget",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetFallbackAllowedOnTarget",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetFunctionAllowedOnTarget",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetTargetAllowed",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "scoped",
        type: "bool"
      }
    ],
    name: "SetTargetScoped",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "allowed",
        type: "bool"
      }
    ],
    name: "SetValueAllowedOnTarget",
    type: "event"
  },
  {
    stateMutability: "nonpayable",
    type: "fallback"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "allowedTargets",
    outputs: [
      {
        internalType: "bool",
        name: "allowed",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "scoped",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "delegateCallAllowed",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "fallbackAllowed",
        type: "bool"
      },
      {
        internalType: "bool",
        name: "valueAllowed",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      },
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    name: "checkAfterExecution",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address payable",
        name: "",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "checkTransaction",
    outputs: [],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      }
    ],
    name: "isAllowedFunction",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isAllowedTarget",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isAllowedToDelegateCall",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isScoped",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isValueAllowed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "isfallbackAllowed",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bytes4",
        name: "functionSig",
        type: "bytes4"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setAllowedFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setDelegateCallAllowedOnTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setFallbackAllowedOnTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "scoped",
        type: "bool"
      }
    ],
    name: "setScoped",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setTargetAllowed",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initializeParams",
        type: "bytes"
      }
    ],
    name: "setUp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        internalType: "bool",
        name: "allow",
        type: "bool"
      }
    ],
    name: "setValueAllowedOnTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], Dw = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      },
      {
        internalType: "address",
        name: "_target",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_cooldown",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_expiration",
        type: "uint256"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "AlreadyDisabledModule",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "AlreadyEnabledModule",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "InvalidModule",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "sender",
        type: "address"
      }
    ],
    name: "NotAuthorized",
    type: "error"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "guard_",
        type: "address"
      }
    ],
    name: "NotIERC165Compliant",
    type: "error"
  },
  {
    inputs: [],
    name: "RedundantUpdateOfState",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousAvatar",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newAvatar",
        type: "address"
      }
    ],
    name: "AvatarSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "guard",
        type: "address"
      }
    ],
    name: "ChangedGuard",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "initiator",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "avatar",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "target",
        type: "address"
      }
    ],
    name: "DelaySetup",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "DisabledModule",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "EnabledModule",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "ExecutionFromModuleFailure",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "ExecutionFromModuleSuccess",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "uint8",
        name: "version",
        type: "uint8"
      }
    ],
    name: "Initialized",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "queueIndex",
        type: "uint256"
      },
      {
        indexed: !0,
        internalType: "bytes32",
        name: "txHash",
        type: "bytes32"
      },
      {
        indexed: !1,
        internalType: "string",
        name: "uri",
        type: "string"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "salt",
        type: "uint256"
      }
    ],
    name: "SecretTransactionAdded",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        indexed: !1,
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "_salt",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "txIndex",
        type: "uint256"
      }
    ],
    name: "SecretTransactionExecuted",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "previousTarget",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "newTarget",
        type: "address"
      }
    ],
    name: "TargetSet",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "queueIndex",
        type: "uint256"
      },
      {
        indexed: !0,
        internalType: "bytes32",
        name: "txHash",
        type: "bytes32"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        indexed: !1,
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "TransactionAdded",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        indexed: !1,
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "txIndex",
        type: "uint256"
      }
    ],
    name: "TransactionExecuted",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "startingApprovedTrxNonce",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "numberOfTrxApproved",
        type: "uint256"
      }
    ],
    name: "TransactionsApproved",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "uint256",
        name: "startingVetoedTrxNonce",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "numberOfTrxVetoed",
        type: "uint256"
      }
    ],
    name: "TransactionsVetoed",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_transactions",
        type: "uint256"
      }
    ],
    name: "approveNext",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "approved",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "avatar",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "prevModule",
        type: "address"
      },
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "disableModule",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "module",
        type: "address"
      }
    ],
    name: "enableModule",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "hashedTransaction",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "uri",
        type: "string"
      }
    ],
    name: "enqueueSecretTx",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "execTransactionFromModule",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "execTransactionFromModuleReturnData",
    outputs: [
      {
        internalType: "bool",
        name: "success",
        type: "bool"
      },
      {
        internalType: "bytes",
        name: "returnData",
        type: "bytes"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "_salt",
        type: "uint256"
      }
    ],
    name: "executeNextSecretTx",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "executeNextTx",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getGuard",
    outputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "start",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "pageSize",
        type: "uint256"
      }
    ],
    name: "getModulesPaginated",
    outputs: [
      {
        internalType: "address[]",
        name: "array",
        type: "address[]"
      },
      {
        internalType: "address",
        name: "next",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      },
      {
        internalType: "uint256",
        name: "_salt",
        type: "uint256"
      }
    ],
    name: "getSecretTransactionHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      },
      {
        internalType: "enum Enum.Operation",
        name: "operation",
        type: "uint8"
      }
    ],
    name: "getTransactionHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_nonce",
        type: "uint256"
      }
    ],
    name: "getTxCreatedAt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_nonce",
        type: "uint256"
      }
    ],
    name: "getTxHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "guard",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_module",
        type: "address"
      }
    ],
    name: "isModuleEnabled",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "queuePointer",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "salt",
    outputs: [
      {
        internalType: "uint256",
        name: "_value",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_avatar",
        type: "address"
      }
    ],
    name: "setAvatar",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_guard",
        type: "address"
      }
    ],
    name: "setGuard",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "_target",
        type: "address"
      }
    ],
    name: "setTarget",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "cooldown",
        type: "uint256"
      }
    ],
    name: "setTxCooldown",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "expiration",
        type: "uint256"
      }
    ],
    name: "setTxExpiration",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes",
        name: "initParams",
        type: "bytes"
      }
    ],
    name: "setUp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "skipExpired",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "target",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "txCooldown",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "txCreatedAt",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "txExpiration",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "txHash",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "txNonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_newTxNonce",
        type: "uint256"
      }
    ],
    name: "vetoTransactionsTill",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "_newTxNonce",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "_transactions",
        type: "uint256"
      }
    ],
    name: "vetoTransactionsTillAndApprove",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], EN = {
  Badger: Ow,
  BACRoles: Bw,
  ScopeGuard: Nw,
  SecretDelay: Dw
}, SN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BACRoles: Bw,
  Badger: Ow,
  ScopeGuard: Nw,
  SecretDelay: Dw,
  default: EN
}, Symbol.toStringTag, { value: "Module" })), MN = {}, CN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: MN
}, Symbol.toStringTag, { value: "Module" })), $w = [
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
], Fw = [
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    name: "getApproved",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "ownerOf",
    outputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceId",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "tokenURI",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], _N = {
  ERC20: $w,
  ERC721: Fw
}, RN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ERC20: $w,
  ERC721: Fw,
  default: _N
}, Symbol.toStringTag, { value: "Module" }));
var kN = Lw, Vv = 128, PN = 127, IN = ~PN, ON = Math.pow(2, 31);
function Lw(n, e, t) {
  e = e || [], t = t || 0;
  for (var i = t; n >= ON; )
    e[t++] = n & 255 | Vv, n /= 128;
  for (; n & IN; )
    e[t++] = n & 255 | Vv, n >>>= 7;
  return e[t] = n | 0, Lw.bytes = t - i + 1, e;
}
var BN = Zy, NN = 128, jv = 127;
function Zy(n, i) {
  var t = 0, i = i || 0, r = 0, s = i, a, o = n.length;
  do {
    if (s >= o)
      throw Zy.bytes = 0, new RangeError("Could not decode varint");
    a = n[s++], t += r < 28 ? (a & jv) << r : (a & jv) * Math.pow(2, r), r += 7;
  } while (a >= NN);
  return Zy.bytes = s - i, t;
}
var DN = Math.pow(2, 7), $N = Math.pow(2, 14), FN = Math.pow(2, 21), LN = Math.pow(2, 28), UN = Math.pow(2, 35), VN = Math.pow(2, 42), jN = Math.pow(2, 49), zN = Math.pow(2, 56), GN = Math.pow(2, 63), qN = function(n) {
  return n < DN ? 1 : n < $N ? 2 : n < FN ? 3 : n < LN ? 4 : n < UN ? 5 : n < VN ? 6 : n < jN ? 7 : n < zN ? 8 : n < GN ? 9 : 10;
}, HN = {
  encode: kN,
  decode: BN,
  encodingLength: qN
}, jd = HN;
const eh = (n, e = 0) => [jd.decode(n, e), jd.decode.bytes], zd = (n, e, t = 0) => (jd.encode(n, e, t), e), Gd = (n) => jd.encodingLength(n), KN = (n, e) => {
  if (n === e)
    return !0;
  if (n.byteLength !== e.byteLength)
    return !1;
  for (let t = 0; t < n.byteLength; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}, dm = (n) => {
  if (n instanceof Uint8Array && n.constructor.name === "Uint8Array")
    return n;
  if (n instanceof ArrayBuffer)
    return new Uint8Array(n);
  if (ArrayBuffer.isView(n))
    return new Uint8Array(n.buffer, n.byteOffset, n.byteLength);
  throw new Error("Unknown type, must be binary type");
}, WN = (n) => new TextEncoder().encode(n), JN = (n) => new TextDecoder().decode(n), QN = (n, e) => {
  const t = e.byteLength, i = Gd(n), r = i + Gd(t), s = new Uint8Array(r + t);
  return zd(n, s, 0), zd(t, s, i), s.set(e, r), new pm(n, t, e, s);
}, YN = (n) => {
  const e = dm(n), [t, i] = eh(e), [r, s] = eh(e.subarray(i)), a = e.subarray(i + s);
  if (a.byteLength !== r)
    throw new Error("Incorrect length");
  return new pm(t, r, a, e);
}, XN = (n, e) => {
  if (n === e)
    return !0;
  {
    const t = (
      /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */
      e
    );
    return n.code === t.code && n.size === t.size && t.bytes instanceof Uint8Array && KN(n.bytes, t.bytes);
  }
};
class pm {
  /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */
  constructor(e, t, i, r) {
    this.code = e, this.size = t, this.digest = i, this.bytes = r;
  }
}
function ZN(n, e) {
  if (n.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), i = 0; i < t.length; i++)
    t[i] = 255;
  for (var r = 0; r < n.length; r++) {
    var s = n.charAt(r), a = s.charCodeAt(0);
    if (t[a] !== 255)
      throw new TypeError(s + " is ambiguous");
    t[a] = r;
  }
  var o = n.length, u = n.charAt(0), l = Math.log(o) / Math.log(256), p = Math.log(256) / Math.log(o);
  function f(x) {
    if (x instanceof Uint8Array || (ArrayBuffer.isView(x) ? x = new Uint8Array(x.buffer, x.byteOffset, x.byteLength) : Array.isArray(x) && (x = Uint8Array.from(x))), !(x instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (x.length === 0)
      return "";
    for (var w = 0, T = 0, _ = 0, I = x.length; _ !== I && x[_] === 0; )
      _++, w++;
    for (var $ = (I - _) * p + 1 >>> 0, N = new Uint8Array($); _ !== I; ) {
      for (var B = x[_], V = 0, K = $ - 1; (B !== 0 || V < T) && K !== -1; K--, V++)
        B += 256 * N[K] >>> 0, N[K] = B % o >>> 0, B = B / o >>> 0;
      if (B !== 0)
        throw new Error("Non-zero carry");
      T = V, _++;
    }
    for (var G = $ - T; G !== $ && N[G] === 0; )
      G++;
    for (var Y = u.repeat(w); G < $; ++G)
      Y += n.charAt(N[G]);
    return Y;
  }
  function b(x) {
    if (typeof x != "string")
      throw new TypeError("Expected String");
    if (x.length === 0)
      return new Uint8Array();
    var w = 0;
    if (x[w] !== " ") {
      for (var T = 0, _ = 0; x[w] === u; )
        T++, w++;
      for (var I = (x.length - w) * l + 1 >>> 0, $ = new Uint8Array(I); x[w]; ) {
        var N = t[x.charCodeAt(w)];
        if (N === 255)
          return;
        for (var B = 0, V = I - 1; (N !== 0 || B < _) && V !== -1; V--, B++)
          N += o * $[V] >>> 0, $[V] = N % 256 >>> 0, N = N / 256 >>> 0;
        if (N !== 0)
          throw new Error("Non-zero carry");
        _ = B, w++;
      }
      if (x[w] !== " ") {
        for (var K = I - _; K !== I && $[K] === 0; )
          K++;
        for (var G = new Uint8Array(T + (I - K)), Y = T; K !== I; )
          G[Y++] = $[K++];
        return G;
      }
    }
  }
  function A(x) {
    var w = b(x);
    if (w)
      return w;
    throw new Error(`Non-${e} character`);
  }
  return {
    encode: f,
    decodeUnsafe: b,
    decode: A
  };
}
var eD = ZN, tD = eD;
class nD {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */
  constructor(e, t, i) {
    this.name = e, this.prefix = t, this.baseEncode = i;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */
  encode(e) {
    if (e instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(e)}`;
    throw Error("Unknown type, must be binary type");
  }
}
class iD {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, t, i) {
    if (this.name = e, this.prefix = t, t.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = /** @type {number} */
    t.codePointAt(0), this.baseDecode = i;
  }
  /**
   * @param {string} text
   */
  decode(e) {
    if (typeof e == "string") {
      if (e.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(e.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return Uw(this, e);
  }
}
class rD {
  /**
   * @param {Decoders<Prefix>} decoders
   */
  constructor(e) {
    this.decoders = e;
  }
  /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */
  or(e) {
    return Uw(this, e);
  }
  /**
   * @param {string} input
   * @returns {Uint8Array}
   */
  decode(e) {
    const t = (
      /** @type {Prefix} */
      e[0]
    ), i = this.decoders[t];
    if (i)
      return i.decode(e);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
}
const Uw = (n, e) => new rD(
  /** @type {Decoders<L|R>} */
  {
    ...n.decoders || { [
      /** @type API.UnibaseDecoder<L> */
      n.prefix
    ]: n },
    ...e.decoders || { [
      /** @type API.UnibaseDecoder<R> */
      e.prefix
    ]: e }
  }
);
class sD {
  /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */
  constructor(e, t, i, r) {
    this.name = e, this.prefix = t, this.baseEncode = i, this.baseDecode = r, this.encoder = new nD(e, t, i), this.decoder = new iD(e, t, r);
  }
  /**
   * @param {Uint8Array} input
   */
  encode(e) {
    return this.encoder.encode(e);
  }
  /**
   * @param {string} input
   */
  decode(e) {
    return this.decoder.decode(e);
  }
}
const Ip = ({ name: n, prefix: e, encode: t, decode: i }) => new sD(n, e, t, i), Ql = ({ prefix: n, name: e, alphabet: t }) => {
  const { encode: i, decode: r } = tD(t, e);
  return Ip({
    prefix: n,
    name: e,
    encode: i,
    /**
     * @param {string} text
     */
    decode: (s) => dm(r(s))
  });
}, aD = (n, e, t, i) => {
  const r = {};
  for (let p = 0; p < e.length; ++p)
    r[e[p]] = p;
  let s = n.length;
  for (; n[s - 1] === "="; )
    --s;
  const a = new Uint8Array(s * t / 8 | 0);
  let o = 0, u = 0, l = 0;
  for (let p = 0; p < s; ++p) {
    const f = r[n[p]];
    if (f === void 0)
      throw new SyntaxError(`Non-${i} character`);
    u = u << t | f, o += t, o >= 8 && (o -= 8, a[l++] = 255 & u >> o);
  }
  if (o >= t || 255 & u << 8 - o)
    throw new SyntaxError("Unexpected end of data");
  return a;
}, oD = (n, e, t) => {
  const i = e[e.length - 1] === "=", r = (1 << t) - 1;
  let s = "", a = 0, o = 0;
  for (let u = 0; u < n.length; ++u)
    for (o = o << 8 | n[u], a += 8; a > t; )
      a -= t, s += e[r & o >> a];
  if (a && (s += e[r & o << t - a]), i)
    for (; s.length * t & 7; )
      s += "=";
  return s;
}, dn = ({ name: n, prefix: e, bitsPerChar: t, alphabet: i }) => Ip({
  prefix: e,
  name: n,
  encode(r) {
    return oD(r, i, t);
  },
  decode(r) {
    return aD(r, i, t, n);
  }
}), wr = Ql({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), uD = Ql({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), lD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc: wr,
  base58flickr: uD
}, Symbol.toStringTag, { value: "Module" })), Vu = dn({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), cD = dn({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), dD = dn({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), pD = dn({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), fD = dn({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), yD = dn({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), hD = dn({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), mD = dn({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), bD = dn({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), gD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32: Vu,
  base32hex: fD,
  base32hexpad: hD,
  base32hexpadupper: mD,
  base32hexupper: yD,
  base32pad: dD,
  base32padupper: pD,
  base32upper: cD,
  base32z: bD
}, Symbol.toStringTag, { value: "Module" })), qd = (n, e) => {
  const { bytes: t, version: i } = n;
  switch (i) {
    case 0:
      return wD(
        t,
        th(n),
        /** @type {API.MultibaseEncoder<"z">} */
        e || wr.encoder
      );
    default:
      return AD(
        t,
        th(n),
        /** @type {API.MultibaseEncoder<Prefix>} */
        e || Vu.encoder
      );
  }
}, vD = (n) => ({
  "/": qd(n)
}), xD = (n) => Qt.parse(n["/"]), zv = /* @__PURE__ */ new WeakMap(), th = (n) => {
  const e = zv.get(n);
  if (e == null) {
    const t = /* @__PURE__ */ new Map();
    return zv.set(n, t), t;
  }
  return e;
};
class Qt {
  /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */
  constructor(e, t, i, r) {
    this.code = t, this.version = e, this.multihash = i, this.bytes = r, this["/"] = r;
  }
  /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */
  get asCID() {
    return this;
  }
  // ArrayBufferView
  get byteOffset() {
    return this.bytes.byteOffset;
  }
  // ArrayBufferView
  get byteLength() {
    return this.bytes.byteLength;
  }
  /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */
  toV0() {
    switch (this.version) {
      case 0:
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          this
        );
      case 1: {
        const { code: e, multihash: t } = this;
        if (e !== mu)
          throw new Error("Cannot convert a non dag-pb CID to CIDv0");
        if (t.code !== ED)
          throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
        return (
          /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */
          Qt.createV0(
            /** @type {API.MultihashDigest<API.SHA_256>} */
            t
          )
        );
      }
      default:
        throw Error(
          `Can not convert CID version ${this.version} to version 0. This is a bug please report`
        );
    }
  }
  /**
   * @returns {CID<Data, Format, Alg, 1>}
   */
  toV1() {
    switch (this.version) {
      case 0: {
        const { code: e, digest: t } = this.multihash, i = QN(e, t);
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          Qt.createV1(this.code, i)
        );
      }
      case 1:
        return (
          /** @type {CID<Data, Format, Alg, 1>} */
          this
        );
      default:
        throw Error(
          `Can not convert CID version ${this.version} to version 1. This is a bug please report`
        );
    }
  }
  /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */
  equals(e) {
    return Qt.equals(this, e);
  }
  /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */
  static equals(e, t) {
    const i = (
      /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */
      t
    );
    return i && e.code === i.code && e.version === i.version && XN(e.multihash, i.multihash);
  }
  /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */
  toString(e) {
    return qd(this, e);
  }
  toJSON() {
    return { "/": qd(this) };
  }
  link() {
    return this;
  }
  get [Symbol.toStringTag]() {
    return "CID";
  }
  // Legacy
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `CID(${this.toString()})`;
  }
  /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */
  static asCID(e) {
    if (e == null)
      return null;
    const t = (
      /** @type {any} */
      e
    );
    if (t instanceof Qt)
      return t;
    if (t["/"] != null && t["/"] === t.bytes || t.asCID === t) {
      const { version: i, code: r, multihash: s, bytes: a } = t;
      return new Qt(
        i,
        r,
        /** @type {API.MultihashDigest<Alg>} */
        s,
        a || Gv(i, r, s.bytes)
      );
    } else if (t[SD] === !0) {
      const { version: i, multihash: r, code: s } = t, a = (
        /** @type {API.MultihashDigest<Alg>} */
        YN(r)
      );
      return Qt.create(i, s, a);
    } else
      return null;
  }
  /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */
  static create(e, t, i) {
    if (typeof t != "number")
      throw new Error("String codecs are no longer supported");
    if (!(i.bytes instanceof Uint8Array))
      throw new Error("Invalid digest");
    switch (e) {
      case 0: {
        if (t !== mu)
          throw new Error(
            `Version 0 CID must use dag-pb (code: ${mu}) block encoding`
          );
        return new Qt(e, t, i, i.bytes);
      }
      case 1: {
        const r = Gv(e, t, i.bytes);
        return new Qt(e, t, i, r);
      }
      default:
        throw new Error("Invalid version");
    }
  }
  /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */
  static createV0(e) {
    return Qt.create(0, mu, e);
  }
  /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */
  static createV1(e, t) {
    return Qt.create(1, e, t);
  }
  /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static decode(e) {
    const [t, i] = Qt.decodeFirst(e);
    if (i.length)
      throw new Error("Incorrect length");
    return t;
  }
  /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */
  static decodeFirst(e) {
    const t = Qt.inspectBytes(e), i = t.size - t.multihashSize, r = dm(
      e.subarray(i, i + t.multihashSize)
    );
    if (r.byteLength !== t.multihashSize)
      throw new Error("Incorrect length");
    const s = r.subarray(
      t.multihashSize - t.digestSize
    ), a = new pm(
      t.multihashCode,
      t.digestSize,
      s,
      r
    );
    return [t.version === 0 ? Qt.createV0(
      /** @type {API.MultihashDigest<API.SHA_256>} */
      a
    ) : Qt.createV1(t.codec, a), e.subarray(t.size)];
  }
  /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */
  static inspectBytes(e) {
    let t = 0;
    const i = () => {
      const [f, b] = eh(e.subarray(t));
      return t += b, f;
    };
    let r = (
      /** @type {V} */
      i()
    ), s = (
      /** @type {C} */
      mu
    );
    if (/** @type {number} */
    r === 18 ? (r = /** @type {V} */
    0, t = 0) : s = /** @type {C} */
    i(), r !== 0 && r !== 1)
      throw new RangeError(`Invalid CID version ${r}`);
    const a = t, o = (
      /** @type {A} */
      i()
    ), u = i(), l = t + u, p = l - a;
    return { version: r, codec: s, multihashCode: o, digestSize: u, multihashSize: p, size: l };
  }
  /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */
  static parse(e, t) {
    const [i, r] = TD(e, t), s = Qt.decode(r);
    if (s.version === 0 && e[0] !== "Q")
      throw Error("Version 0 CID string must not include multibase prefix");
    return th(s).set(i, e), s;
  }
}
const TD = (n, e) => {
  switch (n[0]) {
    case "Q": {
      const t = e || wr;
      return [
        /** @type {Prefix} */
        wr.prefix,
        t.decode(`${wr.prefix}${n}`)
      ];
    }
    case wr.prefix: {
      const t = e || wr;
      return [
        /** @type {Prefix} */
        wr.prefix,
        t.decode(n)
      ];
    }
    case Vu.prefix: {
      const t = e || Vu;
      return [
        /** @type {Prefix} */
        Vu.prefix,
        t.decode(n)
      ];
    }
    default: {
      if (e == null)
        throw Error(
          "To parse non base32 or base58btc encoded CID multibase decoder must be provided"
        );
      return [
        /** @type {Prefix} */
        n[0],
        e.decode(n)
      ];
    }
  }
}, wD = (n, e, t) => {
  const { prefix: i } = t;
  if (i !== wr.prefix)
    throw Error(`Cannot string encode V0 in ${t.name} encoding`);
  const r = e.get(i);
  if (r == null) {
    const s = t.encode(n).slice(1);
    return e.set(i, s), s;
  } else
    return r;
}, AD = (n, e, t) => {
  const { prefix: i } = t, r = e.get(i);
  if (r == null) {
    const s = t.encode(n);
    return e.set(i, s), s;
  } else
    return r;
}, mu = 112, ED = 18, Gv = (n, e, t) => {
  const i = Gd(n), r = i + Gd(e), s = new Uint8Array(r + t.byteLength);
  return zd(n, s, 0), zd(e, s, i), s.set(t, r), s;
}, SD = Symbol.for("@ipld/js-cid/CID"), MD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CID: Qt,
  format: qd,
  fromJSON: xD,
  toJSON: vD
}, Symbol.toStringTag, { value: "Module" }));
function Vw(n) {
  return globalThis.Buffer != null ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : n;
}
function jw(n = 0) {
  return globalThis.Buffer?.allocUnsafe != null ? Vw(globalThis.Buffer.allocUnsafe(n)) : new Uint8Array(n);
}
function CD(n, e) {
  e == null && (e = n.reduce((r, s) => r + s.length, 0));
  const t = jw(e);
  let i = 0;
  for (const r of n)
    t.set(r, i), i += r.length;
  return Vw(t);
}
const _D = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  concat: CD
}, Symbol.toStringTag, { value: "Module" })), RD = Ip({
  prefix: "\0",
  name: "identity",
  encode: (n) => JN(n),
  decode: (n) => WN(n)
}), kD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity: RD
}, Symbol.toStringTag, { value: "Module" })), PD = dn({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), ID = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2: PD
}, Symbol.toStringTag, { value: "Module" })), OD = dn({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), BD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8: OD
}, Symbol.toStringTag, { value: "Module" })), ND = Ql({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), DD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10: ND
}, Symbol.toStringTag, { value: "Module" })), $D = dn({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), FD = dn({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), LD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16: $D,
  base16upper: FD
}, Symbol.toStringTag, { value: "Module" })), UD = Ql({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), VD = Ql({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), jD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36: UD,
  base36upper: VD
}, Symbol.toStringTag, { value: "Module" })), zD = dn({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), GD = dn({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), qD = dn({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), HD = dn({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), KD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: zD,
  base64pad: GD,
  base64url: qD,
  base64urlpad: HD
}, Symbol.toStringTag, { value: "Module" })), zw = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), WD = (
  /** @type {string[]} */
  zw.reduce(
    (n, e, t) => (n[t] = e, n),
    /** @type {string[]} */
    []
  )
), JD = (
  /** @type {number[]} */
  zw.reduce(
    (n, e, t) => (n[
      /** @type {number} */
      e.codePointAt(0)
    ] = t, n),
    /** @type {number[]} */
    []
  )
);
function QD(n) {
  return n.reduce((e, t) => (e += WD[t], e), "");
}
function YD(n) {
  const e = [];
  for (const t of n) {
    const i = JD[
      /** @type {number} */
      t.codePointAt(0)
    ];
    if (i === void 0)
      throw new Error(`Non-base256emoji character: ${t}`);
    e.push(i);
  }
  return new Uint8Array(e);
}
const XD = Ip({
  prefix: "🚀",
  name: "base256emoji",
  encode: QD,
  decode: YD
}), ZD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji: XD
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const qv = { ...kD, ...ID, ...BD, ...DD, ...LD, ...gD, ...jD, ...lD, ...KD, ...ZD };
function Gw(n, e, t, i) {
  return {
    name: n,
    prefix: e,
    encoder: {
      name: n,
      prefix: e,
      encode: t
    },
    decoder: {
      decode: i
    }
  };
}
const Hv = Gw("utf8", "u", (n) => "u" + new TextDecoder("utf8").decode(n), (n) => new TextEncoder().encode(n.substring(1))), Gf = Gw("ascii", "a", (n) => {
  let e = "a";
  for (let t = 0; t < n.length; t++)
    e += String.fromCharCode(n[t]);
  return e;
}, (n) => {
  n = n.substring(1);
  const e = jw(n.length);
  for (let t = 0; t < n.length; t++)
    e[t] = n.charCodeAt(t);
  return e;
}), e$ = {
  utf8: Hv,
  "utf-8": Hv,
  hex: qv.base16,
  latin1: Gf,
  ascii: Gf,
  binary: Gf,
  ...qv
};
function t$(n, e = "utf8") {
  const t = e$[e];
  if (t == null)
    throw new Error(`Unsupported encoding "${e}"`);
  return (e === "utf8" || e === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(n.buffer, n.byteOffset, n.byteLength).toString("utf8") : t.encoder.encode(n).substring(1);
}
const n$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  toString: t$
}, Symbol.toStringTag, { value: "Module" }));
export {
  fN as seed
};
